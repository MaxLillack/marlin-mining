// EXCERPT FROM MERGE  Marlin/Marlin_main.cpp

<<<<<<< HEAD
    } else if (state == 2) { // Probe the next mesh point

      if (probe_point < 0) {
        SERIAL_PROTOCOLPGM("Start mesh probing with \"G29 S1\" first.\n");
        return;
      }
      int ix, iy;
      if (probe_point == 0) {
        current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
        sync_plan_position();
      } else {
        ix = (probe_point-1) % MESH_NUM_X_POINTS;
        iy = (probe_point-1) / MESH_NUM_X_POINTS;
        if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
        mbl.set_z(ix, iy, current_position[Z_AXIS]);
        current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);
        st_synchronize();
      }
      if (probe_point == MESH_NUM_X_POINTS * MESH_NUM_Y_POINTS) {
        SERIAL_PROTOCOLPGM("Mesh probing done.\n");
        probe_point = -1;
        mbl.active = 1;
        enquecommands_P(PSTR("G28"));
        return;
      }
      ix = probe_point % MESH_NUM_X_POINTS;
      iy = probe_point / MESH_NUM_X_POINTS;
      if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
      current_position[X_AXIS] = mbl.get_x(ix);
      current_position[Y_AXIS] = mbl.get_y(iy);
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);
      st_synchronize();
      probe_point++;
    } else if (state == 3) { // Manually modify a single point
      int ix, iy;
      float z;
      if (code_seen('X') || code_seen('x')) {
        ix = code_value_long()-1;
        if (ix < 0 || ix >= MESH_NUM_X_POINTS) {
          SERIAL_PROTOCOLPGM("X out of range (1-" STRINGIFY(MESH_NUM_X_POINTS) ").\n");
          return;
        }
      } else {
          SERIAL_PROTOCOLPGM("X not entered.\n");
          return;
      }
      if (code_seen('Y') || code_seen('y')) {
        iy = code_value_long()-1;
        if (iy < 0 || iy >= MESH_NUM_Y_POINTS) {
          SERIAL_PROTOCOLPGM("Y out of range (1-" STRINGIFY(MESH_NUM_Y_POINTS) ").\n");
          return;
        }
      } else {
          SERIAL_PROTOCOLPGM("Y not entered.\n");
          return;
      }
      if (code_seen('Z') || code_seen('z')) {
        z = code_value();
      } else {
          SERIAL_PROTOCOLPGM("Z not entered.\n");
          return;
      }
      mbl.z_values[iy][ix] = z;
    }
=======
      case MeshNext:
        if (probe_point < 0) {
          SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
          return;
        }
        int ix, iy;
        if (probe_point == 0) {
          // Set Z to a positive value before recording the first Z.
          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
          sync_plan_position();
        }
        else {
          // For others, save the Z of the previous point, then raise Z again.
          ix = (probe_point - 1) % MESH_NUM_X_POINTS;
          iy = (probe_point - 1) / MESH_NUM_X_POINTS;
          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
          mbl.set_z(ix, iy, current_position[Z_AXIS]);
          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);
          st_synchronize();
        }
        // Is there another point to sample? Move there.
        if (probe_point < MESH_NUM_X_POINTS * MESH_NUM_Y_POINTS) {
          ix = probe_point % MESH_NUM_X_POINTS;
          iy = probe_point / MESH_NUM_X_POINTS;
          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
          current_position[X_AXIS] = mbl.get_x(ix);
          current_position[Y_AXIS] = mbl.get_y(iy);
          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);
          st_synchronize();
          probe_point++;
        }
        else {
          // After recording the last point, activate the mbl and home
          SERIAL_PROTOCOLLNPGM("Mesh probing done.");
          probe_point = -1;
          mbl.active = 1;
          enquecommands_P(PSTR("G28"));
        }

    } // switch(state)
>>>>>>> cb02bc6db458bde59ddbf8ef37356a3eb5c0f4a8

