commit d309565b56610b4295c7f517c6fada8d51c0ef04 (from fa2e1be0ca890cd4112dbb951b9297bb38a42f2d)
Merge: 0e3631f fa2e1be
Author: Christian Thalhammer <christian_thalhammer@gmx.at>
Date:   Mon Feb 13 13:07:55 2012 +0100

    Merge remote-tracking branch 'upstream/Marlin_v1' into Marlin_v1
    
    Conflicts:
    	Marlin/Configuration.h

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index f0d8913..cab9085 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -12,8 +12,8 @@
 #define STRING_CONFIG_H_AUTHOR "username" //Who made the changes.
 
 // This determines the communication speed of the printer
-#define BAUDRATE 250000
-//#define BAUDRATE 115200
+//#define BAUDRATE 250000
+#define BAUDRATE 115200
 
 //// The following define selects which electronics board you have. Please choose the one that matches your setup
 // MEGA/RAMPS up to 1.2 = 3,
@@ -21,9 +21,10 @@
 // Gen6 = 5,
 // Sanguinololu 1.2 and above = 62
 // Ultimaker = 7,
+// Gen7 = 77,
 // Teensylu = 8,
 // Gen3+ =9
-#define MOTHERBOARD 7
+#define MOTHERBOARD 77
 
 //===========================================================================
 //=============================Thermal Settings  ============================
@@ -41,14 +42,14 @@
 // 6 is EPCOS 100k
 // 7 is 100k Honeywell thermistor 135-104LAG-J01
 
-#define TEMP_SENSOR_0 -1
+#define TEMP_SENSOR_0 6
 #define TEMP_SENSOR_1 0
 #define TEMP_SENSOR_2 0
-#define TEMP_SENSOR_BED 0
+#define TEMP_SENSOR_BED 1
 
 // Actual temperature must be close to target for this long before M109 returns success
 #define TEMP_RESIDENCY_TIME 30  // (seconds)
-#define TEMP_HYSTERESIS 3       // (CÂ°) range of +/- temperatures considered "close" to the target one
+#define TEMP_HYSTERESIS 3       // (C°) range of +/- temperatures considered "close" to the target one
 
 // The minimal temperature defines the temperature below which the heater will not be enabled It is used
 // to check that the wiring to the thermistor is not broken. 
@@ -108,9 +109,9 @@
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
 
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool X_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
-const bool Y_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
-const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
+const bool X_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops. 
+const bool Y_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops. 
+const bool Z_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops. 
 
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 #define X_ENABLE_ON 0
@@ -124,7 +125,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define DISABLE_Z false
 #define DISABLE_E false // For all extruders
 
-#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
+#define INVERT_X_DIR false    // for Mendel set to false, for Orca set to true
 #define INVERT_Y_DIR false    // for Mendel set to true, for Orca set to false
 #define INVERT_Z_DIR true     // for Mendel set to false, for Orca set to true
 #define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
@@ -149,7 +150,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 
 // default settings 
 
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200*8/3,760*1.1}                    // default steps per unit for ultimaker 
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {80,80,2560,760*1.1}                    // default steps per unit for ultimaker 
 #define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 45}    // (mm/sec)    
 #define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
@@ -170,18 +171,18 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
 //define this to enable eeprom support
-//#define EEPROM_SETTINGS
+#define EEPROM_SETTINGS
 //to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
 // please keep turned on if you can.
-//#define EEPROM_CHITCHAT
+#define EEPROM_CHITCHAT
 
 //LCD and SD support
 //#define ULTRA_LCD  //general lcd support, also 16x2
 #define SDSUPPORT // Enable SD Card Support in Hardware Console
 
-//#define ULTIPANEL
+#define ULTIPANEL
 #ifdef ULTIPANEL
-  //#define NEWPANEL  //enable this if you have a click-encoder panel
+  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
   #define ULTRA_LCD
   #define LCD_WIDTH 20
diff --git a/Marlin/Gen7/boards.txt b/Marlin/Gen7/boards.txt
new file mode 100644
index 0000000..f8c826a
--- /dev/null
+++ b/Marlin/Gen7/boards.txt
@@ -0,0 +1,101 @@
+##############################################################
+
+Gen7-644-16.name=Gen7 with ATmega644 and 16 MHz
+Gen7-644-16.upload.protocol=stk500v2
+Gen7-644-16.upload.maximum_size=63488
+Gen7-644-16.upload.speed=115200
+Gen7-644-16.bootloader.low_fuses=0xF7
+Gen7-644-16.bootloader.high_fuses=0xDC
+Gen7-644-16.bootloader.extended_fuses=0xFC
+Gen7-644-16.bootloader.path=Gen7
+Gen7-644-16.bootloader.file=bootloader-644-16MHz.hex
+Gen7-644-16.bootloader.unlock_bits=0x3F
+Gen7-644-16.bootloader.lock_bits=0x0F
+Gen7-644-16.build.mcu=atmega644
+Gen7-644-16.build.f_cpu=16000000L
+Gen7-644-16.build.core=arduino
+
+##############################################################
+
+Gen7-644-20.name=Gen7 with ATmega644 and 20 MHz
+Gen7-644-20.upload.protocol=stk500v2
+Gen7-644-20.upload.maximum_size=63488
+Gen7-644-20.upload.speed=115200
+Gen7-644-20.bootloader.low_fuses=0xF7
+Gen7-644-20.bootloader.high_fuses=0xDC
+Gen7-644-20.bootloader.extended_fuses=0xFC
+Gen7-644-20.bootloader.path=Gen7
+Gen7-644-20.bootloader.file=bootloader-644-20MHz.hex
+Gen7-644-20.bootloader.unlock_bits=0x3F
+Gen7-644-20.bootloader.lock_bits=0x0F
+Gen7-644-20.build.mcu=atmega644
+Gen7-644-20.build.f_cpu=20000000L
+Gen7-644-20.build.core=arduino
+
+##############################################################
+
+Gen7-644P-16.name=Gen7 with ATmega644P and 16 MHz
+Gen7-644P-16.upload.protocol=stk500v2
+Gen7-644P-16.upload.maximum_size=63488
+Gen7-644P-16.upload.speed=115200
+Gen7-644P-16.bootloader.low_fuses=0xF7
+Gen7-644P-16.bootloader.high_fuses=0xDC
+Gen7-644P-16.bootloader.extended_fuses=0xFC
+Gen7-644P-16.bootloader.path=Gen7
+Gen7-644P-16.bootloader.file=bootloader-644P-16MHz.hex
+Gen7-644P-16.bootloader.unlock_bits=0x3F
+Gen7-644P-16.bootloader.lock_bits=0x0F
+Gen7-644P-16.build.mcu=atmega644p
+Gen7-644P-16.build.f_cpu=16000000L
+Gen7-644P-16.build.core=arduino
+
+##############################################################
+
+Gen7-644P-20.name=Gen7 with ATmega644P and 20 MHz
+Gen7-644P-20.upload.protocol=stk500v2
+Gen7-644P-20.upload.maximum_size=63488
+Gen7-644P-20.upload.speed=115200
+Gen7-644P-20.bootloader.low_fuses=0xF7
+Gen7-644P-20.bootloader.high_fuses=0xDC
+Gen7-644P-20.bootloader.extended_fuses=0xFC
+Gen7-644P-20.bootloader.path=Gen7
+Gen7-644P-20.bootloader.file=bootloader-644P-20MHz.hex
+Gen7-644P-20.bootloader.unlock_bits=0x3F
+Gen7-644P-20.bootloader.lock_bits=0x0F
+Gen7-644P-20.build.mcu=atmega644p
+Gen7-644P-20.build.f_cpu=20000000L
+Gen7-644P-20.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-16.name=Gen7 with ATmega1284 and 16 MHz
+Gen7-1284p-16.upload.protocol=stk500v2
+Gen7-1284p-16.upload.maximum_size=129024
+Gen7-1284p-16.upload.speed=115200
+Gen7-1284p-16.bootloader.low_fuses=0xF7
+Gen7-1284p-16.bootloader.high_fuses=0xD4
+Gen7-1284p-16.bootloader.extended_fuses=0x05
+Gen7-1284p-16.bootloader.path=Gen7
+Gen7-1284p-16.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-16.bootloader.unlock_bits=0x3F
+Gen7-1284p-16.bootloader.lock_bits=0x2F
+Gen7-1284p-16.build.mcu=atmega1284p
+Gen7-1284p-16.build.f_cpu=16000000L
+Gen7-1284p-16.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-20.name=Gen7 with ATmega1284 and 20 MHz
+Gen7-1284p-20.upload.protocol=stk500v2
+Gen7-1284p-20.upload.maximum_size=129024
+Gen7-1284p-20.upload.speed=115200
+Gen7-1284p-20.bootloader.low_fuses=0xF7
+Gen7-1284p-20.bootloader.high_fuses=0xD4
+Gen7-1284p-20.bootloader.extended_fuses=0x05
+Gen7-1284p-20.bootloader.path=Gen7
+Gen7-1284p-20.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-20.bootloader.unlock_bits=0x3F
+Gen7-1284p-20.bootloader.lock_bits=0x2F
+Gen7-1284p-20.build.mcu=atmega1284p
+Gen7-1284p-20.build.f_cpu=20000000L
+Gen7-1284p-20.build.core=arduino
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
new file mode 100644
index 0000000..93df372
--- /dev/null
+++ b/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
@@ -0,0 +1,113 @@
+:020000021000EC
+:10F8000011241FBE8FEF90E49EBF8DBF01C32F92C6
+:10F810003F924F925F926F927F928F929F92AF92A0
+:10F82000BF92CF92DF92EF92FF920F931F93DF93DD
+:10F83000CF93CDB7DEB7C252D1400FB6F894DEBF3A
+:10F840000FBECDBF44245524DD24C25EDE4F188296
+:10F85000CE51D1408824992454013AC20E9428FFF5
+:10F86000282F133059F1143028F4113081F0123060
+:10F8700000F507C0153081F1153030F1163071F701
+:10F880003DC08B3159F711E05BE1D52EE7CF8130D8
+:10F8900041F0C25EDE4F3881CE51D140831709F06E
+:10F8A00019C2D226C25EDE4F2883CE51D14012E06B
+:10F8B000D5CFF82EEE24D82613E0D0CF90E0E82A5A
+:10F8C000F92AD22614E0CACF8E3009F003C2D82616
+:10F8D00015E044245524C2CFE1E0F0E0EC0FFD1F19
+:10F8E000E40DF51D80830894411C511CD8264E144C
+:10F8F0005F0409F0B3CF720116E0B0CF8D1509F0A7
+:10F90000E9C1EAC1CC2447C08D81803311F090E079
+:10F910000AC08F81882311F49EE105C0813011F067
+:10F9200095E001C097E91A821B828D818C838E81BC
+:10F930008D839E831F8247E0E42EF12C88C11A82BA
+:10F9400068E06B8383E58C8394E59D83EBE4EE8331
+:10F9500085E38F8380E3888789878FE58A8782E3C1
+:10F960008B873BE0E32EF12C72C18A81813941F013
+:10F97000823941F0803911F48FE005C080E003C086
+:10F9800082E001C08AE01A828B8323E0E22EF12C10
+:10F990005EC1CC24C3941A8292E0E92EF12C58C1A6
+:10F9A0008D81882311F48EE128C0813011F085E02B
+:10F9B00024C087E922C01A8229E0E1E0F0E0209328
+:10F9C000570084911BC08B81803589F48C818830ED
+:10F9D00039F439E0E2E0F0E03093570084910DC053
+:10F9E00069E0E0E0F0E060935700849106C099E0A0
+:10F9F000E3E0F0E09093570084911A828B831C829D
+:10FA000084E0E82EF12C23C18A8190E0A0E0B0E0F0
+:10FA1000B82EAA24992488248B8190E0A0E0B0E03D
+:10FA2000DC0199278827882A992AAA2ABB2A8D814E
+:10FA300090E0A0E0B0E0882A992AAA2ABB2A8C810B
+:10FA400090E0A0E0B0E0BA2FA92F982F8827882A4D
+:10FA5000992AAA2ABB2A88C0EA81C05EDE4FE883C1
+:10FA6000C052D140C15EDE4F1882CF51D1408B8150
+:10FA7000A82FB0E0C15EDE4F28813981CF51D1403F
+:10FA8000A22BB32B933109F042C075016401CC0C59
+:10FA9000DD1CEE1CFF1C33E0F601E0925B003093AE
+:10FAA0005700E89507B600FCFDCF8E01055F1F4F9C
+:10FAB000F801808161810E5F1F4FA5019401220F23
+:10FAC000331F441F551F362E222490E0822993298C
+:10FAD00061E00C01F90140935B0060935700E895E9
+:10FAE00011240894811C911CA11CB11C129701F7D0
+:10FAF00085E0F601E0925B0080935700E89507B639
+:10FB000000FCFDCF81E180935700E8952DC0FE01F8
+:10FB10003B9620E030E040E050E011977D0100E0AE
+:10FB200010E00894E11CF11C011D111D6081F99980
+:10FB3000FECF1FBAC901880D991D92BD81BD60BD60
+:10FB40000FB6F894FA9AF99A0FBE2F5F3F4F4F4FB6
+:10FB50005F4F2E153F054007510711F03196E6CF54
+:10FB6000820E931EA41EB51E1A826EC09A81CE5DAF
+:10FB7000DE4F9883C252D140CF5DDE4F1882C15212
+:10FB8000D1408B81C82EDD24CF5DDE4FE881F98125
+:10FB9000C152D140CE2ADF2A1A8289818431E1F410
+:10FBA0009601BE016D5F7F4FD501C401880F991F7B
+:10FBB000AA1FBB1FABBFFC0187919691FB018083FD
+:10FBC00091836E5F7F4F0894811C911CA11CB11C16
+:10FBD0002250304049F72EC0BE016D5F7F4F20E0BC
+:10FBE00030E040E050E00894C108D108760100E020
+:10FBF00010E00894C11CD11C0894E11CF11C011DEB
+:10FC0000111DF999FECFC901880D991D92BD81BDC5
+:10FC1000F89A80B5FB018193BF012F5F3F4F4F4F93
+:10FC20005F4F2E153F054007510759F7820E931E6F
+:10FC3000A41EB51E23E0E22EF12CEC0CFD1CFB01F2
+:10FC4000108205C080EC8A8392E0E92EF12CCC244E
+:10FC50008BE10E94C7FEC25EDE4F8881CE51D1404B
+:10FC60000E94C7FE8F2D0E94C7FE8E2D0E94C7FEE8
+:10FC70008EE00E94C7FE85E1D82EC25EDE4FF8817D
+:10FC8000CE51D140DF26DE24DF243E010894611CE2
+:10FC9000711C0AC0F30111913F01812F0E94C7FE20
+:10FCA000D1260894E108F108E114F10499F78D2DAB
+:10FCB0000E94C7FECC2009F044C0C25EDE4FF8812E
+:10FCC000CE51D140FF5FC25EDE4FF883CE51D140AE
+:10FCD000EE24FF2410E0C2CD9981933109F4BCCE0B
+:10FCE0009431B0F4933009F440CE943038F491302C
+:10FCF00009F425CE923009F0A5CF04CE903109F455
+:10FD000001CE913109F445CE963009F09BCF7CCEDF
+:10FD1000983109F458CE993150F4953109F49CCEBC
+:10FD2000953108F423CF963109F08CCF1FCF9B314A
+:10FD300009F436CE9D3109F4E7CD9A3109F082CF2E
+:10FD40003ACECE5DDE4F0FB6F894DEBF0FBECDBF0C
+:10FD5000CF91DF911F910F91FF90EF90DF90CF90A7
+:10FD6000BF90AF909F908F907F906F905F904F90DB
+:10FD70003F902F9008958091C00087FFFCCF089599
+:10FD80008091C00087FFFCCF8091C6000895982F16
+:10FD90008091C00085FFFCCF9093C60008959B0121
+:10FDA000AC0197FF11C08091C00082608093C000B9
+:10FDB00050954095309521953F4F4F4F5F4F60E0F4
+:10FDC00074E284EF90E009C08091C0008D7F809341
+:10FDD000C00060E072E18AE790E00E9447FF2C5F7C
+:10FDE0003F4F4F4F5F4F83E0569547953795279587
+:10FDF0008A95D1F7215030403093C5002093C4003C
+:10FE0000089518B817B81F921F921F920895FFCF38
+:10FE100084B714BE90E083709070892B39F418B8C1
+:10FE200017B81F921F921F920895FFCF88E1809309
+:10FE3000C10060E07EE38EEF9FEF0E94CFFE0E9444
+:10FE400007FC18B817B81F921F921F920895FFCF92
+:10FE500020E030E040E050E013C02F5F3F4F4F4FB5
+:10FE60005F4F21308AE6380788E1480780E058076D
+:10FE700039F418B817B81F921F921F920895FFCF38
+:10FE80008091C00087FFE9CF0E94C0FE0895A1E2E3
+:10FE90001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F04
+:10FEA000FF1FA217B307E407F50720F0A21BB30B4F
+:10FEB000E40BF50B661F771F881F991F1A9469F7CB
+:10FEC00060957095809590959B01AC01BD01CF0127
+:02FED000089593
+:040000031000F800F1
+:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
new file mode 100644
index 0000000..5809869
--- /dev/null
+++ b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E044E755E962E470E0ACCF90E061
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539444E755E962E470E090E0C6
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
new file mode 100644
index 0000000..d216c65
--- /dev/null
+++ b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539441ED5AE363E570E090E0C2
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
new file mode 100644
index 0000000..a9105a2
--- /dev/null
+++ b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E044E755E962E470E0ACCF90E063
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539444E755E962E470E090E0A0E0B0E0AF
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
new file mode 100644
index 0000000..4ee0c6b
--- /dev/null
+++ b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E041ED5AE363E570E0ACCF90E05F
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539441ED5AE363E570E090E0A0E0B0E0AB
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.cpp b/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..8b1fcc6
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,239 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer {
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer = { { 0 }, 0, 0 };
+
+#ifdef UDR1
+ring_buffer rx_buffer1 = { { 0 }, 0, 0 };
+#endif
+
+#ifdef UDR2
+ring_buffer rx_buffer2 = { { 0 }, 0, 0 };
+#endif
+#ifdef UDR3
+ring_buffer rx_buffer3 = { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+ISR(USART0_RX_vect)
+{
+  unsigned char c = UDR0;
+  store_char(c, &rx_buffer);
+}
+
+#ifdef UDR1
+ISR(USART1_RX_vect)
+{
+  unsigned char c = UDR1;
+  store_char(c, &rx_buffer1);
+}
+
+#ifdef UDR2
+ISR(USART2_RX_vect)
+{
+  unsigned char c = UDR2;
+  store_char(c, &rx_buffer2);
+}
+
+#ifdef UDR2
+ISR(USART3_RX_vect)
+{
+  unsigned char c = UDR3;
+  store_char(c, &rx_buffer3);
+}
+#endif
+#endif
+
+#else
+
+#if defined(__AVR_ATmega8__)
+SIGNAL(SIG_UART_RECV)
+#else
+SIGNAL(USART_RX_vect)
+#endif
+{
+#if defined(__AVR_ATmega8__)
+  unsigned char c = UDR;
+#else
+  unsigned char c = UDR0;
+#endif
+  store_char(c, &rx_buffer);
+}
+
+#endif
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x;
+
+  // U2X mode is needed for baud rates higher than (CPU Hz / 16)
+  if (baud > F_CPU / 16) {
+    use_u2x = true;
+  } else {
+    // figure out if U2X mode would allow for a better connection
+    
+    // calculate the percent difference between the baud-rate specified and
+    // the real baud rate for both U2X and non-U2X mode (0-255 error percent)
+    uint8_t nonu2x_baud_error = abs((int)(255-((F_CPU/(16*(((F_CPU/8/baud-1)/2)+1))*255)/baud)));
+    uint8_t u2x_baud_error = abs((int)(255-((F_CPU/(8*(((F_CPU/4/baud-1)/2)+1))*255)/baud)));
+    
+    // prefer non-U2X mode because it handles clock skew better
+    use_u2x = (nonu2x_baud_error > u2x_baud_error);
+  }
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+uint8_t HardwareSerial::available(void)
+{
+  return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+void HardwareSerial::write(uint8_t c)
+{
+  while (!((*_ucsra) & (1 << _udre)))
+    ;
+
+  *_udr = c;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(__AVR_ATmega8__)
+HardwareSerial Serial(&rx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
+#else
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+#endif
+
+#ifdef UDR1
+HardwareSerial Serial1(&rx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRE1, U2X1);
+#endif
+
+#ifdef UDR2
+HardwareSerial Serial2(&rx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRE2, U2X2);
+#endif
+#ifdef UDR3
+HardwareSerial Serial3(&rx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRE3, U2X3);
+#endif
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.h b/Marlin/Gen7/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..f609f73
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/HardwareSerial.h
@@ -0,0 +1,69 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Print.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Print
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    uint8_t available(void);
+    int read(void);
+    void flush(void);
+    virtual void write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+extern HardwareSerial Serial;
+
+#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial1;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial2;
+extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/Makefile b/Marlin/Gen7/cores/arduino/Makefile
new file mode 100644
index 0000000..571687d
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/Makefile
@@ -0,0 +1,243 @@
+# Arduino 0011 Makefile
+# Arduino adaptation by mellis, eighthave, oli.keller
+#
+# This makefile allows you to build sketches from the command line
+# without the Arduino environment (or Java).
+#
+# Detailed instructions for using the makefile:
+#
+#  1. Copy this file into the folder with your sketch. There should be a
+#     file with the same name as the folder and with the extension .pde
+#     (e.g. foo.pde in the foo/ folder).
+#
+#  2. Modify the line containg "INSTALL_DIR" to point to the directory that
+#     contains the Arduino installation (for example, under Mac OS X, this
+#     might be /Applications/arduino-0012).
+#
+#  3. Modify the line containing "PORT" to refer to the filename
+#     representing the USB or serial connection to your Arduino board
+#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
+#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
+#
+#  4. Set the line containing "MCU" to match your board's processor. 
+#     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
+#     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
+#     change F_CPU to 8000000.
+#
+#  5. At the command line, change to the directory containing your
+#     program's file and the makefile.
+#
+#  6. Type "make" and press enter to compile/verify your program.
+#
+#  7. Type "make upload", reset your Arduino board, and press enter to
+#     upload your program to the Arduino board.
+#
+# $Id$
+
+TARGET = $(notdir $(CURDIR))
+INSTALL_DIR = /Users/dmellis/Source/arduino/trunk/build/macosx/build/work
+PORT = /dev/tty.usb*
+UPLOAD_RATE = 19200
+AVRDUDE_PROGRAMMER = stk500v1
+MCU = atmega168
+F_CPU = 16000000
+
+############################################################################
+# Below here nothing should be changed...
+
+ARDUINO = $(INSTALL_DIR)/hardware/cores/arduino
+AVR_TOOLS_PATH = $(INSTALL_DIR)/hardware/tools/avr/bin
+SRC =  $(ARDUINO)/pins_arduino.c $(ARDUINO)/wiring.c \
+$(ARDUINO)/wiring_analog.c $(ARDUINO)/wiring_digital.c \
+$(ARDUINO)/wiring_pulse.c $(ARDUINO)/wiring_serial.c \
+$(ARDUINO)/wiring_shift.c $(ARDUINO)/WInterrupts.c
+CXXSRC = $(ARDUINO)/HardwareSerial.cpp $(ARDUINO)/WMath.cpp
+FORMAT = ihex
+
+
+# Name of this Makefile (used for "make depend").
+MAKEFILE = Makefile
+
+# Debugging format.
+# Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.
+# AVR (extended) COFF requires stabs, plus an avr-objcopy run.
+DEBUG = stabs
+
+OPT = s
+
+# Place -D or -U options here
+CDEFS = -DF_CPU=$(F_CPU)
+CXXDEFS = -DF_CPU=$(F_CPU)
+
+# Place -I options here
+CINCS = -I$(ARDUINO)
+CXXINCS = -I$(ARDUINO)
+
+# Compiler flag to set the C Standard level.
+# c89   - "ANSI" C
+# gnu89 - c89 plus GCC extensions
+# c99   - ISO C99 standard (not yet fully implemented)
+# gnu99 - c99 plus GCC extensions
+CSTANDARD = -std=gnu99
+CDEBUG = -g$(DEBUG)
+CWARN = -Wall -Wstrict-prototypes
+CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
+#CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
+
+CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CSTANDARD) $(CEXTRA)
+CXXFLAGS = $(CDEFS) $(CINCS) -O$(OPT)
+#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
+LDFLAGS = -lm
+
+
+# Programming support using avrdude. Settings and variables.
+AVRDUDE_PORT = $(PORT)
+AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex
+AVRDUDE_FLAGS = -V -F -C $(INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
+-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
+-b $(UPLOAD_RATE)
+
+# Program settings
+CC = $(AVR_TOOLS_PATH)/avr-gcc
+CXX = $(AVR_TOOLS_PATH)/avr-g++
+OBJCOPY = $(AVR_TOOLS_PATH)/avr-objcopy
+OBJDUMP = $(AVR_TOOLS_PATH)/avr-objdump
+AR  = $(AVR_TOOLS_PATH)/avr-ar
+SIZE = $(AVR_TOOLS_PATH)/avr-size
+NM = $(AVR_TOOLS_PATH)/avr-nm
+AVRDUDE = $(AVR_TOOLS_PATH)/avrdude
+REMOVE = rm -f
+MV = mv -f
+
+# Define all object files.
+OBJ = $(SRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.S=.o) 
+
+# Define all listing files.
+LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
+
+# Combine all necessary flags and optional flags.
+# Add target processor to flags.
+ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
+ALL_CXXFLAGS = -mmcu=$(MCU) -I. $(CXXFLAGS)
+ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
+
+
+# Default target.
+all: applet_files build sizeafter
+
+build: elf hex 
+
+applet_files: $(TARGET).pde
+	# Here is the "preprocessing".
+	# It creates a .cpp file based with the same name as the .pde file.
+	# On top of the new .cpp file comes the WProgram.h header.
+	# At the end there is a generic main() function attached.
+	# Then the .cpp file will be compiled. Errors during compile will
+	# refer to this new, automatically generated, file. 
+	# Not the original .pde file you actually edit...
+	test -d applet || mkdir applet
+	echo '#include "WProgram.h"' > applet/$(TARGET).cpp
+	cat $(TARGET).pde >> applet/$(TARGET).cpp
+	cat $(ARDUINO)/main.cxx >> applet/$(TARGET).cpp
+
+elf: applet/$(TARGET).elf
+hex: applet/$(TARGET).hex
+eep: applet/$(TARGET).eep
+lss: applet/$(TARGET).lss 
+sym: applet/$(TARGET).sym
+
+# Program the device.  
+upload: applet/$(TARGET).hex
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+
+	# Display size of file.
+HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
+ELFSIZE = $(SIZE)  applet/$(TARGET).elf
+sizebefore:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+
+sizeafter:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(HEXSIZE); echo; fi
+
+
+# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
+COFFCONVERT=$(OBJCOPY) --debugging \
+--change-section-address .data-0x800000 \
+--change-section-address .bss-0x800000 \
+--change-section-address .noinit-0x800000 \
+--change-section-address .eeprom-0x810000 
+
+
+coff: applet/$(TARGET).elf
+	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+extcoff: $(TARGET).elf
+	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+.SUFFIXES: .elf .hex .eep .lss .sym
+
+.elf.hex:
+	$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
+
+.elf.eep:
+	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
+	--change-section-lma .eeprom=0 -O $(FORMAT) $< $@
+
+# Create extended listing file from ELF output file.
+.elf.lss:
+	$(OBJDUMP) -h -S $< > $@
+
+# Create a symbol table from ELF output file.
+.elf.sym:
+	$(NM) -n $< > $@
+
+	# Link: create ELF output file from library.
+applet/$(TARGET).elf: $(TARGET).pde applet/core.a 
+	$(CC) $(ALL_CFLAGS) -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
+
+applet/core.a: $(OBJ)
+	@for i in $(OBJ); do echo $(AR) rcs applet/core.a $$i; $(AR) rcs applet/core.a $$i; done
+
+
+
+# Compile: create object files from C++ source files.
+.cpp.o:
+	$(CXX) -c $(ALL_CXXFLAGS) $< -o $@ 
+
+# Compile: create object files from C source files.
+.c.o:
+	$(CC) -c $(ALL_CFLAGS) $< -o $@ 
+
+
+# Compile: create assembler files from C source files.
+.c.s:
+	$(CC) -S $(ALL_CFLAGS) $< -o $@
+
+
+# Assemble: create object files from assembler source files.
+.S.o:
+	$(CC) -c $(ALL_ASFLAGS) $< -o $@
+
+
+
+# Target: clean project.
+clean:
+	$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
+	applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/core.a \
+	$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
+
+depend:
+	if grep '^# DO NOT DELETE' $(MAKEFILE) >/dev/null; \
+	then \
+		sed -e '/^# DO NOT DELETE/,$$d' $(MAKEFILE) > \
+			$(MAKEFILE).$$$$ && \
+		$(MV) $(MAKEFILE).$$$$ $(MAKEFILE); \
+	fi
+	echo '# DO NOT DELETE THIS LINE -- make depend depends on it.' \
+		>> $(MAKEFILE); \
+	$(CC) -M -mmcu=$(MCU) $(CDEFS) $(CINCS) $(SRC) $(ASRC) >> $(MAKEFILE)
+
+.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/Marlin/Gen7/cores/arduino/Print.cpp b/Marlin/Gen7/cores/arduino/Print.cpp
new file mode 100644
index 0000000..d4833da
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/Print.cpp
@@ -0,0 +1,203 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void Print::print(uint8_t b)
+{
+  this->write(b);
+}
+
+void Print::print(char c)
+{
+  print((byte) c);
+}
+
+void Print::print(const char c[])
+{
+  while (*c)
+    print(*c++);
+}
+
+void Print::print(int n)
+{
+  print((long) n);
+}
+
+void Print::print(unsigned int n)
+{
+  print((unsigned long) n);
+}
+
+void Print::print(long n)
+{
+  if (n < 0) {
+    print('-');
+    n = -n;
+  }
+  printNumber(n, 10);
+}
+
+void Print::print(unsigned long n)
+{
+  printNumber(n, 10);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0)
+    print((char) n);
+  else if (base == 10)
+    print(n);
+  else
+    printNumber(n, base);
+}
+
+void Print::print(double n)
+{
+  printFloat(n, 2);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(char c)
+{
+  print(c);
+  println();  
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(uint8_t b)
+{
+  print(b);
+  println();
+}
+
+void Print::println(int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(unsigned int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(unsigned long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n)
+{
+  print(n);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/Marlin/Gen7/cores/arduino/Print.h b/Marlin/Gen7/cores/arduino/Print.h
new file mode 100644
index 0000000..c95a0dc
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/Print.h
@@ -0,0 +1,59 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+    virtual void write(uint8_t);
+    void print(char);
+    void print(const char[]);
+    void print(uint8_t);
+    void print(int);
+    void print(unsigned int);
+    void print(long);
+    void print(unsigned long);
+    void print(long, int);
+    void print(double);
+    void println(void);
+    void println(char);
+    void println(const char[]);
+    void println(uint8_t);
+    void println(int);
+    void println(unsigned int);
+    void println(long);
+    void println(unsigned long);
+    void println(long, int);
+    void println(double);
+};
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/Tone.cpp b/Marlin/Gen7/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..827fe49
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/Tone.cpp
@@ -0,0 +1,515 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <wiring.h>
+#include <pins_arduino.h>
+
+#if defined(__AVR_ATmega8__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(__AVR_ATmega1280__)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+#if defined(__AVR_ATmega1280__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        bitWrite(TCCR4B, WGM42, 1);
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if !defined(__AVR_ATmega8__)
+      if (_timer == 0)
+        TCCR0B = prescalarbits;
+      else
+#endif
+        TCCR2B = prescalarbits;
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#if defined(__AVR_ATmega1280__)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+        break;
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  switch (_timer)
+  {
+#if defined(__AVR_ATmega8__)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+    case 2:
+      bitWrite(TIMSK2, OCIE2A, 0);
+      break;
+
+#else
+    case 0:
+      TIMSK0 = 0;
+      break;
+    case 1:
+      TIMSK1 = 0;
+      break;
+    case 2:
+      TIMSK2 = 0;
+      break;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+    case 3:
+      TIMSK3 = 0;
+      break;
+    case 4:
+      TIMSK4 = 0;
+      break;
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    TIMSK0 = 0;   // disable the interrupt
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    TIMSK1 = 0;   // disable the interrupt
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    TIMSK2 = 0;   // disable the interrupt
+    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    TIMSK3 = 0;   // disable the interrupt
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    TIMSK4 = 0;   // disable the interrupt
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    TIMSK5 = 0;   // disable the interrupt
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/WCharacter.h b/Marlin/Gen7/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/Marlin/Gen7/cores/arduino/WConstants.h b/Marlin/Gen7/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/Marlin/Gen7/cores/arduino/WInterrupts.c b/Marlin/Gen7/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..6f3f0b1
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WInterrupts.c
@@ -0,0 +1,87 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		intFunc[interruptNum] = userFunc;
+
+		//clear the config for the change settings
+		EICRA &= ~(B00000011 << (interruptNum * 2));
+
+		//set our mode.
+		EICRA |= (mode << (interruptNum * 2));
+
+		// Enable the interrupt.
+		EIMSK |= (1 << interruptNum);
+	}
+}
+
+void detachInterrupt(uint8_t interruptNum)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		// Disable the interrupt.
+		EIMSK &= ~(1 << interruptNum);
+
+		intFunc[interruptNum] = 0;
+	}
+}
+
+ISR(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+ISR(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+ISR(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/Marlin/Gen7/cores/arduino/WMath.cpp b/Marlin/Gen7/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..7a230f5
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0){
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
diff --git a/Marlin/Gen7/cores/arduino/WProgram.h b/Marlin/Gen7/cores/arduino/WProgram.h
new file mode 100644
index 0000000..2c7ed16
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WProgram.h
@@ -0,0 +1,34 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+#endif
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/WString.cpp b/Marlin/Gen7/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/Marlin/Gen7/cores/arduino/WString.h b/Marlin/Gen7/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/binary.h b/Marlin/Gen7/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/main.cpp b/Marlin/Gen7/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/Marlin/Gen7/cores/arduino/main.cxx b/Marlin/Gen7/cores/arduino/main.cxx
new file mode 100644
index 0000000..52351e4
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/main.cxx
@@ -0,0 +1,12 @@
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.c b/Marlin/Gen7/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..ccb88fe
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+    &DDRA,
+	&DDRB,
+	&DDRC,
+	&DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	&PORTA,
+	&PORTB,
+	&PORTC,
+	&PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	&PINA,
+	&PINB,
+	&PINC,
+	&PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.h b/Marlin/Gen7/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..e0b7add
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring.c b/Marlin/Gen7/cores/arduino/wiring.c
new file mode 100644
index 0000000..1a102ae
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring.c
@@ -0,0 +1,203 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 388 2008-03-08 22:05:23Z mellis $
+*/
+
+#include "wiring_private.h"
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_clock_cycles = 0;
+volatile unsigned long timer0_millis = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	timer0_overflow_count++;
+	// timer 0 prescale factor is 64 and the timer overflows at 256
+	timer0_clock_cycles += 64UL * 256UL;
+	while (timer0_clock_cycles > clockCyclesPerMicrosecond() * 1000UL) {
+		timer0_clock_cycles -= clockCyclesPerMicrosecond() * 1000UL;
+		timer0_millis++;
+	}
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+	
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of the timer0_millis++)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+	
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m, t;
+	uint8_t oldSREG = SREG;
+	
+	cli();	
+	t = TCNT0;
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t == 0))
+		t = 256;
+#else
+	if ((TIFR & _BV(TOV0)) && (t == 0))
+		t = 256;
+#endif
+
+	m = timer0_overflow_count;
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	unsigned long start = millis();
+	
+	while (millis() - start <= ms)
+		;
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. 
+ * Disables interrupts, which will disrupt the millis() function if used
+ * too frequently. */
+void delayMicroseconds(unsigned int us)
+{
+	uint8_t oldSREG;
+
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// disable interrupts, otherwise the timer 0 overflow interrupt that
+	// tracks milliseconds will make us delay longer than we want.
+	oldSREG = SREG;
+	cli();
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+
+	// reenable interrupts.
+	SREG = oldSREG;
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+
+	// set timer 0 prescale factor to 64
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+
+	// enable timer 0 overflow interrupt
+	sbi(TIMSK0, TOIE0);
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+
+	// put timer 1 in 8-bit phase correct pwm mode
+	sbi(TCCR1A, WGM10);
+
+	// set timer 2 prescale factor to 64
+	sbi(TCCR2B, CS22);
+
+	// configure timer 2 for phase correct pwm (8-bit)
+	sbi(TCCR2A, WGM20);
+
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+	UCSR0B = 0;
+	#if defined(__AVR_ATmega644P__)
+	//TODO: test to see if disabling this helps?
+	//UCSR1B = 0;
+	#endif
+}
diff --git a/Marlin/Gen7/cores/arduino/wiring.h b/Marlin/Gen7/cores/arduino/wiring.h
new file mode 100644
index 0000000..6309a36
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring.h
@@ -0,0 +1,133 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 387 2008-03-08 21:30:00Z mellis $
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.14159265
+#define HALF_PI 1.57079
+#define TWO_PI 6.283185
+#define DEG_TO_RAD 0.01745329
+#define RAD_TO_DEG 57.2957786
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#define INTERNAL 3
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((w) & 0xff)
+#define highByte(w) ((w) >> 8)
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+typedef unsigned int word;
+
+#define bit(b) (1 << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+void beginSerial(uint8_t, long);
+void serialWrite(uint8_t, unsigned char);
+int serialAvailable(uint8_t);
+int serialRead(uint8_t);
+void serialFlush(uint8_t);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_analog.c b/Marlin/Gen7/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..b98bb1a
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_analog.c
@@ -0,0 +1,116 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high, ch = analogInPinToBit(pin);
+
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+	// the final AND is to clear the pos/neg reference bits
+	ADMUX = ((analog_reference << 6) | (pin & 0x0f)) & B11000111;
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low = ADCL;
+	high = ADCH;
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	
+	if (digitalPinToTimer(pin) == TIMER1A) {
+		// connect pwm to pin on timer 1, channel A
+		sbi(TCCR1A, COM1A1);
+		// set pwm duty
+		OCR1A = val;
+	} else if (digitalPinToTimer(pin) == TIMER1B) {
+		// connect pwm to pin on timer 1, channel B
+		sbi(TCCR1A, COM1B1);
+		// set pwm duty
+		OCR1B = val;
+	} else if (digitalPinToTimer(pin) == TIMER0A) {
+		// connect pwm to pin on timer 0, channel A
+		sbi(TCCR0A, COM0A1);
+		// set pwm duty
+		OCR0A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER0B) {
+		// connect pwm to pin on timer 0, channel B
+		sbi(TCCR0A, COM0B1);
+		// set pwm duty
+		OCR0B = val;
+	} else if (digitalPinToTimer(pin) == TIMER2A) {
+		// connect pwm to pin on timer 2, channel A
+		sbi(TCCR2A, COM2A1);
+		// set pwm duty
+		OCR2A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER2B) {
+		// connect pwm to pin on timer 2, channel B
+		sbi(TCCR2A, COM2B1);
+		// set pwm duty
+		OCR2B = val;
+	} else if (val < 128)
+	//fail semi-intelligently
+		digitalWrite(pin, LOW);
+	else
+		digitalWrite(pin, HIGH);
+}
diff --git a/Marlin/Gen7/cores/arduino/wiring_digital.c b/Marlin/Gen7/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..3d4b4eb
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_digital.c
@@ -0,0 +1,95 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) *reg &= ~bit;
+	else *reg |= bit;
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+static inline void turnOffPWM(uint8_t timer)
+{
+	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
+	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
+	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
+	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
+	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
+	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) *out &= ~bit;
+	else *out |= bit;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	
+	return LOW;
+}
diff --git a/Marlin/Gen7/cores/arduino/wiring_private.h b/Marlin/Gen7/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..14394a0
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_private.h
@@ -0,0 +1,60 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/signal.h>
+#include <avr/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+
+#define EXTERNAL_NUM_INTERRUPTS 3
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_pulse.c b/Marlin/Gen7/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..8f232f1
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_pulse.c
@@ -0,0 +1,66 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask)
+		width++;
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 10 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 10 + 16); 
+}
diff --git a/Marlin/Gen7/cores/arduino/wiring_serial.c b/Marlin/Gen7/cores/arduino/wiring_serial.c
new file mode 100644
index 0000000..a3314fa
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_serial.c
@@ -0,0 +1,138 @@
+/*
+  wiring_serial.c - serial functions.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+  Modified 29 January 2009, Marius Kintel for Sanguino - http://www.sanguino.cc/
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+
+#include "wiring_private.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+#if defined(__AVR_ATmega644P__)
+unsigned char rx_buffer[2][RX_BUFFER_SIZE];
+int rx_buffer_head[2] = {0, 0};
+int rx_buffer_tail[2] = {0, 0};
+#else
+unsigned char rx_buffer[1][RX_BUFFER_SIZE];
+int rx_buffer_head[1] = {0};
+int rx_buffer_tail[1] = {0};
+#endif
+
+
+#define BEGIN_SERIAL(uart_, baud_) \
+{ \
+    UBRR##uart_##H = ((F_CPU / 16 + baud / 2) / baud - 1) >> 8; \
+    UBRR##uart_##L = ((F_CPU / 16 + baud / 2) / baud - 1); \
+    \
+    /* reset config for UART */ \
+    UCSR##uart_##A = 0; \
+    UCSR##uart_##B = 0; \
+    UCSR##uart_##C = 0; \
+    \
+    /* enable rx and tx */ \
+    sbi(UCSR##uart_##B, RXEN##uart_);\
+    sbi(UCSR##uart_##B, TXEN##uart_);\
+    \
+    /* enable interrupt on complete reception of a byte */ \
+    sbi(UCSR##uart_##B, RXCIE##uart_); \
+    UCSR##uart_##C = _BV(UCSZ##uart_##1)|_BV(UCSZ##uart_##0); \
+    /* defaults to 8-bit, no parity, 1 stop bit */ \
+}
+
+void beginSerial(uint8_t uart, long baud)
+{
+  if (uart == 0) BEGIN_SERIAL(0, baud)
+#if defined(__AVR_ATmega644P__)
+  else BEGIN_SERIAL(1, baud)
+#endif
+}
+
+#define SERIAL_WRITE(uart_, c_) \
+    while (!(UCSR##uart_##A & (1 << UDRE##uart_))) \
+      ; \
+    UDR##uart_ = c
+
+void serialWrite(uint8_t uart, unsigned char c)
+{
+  if (uart == 0) {
+    SERIAL_WRITE(0, c);
+  }
+#if defined(__AVR_ATmega644P__)
+  else {
+    SERIAL_WRITE(1, c);
+  }
+#endif
+}
+
+int serialAvailable(uint8_t uart)
+{
+  return (RX_BUFFER_SIZE + rx_buffer_head[uart] - rx_buffer_tail[uart]) % RX_BUFFER_SIZE;
+}
+
+int serialRead(uint8_t uart)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (rx_buffer_head[uart] == rx_buffer_tail[uart]) {
+    return -1;
+  } else {
+    unsigned char c = rx_buffer[uart][rx_buffer_tail[uart]];
+    rx_buffer_tail[uart] = (rx_buffer_tail[uart] + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void serialFlush(uint8_t uart)
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  rx_buffer_head[uart] = rx_buffer_tail[uart];
+}
+
+#define UART_ISR(uart_) \
+ISR(USART##uart_##_RX_vect) \
+{ \
+  unsigned char c = UDR##uart_; \
+  \
+  int i = (rx_buffer_head[uart_] + 1) % RX_BUFFER_SIZE; \
+  \  
+  /* if we should be storing the received character into the location \
+     just before the tail (meaning that the head would advance to the \
+     current location of the tail), we're about to overflow the buffer \
+     and so we don't write the character or advance the head. */ \
+  if (i != rx_buffer_tail[uart_]) { \
+    rx_buffer[uart_][rx_buffer_head[uart_]] = c; \
+    rx_buffer_head[uart_] = i; \
+  } \
+}
+
+UART_ISR(0)
+#if defined(__AVR_ATmega644P__) 
+UART_ISR(1)
+#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_shift.c b/Marlin/Gen7/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..956f864
--- /dev/null
+++ b/Marlin/Gen7/cores/arduino/wiring_shift.c
@@ -0,0 +1,40 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 07716fd..7ee0762 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -226,11 +226,11 @@ void setup_photpin()
 void setup_powerhold()
 {
  #ifdef SUICIDE_PIN
-    #if (SUICIDE_PIN> -1) 
+   #if (SUICIDE_PIN> -1)
       SET_OUTPUT(SUICIDE_PIN);
       WRITE(SUICIDE_PIN, HIGH);
-    #endif
-  #endif
+   #endif
+ #endif
 }
 
 void suicide()
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index 42f4ebb..cb4399a 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -424,7 +424,7 @@ pins
 #define PD7_PWM			NULL
 #endif	/*	_AVR_ATmega{168,328,328P}__ */
 
-#if defined (__AVR_ATmega644__) || defined (__AVR_ATmega644P__) || defined (__AVR_ATmega644PA__)
+#if defined (__AVR_ATmega644__) || defined (__AVR_ATmega644P__) || defined (__AVR_ATmega644PA__) || defined (__AVR_ATmega1284P__)
 // UART
 #define	RXD					DIO8
 #define	TXD					DIO9
diff --git a/Marlin/pins.h b/Marlin/pins.h
index f7c3e29..a07e083 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -567,6 +567,104 @@
 
 #endif
 
+/*******************************************************************************
+*********
+* Gen7 Alfons3  pin assignment
+*
+********************************************************************************
+********/
+/* These Pins are assigned for the modified GEN7 Board from Alfons3 Please review the pins and adjust it for your needs*/
+
+#if MOTHERBOARD == 77
+#define KNOWN_BOARD
+
+#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)
+    #error Oops!  Make sure you have 'Gen7' selected from the 'Tools -> Boards' menu.
+
+#endif
+
+//x axis pins
+    #define X_STEP_PIN      21                  //different from stanard GEN7
+    #define X_DIR_PIN       20				    //different from stanard GEN7
+    #define X_ENABLE_PIN    24
+    #define X_MIN_PIN       0
+    #define X_MAX_PIN       -1
+
+    //y axis pins
+    #define Y_STEP_PIN      23
+    #define Y_DIR_PIN       22
+    #define Y_ENABLE_PIN    24
+    #define Y_MIN_PIN       1
+    #define Y_MAX_PIN       -1
+
+    //z axis pins
+    #define Z_STEP_PIN      26
+    #define Z_DIR_PIN       25
+    #define Z_ENABLE_PIN    24
+    #define Z_MIN_PIN       2
+    #define Z_MAX_PIN       -1
+
+    //extruder pins
+    #define E0_STEP_PIN      28
+    #define E0_DIR_PIN       27
+    #define E0_ENABLE_PIN    24
+    
+    #define TEMP_0_PIN      2
+    #define TEMP_1_PIN      -1
+    #define TEMP_2_PIN      -1
+    #define TEMP_BED_PIN        1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
+     
+    #define HEATER_0_PIN    4
+    #define HEATER_1_PIN    -1   
+    #define HEATER_2_PIN    -1
+    #define HEATER_BED_PIN      3  // (bed)
+   
+   
+
+    
+    #define SDPOWER         -1
+    #define SDSS            31                  // SCL pin of I2C header || CS Pin for SD Card support
+    #define LED_PIN         -1
+
+    #define FAN_PIN         -1
+    #define PS_ON_PIN       19
+    //our pin for debugging.
+
+    #define DEBUG_PIN        -1
+
+    //our RS485 pins
+    //#define TX_ENABLE_PIN       12
+    //#define RX_ENABLE_PIN       13
+    
+    #define BEEPER -1	
+	#define SDCARDDETECT -1 		
+    #define SUICIDE_PIN -1						//has to be defined; otherwise Power_off doesn't work
+	
+	//Pins for 4bit LCD Support 
+    #define LCD_PINS_RS 18 
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 16
+    #define LCD_PINS_D5 15 
+    #define LCD_PINS_D6 13
+    #define LCD_PINS_D7 14
+    
+     //buttons are directly attached
+    #define BTN_EN1 11
+    #define BTN_EN2 10
+    #define BTN_ENC 12  //the click
+    
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+
+   
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+   
+    
+#endif
 
 #if MOTHERBOARD == 7
 #define KNOWN_BOARD
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 2f3888c..95f0f86 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -851,13 +851,21 @@ ISR(TIMER0_COMPB_vect)
     for(unsigned char e = 0; e < EXTRUDERS; e++) {
        if(current_raw[e] >= maxttemp[e]) {
           target_raw[e] = 0;
-          max_temp_error(e);
-          kill();;
+          #if (PS_ON != -1)
+          {
+            max_temp_error(e);
+            kill();;
+          }
+          #endif
        }
        if(current_raw[e] <= minttemp[e]) {
           target_raw[e] = 0;
-          min_temp_error(e);
-          kill();
+          #if (PS_ON != -1)
+          {
+            min_temp_error(e);
+            kill();
+          }
+          #endif
        }
     }
   
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 08ac950..db8a131 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -27,7 +27,11 @@
     
     #define CLICKED (buttons&EN_C)
     #define BLOCK {blocking=millis()+blocktime;}
-    #define CARDINSERTED (READ(SDCARDDETECT)==0)
+    #if (SDCARDDETECT > -1)
+    {
+      #define CARDINSERTED (READ(SDCARDDETECT)==0)
+    }
+    #endif
     
   #else
 
@@ -50,7 +54,7 @@
   #define blocktime 500
   #define lcdslow 5
     
-  enum MainStatus{Main_Status, Main_Menu, Main_Prepare, Main_Control, Main_SD,Sub_TempControl,Sub_MotionControl};
+  enum MainStatus{Main_Status, Main_Menu, Main_Prepare,Sub_PrepareMove, Main_Control, Main_SD,Sub_TempControl,Sub_MotionControl};
 
   class MainMenu{
   public:
@@ -67,6 +71,7 @@
     void showControl();
     void showControlMotion();
     void showControlTemp();
+    void showAxisMove();
     void showSD();
     bool force_lcd_update;
     int lastencoderpos;
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index 68a5954..ad7b752 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -130,13 +130,17 @@ void beep()
 {
   //return;
   #ifdef ULTIPANEL
-    pinMode(BEEPER,OUTPUT);
-    for(int8_t i=0;i<20;i++){
-      WRITE(BEEPER,HIGH);
-      delay(5);
-      WRITE(BEEPER,LOW);
-      delay(5);
-    }
+	#if (BEEPER > -1)
+	{
+		pinMode(BEEPER,OUTPUT);
+		for(int8_t i=0;i<20;i++){
+		WRITE(BEEPER,HIGH);
+		delay(5);
+		WRITE(BEEPER,LOW);
+		delay(5);
+		}
+	}
+        #endif
   #endif
 }
 
@@ -144,13 +148,17 @@ void beepshort()
 {
   //return;
   #ifdef ULTIPANEL
-    pinMode(BEEPER,OUTPUT);
-    for(int8_t i=0;i<10;i++){
-      WRITE(BEEPER,HIGH);
-      delay(3);
-      WRITE(BEEPER,LOW);
-      delay(3);
-    }
+	#if (BEEPER > -1)
+	{
+		pinMode(BEEPER,OUTPUT);
+		for(int8_t i=0;i<10;i++){
+		WRITE(BEEPER,HIGH);
+		delay(3);
+		WRITE(BEEPER,LOW);
+		delay(3);
+		}
+	}
+        #endif
   #endif  
 }
 
@@ -197,7 +205,11 @@ void buttons_init()
     WRITE(BTN_EN1,HIGH);
     WRITE(BTN_EN2,HIGH);
     WRITE(BTN_ENC,HIGH);
-    WRITE(SDCARDDETECT,HIGH);
+    #if (SDCARDDETECT > -1)
+    {
+      WRITE(SDCARDDETECT,HIGH);
+    }
+    #endif
   #else
     pinMode(SHIFT_CLK,OUTPUT);
     pinMode(SHIFT_LD,OUTPUT);
@@ -445,7 +457,7 @@ void MainMenu::showStatus()
   force_lcd_update=false;
 }
 
-enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat, ItemP_cooldown,ItemP_extrude};
+enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat, ItemP_cooldown,/*ItemP_extrude,*/ItemP_move};
 
 //any action must not contain a ',' character anywhere, or this breaks:
 #define MENUITEM(repaint_action, click_action) \
@@ -484,17 +496,150 @@ void MainMenu::showPrepare()
     case ItemP_cooldown:
       MENUITEM(  lcdprintPGM(" Cooldown")  ,  BLOCK;setTargetHotend0(0);setTargetBed(0);beepshort(); ) ;
       break;
-    case ItemP_extrude:
-      MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
+//    case ItemP_extrude:
+  //    MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
+    //  break;
+    case ItemP_move:
+      MENUITEM(  lcdprintPGM(" Move Axis      \x7E") , BLOCK;status=Sub_PrepareMove;beepshort(); );
       break;
-    
-    
-    default:   
+        default:   
       break;
   }
   line++;
  }
- updateActiveLines(ItemP_extrude,encoderpos);
+ updateActiveLines(ItemP_move,encoderpos);
+}
+
+enum {
+  ItemAM_exit,
+  ItemAM_X, ItemAM_Y, ItemAM_Z, ItemAM_E
+};
+
+void MainMenu::showAxisMove()
+{
+   uint8_t line=0;
+   clearIfNecessary();
+   for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+   {
+     switch(i)
+      {
+          case ItemAM_exit:
+          MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+          break;
+          case ItemAM_X:
+         // MENUITEM(  lcdprintPGM(" X+")  ,  BLOCK;enquecommand("G92 X0");enquecommand("G1 F700 X10");beepshort(); ) ;
+         {
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);lcdprintPGM(" X:");
+                    lcd.setCursor(13,line);lcd.print(ftostr3(current_position[X_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                  if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+                        encoderpos=current_position[X_AXIS];
+                    }
+                    else
+                    {
+                      enquecommand("G1 F700 X"+encoderpos);
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if(encoderpos<1) encoderpos=1;
+                    if(encoderpos>200) encoderpos=200;                   
+                    lcd.setCursor(13,line);lcd.print(current_position[X_AXIS]);
+                  }
+          }
+          break;
+          case ItemAM_Y:
+          //MENUITEM(  lcdprintPGM(" Y+")  ,  BLOCK;enquecommand("G92 Y0");enquecommand("G1 F700 Y10");beepshort(); ) ;
+          {
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);lcdprintPGM(" Y:");
+                    lcd.setCursor(13,line);lcd.print(ftostr3(current_position[Y_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                  if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+                        encoderpos=current_position[Y_AXIS];
+                    }
+                    else
+                    {
+                      enquecommand("G1 F700 Y"+encoderpos);
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if(encoderpos<1) encoderpos=1;
+                    if(encoderpos>200) encoderpos=200;                   
+                    lcd.setCursor(13,line);lcd.print(current_position[Y_AXIS]);
+                  }
+          }
+          break;
+          case ItemAM_Z:
+          //MENUITEM(  lcdprintPGM(" Z+")  ,  BLOCK;enquecommand("G92 Z0");enquecommand("G1 F700 Z10");beepshort(); ) ;
+          {
+                  if(force_lcd_update)
+                  {
+                    lcd.setCursor(0,line);lcdprintPGM(" Z:");
+                    lcd.setCursor(13,line);lcd.print(ftostr3(current_position[Z_AXIS]));
+                  }
+      
+                  if((activeline!=line) )
+                  break;
+                  
+                  if(CLICKED) 
+                  {
+                    linechanging=!linechanging;
+                    if(linechanging)
+                    {
+                        encoderpos=current_position[Z_AXIS];
+                    }
+                    else
+                    {
+                      enquecommand("G1 F700 Z"+encoderpos);
+                      encoderpos=activeline*lcdslow;
+                      beepshort();
+                    }
+                    BLOCK;
+                  }
+                  if(linechanging)
+                  {
+                    if(encoderpos<1) encoderpos=1;
+                    if(encoderpos>170) encoderpos=170;                   
+                    lcd.setCursor(13,line);lcd.print(current_position[Z_AXIS]);
+                  }
+          }
+          break;
+          case ItemAM_E:
+          MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E10");beepshort(); ) ;
+          break;
+          default:
+          break;
+      }
+      line++;
+   }
+   updateActiveLines(ItemAM_E,encoderpos);
 }
 
 enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,
@@ -1140,7 +1285,7 @@ enum {
   ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
   ItemCM_vtravmin,ItemCM_vmin,  
   ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
-  ItemCM_aret,ItemCM_esteps
+  ItemCM_aret, ItemCM_xsteps,ItemCM_ysteps, ItemCM_zsteps, ItemCM_esteps
 };
 
 
@@ -1416,11 +1561,126 @@ void MainMenu::showControlMotion()
         }
         
       }break;
+       case ItemCM_xsteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" X steps/mm:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[0]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)axis_steps_per_unit[0];
+          }
+          else
+          {
+            float factor=float(encoderpos)/float(axis_steps_per_unit[0]);
+            position[X_AXIS]=lround(position[X_AXIS]*factor);
+            //current_position[3]*=factor;
+            axis_steps_per_unit[X_AXIS]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>9999) encoderpos=9999;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break;
+       case ItemCM_ysteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Y steps/mm:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[1]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)axis_steps_per_unit[1];
+          }
+          else
+          {
+            float factor=float(encoderpos)/float(axis_steps_per_unit[1]);
+            position[Y_AXIS]=lround(position[Y_AXIS]*factor);
+            //current_position[3]*=factor;
+            axis_steps_per_unit[Y_AXIS]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>9999) encoderpos=9999;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break;
+       case ItemCM_zsteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Z steps/mm:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[2]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)axis_steps_per_unit[2];
+          }
+          else
+          {
+            float factor=float(encoderpos)/float(axis_steps_per_unit[2]);
+            position[Z_AXIS]=lround(position[Z_AXIS]*factor);
+            //current_position[3]*=factor;
+            axis_steps_per_unit[Z_AXIS]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>9999) encoderpos=9999;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break;
+      
     case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
          {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" Esteps/mm:");
+          lcd.setCursor(0,line);lcdprintPGM(" E steps/mm:");
           lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
         }
         
@@ -1801,6 +2061,10 @@ void MainMenu::update()
           showPrepare(); 
         }
       }break;
+      case Sub_PrepareMove:
+      {        
+            showAxisMove();
+      }break;
       case Main_Control:
       {
         showControl(); 
diff --git a/README b/README
deleted file mode 100644
index 2487d48..0000000
--- a/README
+++ /dev/null
@@ -1,64 +0,0 @@
-This RepRap firmware is a mashup between Sprinter, grbl and many original parts.
- (https://github.com/kliment/Sprinter)
- (https://github.com/simen/grbl/tree)
-
-Derived from Sprinter and Grbl by Erik van der Zalm.
-Sprinters lead developers are Kliment and caru.
-Grbls lead developer is Simen Svale Skogsrud.
-It has been adapted to the Ultimaker Printer by:
-Bernhard Kubicek, Matthijs Keuper, Bradley Feldman, and others...
-
-
-Features:
- - Interrupt based movement with real linear acceleration
- - High steprate
- - Look ahead (Keep the speed high when possible. High cornering speed)
- - Interrupt based temperature protection
- - preliminary support for Matthew Roberts advance algorithm 
-   For more info see: http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
- - Full endstop support
- - Simple LCD support (16x2)
- - SD Card support
- - Provisions for Bernhard Kubicek's new hardware control console and 20x4 lcd
-
-This firmware is optimized for Ultimaker's gen6 electronics (including the Ultimaker 1.5.x daughterboard and Arduino Mega 2560).
-
-The default baudrate is 115200. 
-
-
-========================================================================================
-
-Configuring and compilation
-
-
-Install the latest arduino software IDE/toolset (currently 0022)
-   http://www.arduino.cc/en/Main/Software
-
-Install Ultimaker's RepG 25 build
-    http://software.ultimaker.com
-(or alternatively install Kliment's printrun/pronterface  https://github.com/kliment/Printrun_)
-
-Copy the Ultimaker Marlin firmware
-   https:/github.com/bkubicek/Marlin
-   (Use the download button)
-
-Start the arduino IDE.
-Select Tools -> Board -> Arduino Mega 2560 
-Select the correct serial port in Tools ->Serial Port
-Open Marlin.pde
-
-Click the Verify/Compile button
-
-Click the Upload button
-If all goes well the firmware is uploading
-
-Start Ultimaker's Custom RepG 25
-Make sure Show Experimental Profiles is enabled in Preferences
-Select Sprinter as the Driver
-
-Press the Connect button.
-
-KNOWN ISSUES: RepG will display:  Unknown: marlin x.y.z
-
-That's ok.  Enjoy Silky Smooth Printing.
-

