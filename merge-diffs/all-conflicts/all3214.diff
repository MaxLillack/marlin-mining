commit 8ea5665ee2d6c21289bdf3ef3495c0203856b136 (from af9395ac2ec8d9ede37028720af953e56821120b)
Merge: af9395a fde8c2c
Author: Jim Morris <morris@wolfman.com>
Date:   Wed Feb 26 00:19:28 2014 -0800

    Merge remote-tracking branch 'origin/Marlin_v1' into add/M665-set-delta-configuration
    
    Conflicts:
    	Marlin/Marlin_main.cpp

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index c9f3558..e18c98a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -335,11 +335,49 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 
-  // these are the positions on the bed to do the probing
-  #define LEFT_PROBE_BED_POSITION 15
-  #define RIGHT_PROBE_BED_POSITION 170
-  #define BACK_PROBE_BED_POSITION 180
-  #define FRONT_PROBE_BED_POSITION 20
+// There are 2 different ways to pick the X and Y locations to probe:
+
+//  - "grid" mode
+//    Probe every point in a rectangular grid
+//    You must specify the rectangle, and the density of sample points
+//    This mode is preferred because there are more measurements.
+//    It used to be called ACCURATE_BED_LEVELING but "grid" is more descriptive
+
+//  - "3-point" mode
+//    Probe 3 arbitrary points on the bed (that aren't colinear)
+//    You must specify the X & Y coordinates of all 3 points
+
+  #define AUTO_BED_LEVELING_GRID
+  // with AUTO_BED_LEVELING_GRID, the bed is sampled in a
+  // AUTO_BED_LEVELING_GRID_POINTSxAUTO_BED_LEVELING_GRID_POINTS grid
+  // and least squares solution is calculated
+  // Note: this feature occupies 10'206 byte
+  #ifdef AUTO_BED_LEVELING_GRID
+
+    // set the rectangle in which to probe
+    #define LEFT_PROBE_BED_POSITION 15
+    #define RIGHT_PROBE_BED_POSITION 170
+    #define BACK_PROBE_BED_POSITION 180
+    #define FRONT_PROBE_BED_POSITION 20
+
+     // set the number of grid points per dimension
+     // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
+    #define AUTO_BED_LEVELING_GRID_POINTS 2
+
+
+  #else  // not AUTO_BED_LEVELING_GRID
+    // with no grid, just probe 3 arbitrary points.  A simple cross-product
+    // is used to esimate the plane of the print bed
+
+      #define ABL_PROBE_PT_1_X 15
+      #define ABL_PROBE_PT_1_Y 180
+      #define ABL_PROBE_PT_2_X 15
+      #define ABL_PROBE_PT_2_Y 20
+      #define ABL_PROBE_PT_3_X 170
+      #define ABL_PROBE_PT_3_Y 20
+
+  #endif // AUTO_BED_LEVELING_GRID
+
 
   // these are the offsets to the probe relative to the extruder tip (Hotend - Probe)
   #define X_PROBE_OFFSET_FROM_EXTRUDER -25
@@ -379,16 +417,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 
   #endif
 
-  // with accurate bed leveling, the bed is sampled in a ACCURATE_BED_LEVELING_POINTSxACCURATE_BED_LEVELING_POINTS grid and least squares solution is calculated
-  // Note: this feature occupies 10'206 byte
-  #define ACCURATE_BED_LEVELING
-
-  #ifdef ACCURATE_BED_LEVELING
-     // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
-    #define ACCURATE_BED_LEVELING_POINTS 2
-  #endif
-
-#endif
+#endif // ENABLE_AUTO_BED_LEVELING
 
 
 // The position of the homing switches
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 67cbfcc..bca056f 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -399,8 +399,14 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 // the moves are than replaced by the firmware controlled ones.
 
 // #define FWRETRACT  //ONLY PARTIALLY TESTED
-#define MIN_RETRACT 0.1 //minimum extruded mm to accept a automatic gcode retraction attempt
-
+#ifdef FWRETRACT
+  #define MIN_RETRACT 0.1                //minimum extruded mm to accept a automatic gcode retraction attempt
+  #define RETRACT_LENGTH 3               //default retract length (positive mm)
+  #define RETRACT_FEEDRATE 80*60         //default feedrate for retracting
+  #define RETRACT_ZLIFT 0                //default retract Z-lift
+  #define RETRACT_RECOVER_LENGTH 0       //default additional recover length (mm, added to retract length when recovering)
+  #define RETRACT_RECOVER_FEEDRATE 8*60  //default feedrate for recovering from retraction
+#endif
 
 //adds support for experimental filament exchange support M600; requires display
 #ifdef ULTIPANEL
diff --git a/Marlin/LCD Menu Tree.pdf b/Marlin/LCD Menu Tree.pdf
index 5e29d04..72b5911 100644
Binary files a/Marlin/LCD Menu Tree.pdf and b/Marlin/LCD Menu Tree.pdf differ
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index d79fc01..97866c8 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -1,5 +1,5 @@
 // Tonokip RepRap firmware rewrite based off of Hydra-mmm firmware.
-// Licence: GPL
+// License: GPL
 
 #ifndef MARLIN_H
 #define MARLIN_H
@@ -30,7 +30,7 @@
 # include "Arduino.h"
 #else
 # include "WProgram.h"
-  //Arduino < 1.0.0 does not define this, so we need to do it ourselfs
+  //Arduino < 1.0.0 does not define this, so we need to do it ourselves
 # define analogInputToDigitalPin(p) ((p) + A0)
 #endif
 
@@ -87,7 +87,7 @@ void serial_echopair_P(const char *s_P, double v);
 void serial_echopair_P(const char *s_P, unsigned long v);
 
 
-//things to write to serial from Programmemory. saves 400 to 2k of RAM.
+//Things to write to serial from Program memory. Saves 400 to 2k of RAM.
 FORCE_INLINE void serialprintPGM(const char *str)
 {
   char ch=pgm_read_byte(str);
@@ -184,8 +184,8 @@ void Stop();
 
 bool IsStopped();
 
-void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.
-void enquecommand_P(const char *cmd); //put an ascii command at the end of the current buffer, read from flash
+void enquecommand(const char *cmd); //put an ASCII command at the end of the current buffer.
+void enquecommand_P(const char *cmd); //put an ASCII command at the end of the current buffer, read from flash
 void prepare_arc_move(char isclockwise);
 void clamp_to_software_endstops(float target[3]);
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index d8a105d..d624470 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -31,7 +31,7 @@
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 #include "vector_3.h"
-  #ifdef ACCURATE_BED_LEVELING
+  #ifdef AUTO_BED_LEVELING_GRID
     #include "qr_solve.h"
   #endif
 #endif // ENABLE_AUTO_BED_LEVELING
@@ -63,7 +63,7 @@
 
 #define VERSION_STRING  "1.0.0"
 
-// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
+// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html
 // http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
 
 //Implemented Codes
@@ -76,11 +76,11 @@
 // G10 - retract filament according to settings of M207
 // G11 - retract recover filament according to settings of M208
 // G28 - Home all Axis
-// G29 - Detailed Z-Probe, probes the bed at 3 points.  You must de at the home position for this to work correctly.
+// G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
 // G30 - Single Z Probe, probes bed at current XY location.
 // G90 - Use Absolute Coordinates
 // G91 - Use Relative Coordinates
-// G92 - Set current position to cordinates given
+// G92 - Set current position to coordinates given
 
 // M Codes
 // M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
@@ -101,7 +101,7 @@
 // M31  - Output time since last M109 or SD card start to serial
 // M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
 //        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
-//        Call gcode file : "M32 P !filename#" and return to caller file after finishing (simiarl to #include).
+//        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
 //        The '#' is necessary when calling from within sd files, as it stops buffer prereading
 // M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
 // M80  - Turn on Power Supply
@@ -127,18 +127,18 @@
 // M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 // M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 // M140 - Set bed target temp
-// M150 - Set BlinkM Colour Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
+// M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
 // M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 //        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
 // M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
 // M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 // M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 // M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
 // M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-// M206 - set additional homeing offset
+// M206 - set additional homing offset
 // M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
 // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 // M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 // M220 S<factor in percent>- set speed factor override percentage
@@ -147,7 +147,7 @@
 // M240 - Trigger a camera to take a photograph
 // M250 - Set LCD contrast C<contrast value> (value 0..63)
 // M280 - set servo position absolute. P: servo index, S: angle or microseconds
-// M300 - Play beepsound S<frequency Hz> P<duration ms>
+// M300 - Play beep sound S<frequency Hz> P<duration ms>
 // M301 - Set PID parameters P I and D
 // M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
 // M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
@@ -155,14 +155,14 @@
 // M400 - Finish all moves
 // M401 - Lower z-probe if present
 // M402 - Raise z-probe if present
-// M500 - stores paramters in EEPROM
+// M500 - stores parameters in EEPROM
 // M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-// M503 - print the current settings (from memory not from eeprom)
+// M503 - print the current settings (from memory not from EEPROM)
 // M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
 // M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
 // M665 - set delta configurations
-// M666 - set delta endstop adjustemnt
+// M666 - set delta endstop adjustment
 // M605 - Set dual x-carriage movement mode: S<mode> [ X<duplication x-offset> R<duplication temp offset> ]
 // M907 - Set digital trimpot motor current using axis codes.
 // M908 - Control digital trimpot directly.
@@ -232,10 +232,13 @@ int EtoPPressure=0;
 #endif
 
 #ifdef FWRETRACT
-  bool autoretract_enabled=true;
+  bool autoretract_enabled=false;
   bool retracted=false;
-  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
-  float retract_recover_length=0, retract_recover_feedrate=8*60;
+  float retract_length = RETRACT_LENGTH;
+  float retract_feedrate = RETRACT_FEEDRATE;
+  float retract_zlift = RETRACT_ZLIFT;
+  float retract_recover_length = RETRACT_RECOVER_LENGTH;
+  float retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;
 #endif
 
 #ifdef ULTIPANEL
@@ -264,7 +267,7 @@ int EtoPPressure=0;
 #endif					
 
 //===========================================================================
-//=============================private variables=============================
+//=============================Private Variables=============================
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
@@ -284,7 +287,7 @@ static int buflen = 0;
 static char serial_char;
 static int serial_count = 0;
 static boolean comment_mode = false;
-static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
+static char *strchr_pointer; // just a pointer to find chars in the command string like X, Y, Z, E, etc
 
 const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
 
@@ -312,7 +315,7 @@ bool CooldownNoWait = true;
 bool target_direction;
 
 //===========================================================================
-//=============================ROUTINES=============================
+//=============================Routines======================================
 //===========================================================================
 
 void get_arc_coordinates();
@@ -349,7 +352,7 @@ void enquecommand(const char *cmd)
 {
   if(buflen < BUFSIZE)
   {
-    //this is dangerous if a mixing of serial and this happsens
+    //this is dangerous if a mixing of serial and this happens
     strcpy(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("enqueing \"");
@@ -364,7 +367,7 @@ void enquecommand_P(const char *cmd)
 {
   if(buflen < BUFSIZE)
   {
-    //this is dangerous if a mixing of serial and this happsens
+    //this is dangerous if a mixing of serial and this happens
     strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("enqueing \"");
@@ -671,9 +674,9 @@ void get_command()
     return;
   }
 
-  //'#' stops reading from sd to the buffer prematurely, so procedural macro calls are possible
-  // if it occures, stop_buffering is triggered and the buffer is ran dry.
-  // this character _can_ occure in serial com, due to checksums. however, no checksums are used in sd printing
+  //'#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible
+  // if it occurs, stop_buffering is triggered and the buffer is ran dry.
+  // this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing
 
   static bool stop_buffering=false;
   if(buflen==0) stop_buffering=false;
@@ -832,7 +835,7 @@ static void axis_is_at_home(int axis) {
 }
 
 #ifdef ENABLE_AUTO_BED_LEVELING
-#ifdef ACCURATE_BED_LEVELING
+#ifdef AUTO_BED_LEVELING_GRID
 static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
 {
     vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
@@ -856,42 +859,36 @@ static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 }
 
-#else
-static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yFront, float z_at_xLeft_yBack) {
-    plan_bed_level_matrix.set_to_identity();
+#else // not AUTO_BED_LEVELING_GRID
 
-    vector_3 xLeftyFront = vector_3(LEFT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, z_at_xLeft_yFront);
-    vector_3 xLeftyBack = vector_3(LEFT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION, z_at_xLeft_yBack);
-    vector_3 xRightyFront = vector_3(RIGHT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, z_at_xRight_yFront);
+static void set_bed_level_equation_3pts(float z_at_pt_1, float z_at_pt_2, float z_at_pt_3) {
 
-    vector_3 xPositive = (xRightyFront - xLeftyFront).get_normal();
-    vector_3 yPositive = (xLeftyBack - xLeftyFront).get_normal();
-    vector_3 planeNormal = vector_3::cross(xPositive, yPositive).get_normal();
+    plan_bed_level_matrix.set_to_identity();
 
-    //planeNormal.debug("planeNormal");
-    //yPositive.debug("yPositive");
-    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
-    //bedLevel.debug("bedLevel");
+    vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);
+    vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);
+    vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);
 
-    //plan_bed_level_matrix.debug("bed level before");
-    //vector_3 uncorrected_position = plan_get_position_mm();
-    //uncorrected_position.debug("position before");
+    vector_3 from_2_to_1 = (pt1 - pt2).get_normal();
+    vector_3 from_2_to_3 = (pt3 - pt2).get_normal();
+    vector_3 planeNormal = vector_3::cross(from_2_to_1, from_2_to_3).get_normal();
+    planeNormal = vector_3(planeNormal.x, planeNormal.y, abs(planeNormal.z));
 
-    // and set our bed level equation to do the right thing
-    //plan_bed_level_matrix.debug("bed level after");
+    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
     vector_3 corrected_position = plan_get_position();
-    //corrected_position.debug("position after");
     current_position[X_AXIS] = corrected_position.x;
     current_position[Y_AXIS] = corrected_position.y;
     current_position[Z_AXIS] = corrected_position.z;
 
-    // but the bed at 0 so we don't go below it.
+    // put the bed at 0 so we don't go below it.
     current_position[Z_AXIS] = zprobe_zoffset;
 
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+
 }
-#endif // ACCURATE_BED_LEVELING
+
+#endif // AUTO_BED_LEVELING_GRID
 
 static void run_z_probe() {
     plan_bed_level_matrix.set_to_identity();
@@ -1098,6 +1095,42 @@ void refresh_cmd_timeout(void)
   previous_millis_cmd = millis();
 }
 
+#ifdef FWRETRACT
+  void retract(bool retracting) {
+    if(retracting && !retracted) {
+      destination[X_AXIS]=current_position[X_AXIS];
+      destination[Y_AXIS]=current_position[Y_AXIS];
+      destination[Z_AXIS]=current_position[Z_AXIS];
+      destination[E_AXIS]=current_position[E_AXIS];
+      current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
+      plan_set_e_position(current_position[E_AXIS]);
+      float oldFeedrate = feedrate;
+      feedrate=retract_feedrate;
+      retracted=true;
+      prepare_move();
+      current_position[Z_AXIS]-=retract_zlift;
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      prepare_move();
+      feedrate = oldFeedrate;
+    } else if(!retracting && retracted) {
+      destination[X_AXIS]=current_position[X_AXIS];
+      destination[Y_AXIS]=current_position[Y_AXIS];
+      destination[Z_AXIS]=current_position[Z_AXIS];
+      destination[E_AXIS]=current_position[E_AXIS];
+      current_position[Z_AXIS]+=retract_zlift;
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+      //prepare_move();
+      current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
+      plan_set_e_position(current_position[E_AXIS]);
+      float oldFeedrate = feedrate;
+      feedrate=retract_recover_feedrate;
+      retracted=false;
+      prepare_move();
+      feedrate = oldFeedrate;
+    }
+  } //retract
+#endif //FWRETRACT
+
 void process_commands()
 {
   unsigned long codenum; //throw away variable
@@ -1113,6 +1146,18 @@ void process_commands()
     case 1: // G1
       if(Stopped == false) {
         get_coordinates(); // For X Y Z E F
+          #ifdef FWRETRACT
+            if(autoretract_enabled)
+            if( !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
+              float echange=destination[E_AXIS]-current_position[E_AXIS];
+              if((echange<-MIN_RETRACT && !retracted) || (echange>MIN_RETRACT && retracted)) { //move appears to be an attempt to retract or recover
+                  current_position[E_AXIS] = destination[E_AXIS]; //hide the slicer-generated retract/recover from calculations
+                  plan_set_e_position(current_position[E_AXIS]); //AND from the planner
+                  retract(!retracted);
+                  return;
+              }
+            }
+          #endif //FWRETRACT
         prepare_move();
         //ClearToSend();
         return;
@@ -1147,39 +1192,10 @@ void process_commands()
       break;
       #ifdef FWRETRACT
       case 10: // G10 retract
-      if(!retracted)
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS];
-        current_position[Z_AXIS]-=retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS];
-        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
-        plan_set_e_position(current_position[E_AXIS]);
-        float oldFeedrate = feedrate;
-        feedrate=retract_feedrate;
-        retracted=true;
-        prepare_move();
-        feedrate = oldFeedrate;
-      }
-
+        retract(true);
       break;
       case 11: // G11 retract_recover
-      if(retracted)
-      {
-        destination[X_AXIS]=current_position[X_AXIS];
-        destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS];
-        current_position[Z_AXIS]+=retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS];
-        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
-        plan_set_e_position(current_position[E_AXIS]);
-        float oldFeedrate = feedrate;
-        feedrate=retract_recover_feedrate;
-        retracted=false;
-        prepare_move();
-        feedrate = oldFeedrate;
-      }
+        retract(false);
       break;
       #endif //FWRETRACT
     case 28: //G28 Home all Axis one at a time
@@ -1232,7 +1248,7 @@ void process_commands()
 
 #else // NOT DELTA
 
-      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
+      home_all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])));
 
       #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
@@ -1394,12 +1410,21 @@ void process_commands()
       break;
 
 #ifdef ENABLE_AUTO_BED_LEVELING
-    case 29: // G29 Detailed Z-Probe, probes the bed at 3 points.
+    case 29: // G29 Detailed Z-Probe, probes the bed at 3 or more points.
         {
             #if Z_MIN_PIN == -1
             #error "You must have a Z_MIN endstop in order to enable Auto Bed Leveling feature!!! Z_MIN_PIN must point to a valid hardware pin."
             #endif
 
+            // Prevent user from running a G29 without first homing in X and Y
+            if (! (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) )
+            {
+                LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
+                SERIAL_ECHO_START;
+                SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
+                break; // abort G29, since we don't know where we are
+            }
+
             st_synchronize();
             // make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly
             //vector_3 corrected_position = plan_get_position_mm();
@@ -1414,10 +1439,11 @@ void process_commands()
             setup_for_endstop_move();
 
             feedrate = homing_feedrate[Z_AXIS];
-#ifdef ACCURATE_BED_LEVELING
+#ifdef AUTO_BED_LEVELING_GRID
+            // probe at the points of a lattice grid
 
-            int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
-            int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
+            int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);
+            int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);
 
 
             // solve the plane equation ax + by + d = z
@@ -1427,9 +1453,9 @@ void process_commands()
             // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
 
             // "A" matrix of the linear system of equations
-            double eqnAMatrix[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS*3];
+            double eqnAMatrix[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS*3];
             // "B" vector of Z points
-            double eqnBVector[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS];
+            double eqnBVector[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS];
 
 
             int probePointCounter = 0;
@@ -1452,7 +1478,7 @@ void process_commands()
                 zig = true;
               }
 
-              for (int xCount=0; xCount < ACCURATE_BED_LEVELING_POINTS; xCount++)
+              for (int xCount=0; xCount < AUTO_BED_LEVELING_GRID_POINTS; xCount++)
               {
                 float z_before;
                 if (probePointCounter == 0)
@@ -1469,9 +1495,9 @@ void process_commands()
 
                 eqnBVector[probePointCounter] = measured_z;
 
-                eqnAMatrix[probePointCounter + 0*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = xProbe;
-                eqnAMatrix[probePointCounter + 1*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = yProbe;
-                eqnAMatrix[probePointCounter + 2*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = 1;
+                eqnAMatrix[probePointCounter + 0*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = xProbe;
+                eqnAMatrix[probePointCounter + 1*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = yProbe;
+                eqnAMatrix[probePointCounter + 2*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = 1;
                 probePointCounter++;
                 xProbe += xInc;
               }
@@ -1479,7 +1505,7 @@ void process_commands()
             clean_up_after_endstop_move();
 
             // solve lsq problem
-            double *plane_equation_coefficients = qr_solve(ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS, 3, eqnAMatrix, eqnBVector);
+            double *plane_equation_coefficients = qr_solve(AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS, 3, eqnAMatrix, eqnBVector);
 
             SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[0]);
@@ -1493,24 +1519,24 @@ void process_commands()
 
             free(plane_equation_coefficients);
 
-#else // ACCURATE_BED_LEVELING not defined
-
+#else // AUTO_BED_LEVELING_GRID not defined
 
-            // prob 1
-            float z_at_xLeft_yBack = probe_pt(LEFT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION, Z_RAISE_BEFORE_PROBING);
+            // Probe at 3 arbitrary points
+            // probe 1
+            float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING);
 
-            // prob 2
-            float z_at_xLeft_yFront = probe_pt(LEFT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+            // probe 2
+            float z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
 
-            // prob 3
-            float z_at_xRight_yFront = probe_pt(RIGHT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+            // probe 3
+            float z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
 
             clean_up_after_endstop_move();
 
-            set_bed_level_equation(z_at_xLeft_yFront, z_at_xRight_yFront, z_at_xLeft_yBack);
+            set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
 
 
-#endif // ACCURATE_BED_LEVELING
+#endif // AUTO_BED_LEVELING_GRID
             st_synchronize();
 
             // The following code correct the Z height difference from z-probe position and hotend tip position.
@@ -2079,7 +2105,7 @@ void process_commands()
       }
       else
       {
-        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
+        bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS]))|| (code_seen(axis_codes[E_AXIS])));
         if(all_axis)
         {
           st_synchronize();
@@ -3048,42 +3074,6 @@ void get_coordinates()
     next_feedrate = code_value();
     if(next_feedrate > 0.0) feedrate = next_feedrate;
   }
-  #ifdef FWRETRACT
-  if(autoretract_enabled)
-  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
-  {
-    float echange=destination[E_AXIS]-current_position[E_AXIS];
-    if(echange<-MIN_RETRACT) //retract
-    {
-      if(!retracted)
-      {
-
-      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
-      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
-      float correctede=-echange-retract_length;
-      //to generate the additional steps, not the destination is changed, but inversely the current position
-      current_position[E_AXIS]+=-correctede;
-      feedrate=retract_feedrate;
-      retracted=true;
-      }
-
-    }
-    else
-      if(echange>MIN_RETRACT) //retract_recover
-    {
-      if(retracted)
-      {
-      //current_position[Z_AXIS]+=-retract_zlift;
-      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
-      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
-      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
-      feedrate=retract_recover_feedrate;
-      retracted=false;
-      }
-    }
-
-  }
-  #endif //FWRETRACT
 }
 
 void get_arc_coordinates()
diff --git a/Marlin/Menu Plans.xlsx b/Marlin/Menu Plans.xlsx
index 45a58e4..8c7e2c1 100644
Binary files a/Marlin/Menu Plans.xlsx and b/Marlin/Menu Plans.xlsx differ
diff --git a/Marlin/Servo.h b/Marlin/Servo.h
index 35e040c..204497a 100644
--- a/Marlin/Servo.h
+++ b/Marlin/Servo.h
@@ -24,7 +24,7 @@
 
   Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
   Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.
-  The sequence used to sieze timers is defined in timers.h
+  The sequence used to seize timers is defined in timers.h
 
   The methods are:
 
@@ -50,7 +50,7 @@
 /*
  * Defines for 16 bit timers used with  Servo library
  *
- * If _useTimerX is defined then TimerX is a 16 bit timer on the curent board
+ * If _useTimerX is defined then TimerX is a 16 bit timer on the current board
  * timer16_Sequence_t enumerates the sequence that the timers should be allocated
  * _Nbr_16timers indicates how many 16 bit timers are available.
  *
@@ -89,12 +89,12 @@ typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;
 typedef enum { _Nbr_16timers } timer16_Sequence_t ;
 #endif
 
-#define Servo_VERSION           2      // software version of this library
+#define Servo_VERSION           2     // software version of this library
 
 #define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo
 #define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo
 #define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
-#define REFRESH_INTERVAL    20000     // minumim time to refresh servos in microseconds
+#define REFRESH_INTERVAL    20000     // minimum time to refresh servos in microseconds
 
 #define SERVOS_PER_TIMER       12     // the maximum number of servos controlled by one timer
 #define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)
@@ -118,13 +118,13 @@ public:
   uint8_t attach(int pin);           // attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure
   uint8_t attach(int pin, int min, int max); // as above but also sets min and max values for writes.
   void detach();
-  void write(int value);             // if value is < 200 its treated as an angle, otherwise as pulse width in microseconds
+  void write(int value);             // if value is < 200 it is treated as an angle, otherwise as pulse width in microseconds
   void writeMicroseconds(int value); // Write pulse width in microseconds
   int read();                        // returns current pulse width as an angle between 0 and 180 degrees
   int readMicroseconds();            // returns current pulse width in microseconds for this servo (was read_us() in first release)
   bool attached();                   // return true if this servo is attached, otherwise false
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
-  int pin;                           // store the hw pin of the servo
+  int pin;                           // store the hardware pin of the servo
 #endif
 private:
    uint8_t servoIndex;               // index into the channel data for this servo
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index a969d56..53f8221 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -1,5 +1,5 @@
 /*
-  This code contibuted by Triffid_Hunter and modified by Kliment
+  This code contributed by Triffid_Hunter and modified by Kliment
   why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
 */
 
diff --git a/Marlin/language.h b/Marlin/language.h
index 2126f7f..025f9cf 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -17,6 +17,7 @@
 // 8  Portuguese
 // 9  Finnish
 // 10 Aragonese
+// 11 Dutch
 
 #ifndef LANGUAGE_CHOICE
 	#define LANGUAGE_CHOICE 1  // Pick your language from the list above
@@ -40,7 +41,7 @@
 		#define MACHINE_NAME "Mendel"
 	#endif
 
-// Default firmware set to Mendel	
+// Default firmware set to Mendel
 	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
 #endif
 
@@ -156,11 +157,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD card"	
+	#define MSG_INIT_SDCARD "Init. SD card"
 	#define MSG_CNG_SDCARD "Change SD card"
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -343,9 +344,9 @@
 	#define MSG_FILAMENTCHANGE "Zmien filament"
 	#define MSG_INIT_SDCARD "Inicjal. karty SD"
 	#define MSG_CNG_SDCARD "Zmiana karty SD"
-    #define MSG_ZPROBE_OUT "Sonda Z za lozem"
-    #define MSG_POSITION_UNKNOWN "Wroc w XY przed Z"
-    #define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_ZPROBE_OUT "Sonda Z za lozem"
+	#define MSG_POSITION_UNKNOWN "Wroc w XY przed Z"
+	#define MSG_ZPROBE_ZOFFSET "Offset Z"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -526,11 +527,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet F"
 	#define MSG_AUTORETRACT "Retract. Auto."
 	#define MSG_FILAMENTCHANGE "Changer filament"
-	#define MSG_INIT_SDCARD "Init. la carte SD"	
+	#define MSG_INIT_SDCARD "Init. la carte SD"
 	#define MSG_CNG_SDCARD "Changer de carte"
-    #define MSG_ZPROBE_OUT "Z sonde exte. lit"
-    #define MSG_POSITION_UNKNOWN "Rev. dans XY av.Z"
-    #define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_ZPROBE_OUT "Z sonde exte. lit"
+	#define MSG_POSITION_UNKNOWN "Rev. dans XY av.Z"
+	#define MSG_ZPROBE_ZOFFSET "Offset Z"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -611,7 +612,7 @@
 	#define MSG_BABYSTEPPING_Y "Babystepping Y"
 	#define MSG_BABYSTEPPING_Z "Babystepping Z"
 	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-	
+
 #endif
 
 
@@ -698,7 +699,7 @@
 	#define MSG_STOP_PRINT       "Druck stoppen"
 	#define MSG_CARD_MENU        "SDKarten Menü"
 	#define MSG_NO_CARD          "Keine SDKarte"
-	#define MSG_DWELL            "Warten..."		
+	#define MSG_DWELL            "Warten..."
 	#define MSG_USERWAIT         "Warte auf Nutzer"
 	#define MSG_RESUMING         "Druck fortsetzung"
 	#define MSG_NO_MOVE          "Kein Zug."
@@ -712,17 +713,17 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT      "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Filament wechseln"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_INIT_SDCARD "Init. SD-Card"
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
-	
+
 // Serial Console Messages
 
 	#define MSG_Enqueing "enqueing \""
@@ -905,9 +906,9 @@
 	#define MSG_CONTROL_ARROW "Control"
 	#define MSG_RETRACT_ARROW "Retraer"
 	#define MSG_STEPPER_RELEASED "Desacoplada."
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -1085,11 +1086,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF		"Возврат  F:"
 	#define MSG_AUTORETRACT						"АвтоОткат:"
 	#define MSG_FILAMENTCHANGE 					"Change filament"
-	#define MSG_INIT_SDCARD 					"Init. SD-Card"	
+	#define MSG_INIT_SDCARD 					"Init. SD-Card"
 	#define MSG_CNG_SDCARD 						"Change SD-Card"
-    #define MSG_ZPROBE_OUT 						"Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN 				"Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET 					"Z Offset"
+	#define MSG_ZPROBE_OUT 						"Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN 				"Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET 					"Z Offset"
 	#define MSG_BABYSTEP_X 						"Babystep X"
 	#define MSG_BABYSTEP_Y 						"Babystep Y"
 	#define MSG_BABYSTEP_Z 						"Babystep Z"
@@ -1268,9 +1269,9 @@
 	#define MSG_FILAMENTCHANGE       "Cambia filamento"
 	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
 	#define MSG_CNG_SDCARD           "Cambia SD-Card"
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -1455,11 +1456,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
 	#define MSG_AUTORETRACT " AutoRetr.:"
 	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_INIT_SDCARD "Init. SD-Card"
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "Son. fora da mesa"
-    #define MSG_POSITION_UNKNOWN "XY antes de Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Son. fora da mesa"
+	#define MSG_POSITION_UNKNOWN "XY antes de Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -1639,11 +1640,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT "AutoVeto."
 	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_INIT_SDCARD "Init. SD-Card"
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -1833,9 +1834,9 @@
 	#define MSG_CONTROL_ARROW "Control"
 	#define MSG_RETRACT_ARROW "Retraer"
 	#define MSG_STEPPER_RELEASED "Desacoplada."
-    #define MSG_ZPROBE_OUT "Z probe out. bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_ZPROBE_OUT "Z probe out. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
 	#define MSG_BABYSTEP_X "Babystep X"
 	#define MSG_BABYSTEP_Y "Babystep Y"
 	#define MSG_BABYSTEP_Z "Babystep Z"
@@ -1918,4 +1919,185 @@
 
 #endif
 
+#if LANGUAGE_CHOICE == 11 //Dutch
+
+// LCD Menu Messages
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " gereed."
+	#define MSG_SD_INSERTED "Kaart ingestoken"
+	#define MSG_SD_REMOVED "Kaart verwijderd"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Motoren uit"
+	#define MSG_AUTO_HOME "Auto home"
+	#define MSG_SET_ORIGIN "Nulpunt instellen"
+	#define MSG_PREHEAT_PLA "PLA voorverwarmen"
+	#define MSG_PREHEAT_PLA_SETTINGS "PLA verw. conf"
+	#define MSG_PREHEAT_ABS "ABS voorverwarmen"
+	#define MSG_PREHEAT_ABS_SETTINGS "ABS verw. conf"
+	#define MSG_COOLDOWN "Afkoelen"
+	#define MSG_SWITCH_PS_ON "Stroom aan"
+	#define MSG_SWITCH_PS_OFF "Stroom uit"
+	#define MSG_EXTRUDE "Extrude"
+	#define MSG_RETRACT "Retract"
+	#define MSG_MOVE_AXIS "As verplaatsen"
+	#define MSG_MOVE_X "Verplaats X"
+	#define MSG_MOVE_Y "Verplaats Y"
+	#define MSG_MOVE_Z "Verplaats Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Verplaats 0.1mm"
+	#define MSG_MOVE_1MM "Verplaats 1mm"
+	#define MSG_MOVE_10MM "Verplaats 10mm"
+	#define MSG_SPEED "Snelheid"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Bed"
+	#define MSG_FAN_SPEED "Fan snelheid"
+	#define MSG_FLOW "Flow"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "Aan "
+	#define MSG_OFF "Uit"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Versn"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VZ_JERK "Vz-jerk"
+	#define MSG_VE_JERK "Ve-jerk"
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-retract"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Terugtrekken"
+	#define MSG_TEMPERATURE "Temperatuur"
+	#define MSG_MOTION "Beweging"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM "Geheugen opslaan"
+	#define MSG_LOAD_EPROM "Geheugen laden"
+	#define MSG_RESTORE_FAILSAFE "Noodstop reset"
+	#define MSG_REFRESH "Ververs"
+	#define MSG_WATCH "Info scherm"
+	#define MSG_PREPARE "Voorbereiden"
+	#define MSG_TUNE "Afstellen"
+	#define MSG_PAUSE_PRINT "Print pauzeren"
+	#define MSG_RESUME_PRINT "Print hervatten"
+	#define MSG_STOP_PRINT "Print stoppen"
+	#define MSG_CARD_MENU "Print van SD"
+	#define MSG_NO_CARD "Geen SD kaart"
+	#define MSG_DWELL "Slapen..."
+	#define MSG_USERWAIT "Wachten..."
+	#define MSG_RESUMING "Print hervatten"
+	#define MSG_NO_MOVE "Geen beweging."
+	#define MSG_KILLED "AFGEBROKEN. "
+	#define MSG_STOPPED "GESTOPT. "
+	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACTF "Retract  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Verv. Filament"
+	#define MSG_INIT_SDCARD "Init. SD kaart"
+	#define MSG_CNG_SDCARD "Verv. SD card"
+	#define MSG_ZPROBE_OUT "Z probe uit. bed"
+	#define MSG_POSITION_UNKNOWN "Home X/Y voor Z"
+	#define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystap X"
+	#define MSG_BABYSTEP_Y "Babystap Y"
+	#define MSG_BABYSTEP_Z "Babystap Z"
+	#define MSG_ENDSTOP_ABORT "Endstop afbr."
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "Opstarten"
+	#define MSG_EXTERNAL_RESET " Externe Reset"
+	#define MSG_BROWNOUT_RESET " Lage voedingsspanning Reset"
+	#define MSG_WATCHDOG_RESET " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET " Software Reset"
+	#define MSG_AUTHOR " | Auteur: "
+	#define MSG_CONFIGURATION_VER " Laatst bijgewerkt: "
+	#define MSG_FREE_MEMORY " Vrij Geheugen: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Bestand opslaan voltooid."
+	#define MSG_ERR_LINE_NO "Regelnummer is niet het laatste regelnummer+1, Laatste regel: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "Checksum fout, Laatste regel: "
+	#define MSG_ERR_NO_CHECKSUM "Regel zonder checksum, Laatste regel: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Geen regelnummer met checksum, Laatste regel: "
+	#define MSG_FILE_PRINTED "Bestand afdrukken klaar"
+	#define MSG_BEGIN_FILE_LIST "Begin bestandslijst"
+	#define MSG_END_FILE_LIST "Einde bestandslijst"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Ongeldige extruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Ongeldige extruder "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Ongeldige extruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Ongeldige extruder "
+	#define MSG_ERR_NO_THERMISTORS "Geen thermistors - geen temperatuur"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Ongeldige extruder "
+	#define MSG_HEATING "Opwarmen..."
+	#define MSG_HEATING_COMPLETE "Opwarmen klaar."
+	#define MSG_BED_HEATING "Bed opwarmen."
+	#define MSG_BED_DONE "Bed klaar."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup voor gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
+	#define MSG_COUNT_X " Aantal X: "
+	#define MSG_ERR_KILLED "Printer stopgezet. kill() aangeroepen!"
+	#define MSG_ERR_STOPPED "Printer gestopt vanwege fouten. Los de fout op en gebruik M999 om opnieuw te starten. (Temperatuur is gereset, stel deze opnieuw in na herstart)"
+	#define MSG_RESEND "Opnieuw sturen: "
+	#define MSG_UNKNOWN_COMMAND "Onbekend commando: \""
+	#define MSG_ACTIVE_EXTRUDER "Actieve Extruder: "
+	#define MSG_INVALID_EXTRUDER "Ongeldige extruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Eindstop statusrapportage:"
+	#define MSG_ENDSTOP_HIT "GERAAKT"
+	#define MSG_ENDSTOP_OPEN "open"
+	#define MSG_HOTEND_OFFSET "Hotend afwijking:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Kan subdirectory niet openen"
+	#define MSG_SD_INIT_FAIL "SD initialiseren mislukt"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init mislukt"
+	#define MSG_SD_OPENROOT_FAIL "openRoot mislukt"
+	#define MSG_SD_CARD_OK "SD kaart ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir openen mislukt"
+	#define MSG_SD_OPEN_FILE_FAIL "Openen mislukt, bestand: "
+	#define MSG_SD_FILE_OPENED "Bestand geopend: "
+	#define MSG_SD_SIZE " Grootte: "
+	#define MSG_SD_FILE_SELECTED "Bestanden geselecteerd:"
+	#define MSG_SD_WRITE_TO_FILE "Schrijven naar bestand: "
+	#define MSG_SD_PRINTING_BYTE "SD printen byte: "
+	#define MSG_SD_NOT_PRINTING "Niet SD printen"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Fout tijdens het schrijven naar bestand:"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Kan subdirectory niet in: "
+
+	#define MSG_STEPPER_TOO_HIGH "stapsnelheid te hoog:"
+	#define MSG_ENDSTOPS_HIT "endstops geraakt: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Koude extrusie voorkomen"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " te lange extrusie voorkomen"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Fout in menustructuur"
+
+#endif
+
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 995fa54..9976d43 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -1781,8 +1781,8 @@
 #define Z_DIR_PIN          28
 #define Z_STOP_PIN         30
 
-#define E_STEP_PIN         17
-#define E_DIR_PIN          21
+#define E0_STEP_PIN         17
+#define E0_DIR_PIN          21
 
 #define LED_PIN            -1
 
@@ -1793,15 +1793,16 @@
 
 #define HEATER_0_PIN       12 // (extruder)
 
-#define HEATER_1_PIN       16 // (bed)
+#define HEATER_BED_PIN     16 // (bed)
 #define X_ENABLE_PIN       19
 #define Y_ENABLE_PIN       24
 #define Z_ENABLE_PIN       29
-#define E_ENABLE_PIN       13
+#define E0_ENABLE_PIN      13
 
 #define TEMP_0_PIN          0   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
-#define TEMP_1_PIN          5   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
+#define TEMP_1_PIN         -1   
 #define TEMP_2_PIN         -1
+#define TEMP_BED_PIN        5   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)  
 #define SDPOWER            -1
 #define SDSS               4
 #define HEATER_2_PIN       -1
diff --git a/Marlin/qr_solve.cpp b/Marlin/qr_solve.cpp
index 0a49128..f19d989 100644
--- a/Marlin/qr_solve.cpp
+++ b/Marlin/qr_solve.cpp
@@ -1,11 +1,9 @@
 #include "qr_solve.h"
 
-#ifdef ACCURATE_BED_LEVELING
+#ifdef AUTO_BED_LEVELING_GRID
 
 #include <stdlib.h>
 #include <math.h>
-#include <time.h>
-
 
 //# include "r8lib.h"
 
@@ -1173,7 +1171,7 @@ void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[],
 
   Discussion:
 
-    DQRLSS must be preceeded by a call to DQRANK.
+    DQRLSS must be preceded by a call to DQRANK.
 
     The system is to be solved is
       A * X = B
@@ -1225,7 +1223,7 @@ void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[],
     linear system.
 
     Output, double RSD[M], the residual, B - A*X.  RSD may
-    overwite B.
+    overwrite B.
 
     Input, int JPVT[N], the pivot information from DQRANK.
     Columns JPVT[0], ..., JPVT[KR-1] of the original matrix are linearly
@@ -1314,7 +1312,7 @@ int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[],
     can be replaced by dummy variables in the calling program.
     To save storage, the user may in some cases use the same
     array for different parameters in the calling sequence.  A
-    frequently occuring example is when one wishes to compute
+    frequently occurring example is when one wishes to compute
     any of B, RSD, or AB and does not need Y or QTY.  In this
     case one may identify Y, QTY, and one of B, RSD, or AB, while
     providing separate arrays for anything else that is to be
diff --git a/Marlin/qr_solve.h b/Marlin/qr_solve.h
index b756d1e..b38086a 100644
--- a/Marlin/qr_solve.h
+++ b/Marlin/qr_solve.h
@@ -1,6 +1,6 @@
 #include "Configuration.h"
 
-#ifdef ACCURATE_BED_LEVELING
+#ifdef AUTO_BED_LEVELING_GRID
 
 void daxpy ( int n, double da, double dx[], int incx, double dy[], int incy );
 double ddot ( int n, double dx[], int incx, double dy[], int incy );
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 3a1cb0b..1477a6e 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -71,8 +71,8 @@ float st_get_position_mm(uint8_t axis);
 void st_wake_up();
 
   
-void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered
-void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();
+void checkHitEndstops(); //call from somewhere to create an serial error message with the locations the endstops where hit, in case they were triggered
+void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homing and before a routine call of checkHitEndstops();
 
 void enable_endstops(bool check); // Enable/disable endstop checking
 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 66a097d..4ce5cb1 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -250,7 +250,7 @@ void PID_autotune(float temp, int extruder, int ncycles)
               Kp = 0.6*Ku;
               Ki = 2*Kp/Tu;
               Kd = Kp*Tu/8;
-              SERIAL_PROTOCOLLNPGM(" Clasic PID ");
+              SERIAL_PROTOCOLLNPGM(" Classic PID ");
               SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
               SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
               SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
@@ -306,7 +306,7 @@ void PID_autotune(float temp, int extruder, int ncycles)
       return;
     }
     if(cycles > ncycles) {
-      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the Kp, Ki and Kd constants into Configuration.h");
+      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the last Kp, Ki and Kd constants from above into Configuration.h");
       return;
     }
     lcd_update();
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 82de240..a8580de 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -28,7 +28,7 @@
 #endif
 
 // public functions
-void tp_init();  //initialise the heating
+void tp_init();  //initialize the heating
 void manage_heater(); //it is critical that this is called periodically.
 
 // low level conversion routines
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 8961b67..3262f2d 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -38,7 +38,7 @@ char lcd_status_message[LCD_WIDTH+1] = WELCOME_MSG;
 #include "ultralcd_implementation_hitachi_HD44780.h"
 #endif
 
-/** forward declerations **/
+/** forward declarations **/
 
 void copy_and_scalePID_i();
 void copy_and_scalePID_d();
@@ -62,9 +62,9 @@ static void lcd_set_contrast();
 static void lcd_control_retract_menu();
 static void lcd_sdcard_menu();
 
-static void lcd_quick_feedback();//Cause an LCD refresh, and give the user visual or audiable feedback that something has happend
+static void lcd_quick_feedback();//Cause an LCD refresh, and give the user visual or audible feedback that something has happened
 
-/* Different types of actions that can be used in menuitems. */
+/* Different types of actions that can be used in menu items. */
 static void menu_action_back(menuFunc_t data);
 static void menu_action_submenu(menuFunc_t data);
 static void menu_action_gcode(const char* pgcode);
@@ -145,7 +145,7 @@ static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned l
 #ifndef REPRAPWORLD_KEYPAD
 volatile uint8_t buttons;//Contains the bits of the currently pressed buttons.
 #else
-volatile uint8_t buttons_reprapworld_keypad; // to store the reprapworld_keypad shiftregister values
+volatile uint8_t buttons_reprapworld_keypad; // to store the reprapworld_keypad shift register values
 #endif
 #ifdef LCD_HAS_SLOW_BUTTONS
 volatile uint8_t slow_buttons;//Contains the bits of the currently pressed buttons.
@@ -162,7 +162,7 @@ bool lcd_oldcardstatus;
 menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */
 uint32_t lcd_next_update_millis;
 uint8_t lcd_status_update_delay;
-uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets atleast 1 full redraw (first redraw is partial) */
+uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial) */
 
 //prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.
 menuFunc_t prevMenu = NULL;
@@ -173,10 +173,10 @@ void* editValue;
 int32_t minEditValue, maxEditValue;
 menuFunc_t callbackFunc;
 
-// placeholders for Ki and Kd edits
+// place-holders for Ki and Kd edits
 float raw_Ki, raw_Kd;
 
-/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependend */
+/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependent */
 static void lcd_status_screen()
 {
     if (lcd_status_update_delay)
@@ -708,9 +708,9 @@ static void lcd_control_temperature_preheat_abs_settings_menu()
 static void lcd_control_motion_menu()
 {
     START_MENU();
-    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
 #ifdef ENABLE_AUTO_BED_LEVELING
-    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
+    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
 #endif
     MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
     MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);
@@ -1008,7 +1008,7 @@ void lcd_init()
     WRITE(SHIFT_LD,HIGH);
   #endif
 #else  // Not NEWPANEL
-  #ifdef SR_LCD_2W_NL // Non latching 2 wire shiftregister
+  #ifdef SR_LCD_2W_NL // Non latching 2 wire shift register
      pinMode (SR_DATA_PIN, OUTPUT);
      pinMode (SR_CLK_PIN, OUTPUT);
   #elif defined(SHIFT_CLK) 
@@ -1055,7 +1055,7 @@ void lcd_update()
     {
         lcdDrawUpdate = 2;
         lcd_oldcardstatus = IS_SD_INSERTED;
-        lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.
+        lcd_implementation_init(); // to maybe revive the LCD if static electricity killed it.
 
         if(lcd_oldcardstatus)
         {
@@ -1470,7 +1470,7 @@ char *ftostr52(const float &x)
 }
 
 // Callback for after editing PID i value
-// grab the pid i value out of the temp variable; scale it; then update the PID driver
+// grab the PID i value out of the temp variable; scale it; then update the PID driver
 void copy_and_scalePID_i()
 {
 #ifdef PIDTEMP
@@ -1480,7 +1480,7 @@ void copy_and_scalePID_i()
 }
 
 // Callback for after editing PID d value
-// grab the pid d value out of the temp variable; scale it; then update the PID driver
+// grab the PID d value out of the temp variable; scale it; then update the PID driver
 void copy_and_scalePID_d()
 {
 #ifdef PIDTEMP
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index d6fa0fd..f4570f6 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -17,7 +17,7 @@
   void lcd_setcontrast(uint8_t value);
 #endif
 
-  static unsigned char blink = 0;	// Variable for visualisation of fan rotation in GLCD
+  static unsigned char blink = 0;	// Variable for visualization of fan rotation in GLCD
 
   #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))
   #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))
@@ -29,7 +29,7 @@
   void lcd_buttons_update();
   extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
   #ifdef REPRAPWORLD_KEYPAD
-    extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shiftregister values
+    extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shift register values
   #endif
   #else
   FORCE_INLINE void lcd_buttons_update() {}
@@ -72,7 +72,7 @@
   	  #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_MIDDLE)
     #endif //REPRAPWORLD_KEYPAD
   #else
-    //atomatic, do not change
+    //atomic, do not change
     #define B_LE (1<<BL_LE)
     #define B_UP (1<<BL_UP)
     #define B_MI (1<<BL_MI)
@@ -85,7 +85,7 @@
     #define LCD_CLICKED ((buttons&B_MI)||(buttons&B_ST))
   #endif//NEWPANEL
 
-#else //no lcd
+#else //no LCD
   FORCE_INLINE void lcd_update() {}
   FORCE_INLINE void lcd_init() {}
   FORCE_INLINE void lcd_setstatus(const char* message) {}
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index ccb820b..932895b 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -2,8 +2,8 @@
 #define ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H
 
 /**
-* Implementation of the LCD display routines for a hitachi HD44780 display. These are common LCD character displays.
-* When selecting the rusian language, a slightly different LCD implementation is used to handle UTF8 characters.
+* Implementation of the LCD display routines for a Hitachi HD44780 display. These are common LCD character displays.
+* When selecting the Russian language, a slightly different LCD implementation is used to handle UTF8 characters.
 **/
 
 #ifndef REPRAPWORLD_KEYPAD
@@ -20,7 +20,7 @@ extern volatile uint16_t buttons;  //an extended version of the last checked but
 // via a shift/i2c register.
 
 #ifdef ULTIPANEL
-// All Ultipanels might have an encoder - so this is always be mapped onto first two bits
+// All UltiPanels might have an encoder - so this is always be mapped onto first two bits
 #define BLEN_B 1
 #define BLEN_A 0
 
@@ -725,15 +725,15 @@ static void lcd_implementation_quick_feedback()
       delayMicroseconds(100);
       WRITE(BEEPER,LOW);
       delayMicroseconds(100);
-    }
-    #else
+    }
+    #else
     for(int8_t i=0;i<(LCD_FEEDBACK_FREQUENCY_DURATION_MS / (1000 / LCD_FEEDBACK_FREQUENCY_HZ));i++)
     {
       WRITE(BEEPER,HIGH);
       delayMicroseconds(1000000 / LCD_FEEDBACK_FREQUENCY_HZ / 2);
       WRITE(BEEPER,LOW);
       delayMicroseconds(1000000 / LCD_FEEDBACK_FREQUENCY_HZ / 2);
-    }
+    }
     #endif
 #endif
 }

