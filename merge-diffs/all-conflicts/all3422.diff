commit 373f3ecab3ea9cb18d83d1899e7ff33cd515b0eb (from 9e7b5056a0a02921d1e31d511b34efc9732e3c88)
Merge: e36d31a 9e7b505
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Sun Jun 9 00:51:58 2013 +0200

    Merge branch 'deltabot' of https://github.com/jcrocholl/Marlin into deltabot
    
    Conflicts:
    	Marlin/Configuration.h
    	Marlin/Marlin_main.cpp
    	Marlin/pins.h

diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/boards.txt b/ArduinoAddons/Arduino_0.xx/Gen6/boards.txt
new file mode 100644
index 0000000..327d8d1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/boards.txt
@@ -0,0 +1,35 @@
+##############################################################
+
+Generation_Series.name=Gen6 & Gen6 Deluxe 
+Generation_Series.upload.protocol=stk500
+Generation_Series.upload.maximum_size=63488
+Generation_Series.upload.speed=38400
+Generation_Series.bootloader.low_fuses=0xFF
+Generation_Series.bootloader.high_fuses=0xDC
+Generation_Series.bootloader.extended_fuses=0xFD
+Generation_Series.bootloader.path=atmega644p
+Generation_Series.bootloader.file=ATmegaBOOT_644P.hex
+Generation_Series.bootloader.unlock_bits=0x3F
+Generation_Series.bootloader.lock_bits=0x0F
+Generation_Series.build.mcu=atmega644p
+Generation_Series.build.f_cpu=16000000L
+Generation_Series.build.core=arduino
+
+
+##############################################################
+
+
+Sanguinololu.name=Sanguinololu 1.2 and above
+Sanguinololu.upload.protocol=stk500
+Sanguinololu.upload.maximum_size=63488
+Sanguinololu.upload.speed=38400
+Sanguinololu.bootloader.low_fuses=0xFF
+Sanguinololu.bootloader.high_fuses=0xDC
+Sanguinololu.bootloader.extended_fuses=0xFD
+Sanguinololu.bootloader.path=atmega644p
+Sanguinololu.bootloader.file=ATmegaBOOT_644P.hex
+Sanguinololu.bootloader.unlock_bits=0x3F
+Sanguinololu.bootloader.lock_bits=0x0F
+Sanguinololu.build.mcu=atmega644p
+Sanguinololu.build.f_cpu=16000000L
+Sanguinololu.build.core=arduino
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..1711014
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,713 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_324P.hex
new file mode 100644
index 0000000..e67fe88
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_324P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D85E90E94067D88E0F2
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644.hex b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644.hex
new file mode 100644
index 0000000..d5557de
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644.hex
@@ -0,0 +1,120 @@
+:10F800000C94387C0C94557C0C94557C0C94557C51
+:10F810000C94557C0C94557C0C94557C0C94557C24
+:10F820000C94557C0C94557C0C94557C0C94557C14
+:10F830000C94557C0C94557C0C94557C0C94557C04
+:10F840000C94557C0C94557C0C94557C0C94557CF4
+:10F850000C94557C0C94557C0C94557C0C94557CE4
+:10F860000C94557C0C94557C0C94557C0C94557CD4
+:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
+:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
+:10F89000D9F712E0A0E0B1E001C01D92A930B10794
+:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
+:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
+:10F8C000CDBF882309F481E020E0482F552741155A
+:10F8D000510509F43DC0289A19821A821B821C82A4
+:10F8E0000BC089819A81AB81BC810196A11DB11D9C
+:10F8F00089839A83AB83BC8389819A81AB81BC81E4
+:10F9000080589E43A040B04060F3289819821A8224
+:10F910001B821C820BC089819A81AB81BC810196BC
+:10F92000A11DB11D89839A83AB83BC8389819A8190
+:10F93000AB81BC8180509A4FA040B04060F32F5FF4
+:10F94000822F992787FD9095841795070CF4C3CFD4
+:10F9500019821A821B821C8289819A81AB81BC81A7
+:10F9600080509147A240B040A0F489819A81AB8138
+:10F97000BC810196A11DB11D89839A83AB83BC8391
+:10F9800089819A81AB81BC8180509147A240B0406F
+:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
+:10F9A000CF910895EF92FF920F931F93EE24FF24BF
+:10F9B000870128988091C00087FD17C00894E11C3A
+:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
+:10F9D000080780E0180770F3E0910001F091010141
+:10F9E00009958091C00087FFE9CF289A8091C600D1
+:10F9F000992787FD90951F910F91FF90EF900895A3
+:10FA0000982F8091C00085FFFCCF9093C600089589
+:10FA10000E94D27C803271F0809102018F5F8093CE
+:10FA20000201853009F00895E0910001F091010193
+:10FA30000995089584E10E94007D80E10E94007D87
+:10FA40000895CF93C82F0E94D27C803241F08091DC
+:10FA500002018F5F80930201853081F40AC084E146
+:10FA60000E94007D8C2F0E94007D80E10E94007D1D
+:10FA700005C0E0910001F09101010995CF91089531
+:10FA8000282F90E007C08091C0008823E4F7809180
+:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
+:10FAA000CDBF000094B714BE809160008861809340
+:10FAB00060001092600091FF74C189E18093C400DE
+:10FAC0001092C50088E18093C10086E08093C20057
+:10FAD0005098589A209A83E00E94577C81E00E94B7
+:10FAE000577C0E94D27C8033B9F18133C1F18034DC
+:10FAF00009F456C0813409F45CC0823409F46EC044
+:10FB0000853409F471C0803539F1813509F4F3C0C9
+:10FB1000823511F1853509F4D3C0863509F4CBC09F
+:10FB2000843609F465C0843709F4EBC0853709F4DD
+:10FB3000D2C0863709F44AC0809102018F5F80935A
+:10FB40000201853071F6E0910001F0910101099503
+:10FB50000E94D27C803349F60E94087DC2CF0E9469
+:10FB6000D27CC82F803241F784E10E94007D81E47D
+:10FB70000E94007D86E50E94007D82E50E94007D56
+:10FB80008C2F0E94007D89E40E94007D83E50E9405
+:10FB9000007D80E50E94007D80E10E94007DA1CF74
+:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
+:10FBB00098CF0E94D27C803809F407C1813809F4BB
+:10FBC00000C1823809F4F9C0883921F080E00E9430
+:10FBD000217D87CF83E00E94217D83CF84E10E9435
+:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
+:10FBF0000E94D27C809306020E94D27C80930502F0
+:10FC0000809108028E7F809308020E94D27C853406
+:10FC100009F44BC0E5E0F1E0119281E0E438F80727
+:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
+:10FC30001816190678F405E011E00E94D27CF8014C
+:10FC400081938F0121968091050290910602C81739
+:10FC5000D90798F30E94D27C803209F06DCF809151
+:10FC6000080280FFB6C0C0E0D0E0209105023091CC
+:10FC7000060212161306B8F4E0910301F091040194
+:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
+:10FC9000FA9AF99A31962196C217D30798F3F093FE
+:10FCA0000401E093030184E175CF80910802816033
+:10FCB00080930802AFCF84E00E94407D80E087CF30
+:10FCC0000E94D27C809303010E94D27C8093040125
+:10FCD0000E94087D06CF0E94D27C803209F02CCF92
+:10FCE00084E10E94007D8EE10E94007D86E90E94F1
+:10FCF000007D89E04FCF0E94087D88E080936000FE
+:10FD0000FFCF0E94D27C809306020E94D27C809317
+:10FD100005020E94D27C853409F449C08091080212
+:10FD20008E7F809308028091030190910401880FD7
+:10FD3000991F90930401809303010E94D27C80322A
+:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
+:10FD50000502309106021216130608F01DCFE0913D
+:10FD60000301F09104018091080280FF96C0F99987
+:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
+:10FD80000301F09104013196F0930401E093030123
+:10FD900020910502309106022196C217D30718F36D
+:10FDA000FBCEE0910001F0910101099586CE809192
+:10FDB0000802816080930802C0CF80E10E94217D0B
+:10FDC00090CE81E00E94217D8CCE82E00E94217D38
+:10FDD00088CE8091030190910401880F991F909320
+:10FDE0000401809303018091050280FF09C0809186
+:10FDF00005029091060201969093060280930502F7
+:10FE0000F999FECF1127E0910301F0910401C5E0BB
+:10FE1000D1E08091050290910602103091F400919A
+:10FE2000570001700130D9F303E000935700E895C3
+:10FE30000091570001700130D9F301E100935700A0
+:10FE4000E895099019900091570001700130D9F39D
+:10FE500001E000935700E8951395103898F01127AA
+:10FE60000091570001700130D9F305E0009357006D
+:10FE7000E8950091570001700130D9F301E100933A
+:10FE80005700E8953296029709F0C7CF103011F06D
+:10FE90000296E5CF112484E17DCE869580FF06C0D1
+:10FEA0003196F0930401E093030176CF84910E9490
+:10FEB000007D2091050230910602E0910301F0914E
+:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
+:10FED000007D0E94D27C182F0E94007DC1362CF03C
+:10FEE000C75511363CF0175508C0C033D4F3C05382
+:10FEF0001136CCF710330CF01053C295C07FC10FF0
+:10FF00008C2F992787FD9095CF911F910895CF93BE
+:10FF1000282F992787FD9095807F907095958795DC
+:10FF20009595879595958795959587958A303CF019
+:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
+:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
+:0AFF50000E94007DCF910895FFCFBD
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..99a6ae1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..5714395
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0xF800
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Arduino.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Arduino.h
new file mode 100644
index 0000000..90ee918
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Arduino.h
@@ -0,0 +1 @@
+    #include "WProgram.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..bf7cb69
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,202 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer
+{
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+// fixed by Mark Sproul this is on the 644/644p
+//SIGNAL(SIG_USART_RECV)
+SIGNAL(USART0_RX_vect)
+{
+  unsigned char c  =  UDR0;
+  store_char(c, &rx_buffer);
+}
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+//
+// Drakelive  2012-09-04
+//
+#if ARDUINO >= 100 
+	size_t  HardwareSerial::write(uint8_t c)
+	{
+	  while (!((*_ucsra) & (1 << _udre)))
+	    ;
+
+	  *_udr = c;
+	}
+#else
+	void HardwareSerial::write(uint8_t c)
+	{
+	  while (!((*_ucsra) & (1 << _udre)))
+		 ;
+
+	  *_udr = c;
+	}        
+#endif
+
+// Drakelive  2012-09-04
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..89ebc7a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/HardwareSerial.h
@@ -0,0 +1,87 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    
+    //
+    // Drakelive  2012-09-04
+    //
+    #if ARDUINO >= 100 
+        virtual size_t write(uint8_t);
+    #else
+        virtual void write(uint8_t);
+    #endif
+     
+    // Drakelive  2012-09-04
+
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "usb_api.h"
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.cpp
new file mode 100644
index 0000000..4ee556d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.cpp
@@ -0,0 +1,220 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+void Print::write(const char *str)
+{
+  while (*str)
+    write(*str++);
+}
+
+/* default implementation: may be overridden */
+void Print::write(const uint8_t *buffer, size_t size)
+{
+  while (size--)
+    write(*buffer++);
+}
+
+void Print::print(const String &s)
+{
+  for (int i = 0; i < s.length(); i++) {
+    write(s[i]);
+  }
+}
+
+void Print::print(const char str[])
+{
+  write(str);
+}
+
+void Print::print(char c, int base)
+{
+  print((long) c, base);
+}
+
+void Print::print(unsigned char b, int base)
+{
+  print((unsigned long) b, base);
+}
+
+void Print::print(int n, int base)
+{
+  print((long) n, base);
+}
+
+void Print::print(unsigned int n, int base)
+{
+  print((unsigned long) n, base);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0) {
+    write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      print('-');
+      n = -n;
+    }
+    printNumber(n, 10);
+  } else {
+    printNumber(n, base);
+  }
+}
+
+void Print::print(unsigned long n, int base)
+{
+  if (base == 0) write(n);
+  else printNumber(n, base);
+}
+
+void Print::print(double n, int digits)
+{
+  printFloat(n, digits);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(const String &s)
+{
+  print(s);
+  println();
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(char c, int base)
+{
+  print(c, base);
+  println();
+}
+
+void Print::println(unsigned char b, int base)
+{
+  print(b, base);
+  println();
+}
+
+void Print::println(int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n, int digits)
+{
+  print(n, digits);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.h
new file mode 100644
index 0000000..3f9cb96
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Print.h
@@ -0,0 +1,77 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+     
+    //
+    // Drakelive  2012-09-04
+    //
+    #if ARDUINO >= 100 
+        virtual size_t write(uint8_t) = 0;
+    #else
+        virtual void write(uint8_t) = 0;
+    #endif
+     
+    // Drakelive  2012-09-04     
+
+    virtual void write(const char *str);
+    virtual void write(const uint8_t *buffer, size_t size);
+    
+    void print(const String &);
+    void print(const char[]);
+    void print(char, int = BYTE);
+    void print(unsigned char, int = BYTE);
+    void print(int, int = DEC);
+    void print(unsigned int, int = DEC);
+    void print(long, int = DEC);
+    void print(unsigned long, int = DEC);
+    void print(double, int = 2);
+
+    void println(const String &s);
+    void println(const char[]);
+    void println(char, int = BYTE);
+    void println(unsigned char, int = BYTE);
+    void println(int, int = DEC);
+    void println(unsigned int, int = DEC);
+    void println(long, int = DEC);
+    void println(unsigned long, int = DEC);
+    void println(double, int = 2);
+    void println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Stream.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Stream.h
new file mode 100644
index 0000000..93d8275
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Stream.h
@@ -0,0 +1,35 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+class Stream : public Print
+{
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..c3910e7
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/Tone.cpp
@@ -0,0 +1,601 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "wiring.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+// MLS: This does not make sense, the 3 options are the same
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WConstants.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..3b3e0c9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WInterrupts.c
@@ -0,0 +1,249 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WProgram.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WProgram.h
new file mode 100644
index 0000000..f73e760
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WProgram.h
@@ -0,0 +1,63 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+const static uint8_t A0 = 54;
+const static uint8_t A1 = 55;
+const static uint8_t A2 = 56;
+const static uint8_t A3 = 57;
+const static uint8_t A4 = 58;
+const static uint8_t A5 = 59;
+const static uint8_t A6 = 60;
+const static uint8_t A7 = 61;
+const static uint8_t A8 = 62;
+const static uint8_t A9 = 63;
+const static uint8_t A10 = 64;
+const static uint8_t A11 = 65;
+const static uint8_t A12 = 66;
+const static uint8_t A13 = 67;
+const static uint8_t A14 = 68;
+const static uint8_t A15 = 69;
+#else
+const static uint8_t A0 = 14;
+const static uint8_t A1 = 15;
+const static uint8_t A2 = 16;
+const static uint8_t A3 = 17;
+const static uint8_t A4 = 18;
+const static uint8_t A5 = 19;
+const static uint8_t A6 = 20;
+const static uint8_t A7 = 21;
+#endif
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/binary.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/main.cpp b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..d5fa6fe
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &DDRA,
+	(uint8_t) (uint16_t) &DDRB,
+	(uint8_t) (uint16_t) &DDRC,
+	(uint8_t) (uint16_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PORTA,
+	(uint8_t) (uint16_t) &PORTB,
+	(uint8_t) (uint16_t) &PORTC,
+	(uint8_t) (uint16_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PINA,
+	(uint8_t) (uint16_t) &PINB,
+	(uint8_t) (uint16_t) &PINC,
+	(uint8_t) (uint16_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..fd7ee5c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.c
new file mode 100644
index 0000000..b90d07e
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.c
@@ -0,0 +1,289 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+	sbi(TCCR1, CS10);
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+	
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.h
new file mode 100644
index 0000000..0a93678
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring.h
@@ -0,0 +1,136 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <math.h>
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..d248f4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_analog.c
@@ -0,0 +1,259 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+
+#if defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4A1)
+			case TIMER4A:
+				// connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				OCR4A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..0949da4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_digital.c
@@ -0,0 +1,166 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out |= bit;
+		SREG = oldSREG;
+	}
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..7449c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_private.h
@@ -0,0 +1,68 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+#include <math.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
index 4f71b8a..f18a5ff 100644
--- a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
@@ -14,3 +14,86 @@ sanguino.bootloader.lock_bits=0x0F
 sanguino.build.mcu=atmega644p
 sanguino.build.f_cpu=16000000L
 sanguino.build.core=arduino
+
+##############################################################
+
+atmega644.name=Sanguino W/ ATmega644P
+
+atmega644.upload.protocol=stk500
+atmega644.upload.maximum_size=63488
+atmega644.upload.speed=57600
+
+atmega644.bootloader.low_fuses=0xFF
+atmega644.bootloader.high_fuses=0x9A
+atmega644.bootloader.extended_fuses=0xFF
+atmega644.bootloader.path=atmega
+atmega644.bootloader.file=ATmegaBOOT_168_atmega644p.hex
+#atmega644.bootloader.file=ATmegaBOOT_644P.hex
+atmega644.bootloader.unlock_bits=0x3F
+atmega644.bootloader.lock_bits=0x0F
+
+atmega644.build.mcu=atmega644p
+atmega644.build.f_cpu=16000000L
+atmega644.build.core=arduino
+
+##############################################################
+
+atmega12848m.name=Sanguino W/ ATmega1284p 8mhz
+
+atmega12848m.upload.protocol=stk500
+atmega12848m.upload.maximum_size=131072
+atmega12848m.upload.speed=19200
+
+atmega12848m.bootloader.low_fuses=0xFD
+atmega12848m.bootloader.high_fuses=0x9A
+atmega12848m.bootloader.extended_fuses=0xFF
+atmega12848m.bootloader.path=atmega
+atmega12848m.bootloader.file=ATmegaBOOT_168_atmega1284p_8m.hex
+atmega12848m.bootloader.unlock_bits=0x3F
+atmega12848m.bootloader.lock_bits=0x0F
+
+atmega12848m.build.mcu=atmega1284p
+atmega12848m.build.f_cpu=8000000L
+atmega12848m.build.core=arduino
+
+##############################################################
+
+atmega1284.name=Sanguino W/ ATmega1284p 16mhz
+
+atmega1284.upload.protocol=stk500
+atmega1284.upload.maximum_size=131072
+atmega1284.upload.speed=57600
+
+atmega1284.bootloader.low_fuses=0xFF
+atmega1284.bootloader.high_fuses=0x9A
+atmega1284.bootloader.extended_fuses=0xFF
+atmega1284.bootloader.path=atmega
+atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
+atmega1284.bootloader.unlock_bits=0x3F
+atmega1284.bootloader.lock_bits=0x0F
+
+atmega1284.build.mcu=atmega1284p
+atmega1284.build.f_cpu=16000000L
+atmega1284.build.core=arduino
+
+
+##############################################################
+
+atmega1284s.name=Sanguino W/ ATmega1284p 20mhz
+
+atmega1284s.upload.protocol=stk500
+atmega1284s.upload.maximum_size=131072
+atmega1284s.upload.speed=57600
+
+atmega1284s.bootloader.low_fuses=0xFF
+atmega1284s.bootloader.high_fuses=0x9A
+atmega1284s.bootloader.extended_fuses=0xFF
+atmega1284s.bootloader.path=atmega
+atmega1284s.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
+atmega1284s.bootloader.unlock_bits=0x3F
+atmega1284s.bootloader.lock_bits=0x0F
+
+atmega1284s.build.mcu=atmega1284p
+atmega1284s.build.f_cpu=20000000L
+atmega1284s.build.core=arduino
+#
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/Makefile b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/Makefile
new file mode 100644
index 0000000..742fd4b
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/Makefile
@@ -0,0 +1,470 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+#
+# Instructions
+#
+# To make bootloader .hex file:
+# make diecimila
+# make lilypad
+# make ng
+# etc...
+#
+# To burn bootloader .hex file:
+# make diecimila_isp
+# make lilypad_isp
+# make ng_isp
+# etc...
+
+# program name should not be changed...
+PROGRAM    = optiboot
+
+# The default behavior is to build using tools that are in the users
+# current path variables, but we can also build using an installed
+# Arduino user IDE setup, or the Arduino source tree.
+# Uncomment this next lines to build within the arduino environment,
+# using the arduino-included avrgcc toolset (mac and pc)
+# ENV ?= arduino
+# ENV ?= arduinodev
+# OS ?= macosx
+# OS ?= windows
+
+
+# enter the parameters for the avrdude isp tool
+ISPTOOL    = stk500v2
+ISPPORT    = usb
+ISPSPEED   = -b 115200
+
+MCU_TARGET = atmega168
+LDSECTIONS  = -Wl,--section-start=.text=0x3e00 -Wl,--section-start=.version=0x3ffe
+
+# Build environments
+# Start of some ugly makefile-isms to allow optiboot to be built
+# in several different environments.  See the README.TXT file for
+# details.
+
+# default
+fixpath = $(1)
+
+ifeq ($(ENV), arduino)
+# For Arduino, we assume that we're connected to the optiboot directory
+# included with the arduino distribution, which means that the full set
+# of avr-tools are "right up there" in standard places.
+TOOLROOT = ../../../tools
+GCCROOT = $(TOOLROOT)/avr/bin/
+AVRDUDE_CONF = -C$(TOOLROOT)/avr/etc/avrdude.conf
+
+ifeq ($(OS), windows)
+# On windows, SOME of the tool paths will need to have backslashes instead
+# of forward slashes (because they use windows cmd.exe for execution instead
+# of a unix/mingw shell?)  We also have to ensure that a consistent shell
+# is used even if a unix shell is installed (ie as part of WINAVR)
+fixpath = $(subst /,\,$1)
+SHELL = cmd.exe
+endif
+
+else ifeq ($(ENV), arduinodev)
+# Arduino IDE source code environment.  Use the unpacked compilers created
+# by the build (you'll need to do "ant build" first.)
+ifeq ($(OS), macosx)
+TOOLROOT = ../../../../build/macosx/work/Arduino.app/Contents/Resources/Java/hardware/tools
+endif
+ifeq ($(OS), windows)
+TOOLROOT = ../../../../build/windows/work/hardware/tools
+endif
+
+GCCROOT = $(TOOLROOT)/avr/bin/
+AVRDUDE_CONF = -C$(TOOLROOT)/avr/etc/avrdude.conf
+
+else
+GCCROOT =
+AVRDUDE_CONF =
+endif
+#
+# End of build environment code.
+
+
+# the efuse should really be 0xf8; since, however, only the lower
+# three bits of that byte are used on the atmega168, avrdude gets
+# confused if you specify 1's for the higher bits, see:
+# http://tinker.it/now/2007/02/24/the-tale-of-avrdude-atmega168-and-extended-bits-fuses/
+#
+# similarly, the lock bits should be 0xff instead of 0x3f (to
+# unlock the bootloader section) and 0xcf instead of 0x2f (to
+# lock it), but since the high two bits of the lock byte are
+# unused, avrdude would get confused.
+
+ISPFUSES    = $(GCCROOT)avrdude $(AVRDUDE_CONF) -c $(ISPTOOL) \
+              -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
+              -e -u -U lock:w:0x3f:m -U efuse:w:0x$(EFUSE):m \
+              -U hfuse:w:0x$(HFUSE):m -U lfuse:w:0x$(LFUSE):m
+ISPFLASH    = $(GCCROOT)avrdude $(AVRDUDE_CONF) -c $(ISPTOOL) \
+              -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
+              -U flash:w:$(PROGRAM)_$(TARGET).hex -U lock:w:0x2f:m
+
+STK500 = "C:\Program Files\Atmel\AVR Tools\STK500\Stk500.exe"
+STK500-1 = $(STK500) -e -d$(MCU_TARGET) -pf -vf -if$(PROGRAM)_$(TARGET).hex \
+-lFF -LFF -f$(HFUSE)$(LFUSE) -EF8 -ms -q -cUSB -I200kHz -s -wt
+STK500-2 = $(STK500) -d$(MCU_TARGET) -ms -q -lCF -LCF -cUSB -I200kHz -s -wt
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE = -Os -fno-inline-small-functions -fno-split-wide-types -mshort-calls
+
+DEFS       = 
+LIBS       =
+
+CC         = $(GCCROOT)avr-gcc
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = $(LDSECTIONS) -Wl,--relax -Wl,--gc-sections -nostartfiles -nostdlib
+
+OBJCOPY        = $(GCCROOT)avr-objcopy
+OBJDUMP        = $(call fixpath,$(GCCROOT)avr-objdump)
+
+SIZE           = $(GCCROOT)avr-size
+
+# Test platforms
+# Virtual boot block test
+virboot328: TARGET = atmega328
+virboot328: MCU_TARGET = atmega328p
+virboot328: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200' '-DVIRTUAL_BOOT'
+virboot328: AVR_FREQ = 16000000L
+virboot328: LDSECTIONS  = -Wl,--section-start=.text=0x7e00 -Wl,--section-start=.version=0x7ffe
+virboot328: $(PROGRAM)_atmega328.hex
+virboot328: $(PROGRAM)_atmega328.lst
+
+# 20MHz clocked platforms
+#
+# These are capable of 230400 baud, or 115200 baud on PC (Arduino Avrdude issue)
+#
+
+pro20: TARGET = pro_20mhz
+pro20: MCU_TARGET = atmega168
+pro20: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+pro20: AVR_FREQ = 20000000L
+pro20: $(PROGRAM)_pro_20mhz.hex
+pro20: $(PROGRAM)_pro_20mhz.lst
+
+pro20_isp: pro20
+pro20_isp: TARGET = pro_20mhz
+# 2.7V brownout
+pro20_isp: HFUSE = DD
+# Full swing xtal (20MHz) 258CK/14CK+4.1ms
+pro20_isp: LFUSE = C6
+# 512 byte boot
+pro20_isp: EFUSE = 04
+pro20_isp: isp
+
+# 16MHz clocked platforms
+#
+# These are capable of 230400 baud, or 115200 baud on PC (Arduino Avrdude issue)
+#
+
+pro16: TARGET = pro_16MHz
+pro16: MCU_TARGET = atmega168
+pro16: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+pro16: AVR_FREQ = 16000000L
+pro16: $(PROGRAM)_pro_16MHz.hex
+pro16: $(PROGRAM)_pro_16MHz.lst
+
+pro16_isp: pro16
+pro16_isp: TARGET = pro_16MHz
+# 2.7V brownout
+pro16_isp: HFUSE = DD
+# Full swing xtal (20MHz) 258CK/14CK+4.1ms
+pro16_isp: LFUSE = C6
+# 512 byte boot
+pro16_isp: EFUSE = 04
+pro16_isp: isp
+
+# Diecimila, Duemilanove with m168, and NG use identical bootloaders
+# Call it "atmega168" for generality and clarity, keep "diecimila" for
+# backward compatibility of makefile
+#
+atmega168: TARGET = atmega168
+atmega168: MCU_TARGET = atmega168
+atmega168: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+atmega168: AVR_FREQ = 16000000L 
+atmega168: $(PROGRAM)_atmega168.hex
+atmega168: $(PROGRAM)_atmega168.lst
+
+atmega168_isp: atmega168
+atmega168_isp: TARGET = atmega168
+# 2.7V brownout
+atmega168_isp: HFUSE = DD
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+atmega168_isp: LFUSE = FF
+# 512 byte boot
+atmega168_isp: EFUSE = 04
+atmega168_isp: isp
+
+diecimila: TARGET = diecimila
+diecimila: MCU_TARGET = atmega168
+diecimila: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+diecimila: AVR_FREQ = 16000000L 
+diecimila: $(PROGRAM)_diecimila.hex
+diecimila: $(PROGRAM)_diecimila.lst
+
+diecimila_isp: diecimila
+diecimila_isp: TARGET = diecimila
+# 2.7V brownout
+diecimila_isp: HFUSE = DD
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+diecimila_isp: LFUSE = FF
+# 512 byte boot
+diecimila_isp: EFUSE = 04
+diecimila_isp: isp
+
+atmega328: TARGET = atmega328
+atmega328: MCU_TARGET = atmega328p
+atmega328: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+atmega328: AVR_FREQ = 16000000L
+atmega328: LDSECTIONS  = -Wl,--section-start=.text=0x7e00 -Wl,--section-start=.version=0x7ffe
+atmega328: $(PROGRAM)_atmega328.hex
+atmega328: $(PROGRAM)_atmega328.lst
+
+atmega328_isp: atmega328
+atmega328_isp: TARGET = atmega328
+atmega328_isp: MCU_TARGET = atmega328p
+# 512 byte boot, SPIEN
+atmega328_isp: HFUSE = DE
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+atmega328_isp: LFUSE = FF
+# 2.7V brownout
+atmega328_isp: EFUSE = 05
+atmega328_isp: isp
+
+atmega1284: TARGET = atmega1284p
+atmega1284: MCU_TARGET = atmega1284p
+atmega1284: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200' '-DBIGBOOT'
+atmega1284: AVR_FREQ = 16000000L
+atmega1284: LDSECTIONS  = -Wl,--section-start=.text=0x1fc00
+atmega1284: $(PROGRAM)_atmega1284p.hex
+atmega1284: $(PROGRAM)_atmega1284p.lst
+
+atmega1284_isp: atmega1284
+atmega1284_isp: TARGET = atmega1284p
+atmega1284_isp: MCU_TARGET = atmega1284p
+# 1024 byte boot
+atmega1284_isp: HFUSE = DE
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+atmega1284_isp: LFUSE = FF
+# 2.7V brownout
+atmega1284_isp: EFUSE = FD
+atmega1284_isp: isp
+
+# Sanguino has a minimum boot size of 1024 bytes, so enable extra functions
+#
+sanguino: TARGET = atmega644p
+sanguino: MCU_TARGET = atmega644p
+sanguino: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200' '-DBIGBOOT'
+sanguino: AVR_FREQ = 16000000L
+sanguino: LDSECTIONS  = -Wl,--section-start=.text=0xfc00
+sanguino: $(PROGRAM)_atmega644p.hex
+sanguino: $(PROGRAM)_atmega644p.lst
+
+sanguino_isp: sanguino
+sanguino_isp: TARGET = atmega644p
+sanguino_isp: MCU_TARGET = atmega644p
+# 1024 byte boot
+sanguino_isp: HFUSE = DE
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+sanguino_isp: LFUSE = FF
+# 2.7V brownout
+sanguino_isp: EFUSE = 05
+sanguino_isp: isp
+
+# Mega has a minimum boot size of 1024 bytes, so enable extra functions
+#mega: TARGET = atmega1280
+mega: MCU_TARGET = atmega1280
+mega: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200' '-DBIGBOOT'
+mega: AVR_FREQ = 16000000L
+mega: LDSECTIONS  = -Wl,--section-start=.text=0x1fc00
+mega: $(PROGRAM)_atmega1280.hex
+mega: $(PROGRAM)_atmega1280.lst
+
+mega_isp: mega
+mega_isp: TARGET = atmega1280
+mega_isp: MCU_TARGET = atmega1280
+# 1024 byte boot
+mega_isp: HFUSE = DE
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+mega_isp: LFUSE = FF
+# 2.7V brownout
+mega_isp: EFUSE = 05
+mega_isp: isp
+
+# ATmega8
+#
+atmega8: TARGET = atmega8
+atmega8: MCU_TARGET = atmega8
+atmega8: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+atmega8: AVR_FREQ = 16000000L 
+atmega8: LDSECTIONS  = -Wl,--section-start=.text=0x1e00 -Wl,--section-start=.version=0x1ffe
+atmega8: $(PROGRAM)_atmega8.hex
+atmega8: $(PROGRAM)_atmega8.lst
+
+atmega8_isp: atmega8
+atmega8_isp: TARGET = atmega8
+atmega8_isp: MCU_TARGET = atmega8
+# SPIEN, CKOPT, Bootsize=512B
+atmega8_isp: HFUSE = CC
+# 2.7V brownout, Low power xtal (16MHz) 16KCK/14CK+65ms
+atmega8_isp: LFUSE = BF
+atmega8_isp: isp
+
+# ATmega88
+#
+atmega88: TARGET = atmega88
+atmega88: MCU_TARGET = atmega88
+atmega88: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+atmega88: AVR_FREQ = 16000000L 
+atmega88: LDSECTIONS  = -Wl,--section-start=.text=0x1e00 -Wl,--section-start=.version=0x1ffe
+atmega88: $(PROGRAM)_atmega88.hex
+atmega88: $(PROGRAM)_atmega88.lst
+
+atmega88_isp: atmega88
+atmega88_isp: TARGET = atmega88
+atmega88_isp: MCU_TARGET = atmega88
+# 2.7V brownout
+atmega88_isp: HFUSE = DD
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+atemga88_isp: LFUSE = FF
+# 512 byte boot
+atmega88_isp: EFUSE = 04
+atmega88_isp: isp
+
+
+# 8MHz clocked platforms
+#
+# These are capable of 115200 baud
+#
+
+lilypad: TARGET = lilypad
+lilypad: MCU_TARGET = atmega168
+lilypad: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+lilypad: AVR_FREQ = 8000000L
+lilypad: $(PROGRAM)_lilypad.hex
+lilypad: $(PROGRAM)_lilypad.lst
+
+lilypad_isp: lilypad
+lilypad_isp: TARGET = lilypad
+# 2.7V brownout
+lilypad_isp: HFUSE = DD
+# Internal 8MHz osc (8MHz) Slow rising power
+lilypad_isp: LFUSE = E2
+# 512 byte boot
+lilypad_isp: EFUSE = 04
+lilypad_isp: isp
+
+lilypad_resonator: TARGET = lilypad_resonator
+lilypad_resonator: MCU_TARGET = atmega168
+lilypad_resonator: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+lilypad_resonator: AVR_FREQ = 8000000L
+lilypad_resonator: $(PROGRAM)_lilypad_resonator.hex
+lilypad_resonator: $(PROGRAM)_lilypad_resonator.lst
+
+lilypad_resonator_isp: lilypad_resonator
+lilypad_resonator_isp: TARGET = lilypad_resonator
+# 2.7V brownout
+lilypad_resonator_isp: HFUSE = DD
+# Full swing xtal (20MHz) 258CK/14CK+4.1ms
+lilypad_resonator_isp: LFUSE = C6
+# 512 byte boot
+lilypad_resonator_isp: EFUSE = 04
+lilypad_resonator_isp: isp
+
+pro8: TARGET = pro_8MHz
+pro8: MCU_TARGET = atmega168
+pro8: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+pro8: AVR_FREQ = 8000000L
+pro8: $(PROGRAM)_pro_8MHz.hex
+pro8: $(PROGRAM)_pro_8MHz.lst
+
+pro8_isp: pro8
+pro8_isp: TARGET = pro_8MHz
+# 2.7V brownout
+pro8_isp: HFUSE = DD
+# Full swing xtal (20MHz) 258CK/14CK+4.1ms
+pro8_isp: LFUSE = C6
+# 512 byte boot
+pro8_isp: EFUSE = 04
+pro8_isp: isp
+
+atmega328_pro8: TARGET = atmega328_pro_8MHz
+atmega328_pro8: MCU_TARGET = atmega328p
+atmega328_pro8: CFLAGS += '-DLED_START_FLASHES=3' '-DBAUD_RATE=115200'
+atmega328_pro8: AVR_FREQ = 8000000L
+atmega328_pro8: LDSECTIONS = -Wl,--section-start=.text=0x7e00 -Wl,--section-start=.version=0x7ffe
+atmega328_pro8: $(PROGRAM)_atmega328_pro_8MHz.hex
+atmega328_pro8: $(PROGRAM)_atmega328_pro_8MHz.lst
+
+atmega328_pro8_isp: atmega328_pro8
+atmega328_pro8_isp: TARGET = atmega328_pro_8MHz
+atmega328_pro8_isp: MCU_TARGET = atmega328p
+# 512 byte boot, SPIEN
+atmega328_pro8_isp: HFUSE = DE
+# Low power xtal (16MHz) 16KCK/14CK+65ms
+atmega328_pro8_isp: LFUSE = FF
+# 2.7V brownout
+atmega328_pro8_isp: EFUSE = 05
+atmega328_pro8_isp: isp
+
+# 1MHz clocked platforms
+#
+# These are capable of 9600 baud
+#
+
+luminet: TARGET = luminet
+luminet: MCU_TARGET = attiny84
+luminet: CFLAGS += '-DLED_START_FLASHES=3' '-DSOFT_UART' '-DBAUD_RATE=9600'
+luminet: CFLAGS += '-DVIRTUAL_BOOT_PARTITION'
+luminet: AVR_FREQ = 1000000L
+luminet: LDSECTIONS = -Wl,--section-start=.text=0x1d00 -Wl,--section-start=.version=0x1efe
+luminet: $(PROGRAM)_luminet.hex
+luminet: $(PROGRAM)_luminet.lst
+
+luminet_isp: luminet
+luminet_isp: TARGET = luminet
+luminet_isp: MCU_TARGET = attiny84
+# Brownout disabled
+luminet_isp: HFUSE = DF
+# 1MHz internal oscillator, slowly rising power
+luminet_isp: LFUSE = 62
+# Self-programming enable
+luminet_isp: EFUSE = FE
+luminet_isp: isp
+
+#
+# Generic build instructions
+#
+#
+
+isp: $(TARGET)
+        $(ISPFUSES)
+        $(ISPFLASH)
+
+isp-stk500: $(PROGRAM)_$(TARGET).hex
+        $(STK500-1)
+        $(STK500-2)
+
+%.elf: $(OBJ)
+        $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+        $(SIZE) $@
+
+clean:
+        rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+
+%.lst: %.elf
+        $(OBJDUMP) -h -S $< > $@
+
+%.hex: %.elf
+        $(OBJCOPY) -j .text -j .data -j .version --set-section-flags .version=alloc,load -O ihex $< $@
+
+%.srec: %.elf
+        $(OBJCOPY) -j .text -j .data -j .version --set-section-flags .version=alloc,load -O srec $< $@
+
+%.bin: %.elf
+        $(OBJCOPY) -j .text -j .data -j .version --set-section-flags .version=alloc,load -O binary $< $@
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/boot.h b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/boot.h
new file mode 100644
index 0000000..136273a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/boot.h
@@ -0,0 +1,848 @@
+/* Modified to use out for SPM access
+** Peter Knight, Optiboot project http://optiboot.googlecode.com
+**
+** Todo: Tidy up
+**
+** "_short" routines execute 1 cycle faster and use 1 less word of flash
+** by using "out" instruction instead of "sts".
+**
+** Additional elpm variants that trust the value of RAMPZ
+*/
+
+/* Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007  Eric B. Weddington
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+
+   * Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   * Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in
+     the documentation and/or other materials provided with the
+     distribution.
+   * Neither the name of the copyright holders nor the names of
+     contributors may be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE. */
+
+/* $Id: boot.h,v 1.27.2.3 2008/09/30 13:58:48 arcanum Exp $ */
+
+#ifndef _AVR_BOOT_H_
+#define _AVR_BOOT_H_    1
+
+/** \file */
+/** \defgroup avr_boot <avr/boot.h>: Bootloader Support Utilities
+    \code
+    #include <avr/io.h>
+    #include <avr/boot.h>
+    \endcode
+
+    The macros in this module provide a C language interface to the
+    bootloader support functionality of certain AVR processors. These
+    macros are designed to work with all sizes of flash memory.
+
+    Global interrupts are not automatically disabled for these macros. It
+    is left up to the programmer to do this. See the code example below. 
+    Also see the processor datasheet for caveats on having global interrupts 
+    enabled during writing of the Flash.
+
+    \note Not all AVR processors provide bootloader support. See your
+    processor datasheet to see if it provides bootloader support.
+
+    \todo From email with Marek: On smaller devices (all except ATmega64/128),
+    __SPM_REG is in the I/O space, accessible with the shorter "in" and "out"
+    instructions - since the boot loader has a limited size, this could be an
+    important optimization.
+
+    \par API Usage Example
+    The following code shows typical usage of the boot API.
+
+    \code
+    #include <inttypes.h>
+    #include <avr/interrupt.h>
+    #include <avr/pgmspace.h>
+    
+    void boot_program_page (uint32_t page, uint8_t *buf)
+    {
+        uint16_t i;
+        uint8_t sreg;
+
+        // Disable interrupts.
+
+        sreg = SREG;
+        cli();
+    
+        eeprom_busy_wait ();
+
+        boot_page_erase (page);
+        boot_spm_busy_wait ();      // Wait until the memory is erased.
+
+        for (i=0; i<SPM_PAGESIZE; i+=2)
+        {
+            // Set up little-endian word.
+
+            uint16_t w = *buf++;
+            w += (*buf++) << 8;
+        
+            boot_page_fill (page + i, w);
+        }
+
+        boot_page_write (page);     // Store buffer in flash page.
+        boot_spm_busy_wait();       // Wait until the memory is written.
+
+        // Reenable RWW-section again. We need this if we want to jump back
+        // to the application after bootloading.
+
+        boot_rww_enable ();
+
+        // Re-enable interrupts (if they were ever enabled).
+
+        SREG = sreg;
+    }\endcode */
+
+#include <avr/eeprom.h>
+#include <avr/io.h>
+#include <inttypes.h>
+#include <limits.h>
+
+/* Check for SPM Control Register in processor. */
+#if defined (SPMCSR)
+#  define __SPM_REG    SPMCSR
+#elif defined (SPMCR)
+#  define __SPM_REG    SPMCR
+#else
+#  error AVR processor does not provide bootloader support!
+#endif
+
+
+/* Check for SPM Enable bit. */
+#if defined(SPMEN)
+#  define __SPM_ENABLE  SPMEN
+#elif defined(SELFPRGEN)
+#  define __SPM_ENABLE  SELFPRGEN
+#else
+#  error Cannot find SPM Enable bit definition!
+#endif
+
+/** \ingroup avr_boot
+    \def BOOTLOADER_SECTION
+
+    Used to declare a function or variable to be placed into a
+    new section called .bootloader. This section and its contents
+    can then be relocated to any address (such as the bootloader
+    NRWW area) at link-time. */
+
+#define BOOTLOADER_SECTION    __attribute__ ((section (".bootloader")))
+
+/* Create common bit definitions. */
+#ifdef ASB
+#define __COMMON_ASB    ASB
+#else
+#define __COMMON_ASB    RWWSB
+#endif
+
+#ifdef ASRE
+#define __COMMON_ASRE   ASRE
+#else
+#define __COMMON_ASRE   RWWSRE
+#endif
+
+/* Define the bit positions of the Boot Lock Bits. */
+
+#define BLB12           5
+#define BLB11           4
+#define BLB02           3
+#define BLB01           2
+
+/** \ingroup avr_boot
+    \def boot_spm_interrupt_enable()
+    Enable the SPM interrupt. */
+
+#define boot_spm_interrupt_enable()   (__SPM_REG |= (uint8_t)_BV(SPMIE))
+
+/** \ingroup avr_boot
+    \def boot_spm_interrupt_disable()
+    Disable the SPM interrupt. */
+
+#define boot_spm_interrupt_disable()  (__SPM_REG &= (uint8_t)~_BV(SPMIE))
+
+/** \ingroup avr_boot
+    \def boot_is_spm_interrupt()
+    Check if the SPM interrupt is enabled. */
+
+#define boot_is_spm_interrupt()       (__SPM_REG & (uint8_t)_BV(SPMIE))
+
+/** \ingroup avr_boot
+    \def boot_rww_busy()
+    Check if the RWW section is busy. */
+
+#define boot_rww_busy()          (__SPM_REG & (uint8_t)_BV(__COMMON_ASB))
+
+/** \ingroup avr_boot
+    \def boot_spm_busy()
+    Check if the SPM instruction is busy. */
+
+#define boot_spm_busy()               (__SPM_REG & (uint8_t)_BV(__SPM_ENABLE))
+
+/** \ingroup avr_boot
+    \def boot_spm_busy_wait()
+    Wait while the SPM instruction is busy. */
+
+#define boot_spm_busy_wait()          do{}while(boot_spm_busy())
+
+#define __BOOT_PAGE_ERASE         (_BV(__SPM_ENABLE) | _BV(PGERS))
+#define __BOOT_PAGE_WRITE         (_BV(__SPM_ENABLE) | _BV(PGWRT))
+#define __BOOT_PAGE_FILL          _BV(__SPM_ENABLE)
+#define __BOOT_RWW_ENABLE         (_BV(__SPM_ENABLE) | _BV(__COMMON_ASRE))
+#define __BOOT_LOCK_BITS_SET      (_BV(__SPM_ENABLE) | _BV(BLBSET))
+
+#define __boot_page_fill_short(address, data)   \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw  r0, %3\n\t"                       \
+        "out %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        "clr  r1\n\t"                            \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_FILL),       \
+          "z" ((uint16_t)address),               \
+          "r" ((uint16_t)data)                   \
+        : "r0"                                   \
+    );                                           \
+}))
+
+#define __boot_page_fill_normal(address, data)   \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw  r0, %3\n\t"                       \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        "clr  r1\n\t"                            \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_FILL),       \
+          "z" ((uint16_t)address),               \
+          "r" ((uint16_t)data)                   \
+        : "r0"                                   \
+    );                                           \
+}))
+
+#define __boot_page_fill_alternate(address, data)\
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw  r0, %3\n\t"                       \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        ".word 0xffff\n\t"                       \
+        "nop\n\t"                                \
+        "clr  r1\n\t"                            \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_FILL),       \
+          "z" ((uint16_t)address),               \
+          "r" ((uint16_t)data)                   \
+        : "r0"                                   \
+    );                                           \
+}))
+
+#define __boot_page_fill_extended(address, data) \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw  r0, %4\n\t"                       \
+        "movw r30, %A3\n\t"                      \
+        "sts %1, %C3\n\t"                        \
+        "sts %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        "clr  r1\n\t"                            \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "i" (_SFR_MEM_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_FILL),       \
+          "r" ((uint32_t)address),               \
+          "r" ((uint16_t)data)                   \
+        : "r0", "r30", "r31"                     \
+    );                                           \
+}))
+
+#define __boot_page_fill_extended_short(address, data) \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw  r0, %4\n\t"                       \
+        "movw r30, %A3\n\t"                      \
+        "out %1, %C3\n\t"                        \
+        "out %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        "clr  r1\n\t"                            \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "i" (_SFR_IO_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_FILL),       \
+          "r" ((uint32_t)address),               \
+          "r" ((uint16_t)data)                   \
+        : "r0", "r30", "r31"                     \
+    );                                           \
+}))
+
+#define __boot_page_erase_short(address)        \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "out %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_ERASE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+
+#define __boot_page_erase_normal(address)        \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_ERASE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+#define __boot_page_erase_alternate(address)     \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        ".word 0xffff\n\t"                       \
+        "nop\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_ERASE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+#define __boot_page_erase_extended(address)      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw r30, %A3\n\t"                      \
+        "sts  %1, %C3\n\t"                       \
+        "sts %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "i" (_SFR_MEM_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_ERASE),      \
+          "r" ((uint32_t)address)                \
+        : "r30", "r31"                           \
+    );                                           \
+}))
+#define __boot_page_erase_extended_short(address)      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw r30, %A3\n\t"                      \
+        "out  %1, %C3\n\t"                       \
+        "out %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "i" (_SFR_IO_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_ERASE),      \
+          "r" ((uint32_t)address)                \
+        : "r30", "r31"                           \
+    );                                           \
+}))
+
+#define __boot_page_write_short(address)        \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "out %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_WRITE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+#define __boot_page_write_normal(address)        \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_WRITE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+#define __boot_page_write_alternate(address)     \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        ".word 0xffff\n\t"                       \
+        "nop\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_PAGE_WRITE),      \
+          "z" ((uint16_t)address)                \
+    );                                           \
+}))
+
+#define __boot_page_write_extended(address)      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw r30, %A3\n\t"                      \
+        "sts %1, %C3\n\t"                        \
+        "sts %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "i" (_SFR_MEM_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_WRITE),      \
+          "r" ((uint32_t)address)                \
+        : "r30", "r31"                           \
+    );                                           \
+}))
+#define __boot_page_write_extended_short(address)      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "movw r30, %A3\n\t"                      \
+        "out %1, %C3\n\t"                        \
+        "out %0, %2\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "i" (_SFR_IO_ADDR(RAMPZ)),            \
+          "r" ((uint8_t)__BOOT_PAGE_WRITE),      \
+          "r" ((uint32_t)address)                \
+        : "r30", "r31"                           \
+    );                                           \
+}))
+
+#define __boot_rww_enable_short()                      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "out %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_RWW_ENABLE)       \
+    );                                           \
+}))
+
+#define __boot_rww_enable()                      \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_RWW_ENABLE)       \
+    );                                           \
+}))
+
+#define __boot_rww_enable_alternate()            \
+(__extension__({                                 \
+    __asm__ __volatile__                         \
+    (                                            \
+        "sts %0, %1\n\t"                         \
+        "spm\n\t"                                \
+        ".word 0xffff\n\t"                       \
+        "nop\n\t"                                \
+        :                                        \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t)__BOOT_RWW_ENABLE)       \
+    );                                           \
+}))
+
+/* From the mega16/mega128 data sheets (maybe others):
+
+     Bits by SPM To set the Boot Loader Lock bits, write the desired data to
+     R0, write "X0001001" to SPMCR and execute SPM within four clock cycles
+     after writing SPMCR. The only accessible Lock bits are the Boot Lock bits
+     that may prevent the Application and Boot Loader section from any
+     software update by the MCU.
+
+     If bits 5..2 in R0 are cleared (zero), the corresponding Boot Lock bit
+     will be programmed if an SPM instruction is executed within four cycles
+     after BLBSET and SPMEN (or SELFPRGEN) are set in SPMCR. The Z-pointer is 
+     don't care during this operation, but for future compatibility it is 
+     recommended to load the Z-pointer with $0001 (same as used for reading the 
+     Lock bits). For future compatibility It is also recommended to set bits 7, 
+     6, 1, and 0 in R0 to 1 when writing the Lock bits. When programming the 
+     Lock bits the entire Flash can be read during the operation. */
+
+#define __boot_lock_bits_set_short(lock_bits)                    \
+(__extension__({                                           \
+    uint8_t value = (uint8_t)(~(lock_bits));               \
+    __asm__ __volatile__                                   \
+    (                                                      \
+        "ldi r30, 1\n\t"                                   \
+        "ldi r31, 0\n\t"                                   \
+        "mov r0, %2\n\t"                                   \
+        "out %0, %1\n\t"                                   \
+        "spm\n\t"                                          \
+        :                                                  \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),                  \
+          "r" ((uint8_t)__BOOT_LOCK_BITS_SET),             \
+          "r" (value)                                      \
+        : "r0", "r30", "r31"                               \
+    );                                                     \
+}))
+
+#define __boot_lock_bits_set(lock_bits)                    \
+(__extension__({                                           \
+    uint8_t value = (uint8_t)(~(lock_bits));               \
+    __asm__ __volatile__                                   \
+    (                                                      \
+        "ldi r30, 1\n\t"                                   \
+        "ldi r31, 0\n\t"                                   \
+        "mov r0, %2\n\t"                                   \
+        "sts %0, %1\n\t"                                   \
+        "spm\n\t"                                          \
+        :                                                  \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),                  \
+          "r" ((uint8_t)__BOOT_LOCK_BITS_SET),             \
+          "r" (value)                                      \
+        : "r0", "r30", "r31"                               \
+    );                                                     \
+}))
+
+#define __boot_lock_bits_set_alternate(lock_bits)          \
+(__extension__({                                           \
+    uint8_t value = (uint8_t)(~(lock_bits));               \
+    __asm__ __volatile__                                   \
+    (                                                      \
+        "ldi r30, 1\n\t"                                   \
+        "ldi r31, 0\n\t"                                   \
+        "mov r0, %2\n\t"                                   \
+        "sts %0, %1\n\t"                                   \
+        "spm\n\t"                                          \
+        ".word 0xffff\n\t"                                 \
+        "nop\n\t"                                          \
+        :                                                  \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),                  \
+          "r" ((uint8_t)__BOOT_LOCK_BITS_SET),             \
+          "r" (value)                                      \
+        : "r0", "r30", "r31"                               \
+    );                                                     \
+}))
+
+/*
+   Reading lock and fuse bits:
+
+     Similarly to writing the lock bits above, set BLBSET and SPMEN (or 
+     SELFPRGEN) bits in __SPMREG, and then (within four clock cycles) issue an 
+     LPM instruction.
+
+     Z address:       contents:
+     0x0000           low fuse bits
+     0x0001           lock bits
+     0x0002           extended fuse bits
+     0x0003           high fuse bits
+
+     Sounds confusing, doesn't it?
+
+     Unlike the macros in pgmspace.h, no need to care for non-enhanced
+     cores here as these old cores do not provide SPM support anyway.
+ */
+
+/** \ingroup avr_boot
+    \def GET_LOW_FUSE_BITS
+    address to read the low fuse bits, using boot_lock_fuse_bits_get
+ */
+#define GET_LOW_FUSE_BITS           (0x0000)
+/** \ingroup avr_boot
+    \def GET_LOCK_BITS
+    address to read the lock bits, using boot_lock_fuse_bits_get
+ */
+#define GET_LOCK_BITS               (0x0001)
+/** \ingroup avr_boot
+    \def GET_EXTENDED_FUSE_BITS
+    address to read the extended fuse bits, using boot_lock_fuse_bits_get
+ */
+#define GET_EXTENDED_FUSE_BITS      (0x0002)
+/** \ingroup avr_boot
+    \def GET_HIGH_FUSE_BITS
+    address to read the high fuse bits, using boot_lock_fuse_bits_get
+ */
+#define GET_HIGH_FUSE_BITS          (0x0003)
+
+/** \ingroup avr_boot
+    \def boot_lock_fuse_bits_get(address)
+
+    Read the lock or fuse bits at \c address.
+
+    Parameter \c address can be any of GET_LOW_FUSE_BITS,
+    GET_LOCK_BITS, GET_EXTENDED_FUSE_BITS, or GET_HIGH_FUSE_BITS.
+
+    \note The lock and fuse bits returned are the physical values,
+    i.e. a bit returned as 0 means the corresponding fuse or lock bit
+    is programmed.
+ */
+#define boot_lock_fuse_bits_get_short(address)                   \
+(__extension__({                                           \
+    uint8_t __result;                                      \
+    __asm__ __volatile__                                   \
+    (                                                      \
+        "ldi r30, %3\n\t"                                  \
+        "ldi r31, 0\n\t"                                   \
+        "out %1, %2\n\t"                                   \
+        "lpm %0, Z\n\t"                                    \
+        : "=r" (__result)                                  \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),                  \
+          "r" ((uint8_t)__BOOT_LOCK_BITS_SET),             \
+          "M" (address)                                    \
+        : "r0", "r30", "r31"                               \
+    );                                                     \
+    __result;                                              \
+}))
+
+#define boot_lock_fuse_bits_get(address)                   \
+(__extension__({                                           \
+    uint8_t __result;                                      \
+    __asm__ __volatile__                                   \
+    (                                                      \
+        "ldi r30, %3\n\t"                                  \
+        "ldi r31, 0\n\t"                                   \
+        "sts %1, %2\n\t"                                   \
+        "lpm %0, Z\n\t"                                    \
+        : "=r" (__result)                                  \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),                  \
+          "r" ((uint8_t)__BOOT_LOCK_BITS_SET),             \
+          "M" (address)                                    \
+        : "r0", "r30", "r31"                               \
+    );                                                     \
+    __result;                                              \
+}))
+
+/** \ingroup avr_boot
+    \def boot_signature_byte_get(address)
+
+    Read the Signature Row byte at \c address.  For some MCU types,
+    this function can also retrieve the factory-stored oscillator
+    calibration bytes.
+
+    Parameter \c address can be 0-0x1f as documented by the datasheet.
+    \note The values are MCU type dependent.
+*/
+
+#define __BOOT_SIGROW_READ (_BV(__SPM_ENABLE) | _BV(SIGRD))
+
+#define boot_signature_byte_get_short(addr) \
+(__extension__({                      \
+      uint16_t __addr16 = (uint16_t)(addr);     \
+      uint8_t __result;                         \
+      __asm__ __volatile__                      \
+      (                                         \
+        "out %1, %2\n\t"                        \
+        "lpm %0, Z" "\n\t"                      \
+        : "=r" (__result)                       \
+        : "i" (_SFR_IO_ADDR(__SPM_REG)),        \
+          "r" ((uint8_t) __BOOT_SIGROW_READ),   \
+          "z" (__addr16)                        \
+      );                                        \
+      __result;                                 \
+}))
+
+#define boot_signature_byte_get(addr) \
+(__extension__({                      \
+      uint16_t __addr16 = (uint16_t)(addr);     \
+      uint8_t __result;                         \
+      __asm__ __volatile__                      \
+      (                                         \
+        "sts %1, %2\n\t"                        \
+        "lpm %0, Z" "\n\t"                      \
+        : "=r" (__result)                       \
+        : "i" (_SFR_MEM_ADDR(__SPM_REG)),       \
+          "r" ((uint8_t) __BOOT_SIGROW_READ),   \
+          "z" (__addr16)                        \
+      );                                        \
+      __result;                                 \
+}))
+
+/** \ingroup avr_boot
+    \def boot_page_fill(address, data)
+
+    Fill the bootloader temporary page buffer for flash 
+    address with data word. 
+
+    \note The address is a byte address. The data is a word. The AVR 
+    writes data to the buffer a word at a time, but addresses the buffer
+    per byte! So, increment your address by 2 between calls, and send 2
+    data bytes in a word format! The LSB of the data is written to the lower 
+    address; the MSB of the data is written to the higher address.*/
+
+/** \ingroup avr_boot
+    \def boot_page_erase(address)
+
+    Erase the flash page that contains address.
+
+    \note address is a byte address in flash, not a word address. */
+
+/** \ingroup avr_boot
+    \def boot_page_write(address)
+
+    Write the bootloader temporary page buffer 
+    to flash page that contains address.
+    
+    \note address is a byte address in flash, not a word address. */
+
+/** \ingroup avr_boot
+    \def boot_rww_enable()
+
+    Enable the Read-While-Write memory section. */
+
+/** \ingroup avr_boot
+    \def boot_lock_bits_set(lock_bits)
+
+    Set the bootloader lock bits.
+
+    \param lock_bits A mask of which Boot Loader Lock Bits to set.
+
+    \note In this context, a 'set bit' will be written to a zero value.
+    Note also that only BLBxx bits can be programmed by this command.
+
+    For example, to disallow the SPM instruction from writing to the Boot
+    Loader memory section of flash, you would use this macro as such:
+
+    \code
+    boot_lock_bits_set (_BV (BLB11));
+    \endcode
+
+    \note Like any lock bits, the Boot Loader Lock Bits, once set,
+    cannot be cleared again except by a chip erase which will in turn
+    also erase the boot loader itself. */
+
+/* Normal versions of the macros use 16-bit addresses.
+   Extended versions of the macros use 32-bit addresses.
+   Alternate versions of the macros use 16-bit addresses and require special
+   instruction sequences after LPM.
+
+   FLASHEND is defined in the ioXXXX.h file.
+   USHRT_MAX is defined in <limits.h>. */ 
+
+#if defined(__AVR_ATmega161__) || defined(__AVR_ATmega163__) \
+    || defined(__AVR_ATmega323__)
+
+/* Alternate: ATmega161/163/323 and 16 bit address */
+#define boot_page_fill(address, data) __boot_page_fill_alternate(address, data)
+#define boot_page_erase(address)      __boot_page_erase_alternate(address)
+#define boot_page_write(address)      __boot_page_write_alternate(address)
+#define boot_rww_enable()             __boot_rww_enable_alternate()
+#define boot_lock_bits_set(lock_bits) __boot_lock_bits_set_alternate(lock_bits)
+
+#elif (FLASHEND > USHRT_MAX)
+
+/* Extended: >16 bit address */
+#define boot_page_fill(address, data) __boot_page_fill_extended_short(address, data)
+#define boot_page_erase(address)      __boot_page_erase_extended_short(address)
+#define boot_page_write(address)      __boot_page_write_extended_short(address)
+#define boot_rww_enable()             __boot_rww_enable_short()
+#define boot_lock_bits_set(lock_bits) __boot_lock_bits_set_short(lock_bits)
+
+#else
+
+/* Normal: 16 bit address */
+#define boot_page_fill(address, data) __boot_page_fill_short(address, data)
+#define boot_page_erase(address)      __boot_page_erase_short(address)
+#define boot_page_write(address)      __boot_page_write_short(address)
+#define boot_rww_enable()             __boot_rww_enable_short()
+#define boot_lock_bits_set(lock_bits) __boot_lock_bits_set_short(lock_bits)
+
+#endif
+
+/** \ingroup avr_boot
+
+    Same as boot_page_fill() except it waits for eeprom and spm operations to
+    complete before filling the page. */
+
+#define boot_page_fill_safe(address, data) \
+do { \
+    boot_spm_busy_wait();                       \
+    eeprom_busy_wait();                         \
+    boot_page_fill(address, data);              \
+} while (0)
+
+/** \ingroup avr_boot
+
+    Same as boot_page_erase() except it waits for eeprom and spm operations to
+    complete before erasing the page. */
+
+#define boot_page_erase_safe(address) \
+do { \
+    boot_spm_busy_wait();                       \
+    eeprom_busy_wait();                         \
+    boot_page_erase (address);                  \
+} while (0)
+
+/** \ingroup avr_boot
+
+    Same as boot_page_write() except it waits for eeprom and spm operations to
+    complete before writing the page. */
+
+#define boot_page_write_safe(address) \
+do { \
+    boot_spm_busy_wait();                       \
+    eeprom_busy_wait();                         \
+    boot_page_write (address);                  \
+} while (0)
+
+/** \ingroup avr_boot
+
+    Same as boot_rww_enable() except waits for eeprom and spm operations to
+    complete before enabling the RWW mameory. */
+
+#define boot_rww_enable_safe() \
+do { \
+    boot_spm_busy_wait();                       \
+    eeprom_busy_wait();                         \
+    boot_rww_enable();                          \
+} while (0)
+
+/** \ingroup avr_boot
+
+    Same as boot_lock_bits_set() except waits for eeprom and spm operations to
+    complete before setting the lock bits. */
+
+#define boot_lock_bits_set_safe(lock_bits) \
+do { \
+    boot_spm_busy_wait();                       \
+    eeprom_busy_wait();                         \
+    boot_lock_bits_set (lock_bits);             \
+} while (0)
+
+#endif /* _AVR_BOOT_H_ */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/optiboot.c b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/optiboot.c
new file mode 100644
index 0000000..0318696
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega1284p/optiboot.c
@@ -0,0 +1,724 @@
+/**********************************************************/
+/* -Wl,-section-start=bootloader=0x1fc00 */
+/* Optiboot bootloader for Arduino                        */
+/*                                                        */
+/* http://optiboot.googlecode.com                         */
+/*                                                        */
+/* Arduino-maintained version : See README.TXT            */
+/* http://code.google.com/p/arduino/                      */
+/*                                                        */
+/* Heavily optimised bootloader that is faster and        */
+/* smaller than the Arduino standard bootloader           */
+/*                                                        */
+/* Enhancements:                                          */
+/*   Fits in 512 bytes, saving 1.5K of code space         */
+/*   Background page erasing speeds up programming        */
+/*   Higher baud rate speeds up programming               */
+/*   Written almost entirely in C                         */
+/*   Customisable timeout with accurate timeconstant      */
+/*   Optional virtual UART. No hardware UART required.    */
+/*   Optional virtual boot partition for devices without. */
+/*                                                        */
+/* What you lose:                                         */
+/*   Implements a skeleton STK500 protocol which is       */
+/*     missing several features including EEPROM          */
+/*     programming and non-page-aligned writes            */
+/*   High baud rate breaks compatibility with standard    */
+/*     Arduino flash settings                             */
+/*                                                        */
+/* Fully supported:                                       */
+/*   ATmega168 based devices  (Diecimila etc)             */
+/*   ATmega328P based devices (Duemilanove etc)           */
+/*                                                        */
+/* Alpha test                                             */
+/*   ATmega1280 based devices (Arduino Mega)              */
+/*                                                        */
+/* Work in progress:                                      */
+/*   ATmega644P based devices (Sanguino)                  */
+/*   ATtiny84 based devices (Luminet)                     */
+/*                                                        */
+/* Does not support:                                      */
+/*   USB based devices (eg. Teensy)                       */
+/*                                                        */
+/* Assumptions:                                           */
+/*   The code makes several assumptions that reduce the   */
+/*   code size. They are all true after a hardware reset, */
+/*   but may not be true if the bootloader is called by   */
+/*   other means or on other hardware.                    */
+/*     No interrupts can occur                            */
+/*     UART and Timer 1 are set to their reset state      */
+/*     SP points to RAMEND                                */
+/*                                                        */
+/* Code builds on code, libraries and optimisations from: */
+/*   stk500boot.c          by Jason P. Kyle               */
+/*   Arduino bootloader    http://arduino.cc              */
+/*   Spiff's 1K bootloader http://spiffie.org/know/arduino_1k_bootloader/bootloader.shtml */
+/*   avr-libc project      http://nongnu.org/avr-libc     */
+/*   Adaboot               http://www.ladyada.net/library/arduino/bootloader.html */
+/*   AVR305                Atmel Application Note         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/**********************************************************/
+
+
+/**********************************************************/
+/*                                                        */
+/* Optional defines:                                      */
+/*                                                        */
+/**********************************************************/
+/*                                                        */
+/* BIG_BOOT:                                              */
+/* Build a 1k bootloader, not 512 bytes. This turns on    */
+/* extra functionality.                                   */
+/*                                                        */
+/* BAUD_RATE:                                             */
+/* Set bootloader baud rate.                              */
+/*                                                        */
+/* LUDICROUS_SPEED:                                       */
+/* 230400 baud :-)                                        */
+/*                                                        */
+/* SOFT_UART:                                             */
+/* Use AVR305 soft-UART instead of hardware UART.         */
+/*                                                        */
+/* LED_START_FLASHES:                                     */
+/* Number of LED flashes on bootup.                       */
+/*                                                        */
+/* LED_DATA_FLASH:                                        */
+/* Flash LED when transferring data. For boards without   */
+/* TX or RX LEDs, or for people who like blinky lights.   */
+/*                                                        */
+/* SUPPORT_EEPROM:                                        */
+/* Support reading and writing from EEPROM. This is not   */
+/* used by Arduino, so off by default.                    */
+/*                                                        */
+/* TIMEOUT_MS:                                            */
+/* Bootloader timeout period, in milliseconds.            */
+/* 500,1000,2000,4000,8000 supported.                     */
+/*                                                        */
+/**********************************************************/
+
+/**********************************************************/
+/* Version Numbers!                                       */
+/*                                                        */
+/* Arduino Optiboot now includes this Version number in   */
+/* the source and object code.                            */
+/*                                                        */
+/* Version 3 was released as zip from the optiboot        */
+/*  repository and was distributed with Arduino 0022.     */
