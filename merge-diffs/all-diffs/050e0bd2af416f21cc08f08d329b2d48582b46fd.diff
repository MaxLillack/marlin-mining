commit 050e0bd2af416f21cc08f08d329b2d48582b46fd (from 5f7ad16b19f9dbf9cfe6581d2f677a06d5abd13e)
Merge: 5f7ad16 9b92bb8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 8 19:00:24 2016 -0700

    Merge pull request #3705 from thinkyhead/rc_runaway_logic
    
    Fallthru in thermal runaway test when TRState changes

diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index f8c85fb..19e66c6 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1047,33 +1047,26 @@ void Temperature::init() {
     int heater_index = heater_id >= 0 ? heater_id : EXTRUDERS;
 
     // If the target temperature changes, restart
-    if (tr_target_temperature[heater_index] != target_temperature)
-      *state = TRReset;
+    if (tr_target_temperature[heater_index] != target_temperature) {
+      tr_target_temperature[heater_index] = target_temperature;
+      *state = target_temperature > 0 ? TRFirstHeating : TRInactive;
+    }
 
     switch (*state) {
-      case TRReset:
-        *timer = 0;
-        *state = TRInactive;
       // Inactive state waits for a target temperature to be set
-      case TRInactive:
-        if (target_temperature > 0) {
-          tr_target_temperature[heater_index] = target_temperature;
-          *state = TRFirstHeating;
-        }
-        break;
+      case TRInactive: break;
       // When first heating, wait for the temperature to be reached then go to Stable state
       case TRFirstHeating:
-        if (temperature >= tr_target_temperature[heater_index]) *state = TRStable;
-        break;
+        if (temperature < tr_target_temperature[heater_index]) break;
+        *state = TRStable;
       // While the temperature is stable watch for a bad temperature
       case TRStable:
-        // If the temperature is over the target (-hysteresis) restart the timer
-        if (temperature >= tr_target_temperature[heater_index] - hysteresis_degc)
-          *timer = millis();
-        // If the timer goes too long without a reset, trigger shutdown
-        else if (ELAPSED(millis(), *timer + period_seconds * 1000UL))
+        if (temperature < tr_target_temperature[heater_index] - hysteresis_degc && ELAPSED(millis(), *timer))
           *state = TRRunaway;
-        break;
+        else {
+          *timer = millis() + period_seconds * 1000UL;
+          break;
+        }
       case TRRunaway:
         _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
     }
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 41e4ac1..a178f1f 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -358,17 +358,17 @@ class Temperature {
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
-      typedef enum TRState { TRReset, TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
+      typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
 
       void thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        TRState thermal_runaway_state_machine[EXTRUDERS] = { TRReset };
+        TRState thermal_runaway_state_machine[EXTRUDERS] = { TRInactive };
         millis_t thermal_runaway_timer[EXTRUDERS] = { 0 };
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
-        TRState thermal_runaway_bed_state_machine = TRReset;
+        TRState thermal_runaway_bed_state_machine = TRInactive;
         millis_t thermal_runaway_bed_timer;
       #endif
 

commit 050e0bd2af416f21cc08f08d329b2d48582b46fd (from 9b92bb8f31217cf785979a7f24ea74f6b574942e)
Merge: 5f7ad16 9b92bb8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 8 19:00:24 2016 -0700

    Merge pull request #3705 from thinkyhead/rc_runaway_logic
    
    Fallthru in thermal runaway test when TRState changes

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 5c9e5ff..8307095 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -343,6 +343,7 @@ static uint8_t target_extruder;
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   int xy_travel_speed = XY_TRAVEL_SPEED;
   float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
+  bool bed_leveling_in_progress = false;
 #endif
 
 #if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)
@@ -1632,7 +1633,12 @@ static void setup_for_endstop_move() {
       destination[X_AXIS] = x;
       destination[Y_AXIS] = y;
       destination[Z_AXIS] = z;
-      prepare_move_raw(); // this will also set_current_to_destination
+
+      if (x == current_position[X_AXIS] && y == current_position[Y_AXIS])
+        prepare_move_raw(); // this will also set_current_to_destination
+      else
+        prepare_move();     // this will also set_current_to_destination
+
       stepper.synchronize();
 
     #else
@@ -3238,6 +3244,8 @@ inline void gcode_G28() {
 
     feedrate = homing_feedrate[Z_AXIS];
 
+    bed_leveling_in_progress = true;
+
     #if ENABLED(AUTO_BED_LEVELING_GRID)
 
       // probe at the points of a lattice grid
@@ -3585,15 +3593,17 @@ inline void gcode_G28() {
       stepper.synchronize();
     #endif
 
-    KEEPALIVE_STATE(IN_HANDLER);
-
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("<<< gcode_G29");
       }
     #endif
 
+    bed_leveling_in_progress = false;
+
     report_current_position();
+
+    KEEPALIVE_STATE(IN_HANDLER);
   }
 
   #if DISABLED(Z_PROBE_SLED) // could be avoided
@@ -7305,7 +7315,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
       calculate_delta(target);
 
       #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-        adjust_delta(target);
+        if (!bed_leveling_in_progress) adjust_delta(target);
       #endif
 
       //DEBUG_POS("prepare_move_delta", target);
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 71f2c46..5b449bb 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -240,9 +240,9 @@
    * Don't allow nonsense probe-pin settings
    */
   #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(Z_MIN_PROBE_ENDSTOP)
-    #error You can't enable both Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN and Z_MIN_PROBE_ENDSTOP.
+    #error "You can't enable both Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN and Z_MIN_PROBE_ENDSTOP."
   #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP)
-    #error Don't enable DISABLE_Z_MIN_PROBE_ENDSTOP with Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN.
+    #error "Don't enable DISABLE_Z_MIN_PROBE_ENDSTOP with Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN."
   #elif ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP) && DISABLED(Z_MIN_PROBE_ENDSTOP)
     #error DISABLE_Z_MIN_PROBE_ENDSTOP requires Z_MIN_PROBE_ENDSTOP to be set.
   #endif
@@ -252,7 +252,7 @@
    */
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if !HAS_Z_MIN_PROBE_PIN
-      #error Z_MIN_PROBE_ENDSTOP requires a Z_MIN_PROBE_PIN in your board's pins_XXXX.h file.
+      #error "Z_MIN_PROBE_ENDSTOP requires a Z_MIN_PROBE_PIN in your board's pins_XXXX.h file."
     #endif
     // Forcing Servo definitions can break some hall effect sensor setups. Leaving these here for further comment.
     //#ifndef NUM_SERVOS

