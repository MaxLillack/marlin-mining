commit ac74f45dc0659f271b8a1d45252b0e10bd20afaf (from 8ebcc9dc3a255b718d96be9132c228c517eaadbd)
Merge: 8ebcc9d 36086d3
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sun Feb 9 17:52:26 2014 +0100

    Merge pull request #752 from MatixYo/patch-3
    
    Update language.h

diff --git a/Marlin/language.h b/Marlin/language.h
index 2d97cc3..2ef725f 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -220,7 +220,7 @@
 	#define WELCOME_MSG MACHINE_NAME " Gotowe."
 	#define MSG_SD_INSERTED "Karta wlozona"
 	#define MSG_SD_REMOVED "Karta usunieta"
-	#define MSG_MAIN "Main"
+	#define MSG_MAIN "Menu glowne"
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
 	#define MSG_AUTO_HOME "Auto. poz. zerowa"
@@ -230,8 +230,8 @@
 	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
 	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
 	#define MSG_COOLDOWN "Chlodzenie"
-	#define MSG_SWITCH_PS_ON "Switch Power On"
-	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_SWITCH_PS_ON "Wl. zasilacz"
+	#define MSG_SWITCH_PS_OFF "Wyl. zasilacz"
 	#define MSG_EXTRUDE "Ekstruzja"
 	#define MSG_RETRACT "Cofanie"
 	#define MSG_MOVE_AXIS "Ruch osi"
@@ -273,19 +273,19 @@
 	#define MSG_RECTRACT "Wycofanie"
 	#define MSG_TEMPERATURE "Temperatura"
 	#define MSG_MOTION "Ruch"
-	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_CONTRAST "Kontrast LCD"
 	#define MSG_STORE_EPROM "Zapisz w pamieci"
 	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
-	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_RESTORE_FAILSAFE "Ustawienia fabryczne"
 	#define MSG_REFRESH "\004Odswiez"
-	#define MSG_WATCH "Obserwuj"
+	#define MSG_WATCH "Ekran glowny"
 	#define MSG_PREPARE "Przygotuj"
-	#define MSG_CONTROL "Kontroluj"
+	#define MSG_CONTROL "Ustawienia"
 	#define MSG_TUNE "Strojenie"
 	#define MSG_PAUSE_PRINT "Pauza"
 	#define MSG_RESUME_PRINT "Wznowienie"
 	#define MSG_STOP_PRINT "Stop"
-	#define MSG_CARD_MENU "Menu SDCard"
+	#define MSG_CARD_MENU "Menu karty SD"
 	#define MSG_NO_CARD "Brak karty"
 	#define MSG_DWELL "Uspij..."
 	#define MSG_USERWAIT "Czekaj na uzytkownika..."
@@ -301,11 +301,11 @@
 	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
 	#define MSG_AUTORETRACT "Auto. wycofanie"
-	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+	#define MSG_FILAMENTCHANGE "Zmien filament"
+	#define MSG_INIT_SDCARD "Uruchom karte SD"	
+	#define MSG_CNG_SDCARD "Zmien karte SD"
+    #define MSG_ZPROBE_OUT "Probkuj Z poza lozem"
+    #define MSG_POSITION_UNKNOWN "Domuj X/Y przed Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
 
 // Serial Console Messages
@@ -316,7 +316,7 @@
 	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
 	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
 	#define MSG_SOFTWARE_RESET " Reset (programowy)"
-	#define MSG_MARLIN "Marlin "
+	#define MSG_MARLIN "Marlin"
 	#define MSG_AUTHOR " | Autor: "
 	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
 	#define MSG_FREE_MEMORY " Wolna pamiec: "
@@ -355,8 +355,8 @@
 	#define MSG_Z_MIN "z_min: "
 	#define MSG_Z_MAX "z_max: "
 	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
-	#define MSG_ENDSTOP_HIT "WYZWOLONY"
-	#define MSG_ENDSTOP_OPEN "otwarty"
+	#define MSG_ENDSTOP_HIT "Wyzwolony"
+	#define MSG_ENDSTOP_OPEN "Otwarty"
 	#define MSG_HOTEND_OFFSET "Hotend offsets:"
 
 	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"

commit ac74f45dc0659f271b8a1d45252b0e10bd20afaf (from 36086d3ca4830a7c05bcceaac98c8369a6abbcf1)
Merge: 8ebcc9d 36086d3
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sun Feb 9 17:52:26 2014 +0100

    Merge pull request #752 from MatixYo/patch-3
    
    Update language.h

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 8d39bd9..696b4ca 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -52,6 +52,7 @@
 // 65 = Azteeg X1
 // 66 = Melzi with ATmega1284 (MaKr3d version)
 // 67 = Azteeg X3
+// 68 = Azteeg X3 Pro
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
 // 77 = 3Drag Controller
@@ -156,8 +157,8 @@
 // HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
 //#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
 
-// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS 
-//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R 
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R
 //#define BED_WATTS (12.0*12.0/1.1)      // P=I^2/R
 
 // PID settings:
@@ -374,12 +375,12 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   // with accurate bed leveling, the bed is sampled in a ACCURATE_BED_LEVELING_POINTSxACCURATE_BED_LEVELING_POINTS grid and least squares solution is calculated
   // Note: this feature occupies 10'206 byte
   #define ACCURATE_BED_LEVELING
-  
+
   #ifdef ACCURATE_BED_LEVELING
      // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
     #define ACCURATE_BED_LEVELING_POINTS 2
   #endif
-  
+
 #endif
 
 
@@ -538,21 +539,21 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
   #define NEWPANEL
   #define ULTIPANEL
-  
+
   #ifndef ENCODER_PULSES_PER_STEP
 	#define ENCODER_PULSES_PER_STEP 4
-  #endif 
+  #endif
 
   #ifndef ENCODER_STEPS_PER_MENU_ITEM
 	#define ENCODER_STEPS_PER_MENU_ITEM 1
-  #endif 
-  
-  
+  #endif
+
+
   #ifdef LCD_USE_I2C_BUZZER
 	#define LCD_FEEDBACK_FREQUENCY_HZ 1000
 	#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
   #endif
-  
+
 #endif
 
 // Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 4e5d829..dc986fa 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -12,7 +12,7 @@
 
 //// Heating sanity check:
 // This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
-// If the temperature has not increased at the end of that period, the target temperature is set to zero. 
+// If the temperature has not increased at the end of that period, the target temperature is set to zero.
 // It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
 //  differ by at least 2x WATCH_TEMP_INCREASE
 //#define WATCH_TEMP_PERIOD 40000 //40 seconds
@@ -21,7 +21,7 @@
 #ifdef PIDTEMP
   // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
   // if Kc is choosen well, the additional required power due to increased melting should be compensated.
-  #define PID_ADD_EXTRUSION_RATE  
+  #define PID_ADD_EXTRUSION_RATE
   #ifdef PID_ADD_EXTRUSION_RATE
     #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)
   #endif
@@ -44,10 +44,10 @@
 //The M105 command return, besides traditional information, the ADC value read from temperature sensors.
 //#define SHOW_TEMP_ADC_VALUES
 
-//  extruder run-out prevention. 
+//  extruder run-out prevention.
 //if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
-//#define EXTRUDER_RUNOUT_PREVENT  
-#define EXTRUDER_RUNOUT_MINTEMP 190  
+//#define EXTRUDER_RUNOUT_PREVENT
+#define EXTRUDER_RUNOUT_MINTEMP 190
 #define EXTRUDER_RUNOUT_SECONDS 30.
 #define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
 #define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed
@@ -73,7 +73,7 @@
 // Extruder cooling fans
 // Configure fan pin outputs to automatically turn on/off when the associated
 // extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case 
+// Multiple extruders can be assigned to the same pin in which case
 // the fan will turn on when any selected extruder is above the threshold.
 #define EXTRUDER_0_AUTO_FAN_PIN   -1
 #define EXTRUDER_1_AUTO_FAN_PIN   -1
@@ -103,14 +103,14 @@
     #else
       #define X_HOME_POS X_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else    
+  #else
     #ifdef BED_CENTER_AT_0_0
       #define X_HOME_POS X_MAX_LENGTH * 0.5
     #else
       #define X_HOME_POS X_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //X_HOME_DIR == -1
-  
+
   //Y axis
   #if Y_HOME_DIR == -1
     #ifdef BED_CENTER_AT_0_0
@@ -118,18 +118,18 @@
     #else
       #define Y_HOME_POS Y_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else    
+  #else
     #ifdef BED_CENTER_AT_0_0
       #define Y_HOME_POS Y_MAX_LENGTH * 0.5
     #else
       #define Y_HOME_POS Y_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //Y_HOME_DIR == -1
-  
+
   // Z axis
   #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
     #define Z_HOME_POS Z_MIN_POS
-  #else    
+  #else
     #define Z_HOME_POS Z_MAX_POS
   #endif //Z_HOME_DIR == -1
 #endif //End auto min/max positions
@@ -165,7 +165,7 @@
   #error "You cannot have dual drivers for both Y and Z"
 #endif
 
-// Enable this for dual x-carriage printers. 
+// Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
 // allowing faster printing speeds.
@@ -175,10 +175,10 @@
 // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
 // the second x-carriage always homes to the maximum endstop.
 #define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
-#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed 
+#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed
 #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
-#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
-    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software
     // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
     // without modifying the firmware (through the "M218 T1 X???" command).
     // Remember: you should set the second extruder x-offset to 0 in your slicer.
@@ -193,17 +193,17 @@
 //                           as long as it supports dual x-carriages. (M605 S0)
 //    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
 //                           that additional slicer support is not required. (M605 S1)
-//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all  
+//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all
 //                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
 //                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
 
-// This is the default power-up mode which can be later using M605. 
-#define DEFAULT_DUAL_X_CARRIAGE_MODE 0 
+// This is the default power-up mode which can be later using M605.
+#define DEFAULT_DUAL_X_CARRIAGE_MODE 0
 
 // As the x-carriages are independent we can now account for any relative Z offset
 #define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0
 
-// Default settings in "Auto-park Mode" 
+// Default settings in "Auto-park Mode"
 #define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
 #define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
 
@@ -211,11 +211,11 @@
 #define DEFAULT_DUPLICATION_X_OFFSET 100
 
 #endif //DUAL_X_CARRIAGE
-    
+
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
-#define X_HOME_RETRACT_MM 5 
-#define Y_HOME_RETRACT_MM 5 
-#define Z_HOME_RETRACT_MM 1 
+#define X_HOME_RETRACT_MM 5
+#define Y_HOME_RETRACT_MM 5
+#define Z_HOME_RETRACT_MM 1
 //#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
 
 #define AXIS_RELATIVE_MODES {false, false, false, false}
@@ -268,6 +268,12 @@
 // Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
 #define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
 
+// uncomment to enable an I2C based DIGIPOT like on the Azteeg X3 Pro
+//#define DIGIPOT_I2C
+// Number of channels available for I2C digipot, For Azteeg X3 Pro we have 8
+#define DIGIPOT_I2C_NUM_CHANNELS 8
+// actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
+#define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}
 
 //===========================================================================
 //=============================Additional Features===========================
@@ -276,7 +282,7 @@
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
 #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
-#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order. 
+#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order.
 // if a file is deleted, it frees a block. hence, the order is not purely cronological. To still have auto0.g accessible, there is again the option to do that.
 // using:
 //#define MENU_ADDAUTOSTART
@@ -302,7 +308,7 @@
   #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
   #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
   #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
-  
+
   #ifdef COREXY
     #error BABYSTEPPING not implemented for COREXY yet.
   #endif
@@ -340,10 +346,10 @@
 const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
-// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
+// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT
 // in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
 // be commented out otherwise
-#define SDCARDDETECTINVERTED 
+#define SDCARDDETECTINVERTED
 
 #ifdef ULTIPANEL
  #undef SDCARDDETECTINVERTED
@@ -355,12 +361,12 @@ const unsigned int dropsegments=5; //everything with less than this number of st
   #define POWER_SUPPLY 1
 #endif
 // 1 = ATX
-#if (POWER_SUPPLY == 1) 
+#if (POWER_SUPPLY == 1)
   #define PS_ON_AWAKE  LOW
   #define PS_ON_ASLEEP HIGH
 #endif
 // 2 = X-Box 360 203W
-#if (POWER_SUPPLY == 2) 
+#if (POWER_SUPPLY == 2)
   #define PS_ON_AWAKE  HIGH
   #define PS_ON_ASLEEP LOW
 #endif
@@ -372,7 +378,7 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 //=============================Buffers           ============================
 //===========================================================================
 
-// The number of linear motions that can be in the plan at any give time.  
+// The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
 #if defined SDSUPPORT
   #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
@@ -387,9 +393,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 
 
 // Firmware based and LCD controled retract
-// M207 and M208 can be used to define parameters for the retraction. 
+// M207 and M208 can be used to define parameters for the retraction.
 // The retraction can be called by the slicer using G10 and G11
-// until then, intended retractions can be detected by moves that only extrude and the direction. 
+// until then, intended retractions can be detected by moves that only extrude and the direction.
 // the moves are than replaced by the firmware controlled ones.
 
 // #define FWRETRACT  //ONLY PARTIALLY TESTED
@@ -411,9 +417,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 #ifdef FILAMENTCHANGEENABLE
   #ifdef EXTRUDER_RUNOUT_PREVENT
     #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
-  #endif 
+  #endif
 #endif
- 
+
 //===========================================================================
 //=============================  Define Defines  ============================
 //===========================================================================
diff --git a/Marlin/Makefile b/Marlin/Makefile
index 29a5578..9c26c3c 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -55,7 +55,10 @@ UPLOAD_PORT        ?= /dev/arduino
 BUILD_DIR          ?= applet
 
 # This defines whether Liquid_TWI2 support will be built
-LIQUID_TWI2 ?= 0
+LIQUID_TWI2        ?= 0
+
+# this defines if Wire is needed
+WIRE               ?= 0
 
 ############################################################################
 # Below here nothing should be changed...
@@ -174,6 +177,14 @@ else ifeq  ($(HARDWARE_MOTHERBOARD),301)
 HARDWARE_VARIANT ?= arduino
 MCU              ?= atmega2560
 
+# Azteeg
+else ifeq  ($(HARDWARE_MOTHERBOARD),67)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),68)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
 endif
 
 # Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
@@ -213,6 +224,10 @@ VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire
 VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire/utility
 VPATH += $(ARDUINO_INSTALL_DIR)/libraries/LiquidTWI2
 endif
+ifeq ($(WIRE), 1)
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire/utility
+endif
 else
 VPATH += $(HARDWARE_DIR)/libraries/LiquidCrystal
 VPATH += $(HARDWARE_DIR)/libraries/SPI
@@ -221,6 +236,10 @@ VPATH += $(HARDWARE_DIR)/libraries/Wire
 VPATH += $(HARDWARE_DIR)/libraries/Wire/utility
 VPATH += $(HARDWARE_DIR)/libraries/LiquidTWI2
 endif
+ifeq ($(WIRE, 1)
+VPATH += $(HARDWARE_DIR)/libraries/Wire
+VPATH += $(HARDWARE_DIR)/libraries/Wire/utility
+endif
 endif
 ifeq ($(HARDWARE_VARIANT), arduino)
 HARDWARE_SUB_VARIANT ?= mega
@@ -241,7 +260,7 @@ CXXSRC = WMath.cpp WString.cpp Print.cpp Marlin_main.cpp	\
 	MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp SdFatUtil.cpp	\
 	SdFile.cpp SdVolume.cpp motion_control.cpp planner.cpp		\
 	stepper.cpp temperature.cpp cardreader.cpp ConfigurationStore.cpp \
-	watchdog.cpp SPI.cpp Servo.cpp Tone.cpp ultralcd.cpp
+	watchdog.cpp SPI.cpp Servo.cpp Tone.cpp ultralcd.cpp digipot_mcp4451.cpp
 ifeq ($(LIQUID_TWI2), 0)
 CXXSRC += LiquidCrystal.cpp
 else
@@ -249,6 +268,11 @@ SRC += twi.c
 CXXSRC += Wire.cpp LiquidTWI2.cpp
 endif
 
+ifeq ($(WIRE), 1)
+SRC += twi.c
+CXXSRC += Wire.cpp
+endif
+
 #Check for Arduino 1.0.0 or higher and use the correct sourcefiles for that version
 ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
 CXXSRC += main.cpp
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 6b54aaf..a28393e 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -235,4 +235,9 @@ extern unsigned long stoptime;
 // Handling multiple extruders pins
 extern uint8_t active_extruder;
 
+#ifdef DIGIPOT_I2C
+extern void digipot_i2c_set_current( int channel, float current );
+extern void digipot_i2c_init();
+#endif
+
 #endif
diff --git a/Marlin/Marlin.ino b/Marlin/Marlin.ino
index 2d6211c..79c934b 100644
--- a/Marlin/Marlin.ino
+++ b/Marlin/Marlin.ino
@@ -3,17 +3,17 @@
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
+
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
- 
+
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
- 
+
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -22,8 +22,8 @@
  This firmware is a mashup between Sprinter and grbl.
   (https://github.com/kliment/Sprinter)
   (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
+
+ It has preliminary support for Matthew Roberts advance algorithm
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
@@ -50,3 +50,7 @@
 #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
+
+#if defined(DIGIPOT_I2C)
+  #include <Wire.h>
+#endif
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 2d6211c..79c934b 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -3,17 +3,17 @@
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
+
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
- 
+
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
- 
+
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -22,8 +22,8 @@
  This firmware is a mashup between Sprinter and grbl.
   (https://github.com/kliment/Sprinter)
   (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
+
+ It has preliminary support for Matthew Roberts advance algorithm
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
@@ -50,3 +50,7 @@
 #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
+
+#if defined(DIGIPOT_I2C)
+  #include <Wire.h>
+#endif
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 8601502..b567e2b 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -249,7 +249,7 @@ int EtoPPressure=0;
 float delta[3] = {0.0, 0.0, 0.0};
 #endif
 
-  
+
 //===========================================================================
 //=============================private variables=============================
 //===========================================================================
@@ -492,6 +492,10 @@ void setup()
   #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
     SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
   #endif
+
+  #ifdef DIGIPOT_I2C
+    digipot_i2c_init();
+  #endif
 }
 
 
@@ -789,7 +793,7 @@ static unsigned long delayed_move_time = 0; // used in mode 1
 static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
 static float duplicate_extruder_temp_offset = 0; // used in mode 2
 bool extruder_duplication_enabled = false; // used in mode 2
-#endif //DUAL_X_CARRIAGE    
+#endif //DUAL_X_CARRIAGE
 
 static void axis_is_at_home(int axis) {
 #ifdef DUAL_X_CARRIAGE
@@ -802,8 +806,8 @@ static void axis_is_at_home(int axis) {
     }
     else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
       current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];
-      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS]; 
-      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS], 
+      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS];
+      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS],
                                   max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
       return;
     }
@@ -895,7 +899,7 @@ static void run_z_probe() {
     st_synchronize();
 
     // move back down slowly to find bed
-    feedrate = homing_feedrate[Z_AXIS]/4; 
+    feedrate = homing_feedrate[Z_AXIS]/4;
     zPosition -= home_retract_mm(Z_AXIS) * 2;
     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
@@ -992,7 +996,7 @@ static void homeaxis(int axis) {
 
     current_position[axis] = 0;
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-	
+
 
     // Engage Servo endstop if enabled
     #ifdef SERVO_ENDSTOPS
@@ -1050,7 +1054,7 @@ static void homeaxis(int axis) {
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
     if (axis==Z_AXIS) retract_z_probe();
 #endif
-    
+
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
@@ -1124,7 +1128,7 @@ void process_commands()
         destination[Y_AXIS]=current_position[Y_AXIS];
         destination[Z_AXIS]=current_position[Z_AXIS];
         current_position[Z_AXIS]+=retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]+retract_length+retract_recover_length; 
+        destination[E_AXIS]=current_position[E_AXIS]+retract_length+retract_recover_length;
         feedrate=retract_recover_feedrate;
         retracted=false;
         prepare_move();
@@ -1238,10 +1242,10 @@ void process_commands()
         // reset state used by the different modes
         memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
         delayed_move_time = 0;
-        active_extruder_parked = true; 
-      #else      
+        active_extruder_parked = true;
+      #else
         HOMEAXIS(X);
-      #endif         
+      #endif
       }
 
       if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
@@ -1260,7 +1264,7 @@ void process_commands()
           current_position[Y_AXIS]=code_value()+add_homeing[1];
         }
       }
-      
+
       #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
         #ifndef Z_SAFE_HOMING
           if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
@@ -1272,14 +1276,14 @@ void process_commands()
             #endif
             HOMEAXIS(Z);
           }
-        #else                      // Z Safe mode activated. 
+        #else                      // Z Safe mode activated.
           if(home_all_axis) {
             destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
             feedrate = XY_TRAVEL_SPEED;
             current_position[Z_AXIS] = 0;
-			
+
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
             plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
             st_synchronize();
@@ -1297,7 +1301,7 @@ void process_commands()
               && (current_position[Y_AXIS]+Y_PROBE_OFFSET_FROM_EXTRUDER <= Y_MAX_POS)) {
 
               current_position[Z_AXIS] = 0;
-              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);			  
+              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
               destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
               feedrate = max_feedrate[Z_AXIS];
               plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
@@ -1317,8 +1321,8 @@ void process_commands()
         #endif
       #endif
 
-      
-     
+
+
       if(code_seen(axis_codes[Z_AXIS])) {
         if(code_value_long() != 0) {
           current_position[Z_AXIS]=code_value()+add_homeing[2];
@@ -1364,26 +1368,26 @@ void process_commands()
 
             feedrate = homing_feedrate[Z_AXIS];
 #ifdef ACCURATE_BED_LEVELING
-            
+
             int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
             int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
-            
-            
+
+
             // solve the plane equation ax + by + d = z
             // A is the matrix with rows [x y 1] for all the probed points
             // B is the vector of the Z positions
             // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
             // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
-            
+
             // "A" matrix of the linear system of equations
             double eqnAMatrix[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS*3];
             // "B" vector of Z points
             double eqnBVector[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS];
-            
-            
+
+
             int probePointCounter = 0;
             bool zig = true;
-            
+
             for (int yProbe=FRONT_PROBE_BED_POSITION; yProbe <= BACK_PROBE_BED_POSITION; yProbe += yGridSpacing)
             {
               int xProbe, xInc;
@@ -1400,7 +1404,7 @@ void process_commands()
                 xInc = -xGridSpacing;
                 zig = true;
               }
-              
+
               for (int xCount=0; xCount < ACCURATE_BED_LEVELING_POINTS; xCount++)
               {
                 if (probePointCounter == 0)
@@ -1408,19 +1412,19 @@ void process_commands()
                   // raise before probing
                   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
                 } else
-                {               
+                {
                   // raise extruder
                   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
                 }
-                
-                
+
+
                 do_blocking_move_to(xProbe - X_PROBE_OFFSET_FROM_EXTRUDER, yProbe - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
-    
+
                 engage_z_probe();   // Engage Z Servo endstop if available
                 run_z_probe();
                 eqnBVector[probePointCounter] = current_position[Z_AXIS];
                 retract_z_probe();
-    
+
                 SERIAL_PROTOCOLPGM("Bed x: ");
                 SERIAL_PROTOCOL(xProbe);
                 SERIAL_PROTOCOLPGM(" y: ");
@@ -1428,7 +1432,7 @@ void process_commands()
                 SERIAL_PROTOCOLPGM(" z: ");
                 SERIAL_PROTOCOL(current_position[Z_AXIS]);
                 SERIAL_PROTOCOLPGM("\n");
-                
+
                 eqnAMatrix[probePointCounter + 0*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = xProbe;
                 eqnAMatrix[probePointCounter + 1*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = yProbe;
                 eqnAMatrix[probePointCounter + 2*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = 1;
@@ -1437,25 +1441,25 @@ void process_commands()
               }
             }
             clean_up_after_endstop_move();
-            
+
             // solve lsq problem
             double *plane_equation_coefficients = qr_solve(ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS, 3, eqnAMatrix, eqnBVector);
-            
+
             SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[0]);
             SERIAL_PROTOCOLPGM(" b: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[1]);
             SERIAL_PROTOCOLPGM(" d: ");
             SERIAL_PROTOCOLLN(plane_equation_coefficients[2]);
-            
-            
+
+
             set_bed_level_equation_lsq(plane_equation_coefficients);
-            
+
             free(plane_equation_coefficients);
-            
+
 #else // ACCURATE_BED_LEVELING not defined
-            
-            
+
+
             // prob 1
             do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
             do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, BACK_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
@@ -1481,7 +1485,7 @@ void process_commands()
             run_z_probe();
             float z_at_xLeft_yFront = current_position[Z_AXIS];
             retract_z_probe();
-            
+
             SERIAL_PROTOCOLPGM("Bed x: ");
             SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);
             SERIAL_PROTOCOLPGM(" y: ");
@@ -1499,7 +1503,7 @@ void process_commands()
             run_z_probe();
             float z_at_xRight_yFront = current_position[Z_AXIS];
             retract_z_probe(); // Retract Z Servo endstop if available
-            
+
             SERIAL_PROTOCOLPGM("Bed x: ");
             SERIAL_PROTOCOL(RIGHT_PROBE_BED_POSITION);
             SERIAL_PROTOCOLPGM(" y: ");
@@ -1511,13 +1515,13 @@ void process_commands()
             clean_up_after_endstop_move();
 
             set_bed_level_equation(z_at_xLeft_yFront, z_at_xRight_yFront, z_at_xLeft_yBack);
-         
-            
+
+
 #endif // ACCURATE_BED_LEVELING
-            st_synchronize();            
+            st_synchronize();
 
             // The following code correct the Z height difference from z-probe position and hotend tip position.
-            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend. 
+            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend.
             // When the bed is uneven, this height must be corrected.
             real_z = float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS];  //get the real Z (since the auto bed leveling is already correcting the plane)
             x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER;
@@ -1529,11 +1533,11 @@ void process_commands()
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         }
         break;
-        
+
     case 30: // G30 Single Z Probe
         {
             engage_z_probe(); // Engage Z Servo endstop if available
-            
+
             st_synchronize();
             // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
             setup_for_endstop_move();
@@ -1684,14 +1688,14 @@ void process_commands()
         card.removeFile(strchr_pointer + 4);
       }
       break;
-    case 32: //M32 - Select file and start SD print 
+    case 32: //M32 - Select file and start SD print
     {
       if(card.sdprinting) {
         st_synchronize();
 
       }
-      starpos = (strchr(strchr_pointer + 4,'*')); 
-      
+      starpos = (strchr(strchr_pointer + 4,'*'));
+
       char* namestartpos = (strchr(strchr_pointer + 4,'!'));   //find ! to indicate filename string start.
       if(namestartpos==NULL)
       {
@@ -1699,16 +1703,16 @@ void process_commands()
       }
       else
         namestartpos++; //to skip the '!'
-        
+
       if(starpos!=NULL)
         *(starpos-1)='\0';
-            
+
       bool call_procedure=(code_seen('P'));
-      
-      if(strchr_pointer>namestartpos) 
+
+      if(strchr_pointer>namestartpos)
         call_procedure=false;  //false alert, 'P' found within filename
-      
-      if( card.cardOK ) 
+
+      if( card.cardOK )
       {
         card.openFile(namestartpos,true,!call_procedure);
         if(code_seen('S'))
@@ -1781,7 +1785,7 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
         setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
       setWatch();
       break;
     case 140: // M140 set bed temp
@@ -1847,7 +1851,7 @@ void process_commands()
             SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);
           }
         #endif
-		
+
         SERIAL_PROTOCOLLN("");
       return;
       break;
@@ -1865,14 +1869,14 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = true;
       } else if (code_seen('R')) {
         setTargetHotend(code_value(), tmp_extruder);
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = false;
       }
       #ifdef AUTOTEMP
@@ -2036,7 +2040,7 @@ void process_commands()
             SET_OUTPUT(SUICIDE_PIN);
             WRITE(SUICIDE_PIN, HIGH);
         #endif
-        
+
         #ifdef ULTIPANEL
           powersupply = true;
           LCD_MESSAGEPGM(WELCOME_MSG);
@@ -2193,18 +2197,18 @@ void process_commands()
       #endif
       break;
       //TODO: update for all axis, use for loop
-    #ifdef BLINKM  
+    #ifdef BLINKM
     case 150: // M150
       {
         byte red;
         byte grn;
         byte blu;
-        
+
         if(code_seen('R')) red = code_value();
         if(code_seen('U')) grn = code_value();
         if(code_seen('B')) blu = code_value();
-        
-        SendColors(red,grn,blu);        
+
+        SendColors(red,grn,blu);
       }
       break;
     #endif //BLINKM
@@ -2354,7 +2358,7 @@ void process_commands()
       {
         extruder_offset[Z_AXIS][tmp_extruder] = code_value();
       }
-      #endif       
+      #endif
       SERIAL_ECHO_START;
       SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
       for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++)
@@ -2387,17 +2391,17 @@ void process_commands()
       }
     }
     break;
-	
+
 	case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
 	{
       if(code_seen('P')){
         int pin_number = code_value(); // pin number
         int pin_state = -1; // required pin state - default is inverted
-        
+
         if(code_seen('S')) pin_state = code_value(); // required pin state
-      
+
         if(pin_state >= -1 && pin_state <= 1){
-        
+
           for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
           {
             if (sensitive_pins[i] == pin_number)
@@ -2406,28 +2410,28 @@ void process_commands()
               break;
             }
           }
-        
+
           if (pin_number > -1)
           {
             st_synchronize();
-            
+
             pinMode(pin_number, INPUT);
-            
+
             int target;
             switch(pin_state){
             case 1:
               target = HIGH;
               break;
-            
+
             case 0:
               target = LOW;
               break;
-            
+
             case -1:
               target = !digitalRead(pin_number);
               break;
             }
-            
+
             while(digitalRead(pin_number) != target){
               manage_heater();
               manage_inactivity();
@@ -2437,7 +2441,7 @@ void process_commands()
         }
       }
     }
-    break;	
+    break;
 
     #if NUM_SERVOS > 0
     case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
@@ -2615,13 +2619,13 @@ void process_commands()
         engage_z_probe();    // Engage Z Servo endstop if available
     }
     break;
-    
+
     case 402:
     {
         retract_z_probe();    // Retract Z Servo endstop if enabled
     }
     break;
-#endif    
+#endif
     case 500: // M500 Store settings in EEPROM
     {
         Config_StoreSettings();
@@ -2783,14 +2787,14 @@ void process_commands()
               //    M605 S0: Full control mode. The slicer has full control over x-carriage movement
               //    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
               //    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
-              //                         millimeters x-offset and an optional differential hotend temperature of 
+              //                         millimeters x-offset and an optional differential hotend temperature of
               //                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
               //                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
               //
               //    Note: the X axis should be homed after changing dual x-carriage mode.
     {
         st_synchronize();
-        
+
         if (code_seen('S'))
           dual_x_carriage_mode = code_value();
 
@@ -2801,7 +2805,7 @@ void process_commands()
 
           if (code_seen('R'))
             duplicate_extruder_temp_offset = code_value();
-            
+
           SERIAL_ECHO_START;
           SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
           SERIAL_ECHO(" ");
@@ -2817,13 +2821,13 @@ void process_commands()
         {
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
         }
-        
+
         active_extruder_parked = false;
         extruder_duplication_enabled = false;
         delayed_move_time = 0;
     }
     break;
-    #endif //DUAL_X_CARRIAGE         
+    #endif //DUAL_X_CARRIAGE
 
     case 907: // M907 Set digital trimpot motor current using axis codes.
     {
@@ -2841,6 +2845,12 @@ void process_commands()
       #ifdef MOTOR_CURRENT_PWM_E_PIN
         if(code_seen('E')) digipot_current(2, code_value());
       #endif
+      #ifdef DIGIPOT_I2C
+        // this one uses actual amps in floating point
+        for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());
+        // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
+        for(int i=NUM_AXIS;i<DIGIPOT_I2C_NUM_CHANNELS;i++) if(code_seen('B'+i-NUM_AXIS)) digipot_i2c_set_current(i, code_value());
+      #endif
     }
     break;
     case 908: // M908 Control digital trimpot directly.
@@ -2913,19 +2923,19 @@ void process_commands()
         // Save current position to return to after applying extruder offset
         memcpy(destination, current_position, sizeof(destination));
       #ifdef DUAL_X_CARRIAGE
-        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false && 
+        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
             (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
         {
           // Park old head: 1) raise 2) move to park position 3) lower
-          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS], 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
           st_synchronize();
         }
-        
+
         // apply Y & Z extruder offset (x offset is already used in determining home pos)
         current_position[Y_AXIS] = current_position[Y_AXIS] -
                      extruder_offset[Y_AXIS][active_extruder] +
@@ -2933,7 +2943,7 @@ void process_commands()
         current_position[Z_AXIS] = current_position[Z_AXIS] -
                      extruder_offset[Z_AXIS][active_extruder] +
                      extruder_offset[Z_AXIS][tmp_extruder];
-                     
+
         active_extruder = tmp_extruder;
 
         // This function resets the max/min values - the current position may be overwritten below.
@@ -2941,18 +2951,18 @@ void process_commands()
 
         if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)
         {
-          current_position[X_AXIS] = inactive_extruder_x_pos; 
+          current_position[X_AXIS] = inactive_extruder_x_pos;
           inactive_extruder_x_pos = destination[X_AXIS];
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
         {
           active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
           if (active_extruder == 0 || active_extruder_parked)
-            current_position[X_AXIS] = inactive_extruder_x_pos; 
+            current_position[X_AXIS] = inactive_extruder_x_pos;
           else
-            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset; 
+            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
           inactive_extruder_x_pos = destination[X_AXIS];
-          extruder_duplication_enabled = false; 
+          extruder_duplication_enabled = false;
         }
         else
         {
@@ -2962,7 +2972,7 @@ void process_commands()
           active_extruder_parked = true;
           delayed_move_time = 0;
         }
-      #else    
+      #else
         // Offset extruder (only by XY)
         int i;
         for(i = 0; i < 2; i++) {
@@ -3175,13 +3185,13 @@ void prepare_move()
     {
       // move duplicate extruder into correct duplication position.
       plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[X_AXIS], 1);
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
       st_synchronize();
       extruder_duplication_enabled = true;
       active_extruder_parked = false;
-    }  
+    }
     else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head
     {
       if (current_position[E_AXIS] == destination[E_AXIS])
@@ -3190,7 +3200,7 @@ void prepare_move()
         // be used as start of first non-travel move)
         if (delayed_move_time != 0xFFFFFFFFUL)
         {
-          memcpy(current_position, destination, sizeof(current_position)); 
+          memcpy(current_position, destination, sizeof(current_position));
           if (destination[Z_AXIS] > raised_parked_position[Z_AXIS])
             raised_parked_position[Z_AXIS] = destination[Z_AXIS];
           delayed_move_time = millis();
@@ -3200,9 +3210,9 @@ void prepare_move()
       delayed_move_time = 0;
       // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
       plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS],
           current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
       active_extruder_parked = false;
     }
@@ -3350,8 +3360,8 @@ void manage_inactivity()
      enable_e0();
      float oldepos=current_position[E_AXIS];
      float oldedes=destination[E_AXIS];
-     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], 
-                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
+                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                       EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
      current_position[E_AXIS]=oldepos;
      destination[E_AXIS]=oldedes;
@@ -3368,7 +3378,7 @@ void manage_inactivity()
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       memcpy(destination,current_position,sizeof(destination));
-      prepare_move(); 
+      prepare_move();
     }
   #endif
   #ifdef TEMP_STAT_LEDS
diff --git a/Marlin/digipot_mcp4451.cpp b/Marlin/digipot_mcp4451.cpp
new file mode 100644
index 0000000..11ee684
--- /dev/null
+++ b/Marlin/digipot_mcp4451.cpp
@@ -0,0 +1,54 @@
+#include "Configuration.h"
+
+#ifdef DIGIPOT_I2C
+#include "Stream.h"
+#include "utility/twi.h"
+#include "Wire.h"
+
+// Settings for the I2C based DIGIPOT (MCP4451) on Azteeg X3 Pro
+#define DIGIPOT_I2C_FACTOR 106.7
+#define DIGIPOT_I2C_MAX_CURRENT 2.5
+
+static byte current_to_wiper( float current ){
+    return byte(ceil(float((DIGIPOT_I2C_FACTOR*current))));
+}
+
+static void i2c_send(byte addr, byte a, byte b)
+{
+	Wire.beginTransmission(addr);
+    Wire.write(a);
+    Wire.write(b);
+    Wire.endTransmission();
+}
+
+// This is for the MCP4451 I2C based digipot
+void digipot_i2c_set_current( int channel, float current )
+{
+    current = min( (float) max( current, 0.0f ), DIGIPOT_I2C_MAX_CURRENT);
+    // these addresses are specific to Azteeg X3 Pro, can be set to others,
+    // In this case first digipot is at address A0=0, A1= 0, second one is at A0=0, A1= 1
+    byte addr= 0x2C; // channel 0-3
+    if(channel >= 4) {
+    	addr= 0x2E; // channel 4-7
+    	channel-= 4;
+    }
+
+    // Initial setup
+    i2c_send( addr, 0x40, 0xff );
+    i2c_send( addr, 0xA0, 0xff );
+
+    // Set actual wiper value
+    byte addresses[4] = { 0x00, 0x10, 0x60, 0x70 };
+    i2c_send( addr, addresses[channel], current_to_wiper(current) );
+}
+
+void digipot_i2c_init()
+{
+    const float digipot_motor_current[] = DIGIPOT_I2C_MOTOR_CURRENTS;
+    Wire.begin();
+    // setup initial currents as defined in Configuration_adv.h
+    for(int i=0;i<=sizeof(digipot_motor_current)/sizeof(float);i++) {
+        digipot_i2c_set_current(i, digipot_motor_current[i]);
+    }
+}
+#endif
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 1576d52..52ca284 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -375,7 +375,7 @@
 * Arduino Mega pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67
+#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 #define KNOWN_BOARD 1
 
 //////////////////FIX THIS//////////////
@@ -391,10 +391,10 @@
 // #define RAMPS_V_1_0
 
 
-#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67
+#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 
   #define LARGE_FLASH true
-  
+
   #if MOTHERBOARD == 77
     #define X_STEP_PIN         54
     #define X_DIR_PIN          55
@@ -434,7 +434,7 @@
     #define SDSS               25//53
     #define LED_PIN            13
 
-    #define BEEPER             33    
+    #define BEEPER             33
 
   #else
 
@@ -472,21 +472,35 @@
     #define E1_DIR_PIN         34
     #define E1_ENABLE_PIN      30
 
+    #if MOTHERBOARD == 68
+      #define E2_STEP_PIN        23
+      #define E2_DIR_PIN         25
+      #define E2_ENABLE_PIN      40
+
+      #define E3_STEP_PIN        27
+      #define E3_DIR_PIN         29
+      #define E3_ENABLE_PIN      41
+
+      #define E4_STEP_PIN        43
+      #define E4_DIR_PIN         37
+      #define E4_ENABLE_PIN      42
+    #endif
+
     #define SDPOWER            -1
     #define SDSS               53
     #define LED_PIN            13
   #endif
 
-  #if MOTHERBOARD == 33 || MOTHERBOARD == 35 || MOTHERBOARD == 67
+  #if MOTHERBOARD == 33 || MOTHERBOARD == 35 || MOTHERBOARD == 67 || MOTHERBOARD == 68
     #define FAN_PIN            9 // (Sprinter config)
   #else
     #define FAN_PIN            4 // IO pin. Buffer needed
   #endif
 
   #if MOTHERBOARD == 77
-    #define FAN_PIN            8 
+    #define FAN_PIN            8
   #endif
-  
+
   #if MOTHERBOARD == 35
     #define CONTROLLERFAN_PIN  10 //Pin used for the fan to cool controller
   #endif
@@ -511,17 +525,33 @@
     #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
   #endif
 
-  #define HEATER_2_PIN       -1 
 
   #if MOTHERBOARD == 77
-    #define HEATER_0_PIN       10   
-    #define HEATER_1_PIN       12 
-    #define HEATER_2_PIN       6   
+    #define HEATER_0_PIN       10
+    #define HEATER_1_PIN       12
+    #define HEATER_2_PIN       6
+  #elif MOTHERBOARD == 68
+    #define HEATER_2_PIN       16
+    #define HEATER_3_PIN       17
+    #define HEATER_4_PIN       4
+    #define HEATER_5_PIN       5
+    #define HEATER_6_PIN       6
+    #define HEATER_7_PIN       11
+  #else
+    #define HEATER_2_PIN       -1
   #endif
 
   #define TEMP_0_PIN         13   // ANALOG NUMBERING
   #define TEMP_1_PIN         15   // ANALOG NUMBERING
-  #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+  #if MOTHERBOARD == 68
+    #define TEMP_2_PIN         12   // ANALOG NUMBERING
+    #define TEMP_3_PIN         11   // ANALOG NUMBERING
+    #define TEMP_4_PIN         10   // ANALOG NUMBERING
+    #define TC1                4    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+    #define TC2                5    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+  #else
+    #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+  #endif
 
   #if MOTHERBOARD == 35
     #define HEATER_BED_PIN     -1    // NO BED
@@ -532,9 +562,8 @@
       #define HEATER_BED_PIN     8    // BED
     #endif
   #endif
-  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
-
 
+  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
   #ifdef NUM_SERVOS
     #define SERVO0_PIN         11
@@ -552,20 +581,24 @@
     #endif
   #endif
 
+  #if MOTHERBOARD == 68
+    #define BEEPER 33
+  #endif
+
   #ifdef TEMP_STAT_LEDS
     #if MOTHERBOARD == 67
       #define STAT_LED_RED       6
       #define STAT_LED_BLUE     11
     #endif
   #endif
-  
+
   #ifdef ULTRA_LCD
 
     #ifdef NEWPANEL
-      #define LCD_PINS_RS 16 
+      #define LCD_PINS_RS 16
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D5 25
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
 
@@ -613,25 +646,25 @@
         #else
           #define SDCARDDETECT -1  // Ramps does not use this port
         #endif
-    
+
       #endif
-    
-      #if MOTHERBOARD == 77 
-        #define BEEPER -1 
-
-        #define LCD_PINS_RS 27 
-        #define LCD_PINS_ENABLE 29 
-        #define LCD_PINS_D4 37 
-        #define LCD_PINS_D5 35 
-        #define LCD_PINS_D6 33 
-        #define LCD_PINS_D7 31 
-
-       //buttons 
-       #define BTN_EN1 16 
-       #define BTN_EN2 17 
-       #define BTN_ENC 23 //the click 
-
-    #endif 
+
+      #if MOTHERBOARD == 77
+        #define BEEPER -1
+
+        #define LCD_PINS_RS 27
+        #define LCD_PINS_ENABLE 29
+        #define LCD_PINS_D4 37
+        #define LCD_PINS_D5 35
+        #define LCD_PINS_D6 33
+        #define LCD_PINS_D7 31
+
+       //buttons
+       #define BTN_EN1 16
+       #define BTN_EN2 17
+       #define BTN_ENC 23 //the click
+
+    #endif
     #else //old style panel with shift register
       //arduino pin witch triggers an piezzo beeper
       #define BEEPER 33		//No Beeper added
@@ -642,14 +675,14 @@
       //#define SHIFT_LD 42
       //#define SHIFT_OUT 40
       //#define SHIFT_EN 17
-    
-      #define LCD_PINS_RS 16 
+
+      #define LCD_PINS_RS 16
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D5 25
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
-    #endif 
+    #endif
   #endif //ULTRA_LCD
 
 #else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
@@ -694,16 +727,16 @@
 #define HEATER_1_PIN        -1
 #define HEATER_2_PIN        -1
 #define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          -1   
-#define TEMP_2_PIN          -1   
+#define TEMP_1_PIN          -1
+#define TEMP_2_PIN          -1
 #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
 
 #endif // MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 
-// SPI for Max6675 Thermocouple 
+// SPI for Max6675 Thermocouple
 
 #ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  
+// these pins are defined in the SD library if building with SD support
   #define MAX_SCK_PIN          52
   #define MAX_MISO_PIN         50
   #define MAX_MOSI_PIN         51
@@ -837,17 +870,17 @@
   #define BTN_EN1          14
   #define BTN_EN2          39
   #define BTN_ENC          15  //the click
-    
+
   #define BLEN_C           2
   #define BLEN_B           1
   #define BLEN_A           0
-    
+
   //encoder rotation values
   #define encrot0          0
   #define encrot1          2
   #define encrot2          3
   #define encrot3          1
-  
+
 #endif //RA_CONTROL_PANEL
 
 #ifdef RA_DISCO
@@ -861,7 +894,7 @@
   //This currently only works with the RA Board.
   #define TLC_CLOCK_BIT 3 //bit 3 on port A
   #define TLC_CLOCK_PORT &PORTA //bit 3 on port A
-  
+
   #define TLC_BLANK_BIT 1 //bit 1 on port A
   #define TLC_BLANK_PORT &PORTA //bit 1 on port A
 
@@ -871,12 +904,12 @@
   #define TLC_XLAT_BIT 0 //bit 0 on port A
   #define TLC_XLAT_PORT &PORTA //bit 0 on port A
 
-  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful 
+  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful
   //Leave it at at least 1 if you have enabled RA_LIGHTING
   //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.
-  #define NUM_TLCS 2 
+  #define NUM_TLCS 2
 
-  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions. 
+  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions.
   //Modify them according to your specific situation.
   //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.
   #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards
@@ -1085,8 +1118,8 @@
        #define LCD_PINS_D7        27
      #endif
      //The encoder and click button
-     #define BTN_EN1 11  
-     #define BTN_EN2 10 
+     #define BTN_EN1 11
+     #define BTN_EN2 10
      #ifdef LCD_I2C_PANELOLU2
        #ifdef MELZI
          #define BTN_ENC 29 //the click switch
@@ -1098,8 +1131,8 @@
        #define BTN_ENC 16  //the click switch
      #endif //Panelolu2
      //not connected to a pin
-     #define SDCARDDETECT -1    
-    
+     #define SDCARDDETECT -1
+
    #endif //Newpanel
  #endif //Ultipanel
 
@@ -1121,7 +1154,7 @@
      #define BTN_EN2 10
      #define BTN_ENC 16  //the click switch
      //not connected to a pin
-     #define SDCARDDETECT -1    
+     #define SDCARDDETECT -1
  #endif //Makrpanel
 
 #endif
@@ -1204,9 +1237,9 @@
     #define BTN_EN1 40
     #define BTN_EN2 42
     #define BTN_ENC 19  //the click
-    
+
     #define SDCARDDETECT 38
-    
+
   #else //old style panel with shift register
     //arduino pin witch triggers an piezzo beeper
     #define BEEPER 18
@@ -1223,9 +1256,9 @@
     #define LCD_PINS_D5 21
     #define LCD_PINS_D6 20
     #define LCD_PINS_D7 19
-  
+
     #define SDCARDDETECT -1
-  #endif 
+  #endif
 #endif //ULTRA_LCD
 
 #endif
@@ -1358,7 +1391,7 @@
 #define MOTOR_CURRENT_PWM_Z_PIN 45
 #define MOTOR_CURRENT_PWM_E_PIN 46
 //Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
-#define MOTOR_CURRENT_PWM_RANGE 2000
+#define MOTOR_CURRENT_PWM_RANGE 2000
 #define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}
 
 //arduino pin witch triggers an piezzo beeper
@@ -1443,7 +1476,7 @@
  #else
   #define TEMP_0_PIN         15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used
  #endif
-#endif 
+#endif
 
 #if (TEMP_SENSOR_1==0)
  #define TEMP_1_PIN         -1
@@ -2153,13 +2186,13 @@
     #define BTN_EN1 59
     #define BTN_EN2 64
     #define BTN_ENC 43  //the click
-    
+
     #define BLEN_C 2
     #define BLEN_B 1
     #define BLEN_A 0
-    
+
     #define SDCARDDETECT -1		// Ramps does not use this port
-    
+
       //encoder rotation values
     #define encrot0 0
     #define encrot1 2
@@ -2176,102 +2209,102 @@
 ****************************************************************************************/
 #if MOTHERBOARD == 701
  #define KNOWN_BOARD 1
- 
- 
+
+
  #ifndef __AVR_ATmega2560__
  #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
  #endif
- 
+
  #define LARGE_FLASH        true
- 
+
  #define X_STEP_PIN 26
  #define X_DIR_PIN 27
  #define X_ENABLE_PIN 25
  #define X_MIN_PIN 37
  #define X_MAX_PIN 40 //2 //Max endstops default to disabled "-1", set to commented value to enable.
- 
+
  #define Y_STEP_PIN 4 // A6
  #define Y_DIR_PIN 54 // A0
  #define Y_ENABLE_PIN 5
  #define Y_MIN_PIN 41
  #define Y_MAX_PIN 38 //15
- 
+
  #define Z_STEP_PIN 56 // A2
  #define Z_DIR_PIN 60 // A6
  #define Z_ENABLE_PIN 55 // A1
  #define Z_MIN_PIN 18
  #define Z_MAX_PIN 19
- 
+
  #define E0_STEP_PIN 35
  #define E0_DIR_PIN 36
  #define E0_ENABLE_PIN 34
- 
+
  #define E1_STEP_PIN 29
  #define E1_DIR_PIN 39
  #define E1_ENABLE_PIN 28
- 
+
  #define E2_STEP_PIN 23
  #define E2_DIR_PIN 24
  #define E2_ENABLE_PIN 22
- 
+
  #define SDPOWER -1
  #define SDSS 53
  #define LED_PIN 13
- 
+
  #define FAN_PIN 7
  #define FAN2_PIN 6
  #define PS_ON_PIN 12
  #define KILL_PIN -1
- 
+
  #define HEATER_0_PIN 9 // EXTRUDER 1
  #define HEATER_1_PIN 8 // EXTRUDER 2
  #define HEATER_2_PIN -1
- 
+
  #if TEMP_SENSOR_0 == -1
    #define TEMP_0_PIN 4 // ANALOG NUMBERING
  #else
    #define TEMP_0_PIN 13 // ANALOG NUMBERING
  #endif
- 
- 
+
+
  #if TEMP_SENSOR_1 == -1
    #define TEMP_1_PIN 8 // ANALOG NUMBERING
  #else
    #define TEMP_1_PIN 15 // ANALOG NUMBERING
  #endif
- 
+
  #define TEMP_2_PIN -1 // ANALOG NUMBERING
- 
+
  #define HEATER_BED_PIN 10 // BED
- 
+
  #if TEMP_SENSOR_BED == -1
    #define TEMP_BED_PIN 8 // ANALOG NUMBERING
- #else 
+ #else
    #define TEMP_BED_PIN 14 // ANALOG NUMBERING
  #endif
- 
- #define BEEPER 64	
- 
- 
+
+ #define BEEPER 64
+
+
  #define LCD_PINS_RS 14
  #define LCD_PINS_ENABLE 15
  #define LCD_PINS_D4 30
  #define LCD_PINS_D5 31
  #define LCD_PINS_D6 32
  #define LCD_PINS_D7 33
- 
- 
+
+
  //buttons are directly attached using keypad
  #define BTN_EN1 61
  #define BTN_EN2 59
  #define BTN_ENC 43 //the click
- 
+
  #define BLEN_C 2
  #define BLEN_B 1
  #define BLEN_A 0
- 
+
  #define SDCARDDETECT -1	// Megatronics does not use this port
- 
+
    //encoder rotation values
  #define encrot0 0
  #define encrot1 2
@@ -2287,87 +2320,87 @@
 ****************************************************************************************/
 #if MOTHERBOARD == 702
  #define KNOWN_BOARD 1
- 
- 
+
+
  #ifndef __AVR_ATmega1281__
  #error Oops! Make sure you have 'Minitronics ' selected from the 'Tools -> Boards' menu.
  #endif
- 
+
  #define LARGE_FLASH        true
- 
+
  #define X_STEP_PIN 48
  #define X_DIR_PIN 47
  #define X_ENABLE_PIN 49
  #define X_MIN_PIN 5
  #define X_MAX_PIN -1 //2 //Max endstops default to disabled "-1", set to commented value to enable.
- 
+
  #define Y_STEP_PIN 39 // A6
  #define Y_DIR_PIN 40 // A0
  #define Y_ENABLE_PIN 38
  #define Y_MIN_PIN 2
  #define Y_MAX_PIN -1 //15
- 
+
  #define Z_STEP_PIN 42 // A2
  #define Z_DIR_PIN 43 // A6
  #define Z_ENABLE_PIN 41 // A1
  #define Z_MIN_PIN 6
  #define Z_MAX_PIN -1
- 
+
  #define E0_STEP_PIN 45
  #define E0_DIR_PIN 44
  #define E0_ENABLE_PIN 27
- 
+
  #define E1_STEP_PIN 36
  #define E1_DIR_PIN 35
  #define E1_ENABLE_PIN 37
- 
+
  #define E2_STEP_PIN -1
  #define E2_DIR_PIN -1
  #define E2_ENABLE_PIN -1
- 
+
  #define SDPOWER -1
  #define SDSS 16
  #define LED_PIN 46
- 
+
  #define FAN_PIN 9
  #define FAN2_PIN -1
  #define PS_ON_PIN -1
  #define KILL_PIN -1
- 
+
  #define HEATER_0_PIN 7 // EXTRUDER 1
  #define HEATER_1_PIN 8 // EXTRUDER 2
  #define HEATER_2_PIN -1
- 
+
 
  #define TEMP_0_PIN 7 // ANALOG NUMBERING
  #define TEMP_1_PIN 6 // ANALOG NUMBERING
  #define TEMP_2_PIN -1 // ANALOG NUMBERING
- 
+
  #define HEATER_BED_PIN 3 // BED
  #define TEMP_BED_PIN 6 // ANALOG NUMBERING
- 
- #define BEEPER -1	
- 
- 
+
+ #define BEEPER -1
+
+
  #define LCD_PINS_RS -1
  #define LCD_PINS_ENABLE -1
  #define LCD_PINS_D4 -1
  #define LCD_PINS_D5 -1
  #define LCD_PINS_D6 -1
  #define LCD_PINS_D7 -1
- 
- 
+
+
  //buttons are directly attached using keypad
  #define BTN_EN1 -1
  #define BTN_EN2 -1
  #define BTN_ENC -1 //the click
- 
+
  #define BLEN_C 2
  #define BLEN_B 1
  #define BLEN_A 0
- 
+
  #define SDCARDDETECT -1	// Megatronics does not use this port
- 
+
    //encoder rotation values
  #define encrot0 0
  #define encrot1 2
@@ -2393,7 +2426,7 @@
  #define X_STEP_PIN 14
  #define X_DIR_PIN 15
  #define X_ENABLE_PIN 24
- 
+
  //X endstop
  #define X_MIN_PIN 3
  #define X_MAX_PIN -1
@@ -2406,7 +2439,7 @@
  //Y endstop
  #define Y_MIN_PIN 2
  #define Y_MAX_PIN -1
- 
+
  //Z motor stepper
  #define Z_STEP_PIN 40
  #define Z_DIR_PIN 41
@@ -2415,7 +2448,7 @@
  //Z endstop
  #define Z_MIN_PIN 5
  #define Z_MAX_PIN -1
- 
+
  //Extruder 0 stepper
  #define E0_STEP_PIN 26
  #define E0_DIR_PIN 28
@@ -2442,7 +2475,7 @@
  #define HEATER_BED_PIN 22
  //Cheaptronic v1.0 hasent EXTRUDER 3
  #define HEATER_2_PIN -1
- 
+
  //Temperature sensors
  #define TEMP_0_PIN 15
  #define TEMP_1_PIN 14

