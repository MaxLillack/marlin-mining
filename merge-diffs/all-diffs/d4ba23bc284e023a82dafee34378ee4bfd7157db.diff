commit d4ba23bc284e023a82dafee34378ee4bfd7157db (from bbb424bd2fd3e4c3f65883699a8b32cdc0a1ca0b)
Merge: bbb424b 477b6fa
Author: nothinman <martin@lukasik.name>
Date:   Mon Feb 17 11:27:05 2014 +0000

    Merge pull request #770 from josefpavlik/Marlin_v1
    
    Marlin v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 6a2c43b..bf7f38d 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -123,6 +123,11 @@
 // 51 is 100k thermistor - EPCOS (1k pullup)
 // 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
 // 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+//
+// 1047 is Pt1000 with 4k7 pullup
+// 1010 is Pt1000 with 1k pullup (non standard)
+// 147 is Pt100 with 4k7 pullup
+// 110 is Pt100 with 1k pullup (non standard)
 
 #define TEMP_SENSOR_0 -1
 #define TEMP_SENSOR_1 -1
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index a28393e..7a4b864 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -189,6 +189,8 @@ void enquecommand_P(const char *cmd); //put an ascii command at the end of the c
 void prepare_arc_move(char isclockwise);
 void clamp_to_software_endstops(float target[3]);
 
+void refresh_cmd_timeout(void);
+
 #ifdef FAST_PWM_FAN
 void setPwmFrequency(uint8_t pin, int val);
 #endif
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 2b8138f..498adfd 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1080,6 +1080,10 @@ static void homeaxis(int axis) {
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
++void refresh_cmd_timeout(void)
+{
+  previous_millis_cmd = millis();
+}
 
 void process_commands()
 {
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 58a2466..1d2b3ca 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -857,6 +857,70 @@ const short temptable_60[][2] PROGMEM = {
 };
 #endif
 
+// Pt1000 and Pt100 handling
+// 
+// Rt=R0*(1+a*T+b*T*T) [for T>0]
+// a=3.9083E-3, b=-5.775E-7
+
+#define PtA 3.9083E-3
+#define PtB -5.775E-7
+#define PtRt(T,R0) ((R0)*(1.0+(PtA)*(T)+(PtB)*(T)*(T)))
+#define PtAdVal(T,R0,Rup) (short)(1024/(Rup/PtRt(T,R0)+1))
+#define PtLine(T,R0,Rup) { PtAdVal(T,R0,Rup)*OVERSAMPLENR, T },
+
+#if (THERMISTORHEATER_0 == 110) || (THERMISTORHEATER_1 == 110) || (THERMISTORHEATER_2 == 110) || (THERMISTORBED == 110) // Pt100 with 1k0 pullup
+const short temptable_110[][2] PROGMEM = {
+// only few values are needed as the curve is very flat  
+  PtLine(0,100,1000)
+  PtLine(50,100,1000)
+  PtLine(100,100,1000)
+  PtLine(150,100,1000)
+  PtLine(200,100,1000)
+  PtLine(250,100,1000)
+  PtLine(300,100,1000)
+};
+#endif
+#if (THERMISTORHEATER_0 == 147) || (THERMISTORHEATER_1 == 147) || (THERMISTORHEATER_2 == 147) || (THERMISTORBED == 147) // Pt100 with 4k7 pullup
+const short temptable_147[][2] PROGMEM = {
+// only few values are needed as the curve is very flat  
+  PtLine(0,100,4700)
+  PtLine(50,100,4700)
+  PtLine(100,100,4700)
+  PtLine(150,100,4700)
+  PtLine(200,100,4700)
+  PtLine(250,100,4700)
+  PtLine(300,100,4700)
+};
+#endif
+#if (THERMISTORHEATER_0 == 1010) || (THERMISTORHEATER_1 == 1010) || (THERMISTORHEATER_2 == 1010) || (THERMISTORBED == 1010) // Pt1000 with 1k0 pullup
+const short temptable_1010[][2] PROGMEM = {
+  PtLine(0,1000,1000)
+  PtLine(25,1000,1000)
+  PtLine(50,1000,1000)
+  PtLine(75,1000,1000)
+  PtLine(100,1000,1000)
+  PtLine(125,1000,1000)
+  PtLine(150,1000,1000)
+  PtLine(175,1000,1000)
+  PtLine(200,1000,1000)
+  PtLine(225,1000,1000)
+  PtLine(250,1000,1000)
+  PtLine(275,1000,1000)
+  PtLine(300,1000,1000)
+};
+#endif
+#if (THERMISTORHEATER_0 == 1047) || (THERMISTORHEATER_1 == 1047) || (THERMISTORHEATER_2 == 1047) || (THERMISTORBED == 1047) // Pt1000 with 4k7 pullup
+const short temptable_1047[][2] PROGMEM = {
+// only few values are needed as the curve is very flat  
+  PtLine(0,1000,4700)
+  PtLine(50,1000,4700)
+  PtLine(100,1000,4700)
+  PtLine(150,1000,4700)
+  PtLine(200,1000,4700)
+  PtLine(250,1000,4700)
+  PtLine(300,1000,4700)
+};
+#endif
 
 #define _TT_NAME(_N) temptable_ ## _N
 #define TT_NAME(_N) _TT_NAME(_N)
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index d3f4e32..8961b67 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -460,6 +460,7 @@ static void lcd_move_x()
 {
     if (encoderPosition != 0)
     {
+        refresh_cmd_timeout();
         current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;
         if (min_software_endstops && current_position[X_AXIS] < X_MIN_POS)
             current_position[X_AXIS] = X_MIN_POS;
@@ -489,6 +490,7 @@ static void lcd_move_y()
 {
     if (encoderPosition != 0)
     {
+        refresh_cmd_timeout();
         current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;
         if (min_software_endstops && current_position[Y_AXIS] < Y_MIN_POS)
             current_position[Y_AXIS] = Y_MIN_POS;
@@ -518,6 +520,7 @@ static void lcd_move_z()
 {
     if (encoderPosition != 0)
     {
+        refresh_cmd_timeout();
         current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;
         if (min_software_endstops && current_position[Z_AXIS] < Z_MIN_POS)
             current_position[Z_AXIS] = Z_MIN_POS;

commit d4ba23bc284e023a82dafee34378ee4bfd7157db (from 477b6fa1df30d1ff6021df103d5bb5efef31ee4a)
Merge: bbb424b 477b6fa
Author: nothinman <martin@lukasik.name>
Date:   Mon Feb 17 11:27:05 2014 +0000

    Merge pull request #770 from josefpavlik/Marlin_v1
    
    Marlin v1

diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
index f18a5ff..4e4d214 100644
--- a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
@@ -44,9 +44,9 @@ atmega12848m.upload.protocol=stk500
 atmega12848m.upload.maximum_size=131072
 atmega12848m.upload.speed=19200
 
-atmega12848m.bootloader.low_fuses=0xFD
-atmega12848m.bootloader.high_fuses=0x9A
-atmega12848m.bootloader.extended_fuses=0xFF
+atmega12848m.bootloader.low_fuses=0xD6
+atmega12848m.bootloader.high_fuses=0xDA
+atmega12848m.bootloader.extended_fuses=0xFD
 atmega12848m.bootloader.path=atmega
 atmega12848m.bootloader.file=ATmegaBOOT_168_atmega1284p_8m.hex
 atmega12848m.bootloader.unlock_bits=0x3F
@@ -64,9 +64,9 @@ atmega1284.upload.protocol=stk500
 atmega1284.upload.maximum_size=131072
 atmega1284.upload.speed=57600
 
-atmega1284.bootloader.low_fuses=0xFF
-atmega1284.bootloader.high_fuses=0x9A
-atmega1284.bootloader.extended_fuses=0xFF
+atmega1284.bootloader.low_fuses=0xD6
+atmega1284.bootloader.high_fuses=0xDA
+atmega1284.bootloader.extended_fuses=0xFD
 atmega1284.bootloader.path=atmega
 atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
 atmega1284.bootloader.unlock_bits=0x3F
@@ -85,9 +85,9 @@ atmega1284s.upload.protocol=stk500
 atmega1284s.upload.maximum_size=131072
 atmega1284s.upload.speed=57600
 
-atmega1284s.bootloader.low_fuses=0xFF
-atmega1284s.bootloader.high_fuses=0x9A
-atmega1284s.bootloader.extended_fuses=0xFF
+atmega1284s.bootloader.low_fuses=0xD6
+atmega1284s.bootloader.high_fuses=0xDA
+atmega1284s.bootloader.extended_fuses=0xFD
 atmega1284s.bootloader.path=atmega
 atmega1284s.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
 atmega1284s.bootloader.unlock_bits=0x3F
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt b/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt
deleted file mode 100644
index c1a1f08..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt
+++ /dev/null
@@ -1,85 +0,0 @@
-############################################################
-
-atmega644.name=Sanguino W/ ATmega644P
-
-atmega644.upload.protocol=stk500
-atmega644.upload.maximum_size=63488
-atmega644.upload.speed=57600
-
-atmega644.bootloader.low_fuses=0xFF
-atmega644.bootloader.high_fuses=0x9A
-atmega644.bootloader.extended_fuses=0xFF
-atmega644.bootloader.path=atmega
-atmega644.bootloader.file=ATmegaBOOT_168_atmega644p.hex
-#atmega644.bootloader.file=ATmegaBOOT_644P.hex
-atmega644.bootloader.unlock_bits=0x3F
-atmega644.bootloader.lock_bits=0x0F
-
-atmega644.build.mcu=atmega644p
-atmega644.build.f_cpu=16000000L
-atmega644.build.core=arduino
-atmega644.build.variant=standard
-##############################################################
-
-atmega12848m.name=Sanguino W/ ATmega1284p 8mhz
-
-atmega12848m.upload.protocol=stk500
-atmega12848m.upload.maximum_size=131072
-atmega12848m.upload.speed=19200
-
-atmega12848m.bootloader.low_fuses=0xFD
-atmega12848m.bootloader.high_fuses=0x9A
-atmega12848m.bootloader.extended_fuses=0xFF
-atmega12848m.bootloader.path=atmega
-atmega12848m.bootloader.file=ATmegaBOOT_168_atmega1284p_8m.hex
-atmega12848m.bootloader.unlock_bits=0x3F
-atmega12848m.bootloader.lock_bits=0x0F
-
-atmega12848m.build.mcu=atmega1284p
-atmega12848m.build.f_cpu=8000000L
-atmega12848m.build.core=arduino
-atmega12848m.build.variant=standard
-
-##############################################################
-
-atmega1284.name=Sanguino W/ ATmega1284p 16mhz
-
-atmega1284.upload.protocol=stk500
-atmega1284.upload.maximum_size=131072
-atmega1284.upload.speed=57600
-
-atmega1284.bootloader.low_fuses=0xFF
-atmega1284.bootloader.high_fuses=0x9A
-atmega1284.bootloader.extended_fuses=0xFF
-atmega1284.bootloader.path=atmega
-atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
-atmega1284.bootloader.unlock_bits=0x3F
-atmega1284.bootloader.lock_bits=0x0F
-
-atmega1284.build.mcu=atmega1284p
-atmega1284.build.f_cpu=16000000L
-atmega1284.build.core=arduino
-atmega1284.build.variant=standard
-#
-
-##############################################################
-
-atmega1284.name=Sanguino W/ ATmega1284p 16mhz ceramic resonator
-
-atmega1284.upload.protocol=stk500
-atmega1284.upload.maximum_size=131072
-atmega1284.upload.speed=57600
-
-atmega1284.bootloader.low_fuses=0xD6
-atmega1284.bootloader.high_fuses=0xDC
-atmega1284.bootloader.extended_fuses=0xFD
-atmega1284.bootloader.path=atmega
-atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
-atmega1284.bootloader.unlock_bits=0x3F
-atmega1284.bootloader.lock_bits=0x0F
-
-atmega1284.build.mcu=atmega1284p
-atmega1284.build.f_cpu=16000000L
-atmega1284.build.core=arduino
-atmega1284.build.variant=standard
-#
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c
deleted file mode 100644
index 1df3f03..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c
+++ /dev/null
@@ -1,1071 +0,0 @@
-/**********************************************************/
-/* Serial Bootloader for Atmel megaAVR Controllers        */
-/*                                                        */
-/* tested with ATmega8, ATmega128 and ATmega168           */
-/* should work with other mega's, see code for details    */
-/*                                                        */
-/* ATmegaBOOT.c                                           */
-/*                                                        */
-/*                                                        */
-/* 20090308: integrated Mega changes into main bootloader */
-/*           source by D. Mellis                          */
-/* 20080930: hacked for Arduino Mega (with the 1280       */
-/*           processor, backwards compatible)             */
-/*           by D. Cuartielles                            */
-/* 20070626: hacked for Arduino Diecimila (which auto-    */
-/*           resets when a USB connection is made to it)  */
-/*           by D. Mellis                                 */
-/* 20060802: hacked for Arduino by D. Cuartielles         */
-/*           based on a previous hack by D. Mellis        */
-/*           and D. Cuartielles                           */
-/*                                                        */
-/* Monitor and debug functions were added to the original */
-/* code by Dr. Erik Lins, chip45.com. (See below)         */
-/*                                                        */
-/* Thanks to Karl Pitrich for fixing a bootloader pin     */
-/* problem and more informative LED blinking!             */
-/*                                                        */
-/* For the latest version see:                            */
-/* http://www.chip45.com/                                 */
-/*                                                        */
-/* ------------------------------------------------------ */
-/*                                                        */
-/* based on stk500boot.c                                  */
-/* Copyright (c) 2003, Jason P. Kyle                      */
-/* All rights reserved.                                   */
-/* see avr1.org for original file and information         */
-/*                                                        */
-/* This program is free software; you can redistribute it */
-/* and/or modify it under the terms of the GNU General    */
-/* Public License as published by the Free Software       */
-/* Foundation; either version 2 of the License, or        */
-/* (at your option) any later version.                    */
-/*                                                        */
-/* This program is distributed in the hope that it will   */
-/* be useful, but WITHOUT ANY WARRANTY; without even the  */
-/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
-/* PARTICULAR PURPOSE.  See the GNU General Public        */
-/* License for more details.                              */
-/*                                                        */
-/* You should have received a copy of the GNU General     */
-/* Public License along with this program; if not, write  */
-/* to the Free Software Foundation, Inc.,                 */
-/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
-/*                                                        */
-/* Licence can be viewed at                               */
-/* http://www.fsf.org/licenses/gpl.txt                    */
-/*                                                        */
-/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
-/* m8515,m8535. ATmega161 has a very small boot block so  */
-/* isn't supported.                                       */
-/*                                                        */
-/* Tested with m168                                       */
-/**********************************************************/
-
-/* $Id$ */
-
-
-/* some includes */
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/wdt.h>
-#include <util/delay.h>
-
-/* the current avr-libc eeprom functions do not support the ATmega168 */
-/* own eeprom write/read functions are used instead */
-#if !defined(__AVR_ATmega168__) || !defined(__AVR_ATmega328P__)
-#include <avr/eeprom.h>
-#endif
-
-/* Use the F_CPU defined in Makefile */
-
-/* 20060803: hacked by DojoCorp */
-/* 20070626: hacked by David A. Mellis to decrease waiting time for auto-reset */
-/* set the waiting time for the bootloader */
-/* get this from the Makefile instead */
-/* #define MAX_TIME_COUNT (F_CPU>>4) */
-
-/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
-#define MAX_ERROR_COUNT 5
-
-/* set the UART baud rate */
-/* 20060803: hacked by DojoCorp */
-//#define BAUD_RATE   115200
-#ifndef BAUD_RATE
-#define BAUD_RATE   19200
-#endif
-
-
-/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
-/* never allow AVR Studio to do an update !!!! */
-#define HW_VER	 0x02
-#define SW_MAJOR 0x01
-#define SW_MINOR 0x10
-
-
-/* Adjust to suit whatever pin your hardware uses to enter the bootloader */
-/* ATmega128 has two UARTS so two pins are used to enter bootloader and select UART */
-/* ATmega1280 has four UARTS, but for Arduino Mega, we will only use RXD0 to get code */
-/* BL0... means UART0, BL1... means UART1 */
-#ifdef __AVR_ATmega128__
-#define BL_DDR  DDRF
-#define BL_PORT PORTF
-#define BL_PIN  PINF
-#define BL0     PINF7
-#define BL1     PINF6
-#elif defined __AVR_ATmega1280__ 
-/* we just don't do anything for the MEGA and enter bootloader on reset anyway*/
-#elif defined __AVR_ATmega1284P_ || defined __AVR_ATmega644P__
-
-#else
-/* other ATmegas have only one UART, so only one pin is defined to enter bootloader */
-#define BL_DDR  DDRD
-#define BL_PORT PORTD
-#define BL_PIN  PIND
-#define BL      PIND6
-#endif
-
-
-/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
-/* if monitor functions are included, LED goes on after monitor was entered */
-#if defined __AVR_ATmega128__ || defined __AVR_ATmega1280__
-/* Onboard LED is connected to pin PB7 (e.g. Crumb128, PROBOmega128, Savvy128, Arduino Mega) */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB7
-#elif defined __AVR_ATmega1284P__ || defined __AVR_ATmega644P__
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB0
-#else
-/* Onboard LED is connected to pin PB5 in Arduino NG, Diecimila, and Duomilanuove */ 
-/* other boards like e.g. Crumb8, Crumb168 are using PB2 */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB5
-#endif
-
-
-/* monitor functions will only be compiled when using ATmega128, due to bootblock size constraints */
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
-#define MONITOR 1
-#endif
-
-
-/* define various device id's */
-/* manufacturer byte is always the same */
-#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
-
-#if defined __AVR_ATmega1280__
-#define SIG2	0x97
-#define SIG3	0x03
-#define PAGE_SIZE	0x80U	//128 words
-
-#elif defined __AVR_ATmega1284P__
-#define SIG2	0x97
-#define SIG3	0x05
-#define PAGE_SIZE	0x080U   //128 words
-
-#elif defined __AVR_ATmega1281__
-#define SIG2	0x97
-#define SIG3	0x04
-#define PAGE_SIZE	0x80U	//128 words
-
-#elif defined __AVR_ATmega644P__
-#define SIG2    0x96
-#define SIG3    0x0A
-#define PAGE_SIZE       0x080U   //128 words
-
-#elif defined __AVR_ATmega128__
-#define SIG2	0x97
-#define SIG3	0x02
-#define PAGE_SIZE	0x80U	//128 words
-
-#elif defined __AVR_ATmega64__
-#define SIG2	0x96
-#define SIG3	0x02
-#define PAGE_SIZE	0x80U	//128 words
-
-#elif defined __AVR_ATmega32__
-#define SIG2	0x95
-#define SIG3	0x02
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega16__
-#define SIG2	0x94
-#define SIG3	0x03
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega8__
-#define SIG2	0x93
-#define SIG3	0x07
-#define PAGE_SIZE	0x20U	//32 words
-
-#elif defined __AVR_ATmega88__
-#define SIG2	0x93
-#define SIG3	0x0a
-#define PAGE_SIZE	0x20U	//32 words
-
-#elif defined __AVR_ATmega168__
-#define SIG2	0x94
-#define SIG3	0x06
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega328P__
-#define SIG2	0x95
-#define SIG3	0x0F
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega162__
-#define SIG2	0x94
-#define SIG3	0x04
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega163__
-#define SIG2	0x94
-#define SIG3	0x02
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega169__
-#define SIG2	0x94
-#define SIG3	0x05
-#define PAGE_SIZE	0x40U	//64 words
-
-#elif defined __AVR_ATmega8515__
-#define SIG2	0x93
-#define SIG3	0x06
-#define PAGE_SIZE	0x20U	//32 words
-
-#elif defined __AVR_ATmega8535__
-#define SIG2	0x93
-#define SIG3	0x08
-#define PAGE_SIZE	0x20U	//32 words
-#endif
-
-
-/* function prototypes */
-void putch(char);
-char getch(void);
-void getNch(uint8_t);
-void byte_response(uint8_t);
-void nothing_response(void);
-char gethex(void);
-void puthex(char);
-void flash_led(uint8_t);
-
-/* some variables */
-union address_union {
-	uint16_t word;
-	uint8_t  byte[2];
-} address;
-
-union length_union {
-	uint16_t word;
-	uint8_t  byte[2];
-} length;
-
-struct flags_struct {
-	unsigned eeprom : 1;
-	unsigned rampz  : 1;
-} flags;
-
-uint8_t buff[256];
-uint8_t address_high;
-
-uint8_t pagesz=0x80;
-
-uint8_t i;
-uint8_t bootuart = 0;
-
-uint8_t error_count = 0;
-
-void (*app_start)(void) = 0x0000;
-
-
-/* main program starts here */
-int main(void)
-{
-	uint8_t ch,ch2;
-	uint16_t w;
-
-#ifdef WATCHDOG_MODS
-	ch = MCUSR;
-	MCUSR = 0;
-
-	WDTCSR |= _BV(WDCE) | _BV(WDE);
-	WDTCSR = 0;
-
-	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-	if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
-		app_start();  // skip bootloader
-#else
-	asm volatile("nop\n\t");
-#endif
-
-	/* set pin direction for bootloader pin and enable pullup */
-	/* for ATmega128, two pins need to be initialized */
-#ifdef __AVR_ATmega128__
-	BL_DDR &= ~_BV(BL0);
-	BL_DDR &= ~_BV(BL1);
-	BL_PORT |= _BV(BL0);
-	BL_PORT |= _BV(BL1);
-#else
-	/* We run the bootloader regardless of the state of this pin.  Thus, don't
-	put it in a different state than the other pins.  --DAM, 070709
-	This also applies to Arduino Mega -- DC, 080930
-	BL_DDR &= ~_BV(BL);
-	BL_PORT |= _BV(BL);
-	*/
-#endif
-
-
-#ifdef __AVR_ATmega128__
-	/* check which UART should be used for booting */
-	if(bit_is_clear(BL_PIN, BL0)) {
-		bootuart = 1;
-	}
-	else if(bit_is_clear(BL_PIN, BL1)) {
-		bootuart = 2;
-	}
-#endif
-
-#if defined __AVR_ATmega1280__  || defined __AVR_ATmega1284P__ || defined __AVR_ATmega644P__
-	/* the mega1280 chip has four serial ports ... we could eventually use any of them, or not? */
-	/* however, we don't wanna confuse people, to avoid making a mess, we will stick to RXD0, TXD0 */
-	bootuart = 1;
-#endif
-
-	/* check if flash is programmed already, if not start bootloader anyway */
-	if(pgm_read_byte_near(0x0000) != 0xFF) {
-
-#ifdef __AVR_ATmega128__
-	/* no UART was selected, start application */
-	if(!bootuart) {
-		app_start();
-	}
-#else
-	/* check if bootloader pin is set low */
-	/* we don't start this part neither for the m8, nor m168 */
-	//if(bit_is_set(BL_PIN, BL)) {
-	//      app_start();
-	//    }
-#endif
-	}
-
-#ifdef __AVR_ATmega128__    
-	/* no bootuart was selected, default to uart 0 */
-	if(!bootuart) {
-		bootuart = 1;
-	}
-#endif
-
-
-	/* initialize UART(s) depending on CPU defined */
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)  || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	if(bootuart == 1) {
-		UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-		UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-		UCSR0A = 0x00;
-		UCSR0C = 0x06;
-		UCSR0B = _BV(TXEN0)|_BV(RXEN0);
-	}
-	if(bootuart == 2) {
-		UBRR1L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-		UBRR1H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-		UCSR1A = 0x00;
-		UCSR1C = 0x06;
-		UCSR1B = _BV(TXEN1)|_BV(RXEN1);
-	}
-#elif defined __AVR_ATmega163__
-	UBRR = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-	UBRRHI = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-	UCSRA = 0x00;
-	UCSRB = _BV(TXEN)|_BV(RXEN);	
-#elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
-
-#ifdef DOUBLE_SPEED
-	UCSR0A = (1<<U2X0); //Double speed mode USART0
-	UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*8L)-1);
-	UBRR0H = (F_CPU/(BAUD_RATE*8L)-1) >> 8;
-#else
-	UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-	UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-#endif
-
-	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
-	UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
-
-	/* Enable internal pull-up resistor on pin D0 (RX), in order
-	to supress line noise that prevents the bootloader from
-	timing out (DAM: 20070509) */
-	DDRD &= ~_BV(PIND0);
-	PORTD |= _BV(PIND0);
-#elif defined __AVR_ATmega8__
-	/* m8 */
-	UBRRH = (((F_CPU/BAUD_RATE)/16)-1)>>8; 	// set baud rate
-	UBRRL = (((F_CPU/BAUD_RATE)/16)-1);
-	UCSRB = (1<<RXEN)|(1<<TXEN);  // enable Rx & Tx
-	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);  // config USART; 8N1
-#else
-	/* m16,m32,m169,m8515,m8535 */
-	UBRRL = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-	UBRRH = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-	UCSRA = 0x00;
-	UCSRC = 0x06;
-	UCSRB = _BV(TXEN)|_BV(RXEN);
-#endif
-
-#if defined __AVR_ATmega1280__
-	/* Enable internal pull-up resistor on pin D0 (RX), in order
-	to supress line noise that prevents the bootloader from
-	timing out (DAM: 20070509) */
-	/* feature added to the Arduino Mega --DC: 080930 */
-	DDRE &= ~_BV(PINE0);
-	PORTE |= _BV(PINE0);
-#endif
-
-
-	/* set LED pin as output */
-	LED_DDR |= _BV(LED);
-
-
-	/* flash onboard LED to signal entering of bootloader */
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	// 4x for UART0, 5x for UART1
-	flash_led(NUM_LED_FLASHES + bootuart);
-#else
-	flash_led(NUM_LED_FLASHES);
-#endif
-
-	/* 20050803: by DojoCorp, this is one of the parts provoking the
-		 system to stop listening, cancelled from the original */
-	//putch('\0');
-
-	/* forever loop */
-	for (;;) {
-
-	/* get character from UART */
-	ch = getch();
-
-	/* A bunch of if...else if... gives smaller code than switch...case ! */
-
-	/* Hello is anyone home ? */ 
-	if(ch=='0') {
-		nothing_response();
-	}
-
-
-	/* Request programmer ID */
-	/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
-	/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
-	else if(ch=='1') {
-		if (getch() == ' ') {
-			putch(0x14);
-			putch('A');
-			putch('V');
-			putch('R');
-			putch(' ');
-			putch('I');
-			putch('S');
-			putch('P');
-			putch(0x10);
-		} else {
-			if (++error_count == MAX_ERROR_COUNT)
-				app_start();
-		}
-	}
-
-
-	/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
-	else if(ch=='@') {
-		ch2 = getch();
-		if (ch2>0x85) getch();
-		nothing_response();
-	}
-
-
-	/* AVR ISP/STK500 board requests */
-	else if(ch=='A') {
-		ch2 = getch();
-		if(ch2==0x80) byte_response(HW_VER);		// Hardware version
-		else if(ch2==0x81) byte_response(SW_MAJOR);	// Software major version
-		else if(ch2==0x82) byte_response(SW_MINOR);	// Software minor version
-		else if(ch2==0x98) byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
-		else byte_response(0x00);				// Covers various unnecessary responses we don't care about
-	}
-
-
-	/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
-	else if(ch=='B') {
-		getNch(20);
-		nothing_response();
-	}
-
-
-	/* Parallel programming stuff  DON'T CARE  */
-	else if(ch=='E') {
-		getNch(5);
-		nothing_response();
-	}
-
-
-	/* P: Enter programming mode  */
-	/* R: Erase device, don't care as we will erase one page at a time anyway.  */
-	else if(ch=='P' || ch=='R') {
-		nothing_response();
-	}
-
-
-	/* Leave programming mode  */
-	else if(ch=='Q') {
-		nothing_response();
-#ifdef WATCHDOG_MODS
-		// autoreset via watchdog (sneaky!)
-		WDTCSR = _BV(WDE);
-		while (1); // 16 ms
-#endif
-	}
-
-
-	/* Set address, little endian. EEPROM in bytes, FLASH in words  */
-	/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
-	/* This might explain why little endian was used here, big endian used everywhere else.  */
-	else if(ch=='U') {
-		address.byte[0] = getch();
-		address.byte[1] = getch();
-		nothing_response();
-	}
-
-
-	/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
-	else if(ch=='V') {
-		if (getch() == 0x30) {
-			getch();
-			ch = getch();
-			getch();
-			if (ch == 0) {
-				byte_response(SIG1);
-			} else if (ch == 1) {
-				byte_response(SIG2); 
-			} else {
-				byte_response(SIG3);
-			} 
-		} else {
-			getNch(3);
-			byte_response(0x00);
-		}
-	}
-
-
-	/* Write memory, length is big endian and is in bytes  */
-	else if(ch=='d') {
-		length.byte[1] = getch();
-		length.byte[0] = getch();
-		flags.eeprom = 0;
-		if (getch() == 'E') flags.eeprom = 1;
-		for (w=0;w<length.word;w++) {
-			buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
-		}
-		if (getch() == ' ') {
-			if (flags.eeprom) {		                //Write to EEPROM one byte at a time
-				address.word <<= 1;
-				for(w=0;w<length.word;w++) {
-#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
-					while(EECR & (1<<EEPE));
-					EEAR = (uint16_t)(void *)address.word;
-					EEDR = buff[w];
-					EECR |= (1<<EEMPE);
-					EECR |= (1<<EEPE);
-#else
-					eeprom_write_byte((void *)address.word,buff[w]);
-#endif
-					address.word++;
-				}			
-			}
-			else {					        //Write to FLASH one page at a time
-				if (address.byte[1]>127) address_high = 0x01;	//Only possible with m128, m256 will need 3rd address byte. FIXME
-				else address_high = 0x00;
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) 
-				RAMPZ = address_high;
-#endif
-				address.word = address.word << 1;	        //address * 2 -> byte location
-				/* if ((length.byte[0] & 0x01) == 0x01) length.word++;	//Even up an odd number of bytes */
-				if ((length.byte[0] & 0x01)) length.word++;	//Even up an odd number of bytes
-				cli();					//Disable interrupts, just to be sure
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-				while(bit_is_set(EECR,EEPE));			//Wait for previous EEPROM writes to complete
-#else
-				while(bit_is_set(EECR,EEWE));			//Wait for previous EEPROM writes to complete
-#endif
-				asm volatile(
-					 "clr	r17		\n\t"	//page_word_count
-					 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
-					 "lds	r31,address+1	\n\t"
-					 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
-					 "ldi	r29,hi8(buff)	\n\t"
-					 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
-					 "lds	r25,length+1	\n\t"
-					 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
-					 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
-					 "brne	no_page_erase	\n\t"						 
-					 "wait_spm1:		\n\t"
-					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-					 "andi	r16,1           \n\t"
-					 "cpi	r16,1           \n\t"
-					 "breq	wait_spm1       \n\t"
-					 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
-					 "sts	%0,r16		\n\t"
-					 "spm			\n\t"							 
-#ifdef __AVR_ATmega163__
-					 ".word 0xFFFF		\n\t"
-					 "nop			\n\t"
-#endif
-					 "wait_spm2:		\n\t"
-					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-					 "andi	r16,1           \n\t"
-					 "cpi	r16,1           \n\t"
-					 "breq	wait_spm2       \n\t"									 
-
-					 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-					 "sts	%0,r16		\n\t"						 			 
-					 "spm			\n\t"
-#ifdef __AVR_ATmega163__
-					 ".word 0xFFFF		\n\t"
-					 "nop			\n\t"
-#endif
-					 "no_page_erase:		\n\t"							 
-					 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
-					 "ld	r1,Y+		\n\t"							 
-								 
-					 "wait_spm3:		\n\t"
-					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-					 "andi	r16,1           \n\t"
-					 "cpi	r16,1           \n\t"
-					 "breq	wait_spm3       \n\t"
-					 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
-					 "sts	%0,r16		\n\t"
-					 "spm			\n\t"
-								 
-					 "inc	r17		\n\t"	//page_word_count++
-					 "cpi r17,%1	        \n\t"
-					 "brlo	same_page	\n\t"	//Still same page in FLASH
-					 "write_page:		\n\t"
-					 "clr	r17		\n\t"	//New page, write current one first
-					 "wait_spm4:		\n\t"
-					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-					 "andi	r16,1           \n\t"
-					 "cpi	r16,1           \n\t"
-					 "breq	wait_spm4       \n\t"
-#ifdef __AVR_ATmega163__
-					 "andi	r30,0x80	\n\t"	// m163 requires Z6:Z1 to be zero during page write
-#endif							 							 
-					 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
-					 "sts	%0,r16		\n\t"
-					 "spm			\n\t"
-#ifdef __AVR_ATmega163__
-					 ".word 0xFFFF		\n\t"
-					 "nop			\n\t"
-					 "ori	r30,0x7E	\n\t"	// recover Z6:Z1 state after page write (had to be zero during write)
-#endif
-					 "wait_spm5:		\n\t"
-					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-					 "andi	r16,1           \n\t"
-					 "cpi	r16,1           \n\t"
-					 "breq	wait_spm5       \n\t"									 
-					 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-					 "sts	%0,r16		\n\t"						 			 
-					 "spm			\n\t"					 		 
-#ifdef __AVR_ATmega163__
-					 ".word 0xFFFF		\n\t"
-					 "nop			\n\t"
-#endif
-					 "same_page:		\n\t"							 
-					 "adiw	r30,2		\n\t"	//Next word in FLASH
-					 "sbiw	r24,2		\n\t"	//length-2
-					 "breq	final_write	\n\t"	//Finished
-					 "rjmp	length_loop	\n\t"
-					 "final_write:		\n\t"
-					 "cpi	r17,0		\n\t"
-					 "breq	block_done	\n\t"
-					 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
-					 "rjmp	write_page	\n\t"
-					 "block_done:		\n\t"
-					 "clr	__zero_reg__	\n\t"	//restore zero register
-#if defined __AVR_ATmega168__  || __AVR_ATmega328P__ || __AVR_ATmega128__ || __AVR_ATmega1280__ || __AVR_ATmega1281__ || __AVR_ATmega1284P__ || __AVR_ATmega644P__
-					 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
-#else
-					 : "=m" (SPMCR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
-#endif
-					 );
-				/* Should really add a wait for RWW section to be enabled, don't actually need it since we never */
-				/* exit the bootloader without a power cycle anyhow */
-			}
-			putch(0x14);
-			putch(0x10);
-		} else {
-			if (++error_count == MAX_ERROR_COUNT)
-				app_start();
-		}		
-	}
-
-
-	/* Read memory block mode, length is big endian.  */
-	else if(ch=='t') {
-		length.byte[1] = getch();
-		length.byte[0] = getch();
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-		if (address.word>0x7FFF) flags.rampz = 1;		// No go with m256, FIXME
-		else flags.rampz = 0;
-#endif
-		address.word = address.word << 1;	        // address * 2 -> byte location
-		if (getch() == 'E') flags.eeprom = 1;
-		else flags.eeprom = 0;
-		if (getch() == ' ') {		                // Command terminator
-			putch(0x14);
-			for (w=0;w < length.word;w++) {		        // Can handle odd and even lengths okay
-				if (flags.eeprom) {	                        // Byte access EEPROM read
-#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
-					while(EECR & (1<<EEPE));
-					EEAR = (uint16_t)(void *)address.word;
-					EECR |= (1<<EERE);
-					putch(EEDR);
-#else
-					putch(eeprom_read_byte((void *)address.word));
-#endif
-					address.word++;
-				}
-				else {
-
-					if (!flags.rampz) putch(pgm_read_byte_near(address.word));
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) 
-					else putch(pgm_read_byte_far(address.word + 0x10000));
-					// Hmmmm, yuck  FIXME when m256 arrvies
-#endif
-					address.word++;
-				}
-			}
-			putch(0x10);
-		}
-	}
-
-
-	/* Get device signature bytes  */
-	else if(ch=='u') {
-		if (getch() == ' ') {
-			putch(0x14);
-			putch(SIG1);
-			putch(SIG2);
-			putch(SIG3);
-			putch(0x10);
-		} else {
-			if (++error_count == MAX_ERROR_COUNT)
-				app_start();
-		}
-	}
-
-
-	/* Read oscillator calibration byte */
-	else if(ch=='v') {
-		byte_response(0x00);
-	}
-
-
-#if defined MONITOR 
-
-	/* here come the extended monitor commands by Erik Lins */
-
-	/* check for three times exclamation mark pressed */
-	else if(ch=='!') {
-		ch = getch();
-		if(ch=='!') {
-		ch = getch();
-		if(ch=='!') {
-			PGM_P welcome = "";
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
-			uint16_t extaddr;
-#endif
-			uint8_t addrl, addrh;
-
-#ifdef CRUMB128
-			welcome = "ATmegaBOOT / Crumb128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
-#elif defined PROBOMEGA128
-			welcome = "ATmegaBOOT / PROBOmega128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
-#elif defined SAVVY128
-			welcome = "ATmegaBOOT / Savvy128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
-#elif defined __AVR_ATmega1280__ 
-			welcome = "ATmegaBOOT / Arduino Mega - (C) Arduino LLC - 090930\n\r";
-#endif
-
-			/* turn on LED */
-			LED_DDR |= _BV(LED);
-			LED_PORT &= ~_BV(LED);
-
-			/* print a welcome message and command overview */
-			for(i=0; welcome[i] != '\0'; ++i) {
-				putch(welcome[i]);
-			}
-
-			/* test for valid commands */
-			for(;;) {
-				putch('\n');
-				putch('\r');
-				putch(':');
-				putch(' ');
-
-				ch = getch();
-				putch(ch);
-
-				/* toggle LED */
-				if(ch == 't') {
-					if(bit_is_set(LED_PIN,LED)) {
-						LED_PORT &= ~_BV(LED);
-						putch('1');
-					} else {
-						LED_PORT |= _BV(LED);
-						putch('0');
-					}
-				} 
-
-				/* read byte from address */
-				else if(ch == 'r') {
-					ch = getch(); putch(ch);
-					addrh = gethex();
-					addrl = gethex();
-					putch('=');
-					ch = *(uint8_t *)((addrh << 8) + addrl);
-					puthex(ch);
-				}
-
-				/* write a byte to address  */
-				else if(ch == 'w') {
-					ch = getch(); putch(ch);
-					addrh = gethex();
-					addrl = gethex();
-					ch = getch(); putch(ch);
-					ch = gethex();
-					*(uint8_t *)((addrh << 8) + addrl) = ch;
-				}
-
-				/* read from uart and echo back */
-				else if(ch == 'u') {
-					for(;;) {
-						putch(getch());
-					}
-				}
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
-				/* external bus loop  */
-				else if(ch == 'b') {
-					putch('b');
-					putch('u');
-					putch('s');
-					MCUCR = 0x80;
-					XMCRA = 0;
-					XMCRB = 0;
-					extaddr = 0x1100;
-					for(;;) {
-						ch = *(volatile uint8_t *)extaddr;
-						if(++extaddr == 0) {
-							extaddr = 0x1100;
-						}
-					}
-				}
-#endif
-
-				else if(ch == 'j') {
-					app_start();
-				}
-
-			} /* end of monitor functions */
-
-		}
-		}
-	}
-	/* end of monitor */
-#endif
-	else if (++error_count == MAX_ERROR_COUNT) {
-		app_start();
-	}
-	} /* end of forever loop */
-
-}
-
-
-char gethexnib(void) {
-	char a;
-	a = getch(); putch(a);
-	if(a >= 'a') {
-		return (a - 'a' + 0x0a);
-	} else if(a >= '0') {
-		return(a - '0');
-	}
-	return a;
-}
-
-
-char gethex(void) {
-	return (gethexnib() << 4) + gethexnib();
-}
-
-
-void puthex(char ch) {
-	char ah;
-
-	ah = ch >> 4;
-	if(ah >= 0x0a) {
-		ah = ah - 0x0a + 'a';
-	} else {
-		ah += '0';
-	}
-	
-	ch &= 0x0f;
-	if(ch >= 0x0a) {
-		ch = ch - 0x0a + 'a';
-	} else {
-		ch += '0';
-	}
-	
-	putch(ah);
-	putch(ch);
-}
-
-
-void putch(char ch)
-{
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	if(bootuart == 1) {
-		while (!(UCSR0A & _BV(UDRE0)));
-		UDR0 = ch;
-	}
-	else if (bootuart == 2) {
-		while (!(UCSR1A & _BV(UDRE1)));
-		UDR1 = ch;
-	}
-#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
-	while (!(UCSR0A & _BV(UDRE0)));
-	UDR0 = ch;
-#else
-	/* m8,16,32,169,8515,8535,163 */
-	while (!(UCSRA & _BV(UDRE)));
-	UDR = ch;
-#endif
-}
-
-
-char getch(void)
-{
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	uint32_t count = 0;
-	if(bootuart == 1) {
-		while(!(UCSR0A & _BV(RXC0))) {
-			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-			/* HACKME:: here is a good place to count times*/
-			count++;
-			if (count > MAX_TIME_COUNT)
-				app_start();
-			}
-
-			return UDR0;
-		}
-	else if(bootuart == 2) {
-		while(!(UCSR1A & _BV(RXC1))) {
-			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-			/* HACKME:: here is a good place to count times*/
-			count++;
-			if (count > MAX_TIME_COUNT)
-				app_start();
-		}
-
-		return UDR1;
-	}
-	return 0;
-#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
-	uint32_t count = 0;
-	while(!(UCSR0A & _BV(RXC0))){
-		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-		/* HACKME:: here is a good place to count times*/
-		count++;
-		if (count > MAX_TIME_COUNT)
-			app_start();
-	}
-	return UDR0;
-#else
-	/* m8,16,32,169,8515,8535,163 */
-	uint32_t count = 0;
-	while(!(UCSRA & _BV(RXC))){
-		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-		/* HACKME:: here is a good place to count times*/
-		count++;
-		if (count > MAX_TIME_COUNT)
-			app_start();
-	}
-	return UDR;
-#endif
-}
-
-
-void getNch(uint8_t count)
-{
-	while(count--) {
-#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-		if(bootuart == 1) {
-			while(!(UCSR0A & _BV(RXC0)));
-			UDR0;
-		} 
-		else if(bootuart == 2) {
-			while(!(UCSR1A & _BV(RXC1)));
-			UDR1;
-		}
-#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
-		getch();
-#else
-		/* m8,16,32,169,8515,8535,163 */
-		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-		//while(!(UCSRA & _BV(RXC)));
-		//UDR;
-		getch(); // need to handle time out
-#endif		
-	}
-}
-
-
-void byte_response(uint8_t val)
-{
-	if (getch() == ' ') {
-		putch(0x14);
-		putch(val);
-		putch(0x10);
-	} else {
-		if (++error_count == MAX_ERROR_COUNT)
-			app_start();
-	}
-}
-
-
-void nothing_response(void)
-{
-	if (getch() == ' ') {
-		putch(0x14);
-		putch(0x10);
-	} else {
-		if (++error_count == MAX_ERROR_COUNT)
-			app_start();
-	}
-}
-
-void flash_led(uint8_t count)
-{
-	while (count--) {
-		LED_PORT |= _BV(LED);
-		_delay_ms(100);
-		LED_PORT &= ~_BV(LED);
-		_delay_ms(100);
-	}
-}
-
-
-/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex
deleted file mode 100644
index a63dc8d..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex
+++ /dev/null
@@ -1,130 +0,0 @@
-:020000021000EC
-:10F000000C9446F80C9465F80C9465F80C9465F82B
-:10F010000C9465F80C9465F80C9465F80C9465F8FC
-:10F020000C9465F80C9465F80C9465F80C9465F8EC
-:10F030000C9465F80C9465F80C9465F80C9465F8DC
-:10F040000C9465F80C9465F80C9465F80C9465F8CC
-:10F050000C9465F80C9465F80C9465F80C9465F8BC
-:10F060000C9465F80C9465F80C9465F80C9465F8AC
-:10F070000C9465F80C9465F80C9465F80C9465F89C
-:10F080000C9465F80C9465F80C9465F811241FBE77
-:10F09000CFEFD0E4DEBFCDBF11E0A0E0B1E0E8EDFE
-:10F0A000F7EF01E00BBF02C007900D92A230B1074D
-:10F0B000D9F712E0A2E0B1E001C01D92AD30B10776
-:10F0C000E1F70E947EF90C94EAFB0C9400F8909111
-:10F0D0000201913019F0923041F008959091C000F2
-:10F0E00095FFFCCF8093C60008959091C80095FFCE
-:10F0F000FCCF8093CE0008951F93982F95959595FA
-:10F1000095959595905D182F1F701A304CF4105DF1
-:10F11000892F0E9467F8812F0E9467F81F91089538
-:10F12000195A892F0E9467F8812F0E9467F81F9152
-:10F130000895EF92FF920F931F9380910201813007
-:10F1400069F1823031F080E01F910F91FF90EF90D4
-:10F150000895EE24FF2487018091C80087FD17C021
-:10F160000894E11CF11C011D111D81E4E81682E4E4
-:10F17000F8068FE0080780E0180770F3E0910401BB
-:10F18000F091050109958091C80087FFE9CF809132
-:10F19000CE001F910F91FF90EF900895EE24FF2471
-:10F1A00087018091C00087FD17C00894E11CF11C05
-:10F1B000011D111D81E4E81682E4F8068FE00807BE
-:10F1C00080E0180770F3E0910401F09105010995C2
-:10F1D0008091C00087FFE9CF8091C6001F910F91F9
-:10F1E000FF90EF9008951F930E9499F8182F0E94A6
-:10F1F00067F8113634F410330CF01053812F1F913F
-:10F2000008951755812F1F9108951F930E94F3F8B9
-:10F21000182F0E94F3F81295107F810F1F91089507
-:10F2200020910201882339F0213031F0223061F041
-:10F2300081508823C9F708959091C00097FFFCCFB3
-:10F240009091C6008150F5CF9091C80097FFFCCFF8
-:10F250009091CE008150EDCF1F93182F0E9499F806
-:10F26000803281F0809103018F5F809303018530AC
-:10F2700011F01F910895E0910401F09105010995A5
-:10F280001F91089584E10E9467F8812F0E9467F81A
-:10F2900080E10E9467F8EDCF0E9499F8803271F00A
-:10F2A000809103018F5F80930301853009F00895F9
-:10F2B000E0910401F09105010995089584E10E940F
-:10F2C00067F880E10E9467F8089515C0289A2FEF2B
-:10F2D00031EE44E0215030404040E1F700C00000F2
-:10F2E00028982FEF31EE44E0215030404040E1F7C4
-:10F2F00000C000008150882349F70895EF92FF92E3
-:10F300000F931F93CF93DF93000081E0809302015E
-:10F3100080E18093C4001092C5001092C00086E086
-:10F320008093C20088E18093C100209A81E00E940E
-:10F3300065F90E9499F88033B1F18133B9F18034D5
-:10F3400009F454C0813409F45AC0823409F469C004
-:10F35000853409F46CC0803531F1823521F1813575
-:10F3600011F1853509F469C0863509F471C0843618
-:10F3700009F47AC0843709F4E1C0853709F43FC144
-:10F38000863709F44AC0809103018F5F809303019F
-:10F39000853079F6E0910401F091050109950E940C
-:10F3A00099F8803351F60E944CF9C3CF0E9499F826
-:10F3B000803249F784E10E9467F881E40E9467F88F
-:10F3C00086E50E9467F882E50E9467F880E20E9465
-:10F3D00067F889E40E9467F883E50E9467F880E592
-:10F3E0000E9467F880E10E9467F8A3CF0E9499F815
-:10F3F0008638C8F20E9499F80E944CF99ACF0E9470
-:10F4000099F8803809F414C1813809F415C182389B
-:10F4100009F416C1883909F407C180E00E942CF96B
-:10F4200088CF84E10E9410F90E944CF982CF85E0D8
-:10F430000E9410F90E944CF97CCF0E9499F88093A9
-:10F4400006010E9499F8809307010E944CF971CF40
-:10F450000E9499F8803309F405C183E00E9410F9F5
-:10F4600080E00E942CF965CF0E9499F880930902F0
-:10F470000E9499F88093080280910C028E7F8093FD
-:10F480000C020E9499F8853409F4FDC080910802AD
-:10F49000909109020097A1F068E0E62E61E0F62E57
-:10F4A00000E010E00E9499F8F70181937F010F5F5F
-:10F4B0001F4F80910802909109020817190790F3D5
-:10F4C0000E9499F8803209F05ECF80910C0280FF93
-:10F4D000ECC08091060190910701880F991F9093CD
-:10F4E000070180930601209108023091090221153D
-:10F4F0003105E9F048E0E42E41E0F42E00E010E0B0
-:10F50000F70161917F010E94DCFB809106019091DF
-:10F510000701019690930701809306010F5F1F4F2B
-:10F5200020910802309109020217130748F384E181
-:10F530000E9467F880E10E9467F8FBCE0E9499F86C
-:10F54000809309020E9499F8809308028091060135
-:10F550009091070197FDA3C020910C022D7F20936D
-:10F560000C02880F991F90930701809306010E9457
-:10F5700099F8853409F48DC080910C028E7F8093B8
-:10F580000C020E9499F8803209F0D3CE84E10E94E7
-:10F5900067F88091080290910902009709F440C031
-:10F5A00000E010E0809106019091070116C0FC0177
-:10F5B00084910E9467F8809106019091070101965D
-:10F5C00090930701809306010F5F1F4F209108025F
-:10F5D000309109020217130718F520910C0220FD43
-:10F5E00033C021FFE4CFA0E0B0E080509040AF4FA7
-:10F5F000BF4FABBFFC0187910E9467F8DCCF0E9430
-:10F6000099F8803209F0BFCE84E10E9467F88EE15C
-:10F610000E9467F887E90E9467F885E00E9467F812
-:10F6200080E10E9467F885CE83E00E942CF981CEAC
-:10F6300082E00E942CF97DCE81E00E942CF979CEE7
-:10F6400080E10E942CF975CE0E94D4FB0E9467F8DD
-:10F650008091060190910701019690930701809394
-:10F660000601B2CF0E9499F80E9499F8082F0E94D3
-:10F6700099F8002309F48BC0013009F48CC085E0AF
-:10F680000E942CF956CE80910C02816080930C026E
-:10F69000FDCE80910C02816080930C0272CF20918C
-:10F6A0000C02226020930C025CCF8091070187FD41
-:10F6B00076C010920B0280E08BBF80910601909182
-:10F6C0000701880F991F909307018093060180918D
-:10F6D000080280FF09C080910802909109020196FA
-:10F6E0009093090280930802F894F999FECF1127AC
-:10F6F000E0910601F0910701C8E0D1E08091080295
-:10F7000090910902103091F400915700017001307E
-:10F71000D9F303E000935700E8950091570001707A
-:10F720000130D9F301E100935700E8950990199051
-:10F730000091570001700130D9F301E000935700A8
-:10F74000E8951395103898F0112700915700017033
-:10F750000130D9F305E000935700E8950091570078
-:10F7600001700130D9F301E100935700E89532961A
-:10F77000029709F0C7CF103011F00296E5CF11249F
-:10F7800084E10E9467F880E10E9467F8D2CD8EE1A3
-:10F790000E942CF9CECD87E90E942CF9CACDF1E068
-:10F7A000F0930B0281E088CFF999FECF92BD81BD25
-:10F7B000F89A992780B50895262FF999FECF1FBA98
-:10F7C00092BD81BD20BD0FB6F894FA9AF99A0FBE8A
-:08F7D00001960895F894FFCFA3
-:02F7D8008000AF
-:040000031000F000F9
-:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex
deleted file mode 100644
index 7f5f3f3..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex
+++ /dev/null
@@ -1,130 +0,0 @@
-:020000021000EC
-:10F000000C9446F80C9465F80C9465F80C9465F82B
-:10F010000C9465F80C9465F80C9465F80C9465F8FC
-:10F020000C9465F80C9465F80C9465F80C9465F8EC
-:10F030000C9465F80C9465F80C9465F80C9465F8DC
-:10F040000C9465F80C9465F80C9465F80C9465F8CC
-:10F050000C9465F80C9465F80C9465F80C9465F8BC
-:10F060000C9465F80C9465F80C9465F80C9465F8AC
-:10F070000C9465F80C9465F80C9465F80C9465F89C
-:10F080000C9465F80C9465F80C9465F811241FBE77
-:10F09000CFEFD0E4DEBFCDBF11E0A0E0B1E0E8EDFE
-:10F0A000F7EF01E00BBF02C007900D92A230B1074D
-:10F0B000D9F712E0A2E0B1E001C01D92AD30B10776
-:10F0C000E1F70E947EF90C94EAFB0C9400F8909111
-:10F0D0000201913019F0923041F008959091C000F2
-:10F0E00095FFFCCF8093C60008959091C80095FFCE
-:10F0F000FCCF8093CE0008951F93982F95959595FA
-:10F1000095959595905D182F1F701A304CF4105DF1
-:10F11000892F0E9467F8812F0E9467F81F91089538
-:10F12000195A892F0E9467F8812F0E9467F81F9152
-:10F130000895EF92FF920F931F9380910201813007
-:10F1400069F1823031F080E01F910F91FF90EF90D4
-:10F150000895EE24FF2487018091C80087FD17C021
-:10F160000894E11CF11C011D111D81E2E81681EAE1
-:10F17000F80687E0080780E0180770F3E0910401C3
-:10F18000F091050109958091C80087FFE9CF809132
-:10F19000CE001F910F91FF90EF900895EE24FF2471
-:10F1A00087018091C00087FD17C00894E11CF11C05
-:10F1B000011D111D81E2E81681EAF80687E00807C3
-:10F1C00080E0180770F3E0910401F09105010995C2
-:10F1D0008091C00087FFE9CF8091C6001F910F91F9
-:10F1E000FF90EF9008951F930E9499F8182F0E94A6
-:10F1F00067F8113634F410330CF01053812F1F913F
-:10F2000008951755812F1F9108951F930E94F3F8B9
-:10F21000182F0E94F3F81295107F810F1F91089507
-:10F2200020910201882339F0213031F0223061F041
-:10F2300081508823C9F708959091C00097FFFCCFB3
-:10F240009091C6008150F5CF9091C80097FFFCCFF8
-:10F250009091CE008150EDCF1F93182F0E9499F806
-:10F26000803281F0809103018F5F809303018530AC
-:10F2700011F01F910895E0910401F09105010995A5
-:10F280001F91089584E10E9467F8812F0E9467F81A
-:10F2900080E10E9467F8EDCF0E9499F8803271F00A
-:10F2A000809103018F5F80930301853009F00895F9
-:10F2B000E0910401F09105010995089584E10E940F
-:10F2C00067F880E10E9467F8089515C0289A2FEF2B
-:10F2D00030E742E0215030404040E1F700C00000FC
-:10F2E00028982FEF30E742E0215030404040E1F7CE
-:10F2F00000C000008150882349F70895EF92FF92E3
-:10F300000F931F93CF93DF93000081E0809302015E
-:10F3100089E18093C4001092C5001092C00086E07D
-:10F320008093C20088E18093C100209A81E00E940E
-:10F3300065F90E9499F88033B1F18133B9F18034D5
-:10F3400009F454C0813409F45AC0823409F469C004
-:10F35000853409F46CC0803531F1823521F1813575
-:10F3600011F1853509F469C0863509F471C0843618
-:10F3700009F47AC0843709F4E1C0853709F43FC144
-:10F38000863709F44AC0809103018F5F809303019F
-:10F39000853079F6E0910401F091050109950E940C
-:10F3A00099F8803351F60E944CF9C3CF0E9499F826
-:10F3B000803249F784E10E9467F881E40E9467F88F
-:10F3C00086E50E9467F882E50E9467F880E20E9465
-:10F3D00067F889E40E9467F883E50E9467F880E592
-:10F3E0000E9467F880E10E9467F8A3CF0E9499F815
-:10F3F0008638C8F20E9499F80E944CF99ACF0E9470
-:10F4000099F8803809F414C1813809F415C182389B
-:10F4100009F416C1883909F407C180E00E942CF96B
-:10F4200088CF84E10E9410F90E944CF982CF85E0D8
-:10F430000E9410F90E944CF97CCF0E9499F88093A9
-:10F4400006010E9499F8809307010E944CF971CF40
-:10F450000E9499F8803309F405C183E00E9410F9F5
-:10F4600080E00E942CF965CF0E9499F880930902F0
-:10F470000E9499F88093080280910C028E7F8093FD
-:10F480000C020E9499F8853409F4FDC080910802AD
-:10F49000909109020097A1F068E0E62E61E0F62E57
-:10F4A00000E010E00E9499F8F70181937F010F5F5F
-:10F4B0001F4F80910802909109020817190790F3D5
-:10F4C0000E9499F8803209F05ECF80910C0280FF93
-:10F4D000ECC08091060190910701880F991F9093CD
-:10F4E000070180930601209108023091090221153D
-:10F4F0003105E9F048E0E42E41E0F42E00E010E0B0
-:10F50000F70161917F010E94DCFB809106019091DF
-:10F510000701019690930701809306010F5F1F4F2B
-:10F5200020910802309109020217130748F384E181
-:10F530000E9467F880E10E9467F8FBCE0E9499F86C
-:10F54000809309020E9499F8809308028091060135
-:10F550009091070197FDA3C020910C022D7F20936D
-:10F560000C02880F991F90930701809306010E9457
-:10F5700099F8853409F48DC080910C028E7F8093B8
-:10F580000C020E9499F8803209F0D3CE84E10E94E7
-:10F5900067F88091080290910902009709F440C031
-:10F5A00000E010E0809106019091070116C0FC0177
-:10F5B00084910E9467F8809106019091070101965D
-:10F5C00090930701809306010F5F1F4F209108025F
-:10F5D000309109020217130718F520910C0220FD43
-:10F5E00033C021FFE4CFA0E0B0E080509040AF4FA7
-:10F5F000BF4FABBFFC0187910E9467F8DCCF0E9430
-:10F6000099F8803209F0BFCE84E10E9467F88EE15C
-:10F610000E9467F887E90E9467F885E00E9467F812
-:10F6200080E10E9467F885CE83E00E942CF981CEAC
-:10F6300082E00E942CF97DCE81E00E942CF979CEE7
-:10F6400080E10E942CF975CE0E94D4FB0E9467F8DD
-:10F650008091060190910701019690930701809394
-:10F660000601B2CF0E9499F80E9499F8082F0E94D3
-:10F6700099F8002309F48BC0013009F48CC085E0AF
-:10F680000E942CF956CE80910C02816080930C026E
-:10F69000FDCE80910C02816080930C0272CF20918C
-:10F6A0000C02226020930C025CCF8091070187FD41
-:10F6B00076C010920B0280E08BBF80910601909182
-:10F6C0000701880F991F909307018093060180918D
-:10F6D000080280FF09C080910802909109020196FA
-:10F6E0009093090280930802F894F999FECF1127AC
-:10F6F000E0910601F0910701C8E0D1E08091080295
-:10F7000090910902103091F400915700017001307E
-:10F71000D9F303E000935700E8950091570001707A
-:10F720000130D9F301E100935700E8950990199051
-:10F730000091570001700130D9F301E000935700A8
-:10F74000E8951395103898F0112700915700017033
-:10F750000130D9F305E000935700E8950091570078
-:10F7600001700130D9F301E100935700E89532961A
-:10F77000029709F0C7CF103011F00296E5CF11249F
-:10F7800084E10E9467F880E10E9467F8D2CD8EE1A3
-:10F790000E942CF9CECD87E90E942CF9CACDF1E068
-:10F7A000F0930B0281E088CFF999FECF92BD81BD25
-:10F7B000F89A992780B50895262FF999FECF1FBA98
-:10F7C00092BD81BD20BD0FB6F894FA9AF99A0FBE8A
-:08F7D00001960895F894FFCFA3
-:02F7D8008000AF
-:040000031000F000F9
-:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex
deleted file mode 100644
index 2edf9c6..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex
+++ /dev/null
@@ -1,126 +0,0 @@
-:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
-:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
-:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
-:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
-:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
-:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
-:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
-:10F870000C945B7C0C945B7C0C945B7C11241FBE11
-:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0EAEA0A
-:10F89000FFEF02C005900D92A230B107D9F712E038
-:10F8A000A2E0B1E001C01D92AD30B107E1F70E94C6
-:10F8B000747D0C94D37F0C94007C90910201913064
-:10F8C00019F0923041F008959091C00095FFFCCF5F
-:10F8D0008093C60008959091C80095FFFCCF809357
-:10F8E000CE0008951F93982F95959595959595958C
-:10F8F000905D182F1F701A304CF4105D892F0E94F4
-:10F900005D7C812F0E945D7C1F910895195A892F7B
-:10F910000E945D7C812F0E945D7C1F910895EF9273
-:10F92000FF920F931F9380910201813069F1823021
-:10F9300031F080E01F910F91FF90EF900895EE2439
-:10F94000FF2487018091C80087FD17C00894E11C3F
-:10F95000F11C011D111D81E4E81682E4F8068FE018
-:10F96000080780E0180770F3E0910401F0910501A9
-:10F9700009958091C80087FFE9CF8091CE001F9143
-:10F980000F91FF90EF900895EE24FF24870180915E
-:10F99000C00087FD17C00894E11CF11C011D111D5A
-:10F9A00081E4E81682E4F8068FE0080780E0180793
-:10F9B00070F3E0910401F091050109958091C00078
-:10F9C00087FFE9CF8091C6001F910F91FF90EF90C4
-:10F9D00008951F930E948F7C182F0E945D7C113622
-:10F9E00034F410330CF01053812F1F9108951755E4
-:10F9F000812F1F9108951F930E94E97C182F0E9468
-:10FA0000E97C1295107F810F1F91089520910201CA
-:10FA1000882339F0213031F0223061F08150882381
-:10FA2000C9F708959091C00097FFFCCF9091C60050
-:10FA30008150F5CF9091C80097FFFCCF9091CE00F8
-:10FA40008150EDCF1F93182F0E948F7C803281F060
-:10FA5000809103018F5F80930301853011F01F9126
-:10FA60000895E0910401F091050109951F91089511
-:10FA700084E10E945D7C812F0E945D7C80E10E9478
-:10FA80005D7CEDCF0E948F7C803271F0809103010C
-:10FA90008F5F80930301853009F00895E0910401A0
-:10FAA000F09105010995089584E10E945D7C80E153
-:10FAB0000E945D7C089515C0289A2FEF31EE44E036
-:10FAC000215030404040E1F700C0000028982FEF5F
-:10FAD00031EE44E0215030404040E1F700C00000EA
-:10FAE0008150882349F70895EF92FF920F931F9357
-:10FAF000CF93DF93000081E08093020180E1809347
-:10FB0000C4001092C5001092C00086E08093C2002D
-:10FB100088E18093C100209A81E00E945B7D0E9471
-:10FB20008F7C8033B1F18133B9F1803409F454C052
-:10FB3000813409F45AC0823409F469C0853409F467
-:10FB40006CC0803531F1823521F1813511F1853577
-:10FB500009F469C0863509F471C0843609F47AC0A5
-:10FB6000843709F4E1C0853709F439C1863709F4CF
-:10FB70004AC0809103018F5F80930301853079F63D
-:10FB8000E0910401F091050109950E948F7C80337A
-:10FB900051F60E94427DC3CF0E948F7C803249F78C
-:10FBA00084E10E945D7C81E40E945D7C86E50E9488
-:10FBB0005D7C82E50E945D7C80E20E945D7C89E440
-:10FBC0000E945D7C83E50E945D7C80E50E945D7CF7
-:10FBD00080E10E945D7CA3CF0E948F7C8638C8F2B2
-:10FBE0000E948F7C0E94427D9ACF0E948F7C803839
-:10FBF00009F40EC1813809F40FC1823809F410C12B
-:10FC0000883909F401C180E00E94227D88CF84E117
-:10FC10000E94067D0E94427D82CF85E00E94067D83
-:10FC20000E94427D7CCF0E948F7C809306010E94BF
-:10FC30008F7C809307010E94427D71CF0E948F7C50
-:10FC4000803309F4F1C083E00E94067D80E00E94C9
-:10FC5000227D65CF0E948F7C809309020E948F7C59
-:10FC60008093080280910C028E7F80930C020E9488
-:10FC70008F7C853409F4E9C08091080290910902D3
-:10FC80000097A1F068E0E62E61E0F62E00E010E0BB
-:10FC90000E948F7CF70181937F010F5F1F4F80913E
-:10FCA0000802909109020817190790F30E948F7CAF
-:10FCB000803209F05ECF80910C0280FFE5C0809118
-:10FCC000060190910701880F991F90930701809377
-:10FCD0000601209108023091090221153105E9F051
-:10FCE00048E0E42E41E0F42E00E010E0F7016191DD
-:10FCF0007F010E94C57F80910601909107010196C6
-:10FD000090930701809306010F5F1F4F2091080217
-:10FD1000309109020217130748F384E10E945D7CC9
-:10FD200080E10E945D7CFBCE0E948F7C8093090263
-:10FD30000E948F7C809308028091060190910701B8
-:10FD400097FD9CC020910C022D7F20930C02880F00
-:10FD5000991F90930701809306010E948F7C853440
-:10FD600009F486C080910C028E7F80930C020E9461
-:10FD70008F7C803209F0D3CE84E10E945D7C20919B
-:10FD800008023091090221153105D1F100E010E09F
-:10FD900080910601909107010CC041FF5CC0019663
-:10FDA00090930701809306010F5F1F4F02171307FF
-:10FDB00038F540910C0240FFF0CF0E94BD7F0E94B9
-:10FDC0005D7C809106019091070101969093070157
-:10FDD000809306012091080230910902E5CF0E942C
-:10FDE0008F7C803209F0C5CE84E10E945D7C8EE17B
-:10FDF0000E945D7C86E90E945D7C8AE00E945D7CB9
-:10FE000080E10E945D7C8BCE83E00E94227D87CEC4
-:10FE100082E00E94227D83CE81E00E94227D7FCEFF
-:10FE200080E10E94227D7BCE0E948F7C0E948F7C8D
-:10FE3000082F0E948F7C002309F497C0013009F439
-:10FE400098C08AE00E94227D6ACE80910C02816077
-:10FE500080930C0211CFFC0184910E945D7C209163
-:10FE6000080230910902809106019091070197CF15
-:10FE700080910C02816080930C0279CF20910C025A
-:10FE8000226020930C0263CF80910701880F880BBA
-:10FE9000817080930B028091060190910701880F79
-:10FEA000991F90930701809306018091080280FFBB
-:10FEB00009C080910802909109020196909309026D
-:10FEC00080930802F894F999FECF1127E09106017A
-:10FED000F0910701C8E0D1E08091080290910902F9
-:10FEE000103091F40091570001700130D9F303E014
-:10FEF00000935700E8950091570001700130D9F345
-:10FF000001E100935700E89509901990009157007E
-:10FF100001700130D9F301E000935700E895139583
-:10FF2000103898F011270091570001700130D9F373
-:10FF300005E000935700E8950091570001700130EB
-:10FF4000D9F301E100935700E8953296029709F042
-:10FF5000C7CF103011F00296E5CF112484E10E9442
-:10FF60005D7C80E10E945D7CDACD8EE10E94227D85
-:10FF7000D6CD86E90E94227DD2CDF999FECF92BDE1
-:10FF800081BDF89A992780B50895262FF999FECF5B
-:10FF90001FBA92BD81BD20BD0FB6F894FA9AF99AA6
-:0AFFA0000FBE01960895F894FFCFFC
-:02FFAA008000D5
-:040000030000F80001
-:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/Makefile b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/Makefile
deleted file mode 100644
index 3f2bb61..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega/Makefile
+++ /dev/null
@@ -1,254 +0,0 @@
-# Makefile for ATmegaBOOT
-# E.Lins, 18.7.2005
-# $Id$
-#
-# Instructions
-#
-# To make bootloader .hex file:
-# make diecimila
-# make lilypad
-# make ng
-# etc...
-#
-# To burn bootloader .hex file:
-# make diecimila_isp
-# make lilypad_isp
-# make ng_isp
-# etc...
-
-# program name should not be changed...
-PROGRAM    = ATmegaBOOT_168
-
-# enter the parameters for the avrdude isp tool
-ISPTOOL	   = stk500v2
-ISPPORT	   = usb
-ISPSPEED   = -b 115200
-
-MCU_TARGET = atmega168
-LDSECTION  = --section-start=.text=0x3800
-
-# the efuse should really be 0xf8; since, however, only the lower
-# three bits of that byte are used on the atmega168, avrdude gets
-# confused if you specify 1's for the higher bits, see:
-# http://tinker.it/now/2007/02/24/the-tale-of-avrdude-atmega168-and-extended-bits-fuses/
-#
-# similarly, the lock bits should be 0xff instead of 0x3f (to
-# unlock the bootloader section) and 0xcf instead of 0x0f (to
-# lock it), but since the high two bits of the lock byte are
-# unused, avrdude would get confused.
-
-ISPFUSES    = avrdude -c $(ISPTOOL) -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
--e -u -U lock:w:0x3f:m -U efuse:w:0x$(EFUSE):m -U hfuse:w:0x$(HFUSE):m -U lfuse:w:0x$(LFUSE):m
-ISPFLASH    = avrdude -c $(ISPTOOL) -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
--U flash:w:$(PROGRAM)_$(TARGET).hex -U lock:w:0x0f:m
-
-STK500 = "C:\Program Files\Atmel\AVR Tools\STK500\Stk500.exe"
-STK500-1 = $(STK500) -e -d$(MCU_TARGET) -pf -vf -if$(PROGRAM)_$(TARGET).hex \
--lFF -LFF -f$(HFUSE)$(LFUSE) -EF8 -ms -q -cUSB -I200kHz -s -wt
-STK500-2 = $(STK500) -d$(MCU_TARGET) -ms -q -lCF -LCF -cUSB -I200kHz -s -wt
-
-
-OBJ        = $(PROGRAM).o
-OPTIMIZE   = -O2
-
-DEFS       = 
-LIBS       =
-
-CC         = avr-gcc
-
-# Override is only needed by avr-lib build system.
-
-override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
-override LDFLAGS       = -Wl,$(LDSECTION)
-#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
-
-OBJCOPY        = avr-objcopy
-OBJDUMP        = avr-objdump
-
-all:
-
-lilypad: TARGET = lilypad
-lilypad: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>1' '-DNUM_LED_FLASHES=3'
-lilypad: AVR_FREQ = 8000000L
-lilypad: $(PROGRAM)_lilypad.hex
-
-lilypad_isp: lilypad
-lilypad_isp: TARGET = lilypad
-lilypad_isp: HFUSE = DD
-lilypad_isp: LFUSE = E2
-lilypad_isp: EFUSE = 00
-lilypad_isp: isp
-
-lilypad_resonator: TARGET = lilypad_resonator
-lilypad_resonator: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=3'
-lilypad_resonator: AVR_FREQ = 8000000L
-lilypad_resonator: $(PROGRAM)_lilypad_resonator.hex
-
-lilypad_resonator_isp: lilypad_resonator
-lilypad_resonator_isp: TARGET = lilypad_resonator
-lilypad_resonator_isp: HFUSE = DD
-lilypad_resonator_isp: LFUSE = C6
-lilypad_resonator_isp: EFUSE = 00
-lilypad_resonator_isp: isp
-
-pro8: TARGET = pro_8MHz
-pro8: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
-pro8: AVR_FREQ = 8000000L
-pro8: $(PROGRAM)_pro_8MHz.hex
-
-pro8_isp: pro8
-pro8_isp: TARGET = pro_8MHz
-pro8_isp: HFUSE = DD
-pro8_isp: LFUSE = C6
-pro8_isp: EFUSE = 00
-pro8_isp: isp
-
-pro16: TARGET = pro_16MHz
-pro16: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
-pro16: AVR_FREQ = 16000000L
-pro16: $(PROGRAM)_pro_16MHz.hex
-
-pro16_isp: pro16
-pro16_isp: TARGET = pro_16MHz
-pro16_isp: HFUSE = DD
-pro16_isp: LFUSE = C6
-pro16_isp: EFUSE = 00
-pro16_isp: isp
-
-pro20: TARGET = pro_20mhz
-pro20: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
-pro20: AVR_FREQ = 20000000L
-pro20: $(PROGRAM)_pro_20mhz.hex
-
-pro20_isp: pro20
-pro20_isp: TARGET = pro_20mhz
-pro20_isp: HFUSE = DD
-pro20_isp: LFUSE = C6
-pro20_isp: EFUSE = 00
-pro20_isp: isp
-
-diecimila: TARGET = diecimila
-diecimila: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1'
-diecimila: AVR_FREQ = 16000000L 
-diecimila: $(PROGRAM)_diecimila.hex
-
-diecimila_isp: diecimila
-diecimila_isp: TARGET = diecimila
-diecimila_isp: HFUSE = DD
-diecimila_isp: LFUSE = FF
-diecimila_isp: EFUSE = 00
-diecimila_isp: isp
-
-ng: TARGET = ng
-ng: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>1' '-DNUM_LED_FLASHES=3'
-ng: AVR_FREQ = 16000000L
-ng: $(PROGRAM)_ng.hex
-
-ng_isp: ng
-ng_isp: TARGET = ng
-ng_isp: HFUSE = DD
-ng_isp: LFUSE = FF
-ng_isp: EFUSE = 00
-ng_isp: isp
-
-atmega328: TARGET = atmega328
-atmega328: MCU_TARGET = atmega328p
-atmega328: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' -DBAUD_RATE=57600
-atmega328: AVR_FREQ = 16000000L 
-atmega328: LDSECTION  = --section-start=.text=0x7800
-atmega328: $(PROGRAM)_atmega328.hex
-
-atmega328_isp: atmega328
-atmega328_isp: TARGET = atmega328
-atmega328_isp: MCU_TARGET = atmega328p
-atmega328_isp: HFUSE = DA
-atmega328_isp: LFUSE = FF
-atmega328_isp: EFUSE = 05
-atmega328_isp: isp
-
-atmega328_pro8: TARGET = atmega328_pro_8MHz
-atmega328_pro8: MCU_TARGET = atmega328p
-atmega328_pro8: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' -DBAUD_RATE=57600 -DDOUBLE_SPEED
-atmega328_pro8: AVR_FREQ = 8000000L 
-atmega328_pro8: LDSECTION  = --section-start=.text=0x7800
-atmega328_pro8: $(PROGRAM)_atmega328_pro_8MHz.hex
-
-atmega328_pro8_isp: atmega328_pro8
-atmega328_pro8_isp: TARGET = atmega328_pro_8MHz
-atmega328_pro8_isp: MCU_TARGET = atmega328p
-atmega328_pro8_isp: HFUSE = DA
-atmega328_pro8_isp: LFUSE = FF
-atmega328_pro8_isp: EFUSE = 05
-atmega328_pro8_isp: isp
-
-mega: TARGET = atmega1280
-mega: MCU_TARGET = atmega1280
-mega: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' -DBAUD_RATE=57600
-mega: AVR_FREQ = 16000000L 
-mega: LDSECTION  = --section-start=.text=0x1F000
-mega: $(PROGRAM)_atmega1280.hex
-
-mega_isp: mega
-mega_isp: TARGET = atmega1280
-mega_isp: MCU_TARGET = atmega1280
-mega_isp: HFUSE = DA
-mega_isp: LFUSE = FF
-mega_isp: EFUSE = F5
-mega_isp: isp
-
-atmega1284p: TARGET = atmega1284p
-atmega1284p: MCU_TARGET = atmega1284p
-atmega1284p: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=57600'
-atmega1284p: AVR_FREQ = 16000000L 
-atmega1284p: LDSECTION  = --section-start=.text=0x1F000
-atmega1284p: $(PROGRAM)_atmega1284p.hex
-
-atmega1284p_8m: TARGET = atmega1284p
-atmega1284p_8m: MCU_TARGET = atmega1284p
-atmega1284p_8m: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=19200'
-atmega1284p_8m: AVR_FREQ = 8000000L
-atmega1284p_8m: LDSECTION  = --section-start=.text=0x1F000
-atmega1284p_8m: $(PROGRAM)_atmega1284p_8m.hex
-
-atmega644p: TARGET = atmega644p
-atmega644p: MCU_TARGET = atmega644p
-atmega644p: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=57600'
-atmega644p: AVR_FREQ = 16000000L
-atmega644p: LDSECTION  = --section-start=.text=0xF800
-atmega644p: $(PROGRAM)_atmega644p.hex
-
-
-atmega1284p_isp: atmega1284p
-atmega1284p_isp: TARGET = atmega1284p
-atmega1284p_isp: MCU_TARGET = atmega1284p
-atmega1284p_isp: HFUSE = DC
-atmega1284p_isp: LFUSE = FF
-atmega1284p_isp: EFUSE = FD
-atmega1284p_isp: isp
-
-isp: $(TARGET)
-	$(ISPFUSES)
-	$(ISPFLASH)
-
-isp-stk500: $(PROGRAM)_$(TARGET).hex
-	$(STK500-1)
-	$(STK500-2)
-
-%.elf: $(OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
-
-clean:
-	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
-
-%.lst: %.elf
-	$(OBJDUMP) -h -S $< > $@
-
-%.hex: %.elf
-	$(OBJCOPY) -j .text -j .data -O ihex $< $@
-
-%.srec: %.elf
-	$(OBJCOPY) -j .text -j .data -O srec $< $@
-
-%.bin: %.elf
-	$(OBJCOPY) -j .text -j .data -O binary $< $@
-	
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
deleted file mode 100644
index 51bd8d5..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ /dev/null
@@ -1,717 +0,0 @@
-/**********************************************************/
-/* Serial Bootloader for Atmel megaAVR Controllers        */
-/*                                                        */
-/* tested with ATmega644 and ATmega644P                   */
-/* should work with other mega's, see code for details    */
-/*                                                        */
-/* ATmegaBOOT.c                                           */
-/*                                                        */
-/* 20090131: Added 324P support from Alex Leone           */
-/*           Marius Kintel                                */
-/* 20080915: applied ADABoot mods for Sanguino 644P       */
-/*           Brian Riley                                  */
-/* 20080711: hacked for Sanguino by Zach Smith            */
-/*           and Justin Day                               */
-/* 20070626: hacked for Arduino Diecimila (which auto-    */
-/*           resets when a USB connection is made to it)  */
-/*           by D. Mellis                                 */
-/* 20060802: hacked for Arduino by D. Cuartielles         */
-/*           based on a previous hack by D. Mellis        */
-/*           and D. Cuartielles                           */
-/*                                                        */
-/* Monitor and debug functions were added to the original */
-/* code by Dr. Erik Lins, chip45.com. (See below)         */
-/*                                                        */
-/* Thanks to Karl Pitrich for fixing a bootloader pin     */
-/* problem and more informative LED blinking!             */
-/*                                                        */
-/* For the latest version see:                            */
-/* http://www.chip45.com/                                 */
-/*                                                        */
-/* ------------------------------------------------------ */
-/*                                                        */
-/* based on stk500boot.c                                  */
-/* Copyright (c) 2003, Jason P. Kyle                      */
-/* All rights reserved.                                   */
-/* see avr1.org for original file and information         */
-/*                                                        */
-/* This program is free software; you can redistribute it */
-/* and/or modify it under the terms of the GNU General    */
-/* Public License as published by the Free Software       */
-/* Foundation; either version 2 of the License, or        */
-/* (at your option) any later version.                    */
-/*                                                        */
-/* This program is distributed in the hope that it will   */
-/* be useful, but WITHOUT ANY WARRANTY; without even the  */
-/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
-/* PARTICULAR PURPOSE.  See the GNU General Public        */
-/* License for more details.                              */
-/*                                                        */
-/* You should have received a copy of the GNU General     */
-/* Public License along with this program; if not, write  */
-/* to the Free Software Foundation, Inc.,                 */
-/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
-/*                                                        */
-/* Licence can be viewed at                               */
-/* http://www.fsf.org/licenses/gpl.txt                    */
-/*                                                        */
-/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
-/* m8515,m8535. ATmega161 has a very small boot block so  */
-/* isn't supported.                                       */
-/*                                                        */
-/* Tested with m168                                       */
-/**********************************************************/
-
-/* $Id$ */
-
-
-/* some includes */
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/wdt.h>
-#include <avr/boot.h>
-
-#ifdef ADABOOT
-    #define NUM_LED_FLASHES 3
-    #define ADABOOT_VER	1
-#endif
-
-
-/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
-#define MAX_ERROR_COUNT 5
-
-/* set the UART baud rate */
-/* 20080711: hack by Zach Hoeken */
-#define BAUD_RATE   38400
-
-/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
-/* never allow AVR Studio to do an update !!!! */
-#define HW_VER	 0x02
-#define SW_MAJOR 0x01
-#define SW_MINOR 0x10
-
-/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
-/* if monitor functions are included, LED goes on after monitor was entered */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB0
-
-/* define various device id's */
-/* manufacturer byte is always the same */
-#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
-#if defined(__AVR_ATmega1284P__)
-#define SIG2	0x97
-#define SIG3	0x05
-#elif defined(__AVR_ATmega644P__)
-#define SIG2	0x96
-#define SIG3	0x0A
-#elif defined(__AVR_ATmega644__)
-#define SIG2	0x96
-#define SIG3	0x09
-#elif defined(__AVR_ATmega324P__)
-#define SIG2	0x95
-#define SIG3	0x08
-#endif
-
-#define PAGE_SIZE		0x080U   //128 words
-#define PAGE_SIZE_BYTES	0x100U   //256 bytes
-
-/* function prototypes */
-void putch(char);
-char getch(void);
-void getNch(uint8_t);
-void byte_response(uint8_t);
-void nothing_response(void);
-char gethex(void);
-void puthex(char);
-void flash_led(uint8_t);
-
-/* some variables */
-union address_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} address;
-
-union length_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} length;
-
-struct flags_struct
-{
-    unsigned eeprom : 1;
-    unsigned rampz  : 1;
-} flags;
-
-uint8_t buff[256];
-
-uint8_t error_count = 0;
-uint8_t sreg;
-
-void (*app_start)(void) = 0x0000;
-
-/* main program starts here */
-int main(void)
-{
-    uint8_t ch,ch2;
-    uint16_t w;
-	uint16_t i;
-	
-    asm volatile("nop\n\t");
-
-#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
-    ch = MCUSR;
-    MCUSR = 0;
-
-    WDTCSR |= _BV(WDCE) | _BV(WDE);
-    WDTCSR = 0;
-
-    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
-      app_start();  // skip bootloader
-#endif
-
-
-	//initialize our serial port.
-    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
-    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
-
-    /* Enable internal pull-up resistor on pin D0 (RX), in order
-    to supress line noise that prevents the bootloader from
-    timing out (DAM: 20070509) */
-    DDRD &= ~_BV(PIND0);
-    PORTD |= _BV(PIND0);
-
-    /* set LED pin as output */
-    LED_DDR |= _BV(LED);
-
-	    /* flash onboard LED to signal entering of bootloader                   */
-	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
-	    /* then a pause and another flash series signifying ADABOOT sub-version */
-
-
-	flash_led(NUM_LED_FLASHES);
-
-	#ifdef	ADABOOT
-		flash_led(ADABOOT_VER);		// BBR 9/13/2008
-	#endif 
-
-    /* forever loop */
-    for (;;)
-	{
-		/* get character from UART */
-		ch = getch();
-
-		/* A bunch of if...else if... gives smaller code than switch...case ! */
-
-		/* Hello is anyone home ? */ 
-		if(ch=='0')
-		    nothing_response();
-
-
-		/* Request programmer ID */
-		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
-		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
-		else if(ch=='1')
-		{
-		    if (getch() == ' ')
-			{
-				putch(0x14);
-				putch('A');
-				putch('V');
-				putch('R');
-				putch(' ');
-				putch('I');
-				putch('S');
-				putch('P');
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }
-		}
-
-
-		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
-		else if(ch=='@')
-		{
-		    ch2 = getch();
-		    if (ch2 > 0x85)
-				getch();
-		    nothing_response();
-		}
-
-
-		/* AVR ISP/STK500 board requests */
-		else if(ch=='A')
-		{
-		    ch2 = getch();
-		    if(ch2 == 0x80)
-				byte_response(HW_VER);		// Hardware version
-		    else if(ch2==0x81)
-				byte_response(SW_MAJOR);	// Software major version
-		    else if(ch2==0x82)
-				byte_response(SW_MINOR);	// Software minor version
-		    else if(ch2==0x98)
-				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
-		    else
-				byte_response(0x00);		// Covers various unnecessary responses we don't care about
-		}
-
-
-		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
-		else if(ch=='B')
-		{
-		    getNch(20);
-		    nothing_response();
-		}
-
-
-		/* Parallel programming stuff  DON'T CARE  */
-		else if(ch=='E')
-		{
-		    getNch(5);
-		    nothing_response();
-		}
-
-
-		/* Enter programming mode  */
-		else if(ch=='P')
-		{
-		    nothing_response();
-		}
-
-
-		/* Leave programming mode  */
-		else if(ch=='Q')
-		{
-		    nothing_response();
-#ifdef ADABOOT		
-			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
-	  		WDTCSR = _BV(WDE);
-	  		while (1); // 16 ms
-#endif		
-		}
-
-
-		/* Erase device, don't care as we will erase one page at a time anyway.  */
-		else if(ch=='R')
-		{
-		    nothing_response();
-		}
-
-
-		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
-		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
-		/* This might explain why little endian was used here, big endian used everywhere else.  */
-		else if(ch=='U')
-		{
-		    address.byte[0] = getch();
-		    address.byte[1] = getch();
-		    nothing_response();
-		}
-
-
-		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
-		else if(ch=='V')
-		{
-		    getNch(4);
-		    byte_response(0x00);
-		}
-
-
-		/* Write memory, length is big endian and is in bytes  */
-		else if(ch=='d')
-		{
-		    length.byte[1] = getch();
-		    length.byte[0] = getch();
-	
-		    flags.eeprom = 0;
-		    if (getch() == 'E')
-				flags.eeprom = 1;
-
-			for (i=0; i<PAGE_SIZE; i++)
-				buff[i] = 0;
-		
-		    for (w = 0; w < length.word; w++)
-			{
-				// Store data in buffer, can't keep up with serial data stream whilst programming pages
-				buff[w] = getch();
-		    }
-	
-		    if (getch() == ' ')
-			{
-				if (flags.eeprom)
-				{		                
-					//Write to EEPROM one byte at a time
-				    for(w=0;w<length.word;w++)
-					{
-						while(EECR & (1<<EEPE));
-					
-						EEAR = (uint16_t)(void *)address.word;
-						EEDR = buff[w];
-						EECR |= (1<<EEMPE);
-						EECR |= (1<<EEPE);
-
-						address.word++;
-				    }			
-				}
-				else
-				{
-					//address * 2 -> byte location
-				    address.word = address.word << 1;
-			    
-					//Even up an odd number of bytes
-					if ((length.byte[0] & 0x01))
-						length.word++;
-				
-					// HACKME: EEPE used to be EEWE
-				    //Wait for previous EEPROM writes to complete
-					//while(bit_is_set(EECR,EEPE));
-					while(EECR & (1<<EEPE));
-				
-				    asm volatile(
-						 "clr	r17		\n\t"	//page_word_count
-						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
-						 "lds	r31,address+1	\n\t"
-						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
-						 "ldi	r29,hi8(buff)	\n\t"
-						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
-						 "lds	r25,length+1	\n\t"
-						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
-						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
-						 "brne	no_page_erase	\n\t"						 
-						 "wait_spm1:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm1       \n\t"
-						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"							 
-						 "wait_spm2:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm2       \n\t"									 
-
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"
-						 "no_page_erase:		\n\t"							 
-						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
-						 "ld	r1,Y+		\n\t"							 
-							 
-						 "wait_spm3:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm3       \n\t"
-						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-							 
-						 "inc	r17		\n\t"	//page_word_count++
-						 "cpi r17,%1	        \n\t"
-						 "brlo	same_page	\n\t"	//Still same page in FLASH
-						 "write_page:		\n\t"
-						 "clr	r17		\n\t"	//New page, write current one first
-						 "wait_spm4:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm4       \n\t"						 							 
-						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-						 "wait_spm5:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm5       \n\t"									 
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"					 		 
-						 "same_page:		\n\t"							 
-						 "adiw	r30,2		\n\t"	//Next word in FLASH
-						 "sbiw	r24,2		\n\t"	//length-2
-						 "breq	final_write	\n\t"	//Finished
-						 "rjmp	length_loop	\n\t"
-						 "final_write:		\n\t"
-						 "cpi	r17,0		\n\t"
-						 "breq	block_done	\n\t"
-						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
-						 "rjmp	write_page	\n\t"
-						 "block_done:		\n\t"
-						 "clr	__zero_reg__	\n\t"	//restore zero register
-						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
-
-						 );
-				}
-				putch(0x14);
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }		
-		}
-    
-		/* Read memory block mode, length is big endian.  */
-		else if(ch=='t')
-		{
-			length.byte[1] = getch();
-			length.byte[0] = getch();
-
-			if (getch() == 'E')
-				flags.eeprom = 1;
-			else
-			{
-				flags.eeprom = 0;
-				address.word = address.word << 1;	        // address * 2 -> byte location
-			}
-
-			// Command terminator
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				for (w=0; w<length.word; w++)
-				{
-					// Can handle odd and even lengths okay
-				    if (flags.eeprom) 
-					{
-						// Byte access EEPROM read
-						while(EECR & (1<<EEPE));
-						EEAR = (uint16_t)(void *)address.word;
-						EECR |= (1<<EERE);
-						putch(EEDR);
-
-						address.word++;
-				    }
-				    else
-					{
-						if (!flags.rampz)
-							putch(pgm_read_byte_near(address.word));
-
-						address.word++;
-				    }
-				}
-				putch(0x10);
-		    }
-		}
-
-
-		/* Get device signature bytes  */
-		else if(ch=='u')
-		{
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				putch(SIG1);
-				putch(SIG2);
-				putch(SIG3);
-				putch(0x10);
-			}
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-					app_start();
-			}
-		}
-
-
-		/* Read oscillator calibration byte */
-		else if(ch=='v')
-			byte_response(0x00);
-
-		else if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-
-	}
-    /* end of forever loop */
-}
-
-
-char gethex(void)
-{
-    char ah,al;
-
-    ah = getch();
-	putch(ah);
-    al = getch();
-	putch(al);
-    
-	if(ah >= 'a')
-		ah = ah - 'a' + 0x0a;
-	else if(ah >= '0')
-		ah -= '0';
-    if(al >= 'a')
-		al = al - 'a' + 0x0a;
-	else if(al >= '0')
-		al -= '0';
-
-    return (ah << 4) + al;
-}
-
-
-void puthex(char ch)
-{
-    char ah,al;
-
-    ah = (ch & 0xf0) >> 4;
-	if(ah >= 0x0a)
-		ah = ah - 0x0a + 'a';
-	else
-		ah += '0';
-
-    al = (ch & 0x0f);
-	if(al >= 0x0a)
-		al = al - 0x0a + 'a';
-	else
-		al += '0';
-
-    putch(ah);
-    putch(al);
-}
-
-
-void putch(char ch)
-{
-    while (!(UCSR0A & _BV(UDRE0)));
-    UDR0 = ch;
-}
-
-
-
-
-char getch(void)
-{
-    uint32_t count = 0;
-
-#ifdef ADABOOT
-	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    while(!(UCSR0A & _BV(RXC0)))
-	{
-    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-    	/* HACKME:: here is a good place to count times*/
-    	count++;
-    	if (count > MAX_TIME_COUNT)
-    		app_start();
-     }
-
-#ifdef ADABOOT
-	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    return UDR0;
-}
-
-
-void getNch(uint8_t count)
-{
-    uint8_t i;
-    for(i=0;i<count;i++)
-	{
-		while(!(UCSR0A & _BV(RXC0)));
-		UDR0;
-    }
-}
-
-
-void byte_response(uint8_t val)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(val);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-
-void nothing_response(void)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-#ifdef ADABOOT
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED count times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get      */
-	/* optimized away if compiling with optimizations (DAM).          */
-	
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = ADABOOT;
-    }
-    
-
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);					// LED on
-		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
-		LED_PORT &= ~_BV(LED);					// LED off
-		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
-	}
-
-	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
-		
-}
-
-#else
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED three times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get
-	optimized away if compiling with optimizations (DAM). */
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = 3;
-    }
-    
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l);
-		LED_PORT &= ~_BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l); 
-	}
-		
-}
-
-
-#endif
-
-
-/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
deleted file mode 100644
index 7e0adff..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
+++ /dev/null
@@ -1,388 +0,0 @@
-/**********************************************************/
-/* Serial Bootloader for Atmel megaAVR Controllers        */
-/*                                                        */
-/* tested with ATmega644 and ATmega644P                   */
-/* should work with other mega's, see code for details    */
-/*                                                        */
-/* ATmegaBOOT.c                                           */
-/*                                                        */
-/* 20090131: Added 324P support from Alex Leone           */
-/*           Marius Kintel                                */
-/* 20080915: applied ADABoot mods for Sanguino 644P       */
-/*           Brian Riley                                  */
-/* 20080711: hacked for Sanguino by Zach Smith            */
-/*           and Justin Day                               */
-/* 20070626: hacked for Arduino Diecimila (which auto-    */
-/*           resets when a USB connection is made to it)  */
-/*           by D. Mellis                                 */
-/* 20060802: hacked for Arduino by D. Cuartielles         */
-/*           based on a previous hack by D. Mellis        */
-/*           and D. Cuartielles                           */
-/*                                                        */
-/* Monitor and debug functions were added to the original */
-/* code by Dr. Erik Lins, chip45.com. (See below)         */
-/*                                                        */
-/* Thanks to Karl Pitrich for fixing a bootloader pin     */
-/* problem and more informative LED blinking!             */
-/*                                                        */
-/* For the latest version see:                            */
-/* http://www.chip45.com/                                 */
-/*                                                        */
-/* ------------------------------------------------------ */
-/*                                                        */
-/* based on stk500boot.c                                  */
-/* Copyright (c) 2003, Jason P. Kyle                      */
-/* All rights reserved.                                   */
-/* see avr1.org for original file and information         */
-/*                                                        */
-/* This program is free software; you can redistribute it */
-/* and/or modify it under the terms of the GNU General    */
-/* Public License as published by the Free Software       */
-/* Foundation; either version 2 of the License, or        */
-/* (at your option) any later version.                    */
-/*                                                        */
-/* This program is distributed in the hope that it will   */
-/* be useful, but WITHOUT ANY WARRANTY; without even the  */
-/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
-/* PARTICULAR PURPOSE.  See the GNU General Public        */
-/* License for more details.                              */
-/*                                                        */
-/* You should have received a copy of the GNU General     */
-/* Public License along with this program; if not, write  */
-/* to the Free Software Foundation, Inc.,                 */
-/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
-/*                                                        */
-/* Licence can be viewed at                               */
-/* http://www.fsf.org/licenses/gpl.txt                    */
-/*                                                        */
-/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
-/* m8515,m8535. ATmega161 has a very small boot block so  */
-/* isn't supported.                                       */
-/*                                                        */
-/* Tested with m168                                       */
-/**********************************************************/
-
-/* $Id$ */
-
-
-/* some includes */
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/wdt.h>
-#include <avr/boot.h>
-#include <util/delay.h>
-
-#ifdef ADABOOT
-    #define NUM_LED_FLASHES 3
-    #define ADABOOT_VER	1
-#endif
-
-
-/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
-#define MAX_ERROR_COUNT 5
-
-/* set the UART baud rate */
-/* 20080711: hack by Zach Hoeken */
-#define BAUD_RATE   38400
-
-/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
-/* never allow AVR Studio to do an update !!!! */
-#define HW_VER	 0x02
-#define SW_MAJOR 0x01
-#define SW_MINOR 0x10
-
-/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
-/* if monitor functions are included, LED goes on after monitor was entered */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB0
-
-/* define various device id's */
-/* manufacturer byte is always the same */
-#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
-#if defined(__AVR_ATmega1284P__)
-#define SIG2	0x97
-#define SIG3	0x05
-#elif defined(__AVR_ATmega644P__)
-#define SIG2	0x96
-#define SIG3	0x0A
-#elif defined(__AVR_ATmega644__)
-#define SIG2	0x96
-#define SIG3	0x09
-#elif defined(__AVR_ATmega324P__)
-#define SIG2	0x95
-#define SIG3	0x08
-#endif
-#define PAGE_SIZE		0x080U   //128 words
-#define PAGE_SIZE_BYTES	0x100U   //256 bytes
-
-/* function prototypes */
-void putch(char);
-char getch(void);
-void getNch(uint8_t);
-void byte_response(uint8_t);
-void nothing_response(void);
-char gethex(void);
-void puthex(char);
-void flash_led(uint8_t);
-
-/* some variables */
-union address_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} address;
-
-union length_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} length;
-
-struct flags_struct
-{
-    unsigned eeprom : 1;
-    unsigned rampz  : 1;
-} flags;
-
-uint8_t buff[256];
-
-uint8_t error_count = 0;
-uint8_t sreg;
-
-void (*app_start)(void) = 0x0000;
-
-/* main program starts here */
-int main(void)
-{
-    uint8_t ch,ch2;
-    uint16_t w;
-	uint16_t i;
-	
-    asm volatile("nop\n\t");
-
-#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
-    ch = MCUSR;
-    MCUSR = 0;
-
-    WDTCSR |= _BV(WDCE) | _BV(WDE);
-    WDTCSR = 0;
-
-    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
-      app_start();  // skip bootloader
-#endif
-
-
-	//initialize our serial port.
-    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
-    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
-
-    /* Enable internal pull-up resistor on pin D0 (RX), in order
-    to supress line noise that prevents the bootloader from
-    timing out (DAM: 20070509) */
-    DDRD &= ~_BV(PIND0);
-    PORTD |= _BV(PIND0);
-
-    /* set LED pin as output */
-    LED_DDR |= _BV(LED);
-
-	    /* flash onboard LED to signal entering of bootloader                   */
-	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
-	    /* then a pause and another flash series signifying ADABOOT sub-version */
-
-
-	flash_led(NUM_LED_FLASHES);
-
-	#ifdef	ADABOOT
-		flash_led(ADABOOT_VER);		// BBR 9/13/2008
-	#endif 
-
-    /* forever loop */
-    for (;;)
-	{
-          putch('\r');
-          _delay_ms(500);
-        }
-    /* end of forever loop */
-}
-
-
-char gethex(void)
-{
-    char ah,al;
-
-    ah = getch();
-	putch(ah);
-    al = getch();
-	putch(al);
-    
-	if(ah >= 'a')
-		ah = ah - 'a' + 0x0a;
-	else if(ah >= '0')
-		ah -= '0';
-    if(al >= 'a')
-		al = al - 'a' + 0x0a;
-	else if(al >= '0')
-		al -= '0';
-
-    return (ah << 4) + al;
-}
-
-
-void puthex(char ch)
-{
-    char ah,al;
-
-    ah = (ch & 0xf0) >> 4;
-	if(ah >= 0x0a)
-		ah = ah - 0x0a + 'a';
-	else
-		ah += '0';
-
-    al = (ch & 0x0f);
-	if(al >= 0x0a)
-		al = al - 0x0a + 'a';
-	else
-		al += '0';
-
-    putch(ah);
-    putch(al);
-}
-
-
-void putch(char ch)
-{
-    while (!(UCSR0A & _BV(UDRE0)));
-    UDR0 = ch;
-}
-
-
-
-
-char getch(void)
-{
-    uint32_t count = 0;
-
-#ifdef ADABOOT
-	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    while(!(UCSR0A & _BV(RXC0)))
-	{
-    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-    	/* HACKME:: here is a good place to count times*/
-    	count++;
-    	if (count > MAX_TIME_COUNT)
-    		app_start();
-     }
-
-#ifdef ADABOOT
-	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    return UDR0;
-}
-
-
-void getNch(uint8_t count)
-{
-    uint8_t i;
-    for(i=0;i<count;i++)
-	{
-		while(!(UCSR0A & _BV(RXC0)));
-		UDR0;
-    }
-}
-
-
-void byte_response(uint8_t val)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(val);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-
-void nothing_response(void)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-#ifdef ADABOOT
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED count times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get      */
-	/* optimized away if compiling with optimizations (DAM).          */
-	
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = ADABOOT;
-    }
-    
-
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);					// LED on
-		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
-		LED_PORT &= ~_BV(LED);					// LED off
-		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
-	}
-
-	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
-		
-}
-
-#else
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED three times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get
-	optimized away if compiling with optimizations (DAM). */
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = 3;
-    }
-    
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l);
-		LED_PORT &= ~_BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l); 
-	}
-		
-}
-
-
-#endif
-
-
-/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf
deleted file mode 100644
index 0ec5c7b..0000000
Binary files a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf and /dev/null differ
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
deleted file mode 100644
index 849c78f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
+++ /dev/null
@@ -1,110 +0,0 @@
-:020000021000EC
-:10F000000C943EF80C9450F80C9450F80C9450F872
-:10F010000C9450F80C9450F80C9450F80C9450F850
-:10F020000C9450F80C9450F80C9450F80C9450F840
-:10F030000C9450F80C9450F80C9450F80C9450F830
-:10F040000C9450F80C9450F80C9450F80C9450F820
-:10F050000C9450F80C9450F80C9450F80C9450F810
-:10F060000C9450F80C9450F80C9450F80C9450F800
-:10F070000C9450F80C9450F80C9450F811241FBEC6
-:10F08000CFEFD0E1DEBFCDBF12E0A0E0B1E001C024
-:10F090001D92A930B107E1F70E9471F90C944FFB62
-:10F0A0000C9400F89091C00095FFFCCF8093C600AF
-:10F0B00008951F93282F332727FD3095207F307028
-:10F0C00094E0359527959A95E1F72A3014F0295A5E
-:10F0D00001C0205D182F1F701A3014F0195A01C09A
-:10F0E000105D822F0E9452F8812F0E9452F81F91CA
-:10F0F0000895EF92FF920F931F932898EE24FF2418
-:10F10000870113C00894E11CF11C011D111D81E051
-:10F11000E81689E0F8068DE3080780E0180728F074
-:10F12000E0910101F091020109958091C00087FFF3
-:10F13000E9CF289A8091C6001F910F91FF90EF9020
-:10F1400008950F931F930E9479F8082F0E9452F898
-:10F150000E9479F8182F0E9452F8013614F00755D2
-:10F1600003C000330CF00053113614F0175503C0E0
-:10F1700010330CF01053802F8295807F810F1F91E8
-:10F180000F91089590E007C02091C00027FFFCCFA9
-:10F190002091C6009F5F9817B8F308951F93182F0A
-:10F1A0000E9479F8803251F484E10E9452F8812F54
-:10F1B0000E9452F880E10E9452F80CC08091000138
-:10F1C0008F5F80930001853029F4E0910101F09177
-:10F1D000020109951F9108950E9479F8803239F44F
-:10F1E00084E10E9452F880E10E9452F808958091D3
-:10F1F00000018F5F80930001853029F4E0910101C7
-:10F20000F091020109950895DF93CF9300D000D0CB
-:10F21000CDB7DEB7882309F481E090E03DC0289A9D
-:10F2200019821A821B821C820CC029813A814B816F
-:10F230005C812F5F3F4F4F4F5F4F29833A834B8352
-:10F240005C8329813A814B815C8120386EE33607EB
-:10F2500060E0460760E0560740F3289819821A825A
-:10F260001B821C820CC029813A814B815C812F5FFB
-:10F270003F4F4F4F5F4F29833A834B835C832981F4
-:10F280003A814B815C8120306AEF360760E04607A7
-:10F2900060E0560740F39F5F981709F619821A82BB
-:10F2A0001B821C820BC089819A81AB81BC81019633
-:10F2B000A11DB11D89839A83AB83BC8389819A8107
-:10F2C000AB81BC81803021E7920722E0A20720E0D9
-:10F2D000B20748F30F900F900F900F90CF91DF91EE
-:10F2E0000895CF92DF92EF92FF920F931F93CF93E7
-:10F2F000DF93000094B714BE809160008861809312
-:10F3000060001092600091FD05C0E0910101F09154
-:10F310000201099589E18093C4001092C50088E13B
-:10F320008093C10086E08093C2005098589A209A3A
-:10F3300083E00E9404F981E00E9404F90E9479F8B8
-:10F34000803309F441C08133E1F40E9479F88032BE
-:10F3500009F097C184E10E9452F881E40E9452F8BA
-:10F3600086E50E9452F882E50E9452F880E20E94EF
-:10F3700052F889E40E9452F883E50E9452F880E531
-:10F380000BC1803439F40E9479F88638E8F00E9485
-:10F3900079F81AC0813499F40E9479F8803811F410
-:10F3A00082E06CC1813811F481E068C1823811F4C7
-:10F3B00080E164C1883909F060C183E05FC18234B3
-:10F3C00031F484E10E94C2F80E94ECF8B7CF853492
-:10F3D00011F485E0F7CF8035B9F3813531F40E941F
-:10F3E000ECF888E080936000FFCF823569F38535C3
-:10F3F00049F40E9479F8809303010E9479F8809380
-:10F400000401E2CF863521F484E00E94C2F835C1C0
-:10F41000843609F0C7C00E9479F8809306020E94E2
-:10F4200079F880930502809108028E7F809308020C
-:10F430000E9479F8853429F48091080281608093D4
-:10F44000080205E011E0F801119281E0E538F807C3
-:10F45000D9F745E0C42E41E0D42EEE24FF2408C0A5
-:10F460000E9479F8F60181936F010894E11CF11C68
-:10F470008091050290910602E816F90688F30E9431
-:10F4800079F8803209F0FDC08091080280FD17C034
-:10F4900020C0F999FECF209103013091040132BDC3
-:10F4A00021BDF80141918F0140BDFA9AF99A2F5F71
-:10F4B0003F4F3093040120930301019602C080E086
-:10F4C00090E020910502309106028217930708F31D
-:10F4D00062C08091030190910401880F991F90935D
-:10F4E0000401809303018091050280FF09C080918F
-:10F4F0000502909106020196909306028093050200
-:10F50000F999FECF1127E0910301F0910401C5E0C4
-:10F51000D1E08091050290910602103091F40091A3
-:10F52000570001700130D9F303E000935700E895CC
-:10F530000091570001700130D9F301E100935700A9
-:10F54000E895099019900091570001700130D9F3A6
-:10F5500001E000935700E8951395103898F01127B3
-:10F560000091570001700130D9F305E00093570076
-:10F57000E8950091570001700130D9F301E1009343
-:10F580005700E8953296029709F0C7CF103011F076
-:10F590000296E5CF112484E10E9452F880E10E9496
-:10F5A00052F8CCCE843709F055C00E9479F8809388
-:10F5B00006020E9479F8809305020E9479F89091E2
-:10F5C0000802853421F49160909308020DC09E7F5B
-:10F5D000909308028091030190910401880F991F74
-:10F5E00090930401809303010E9479F8803209F01E
-:10F5F000A5CE84E10E9452F800E010E023C0809183
-:10F60000080280FF0BC0F999FECF80910301909111
-:10F61000040192BD81BDF89A80B507C081FD07C085
-:10F62000E0910301F091040184910E9452F88091CD
-:10F6300003019091040101969093040180930301CA
-:10F640000F5F1F4F8091050290910602081719075E
-:10F65000B0F2A4CF853779F40E9479F8803289F42A
-:10F6600084E10E9452F88EE10E9452F886E90E94DD
-:10F6700052F88AE091CF863721F480E00E94CEF8DC
-:10F680005DCE809100018F5F80930001853009F08D
-:10F6900055CEE0910101F091020109954FCEF89409
-:02F6A000FFCF9A
-:040000031000F000F9
-:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/Makefile
deleted file mode 100644
index 2bb5e0e..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/Makefile
+++ /dev/null
@@ -1,56 +0,0 @@
-#Makefile for ATmegaBOOT
-# E.Lins, 18.7.2005
-# $Id$
-
-
-# program name should not be changed...
-PROGRAM    = ATmegaBOOT_644P
-
-# enter the target CPU frequency
-AVR_FREQ   = 16000000L
-
-MCU_TARGET = atmega644p
-LDSECTION  = --section-start=.text=0x1F000
-
-OBJ        = $(PROGRAM).o
-OPTIMIZE   = -Os
-
-DEFS       = 
-LIBS       = 
-
-CC         = avr-gcc
-
-
-# Override is only needed by avr-lib build system.
-
-override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
-override LDFLAGS       = -Wl,$(LDSECTION)
-#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
-
-OBJCOPY        = avr-objcopy
-OBJDUMP        = avr-objdump
-
-all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
-all: $(PROGRAM).hex
-
-$(PROGRAM).hex: $(PROGRAM).elf
-	$(OBJCOPY) -j .text -j .data -O ihex $< $@
-	
-$(PROGRAM).elf: $(OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
-	
-$(OBJ): ATmegaBOOT.c
-	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -Os -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
-
-%.lst: %.elf
-	$(OBJDUMP) -h -S $< > $@
-
-%.srec: %.elf
-	$(OBJCOPY) -j .text -j .data -O srec $< $@
-
-%.bin: %.elf
-	$(OBJCOPY) -j .text -j .data -O binary $< $@
-
-clean:
-	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
-	
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/README.txt
deleted file mode 100644
index 8286007..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/bootloaders/atmega644p/README.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
-To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Arduino.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Arduino.h
deleted file mode 100644
index b265825..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Arduino.h
+++ /dev/null
@@ -1,215 +0,0 @@
-#ifndef Arduino_h
-#define Arduino_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/pgmspace.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-#define INPUT_PULLUP 0x2
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
-#define DEFAULT 0
-#define EXTERNAL 1
-#define INTERNAL 2
-#else  
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-#endif
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
-#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-
-#define analogInPinToBit(P) (P)
-
-// On the ATmega1280, the addresses of some of the port registers are
-// greater than 255, so we can't store them in uint8_t's.
-extern const uint16_t PROGMEM port_to_mode_PGM[];
-extern const uint16_t PROGMEM port_to_input_PGM[];
-extern const uint16_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#ifdef ARDUINO_MAIN
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-#define PE 5
-#define PF 6
-#define PG 7
-#define PH 8
-#define PJ 10
-#define PK 11
-#define PL 12
-#endif
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-#define TIMER3A 8
-#define TIMER3B 9
-#define TIMER3C 10
-#define TIMER4A 11
-#define TIMER4B 12
-#define TIMER4C 13
-#define TIMER4D 14	
-#define TIMER5A 15
-#define TIMER5B 16
-#define TIMER5C 17
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-
-#endif
-
-#include "pins_arduino.h"
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/CDC.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/CDC.cpp
deleted file mode 100644
index 701e483..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/CDC.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include <avr/wdt.h>
-
-#if defined(USBCON)
-#ifdef CDC_ENABLED
-
-#if (RAMEND < 1000)
-#define SERIAL_BUFFER_SIZE 16
-#else
-#define SERIAL_BUFFER_SIZE 64
-#endif
-
-struct ring_buffer
-{
-	unsigned char buffer[SERIAL_BUFFER_SIZE];
-	volatile int head;
-	volatile int tail;
-};
-
-ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
-
-typedef struct
-{
-	u32	dwDTERate;
-	u8	bCharFormat;
-	u8 	bParityType;
-	u8 	bDataBits;
-	u8	lineState;
-} LineInfo;
-
-static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
-
-#define WEAK __attribute__ ((weak))
-
-extern const CDCDescriptor _cdcInterface PROGMEM;
-const CDCDescriptor _cdcInterface =
-{
-	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
-
-	//	CDC communication interface
-	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
-	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
-	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
-	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported
-	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, data interface is slave 0
-	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
-
-	//	CDC data interface
-	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
-	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
-	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
-};
-
-int WEAK CDC_GetInterface(u8* interfaceNum)
-{
-	interfaceNum[0] += 2;	// uses 2
-	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
-}
-
-bool WEAK CDC_Setup(Setup& setup)
-{
-	u8 r = setup.bRequest;
-	u8 requestType = setup.bmRequestType;
-
-	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
-	{
-		if (CDC_GET_LINE_CODING == r)
-		{
-			USB_SendControl(0,(void*)&_usbLineInfo,7);
-			return true;
-		}
-	}
-
-	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
-	{
-		if (CDC_SET_LINE_CODING == r)
-		{
-			USB_RecvControl((void*)&_usbLineInfo,7);
-			return true;
-		}
-
-		if (CDC_SET_CONTROL_LINE_STATE == r)
-		{
-			_usbLineInfo.lineState = setup.wValueL;
-
-			// auto-reset into the bootloader is triggered when the port, already 
-			// open at 1200 bps, is closed.  this is the signal to start the watchdog
-			// with a relatively long period so it can finish housekeeping tasks
-			// like servicing endpoints before the sketch ends
-			if (1200 == _usbLineInfo.dwDTERate) {
-				// We check DTR state to determine if host port is open (bit 0 of lineState).
-				if ((_usbLineInfo.lineState & 0x01) == 0) {
-					*(uint16_t *)0x0800 = 0x7777;
-					wdt_enable(WDTO_120MS);
-				} else {
-					// Most OSs do some intermediate steps when configuring ports and DTR can
-					// twiggle more than once before stabilizing.
-					// To avoid spurious resets we set the watchdog to 250ms and eventually
-					// cancel if DTR goes back high.
-	
-					wdt_disable();
-					wdt_reset();
-					*(uint16_t *)0x0800 = 0x0;
-				}
-			}
-			return true;
-		}
-	}
-	return false;
-}
-
-
-int _serialPeek = -1;
-void Serial_::begin(uint16_t baud_count)
-{
-}
-
-void Serial_::end(void)
-{
-}
-
-void Serial_::accept(void) 
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
-	
-	// if we should be storing the received character into the location
-	// just before the tail (meaning that the head would advance to the
-	// current location of the tail), we're about to overflow the buffer
-	// and so we don't write the character or advance the head.
-
-	// while we have room to store a byte
-	while (i != buffer->tail) {
-		int c = USB_Recv(CDC_RX);
-		if (c == -1)
-			break;	// no more data
-		buffer->buffer[buffer->head] = c;
-		buffer->head = i;
-
-		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
-	}
-}
-
-int Serial_::available(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
-}
-
-int Serial_::peek(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	if (buffer->head == buffer->tail) {
-		return -1;
-	} else {
-		return buffer->buffer[buffer->tail];
-	}
-}
-
-int Serial_::read(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	// if the head isn't ahead of the tail, we don't have any characters
-	if (buffer->head == buffer->tail) {
-		return -1;
-	} else {
-		unsigned char c = buffer->buffer[buffer->tail];
-		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
-		return c;
-	}	
-}
-
-void Serial_::flush(void)
-{
-	USB_Flush(CDC_TX);
-}
-
-size_t Serial_::write(uint8_t c)
-{
-	/* only try to send bytes if the high-level CDC connection itself 
-	 is open (not just the pipe) - the OS should set lineState when the port
-	 is opened and clear lineState when the port is closed.
-	 bytes sent before the user opens the connection or after
-	 the connection is closed are lost - just like with a UART. */
-	
-	// TODO - ZE - check behavior on different OSes and test what happens if an
-	// open connection isn't broken cleanly (cable is yanked out, host dies
-	// or locks up, or host virtual serial port hangs)
-	if (_usbLineInfo.lineState > 0)	{
-		int r = USB_Send(CDC_TX,&c,1);
-		if (r > 0) {
-			return r;
-		} else {
-			setWriteError();
-			return 0;
-		}
-	}
-	setWriteError();
-	return 0;
-}
-
-// This operator is a convenient way for a sketch to check whether the
-// port has actually been configured and opened by the host (as opposed
-// to just being connected to the host).  It can be used, for example, in 
-// setup() before printing to ensure that an application on the host is
-// actually ready to receive and display the data.
-// We add a short delay before returning to fix a bug observed by Federico
-// where the port is configured (lineState != 0) but not quite opened.
-Serial_::operator bool() {
-	bool result = false;
-	if (_usbLineInfo.lineState > 0) 
-		result = true;
-	delay(10);
-	return result;
-}
-
-Serial_ Serial;
-
-#endif
-#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Client.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Client.h
deleted file mode 100644
index ea13483..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Client.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef client_h
-#define client_h
-#include "Print.h"
-#include "Stream.h"
-#include "IPAddress.h"
-
-class Client : public Stream {
-
-public:
-  virtual int connect(IPAddress ip, uint16_t port) =0;
-  virtual int connect(const char *host, uint16_t port) =0;
-  virtual size_t write(uint8_t) =0;
-  virtual size_t write(const uint8_t *buf, size_t size) =0;
-  virtual int available() = 0;
-  virtual int read() = 0;
-  virtual int read(uint8_t *buf, size_t size) = 0;
-  virtual int peek() = 0;
-  virtual void flush() = 0;
-  virtual void stop() = 0;
-  virtual uint8_t connected() = 0;
-  virtual operator bool() = 0;
-protected:
-  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HID.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HID.cpp
deleted file mode 100644
index ac63608..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HID.cpp
+++ /dev/null
@@ -1,520 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include "USBDesc.h"
-
-#if defined(USBCON)
-#ifdef HID_ENABLED
-
-//#define RAWHID_ENABLED
-
-//	Singletons for mouse and keyboard
-
-Mouse_ Mouse;
-Keyboard_ Keyboard;
-
-//================================================================================
-//================================================================================
-
-//	HID report descriptor
-
-#define LSB(_x) ((_x) & 0xFF)
-#define MSB(_x) ((_x) >> 8)
-
-#define RAWHID_USAGE_PAGE	0xFFC0
-#define RAWHID_USAGE		0x0C00
-#define RAWHID_TX_SIZE 64
-#define RAWHID_RX_SIZE 64
-
-extern const u8 _hidReportDescriptor[] PROGMEM;
-const u8 _hidReportDescriptor[] = {
-	
-	//	Mouse
-    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 54
-    0x09, 0x02,                    // USAGE (Mouse)
-    0xa1, 0x01,                    // COLLECTION (Application)
-    0x09, 0x01,                    //   USAGE (Pointer)
-    0xa1, 0x00,                    //   COLLECTION (Physical)
-    0x85, 0x01,                    //     REPORT_ID (1)
-    0x05, 0x09,                    //     USAGE_PAGE (Button)
-    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
-    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
-    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
-    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
-    0x95, 0x03,                    //     REPORT_COUNT (3)
-    0x75, 0x01,                    //     REPORT_SIZE (1)
-    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
-    0x95, 0x01,                    //     REPORT_COUNT (1)
-    0x75, 0x05,                    //     REPORT_SIZE (5)
-    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
-    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
-    0x09, 0x30,                    //     USAGE (X)
-    0x09, 0x31,                    //     USAGE (Y)
-    0x09, 0x38,                    //     USAGE (Wheel)
-    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
-    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
-    0x75, 0x08,                    //     REPORT_SIZE (8)
-    0x95, 0x03,                    //     REPORT_COUNT (3)
-    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
-    0xc0,                          //   END_COLLECTION
-    0xc0,                          // END_COLLECTION
-
-	//	Keyboard
-    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 47
-    0x09, 0x06,                    // USAGE (Keyboard)
-    0xa1, 0x01,                    // COLLECTION (Application)
-    0x85, 0x02,                    //   REPORT_ID (2)
-    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
-   
-	0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
-    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
-    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
-    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
-    0x75, 0x01,                    //   REPORT_SIZE (1)
-    
-	0x95, 0x08,                    //   REPORT_COUNT (8)
-    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
-    0x95, 0x01,                    //   REPORT_COUNT (1)
-    0x75, 0x08,                    //   REPORT_SIZE (8)
-    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
-    
-	0x95, 0x06,                    //   REPORT_COUNT (6)
-    0x75, 0x08,                    //   REPORT_SIZE (8)
-    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
-    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
-    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
-    
-	0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
-    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
-    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
-    0xc0,                          // END_COLLECTION
-
-#if RAWHID_ENABLED
-	//	RAW HID
-	0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),	// 30
-	0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
-
-	0xA1, 0x01,				// Collection 0x01
-    0x85, 0x03,             // REPORT_ID (3)
-	0x75, 0x08,				// report size = 8 bits
-	0x15, 0x00,				// logical minimum = 0
-	0x26, 0xFF, 0x00,		// logical maximum = 255
-
-	0x95, 64,				// report count TX
-	0x09, 0x01,				// usage
-	0x81, 0x02,				// Input (array)
-
-	0x95, 64,				// report count RX
-	0x09, 0x02,				// usage
-	0x91, 0x02,				// Output (array)
-	0xC0					// end collection
-#endif
-};
-
-extern const HIDDescriptor _hidInterface PROGMEM;
-const HIDDescriptor _hidInterface =
-{
-	D_INTERFACE(HID_INTERFACE,1,3,0,0),
-	D_HIDREPORT(sizeof(_hidReportDescriptor)),
-	D_ENDPOINT(USB_ENDPOINT_IN (HID_ENDPOINT_INT),USB_ENDPOINT_TYPE_INTERRUPT,0x40,0x01)
-};
-
-//================================================================================
-//================================================================================
-//	Driver
-
-u8 _hid_protocol = 1;
-u8 _hid_idle = 1;
-
-#define WEAK __attribute__ ((weak))
-
-int WEAK HID_GetInterface(u8* interfaceNum)
-{
-	interfaceNum[0] += 1;	// uses 1
-	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
-}
-
-int WEAK HID_GetDescriptor(int i)
-{
-	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
-}
-
-void WEAK HID_SendReport(u8 id, const void* data, int len)
-{
-	USB_Send(HID_TX, &id, 1);
-	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
-}
-
-bool WEAK HID_Setup(Setup& setup)
-{
-	u8 r = setup.bRequest;
-	u8 requestType = setup.bmRequestType;
-	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
-	{
-		if (HID_GET_REPORT == r)
-		{
-			//HID_GetReport();
-			return true;
-		}
-		if (HID_GET_PROTOCOL == r)
-		{
-			//Send8(_hid_protocol);	// TODO
-			return true;
-		}
-	}
-	
-	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
-	{
-		if (HID_SET_PROTOCOL == r)
-		{
-			_hid_protocol = setup.wValueL;
-			return true;
-		}
-
-		if (HID_SET_IDLE == r)
-		{
-			_hid_idle = setup.wValueL;
-			return true;
-		}
-	}
-	return false;
-}
-
-//================================================================================
-//================================================================================
-//	Mouse
-
-Mouse_::Mouse_(void) : _buttons(0)
-{
-}
-
-void Mouse_::begin(void) 
-{
-}
-
-void Mouse_::end(void) 
-{
-}
-
-void Mouse_::click(uint8_t b)
-{
-	_buttons = b;
-	move(0,0,0);
-	_buttons = 0;
-	move(0,0,0);
-}
-
-void Mouse_::move(signed char x, signed char y, signed char wheel)
-{
-	u8 m[4];
-	m[0] = _buttons;
-	m[1] = x;
-	m[2] = y;
-	m[3] = wheel;
-	HID_SendReport(1,m,4);
-}
-
-void Mouse_::buttons(uint8_t b)
-{
-	if (b != _buttons)
-	{
-		_buttons = b;
-		move(0,0,0);
-	}
-}
-
-void Mouse_::press(uint8_t b) 
-{
-	buttons(_buttons | b);
-}
-
-void Mouse_::release(uint8_t b)
-{
-	buttons(_buttons & ~b);
-}
-
-bool Mouse_::isPressed(uint8_t b)
-{
-	if ((b & _buttons) > 0) 
-		return true;
-	return false;
-}
-
-//================================================================================
-//================================================================================
-//	Keyboard
-
-Keyboard_::Keyboard_(void) 
-{
-}
-
-void Keyboard_::begin(void) 
-{
-}
-
-void Keyboard_::end(void) 
-{
-}
-
-void Keyboard_::sendReport(KeyReport* keys)
-{
-	HID_SendReport(2,keys,sizeof(KeyReport));
-}
-
-extern
-const uint8_t _asciimap[128] PROGMEM;
-
-#define SHIFT 0x80
-const uint8_t _asciimap[128] =
-{
-	0x00,             // NUL
-	0x00,             // SOH
-	0x00,             // STX
-	0x00,             // ETX
-	0x00,             // EOT
-	0x00,             // ENQ
-	0x00,             // ACK  
-	0x00,             // BEL
-	0x2a,			// BS	Backspace
-	0x2b,			// TAB	Tab
-	0x28,			// LF	Enter
-	0x00,             // VT 
-	0x00,             // FF 
-	0x00,             // CR 
-	0x00,             // SO 
-	0x00,             // SI 
-	0x00,             // DEL
-	0x00,             // DC1
-	0x00,             // DC2
-	0x00,             // DC3
-	0x00,             // DC4
-	0x00,             // NAK
-	0x00,             // SYN
-	0x00,             // ETB
-	0x00,             // CAN
-	0x00,             // EM 
-	0x00,             // SUB
-	0x00,             // ESC
-	0x00,             // FS 
-	0x00,             // GS 
-	0x00,             // RS 
-	0x00,             // US 
-
-	0x2c,		   //  ' '
-	0x1e|SHIFT,	   // !
-	0x34|SHIFT,	   // "
-	0x20|SHIFT,    // #
-	0x21|SHIFT,    // $
-	0x22|SHIFT,    // %
-	0x24|SHIFT,    // &
-	0x34,          // '
-	0x26|SHIFT,    // (
-	0x27|SHIFT,    // )
-	0x25|SHIFT,    // *
-	0x2e|SHIFT,    // +
-	0x36,          // ,
-	0x2d,          // -
-	0x37,          // .
-	0x38,          // /
-	0x27,          // 0
-	0x1e,          // 1
-	0x1f,          // 2
-	0x20,          // 3
-	0x21,          // 4
-	0x22,          // 5
-	0x23,          // 6
-	0x24,          // 7
-	0x25,          // 8
-	0x26,          // 9
-	0x33|SHIFT,      // :
-	0x33,          // ;
-	0x36|SHIFT,      // <
-	0x2e,          // =
-	0x37|SHIFT,      // >
-	0x38|SHIFT,      // ?
-	0x1f|SHIFT,      // @
-	0x04|SHIFT,      // A
-	0x05|SHIFT,      // B
-	0x06|SHIFT,      // C
-	0x07|SHIFT,      // D
-	0x08|SHIFT,      // E
-	0x09|SHIFT,      // F
-	0x0a|SHIFT,      // G
-	0x0b|SHIFT,      // H
-	0x0c|SHIFT,      // I
-	0x0d|SHIFT,      // J
-	0x0e|SHIFT,      // K
-	0x0f|SHIFT,      // L
-	0x10|SHIFT,      // M
-	0x11|SHIFT,      // N
-	0x12|SHIFT,      // O
-	0x13|SHIFT,      // P
-	0x14|SHIFT,      // Q
-	0x15|SHIFT,      // R
-	0x16|SHIFT,      // S
-	0x17|SHIFT,      // T
-	0x18|SHIFT,      // U
-	0x19|SHIFT,      // V
-	0x1a|SHIFT,      // W
-	0x1b|SHIFT,      // X
-	0x1c|SHIFT,      // Y
-	0x1d|SHIFT,      // Z
-	0x2f,          // [
-	0x31,          // bslash
-	0x30,          // ]
-	0x23|SHIFT,    // ^
-	0x2d|SHIFT,    // _
-	0x35,          // `
-	0x04,          // a
-	0x05,          // b
-	0x06,          // c
-	0x07,          // d
-	0x08,          // e
-	0x09,          // f
-	0x0a,          // g
-	0x0b,          // h
-	0x0c,          // i
-	0x0d,          // j
-	0x0e,          // k
-	0x0f,          // l
-	0x10,          // m
-	0x11,          // n
-	0x12,          // o
-	0x13,          // p
-	0x14,          // q
-	0x15,          // r
-	0x16,          // s
-	0x17,          // t
-	0x18,          // u
-	0x19,          // v
-	0x1a,          // w
-	0x1b,          // x
-	0x1c,          // y
-	0x1d,          // z
-	0x2f|SHIFT,    // 
-	0x31|SHIFT,    // |
-	0x30|SHIFT,    // }
-	0x35|SHIFT,    // ~
-	0				// DEL
-};
-
-uint8_t USBPutChar(uint8_t c);
-
-// press() adds the specified key (printing, non-printing, or modifier)
-// to the persistent key report and sends the report.  Because of the way 
-// USB HID works, the host acts like the key remains pressed until we 
-// call release(), releaseAll(), or otherwise clear the report and resend.
-size_t Keyboard_::press(uint8_t k) 
-{
-	uint8_t i;
-	if (k >= 136) {			// it's a non-printing key (not a modifier)
-		k = k - 136;
-	} else if (k >= 128) {	// it's a modifier key
-		_keyReport.modifiers |= (1<<(k-128));
-		k = 0;
-	} else {				// it's a printing key
-		k = pgm_read_byte(_asciimap + k);
-		if (!k) {
-			setWriteError();
-			return 0;
-		}
-		if (k & 0x80) {						// it's a capital letter or other character reached with shift
-			_keyReport.modifiers |= 0x02;	// the left shift modifier
-			k &= 0x7F;
-		}
-	}
-	
-	// Add k to the key report only if it's not already present
-	// and if there is an empty slot.
-	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
-		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
-		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
-		
-		for (i=0; i<6; i++) {
-			if (_keyReport.keys[i] == 0x00) {
-				_keyReport.keys[i] = k;
-				break;
-			}
-		}
-		if (i == 6) {
-			setWriteError();
-			return 0;
-		}	
-	}
-	sendReport(&_keyReport);
-	return 1;
-}
-
-// release() takes the specified key out of the persistent key report and
-// sends the report.  This tells the OS the key is no longer pressed and that
-// it shouldn't be repeated any more.
-size_t Keyboard_::release(uint8_t k) 
-{
-	uint8_t i;
-	if (k >= 136) {			// it's a non-printing key (not a modifier)
-		k = k - 136;
-	} else if (k >= 128) {	// it's a modifier key
-		_keyReport.modifiers &= ~(1<<(k-128));
-		k = 0;
-	} else {				// it's a printing key
-		k = pgm_read_byte(_asciimap + k);
-		if (!k) {
-			return 0;
-		}
-		if (k & 0x80) {							// it's a capital letter or other character reached with shift
-			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
-			k &= 0x7F;
-		}
-	}
-	
-	// Test the key report to see if k is present.  Clear it if it exists.
-	// Check all positions in case the key is present more than once (which it shouldn't be)
-	for (i=0; i<6; i++) {
-		if (0 != k && _keyReport.keys[i] == k) {
-			_keyReport.keys[i] = 0x00;
-		}
-	}
-
-	sendReport(&_keyReport);
-	return 1;
-}
-
-void Keyboard_::releaseAll(void)
-{
-	_keyReport.keys[0] = 0;
-	_keyReport.keys[1] = 0;	
-	_keyReport.keys[2] = 0;
-	_keyReport.keys[3] = 0;	
-	_keyReport.keys[4] = 0;
-	_keyReport.keys[5] = 0;	
-	_keyReport.modifiers = 0;
-	sendReport(&_keyReport);
-}
-
-size_t Keyboard_::write(uint8_t c)
-{	
-	uint8_t p = press(c);		// Keydown
-	uint8_t r = release(c);		// Keyup
-	return (p);					// just return the result of press() since release() almost always returns 1
-}
-
-#endif
-
-#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index 794a7be..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-  Modified 28 September 2010 by Mark Sproul
-  Modified 14 August 2012 by Alarus
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "Arduino.h"
-#include "wiring_private.h"
-
-// this next line disables the entire HardwareSerial.cpp, 
-// this is so I can support Attiny series and any other chip without a uart
-#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
-
-#include "HardwareSerial.h"
-
-/*
- * on ATmega8, the uart and its bits are not numbered, so there is no "TXC0"
- * definition.
- */
-#if !defined(TXC0)
-#if defined(TXC)
-#define TXC0 TXC
-#elif defined(TXC1)
-// Some devices have uart1 but no uart0
-#define TXC0 TXC1
-#else
-#error TXC0 not definable in HardwareSerial.h
-#endif
-#endif
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which head is the index of the location
-// to which to write the next incoming character and tail is the index of the
-// location from which to read.
-#if (RAMEND < 1000)
-  #define SERIAL_BUFFER_SIZE 16
-#else
-  #define SERIAL_BUFFER_SIZE 64
-#endif
-
-struct ring_buffer
-{
-  unsigned char buffer[SERIAL_BUFFER_SIZE];
-  volatile unsigned int head;
-  volatile unsigned int tail;
-};
-
-#if defined(USBCON)
-  ring_buffer rx_buffer = { { 0 }, 0, 0};
-  ring_buffer tx_buffer = { { 0 }, 0, 0};
-#endif
-#if defined(UBRRH) || defined(UBRR0H)
-  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR1H)
-  ring_buffer rx_buffer1  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR2H)
-  ring_buffer rx_buffer2  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer2  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR3H)
-  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
-#endif
-
-inline void store_char(unsigned char c, ring_buffer *buffer)
-{
-  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != buffer->tail) {
-    buffer->buffer[buffer->head] = c;
-    buffer->head = i;
-  }
-}
-
-#if !defined(USART0_RX_vect) && defined(USART1_RX_vect)
-// do nothing - on the 32u4 the first USART is USART1
-#else
-#if !defined(USART_RX_vect) && !defined(SIG_USART0_RECV) && \
-    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
-	!defined(SIG_UART_RECV)
-  #error "Don't know what the Data Received vector is called for the first UART"
-#else
-  void serialEvent() __attribute__((weak));
-  void serialEvent() {}
-  #define serialEvent_implemented
-#if defined(USART_RX_vect)
-  SIGNAL(USART_RX_vect)
-#elif defined(SIG_USART0_RECV)
-  SIGNAL(SIG_USART0_RECV)
-#elif defined(SIG_UART0_RECV)
-  SIGNAL(SIG_UART0_RECV)
-#elif defined(USART0_RX_vect)
-  SIGNAL(USART0_RX_vect)
-#elif defined(SIG_UART_RECV)
-  SIGNAL(SIG_UART_RECV)
-#endif
-  {
-  #if defined(UDR0)
-    if (bit_is_clear(UCSR0A, UPE0)) {
-      unsigned char c = UDR0;
-      store_char(c, &rx_buffer);
-    } else {
-      unsigned char c = UDR0;
-    };
-  #elif defined(UDR)
-    if (bit_is_clear(UCSRA, PE)) {
-      unsigned char c = UDR;
-      store_char(c, &rx_buffer);
-    } else {
-      unsigned char c = UDR;
-    };
-  #else
-    #error UDR not defined
-  #endif
-  }
-#endif
-#endif
-
-#if defined(USART1_RX_vect)
-  void serialEvent1() __attribute__((weak));
-  void serialEvent1() {}
-  #define serialEvent1_implemented
-  SIGNAL(USART1_RX_vect)
-  {
-    if (bit_is_clear(UCSR1A, UPE1)) {
-      unsigned char c = UDR1;
-      store_char(c, &rx_buffer1);
-    } else {
-      unsigned char c = UDR1;
-    };
-  }
-#elif defined(SIG_USART1_RECV)
-  #error SIG_USART1_RECV
-#endif
-
-#if defined(USART2_RX_vect) && defined(UDR2)
-  void serialEvent2() __attribute__((weak));
-  void serialEvent2() {}
-  #define serialEvent2_implemented
-  SIGNAL(USART2_RX_vect)
-  {
-    if (bit_is_clear(UCSR2A, UPE2)) {
-      unsigned char c = UDR2;
-      store_char(c, &rx_buffer2);
-    } else {
-      unsigned char c = UDR2;
-    };
-  }
-#elif defined(SIG_USART2_RECV)
-  #error SIG_USART2_RECV
-#endif
-
-#if defined(USART3_RX_vect) && defined(UDR3)
-  void serialEvent3() __attribute__((weak));
-  void serialEvent3() {}
-  #define serialEvent3_implemented
-  SIGNAL(USART3_RX_vect)
-  {
-    if (bit_is_clear(UCSR3A, UPE3)) {
-      unsigned char c = UDR3;
-      store_char(c, &rx_buffer3);
-    } else {
-      unsigned char c = UDR3;
-    };
-  }
-#elif defined(SIG_USART3_RECV)
-  #error SIG_USART3_RECV
-#endif
-
-void serialEventRun(void)
-{
-#ifdef serialEvent_implemented
-  if (Serial.available()) serialEvent();
-#endif
-#ifdef serialEvent1_implemented
-  if (Serial1.available()) serialEvent1();
-#endif
-#ifdef serialEvent2_implemented
-  if (Serial2.available()) serialEvent2();
-#endif
-#ifdef serialEvent3_implemented
-  if (Serial3.available()) serialEvent3();
-#endif
-}
-
-
-#if !defined(USART0_UDRE_vect) && defined(USART1_UDRE_vect)
-// do nothing - on the 32u4 the first USART is USART1
-#else
-#if !defined(UART0_UDRE_vect) && !defined(UART_UDRE_vect) && !defined(USART0_UDRE_vect) && !defined(USART_UDRE_vect)
-  #error "Don't know what the Data Register Empty vector is called for the first UART"
-#else
-#if defined(UART0_UDRE_vect)
-ISR(UART0_UDRE_vect)
-#elif defined(UART_UDRE_vect)
-ISR(UART_UDRE_vect)
-#elif defined(USART0_UDRE_vect)
-ISR(USART0_UDRE_vect)
-#elif defined(USART_UDRE_vect)
-ISR(USART_UDRE_vect)
-#endif
-{
-  if (tx_buffer.head == tx_buffer.tail) {
-	// Buffer empty, so disable interrupts
-#if defined(UCSR0B)
-    cbi(UCSR0B, UDRIE0);
-#else
-    cbi(UCSRB, UDRIE);
-#endif
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
-    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-  #if defined(UDR0)
-    UDR0 = c;
-  #elif defined(UDR)
-    UDR = c;
-  #else
-    #error UDR not defined
-  #endif
-  }
-}
-#endif
-#endif
-
-#ifdef USART1_UDRE_vect
-ISR(USART1_UDRE_vect)
-{
-  if (tx_buffer1.head == tx_buffer1.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR1B, UDRIE1);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
-    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR1 = c;
-  }
-}
-#endif
-
-#ifdef USART2_UDRE_vect
-ISR(USART2_UDRE_vect)
-{
-  if (tx_buffer2.head == tx_buffer2.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR2B, UDRIE2);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
-    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR2 = c;
-  }
-}
-#endif
-
-#ifdef USART3_UDRE_vect
-ISR(USART3_UDRE_vect)
-{
-  if (tx_buffer3.head == tx_buffer3.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR3B, UDRIE3);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
-    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR3 = c;
-  }
-}
-#endif
-
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *ucsrc, volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _tx_buffer = tx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _ucsrc = ucsrc;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udrie = udrie;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(unsigned long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-
-try_again:
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-  
-  if ((baud_setting > 4095) && use_u2x)
-  {
-    use_u2x = false;
-    goto try_again;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  transmitting = false;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-  cbi(*_ucsrb, _udrie);
-}
-
-void HardwareSerial::begin(unsigned long baud, byte config)
-{
-  uint16_t baud_setting;
-  uint8_t current_config;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-
-try_again:
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-  
-  if ((baud_setting > 4095) && use_u2x)
-  {
-    use_u2x = false;
-    goto try_again;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  //set the data bits, parity, and stop bits
-#if defined(__AVR_ATmega8__)
-  config |= 0x80; // select UCSRC register (shared with UBRRH)
-#endif
-  *_ucsrc = config;
-  
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-  cbi(*_ucsrb, _udrie);
-}
-
-void HardwareSerial::end()
-{
-  // wait for transmission of outgoing data
-  while (_tx_buffer->head != _tx_buffer->tail)
-    ;
-
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-  cbi(*_ucsrb, _udrie);
-  
-  // clear any received data
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-int HardwareSerial::available(void)
-{
-  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
-}
-
-int HardwareSerial::peek(void)
-{
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    return _rx_buffer->buffer[_rx_buffer->tail];
-  }
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
-  while (transmitting && ! (*_ucsra & _BV(TXC0)));
-  transmitting = false;
-}
-
-size_t HardwareSerial::write(uint8_t c)
-{
-  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
-	
-  // If the output buffer is full, there's nothing for it other than to 
-  // wait for the interrupt handler to empty it a bit
-  // ???: return 0 here instead?
-  while (i == _tx_buffer->tail)
-    ;
-	
-  _tx_buffer->buffer[_tx_buffer->head] = c;
-  _tx_buffer->head = i;
-	
-  sbi(*_ucsrb, _udrie);
-  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
-  transmitting = true;
-  sbi(*_ucsra, TXC0);
-  
-  return 1;
-}
-
-HardwareSerial::operator bool() {
-	return true;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-
-#if defined(UBRRH) && defined(UBRRL)
-  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
-#elif defined(UBRR0H) && defined(UBRR0L)
-  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
-#elif defined(USBCON)
-  // do nothing - Serial object and buffers are initialized in CDC code
-#else
-  #error no serial port defined  (port 0)
-#endif
-
-#if defined(UBRR1H)
-  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
-#endif
-#if defined(UBRR2H)
-  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
-#endif
-#if defined(UBRR3H)
-  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
-#endif
-
-#endif // whole file
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.h
deleted file mode 100644
index a73117f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  Modified 28 September 2010 by Mark Sproul
-  Modified 14 August 2012 by Alarus
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Stream.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Stream
-{
-  private:
-    ring_buffer *_rx_buffer;
-    ring_buffer *_tx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_ucsrc;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udrie;
-    uint8_t _u2x;
-    bool transmitting;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *ucsrc, volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x);
-    void begin(unsigned long);
-    void begin(unsigned long, uint8_t);
-    void end();
-    virtual int available(void);
-    virtual int peek(void);
-    virtual int read(void);
-    virtual void flush(void);
-    virtual size_t write(uint8_t);
-    inline size_t write(unsigned long n) { return write((uint8_t)n); }
-    inline size_t write(long n) { return write((uint8_t)n); }
-    inline size_t write(unsigned int n) { return write((uint8_t)n); }
-    inline size_t write(int n) { return write((uint8_t)n); }
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-    operator bool();
-};
-
-// Define config for Serial.begin(baud, config);
-#define SERIAL_5N1 0x00
-#define SERIAL_6N1 0x02
-#define SERIAL_7N1 0x04
-#define SERIAL_8N1 0x06
-#define SERIAL_5N2 0x08
-#define SERIAL_6N2 0x0A
-#define SERIAL_7N2 0x0C
-#define SERIAL_8N2 0x0E
-#define SERIAL_5E1 0x20
-#define SERIAL_6E1 0x22
-#define SERIAL_7E1 0x24
-#define SERIAL_8E1 0x26
-#define SERIAL_5E2 0x28
-#define SERIAL_6E2 0x2A
-#define SERIAL_7E2 0x2C
-#define SERIAL_8E2 0x2E
-#define SERIAL_5O1 0x30
-#define SERIAL_6O1 0x32
-#define SERIAL_7O1 0x34
-#define SERIAL_8O1 0x36
-#define SERIAL_5O2 0x38
-#define SERIAL_6O2 0x3A
-#define SERIAL_7O2 0x3C
-#define SERIAL_8O2 0x3E
-
-#if defined(UBRRH) || defined(UBRR0H)
-  extern HardwareSerial Serial;
-#elif defined(USBCON)
-  #include "USBAPI.h"
-//  extern HardwareSerial Serial_;  
-#endif
-#if defined(UBRR1H)
-  extern HardwareSerial Serial1;
-#endif
-#if defined(UBRR2H)
-  extern HardwareSerial Serial2;
-#endif
-#if defined(UBRR3H)
-  extern HardwareSerial Serial3;
-#endif
-
-extern void serialEventRun(void) __attribute__((weak));
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.cpp
deleted file mode 100644
index fe3deb7..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-
-#include <Arduino.h>
-#include <IPAddress.h>
-
-IPAddress::IPAddress()
-{
-    memset(_address, 0, sizeof(_address));
-}
-
-IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
-{
-    _address[0] = first_octet;
-    _address[1] = second_octet;
-    _address[2] = third_octet;
-    _address[3] = fourth_octet;
-}
-
-IPAddress::IPAddress(uint32_t address)
-{
-    memcpy(_address, &address, sizeof(_address));
-}
-
-IPAddress::IPAddress(const uint8_t *address)
-{
-    memcpy(_address, address, sizeof(_address));
-}
-
-IPAddress& IPAddress::operator=(const uint8_t *address)
-{
-    memcpy(_address, address, sizeof(_address));
-    return *this;
-}
-
-IPAddress& IPAddress::operator=(uint32_t address)
-{
-    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
-    return *this;
-}
-
-bool IPAddress::operator==(const uint8_t* addr)
-{
-    return memcmp(addr, _address, sizeof(_address)) == 0;
-}
-
-size_t IPAddress::printTo(Print& p) const
-{
-    size_t n = 0;
-    for (int i =0; i < 3; i++)
-    {
-        n += p.print(_address[i], DEC);
-        n += p.print('.');
-    }
-    n += p.print(_address[3], DEC);
-    return n;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.h
deleted file mode 100644
index 2585aec..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/IPAddress.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- *
- * MIT License:
- * Copyright (c) 2011 Adrian McEwen
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * adrianm@mcqn.com 1/1/2011
- */
-
-#ifndef IPAddress_h
-#define IPAddress_h
-
-#include <Printable.h>
-
-// A class to make it easier to handle and pass around IP addresses
-
-class IPAddress : public Printable {
-private:
-    uint8_t _address[4];  // IPv4 address
-    // Access the raw byte array containing the address.  Because this returns a pointer
-    // to the internal structure rather than a copy of the address this function should only
-    // be used when you know that the usage of the returned uint8_t* will be transient and not
-    // stored.
-    uint8_t* raw_address() { return _address; };
-
-public:
-    // Constructors
-    IPAddress();
-    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
-    IPAddress(uint32_t address);
-    IPAddress(const uint8_t *address);
-
-    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
-    // to a four-byte uint8_t array is expected
-    operator uint32_t() { return *((uint32_t*)_address); };
-    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
-    bool operator==(const uint8_t* addr);
-
-    // Overloaded index operator to allow getting and setting individual octets of the address
-    uint8_t operator[](int index) const { return _address[index]; };
-    uint8_t& operator[](int index) { return _address[index]; };
-
-    // Overloaded copy operators to allow initialisation of IPAddress objects from other types
-    IPAddress& operator=(const uint8_t *address);
-    IPAddress& operator=(uint32_t address);
-
-    virtual size_t printTo(Print& p) const;
-
-    friend class EthernetClass;
-    friend class UDP;
-    friend class Client;
-    friend class Server;
-    friend class DhcpClass;
-    friend class DNSClient;
-};
-
-const IPAddress INADDR_NONE(0,0,0,0);
-
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Platform.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Platform.h
deleted file mode 100644
index 8b8f742..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Platform.h
+++ /dev/null
@@ -1,23 +0,0 @@
-
-#ifndef __PLATFORM_H__
-#define __PLATFORM_H__
-
-#include <inttypes.h>
-#include <avr/pgmspace.h>
-#include <avr/eeprom.h>
-#include <avr/interrupt.h>
-#include <util/delay.h>
-
-typedef unsigned char u8;
-typedef unsigned short u16;
-typedef unsigned long u32;
-
-#include "Arduino.h"
-
-#if defined(USBCON)
-	#include "USBDesc.h"
-	#include "USBCore.h"
-	#include "USBAPI.h"
-#endif /* if defined(USBCON) */
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.cpp
deleted file mode 100644
index 53961ec..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include "Arduino.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-/* default implementation: may be overridden */
-size_t Print::write(const uint8_t *buffer, size_t size)
-{
-  size_t n = 0;
-  while (size--) {
-    n += write(*buffer++);
-  }
-  return n;
-}
-
-size_t Print::print(const __FlashStringHelper *ifsh)
-{
-  const char PROGMEM *p = (const char PROGMEM *)ifsh;
-  size_t n = 0;
-  while (1) {
-    unsigned char c = pgm_read_byte(p++);
-    if (c == 0) break;
-    n += write(c);
-  }
-  return n;
-}
-
-size_t Print::print(const String &s)
-{
-  size_t n = 0;
-  for (uint16_t i = 0; i < s.length(); i++) {
-    n += write(s[i]);
-  }
-  return n;
-}
-
-size_t Print::print(const char str[])
-{
-  return write(str);
-}
-
-size_t Print::print(char c)
-{
-  return write(c);
-}
-
-size_t Print::print(unsigned char b, int base)
-{
-  return print((unsigned long) b, base);
-}
-
-size_t Print::print(int n, int base)
-{
-  return print((long) n, base);
-}
-
-size_t Print::print(unsigned int n, int base)
-{
-  return print((unsigned long) n, base);
-}
-
-size_t Print::print(long n, int base)
-{
-  if (base == 0) {
-    return write(n);
-  } else if (base == 10) {
-    if (n < 0) {
-      int t = print('-');
-      n = -n;
-      return printNumber(n, 10) + t;
-    }
-    return printNumber(n, 10);
-  } else {
-    return printNumber(n, base);
-  }
-}
-
-size_t Print::print(unsigned long n, int base)
-{
-  if (base == 0) return write(n);
-  else return printNumber(n, base);
-}
-
-size_t Print::print(double n, int digits)
-{
-  return printFloat(n, digits);
-}
-
-size_t Print::println(const __FlashStringHelper *ifsh)
-{
-  size_t n = print(ifsh);
-  n += println();
-  return n;
-}
-
-size_t Print::print(const Printable& x)
-{
-  return x.printTo(*this);
-}
-
-size_t Print::println(void)
-{
-  size_t n = print('\r');
-  n += print('\n');
-  return n;
-}
-
-size_t Print::println(const String &s)
-{
-  size_t n = print(s);
-  n += println();
-  return n;
-}
-
-size_t Print::println(const char c[])
-{
-  size_t n = print(c);
-  n += println();
-  return n;
-}
-
-size_t Print::println(char c)
-{
-  size_t n = print(c);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned char b, int base)
-{
-  size_t n = print(b, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(int num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned int num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(long num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned long num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(double num, int digits)
-{
-  size_t n = print(num, digits);
-  n += println();
-  return n;
-}
-
-size_t Print::println(const Printable& x)
-{
-  size_t n = print(x);
-  n += println();
-  return n;
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-size_t Print::printNumber(unsigned long n, uint8_t base) {
-  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
-  char *str = &buf[sizeof(buf) - 1];
-
-  *str = '\0';
-
-  // prevent crash if called with base == 1
-  if (base < 2) base = 10;
-
-  do {
-    unsigned long m = n;
-    n /= base;
-    char c = m - base * n;
-    *--str = c < 10 ? c + '0' : c + 'A' - 10;
-  } while(n);
-
-  return write(str);
-}
-
-size_t Print::printFloat(double number, uint8_t digits) 
-{ 
-  size_t n = 0;
-  
-  if (isnan(number)) return print("nan");
-  if (isinf(number)) return print("inf");
-  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
-  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
-  
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     n += print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  n += print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0) {
-    n += print("."); 
-  }
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    n += print(toPrint);
-    remainder -= toPrint; 
-  } 
-  
-  return n;
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.h
deleted file mode 100644
index dc76150..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Print.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-#include <stdio.h> // for size_t
-
-#include "WString.h"
-#include "Printable.h"
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-
-class Print
-{
-  private:
-    int write_error;
-    size_t printNumber(unsigned long, uint8_t);
-    size_t printFloat(double, uint8_t);
-  protected:
-    void setWriteError(int err = 1) { write_error = err; }
-  public:
-    Print() : write_error(0) {}
-  
-    int getWriteError() { return write_error; }
-    void clearWriteError() { setWriteError(0); }
-  
-    virtual size_t write(uint8_t) = 0;
-    size_t write(const char *str) {
-      if (str == NULL) return 0;
-      return write((const uint8_t *)str, strlen(str));
-    }
-    virtual size_t write(const uint8_t *buffer, size_t size);
-    
-    size_t print(const __FlashStringHelper *);
-    size_t print(const String &);
-    size_t print(const char[]);
-    size_t print(char);
-    size_t print(unsigned char, int = DEC);
-    size_t print(int, int = DEC);
-    size_t print(unsigned int, int = DEC);
-    size_t print(long, int = DEC);
-    size_t print(unsigned long, int = DEC);
-    size_t print(double, int = 2);
-    size_t print(const Printable&);
-
-    size_t println(const __FlashStringHelper *);
-    size_t println(const String &s);
-    size_t println(const char[]);
-    size_t println(char);
-    size_t println(unsigned char, int = DEC);
-    size_t println(int, int = DEC);
-    size_t println(unsigned int, int = DEC);
-    size_t println(long, int = DEC);
-    size_t println(unsigned long, int = DEC);
-    size_t println(double, int = 2);
-    size_t println(const Printable&);
-    size_t println(void);
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Printable.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Printable.h
deleted file mode 100644
index d03c9af..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Printable.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  Printable.h - Interface class that allows printing of complex types
-  Copyright (c) 2011 Adrian McEwen.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Printable_h
-#define Printable_h
-
-#include <new.h>
-
-class Print;
-
-/** The Printable class provides a way for new classes to allow themselves to be printed.
-    By deriving from Printable and implementing the printTo method, it will then be possible
-    for users to print out instances of this class by passing them into the usual
-    Print::print and Print::println methods.
-*/
-
-class Printable
-{
-  public:
-    virtual size_t printTo(Print& p) const = 0;
-};
-
-#endif
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Server.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Server.h
deleted file mode 100644
index 9674c76..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Server.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef server_h
-#define server_h
-
-class Server : public Print {
-public:
-  virtual void begin() =0;
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.cpp
deleted file mode 100644
index aafb7fc..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- Stream.cpp - adds parsing methods to Stream class
- Copyright (c) 2008 David A. Mellis.  All right reserved.
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
- Created July 2011
- parsing functions based on TextFinder library by Michael Margolis
- */
-
-#include "Arduino.h"
-#include "Stream.h"
-
-#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
-#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
-
-// private method to read stream with timeout
-int Stream::timedRead()
-{
-  int c;
-  _startMillis = millis();
-  do {
-    c = read();
-    if (c >= 0) return c;
-  } while(millis() - _startMillis < _timeout);
-  return -1;     // -1 indicates timeout
-}
-
-// private method to peek stream with timeout
-int Stream::timedPeek()
-{
-  int c;
-  _startMillis = millis();
-  do {
-    c = peek();
-    if (c >= 0) return c;
-  } while(millis() - _startMillis < _timeout);
-  return -1;     // -1 indicates timeout
-}
-
-// returns peek of the next digit in the stream or -1 if timeout
-// discards non-numeric characters
-int Stream::peekNextDigit()
-{
-  int c;
-  while (1) {
-    c = timedPeek();
-    if (c < 0) return c;  // timeout
-    if (c == '-') return c;
-    if (c >= '0' && c <= '9') return c;
-    read();  // discard non-numeric
-  }
-}
-
-// Public Methods
-//////////////////////////////////////////////////////////////
-
-void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
-{
-  _timeout = timeout;
-}
-
- // find returns true if the target string is found
-bool  Stream::find(char *target)
-{
-  return findUntil(target, NULL);
-}
-
-// reads data from the stream until the target string of given length is found
-// returns true if target string is found, false if timed out
-bool Stream::find(char *target, size_t length)
-{
-  return findUntil(target, length, NULL, 0);
-}
-
-// as find but search ends if the terminator string is found
-bool  Stream::findUntil(char *target, char *terminator)
-{
-  return findUntil(target, strlen(target), terminator, strlen(terminator));
-}
-
-// reads data from the stream until the target string of the given length is found
-// search terminated if the terminator string is found
-// returns true if target string is found, false if terminated or timed out
-bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
-{
-  size_t index = 0;  // maximum target string length is 64k bytes!
-  size_t termIndex = 0;
-  int c;
-  
-  if( *target == 0)
-    return true;   // return true if target is a null string
-  while( (c = timedRead()) > 0){
-    
-    if(c != target[index])
-      index = 0; // reset index if any char does not match
-    
-    if( c == target[index]){
-      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
-      if(++index >= targetLen){ // return true if all chars in the target match
-        return true;
-      }
-    }
-    
-    if(termLen > 0 && c == terminator[termIndex]){
-      if(++termIndex >= termLen)
-        return false;       // return false if terminate string found before target string
-    }
-    else
-      termIndex = 0;
-  }
-  return false;
-}
-
-
-// returns the first valid (long) integer value from the current position.
-// initial characters that are not digits (or the minus sign) are skipped
-// function is terminated by the first character that is not a digit.
-long Stream::parseInt()
-{
-  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
-}
-
-// as above but a given skipChar is ignored
-// this allows format characters (typically commas) in values to be ignored
-long Stream::parseInt(char skipChar)
-{
-  boolean isNegative = false;
-  long value = 0;
-  int c;
-
-  c = peekNextDigit();
-  // ignore non numeric leading characters
-  if(c < 0)
-    return 0; // zero returned if timeout
-
-  do{
-    if(c == skipChar)
-      ; // ignore this charactor
-    else if(c == '-')
-      isNegative = true;
-    else if(c >= '0' && c <= '9')        // is c a digit?
-      value = value * 10 + c - '0';
-    read();  // consume the character we got with peek
-    c = timedPeek();
-  }
-  while( (c >= '0' && c <= '9') || c == skipChar );
-
-  if(isNegative)
-    value = -value;
-  return value;
-}
-
-
-// as parseInt but returns a floating point value
-float Stream::parseFloat()
-{
-  return parseFloat(NO_SKIP_CHAR);
-}
-
-// as above but the given skipChar is ignored
-// this allows format characters (typically commas) in values to be ignored
-float Stream::parseFloat(char skipChar){
-  boolean isNegative = false;
-  boolean isFraction = false;
-  long value = 0;
-  char c;
-  float fraction = 1.0;
-
-  c = peekNextDigit();
-    // ignore non numeric leading characters
-  if(c < 0)
-    return 0; // zero returned if timeout
-
-  do{
-    if(c == skipChar)
-      ; // ignore
-    else if(c == '-')
-      isNegative = true;
-    else if (c == '.')
-      isFraction = true;
-    else if(c >= '0' && c <= '9')  {      // is c a digit?
-      value = value * 10 + c - '0';
-      if(isFraction)
-         fraction *= 0.1;
-    }
-    read();  // consume the character we got with peek
-    c = timedPeek();
-  }
-  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
-
-  if(isNegative)
-    value = -value;
-  if(isFraction)
-    return value * fraction;
-  else
-    return value;
-}
-
-// read characters from stream into buffer
-// terminates if length characters have been read, or timeout (see setTimeout)
-// returns the number of characters placed in the buffer
-// the buffer is NOT null terminated.
-//
-size_t Stream::readBytes(char *buffer, size_t length)
-{
-  size_t count = 0;
-  while (count < length) {
-    int c = timedRead();
-    if (c < 0) break;
-    *buffer++ = (char)c;
-    count++;
-  }
-  return count;
-}
-
-
-// as readBytes with terminator character
-// terminates if length characters have been read, timeout, or if the terminator character  detected
-// returns the number of characters placed in the buffer (0 means no valid data found)
-
-size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
-{
-  if (length < 1) return 0;
-  size_t index = 0;
-  while (index < length) {
-    int c = timedRead();
-    if (c < 0 || c == terminator) break;
-    *buffer++ = (char)c;
-    index++;
-  }
-  return index; // return number of characters, not including null terminator
-}
-
-String Stream::readString()
-{
-  String ret;
-  int c = timedRead();
-  while (c >= 0)
-  {
-    ret += (char)c;
-    c = timedRead();
-  }
-  return ret;
-}
-
-String Stream::readStringUntil(char terminator)
-{
-  String ret;
-  int c = timedRead();
-  while (c >= 0 && c != terminator)
-  {
-    ret += (char)c;
-    c = timedRead();
-  }
-  return ret;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.h
deleted file mode 100644
index 58bbf75..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Stream.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-  Stream.h - base class for character-based streams.
-  Copyright (c) 2010 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  parsing functions based on TextFinder library by Michael Margolis
-*/
-
-#ifndef Stream_h
-#define Stream_h
-
-#include <inttypes.h>
-#include "Print.h"
-
-// compatability macros for testing
-/*
-#define   getInt()            parseInt()
-#define   getInt(skipChar)    parseInt(skipchar)
-#define   getFloat()          parseFloat()
-#define   getFloat(skipChar)  parseFloat(skipChar)
-#define   getString( pre_string, post_string, buffer, length)
-readBytesBetween( pre_string, terminator, buffer, length)
-*/
-
-class Stream : public Print
-{
-  private:
-    unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
-    unsigned long _startMillis;  // used for timeout measurement
-    int timedRead();    // private method to read stream with timeout
-    int timedPeek();    // private method to peek stream with timeout
-    int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
-
-  public:
-    virtual int available() = 0;
-    virtual int read() = 0;
-    virtual int peek() = 0;
-    virtual void flush() = 0;
-
-    Stream() {_timeout=1000;}
-
-// parsing methods
-
-  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
-
-  bool find(char *target);   // reads data from the stream until the target string is found
-  // returns true if target string is found, false if timed out (see setTimeout)
-
-  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
-  // returns true if target string is found, false if timed out
-
-  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
-
-  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
-
-
-  long parseInt(); // returns the first valid (long) integer value from the current position.
-  // initial characters that are not digits (or the minus sign) are skipped
-  // integer is terminated by the first character that is not a digit.
-
-  float parseFloat();               // float version of parseInt
-
-  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
-  // terminates if length characters have been read or timeout (see setTimeout)
-  // returns the number of characters placed in the buffer (0 means no valid data found)
-
-  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
-  // terminates if length characters have been read, timeout, or if the terminator character  detected
-  // returns the number of characters placed in the buffer (0 means no valid data found)
-
-  // Arduino String functions to be added here
-  String readString();
-  String readStringUntil(char terminator);
-
-  protected:
-  long parseInt(char skipChar); // as above but the given skipChar is ignored
-  // as above but the given skipChar is ignored
-  // this allows format characters (typically commas) in values to be ignored
-
-  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Tone.cpp
deleted file mode 100644
index 9bb6fe7..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,616 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
-0008    S Kanemoto  12/06/22 Fixed for Leonardo by @maris_HY
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include "Arduino.h"
-#include "pins_arduino.h"
-
-#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(TIMSK3)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-#endif
-
-#if defined(TIMSK4)
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-#endif
-
-#if defined(TIMSK5)
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#elif defined(__AVR_ATmega32U4__)
- 
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER3
- 
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 3 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
- 
-#else
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-      #if defined(TCCR0A) && defined(TCCR0B)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR2A) && defined(TCCR2B)
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        #if defined(WGM42)
-          bitWrite(TCCR4B, WGM42, 1);
-        #elif defined(CS43)
-          #warning this may not be correct
-          // atmega32u4
-          bitWrite(TCCR4B, CS43, 1);
-        #endif
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if defined(TCCR0B)
-      if (_timer == 0)
-      {
-        TCCR0B = prescalarbits;
-      }
-      else
-#endif
-#if defined(TCCR2B)
-      {
-        TCCR2B = prescalarbits;
-      }
-#else
-      {
-        // dummy place holder to make the above ifdefs work
-      }
-#endif
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-      {
-#if defined(TCCR1B)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#endif
-      }
-#if defined(TCCR3B)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR4B)
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR5B)
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
-        // this combination is for at least the ATmega32
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK, OCIE1A, 1);
-#endif
-        break;
-
-#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-#endif
-
-#if defined(TIMSK3)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-#endif
-
-#if defined(TIMSK4)
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-#endif
-
-#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-// XXX: this function only works properly for timer 2 (the only one we use
-// currently).  for the others, it should end the tone, but won't restore
-// proper PWM functionality for the timer.
-void disableTimer(uint8_t _timer)
-{
-  switch (_timer)
-  {
-    case 0:
-      #if defined(TIMSK0)
-        TIMSK0 = 0;
-      #elif defined(TIMSK)
-        TIMSK = 0; // atmega32
-      #endif
-      break;
-
-#if defined(TIMSK1) && defined(OCIE1A)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-#endif
-
-    case 2:
-      #if defined(TIMSK2) && defined(OCIE2A)
-        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
-      #endif
-      #if defined(TCCR2A) && defined(WGM20)
-        TCCR2A = (1 << WGM20);
-      #endif
-      #if defined(TCCR2B) && defined(CS22)
-        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
-      #endif
-      #if defined(OCR2A)
-        OCR2A = 0;
-      #endif
-      break;
-
-#if defined(TIMSK3)
-    case 3:
-      TIMSK3 = 0;
-      break;
-#endif
-
-#if defined(TIMSK4)
-    case 4:
-      TIMSK4 = 0;
-      break;
-#endif
-
-#if defined(TIMSK5)
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  disableTimer(_timer);
-
-  digitalWrite(_pin, 0);
-}
-
-#ifdef USE_TIMER0
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    disableTimer(0);
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER1
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    disableTimer(1);
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER2
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    // need to call noTone() so that the tone_pins[] entry is reset, so the
-    // timer gets initialized next time we call tone().
-    // XXX: this assumes timer 2 is always the first one used.
-    noTone(tone_pins[0]);
-//    disableTimer(2);
-//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER3
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    disableTimer(3);
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER4
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    disableTimer(4);
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER5
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    disableTimer(5);
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBAPI.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBAPI.h
deleted file mode 100644
index eb2e593..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBAPI.h
+++ /dev/null
@@ -1,196 +0,0 @@
-
-
-#ifndef __USBAPI__
-#define __USBAPI__
-
-#if defined(USBCON)
-
-//================================================================================
-//================================================================================
-//	USB
-
-class USBDevice_
-{
-public:
-	USBDevice_();
-	bool configured();
-
-	void attach();
-	void detach();	// Serial port goes down too...
-	void poll();
-};
-extern USBDevice_ USBDevice;
-
-//================================================================================
-//================================================================================
-//	Serial over CDC (Serial1 is the physical port)
-
-class Serial_ : public Stream
-{
-private:
-	ring_buffer *_cdc_rx_buffer;
-public:
-	void begin(uint16_t baud_count);
-	void end(void);
-
-	virtual int available(void);
-	virtual void accept(void);
-	virtual int peek(void);
-	virtual int read(void);
-	virtual void flush(void);
-	virtual size_t write(uint8_t);
-	using Print::write; // pull in write(str) and write(buf, size) from Print
-	operator bool();
-};
-extern Serial_ Serial;
-
-//================================================================================
-//================================================================================
-//	Mouse
-
-#define MOUSE_LEFT 1
-#define MOUSE_RIGHT 2
-#define MOUSE_MIDDLE 4
-#define MOUSE_ALL (MOUSE_LEFT | MOUSE_RIGHT | MOUSE_MIDDLE)
-
-class Mouse_
-{
-private:
-	uint8_t _buttons;
-	void buttons(uint8_t b);
-public:
-	Mouse_(void);
-	void begin(void);
-	void end(void);
-	void click(uint8_t b = MOUSE_LEFT);
-	void move(signed char x, signed char y, signed char wheel = 0);	
-	void press(uint8_t b = MOUSE_LEFT);		// press LEFT by default
-	void release(uint8_t b = MOUSE_LEFT);	// release LEFT by default
-	bool isPressed(uint8_t b = MOUSE_LEFT);	// check LEFT by default
-};
-extern Mouse_ Mouse;
-
-//================================================================================
-//================================================================================
-//	Keyboard
-
-#define KEY_LEFT_CTRL		0x80
-#define KEY_LEFT_SHIFT		0x81
-#define KEY_LEFT_ALT		0x82
-#define KEY_LEFT_GUI		0x83
-#define KEY_RIGHT_CTRL		0x84
-#define KEY_RIGHT_SHIFT		0x85
-#define KEY_RIGHT_ALT		0x86
-#define KEY_RIGHT_GUI		0x87
-
-#define KEY_UP_ARROW		0xDA
-#define KEY_DOWN_ARROW		0xD9
-#define KEY_LEFT_ARROW		0xD8
-#define KEY_RIGHT_ARROW		0xD7
-#define KEY_BACKSPACE		0xB2
-#define KEY_TAB				0xB3
-#define KEY_RETURN			0xB0
-#define KEY_ESC				0xB1
-#define KEY_INSERT			0xD1
-#define KEY_DELETE			0xD4
-#define KEY_PAGE_UP			0xD3
-#define KEY_PAGE_DOWN		0xD6
-#define KEY_HOME			0xD2
-#define KEY_END				0xD5
-#define KEY_CAPS_LOCK		0xC1
-#define KEY_F1				0xC2
-#define KEY_F2				0xC3
-#define KEY_F3				0xC4
-#define KEY_F4				0xC5
-#define KEY_F5				0xC6
-#define KEY_F6				0xC7
-#define KEY_F7				0xC8
-#define KEY_F8				0xC9
-#define KEY_F9				0xCA
-#define KEY_F10				0xCB
-#define KEY_F11				0xCC
-#define KEY_F12				0xCD
-
-//	Low level key report: up to 6 keys and shift, ctrl etc at once
-typedef struct
-{
-	uint8_t modifiers;
-	uint8_t reserved;
-	uint8_t keys[6];
-} KeyReport;
-
-class Keyboard_ : public Print
-{
-private:
-	KeyReport _keyReport;
-	void sendReport(KeyReport* keys);
-public:
-	Keyboard_(void);
-	void begin(void);
-	void end(void);
-	virtual size_t write(uint8_t k);
-	virtual size_t press(uint8_t k);
-	virtual size_t release(uint8_t k);
-	virtual void releaseAll(void);
-};
-extern Keyboard_ Keyboard;
-
-//================================================================================
-//================================================================================
-//	Low level API
-
-typedef struct
-{
-	uint8_t bmRequestType;
-	uint8_t bRequest;
-	uint8_t wValueL;
-	uint8_t wValueH;
-	uint16_t wIndex;
-	uint16_t wLength;
-} Setup;
-
-//================================================================================
-//================================================================================
-//	HID 'Driver'
-
-int		HID_GetInterface(uint8_t* interfaceNum);
-int		HID_GetDescriptor(int i);
-bool	HID_Setup(Setup& setup);
-void	HID_SendReport(uint8_t id, const void* data, int len);
-
-//================================================================================
-//================================================================================
-//	MSC 'Driver'
-
-int		MSC_GetInterface(uint8_t* interfaceNum);
-int		MSC_GetDescriptor(int i);
-bool	MSC_Setup(Setup& setup);
-bool	MSC_Data(uint8_t rx,uint8_t tx);
-
-//================================================================================
-//================================================================================
-//	CSC 'Driver'
-
-int		CDC_GetInterface(uint8_t* interfaceNum);
-int		CDC_GetDescriptor(int i);
-bool	CDC_Setup(Setup& setup);
-
-//================================================================================
-//================================================================================
-
-#define TRANSFER_PGM		0x80
-#define TRANSFER_RELEASE	0x40
-#define TRANSFER_ZERO		0x20
-
-int USB_SendControl(uint8_t flags, const void* d, int len);
-int USB_RecvControl(void* d, int len);
-
-uint8_t	USB_Available(uint8_t ep);
-int USB_Send(uint8_t ep, const void* data, int len);	// blocking
-int USB_Recv(uint8_t ep, void* data, int len);		// non-blocking
-int USB_Recv(uint8_t ep);							// non-blocking
-void USB_Flush(uint8_t ep);
-
-#endif
-
-#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.cpp
deleted file mode 100644
index d3e0170..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.cpp
+++ /dev/null
@@ -1,684 +0,0 @@
-
-
-/* Copyright (c) 2010, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include "USBDesc.h"
-
-#if defined(USBCON)
-
-#define EP_TYPE_CONTROL				0x00
-#define EP_TYPE_BULK_IN				0x81
-#define EP_TYPE_BULK_OUT			0x80
-#define EP_TYPE_INTERRUPT_IN		0xC1
-#define EP_TYPE_INTERRUPT_OUT		0xC0
-#define EP_TYPE_ISOCHRONOUS_IN		0x41
-#define EP_TYPE_ISOCHRONOUS_OUT		0x40
-
-/** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse type */
-#define TX_RX_LED_PULSE_MS 100
-volatile u8 TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
-volatile u8 RxLEDPulse; /**< Milliseconds remaining for data Rx LED pulse */
-
-//==================================================================
-//==================================================================
-
-extern const u16 STRING_LANGUAGE[] PROGMEM;
-extern const u16 STRING_IPRODUCT[] PROGMEM;
-extern const u16 STRING_IMANUFACTURER[] PROGMEM;
-extern const DeviceDescriptor USB_DeviceDescriptor PROGMEM;
-extern const DeviceDescriptor USB_DeviceDescriptorA PROGMEM;
-
-const u16 STRING_LANGUAGE[2] = {
-	(3<<8) | (2+2),
-	0x0409	// English
-};
-
-const u16 STRING_IPRODUCT[17] = {
-	(3<<8) | (2+2*16),
-#if USB_PID == 0x8036	
-	'A','r','d','u','i','n','o',' ','L','e','o','n','a','r','d','o'
-#elif USB_PID == 0x8037
-	'A','r','d','u','i','n','o',' ','M','i','c','r','o',' ',' ',' '
-#elif USB_PID == 0x803C
-	'A','r','d','u','i','n','o',' ','E','s','p','l','o','r','a',' '
-#elif USB_PID == 0x9208
-	'L','i','l','y','P','a','d','U','S','B',' ',' ',' ',' ',' ',' '
-#else
-	'U','S','B',' ','I','O',' ','B','o','a','r','d',' ',' ',' ',' '
-#endif
-};
-
-const u16 STRING_IMANUFACTURER[12] = {
-	(3<<8) | (2+2*11),
-#if USB_VID == 0x2341
-	'A','r','d','u','i','n','o',' ','L','L','C'
-#elif USB_VID == 0x1b4f
-	'S','p','a','r','k','F','u','n',' ',' ',' '
-#else
-	'U','n','k','n','o','w','n',' ',' ',' ',' '
-#endif
-};
-
-#ifdef CDC_ENABLED
-#define DEVICE_CLASS 0x02
-#else
-#define DEVICE_CLASS 0x00
-#endif
-
-//	DEVICE DESCRIPTOR
-const DeviceDescriptor USB_DeviceDescriptor =
-	D_DEVICE(0x00,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
-
-const DeviceDescriptor USB_DeviceDescriptorA =
-	D_DEVICE(DEVICE_CLASS,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
-
-//==================================================================
-//==================================================================
-
-volatile u8 _usbConfiguration = 0;
-
-static inline void WaitIN(void)
-{
-	while (!(UEINTX & (1<<TXINI)));
-}
-
-static inline void ClearIN(void)
-{
-	UEINTX = ~(1<<TXINI);
-}
-
-static inline void WaitOUT(void)
-{
-	while (!(UEINTX & (1<<RXOUTI)))
-		;
-}
-
-static inline u8 WaitForINOrOUT()
-{
-	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
-		;
-	return (UEINTX & (1<<RXOUTI)) == 0;
-}
-
-static inline void ClearOUT(void)
-{
-	UEINTX = ~(1<<RXOUTI);
-}
-
-void Recv(volatile u8* data, u8 count)
-{
-	while (count--)
-		*data++ = UEDATX;
-	
-	RXLED1;					// light the RX LED
-	RxLEDPulse = TX_RX_LED_PULSE_MS;	
-}
-
-static inline u8 Recv8()
-{
-	RXLED1;					// light the RX LED
-	RxLEDPulse = TX_RX_LED_PULSE_MS;
-
-	return UEDATX;	
-}
-
-static inline void Send8(u8 d)
-{
-	UEDATX = d;
-}
-
-static inline void SetEP(u8 ep)
-{
-	UENUM = ep;
-}
-
-static inline u8 FifoByteCount()
-{
-	return UEBCLX;
-}
-
-static inline u8 ReceivedSetupInt()
-{
-	return UEINTX & (1<<RXSTPI);
-}
-
-static inline void ClearSetupInt()
-{
-	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
-}
-
-static inline void Stall()
-{
-	UECONX = (1<<STALLRQ) | (1<<EPEN);
-}
-
-static inline u8 ReadWriteAllowed()
-{
-	return UEINTX & (1<<RWAL);
-}
-
-static inline u8 Stalled()
-{
-	return UEINTX & (1<<STALLEDI);
-}
-
-static inline u8 FifoFree()
-{
-	return UEINTX & (1<<FIFOCON);
-}
-
-static inline void ReleaseRX()
-{
-	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
-}
-
-static inline void ReleaseTX()
-{
-	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
-}
-
-static inline u8 FrameNumber()
-{
-	return UDFNUML;
-}
-
-//==================================================================
-//==================================================================
-
-u8 USBGetConfiguration(void)
-{
-	return _usbConfiguration;
-}
-
-#define USB_RECV_TIMEOUT
-class LockEP
-{
-	u8 _sreg;
-public:
-	LockEP(u8 ep) : _sreg(SREG)
-	{
-		cli();
-		SetEP(ep & 7);
-	}
-	~LockEP()
-	{
-		SREG = _sreg;
-	}
-};
-
-//	Number of bytes, assumes a rx endpoint
-u8 USB_Available(u8 ep)
-{
-	LockEP lock(ep);
-	return FifoByteCount();
-}
-
-//	Non Blocking receive
-//	Return number of bytes read
-int USB_Recv(u8 ep, void* d, int len)
-{
-	if (!_usbConfiguration || len < 0)
-		return -1;
-	
-	LockEP lock(ep);
-	u8 n = FifoByteCount();
-	len = min(n,len);
-	n = len;
-	u8* dst = (u8*)d;
-	while (n--)
-		*dst++ = Recv8();
-	if (len && !FifoByteCount())	// release empty buffer
-		ReleaseRX();
-	
-	return len;
-}
-
-//	Recv 1 byte if ready
-int USB_Recv(u8 ep)
-{
-	u8 c;
-	if (USB_Recv(ep,&c,1) != 1)
-		return -1;
-	return c;
-}
-
-//	Space in send EP
-u8 USB_SendSpace(u8 ep)
-{
-	LockEP lock(ep);
-	if (!ReadWriteAllowed())
-		return 0;
-	return 64 - FifoByteCount();
-}
-
-//	Blocking Send of data to an endpoint
-int USB_Send(u8 ep, const void* d, int len)
-{
-	if (!_usbConfiguration)
-		return -1;
-
-	int r = len;
-	const u8* data = (const u8*)d;
-	u8 zero = ep & TRANSFER_ZERO;
-	u8 timeout = 250;		// 250ms timeout on send? TODO
-	while (len)
-	{
-		u8 n = USB_SendSpace(ep);
-		if (n == 0)
-		{
-			if (!(--timeout))
-				return -1;
-			delay(1);
-			continue;
-		}
-
-		if (n > len)
-			n = len;
-		len -= n;
-		{
-			LockEP lock(ep);
-			if (ep & TRANSFER_ZERO)
-			{
-				while (n--)
-					Send8(0);
-			}
-			else if (ep & TRANSFER_PGM)
-			{
-				while (n--)
-					Send8(pgm_read_byte(data++));
-			}
-			else
-			{
-				while (n--)
-					Send8(*data++);
-			}
-			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
-				ReleaseTX();
-		}
-	}
-	TXLED1;					// light the TX LED
-	TxLEDPulse = TX_RX_LED_PULSE_MS;
-	return r;
-}
-
-extern const u8 _initEndpoints[] PROGMEM;
-const u8 _initEndpoints[] = 
-{
-	0,
-	
-#ifdef CDC_ENABLED
-	EP_TYPE_INTERRUPT_IN,		// CDC_ENDPOINT_ACM
-	EP_TYPE_BULK_OUT,			// CDC_ENDPOINT_OUT
-	EP_TYPE_BULK_IN,			// CDC_ENDPOINT_IN
-#endif
-
-#ifdef HID_ENABLED
-	EP_TYPE_INTERRUPT_IN		// HID_ENDPOINT_INT
-#endif
-};
-
-#define EP_SINGLE_64 0x32	// EP0
-#define EP_DOUBLE_64 0x36	// Other endpoints
-
-static
-void InitEP(u8 index, u8 type, u8 size)
-{
-	UENUM = index;
-	UECONX = 1;
-	UECFG0X = type;
-	UECFG1X = size;
-}
-
-static
-void InitEndpoints()
-{
-	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
-	{
-		UENUM = i;
-		UECONX = 1;
-		UECFG0X = pgm_read_byte(_initEndpoints+i);
-		UECFG1X = EP_DOUBLE_64;
-	}
-	UERST = 0x7E;	// And reset them
-	UERST = 0;
-}
-
-//	Handle CLASS_INTERFACE requests
-static
-bool ClassInterfaceRequest(Setup& setup)
-{
-	u8 i = setup.wIndex;
-
-#ifdef CDC_ENABLED
-	if (CDC_ACM_INTERFACE == i)
-		return CDC_Setup(setup);
-#endif
-
-#ifdef HID_ENABLED
-	if (HID_INTERFACE == i)
-		return HID_Setup(setup);
-#endif
-	return false;
-}
-
-int _cmark;
-int _cend;
-void InitControl(int end)
-{
-	SetEP(0);
-	_cmark = 0;
-	_cend = end;
-}
-
-static
-bool SendControl(u8 d)
-{
-	if (_cmark < _cend)
-	{
-		if (!WaitForINOrOUT())
-			return false;
-		Send8(d);
-		if (!((_cmark + 1) & 0x3F))
-			ClearIN();	// Fifo is full, release this packet
-	}
-	_cmark++;
-	return true;
-};
-
-//	Clipped by _cmark/_cend
-int USB_SendControl(u8 flags, const void* d, int len)
-{
-	int sent = len;
-	const u8* data = (const u8*)d;
-	bool pgm = flags & TRANSFER_PGM;
-	while (len--)
-	{
-		u8 c = pgm ? pgm_read_byte(data++) : *data++;
-		if (!SendControl(c))
-			return -1;
-	}
-	return sent;
-}
-
-//	Does not timeout or cross fifo boundaries
-//	Will only work for transfers <= 64 bytes
-//	TODO
-int USB_RecvControl(void* d, int len)
-{
-	WaitOUT();
-	Recv((u8*)d,len);
-	ClearOUT();
-	return len;
-}
-
-int SendInterfaces()
-{
-	int total = 0;
-	u8 interfaces = 0;
-
-#ifdef CDC_ENABLED
-	total = CDC_GetInterface(&interfaces);
-#endif
-
-#ifdef HID_ENABLED
-	total += HID_GetInterface(&interfaces);
-#endif
-
-	return interfaces;
-}
-
-//	Construct a dynamic configuration descriptor
-//	This really needs dynamic endpoint allocation etc
-//	TODO
-static
-bool SendConfiguration(int maxlen)
-{
-	//	Count and measure interfaces
-	InitControl(0);	
-	int interfaces = SendInterfaces();
-	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
-
-	//	Now send them
-	InitControl(maxlen);
-	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
-	SendInterfaces();
-	return true;
-}
-
-u8 _cdcComposite = 0;
-
-static
-bool SendDescriptor(Setup& setup)
-{
-	u8 t = setup.wValueH;
-	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
-		return SendConfiguration(setup.wLength);
-
-	InitControl(setup.wLength);
-#ifdef HID_ENABLED
-	if (HID_REPORT_DESCRIPTOR_TYPE == t)
-		return HID_GetDescriptor(t);
-#endif
-
-	u8 desc_length = 0;
-	const u8* desc_addr = 0;
-	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
-	{
-		if (setup.wLength == 8)
-			_cdcComposite = 1;
-		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
-	}
-	else if (USB_STRING_DESCRIPTOR_TYPE == t)
-	{
-		if (setup.wValueL == 0)
-			desc_addr = (const u8*)&STRING_LANGUAGE;
-		else if (setup.wValueL == IPRODUCT) 
-			desc_addr = (const u8*)&STRING_IPRODUCT;
-		else if (setup.wValueL == IMANUFACTURER)
-			desc_addr = (const u8*)&STRING_IMANUFACTURER;
-		else
-			return false;
-	}
-
-	if (desc_addr == 0)
-		return false;
-	if (desc_length == 0)
-		desc_length = pgm_read_byte(desc_addr);
-
-	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
-	return true;
-}
-
-//	Endpoint 0 interrupt
-ISR(USB_COM_vect)
-{
-    SetEP(0);
-	if (!ReceivedSetupInt())
-		return;
-
-	Setup setup;
-	Recv((u8*)&setup,8);
-	ClearSetupInt();
-
-	u8 requestType = setup.bmRequestType;
-	if (requestType & REQUEST_DEVICETOHOST)
-		WaitIN();
-	else
-		ClearIN();
-
-    bool ok = true;
-	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
-	{
-		//	Standard Requests
-		u8 r = setup.bRequest;
-		if (GET_STATUS == r)
-		{
-			Send8(0);		// TODO
-			Send8(0);
-		}
-		else if (CLEAR_FEATURE == r)
-		{
-		}
-		else if (SET_FEATURE == r)
-		{
-		}
-		else if (SET_ADDRESS == r)
-		{
-			WaitIN();
-			UDADDR = setup.wValueL | (1<<ADDEN);
-		}
-		else if (GET_DESCRIPTOR == r)
-		{
-			ok = SendDescriptor(setup);
-		}
-		else if (SET_DESCRIPTOR == r)
-		{
-			ok = false;
-		}
-		else if (GET_CONFIGURATION == r)
-		{
-			Send8(1);
-		}
-		else if (SET_CONFIGURATION == r)
-		{
-			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
-			{
-				InitEndpoints();
-				_usbConfiguration = setup.wValueL;
-			} else
-				ok = false;
-		}
-		else if (GET_INTERFACE == r)
-		{
-		}
-		else if (SET_INTERFACE == r)
-		{
-		}
-	}
-	else
-	{
-		InitControl(setup.wLength);		//	Max length of transfer
-		ok = ClassInterfaceRequest(setup);
-	}
-
-	if (ok)
-		ClearIN();
-	else
-	{
-		Stall();
-	}
-}
-
-void USB_Flush(u8 ep)
-{
-	SetEP(ep);
-	if (FifoByteCount())
-		ReleaseTX();
-}
-
-//	General interrupt
-ISR(USB_GEN_vect)
-{
-	u8 udint = UDINT;
-	UDINT = 0;
-
-	//	End of Reset
-	if (udint & (1<<EORSTI))
-	{
-		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
-		_usbConfiguration = 0;			// not configured yet
-		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
-	}
-
-	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
-	if (udint & (1<<SOFI))
-	{
-#ifdef CDC_ENABLED
-		USB_Flush(CDC_TX);				// Send a tx frame if found
-		if (USB_Available(CDC_RX))	// Handle received bytes (if any)
-			Serial.accept();
-#endif
-		
-		// check whether the one-shot period has elapsed.  if so, turn off the LED
-		if (TxLEDPulse && !(--TxLEDPulse))
-			TXLED0;
-		if (RxLEDPulse && !(--RxLEDPulse))
-			RXLED0;
-	}
-}
-
-//	VBUS or counting frames
-//	Any frame counting?
-u8 USBConnected()
-{
-	u8 f = UDFNUML;
-	delay(3);
-	return f != UDFNUML;
-}
-
-//=======================================================================
-//=======================================================================
-
-USBDevice_ USBDevice;
-
-USBDevice_::USBDevice_()
-{
-}
-
-void USBDevice_::attach()
-{
-	_usbConfiguration = 0;
-	UHWCON = 0x01;						// power internal reg
-	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
-#if F_CPU == 16000000UL
-	PLLCSR = 0x12;						// Need 16 MHz xtal
-#elif F_CPU == 8000000UL
-	PLLCSR = 0x02;						// Need 8 MHz xtal
-#endif
-	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
-		;
-
-	// Some tests on specific versions of macosx (10.7.3), reported some
-	// strange behaviuors when the board is reset using the serial
-	// port touch at 1200 bps. This delay fixes this behaviour.
-	delay(1);
-
-	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
-	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
-	UDCON = 0;							// enable attach resistor
-	
-	TX_RX_LED_INIT;
-}
-
-void USBDevice_::detach()
-{
-}
-
-//	Check for interrupts
-//	TODO: VBUS detection
-bool USBDevice_::configured()
-{
-	return _usbConfiguration;
-}
-
-void USBDevice_::poll()
-{
-}
-
-#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.h
deleted file mode 100644
index 8d13806..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBCore.h
+++ /dev/null
@@ -1,303 +0,0 @@
-
-// Copyright (c) 2010, Peter Barrett 
-/*
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-**  
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#ifndef __USBCORE_H__
-#define __USBCORE_H__
-
-//	Standard requests
-#define GET_STATUS			0
-#define CLEAR_FEATURE		1
-#define SET_FEATURE			3
-#define SET_ADDRESS			5
-#define GET_DESCRIPTOR		6
-#define SET_DESCRIPTOR		7
-#define GET_CONFIGURATION	8
-#define SET_CONFIGURATION	9
-#define GET_INTERFACE		10
-#define SET_INTERFACE		11
-
-
-// bmRequestType
-#define REQUEST_HOSTTODEVICE	0x00
-#define REQUEST_DEVICETOHOST	0x80
-#define REQUEST_DIRECTION		0x80
-
-#define REQUEST_STANDARD		0x00
-#define REQUEST_CLASS			0x20
-#define REQUEST_VENDOR			0x40
-#define REQUEST_TYPE			0x60
-
-#define REQUEST_DEVICE			0x00
-#define REQUEST_INTERFACE		0x01
-#define REQUEST_ENDPOINT		0x02
-#define REQUEST_OTHER			0x03
-#define REQUEST_RECIPIENT		0x03
-
-#define REQUEST_DEVICETOHOST_CLASS_INTERFACE  (REQUEST_DEVICETOHOST + REQUEST_CLASS + REQUEST_INTERFACE)
-#define REQUEST_HOSTTODEVICE_CLASS_INTERFACE  (REQUEST_HOSTTODEVICE + REQUEST_CLASS + REQUEST_INTERFACE)
-
-//	Class requests
-
-#define CDC_SET_LINE_CODING			0x20
-#define CDC_GET_LINE_CODING			0x21
-#define CDC_SET_CONTROL_LINE_STATE	0x22
-
-#define MSC_RESET					0xFF
-#define MSC_GET_MAX_LUN				0xFE
-
-#define HID_GET_REPORT				0x01
-#define HID_GET_IDLE				0x02
-#define HID_GET_PROTOCOL			0x03
-#define HID_SET_REPORT				0x09
-#define HID_SET_IDLE				0x0A
-#define HID_SET_PROTOCOL			0x0B
-
-//	Descriptors
-
-#define USB_DEVICE_DESC_SIZE 18
-#define USB_CONFIGUARTION_DESC_SIZE 9
-#define USB_INTERFACE_DESC_SIZE 9
-#define USB_ENDPOINT_DESC_SIZE 7
-
-#define USB_DEVICE_DESCRIPTOR_TYPE             1
-#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
-#define USB_STRING_DESCRIPTOR_TYPE             3
-#define USB_INTERFACE_DESCRIPTOR_TYPE          4
-#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
-
-#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
-#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
-#define USB_DEVICE_CLASS_STORAGE               0x08
-#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
-
-#define USB_CONFIG_POWERED_MASK                0x40
-#define USB_CONFIG_BUS_POWERED                 0x80
-#define USB_CONFIG_SELF_POWERED                0xC0
-#define USB_CONFIG_REMOTE_WAKEUP               0x20
-
-// bMaxPower in Configuration Descriptor
-#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
-
-// bEndpointAddress in Endpoint Descriptor
-#define USB_ENDPOINT_DIRECTION_MASK            0x80
-#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
-#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
-
-#define USB_ENDPOINT_TYPE_MASK                 0x03
-#define USB_ENDPOINT_TYPE_CONTROL              0x00
-#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
-#define USB_ENDPOINT_TYPE_BULK                 0x02
-#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
-
-#define TOBYTES(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
-
-#define CDC_V1_10                               0x0110
-#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
-
-#define CDC_CALL_MANAGEMENT                     0x01
-#define CDC_ABSTRACT_CONTROL_MODEL              0x02
-#define CDC_HEADER                              0x00
-#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
-#define CDC_UNION                               0x06
-#define CDC_CS_INTERFACE                        0x24
-#define CDC_CS_ENDPOINT                         0x25
-#define CDC_DATA_INTERFACE_CLASS                0x0A
-
-#define MSC_SUBCLASS_SCSI						0x06 
-#define MSC_PROTOCOL_BULK_ONLY					0x50 
-
-#define HID_HID_DESCRIPTOR_TYPE					0x21
-#define HID_REPORT_DESCRIPTOR_TYPE				0x22
-#define HID_PHYSICAL_DESCRIPTOR_TYPE			0x23
-
-
-//	Device
-typedef struct {
-	u8 len;				// 18
-	u8 dtype;			// 1 USB_DEVICE_DESCRIPTOR_TYPE
-	u16 usbVersion;		// 0x200
-	u8	deviceClass;
-	u8	deviceSubClass;
-	u8	deviceProtocol;
-	u8	packetSize0;	// Packet 0
-	u16	idVendor;
-	u16	idProduct;
-	u16	deviceVersion;	// 0x100
-	u8	iManufacturer;
-	u8	iProduct;
-	u8	iSerialNumber;
-	u8	bNumConfigurations;
-} DeviceDescriptor;
-
-//	Config
-typedef struct {
-	u8	len;			// 9
-	u8	dtype;			// 2
-	u16 clen;			// total length
-	u8	numInterfaces;
-	u8	config;
-	u8	iconfig;
-	u8	attributes;
-	u8	maxPower;
-} ConfigDescriptor;
-
-//	String
-
-//	Interface
-typedef struct
-{
-	u8 len;		// 9
-	u8 dtype;	// 4
-	u8 number;
-	u8 alternate;
-	u8 numEndpoints;
-	u8 interfaceClass;
-	u8 interfaceSubClass;
-	u8 protocol;
-	u8 iInterface;
-} InterfaceDescriptor;
-
-//	Endpoint
-typedef struct
-{
-	u8 len;		// 7
-	u8 dtype;	// 5
-	u8 addr;
-	u8 attr;
-	u16 packetSize;
-	u8 interval;
-} EndpointDescriptor;
-
-// Interface Association Descriptor
-// Used to bind 2 interfaces together in CDC compostite device
-typedef struct
-{
-	u8 len;				// 8
-	u8 dtype;			// 11
-	u8 firstInterface;
-	u8 interfaceCount;
-	u8 functionClass;
-	u8 funtionSubClass;
-	u8 functionProtocol;
-	u8 iInterface;
-} IADDescriptor;
-
-//	CDC CS interface descriptor
-typedef struct
-{
-	u8 len;		// 5
-	u8 dtype;	// 0x24
-	u8 subtype;
-	u8 d0;
-	u8 d1;
-} CDCCSInterfaceDescriptor;
-
-typedef struct
-{
-	u8 len;		// 4
-	u8 dtype;	// 0x24
-	u8 subtype;
-	u8 d0;
-} CDCCSInterfaceDescriptor4;
-
-typedef struct 
-{
-    u8	len;
-    u8 	dtype;		// 0x24
-    u8 	subtype;	// 1
-    u8 	bmCapabilities;
-    u8 	bDataInterface;
-} CMFunctionalDescriptor;
-	
-typedef struct 
-{
-    u8	len;
-    u8 	dtype;		// 0x24
-    u8 	subtype;	// 1
-    u8 	bmCapabilities;
-} ACMFunctionalDescriptor;
-
-typedef struct 
-{
-	//	IAD
-	IADDescriptor				iad;	// Only needed on compound device
-
-	//	Control
-	InterfaceDescriptor			cif;	// 
-	CDCCSInterfaceDescriptor	header;
-	CMFunctionalDescriptor		callManagement;			// Call Management
-	ACMFunctionalDescriptor		controlManagement;		// ACM
-	CDCCSInterfaceDescriptor	functionalDescriptor;	// CDC_UNION
-	EndpointDescriptor			cifin;
-
-	//	Data
-	InterfaceDescriptor			dif;
-	EndpointDescriptor			in;
-	EndpointDescriptor			out;
-} CDCDescriptor;
-
-typedef struct 
-{
-	InterfaceDescriptor			msc;
-	EndpointDescriptor			in;
-	EndpointDescriptor			out;
-} MSCDescriptor;
-
-typedef struct
-{
-	u8 len;			// 9
-	u8 dtype;		// 0x21
-	u8 addr;
-	u8	versionL;	// 0x101
-	u8	versionH;	// 0x101
-	u8	country;
-	u8	desctype;	// 0x22 report
-	u8	descLenL;
-	u8	descLenH;
-} HIDDescDescriptor;
-
-typedef struct 
-{
-	InterfaceDescriptor			hid;
-	HIDDescDescriptor			desc;
-	EndpointDescriptor			in;
-} HIDDescriptor;
-
-
-#define D_DEVICE(_class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs) \
-	{ 18, 1, 0x200, _class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs }
-
-#define D_CONFIG(_totalLength,_interfaces) \
-	{ 9, 2, _totalLength,_interfaces, 1, 0, USB_CONFIG_BUS_POWERED, USB_CONFIG_POWER_MA(500) }
-
-#define D_INTERFACE(_n,_numEndpoints,_class,_subClass,_protocol) \
-	{ 9, 4, _n, 0, _numEndpoints, _class,_subClass, _protocol, 0 }
-
-#define D_ENDPOINT(_addr,_attr,_packetSize, _interval) \
-	{ 7, 5, _addr,_attr,_packetSize, _interval }
-
-#define D_IAD(_firstInterface, _count, _class, _subClass, _protocol) \
-	{ 8, 11, _firstInterface, _count, _class, _subClass, _protocol, 0 }
-
-#define D_HIDREPORT(_descriptorLength) \
-	{ 9, 0x21, 0x1, 0x1, 0, 1, 0x22, _descriptorLength, 0 }
-
-#define D_CDCCS(_subtype,_d0,_d1)	{ 5, 0x24, _subtype, _d0, _d1 }
-#define D_CDCCS4(_subtype,_d0)		{ 4, 0x24, _subtype, _d0 }
-
-
-#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBDesc.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBDesc.h
deleted file mode 100644
index 900713e..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/USBDesc.h
+++ /dev/null
@@ -1,63 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#define CDC_ENABLED
-#define HID_ENABLED
-
-
-#ifdef CDC_ENABLED
-#define CDC_INTERFACE_COUNT	2
-#define CDC_ENPOINT_COUNT	3
-#else
-#define CDC_INTERFACE_COUNT	0
-#define CDC_ENPOINT_COUNT	0
-#endif
-
-#ifdef HID_ENABLED
-#define HID_INTERFACE_COUNT	1
-#define HID_ENPOINT_COUNT	1
-#else
-#define HID_INTERFACE_COUNT	0
-#define HID_ENPOINT_COUNT	0
-#endif
-
-#define CDC_ACM_INTERFACE	0	// CDC ACM
-#define CDC_DATA_INTERFACE	1	// CDC Data
-#define CDC_FIRST_ENDPOINT	1
-#define CDC_ENDPOINT_ACM	(CDC_FIRST_ENDPOINT)							// CDC First
-#define CDC_ENDPOINT_OUT	(CDC_FIRST_ENDPOINT+1)
-#define CDC_ENDPOINT_IN		(CDC_FIRST_ENDPOINT+2)
-
-#define HID_INTERFACE		(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT)		// HID Interface
-#define HID_FIRST_ENDPOINT	(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT)
-#define HID_ENDPOINT_INT	(HID_FIRST_ENDPOINT)
-
-#define INTERFACE_COUNT		(MSC_INTERFACE + MSC_INTERFACE_COUNT)
-
-#ifdef CDC_ENABLED
-#define CDC_RX CDC_ENDPOINT_OUT
-#define CDC_TX CDC_ENDPOINT_IN
-#endif
-
-#ifdef HID_ENABLED
-#define HID_TX HID_ENDPOINT_INT
-#endif
-
-#define IMANUFACTURER	1
-#define IPRODUCT		2
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Udp.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Udp.h
deleted file mode 100644
index dc5644b..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/Udp.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *  Udp.cpp: Library to send/receive UDP packets.
- *
- * NOTE: UDP is fast, but has some important limitations (thanks to Warren Gray for mentioning these)
- * 1) UDP does not guarantee the order in which assembled UDP packets are received. This
- * might not happen often in practice, but in larger network topologies, a UDP
- * packet can be received out of sequence. 
- * 2) UDP does not guard against lost packets - so packets *can* disappear without the sender being
- * aware of it. Again, this may not be a concern in practice on small local networks.
- * For more information, see http://www.cafeaulait.org/course/week12/35.html
- *
- * MIT License:
- * Copyright (c) 2008 Bjoern Hartmann
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * bjoern@cs.stanford.edu 12/30/2008
- */
-
-#ifndef udp_h
-#define udp_h
-
-#include <Stream.h>
-#include <IPAddress.h>
-
-class UDP : public Stream {
-
-public:
-  virtual uint8_t begin(uint16_t) =0;	// initialize, start listening on specified port. Returns 1 if successful, 0 if there are no sockets available to use
-  virtual void stop() =0;  // Finish with the UDP socket
-
-  // Sending UDP packets
-  
-  // Start building up a packet to send to the remote host specific in ip and port
-  // Returns 1 if successful, 0 if there was a problem with the supplied IP address or port
-  virtual int beginPacket(IPAddress ip, uint16_t port) =0;
-  // Start building up a packet to send to the remote host specific in host and port
-  // Returns 1 if successful, 0 if there was a problem resolving the hostname or port
-  virtual int beginPacket(const char *host, uint16_t port) =0;
-  // Finish off this packet and send it
-  // Returns 1 if the packet was sent successfully, 0 if there was an error
-  virtual int endPacket() =0;
-  // Write a single byte into the packet
-  virtual size_t write(uint8_t) =0;
-  // Write size bytes from buffer into the packet
-  virtual size_t write(const uint8_t *buffer, size_t size) =0;
-
-  // Start processing the next available incoming packet
-  // Returns the size of the packet in bytes, or 0 if no packets are available
-  virtual int parsePacket() =0;
-  // Number of bytes remaining in the current packet
-  virtual int available() =0;
-  // Read a single byte from the current packet
-  virtual int read() =0;
-  // Read up to len bytes from the current packet and place them into buffer
-  // Returns the number of bytes read, or 0 if none are available
-  virtual int read(unsigned char* buffer, size_t len) =0;
-  // Read up to len characters from the current packet and place them into buffer
-  // Returns the number of characters read, or 0 if none are available
-  virtual int read(char* buffer, size_t len) =0;
-  // Return the next byte from the current packet without moving on to the next byte
-  virtual int peek() =0;
-  virtual void flush() =0;	// Finish reading the current packet
-
-  // Return the IP address of the host who sent the current incoming packet
-  virtual IPAddress remoteIP() =0;
-  // Return the port of the host who sent the current incoming packet
-  virtual uint16_t remotePort() =0;
-protected:
-  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WInterrupts.c
deleted file mode 100644
index 62efc9c..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-  Modified 1 August 2010 by Mark Sproul
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "wiring_private.h"
-
-static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    intFunc[interruptNum] = userFunc;
-    
-    // Configure the interrupt mode (trigger on low input, any change, rising
-    // edge, or falling edge).  The mode constants were chosen to correspond
-    // to the configuration bits in the hardware register, so we simply shift
-    // the mode into place.
-      
-    // Enable the interrupt.
-      
-    switch (interruptNum) {
-#if defined(__AVR_ATmega32U4__)
-	// I hate doing this, but the register assignment differs between the 1280/2560
-	// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't 
-	// even present on the 32U4 this is the only way to distinguish between them.
-	case 0:
-		EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);
-		EIMSK |= (1<<INT0);
-		break;
-	case 1:
-		EICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);
-		EIMSK |= (1<<INT1);
-		break;	
-    case 2:
-        EICRA = (EICRA & ~((1<<ISC20) | (1<<ISC21))) | (mode << ISC20);
-        EIMSK |= (1<<INT2);
-        break;
-    case 3:
-        EICRA = (EICRA & ~((1<<ISC30) | (1<<ISC31))) | (mode << ISC30);
-        EIMSK |= (1<<INT3);
-        break;
-#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-      break;
-    case 3:
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-      break;
-    case 4:
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-      break;
-    case 5:
-      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
-      EIMSK |= (1 << INT3);
-      break;
-    case 0:
-      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
-      EIMSK |= (1 << INT4);
-      break;
-    case 1:
-      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
-      EIMSK |= (1 << INT5);
-      break;
-    case 6:
-      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
-      EIMSK |= (1 << INT6);
-      break;
-    case 7:
-      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
-      EIMSK |= (1 << INT7);
-      break;
-#else		
-    case 0:
-    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GICR |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GIMSK |= (1 << INT0);
-    #else
-      #error attachInterrupt not finished for this CPU (case 0)
-    #endif
-      break;
-
-    case 1:
-    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GICR |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GIMSK |= (1 << INT1);
-    #else
-      #warning attachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-    
-    case 2:
-    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      GICR |= (1 << INT2);
-    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      GIMSK |= (1 << INT2);
-    #endif
-      break;
-#endif
-    }
-  }
-}
-
-void detachInterrupt(uint8_t interruptNum) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    // Disable the interrupt.  (We can't assume that interruptNum is equal
-    // to the number of the EIMSK bit to clear, as this isn't true on the 
-    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
-    switch (interruptNum) {
-#if defined(__AVR_ATmega32U4__)
-    case 0:
-        EIMSK &= ~(1<<INT0);
-        break;
-    case 1:
-        EIMSK &= ~(1<<INT1);
-        break;
-    case 2:
-        EIMSK &= ~(1<<INT2);
-        break;
-    case 3:
-        EIMSK &= ~(1<<INT3);
-        break;		
-#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EIMSK &= ~(1 << INT0);
-      break;
-    case 3:
-      EIMSK &= ~(1 << INT1);
-      break;
-    case 4:
-      EIMSK &= ~(1 << INT2);
-      break;
-    case 5:
-      EIMSK &= ~(1 << INT3);
-      break;
-    case 0:
-      EIMSK &= ~(1 << INT4);
-      break;
-    case 1:
-      EIMSK &= ~(1 << INT5);
-      break;
-    case 6:
-      EIMSK &= ~(1 << INT6);
-      break;
-    case 7:
-      EIMSK &= ~(1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EIMSK) && defined(INT0)
-      EIMSK &= ~(1 << INT0);
-    #elif defined(GICR) && defined(ISC00)
-      GICR &= ~(1 << INT0); // atmega32
-    #elif defined(GIMSK) && defined(INT0)
-      GIMSK &= ~(1 << INT0);
-    #else
-      #error detachInterrupt not finished for this cpu
-    #endif
-      break;
-
-    case 1:
-    #if defined(EIMSK) && defined(INT1)
-      EIMSK &= ~(1 << INT1);
-    #elif defined(GICR) && defined(INT1)
-      GICR &= ~(1 << INT1); // atmega32
-    #elif defined(GIMSK) && defined(INT1)
-      GIMSK &= ~(1 << INT1);
-    #else
-      #warning detachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-      
-    intFunc[interruptNum] = 0;
-  }
-}
-
-/*
-void attachInterruptTwi(void (*userFunc)(void) ) {
-  twiIntFunc = userFunc;
-}
-*/
-
-#if defined(__AVR_ATmega32U4__)
-SIGNAL(INT0_vect) {
-	if(intFunc[EXTERNAL_INT_0])
-		intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-	if(intFunc[EXTERNAL_INT_1])
-		intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT2_vect) {
-    if(intFunc[EXTERNAL_INT_2])
-		intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT3_vect) {
-    if(intFunc[EXTERNAL_INT_3])
-		intFunc[EXTERNAL_INT_3]();
-}
-
-#elif defined(EICRA) && defined(EICRB)
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_3])
-    intFunc[EXTERNAL_INT_3]();
-}
-
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_4])
-    intFunc[EXTERNAL_INT_4]();
-}
-
-SIGNAL(INT3_vect) {
-  if(intFunc[EXTERNAL_INT_5])
-    intFunc[EXTERNAL_INT_5]();
-}
-
-SIGNAL(INT4_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT5_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT6_vect) {
-  if(intFunc[EXTERNAL_INT_6])
-    intFunc[EXTERNAL_INT_6]();
-}
-
-SIGNAL(INT7_vect) {
-  if(intFunc[EXTERNAL_INT_7])
-    intFunc[EXTERNAL_INT_7]();
-}
-
-#else
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-#if defined(EICRA) && defined(ISC20)
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-#endif
-
-#endif
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WMath.cpp
deleted file mode 100644
index 2120c4c..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0) {
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.cpp
deleted file mode 100644
index c6839fc..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,645 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  ...mostly rewritten by Paul Stoffregen...
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-  Copyright 2011, Paul Stoffregen, paul@pjrc.com
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "WString.h"
-
-
-/*********************************************/
-/*  Constructors                             */
-/*********************************************/
-
-String::String(const char *cstr)
-{
-	init();
-	if (cstr) copy(cstr, strlen(cstr));
-}
-
-String::String(const String &value)
-{
-	init();
-	*this = value;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-String::String(String &&rval)
-{
-	init();
-	move(rval);
-}
-String::String(StringSumHelper &&rval)
-{
-	init();
-	move(rval);
-}
-#endif
-
-String::String(char c)
-{
-	init();
-	char buf[2];
-	buf[0] = c;
-	buf[1] = 0;
-	*this = buf;
-}
-
-String::String(unsigned char value, unsigned char base)
-{
-	init();
-	char buf[9];
-	utoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(int value, unsigned char base)
-{
-	init();
-	char buf[18];
-	itoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(unsigned int value, unsigned char base)
-{
-	init();
-	char buf[17];
-	utoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(long value, unsigned char base)
-{
-	init();
-	char buf[34];
-	ltoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(unsigned long value, unsigned char base)
-{
-	init();
-	char buf[33];
-	ultoa(value, buf, base);
-	*this = buf;
-}
-
-String::~String()
-{
-	free(buffer);
-}
-
-/*********************************************/
-/*  Memory Management                        */
-/*********************************************/
-
-inline void String::init(void)
-{
-	buffer = NULL;
-	capacity = 0;
-	len = 0;
-	flags = 0;
-}
-
-void String::invalidate(void)
-{
-	if (buffer) free(buffer);
-	buffer = NULL;
-	capacity = len = 0;
-}
-
-unsigned char String::reserve(unsigned int size)
-{
-	if (buffer && capacity >= size) return 1;
-	if (changeBuffer(size)) {
-		if (len == 0) buffer[0] = 0;
-		return 1;
-	}
-	return 0;
-}
-
-unsigned char String::changeBuffer(unsigned int maxStrLen)
-{
-	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
-	if (newbuffer) {
-		buffer = newbuffer;
-		capacity = maxStrLen;
-		return 1;
-	}
-	return 0;
-}
-
-/*********************************************/
-/*  Copy and Move                            */
-/*********************************************/
-
-String & String::copy(const char *cstr, unsigned int length)
-{
-	if (!reserve(length)) {
-		invalidate();
-		return *this;
-	}
-	len = length;
-	strcpy(buffer, cstr);
-	return *this;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-void String::move(String &rhs)
-{
-	if (buffer) {
-		if (capacity >= rhs.len) {
-			strcpy(buffer, rhs.buffer);
-			len = rhs.len;
-			rhs.len = 0;
-			return;
-		} else {
-			free(buffer);
-		}
-	}
-	buffer = rhs.buffer;
-	capacity = rhs.capacity;
-	len = rhs.len;
-	rhs.buffer = NULL;
-	rhs.capacity = 0;
-	rhs.len = 0;
-}
-#endif
-
-String & String::operator = (const String &rhs)
-{
-	if (this == &rhs) return *this;
-	
-	if (rhs.buffer) copy(rhs.buffer, rhs.len);
-	else invalidate();
-	
-	return *this;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-String & String::operator = (String &&rval)
-{
-	if (this != &rval) move(rval);
-	return *this;
-}
-
-String & String::operator = (StringSumHelper &&rval)
-{
-	if (this != &rval) move(rval);
-	return *this;
-}
-#endif
-
-String & String::operator = (const char *cstr)
-{
-	if (cstr) copy(cstr, strlen(cstr));
-	else invalidate();
-	
-	return *this;
-}
-
-/*********************************************/
-/*  concat                                   */
-/*********************************************/
-
-unsigned char String::concat(const String &s)
-{
-	return concat(s.buffer, s.len);
-}
-
-unsigned char String::concat(const char *cstr, unsigned int length)
-{
-	unsigned int newlen = len + length;
-	if (!cstr) return 0;
-	if (length == 0) return 1;
-	if (!reserve(newlen)) return 0;
-	strcpy(buffer + len, cstr);
-	len = newlen;
-	return 1;
-}
-
-unsigned char String::concat(const char *cstr)
-{
-	if (!cstr) return 0;
-	return concat(cstr, strlen(cstr));
-}
-
-unsigned char String::concat(char c)
-{
-	char buf[2];
-	buf[0] = c;
-	buf[1] = 0;
-	return concat(buf, 1);
-}
-
-unsigned char String::concat(unsigned char num)
-{
-	char buf[4];
-	itoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(int num)
-{
-	char buf[7];
-	itoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(unsigned int num)
-{
-	char buf[6];
-	utoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(long num)
-{
-	char buf[12];
-	ltoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(unsigned long num)
-{
-	char buf[11];
-	ultoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-/*********************************************/
-/*  Concatenate                              */
-/*********************************************/
-
-StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, char c)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(c)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, int num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, long num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-/*********************************************/
-/*  Comparison                               */
-/*********************************************/
-
-int String::compareTo(const String &s) const
-{
-	if (!buffer || !s.buffer) {
-		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
-		if (buffer && len > 0) return *(unsigned char *)buffer;
-		return 0;
-	}
-	return strcmp(buffer, s.buffer);
-}
-
-unsigned char String::equals(const String &s2) const
-{
-	return (len == s2.len && compareTo(s2) == 0);
-}
-
-unsigned char String::equals(const char *cstr) const
-{
-	if (len == 0) return (cstr == NULL || *cstr == 0);
-	if (cstr == NULL) return buffer[0] == 0;
-	return strcmp(buffer, cstr) == 0;
-}
-
-unsigned char String::operator<(const String &rhs) const
-{
-	return compareTo(rhs) < 0;
-}
-
-unsigned char String::operator>(const String &rhs) const
-{
-	return compareTo(rhs) > 0;
-}
-
-unsigned char String::operator<=(const String &rhs) const
-{
-	return compareTo(rhs) <= 0;
-}
-
-unsigned char String::operator>=(const String &rhs) const
-{
-	return compareTo(rhs) >= 0;
-}
-
-unsigned char String::equalsIgnoreCase( const String &s2 ) const
-{
-	if (this == &s2) return 1;
-	if (len != s2.len) return 0;
-	if (len == 0) return 1;
-	const char *p1 = buffer;
-	const char *p2 = s2.buffer;
-	while (*p1) {
-		if (tolower(*p1++) != tolower(*p2++)) return 0;
-	} 
-	return 1;
-}
-
-unsigned char String::startsWith( const String &s2 ) const
-{
-	if (len < s2.len) return 0;
-	return startsWith(s2, 0);
-}
-
-unsigned char String::startsWith( const String &s2, unsigned int offset ) const
-{
-	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
-	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
-}
-
-unsigned char String::endsWith( const String &s2 ) const
-{
-	if ( len < s2.len || !buffer || !s2.buffer) return 0;
-	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
-}
-
-/*********************************************/
-/*  Character Access                         */
-/*********************************************/
-
-char String::charAt(unsigned int loc) const
-{
-	return operator[](loc);
-}
-
-void String::setCharAt(unsigned int loc, char c) 
-{
-	if (loc < len) buffer[loc] = c;
-}
-
-char & String::operator[](unsigned int index)
-{
-	static char dummy_writable_char;
-	if (index >= len || !buffer) {
-		dummy_writable_char = 0;
-		return dummy_writable_char;
-	}
-	return buffer[index];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-	if (index >= len || !buffer) return 0;
-	return buffer[index];
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
-{
-	if (!bufsize || !buf) return;
-	if (index >= len) {
-		buf[0] = 0;
-		return;
-	}
-	unsigned int n = bufsize - 1;
-	if (n > len - index) n = len - index;
-	strncpy((char *)buf, buffer + index, n);
-	buf[n] = 0;
-}
-
-/*********************************************/
-/*  Search                                   */
-/*********************************************/
-
-int String::indexOf(char c) const
-{
-	return indexOf(c, 0);
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-	if (fromIndex >= len) return -1;
-	const char* temp = strchr(buffer + fromIndex, ch);
-	if (temp == NULL) return -1;
-	return temp - buffer;
-}
-
-int String::indexOf(const String &s2) const
-{
-	return indexOf(s2, 0);
-}
-
-int String::indexOf(const String &s2, unsigned int fromIndex) const
-{
-	if (fromIndex >= len) return -1;
-	const char *found = strstr(buffer + fromIndex, s2.buffer);
-	if (found == NULL) return -1;
-	return found - buffer;
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-	return lastIndexOf(theChar, len - 1);
-}
-
-int String::lastIndexOf(char ch, unsigned int fromIndex) const
-{
-	if (fromIndex >= len) return -1;
-	char tempchar = buffer[fromIndex + 1];
-	buffer[fromIndex + 1] = '\0';
-	char* temp = strrchr( buffer, ch );
-	buffer[fromIndex + 1] = tempchar;
-	if (temp == NULL) return -1;
-	return temp - buffer;
-}
-
-int String::lastIndexOf(const String &s2) const
-{
-	return lastIndexOf(s2, len - s2.len);
-}
-
-int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
-{
-  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
-	if (fromIndex >= len) fromIndex = len - 1;
-	int found = -1;
-	for (char *p = buffer; p <= buffer + fromIndex; p++) {
-		p = strstr(p, s2.buffer);
-		if (!p) break;
-		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
-	}
-	return found;
-}
-
-String String::substring( unsigned int left ) const
-{
-	return substring(left, len);
-}
-
-String String::substring(unsigned int left, unsigned int right) const
-{
-	if (left > right) {
-		unsigned int temp = right;
-		right = left;
-		left = temp;
-	}
-	String out;
-	if (left > len) return out;
-	if (right > len) right = len;
-	char temp = buffer[right];  // save the replaced character
-	buffer[right] = '\0';	
-	out = buffer + left;  // pointer arithmetic
-	buffer[right] = temp;  //restore character
-	return out;
-}
-
-/*********************************************/
-/*  Modification                             */
-/*********************************************/
-
-void String::replace(char find, char replace)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		if (*p == find) *p = replace;
-	}
-}
-
-void String::replace(const String& find, const String& replace)
-{
-	if (len == 0 || find.len == 0) return;
-	int diff = replace.len - find.len;
-	char *readFrom = buffer;
-	char *foundAt;
-	if (diff == 0) {
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			memcpy(foundAt, replace.buffer, replace.len);
-			readFrom = foundAt + replace.len;
-		}
-	} else if (diff < 0) {
-		char *writeTo = buffer;
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			unsigned int n = foundAt - readFrom;
-			memcpy(writeTo, readFrom, n);
-			writeTo += n;
-			memcpy(writeTo, replace.buffer, replace.len);
-			writeTo += replace.len;
-			readFrom = foundAt + find.len;
-			len += diff;
-		}
-		strcpy(writeTo, readFrom);
-	} else {
-		unsigned int size = len; // compute size needed for result
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			readFrom = foundAt + find.len;
-			size += diff;
-		}
-		if (size == len) return;
-		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
-		int index = len - 1;
-		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
-			readFrom = buffer + index + find.len;
-			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
-			len += diff;
-			buffer[len] = 0;
-			memcpy(buffer + index, replace.buffer, replace.len);
-			index--;
-		}
-	}
-}
-
-void String::toLowerCase(void)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		*p = tolower(*p);
-	}
-}
-
-void String::toUpperCase(void)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		*p = toupper(*p);
-	}
-}
-
-void String::trim(void)
-{
-	if (!buffer || len == 0) return;
-	char *begin = buffer;
-	while (isspace(*begin)) begin++;
-	char *end = buffer + len - 1;
-	while (isspace(*end) && end >= begin) end--;
-	len = end + 1 - begin;
-	if (begin > buffer) memcpy(buffer, begin, len);
-	buffer[len] = 0;
-}
-
-/*********************************************/
-/*  Parsing / Conversion                     */
-/*********************************************/
-
-long String::toInt(void) const
-{
-	if (buffer) return atol(buffer);
-	return 0;
-}
-
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.h
deleted file mode 100644
index 947325e..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/WString.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  ...mostly rewritten by Paul Stoffregen...
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-  Copyright 2011, Paul Stoffregen, paul@pjrc.com
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_class_h
-#define String_class_h
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <avr/pgmspace.h>
-
-// When compiling programs with this class, the following gcc parameters
-// dramatically increase performance and memory (RAM) efficiency, typically
-// with little or no increase in code size.
-//     -felide-constructors
-//     -std=c++0x
-
-class __FlashStringHelper;
-#define F(string_literal) (reinterpret_cast<const __FlashStringHelper *>(PSTR(string_literal)))
-
-// An inherited class for holding the result of a concatenation.  These
-// result objects are assumed to be writable by subsequent concatenations.
-class StringSumHelper;
-
-// The string class
-class String
-{
-	// use a function pointer to allow for "if (s)" without the
-	// complications of an operator bool(). for more information, see:
-	// http://www.artima.com/cppsource/safebool.html
-	typedef void (String::*StringIfHelperType)() const;
-	void StringIfHelper() const {}
-
-public:
-	// constructors
-	// creates a copy of the initial value.
-	// if the initial value is null or invalid, or if memory allocation
-	// fails, the string will be marked as invalid (i.e. "if (s)" will
-	// be false).
-	String(const char *cstr = "");
-	String(const String &str);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	String(String &&rval);
-	String(StringSumHelper &&rval);
-	#endif
-	explicit String(char c);
-	explicit String(unsigned char, unsigned char base=10);
-	explicit String(int, unsigned char base=10);
-	explicit String(unsigned int, unsigned char base=10);
-	explicit String(long, unsigned char base=10);
-	explicit String(unsigned long, unsigned char base=10);
-	~String(void);
-
-	// memory management
-	// return true on success, false on failure (in which case, the string
-	// is left unchanged).  reserve(0), if successful, will validate an
-	// invalid string (i.e., "if (s)" will be true afterwards)
-	unsigned char reserve(unsigned int size);
-	inline unsigned int length(void) const {return len;}
-
-	// creates a copy of the assigned value.  if the value is null or
-	// invalid, or if the memory allocation fails, the string will be 
-	// marked as invalid ("if (s)" will be false).
-	String & operator = (const String &rhs);
-	String & operator = (const char *cstr);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	String & operator = (String &&rval);
-	String & operator = (StringSumHelper &&rval);
-	#endif
-
-	// concatenate (works w/ built-in types)
-	
-	// returns true on success, false on failure (in which case, the string
-	// is left unchanged).  if the argument is null or invalid, the 
-	// concatenation is considered unsucessful.  
-	unsigned char concat(const String &str);
-	unsigned char concat(const char *cstr);
-	unsigned char concat(char c);
-	unsigned char concat(unsigned char c);
-	unsigned char concat(int num);
-	unsigned char concat(unsigned int num);
-	unsigned char concat(long num);
-	unsigned char concat(unsigned long num);
-	
-	// if there's not enough memory for the concatenated value, the string
-	// will be left unchanged (but this isn't signalled in any way)
-	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
-	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
-	String & operator += (char c)			{concat(c); return (*this);}
-	String & operator += (unsigned char num)		{concat(num); return (*this);}
-	String & operator += (int num)			{concat(num); return (*this);}
-	String & operator += (unsigned int num)		{concat(num); return (*this);}
-	String & operator += (long num)			{concat(num); return (*this);}
-	String & operator += (unsigned long num)	{concat(num); return (*this);}
-
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, char c);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, int num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, long num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num);
-
-	// comparison (only works w/ Strings and "strings")
-	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
-	int compareTo(const String &s) const;
-	unsigned char equals(const String &s) const;
-	unsigned char equals(const char *cstr) const;
-	unsigned char operator == (const String &rhs) const {return equals(rhs);}
-	unsigned char operator == (const char *cstr) const {return equals(cstr);}
-	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
-	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
-	unsigned char operator <  (const String &rhs) const;
-	unsigned char operator >  (const String &rhs) const;
-	unsigned char operator <= (const String &rhs) const;
-	unsigned char operator >= (const String &rhs) const;
-	unsigned char equalsIgnoreCase(const String &s) const;
-	unsigned char startsWith( const String &prefix) const;
-	unsigned char startsWith(const String &prefix, unsigned int offset) const;
-	unsigned char endsWith(const String &suffix) const;
-
-	// character acccess
-	char charAt(unsigned int index) const;
-	void setCharAt(unsigned int index, char c);
-	char operator [] (unsigned int index) const;
-	char& operator [] (unsigned int index);
-	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
-	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
-		{getBytes((unsigned char *)buf, bufsize, index);}
-
-	// search
-	int indexOf( char ch ) const;
-	int indexOf( char ch, unsigned int fromIndex ) const;
-	int indexOf( const String &str ) const;
-	int indexOf( const String &str, unsigned int fromIndex ) const;
-	int lastIndexOf( char ch ) const;
-	int lastIndexOf( char ch, unsigned int fromIndex ) const;
-	int lastIndexOf( const String &str ) const;
-	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
-	String substring( unsigned int beginIndex ) const;
-	String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-
-	// modification
-	void replace(char find, char replace);
-	void replace(const String& find, const String& replace);
-	void toLowerCase(void);
-	void toUpperCase(void);
-	void trim(void);
-
-	// parsing/conversion
-	long toInt(void) const;
-
-protected:
-	char *buffer;	        // the actual char array
-	unsigned int capacity;  // the array length minus one (for the '\0')
-	unsigned int len;       // the String length (not counting the '\0')
-	unsigned char flags;    // unused, for future features
-protected:
-	void init(void);
-	void invalidate(void);
-	unsigned char changeBuffer(unsigned int maxStrLen);
-	unsigned char concat(const char *cstr, unsigned int length);
-
-	// copy and move
-	String & copy(const char *cstr, unsigned int length);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	void move(String &rhs);
-	#endif
-};
-
-class StringSumHelper : public String
-{
-public:
-	StringSumHelper(const String &s) : String(s) {}
-	StringSumHelper(const char *p) : String(p) {}
-	StringSumHelper(char c) : String(c) {}
-	StringSumHelper(unsigned char num) : String(num) {}
-	StringSumHelper(int num) : String(num) {}
-	StringSumHelper(unsigned int num) : String(num) {}
-	StringSumHelper(long num) : String(num) {}
-	StringSumHelper(unsigned long num) : String(num) {}
-};
-
-#endif  // __cplusplus
-#endif  // String_class_h
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/binary.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/main.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/main.cpp
deleted file mode 100644
index 3d4e079..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/main.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#include <Arduino.h>
-
-int main(void)
-{
-	init();
-
-#if defined(USBCON)
-	USBDevice.attach();
-#endif
-	
-	setup();
-    
-	for (;;) {
-		loop();
-		if (serialEventRun) serialEventRun();
-	}
-        
-	return 0;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.cpp b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.cpp
deleted file mode 100644
index 0f6d422..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-#include <new.h>
-
-void * operator new(size_t size)
-{
-  return malloc(size);
-}
-
-void operator delete(void * ptr)
-{
-  free(ptr);
-} 
-
-int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
-void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
-void __cxa_guard_abort (__guard *) {}; 
-
-void __cxa_pure_virtual(void) {};
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.h
deleted file mode 100644
index cd940ce..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/new.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* Header to define new/delete operators as they aren't provided by avr-gcc by default
-   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=59453 
- */
-
-#ifndef NEW_H
-#define NEW_H
-
-#include <stdlib.h>
-
-void * operator new(size_t size);
-void operator delete(void * ptr); 
-
-__extension__ typedef int __guard __attribute__((mode (__DI__)));
-
-extern "C" int __cxa_guard_acquire(__guard *);
-extern "C" void __cxa_guard_release (__guard *);
-extern "C" void __cxa_guard_abort (__guard *); 
-
-extern "C" void __cxa_pure_virtual(void);
-
-#endif
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring.c
deleted file mode 100644
index ac8bb6f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#include "wiring_private.h"
-
-// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
-// the overflow handler is called every 256 ticks.
-#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
-
-// the whole number of milliseconds per timer0 overflow
-#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
-
-// the fractional number of milliseconds per timer0 overflow. we shift right
-// by three to fit these numbers into a byte. (for the clock speeds we care
-// about - 8 and 16 MHz - this doesn't lose precision.)
-#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
-#define FRACT_MAX (1000 >> 3)
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_millis = 0;
-static unsigned char timer0_fract = 0;
-
-#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
-SIGNAL(TIM0_OVF_vect)
-#else
-SIGNAL(TIMER0_OVF_vect)
-#endif
-{
-	// copy these to local variables so they can be stored in registers
-	// (volatile variables must be read from memory on every access)
-	unsigned long m = timer0_millis;
-	unsigned char f = timer0_fract;
-
-	m += MILLIS_INC;
-	f += FRACT_INC;
-	if (f >= FRACT_MAX) {
-		f -= FRACT_MAX;
-		m += 1;
-	}
-
-	timer0_fract = f;
-	timer0_millis = m;
-	timer0_overflow_count++;
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of a write to timer0_millis)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m;
-	uint8_t oldSREG = SREG, t;
-	
-	cli();
-	m = timer0_overflow_count;
-#if defined(TCNT0)
-	t = TCNT0;
-#elif defined(TCNT0L)
-	t = TCNT0L;
-#else
-	#error TIMER 0 not defined
-#endif
-
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t < 255))
-		m++;
-#else
-	if ((TIFR & _BV(TOV0)) && (t < 255))
-		m++;
-#endif
-
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	uint16_t start = (uint16_t)micros();
-
-	while (ms > 0) {
-		if (((uint16_t)micros() - start) >= 1000) {
-			ms--;
-			start += 1000;
-		}
-	}
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
-void delayMicroseconds(unsigned int us)
-{
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-#if F_CPU >= 20000000L
-	// for the 20 MHz clock on rare Arduino boards
-
-	// for a one-microsecond delay, simply wait 2 cycle and return. The overhead
-	// of the function call yields a delay of exactly a one microsecond.
-	__asm__ __volatile__ (
-		"nop" "\n\t"
-		"nop"); //just waiting 2 cycle
-	if (--us == 0)
-		return;
-
-	// the following loop takes a 1/5 of a microsecond (4 cycles)
-	// per iteration, so execute it five times for each microsecond of
-	// delay requested.
-	us = (us<<2) + us; // x5 us
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-
-#elif F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-    
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-#if defined(TCCR0A) && defined(WGM01)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-#endif  
-
-	// set timer 0 prescale factor to 64
-#if defined(__AVR_ATmega128__)
-	// CPU specific: different values for the ATmega128
-	sbi(TCCR0, CS02);
-#elif defined(TCCR0) && defined(CS01) && defined(CS00)
-	// this combination is for the standard atmega8
-	sbi(TCCR0, CS01);
-	sbi(TCCR0, CS00);
-#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
-	// this combination is for the standard 168/328/1280/2560
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
-	// this combination is for the __AVR_ATmega645__ series
-	sbi(TCCR0A, CS01);
-	sbi(TCCR0A, CS00);
-#else
-	#error Timer 0 prescale factor 64 not set correctly
-#endif
-
-	// enable timer 0 overflow interrupt
-#if defined(TIMSK) && defined(TOIE0)
-	sbi(TIMSK, TOIE0);
-#elif defined(TIMSK0) && defined(TOIE0)
-	sbi(TIMSK0, TOIE0);
-#else
-	#error	Timer 0 overflow interrupt not set correctly
-#endif
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-#if defined(TCCR1B) && defined(CS11) && defined(CS10)
-	TCCR1B = 0;
-
-	// set timer 1 prescale factor to 64
-	sbi(TCCR1B, CS11);
-#if F_CPU >= 8000000L
-	sbi(TCCR1B, CS10);
-#endif
-#elif defined(TCCR1) && defined(CS11) && defined(CS10)
-	sbi(TCCR1, CS11);
-#if F_CPU >= 8000000L
-	sbi(TCCR1, CS10);
-#endif
-#endif
-	// put timer 1 in 8-bit phase correct pwm mode
-#if defined(TCCR1A) && defined(WGM10)
-	sbi(TCCR1A, WGM10);
-#elif defined(TCCR1)
-	#warning this needs to be finished
-#endif
-
-	// set timer 2 prescale factor to 64
-#if defined(TCCR2) && defined(CS22)
-	sbi(TCCR2, CS22);
-#elif defined(TCCR2B) && defined(CS22)
-	sbi(TCCR2B, CS22);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-	// configure timer 2 for phase correct pwm (8-bit)
-#if defined(TCCR2) && defined(WGM20)
-	sbi(TCCR2, WGM20);
-#elif defined(TCCR2A) && defined(WGM20)
-	sbi(TCCR2A, WGM20);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
-	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
-	sbi(TCCR3B, CS30);
-	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
-	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
-	sbi(TCCR4B, CS41);
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
-	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
-	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
-#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
-#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
-	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
-#endif
-#endif /* end timer4 block for ATMEGA1280/2560 and similar */	
-
-#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
-	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
-	sbi(TCCR5B, CS50);
-	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(ADCSRA)
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-#endif
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-#if defined(UCSRB)
-	UCSRB = 0;
-#elif defined(UCSR0B)
-	UCSR0B = 0;
-#endif
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_analog.c
deleted file mode 100644
index 23b01c6..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high;
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
-#elif defined(__AVR_ATmega32U4__)
-	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
-#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
-#else
-	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
-#endif
-	
-#if defined(__AVR_ATmega32U4__)
-	pin = analogPinToChannel(pin);
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#elif defined(ADCSRB) && defined(MUX5)
-	// the MUX5 bit of ADCSRB selects whether we're reading from channels
-	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#endif
-  
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-#if defined(ADMUX)
-	ADMUX = (analog_reference << 6) | (pin & 0x07);
-#endif
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-#if defined(ADCSRA) && defined(ADCL)
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low  = ADCL;
-	high = ADCH;
-#else
-	// we dont have an ADC, return 0
-	low  = 0;
-	high = 0;
-#endif
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	if (val == 0)
-	{
-		digitalWrite(pin, LOW);
-	}
-	else if (val == 255)
-	{
-		digitalWrite(pin, HIGH);
-	}
-	else
-	{
-		switch(digitalPinToTimer(pin))
-		{
-			// XXX fix needed for atmega8
-			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
-			case TIMER0A:
-				// connect pwm to pin on timer 0
-				sbi(TCCR0, COM00);
-				OCR0 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0A1)
-			case TIMER0A:
-				// connect pwm to pin on timer 0, channel A
-				sbi(TCCR0A, COM0A1);
-				OCR0A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0B1)
-			case TIMER0B:
-				// connect pwm to pin on timer 0, channel B
-				sbi(TCCR0A, COM0B1);
-				OCR0B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1A1)
-			case TIMER1A:
-				// connect pwm to pin on timer 1, channel A
-				sbi(TCCR1A, COM1A1);
-				OCR1A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1B1)
-			case TIMER1B:
-				// connect pwm to pin on timer 1, channel B
-				sbi(TCCR1A, COM1B1);
-				OCR1B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2) && defined(COM21)
-			case TIMER2:
-				// connect pwm to pin on timer 2
-				sbi(TCCR2, COM21);
-				OCR2 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2A1)
-			case TIMER2A:
-				// connect pwm to pin on timer 2, channel A
-				sbi(TCCR2A, COM2A1);
-				OCR2A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2B1)
-			case TIMER2B:
-				// connect pwm to pin on timer 2, channel B
-				sbi(TCCR2A, COM2B1);
-				OCR2B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3A1)
-			case TIMER3A:
-				// connect pwm to pin on timer 3, channel A
-				sbi(TCCR3A, COM3A1);
-				OCR3A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3B1)
-			case TIMER3B:
-				// connect pwm to pin on timer 3, channel B
-				sbi(TCCR3A, COM3B1);
-				OCR3B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3C1)
-			case TIMER3C:
-				// connect pwm to pin on timer 3, channel C
-				sbi(TCCR3A, COM3C1);
-				OCR3C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A)
-			case TIMER4A:
-				//connect pwm to pin on timer 4, channel A
-				sbi(TCCR4A, COM4A1);
-				#if defined(COM4A0)		// only used on 32U4
-				cbi(TCCR4A, COM4A0);
-				#endif
-				OCR4A = val;	// set pwm duty
-				break;
-			#endif
-			
-			#if defined(TCCR4A) && defined(COM4B1)
-			case TIMER4B:
-				// connect pwm to pin on timer 4, channel B
-				sbi(TCCR4A, COM4B1);
-				OCR4B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4C1)
-			case TIMER4C:
-				// connect pwm to pin on timer 4, channel C
-				sbi(TCCR4A, COM4C1);
-				OCR4C = val; // set pwm duty
-				break;
-			#endif
-				
-			#if defined(TCCR4C) && defined(COM4D1)
-			case TIMER4D:				
-				// connect pwm to pin on timer 4, channel D
-				sbi(TCCR4C, COM4D1);
-				#if defined(COM4D0)		// only used on 32U4
-				cbi(TCCR4C, COM4D0);
-				#endif
-				OCR4D = val;	// set pwm duty
-				break;
-			#endif
-
-							
-			#if defined(TCCR5A) && defined(COM5A1)
-			case TIMER5A:
-				// connect pwm to pin on timer 5, channel A
-				sbi(TCCR5A, COM5A1);
-				OCR5A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5B1)
-			case TIMER5B:
-				// connect pwm to pin on timer 5, channel B
-				sbi(TCCR5A, COM5B1);
-				OCR5B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5C1)
-			case TIMER5C:
-				// connect pwm to pin on timer 5, channel C
-				sbi(TCCR5A, COM5C1);
-				OCR5C = val; // set pwm duty
-				break;
-			#endif
-
-			case NOT_ON_TIMER:
-			default:
-				if (val < 128) {
-					digitalWrite(pin, LOW);
-				} else {
-					digitalWrite(pin, HIGH);
-				}
-		}
-	}
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_digital.c
deleted file mode 100644
index be323b1..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#define ARDUINO_MAIN
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg, *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-	out = portOutputRegister(port);
-
-	if (mode == INPUT) { 
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		*out &= ~bit;
-		SREG = oldSREG;
-	} else if (mode == INPUT_PULLUP) {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		*out |= bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg |= bit;
-		SREG = oldSREG;
-	}
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-// Mark Sproul:
-// - Removed inline. Save 170 bytes on atmega1280
-// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
-// - Added more #ifdefs, now compiles for atmega645
-//
-//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-//static inline void turnOffPWM(uint8_t timer)
-static void turnOffPWM(uint8_t timer)
-{
-	switch (timer)
-	{
-		#if defined(TCCR1A) && defined(COM1A1)
-		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
-		#endif
-		#if defined(TCCR1A) && defined(COM1B1)
-		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
-		#endif
-		
-		#if defined(TCCR2) && defined(COM21)
-		case  TIMER2:   cbi(TCCR2, COM21);      break;
-		#endif
-		
-		#if defined(TCCR0A) && defined(COM0A1)
-		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
-		#endif
-		
-		#if defined(TIMER0B) && defined(COM0B1)
-		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2A1)
-		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2B1)
-		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
-		#endif
-		
-		#if defined(TCCR3A) && defined(COM3A1)
-		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3B1)
-		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3C1)
-		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
-		#endif
-
-		#if defined(TCCR4A) && defined(COM4A1)
-		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
-		#endif					
-		#if defined(TCCR4A) && defined(COM4B1)
-		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4C1)
-		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
-		#endif			
-		#if defined(TCCR4C) && defined(COM4D1)
-		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
-		#endif			
-			
-		#if defined(TCCR5A)
-		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
-		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
-		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
-		#endif
-	}
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	uint8_t oldSREG = SREG;
-	cli();
-
-	if (val == LOW) {
-		*out &= ~bit;
-	} else {
-		*out |= bit;
-	}
-
-	SREG = oldSREG;
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	return LOW;
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_private.h
deleted file mode 100644
index f678265..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "Arduino.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-#define EXTERNAL_INT_3 3
-#define EXTERNAL_INT_4 4
-#define EXTERNAL_INT_5 5
-#define EXTERNAL_INT_6 6
-#define EXTERNAL_INT_7 7
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define EXTERNAL_NUM_INTERRUPTS 8
-#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-#define EXTERNAL_NUM_INTERRUPTS 3
-#elif defined(__AVR_ATmega32U4__)
-#define EXTERNAL_NUM_INTERRUPTS 4
-#else
-#define EXTERNAL_NUM_INTERRUPTS 2
-#endif
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 0d96886..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask) {
-		if (numloops++ == maxloops)
-			return 0;
-		width++;
-	}
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 20 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 21 + 16); 
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_shift.c
deleted file mode 100644
index cfe7867..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
-	uint8_t value = 0;
-	uint8_t i;
-
-	for (i = 0; i < 8; ++i) {
-		digitalWrite(clockPin, HIGH);
-		if (bitOrder == LSBFIRST)
-			value |= digitalRead(dataPin) << i;
-		else
-			value |= digitalRead(dataPin) << (7 - i);
-		digitalWrite(clockPin, LOW);
-	}
-	return value;
-}
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
-{
-	uint8_t i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/variants/standard/pins_arduino.h b/ArduinoAddons/Arduino_1.x.x/Sanguino/variants/standard/pins_arduino.h
deleted file mode 100644
index 499952d..0000000
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/variants/standard/pins_arduino.h
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-
-  Changelog
-  -----------
-  11/25/11  - ryan@ryanmsutton.com - Add pins for Sanguino 644P and 1284P
-  07/15/12  - ryan@ryanmsutton.com - Updated for arduino0101
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-#define TIMER3A 8
-#define TIMER3B 9
-#define TIMER3C 10
-#define TIMER4A 11
-#define TIMER4B 12
-#define TIMER4C 13
-#define TIMER5A 14
-#define TIMER5B 15
-#define TIMER5C 16
-
-const static uint8_t SS   = 4;
-const static uint8_t MOSI = 5;
-const static uint8_t MISO = 6;
-const static uint8_t SCK  = 7;
-
-static const uint8_t SDA = 17;
-static const uint8_t SCL = 16;
-static const uint8_t LED_BUILTIN = 13;
-
-static const uint8_t A0 = 31;
-static const uint8_t A1 = 30;
-static const uint8_t A2 = 29;
-static const uint8_t A3 = 28;
-static const uint8_t A4 = 27;
-static const uint8_t A5 = 26;
-static const uint8_t A6 = 25;
-static const uint8_t A7 = 24;
-
-// On the ATmega1280, the addresses of some of the port registers are
-// greater than 255, so we can't store them in uint8_t's.
-// extern const uint16_t PROGMEM port_to_mode_PGM[];
-// extern const uint16_t PROGMEM port_to_input_PGM[];
-// extern const uint16_t PROGMEM port_to_output_PGM[];
-
-// extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-// extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-// extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// ATMEL ATMEGA644P / SANGUINO
-//
-//                   +---\/---+
-//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-//             RST  9|        |32  AREF
-//             VCC 10|        |31  GND 
-//             GND 11|        |30  AVCC
-//           XTAL2 12|        |29  PC7 (D 23)
-//           XTAL1 13|        |28  PC6 (D 22)
-//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-//                   +--------+
-//
-#define NUM_DIGITAL_PINS            24
-#define NUM_ANALOG_INPUTS           8
-#define analogInputToDigitalPin(p)  ((p < 7) ? (p) + 24 : -1)
-
-#define digitalPinHasPWM(p)         ((p) == 3 || (p) == 4 || (p) == 12 || (p) == 13 || (p) == 14 || (p) == 15 )
-
-#define digitalPinToPCICR(p)    ( (((p) >= 0) && ((p) <= 31)) ? (&PCICR) : ((uint8_t *)0) )
-
-#define digitalPinToPCICRbit(p) ( (((p) >= 24) && ((p) <= 31)) ? 0 : \
-                                ( (((p) >=  0) && ((p) <=  7)) ? 1 : \
-                                ( (((p) >= 16) && ((p) <= 23)) ? 2 : \
-                                ( (((p) >=  8) && ((p) <= 15)) ? 3 : \
-                                0 ) ) ) )
-
-#define digitalPinToPCMSK(p)    ( (((p) >= 24) && ((p) <= 31)) ? (&PCMSK0) : \
-                                ( (((p) >=  0) && ((p) <=  7)) ? (&PCMSK1) : \
-                                ( (((p) >= 16) && ((p) <= 23)) ? (&PCMSK2) : \
-                                ( (((p) >=  8) && ((p) <= 15)) ? (&PCMSK3) : \
-                                ((uint8_t *)0) ) ) ) )
-
-
-#define digitalPinToPCMSKbit(p) ( (((p) >= 24) && ((p) <= 31)) ? (31 - (p)) : \
-                                ( (((p) >=  0) && ((p) <=  7)) ? (p) : \
-                                ( (((p) >= 16) && ((p) <= 23)) ? ((p) - 16) : \
-                                ( (((p) >=  8) && ((p) <= 15)) ? ((p) - 8) : \
-                                0 ) ) ) )
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-#define PE 5
-#define PF 6
-#define PG 7
-#define PH 8
-#define PJ 10
-#define PK 11
-#define PL 12
-
-#ifdef ARDUINO_MAIN
-// these arrays map port names (e.g. port B) to the
-// appropriate addresses for various functions (e.g. reading
-// and writing)
-const uint16_t PROGMEM port_to_mode_PGM[] =
-{
-        NOT_A_PORT,
-        (uint16_t) &DDRA,
-        (uint16_t) &DDRB,
-        (uint16_t) &DDRC,
-        (uint16_t) &DDRD,
-};
-
-const uint16_t PROGMEM port_to_output_PGM[] =
-{
-        NOT_A_PORT,
-        (uint16_t) &PORTA,
-        (uint16_t) &PORTB,
-        (uint16_t) &PORTC,
-        (uint16_t) &PORTD,
-};
-const uint16_t PROGMEM port_to_input_PGM[] =
-{
-        NOT_A_PORT,
-        (uint16_t) &PINA,
-        (uint16_t) &PINB,
-        (uint16_t) &PINC,
-        (uint16_t) &PIND,
-};
-const uint8_t PROGMEM digital_pin_to_port_PGM[] =
-{
-        PB, /* 0 */
-        PB,
-        PB,
-        PB,
-        PB,
-        PB,
-        PB,
-        PB,
-        PD, /* 8 */
-        PD,
-        PD,
-        PD,
-        PD,
-        PD,
-        PD,
-        PD,
-        PC, /* 16 */
-        PC,
-        PC,
-        PC,
-        PC,
-        PC,
-        PC,
-        PC,
-        PA, /* 24 */
-        PA,
-        PA,
-        PA,
-        PA,
-        PA,
-        PA,
-        PA  /* 31 */
-};
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
-{
-        _BV(0), /* 0, port B */
-        _BV(1),
-        _BV(2),
-        _BV(3),
-        _BV(4),
-        _BV(5),
-        _BV(6),
-        _BV(7),
-        _BV(0), /* 8, port D */
-        _BV(1),
-        _BV(2),
-        _BV(3),
-        _BV(4),
-        _BV(5),
-        _BV(6),
-        _BV(7),
-        _BV(0), /* 16, port C */
-        _BV(1),
-        _BV(2),
-        _BV(3),
-        _BV(4),
-        _BV(5),
-        _BV(6),
-        _BV(7),
-        _BV(7), /* 24, port A */
-        _BV(6),
-        _BV(5),
-        _BV(4),
-        _BV(3),
-        _BV(2),
-        _BV(1),
-        _BV(0)
-};
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
-{
-        NOT_ON_TIMER,   /* 0  - PB0 */
-        NOT_ON_TIMER,   /* 1  - PB1 */
-        NOT_ON_TIMER,   /* 2  - PB2 */
-        TIMER0A,        /* 3  - PB3 */
-        TIMER0B,                /* 4  - PB4 */
-        NOT_ON_TIMER,   /* 5  - PB5 */
-        NOT_ON_TIMER,   /* 6  - PB6 */
-        NOT_ON_TIMER,   /* 7  - PB7 */
-        NOT_ON_TIMER,   /* 8  - PD0 */
-        NOT_ON_TIMER,   /* 9  - PD1 */
-        NOT_ON_TIMER,   /* 10 - PD2 */
-        NOT_ON_TIMER,   /* 11 - PD3 */
-        TIMER1B,        /* 12 - PD4 */
-        TIMER1A,        /* 13 - PD5 */
-        TIMER2B,        /* 14 - PD6 */
-        TIMER2A,        /* 15 - PD7 */
-        NOT_ON_TIMER,   /* 16 - PC0 */
-        NOT_ON_TIMER,   /* 17 - PC1 */
-        NOT_ON_TIMER,   /* 18 - PC2 */
-        NOT_ON_TIMER,   /* 19 - PC3 */
-        NOT_ON_TIMER,   /* 20 - PC4 */
-        NOT_ON_TIMER,   /* 21 - PC5 */
-        NOT_ON_TIMER,   /* 22 - PC6 */
-        NOT_ON_TIMER,   /* 23 - PC7 */
-        NOT_ON_TIMER,   /* 24 - PA0 */
-        NOT_ON_TIMER,   /* 25 - PA1 */
-        NOT_ON_TIMER,   /* 26 - PA2 */
-        NOT_ON_TIMER,   /* 27 - PA3 */
-        NOT_ON_TIMER,   /* 28 - PA4 */
-        NOT_ON_TIMER,   /* 29 - PA5 */
-        NOT_ON_TIMER,   /* 30 - PA6 */
-        NOT_ON_TIMER   /* 31 - PA7 */
-};
-#endif
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/boards.txt b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/boards.txt
new file mode 100644
index 0000000..2bec14e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/boards.txt
@@ -0,0 +1,83 @@
+############################################################
+
+atmega644.name=Sanguino W/ ATmega644P
+
+atmega644.upload.protocol=stk500
+atmega644.upload.maximum_size=63488
+atmega644.upload.speed=57600
+
+atmega644.bootloader.low_fuses=0xFF
+atmega644.bootloader.high_fuses=0x9A
+atmega644.bootloader.extended_fuses=0xFF
+atmega644.bootloader.path=atmega
+atmega644.bootloader.file=ATmegaBOOT_168_atmega644p.hex
+#atmega644.bootloader.file=ATmegaBOOT_644P.hex
+atmega644.bootloader.unlock_bits=0x3F
+atmega644.bootloader.lock_bits=0x0F
+
+atmega644.build.mcu=atmega644p
+atmega644.build.f_cpu=16000000L
+atmega644.build.core=arduino
+atmega644.build.variant=standard
+##############################################################
+
+atmega12848m.name=Sanguino W/ ATmega1284p 8mhz
+
+atmega12848m.upload.protocol=stk500
+atmega12848m.upload.maximum_size=131072
+atmega12848m.upload.speed=19200
+
+atmega1284.bootloader.low_fuses=0xD6
+atmega1284.bootloader.high_fuses=0xDA
+atmega1284.bootloader.extended_fuses=0xFD
+atmega12848m.bootloader.path=atmega
+atmega12848m.bootloader.file=ATmegaBOOT_168_atmega1284p_8m.hex
+atmega12848m.bootloader.unlock_bits=0x3F
+atmega12848m.bootloader.lock_bits=0x0F
+
+atmega12848m.build.mcu=atmega1284p
+atmega12848m.build.f_cpu=8000000L
+atmega12848m.build.core=arduino
+atmega12848m.build.variant=standard
+
+##############################################################
+
+atmega1284.name=Sanguino W/ ATmega1284p 16mhz
+
+atmega1284.upload.protocol=stk500
+atmega1284.upload.maximum_size=131072
+atmega1284.upload.speed=57600
+
+atmega1284.bootloader.low_fuses=0xD6
+atmega1284.bootloader.high_fuses=0xDA
+atmega1284.bootloader.extended_fuses=0xFD
+atmega1284.bootloader.path=atmega
+atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
+atmega1284.bootloader.unlock_bits=0x3F
+atmega1284.bootloader.lock_bits=0x0F
+
+atmega1284.build.mcu=atmega1284p
+atmega1284.build.f_cpu=16000000L
+atmega1284.build.core=arduino
+atmega1284.build.variant=standard
+##############################################################
+
+atmega1284m.name=Sanguino W/ ATmega1284p 20mhz
+
+atmega1284m.upload.protocol=stk500
+atmega1284m.upload.maximum_size=131072
+atmega1284m.upload.speed=57600
+
+atmega1284m.bootloader.low_fuses=0xD6
+atmega1284m.bootloader.high_fuses=0xDA
+atmega1284m.bootloader.extended_fuses=0xFD
+atmega1284m.bootloader.path=atmega
+atmega1284m.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
+atmega1284m.bootloader.unlock_bits=0x3F
+atmega1284m.bootloader.lock_bits=0x0F
+
+atmega1284m.build.mcu=atmega1284p
+atmega1284m.build.f_cpu=20000000L
+atmega1284m.build.core=arduino
+atmega1284m.build.variant=standard
+#
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c
new file mode 100644
index 0000000..1df3f03
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168.c
@@ -0,0 +1,1071 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega8, ATmega128 and ATmega168           */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/*                                                        */
+/* 20090308: integrated Mega changes into main bootloader */
+/*           source by D. Mellis                          */
+/* 20080930: hacked for Arduino Mega (with the 1280       */
+/*           processor, backwards compatible)             */
+/*           by D. Cuartielles                            */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <util/delay.h>
+
+/* the current avr-libc eeprom functions do not support the ATmega168 */
+/* own eeprom write/read functions are used instead */
+#if !defined(__AVR_ATmega168__) || !defined(__AVR_ATmega328P__)
+#include <avr/eeprom.h>
+#endif
+
+/* Use the F_CPU defined in Makefile */
+
+/* 20060803: hacked by DojoCorp */
+/* 20070626: hacked by David A. Mellis to decrease waiting time for auto-reset */
+/* set the waiting time for the bootloader */
+/* get this from the Makefile instead */
+/* #define MAX_TIME_COUNT (F_CPU>>4) */
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20060803: hacked by DojoCorp */
+//#define BAUD_RATE   115200
+#ifndef BAUD_RATE
+#define BAUD_RATE   19200
+#endif
+
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+
+/* Adjust to suit whatever pin your hardware uses to enter the bootloader */
+/* ATmega128 has two UARTS so two pins are used to enter bootloader and select UART */
+/* ATmega1280 has four UARTS, but for Arduino Mega, we will only use RXD0 to get code */
+/* BL0... means UART0, BL1... means UART1 */
+#ifdef __AVR_ATmega128__
+#define BL_DDR  DDRF
+#define BL_PORT PORTF
+#define BL_PIN  PINF
+#define BL0     PINF7
+#define BL1     PINF6
+#elif defined __AVR_ATmega1280__ 
+/* we just don't do anything for the MEGA and enter bootloader on reset anyway*/
+#elif defined __AVR_ATmega1284P_ || defined __AVR_ATmega644P__
+
+#else
+/* other ATmegas have only one UART, so only one pin is defined to enter bootloader */
+#define BL_DDR  DDRD
+#define BL_PORT PORTD
+#define BL_PIN  PIND
+#define BL      PIND6
+#endif
+
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#if defined __AVR_ATmega128__ || defined __AVR_ATmega1280__
+/* Onboard LED is connected to pin PB7 (e.g. Crumb128, PROBOmega128, Savvy128, Arduino Mega) */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB7
+#elif defined __AVR_ATmega1284P__ || defined __AVR_ATmega644P__
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+#else
+/* Onboard LED is connected to pin PB5 in Arduino NG, Diecimila, and Duomilanuove */ 
+/* other boards like e.g. Crumb8, Crumb168 are using PB2 */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB5
+#endif
+
+
+/* monitor functions will only be compiled when using ATmega128, due to bootblock size constraints */
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
+#define MONITOR 1
+#endif
+
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+
+#if defined __AVR_ATmega1280__
+#define SIG2	0x97
+#define SIG3	0x03
+#define PAGE_SIZE	0x80U	//128 words
+
+#elif defined __AVR_ATmega1284P__
+#define SIG2	0x97
+#define SIG3	0x05
+#define PAGE_SIZE	0x080U   //128 words
+
+#elif defined __AVR_ATmega1281__
+#define SIG2	0x97
+#define SIG3	0x04
+#define PAGE_SIZE	0x80U	//128 words
+
+#elif defined __AVR_ATmega644P__
+#define SIG2    0x96
+#define SIG3    0x0A
+#define PAGE_SIZE       0x080U   //128 words
+
+#elif defined __AVR_ATmega128__
+#define SIG2	0x97
+#define SIG3	0x02
+#define PAGE_SIZE	0x80U	//128 words
+
+#elif defined __AVR_ATmega64__
+#define SIG2	0x96
+#define SIG3	0x02
+#define PAGE_SIZE	0x80U	//128 words
+
+#elif defined __AVR_ATmega32__
+#define SIG2	0x95
+#define SIG3	0x02
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega16__
+#define SIG2	0x94
+#define SIG3	0x03
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega8__
+#define SIG2	0x93
+#define SIG3	0x07
+#define PAGE_SIZE	0x20U	//32 words
+
+#elif defined __AVR_ATmega88__
+#define SIG2	0x93
+#define SIG3	0x0a
+#define PAGE_SIZE	0x20U	//32 words
+
+#elif defined __AVR_ATmega168__
+#define SIG2	0x94
+#define SIG3	0x06
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega328P__
+#define SIG2	0x95
+#define SIG3	0x0F
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega162__
+#define SIG2	0x94
+#define SIG3	0x04
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega163__
+#define SIG2	0x94
+#define SIG3	0x02
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega169__
+#define SIG2	0x94
+#define SIG3	0x05
+#define PAGE_SIZE	0x40U	//64 words
+
+#elif defined __AVR_ATmega8515__
+#define SIG2	0x93
+#define SIG3	0x06
+#define PAGE_SIZE	0x20U	//32 words
+
+#elif defined __AVR_ATmega8535__
+#define SIG2	0x93
+#define SIG3	0x08
+#define PAGE_SIZE	0x20U	//32 words
+#endif
+
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union {
+	uint16_t word;
+	uint8_t  byte[2];
+} address;
+
+union length_union {
+	uint16_t word;
+	uint8_t  byte[2];
+} length;
+
+struct flags_struct {
+	unsigned eeprom : 1;
+	unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+uint8_t address_high;
+
+uint8_t pagesz=0x80;
+
+uint8_t i;
+uint8_t bootuart = 0;
+
+uint8_t error_count = 0;
+
+void (*app_start)(void) = 0x0000;
+
+
+/* main program starts here */
+int main(void)
+{
+	uint8_t ch,ch2;
+	uint16_t w;
+
+#ifdef WATCHDOG_MODS
+	ch = MCUSR;
+	MCUSR = 0;
+
+	WDTCSR |= _BV(WDCE) | _BV(WDE);
+	WDTCSR = 0;
+
+	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+	if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
+		app_start();  // skip bootloader
+#else
+	asm volatile("nop\n\t");
+#endif
+
+	/* set pin direction for bootloader pin and enable pullup */
+	/* for ATmega128, two pins need to be initialized */
+#ifdef __AVR_ATmega128__
+	BL_DDR &= ~_BV(BL0);
+	BL_DDR &= ~_BV(BL1);
+	BL_PORT |= _BV(BL0);
+	BL_PORT |= _BV(BL1);
+#else
+	/* We run the bootloader regardless of the state of this pin.  Thus, don't
+	put it in a different state than the other pins.  --DAM, 070709
+	This also applies to Arduino Mega -- DC, 080930
+	BL_DDR &= ~_BV(BL);
+	BL_PORT |= _BV(BL);
+	*/
+#endif
+
+
+#ifdef __AVR_ATmega128__
+	/* check which UART should be used for booting */
+	if(bit_is_clear(BL_PIN, BL0)) {
+		bootuart = 1;
+	}
+	else if(bit_is_clear(BL_PIN, BL1)) {
+		bootuart = 2;
+	}
+#endif
+
+#if defined __AVR_ATmega1280__  || defined __AVR_ATmega1284P__ || defined __AVR_ATmega644P__
+	/* the mega1280 chip has four serial ports ... we could eventually use any of them, or not? */
+	/* however, we don't wanna confuse people, to avoid making a mess, we will stick to RXD0, TXD0 */
+	bootuart = 1;
+#endif
+
+	/* check if flash is programmed already, if not start bootloader anyway */
+	if(pgm_read_byte_near(0x0000) != 0xFF) {
+
+#ifdef __AVR_ATmega128__
+	/* no UART was selected, start application */
+	if(!bootuart) {
+		app_start();
+	}
+#else
+	/* check if bootloader pin is set low */
+	/* we don't start this part neither for the m8, nor m168 */
+	//if(bit_is_set(BL_PIN, BL)) {
+	//      app_start();
+	//    }
+#endif
+	}
+
+#ifdef __AVR_ATmega128__    
+	/* no bootuart was selected, default to uart 0 */
+	if(!bootuart) {
+		bootuart = 1;
+	}
+#endif
+
+
+	/* initialize UART(s) depending on CPU defined */
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)  || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	if(bootuart == 1) {
+		UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+		UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+		UCSR0A = 0x00;
+		UCSR0C = 0x06;
+		UCSR0B = _BV(TXEN0)|_BV(RXEN0);
+	}
+	if(bootuart == 2) {
+		UBRR1L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+		UBRR1H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+		UCSR1A = 0x00;
+		UCSR1C = 0x06;
+		UCSR1B = _BV(TXEN1)|_BV(RXEN1);
+	}
+#elif defined __AVR_ATmega163__
+	UBRR = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+	UBRRHI = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+	UCSRA = 0x00;
+	UCSRB = _BV(TXEN)|_BV(RXEN);	
+#elif defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__)
+
+#ifdef DOUBLE_SPEED
+	UCSR0A = (1<<U2X0); //Double speed mode USART0
+	UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*8L)-1);
+	UBRR0H = (F_CPU/(BAUD_RATE*8L)-1) >> 8;
+#else
+	UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+	UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+#endif
+
+	UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+	UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+	/* Enable internal pull-up resistor on pin D0 (RX), in order
+	to supress line noise that prevents the bootloader from
+	timing out (DAM: 20070509) */
+	DDRD &= ~_BV(PIND0);
+	PORTD |= _BV(PIND0);
+#elif defined __AVR_ATmega8__
+	/* m8 */
+	UBRRH = (((F_CPU/BAUD_RATE)/16)-1)>>8; 	// set baud rate
+	UBRRL = (((F_CPU/BAUD_RATE)/16)-1);
+	UCSRB = (1<<RXEN)|(1<<TXEN);  // enable Rx & Tx
+	UCSRC = (1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);  // config USART; 8N1
+#else
+	/* m16,m32,m169,m8515,m8535 */
+	UBRRL = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+	UBRRH = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+	UCSRA = 0x00;
+	UCSRC = 0x06;
+	UCSRB = _BV(TXEN)|_BV(RXEN);
+#endif
+
+#if defined __AVR_ATmega1280__
+	/* Enable internal pull-up resistor on pin D0 (RX), in order
+	to supress line noise that prevents the bootloader from
+	timing out (DAM: 20070509) */
+	/* feature added to the Arduino Mega --DC: 080930 */
+	DDRE &= ~_BV(PINE0);
+	PORTE |= _BV(PINE0);
+#endif
+
+
+	/* set LED pin as output */
+	LED_DDR |= _BV(LED);
+
+
+	/* flash onboard LED to signal entering of bootloader */
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	// 4x for UART0, 5x for UART1
+	flash_led(NUM_LED_FLASHES + bootuart);
+#else
+	flash_led(NUM_LED_FLASHES);
+#endif
+
+	/* 20050803: by DojoCorp, this is one of the parts provoking the
+		 system to stop listening, cancelled from the original */
+	//putch('\0');
+
+	/* forever loop */
+	for (;;) {
+
+	/* get character from UART */
+	ch = getch();
+
+	/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+	/* Hello is anyone home ? */ 
+	if(ch=='0') {
+		nothing_response();
+	}
+
+
+	/* Request programmer ID */
+	/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+	/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+	else if(ch=='1') {
+		if (getch() == ' ') {
+			putch(0x14);
+			putch('A');
+			putch('V');
+			putch('R');
+			putch(' ');
+			putch('I');
+			putch('S');
+			putch('P');
+			putch(0x10);
+		} else {
+			if (++error_count == MAX_ERROR_COUNT)
+				app_start();
+		}
+	}
+
+
+	/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+	else if(ch=='@') {
+		ch2 = getch();
+		if (ch2>0x85) getch();
+		nothing_response();
+	}
+
+
+	/* AVR ISP/STK500 board requests */
+	else if(ch=='A') {
+		ch2 = getch();
+		if(ch2==0x80) byte_response(HW_VER);		// Hardware version
+		else if(ch2==0x81) byte_response(SW_MAJOR);	// Software major version
+		else if(ch2==0x82) byte_response(SW_MINOR);	// Software minor version
+		else if(ch2==0x98) byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		else byte_response(0x00);				// Covers various unnecessary responses we don't care about
+	}
+
+
+	/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+	else if(ch=='B') {
+		getNch(20);
+		nothing_response();
+	}
+
+
+	/* Parallel programming stuff  DON'T CARE  */
+	else if(ch=='E') {
+		getNch(5);
+		nothing_response();
+	}
+
+
+	/* P: Enter programming mode  */
+	/* R: Erase device, don't care as we will erase one page at a time anyway.  */
+	else if(ch=='P' || ch=='R') {
+		nothing_response();
+	}
+
+
+	/* Leave programming mode  */
+	else if(ch=='Q') {
+		nothing_response();
+#ifdef WATCHDOG_MODS
+		// autoreset via watchdog (sneaky!)
+		WDTCSR = _BV(WDE);
+		while (1); // 16 ms
+#endif
+	}
+
+
+	/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+	/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+	/* This might explain why little endian was used here, big endian used everywhere else.  */
+	else if(ch=='U') {
+		address.byte[0] = getch();
+		address.byte[1] = getch();
+		nothing_response();
+	}
+
+
+	/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+	else if(ch=='V') {
+		if (getch() == 0x30) {
+			getch();
+			ch = getch();
+			getch();
+			if (ch == 0) {
+				byte_response(SIG1);
+			} else if (ch == 1) {
+				byte_response(SIG2); 
+			} else {
+				byte_response(SIG3);
+			} 
+		} else {
+			getNch(3);
+			byte_response(0x00);
+		}
+	}
+
+
+	/* Write memory, length is big endian and is in bytes  */
+	else if(ch=='d') {
+		length.byte[1] = getch();
+		length.byte[0] = getch();
+		flags.eeprom = 0;
+		if (getch() == 'E') flags.eeprom = 1;
+		for (w=0;w<length.word;w++) {
+			buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
+		}
+		if (getch() == ' ') {
+			if (flags.eeprom) {		                //Write to EEPROM one byte at a time
+				address.word <<= 1;
+				for(w=0;w<length.word;w++) {
+#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
+					while(EECR & (1<<EEPE));
+					EEAR = (uint16_t)(void *)address.word;
+					EEDR = buff[w];
+					EECR |= (1<<EEMPE);
+					EECR |= (1<<EEPE);
+#else
+					eeprom_write_byte((void *)address.word,buff[w]);
+#endif
+					address.word++;
+				}			
+			}
+			else {					        //Write to FLASH one page at a time
+				if (address.byte[1]>127) address_high = 0x01;	//Only possible with m128, m256 will need 3rd address byte. FIXME
+				else address_high = 0x00;
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) 
+				RAMPZ = address_high;
+#endif
+				address.word = address.word << 1;	        //address * 2 -> byte location
+				/* if ((length.byte[0] & 0x01) == 0x01) length.word++;	//Even up an odd number of bytes */
+				if ((length.byte[0] & 0x01)) length.word++;	//Even up an odd number of bytes
+				cli();					//Disable interrupts, just to be sure
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+				while(bit_is_set(EECR,EEPE));			//Wait for previous EEPROM writes to complete
+#else
+				while(bit_is_set(EECR,EEWE));			//Wait for previous EEPROM writes to complete
+#endif
+				asm volatile(
+					 "clr	r17		\n\t"	//page_word_count
+					 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+					 "lds	r31,address+1	\n\t"
+					 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+					 "ldi	r29,hi8(buff)	\n\t"
+					 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+					 "lds	r25,length+1	\n\t"
+					 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+					 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+					 "brne	no_page_erase	\n\t"						 
+					 "wait_spm1:		\n\t"
+					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+					 "andi	r16,1           \n\t"
+					 "cpi	r16,1           \n\t"
+					 "breq	wait_spm1       \n\t"
+					 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+					 "sts	%0,r16		\n\t"
+					 "spm			\n\t"							 
+#ifdef __AVR_ATmega163__
+					 ".word 0xFFFF		\n\t"
+					 "nop			\n\t"
+#endif
+					 "wait_spm2:		\n\t"
+					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+					 "andi	r16,1           \n\t"
+					 "cpi	r16,1           \n\t"
+					 "breq	wait_spm2       \n\t"									 
+
+					 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+					 "sts	%0,r16		\n\t"						 			 
+					 "spm			\n\t"
+#ifdef __AVR_ATmega163__
+					 ".word 0xFFFF		\n\t"
+					 "nop			\n\t"
+#endif
+					 "no_page_erase:		\n\t"							 
+					 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+					 "ld	r1,Y+		\n\t"							 
+								 
+					 "wait_spm3:		\n\t"
+					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+					 "andi	r16,1           \n\t"
+					 "cpi	r16,1           \n\t"
+					 "breq	wait_spm3       \n\t"
+					 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+					 "sts	%0,r16		\n\t"
+					 "spm			\n\t"
+								 
+					 "inc	r17		\n\t"	//page_word_count++
+					 "cpi r17,%1	        \n\t"
+					 "brlo	same_page	\n\t"	//Still same page in FLASH
+					 "write_page:		\n\t"
+					 "clr	r17		\n\t"	//New page, write current one first
+					 "wait_spm4:		\n\t"
+					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+					 "andi	r16,1           \n\t"
+					 "cpi	r16,1           \n\t"
+					 "breq	wait_spm4       \n\t"
+#ifdef __AVR_ATmega163__
+					 "andi	r30,0x80	\n\t"	// m163 requires Z6:Z1 to be zero during page write
+#endif							 							 
+					 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+					 "sts	%0,r16		\n\t"
+					 "spm			\n\t"
+#ifdef __AVR_ATmega163__
+					 ".word 0xFFFF		\n\t"
+					 "nop			\n\t"
+					 "ori	r30,0x7E	\n\t"	// recover Z6:Z1 state after page write (had to be zero during write)
+#endif
+					 "wait_spm5:		\n\t"
+					 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+					 "andi	r16,1           \n\t"
+					 "cpi	r16,1           \n\t"
+					 "breq	wait_spm5       \n\t"									 
+					 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+					 "sts	%0,r16		\n\t"						 			 
+					 "spm			\n\t"					 		 
+#ifdef __AVR_ATmega163__
+					 ".word 0xFFFF		\n\t"
+					 "nop			\n\t"
+#endif
+					 "same_page:		\n\t"							 
+					 "adiw	r30,2		\n\t"	//Next word in FLASH
+					 "sbiw	r24,2		\n\t"	//length-2
+					 "breq	final_write	\n\t"	//Finished
+					 "rjmp	length_loop	\n\t"
+					 "final_write:		\n\t"
+					 "cpi	r17,0		\n\t"
+					 "breq	block_done	\n\t"
+					 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+					 "rjmp	write_page	\n\t"
+					 "block_done:		\n\t"
+					 "clr	__zero_reg__	\n\t"	//restore zero register
+#if defined __AVR_ATmega168__  || __AVR_ATmega328P__ || __AVR_ATmega128__ || __AVR_ATmega1280__ || __AVR_ATmega1281__ || __AVR_ATmega1284P__ || __AVR_ATmega644P__
+					 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+#else
+					 : "=m" (SPMCR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+#endif
+					 );
+				/* Should really add a wait for RWW section to be enabled, don't actually need it since we never */
+				/* exit the bootloader without a power cycle anyhow */
+			}
+			putch(0x14);
+			putch(0x10);
+		} else {
+			if (++error_count == MAX_ERROR_COUNT)
+				app_start();
+		}		
+	}
+
+
+	/* Read memory block mode, length is big endian.  */
+	else if(ch=='t') {
+		length.byte[1] = getch();
+		length.byte[0] = getch();
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+		if (address.word>0x7FFF) flags.rampz = 1;		// No go with m256, FIXME
+		else flags.rampz = 0;
+#endif
+		address.word = address.word << 1;	        // address * 2 -> byte location
+		if (getch() == 'E') flags.eeprom = 1;
+		else flags.eeprom = 0;
+		if (getch() == ' ') {		                // Command terminator
+			putch(0x14);
+			for (w=0;w < length.word;w++) {		        // Can handle odd and even lengths okay
+				if (flags.eeprom) {	                        // Byte access EEPROM read
+#if defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
+					while(EECR & (1<<EEPE));
+					EEAR = (uint16_t)(void *)address.word;
+					EECR |= (1<<EERE);
+					putch(EEDR);
+#else
+					putch(eeprom_read_byte((void *)address.word));
+#endif
+					address.word++;
+				}
+				else {
+
+					if (!flags.rampz) putch(pgm_read_byte_near(address.word));
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) 
+					else putch(pgm_read_byte_far(address.word + 0x10000));
+					// Hmmmm, yuck  FIXME when m256 arrvies
+#endif
+					address.word++;
+				}
+			}
+			putch(0x10);
+		}
+	}
+
+
+	/* Get device signature bytes  */
+	else if(ch=='u') {
+		if (getch() == ' ') {
+			putch(0x14);
+			putch(SIG1);
+			putch(SIG2);
+			putch(SIG3);
+			putch(0x10);
+		} else {
+			if (++error_count == MAX_ERROR_COUNT)
+				app_start();
+		}
+	}
+
+
+	/* Read oscillator calibration byte */
+	else if(ch=='v') {
+		byte_response(0x00);
+	}
+
+
+#if defined MONITOR 
+
+	/* here come the extended monitor commands by Erik Lins */
+
+	/* check for three times exclamation mark pressed */
+	else if(ch=='!') {
+		ch = getch();
+		if(ch=='!') {
+		ch = getch();
+		if(ch=='!') {
+			PGM_P welcome = "";
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
+			uint16_t extaddr;
+#endif
+			uint8_t addrl, addrh;
+
+#ifdef CRUMB128
+			welcome = "ATmegaBOOT / Crumb128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
+#elif defined PROBOMEGA128
+			welcome = "ATmegaBOOT / PROBOmega128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
+#elif defined SAVVY128
+			welcome = "ATmegaBOOT / Savvy128 - (C) J.P.Kyle, E.Lins - 050815\n\r";
+#elif defined __AVR_ATmega1280__ 
+			welcome = "ATmegaBOOT / Arduino Mega - (C) Arduino LLC - 090930\n\r";
+#endif
+
+			/* turn on LED */
+			LED_DDR |= _BV(LED);
+			LED_PORT &= ~_BV(LED);
+
+			/* print a welcome message and command overview */
+			for(i=0; welcome[i] != '\0'; ++i) {
+				putch(welcome[i]);
+			}
+
+			/* test for valid commands */
+			for(;;) {
+				putch('\n');
+				putch('\r');
+				putch(':');
+				putch(' ');
+
+				ch = getch();
+				putch(ch);
+
+				/* toggle LED */
+				if(ch == 't') {
+					if(bit_is_set(LED_PIN,LED)) {
+						LED_PORT &= ~_BV(LED);
+						putch('1');
+					} else {
+						LED_PORT |= _BV(LED);
+						putch('0');
+					}
+				} 
+
+				/* read byte from address */
+				else if(ch == 'r') {
+					ch = getch(); putch(ch);
+					addrh = gethex();
+					addrl = gethex();
+					putch('=');
+					ch = *(uint8_t *)((addrh << 8) + addrl);
+					puthex(ch);
+				}
+
+				/* write a byte to address  */
+				else if(ch == 'w') {
+					ch = getch(); putch(ch);
+					addrh = gethex();
+					addrl = gethex();
+					ch = getch(); putch(ch);
+					ch = gethex();
+					*(uint8_t *)((addrh << 8) + addrl) = ch;
+				}
+
+				/* read from uart and echo back */
+				else if(ch == 'u') {
+					for(;;) {
+						putch(getch());
+					}
+				}
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
+				/* external bus loop  */
+				else if(ch == 'b') {
+					putch('b');
+					putch('u');
+					putch('s');
+					MCUCR = 0x80;
+					XMCRA = 0;
+					XMCRB = 0;
+					extaddr = 0x1100;
+					for(;;) {
+						ch = *(volatile uint8_t *)extaddr;
+						if(++extaddr == 0) {
+							extaddr = 0x1100;
+						}
+					}
+				}
+#endif
+
+				else if(ch == 'j') {
+					app_start();
+				}
+
+			} /* end of monitor functions */
+
+		}
+		}
+	}
+	/* end of monitor */
+#endif
+	else if (++error_count == MAX_ERROR_COUNT) {
+		app_start();
+	}
+	} /* end of forever loop */
+
+}
+
+
+char gethexnib(void) {
+	char a;
+	a = getch(); putch(a);
+	if(a >= 'a') {
+		return (a - 'a' + 0x0a);
+	} else if(a >= '0') {
+		return(a - '0');
+	}
+	return a;
+}
+
+
+char gethex(void) {
+	return (gethexnib() << 4) + gethexnib();
+}
+
+
+void puthex(char ch) {
+	char ah;
+
+	ah = ch >> 4;
+	if(ah >= 0x0a) {
+		ah = ah - 0x0a + 'a';
+	} else {
+		ah += '0';
+	}
+	
+	ch &= 0x0f;
+	if(ch >= 0x0a) {
+		ch = ch - 0x0a + 'a';
+	} else {
+		ch += '0';
+	}
+	
+	putch(ah);
+	putch(ch);
+}
+
+
+void putch(char ch)
+{
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	if(bootuart == 1) {
+		while (!(UCSR0A & _BV(UDRE0)));
+		UDR0 = ch;
+	}
+	else if (bootuart == 2) {
+		while (!(UCSR1A & _BV(UDRE1)));
+		UDR1 = ch;
+	}
+#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
+	while (!(UCSR0A & _BV(UDRE0)));
+	UDR0 = ch;
+#else
+	/* m8,16,32,169,8515,8535,163 */
+	while (!(UCSRA & _BV(UDRE)));
+	UDR = ch;
+#endif
+}
+
+
+char getch(void)
+{
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	uint32_t count = 0;
+	if(bootuart == 1) {
+		while(!(UCSR0A & _BV(RXC0))) {
+			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+			/* HACKME:: here is a good place to count times*/
+			count++;
+			if (count > MAX_TIME_COUNT)
+				app_start();
+			}
+
+			return UDR0;
+		}
+	else if(bootuart == 2) {
+		while(!(UCSR1A & _BV(RXC1))) {
+			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+			/* HACKME:: here is a good place to count times*/
+			count++;
+			if (count > MAX_TIME_COUNT)
+				app_start();
+		}
+
+		return UDR1;
+	}
+	return 0;
+#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
+	uint32_t count = 0;
+	while(!(UCSR0A & _BV(RXC0))){
+		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+		/* HACKME:: here is a good place to count times*/
+		count++;
+		if (count > MAX_TIME_COUNT)
+			app_start();
+	}
+	return UDR0;
+#else
+	/* m8,16,32,169,8515,8535,163 */
+	uint32_t count = 0;
+	while(!(UCSRA & _BV(RXC))){
+		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+		/* HACKME:: here is a good place to count times*/
+		count++;
+		if (count > MAX_TIME_COUNT)
+			app_start();
+	}
+	return UDR;
+#endif
+}
+
+
+void getNch(uint8_t count)
+{
+	while(count--) {
+#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+		if(bootuart == 1) {
+			while(!(UCSR0A & _BV(RXC0)));
+			UDR0;
+		} 
+		else if(bootuart == 2) {
+			while(!(UCSR1A & _BV(RXC1)));
+			UDR1;
+		}
+#elif defined(__AVR_ATmega168__)  || defined(__AVR_ATmega328P__)
+		getch();
+#else
+		/* m8,16,32,169,8515,8535,163 */
+		/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+		//while(!(UCSRA & _BV(RXC)));
+		//UDR;
+		getch(); // need to handle time out
+#endif		
+	}
+}
+
+
+void byte_response(uint8_t val)
+{
+	if (getch() == ' ') {
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+	} else {
+		if (++error_count == MAX_ERROR_COUNT)
+			app_start();
+	}
+}
+
+
+void nothing_response(void)
+{
+	if (getch() == ' ') {
+		putch(0x14);
+		putch(0x10);
+	} else {
+		if (++error_count == MAX_ERROR_COUNT)
+			app_start();
+	}
+}
+
+void flash_led(uint8_t count)
+{
+	while (count--) {
+		LED_PORT |= _BV(LED);
+		_delay_ms(100);
+		LED_PORT &= ~_BV(LED);
+		_delay_ms(100);
+	}
+}
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex
new file mode 100644
index 0000000..a63dc8d
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p.hex
@@ -0,0 +1,130 @@
+:020000021000EC
+:10F000000C9446F80C9465F80C9465F80C9465F82B
+:10F010000C9465F80C9465F80C9465F80C9465F8FC
+:10F020000C9465F80C9465F80C9465F80C9465F8EC
+:10F030000C9465F80C9465F80C9465F80C9465F8DC
+:10F040000C9465F80C9465F80C9465F80C9465F8CC
+:10F050000C9465F80C9465F80C9465F80C9465F8BC
+:10F060000C9465F80C9465F80C9465F80C9465F8AC
+:10F070000C9465F80C9465F80C9465F80C9465F89C
+:10F080000C9465F80C9465F80C9465F811241FBE77
+:10F09000CFEFD0E4DEBFCDBF11E0A0E0B1E0E8EDFE
+:10F0A000F7EF01E00BBF02C007900D92A230B1074D
+:10F0B000D9F712E0A2E0B1E001C01D92AD30B10776
+:10F0C000E1F70E947EF90C94EAFB0C9400F8909111
+:10F0D0000201913019F0923041F008959091C000F2
+:10F0E00095FFFCCF8093C60008959091C80095FFCE
+:10F0F000FCCF8093CE0008951F93982F95959595FA
+:10F1000095959595905D182F1F701A304CF4105DF1
+:10F11000892F0E9467F8812F0E9467F81F91089538
+:10F12000195A892F0E9467F8812F0E9467F81F9152
+:10F130000895EF92FF920F931F9380910201813007
+:10F1400069F1823031F080E01F910F91FF90EF90D4
+:10F150000895EE24FF2487018091C80087FD17C021
+:10F160000894E11CF11C011D111D81E4E81682E4E4
+:10F17000F8068FE0080780E0180770F3E0910401BB
+:10F18000F091050109958091C80087FFE9CF809132
+:10F19000CE001F910F91FF90EF900895EE24FF2471
+:10F1A00087018091C00087FD17C00894E11CF11C05
+:10F1B000011D111D81E4E81682E4F8068FE00807BE
+:10F1C00080E0180770F3E0910401F09105010995C2
+:10F1D0008091C00087FFE9CF8091C6001F910F91F9
+:10F1E000FF90EF9008951F930E9499F8182F0E94A6
+:10F1F00067F8113634F410330CF01053812F1F913F
+:10F2000008951755812F1F9108951F930E94F3F8B9
+:10F21000182F0E94F3F81295107F810F1F91089507
+:10F2200020910201882339F0213031F0223061F041
+:10F2300081508823C9F708959091C00097FFFCCFB3
+:10F240009091C6008150F5CF9091C80097FFFCCFF8
+:10F250009091CE008150EDCF1F93182F0E9499F806
+:10F26000803281F0809103018F5F809303018530AC
+:10F2700011F01F910895E0910401F09105010995A5
+:10F280001F91089584E10E9467F8812F0E9467F81A
+:10F2900080E10E9467F8EDCF0E9499F8803271F00A
+:10F2A000809103018F5F80930301853009F00895F9
+:10F2B000E0910401F09105010995089584E10E940F
+:10F2C00067F880E10E9467F8089515C0289A2FEF2B
+:10F2D00031EE44E0215030404040E1F700C00000F2
+:10F2E00028982FEF31EE44E0215030404040E1F7C4
+:10F2F00000C000008150882349F70895EF92FF92E3
+:10F300000F931F93CF93DF93000081E0809302015E
+:10F3100080E18093C4001092C5001092C00086E086
+:10F320008093C20088E18093C100209A81E00E940E
+:10F3300065F90E9499F88033B1F18133B9F18034D5
+:10F3400009F454C0813409F45AC0823409F469C004
+:10F35000853409F46CC0803531F1823521F1813575
+:10F3600011F1853509F469C0863509F471C0843618
+:10F3700009F47AC0843709F4E1C0853709F43FC144
+:10F38000863709F44AC0809103018F5F809303019F
+:10F39000853079F6E0910401F091050109950E940C
+:10F3A00099F8803351F60E944CF9C3CF0E9499F826
+:10F3B000803249F784E10E9467F881E40E9467F88F
+:10F3C00086E50E9467F882E50E9467F880E20E9465
+:10F3D00067F889E40E9467F883E50E9467F880E592
+:10F3E0000E9467F880E10E9467F8A3CF0E9499F815
+:10F3F0008638C8F20E9499F80E944CF99ACF0E9470
+:10F4000099F8803809F414C1813809F415C182389B
+:10F4100009F416C1883909F407C180E00E942CF96B
+:10F4200088CF84E10E9410F90E944CF982CF85E0D8
+:10F430000E9410F90E944CF97CCF0E9499F88093A9
+:10F4400006010E9499F8809307010E944CF971CF40
+:10F450000E9499F8803309F405C183E00E9410F9F5
+:10F4600080E00E942CF965CF0E9499F880930902F0
+:10F470000E9499F88093080280910C028E7F8093FD
+:10F480000C020E9499F8853409F4FDC080910802AD
+:10F49000909109020097A1F068E0E62E61E0F62E57
+:10F4A00000E010E00E9499F8F70181937F010F5F5F
+:10F4B0001F4F80910802909109020817190790F3D5
+:10F4C0000E9499F8803209F05ECF80910C0280FF93
+:10F4D000ECC08091060190910701880F991F9093CD
+:10F4E000070180930601209108023091090221153D
+:10F4F0003105E9F048E0E42E41E0F42E00E010E0B0
+:10F50000F70161917F010E94DCFB809106019091DF
+:10F510000701019690930701809306010F5F1F4F2B
+:10F5200020910802309109020217130748F384E181
+:10F530000E9467F880E10E9467F8FBCE0E9499F86C
+:10F54000809309020E9499F8809308028091060135
+:10F550009091070197FDA3C020910C022D7F20936D
+:10F560000C02880F991F90930701809306010E9457
+:10F5700099F8853409F48DC080910C028E7F8093B8
+:10F580000C020E9499F8803209F0D3CE84E10E94E7
+:10F5900067F88091080290910902009709F440C031
+:10F5A00000E010E0809106019091070116C0FC0177
+:10F5B00084910E9467F8809106019091070101965D
+:10F5C00090930701809306010F5F1F4F209108025F
+:10F5D000309109020217130718F520910C0220FD43
+:10F5E00033C021FFE4CFA0E0B0E080509040AF4FA7
+:10F5F000BF4FABBFFC0187910E9467F8DCCF0E9430
+:10F6000099F8803209F0BFCE84E10E9467F88EE15C
+:10F610000E9467F887E90E9467F885E00E9467F812
+:10F6200080E10E9467F885CE83E00E942CF981CEAC
+:10F6300082E00E942CF97DCE81E00E942CF979CEE7
+:10F6400080E10E942CF975CE0E94D4FB0E9467F8DD
+:10F650008091060190910701019690930701809394
+:10F660000601B2CF0E9499F80E9499F8082F0E94D3
+:10F6700099F8002309F48BC0013009F48CC085E0AF
+:10F680000E942CF956CE80910C02816080930C026E
+:10F69000FDCE80910C02816080930C0272CF20918C
+:10F6A0000C02226020930C025CCF8091070187FD41
+:10F6B00076C010920B0280E08BBF80910601909182
+:10F6C0000701880F991F909307018093060180918D
+:10F6D000080280FF09C080910802909109020196FA
+:10F6E0009093090280930802F894F999FECF1127AC
+:10F6F000E0910601F0910701C8E0D1E08091080295
+:10F7000090910902103091F400915700017001307E
+:10F71000D9F303E000935700E8950091570001707A
+:10F720000130D9F301E100935700E8950990199051
+:10F730000091570001700130D9F301E000935700A8
+:10F74000E8951395103898F0112700915700017033
+:10F750000130D9F305E000935700E8950091570078
+:10F7600001700130D9F301E100935700E89532961A
+:10F77000029709F0C7CF103011F00296E5CF11249F
+:10F7800084E10E9467F880E10E9467F8D2CD8EE1A3
+:10F790000E942CF9CECD87E90E942CF9CACDF1E068
+:10F7A000F0930B0281E088CFF999FECF92BD81BD25
+:10F7B000F89A992780B50895262FF999FECF1FBA98
+:10F7C00092BD81BD20BD0FB6F894FA9AF99A0FBE8A
+:08F7D00001960895F894FFCFA3
+:02F7D8008000AF
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex
new file mode 100644
index 0000000..7f5f3f3
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega1284p_8m.hex
@@ -0,0 +1,130 @@
+:020000021000EC
+:10F000000C9446F80C9465F80C9465F80C9465F82B
+:10F010000C9465F80C9465F80C9465F80C9465F8FC
+:10F020000C9465F80C9465F80C9465F80C9465F8EC
+:10F030000C9465F80C9465F80C9465F80C9465F8DC
+:10F040000C9465F80C9465F80C9465F80C9465F8CC
+:10F050000C9465F80C9465F80C9465F80C9465F8BC
+:10F060000C9465F80C9465F80C9465F80C9465F8AC
+:10F070000C9465F80C9465F80C9465F80C9465F89C
+:10F080000C9465F80C9465F80C9465F811241FBE77
+:10F09000CFEFD0E4DEBFCDBF11E0A0E0B1E0E8EDFE
+:10F0A000F7EF01E00BBF02C007900D92A230B1074D
+:10F0B000D9F712E0A2E0B1E001C01D92AD30B10776
+:10F0C000E1F70E947EF90C94EAFB0C9400F8909111
+:10F0D0000201913019F0923041F008959091C000F2
+:10F0E00095FFFCCF8093C60008959091C80095FFCE
+:10F0F000FCCF8093CE0008951F93982F95959595FA
+:10F1000095959595905D182F1F701A304CF4105DF1
+:10F11000892F0E9467F8812F0E9467F81F91089538
+:10F12000195A892F0E9467F8812F0E9467F81F9152
+:10F130000895EF92FF920F931F9380910201813007
+:10F1400069F1823031F080E01F910F91FF90EF90D4
+:10F150000895EE24FF2487018091C80087FD17C021
+:10F160000894E11CF11C011D111D81E2E81681EAE1
+:10F17000F80687E0080780E0180770F3E0910401C3
+:10F18000F091050109958091C80087FFE9CF809132
+:10F19000CE001F910F91FF90EF900895EE24FF2471
+:10F1A00087018091C00087FD17C00894E11CF11C05
+:10F1B000011D111D81E2E81681EAF80687E00807C3
+:10F1C00080E0180770F3E0910401F09105010995C2
+:10F1D0008091C00087FFE9CF8091C6001F910F91F9
+:10F1E000FF90EF9008951F930E9499F8182F0E94A6
+:10F1F00067F8113634F410330CF01053812F1F913F
+:10F2000008951755812F1F9108951F930E94F3F8B9
+:10F21000182F0E94F3F81295107F810F1F91089507
+:10F2200020910201882339F0213031F0223061F041
+:10F2300081508823C9F708959091C00097FFFCCFB3
+:10F240009091C6008150F5CF9091C80097FFFCCFF8
+:10F250009091CE008150EDCF1F93182F0E9499F806
+:10F26000803281F0809103018F5F809303018530AC
+:10F2700011F01F910895E0910401F09105010995A5
+:10F280001F91089584E10E9467F8812F0E9467F81A
+:10F2900080E10E9467F8EDCF0E9499F8803271F00A
+:10F2A000809103018F5F80930301853009F00895F9
+:10F2B000E0910401F09105010995089584E10E940F
+:10F2C00067F880E10E9467F8089515C0289A2FEF2B
+:10F2D00030E742E0215030404040E1F700C00000FC
+:10F2E00028982FEF30E742E0215030404040E1F7CE
+:10F2F00000C000008150882349F70895EF92FF92E3
+:10F300000F931F93CF93DF93000081E0809302015E
+:10F3100089E18093C4001092C5001092C00086E07D
+:10F320008093C20088E18093C100209A81E00E940E
+:10F3300065F90E9499F88033B1F18133B9F18034D5
+:10F3400009F454C0813409F45AC0823409F469C004
+:10F35000853409F46CC0803531F1823521F1813575
+:10F3600011F1853509F469C0863509F471C0843618
+:10F3700009F47AC0843709F4E1C0853709F43FC144
+:10F38000863709F44AC0809103018F5F809303019F
+:10F39000853079F6E0910401F091050109950E940C
+:10F3A00099F8803351F60E944CF9C3CF0E9499F826
+:10F3B000803249F784E10E9467F881E40E9467F88F
+:10F3C00086E50E9467F882E50E9467F880E20E9465
+:10F3D00067F889E40E9467F883E50E9467F880E592
+:10F3E0000E9467F880E10E9467F8A3CF0E9499F815
+:10F3F0008638C8F20E9499F80E944CF99ACF0E9470
+:10F4000099F8803809F414C1813809F415C182389B
+:10F4100009F416C1883909F407C180E00E942CF96B
+:10F4200088CF84E10E9410F90E944CF982CF85E0D8
+:10F430000E9410F90E944CF97CCF0E9499F88093A9
+:10F4400006010E9499F8809307010E944CF971CF40
+:10F450000E9499F8803309F405C183E00E9410F9F5
+:10F4600080E00E942CF965CF0E9499F880930902F0
+:10F470000E9499F88093080280910C028E7F8093FD
+:10F480000C020E9499F8853409F4FDC080910802AD
+:10F49000909109020097A1F068E0E62E61E0F62E57
+:10F4A00000E010E00E9499F8F70181937F010F5F5F
+:10F4B0001F4F80910802909109020817190790F3D5
+:10F4C0000E9499F8803209F05ECF80910C0280FF93
+:10F4D000ECC08091060190910701880F991F9093CD
+:10F4E000070180930601209108023091090221153D
+:10F4F0003105E9F048E0E42E41E0F42E00E010E0B0
+:10F50000F70161917F010E94DCFB809106019091DF
+:10F510000701019690930701809306010F5F1F4F2B
+:10F5200020910802309109020217130748F384E181
+:10F530000E9467F880E10E9467F8FBCE0E9499F86C
+:10F54000809309020E9499F8809308028091060135
+:10F550009091070197FDA3C020910C022D7F20936D
+:10F560000C02880F991F90930701809306010E9457
+:10F5700099F8853409F48DC080910C028E7F8093B8
+:10F580000C020E9499F8803209F0D3CE84E10E94E7
+:10F5900067F88091080290910902009709F440C031
+:10F5A00000E010E0809106019091070116C0FC0177
+:10F5B00084910E9467F8809106019091070101965D
+:10F5C00090930701809306010F5F1F4F209108025F
+:10F5D000309109020217130718F520910C0220FD43
+:10F5E00033C021FFE4CFA0E0B0E080509040AF4FA7
+:10F5F000BF4FABBFFC0187910E9467F8DCCF0E9430
+:10F6000099F8803209F0BFCE84E10E9467F88EE15C
+:10F610000E9467F887E90E9467F885E00E9467F812
+:10F6200080E10E9467F885CE83E00E942CF981CEAC
+:10F6300082E00E942CF97DCE81E00E942CF979CEE7
+:10F6400080E10E942CF975CE0E94D4FB0E9467F8DD
+:10F650008091060190910701019690930701809394
+:10F660000601B2CF0E9499F80E9499F8082F0E94D3
+:10F6700099F8002309F48BC0013009F48CC085E0AF
+:10F680000E942CF956CE80910C02816080930C026E
+:10F69000FDCE80910C02816080930C0272CF20918C
+:10F6A0000C02226020930C025CCF8091070187FD41
+:10F6B00076C010920B0280E08BBF80910601909182
+:10F6C0000701880F991F909307018093060180918D
+:10F6D000080280FF09C080910802909109020196FA
+:10F6E0009093090280930802F894F999FECF1127AC
+:10F6F000E0910601F0910701C8E0D1E08091080295
+:10F7000090910902103091F400915700017001307E
+:10F71000D9F303E000935700E8950091570001707A
+:10F720000130D9F301E100935700E8950990199051
+:10F730000091570001700130D9F301E000935700A8
+:10F74000E8951395103898F0112700915700017033
+:10F750000130D9F305E000935700E8950091570078
+:10F7600001700130D9F301E100935700E89532961A
+:10F77000029709F0C7CF103011F00296E5CF11249F
+:10F7800084E10E9467F880E10E9467F8D2CD8EE1A3
+:10F790000E942CF9CECD87E90E942CF9CACDF1E068
+:10F7A000F0930B0281E088CFF999FECF92BD81BD25
+:10F7B000F89A992780B50895262FF999FECF1FBA98
+:10F7C00092BD81BD20BD0FB6F894FA9AF99A0FBE8A
+:08F7D00001960895F894FFCFA3
+:02F7D8008000AF
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex
new file mode 100644
index 0000000..2edf9c6
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/ATmegaBOOT_168_atmega644p.hex
@@ -0,0 +1,126 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0EAEA0A
+:10F89000FFEF02C005900D92A230B107D9F712E038
+:10F8A000A2E0B1E001C01D92AD30B107E1F70E94C6
+:10F8B000747D0C94D37F0C94007C90910201913064
+:10F8C00019F0923041F008959091C00095FFFCCF5F
+:10F8D0008093C60008959091C80095FFFCCF809357
+:10F8E000CE0008951F93982F95959595959595958C
+:10F8F000905D182F1F701A304CF4105D892F0E94F4
+:10F900005D7C812F0E945D7C1F910895195A892F7B
+:10F910000E945D7C812F0E945D7C1F910895EF9273
+:10F92000FF920F931F9380910201813069F1823021
+:10F9300031F080E01F910F91FF90EF900895EE2439
+:10F94000FF2487018091C80087FD17C00894E11C3F
+:10F95000F11C011D111D81E4E81682E4F8068FE018
+:10F96000080780E0180770F3E0910401F0910501A9
+:10F9700009958091C80087FFE9CF8091CE001F9143
+:10F980000F91FF90EF900895EE24FF24870180915E
+:10F99000C00087FD17C00894E11CF11C011D111D5A
+:10F9A00081E4E81682E4F8068FE0080780E0180793
+:10F9B00070F3E0910401F091050109958091C00078
+:10F9C00087FFE9CF8091C6001F910F91FF90EF90C4
+:10F9D00008951F930E948F7C182F0E945D7C113622
+:10F9E00034F410330CF01053812F1F9108951755E4
+:10F9F000812F1F9108951F930E94E97C182F0E9468
+:10FA0000E97C1295107F810F1F91089520910201CA
+:10FA1000882339F0213031F0223061F08150882381
+:10FA2000C9F708959091C00097FFFCCF9091C60050
+:10FA30008150F5CF9091C80097FFFCCF9091CE00F8
+:10FA40008150EDCF1F93182F0E948F7C803281F060
+:10FA5000809103018F5F80930301853011F01F9126
+:10FA60000895E0910401F091050109951F91089511
+:10FA700084E10E945D7C812F0E945D7C80E10E9478
+:10FA80005D7CEDCF0E948F7C803271F0809103010C
+:10FA90008F5F80930301853009F00895E0910401A0
+:10FAA000F09105010995089584E10E945D7C80E153
+:10FAB0000E945D7C089515C0289A2FEF31EE44E036
+:10FAC000215030404040E1F700C0000028982FEF5F
+:10FAD00031EE44E0215030404040E1F700C00000EA
+:10FAE0008150882349F70895EF92FF920F931F9357
+:10FAF000CF93DF93000081E08093020180E1809347
+:10FB0000C4001092C5001092C00086E08093C2002D
+:10FB100088E18093C100209A81E00E945B7D0E9471
+:10FB20008F7C8033B1F18133B9F1803409F454C052
+:10FB3000813409F45AC0823409F469C0853409F467
+:10FB40006CC0803531F1823521F1813511F1853577
+:10FB500009F469C0863509F471C0843609F47AC0A5
+:10FB6000843709F4E1C0853709F439C1863709F4CF
+:10FB70004AC0809103018F5F80930301853079F63D
+:10FB8000E0910401F091050109950E948F7C80337A
+:10FB900051F60E94427DC3CF0E948F7C803249F78C
+:10FBA00084E10E945D7C81E40E945D7C86E50E9488
+:10FBB0005D7C82E50E945D7C80E20E945D7C89E440
+:10FBC0000E945D7C83E50E945D7C80E50E945D7CF7
+:10FBD00080E10E945D7CA3CF0E948F7C8638C8F2B2
+:10FBE0000E948F7C0E94427D9ACF0E948F7C803839
+:10FBF00009F40EC1813809F40FC1823809F410C12B
+:10FC0000883909F401C180E00E94227D88CF84E117
+:10FC10000E94067D0E94427D82CF85E00E94067D83
+:10FC20000E94427D7CCF0E948F7C809306010E94BF
+:10FC30008F7C809307010E94427D71CF0E948F7C50
+:10FC4000803309F4F1C083E00E94067D80E00E94C9
+:10FC5000227D65CF0E948F7C809309020E948F7C59
+:10FC60008093080280910C028E7F80930C020E9488
+:10FC70008F7C853409F4E9C08091080290910902D3
+:10FC80000097A1F068E0E62E61E0F62E00E010E0BB
+:10FC90000E948F7CF70181937F010F5F1F4F80913E
+:10FCA0000802909109020817190790F30E948F7CAF
+:10FCB000803209F05ECF80910C0280FFE5C0809118
+:10FCC000060190910701880F991F90930701809377
+:10FCD0000601209108023091090221153105E9F051
+:10FCE00048E0E42E41E0F42E00E010E0F7016191DD
+:10FCF0007F010E94C57F80910601909107010196C6
+:10FD000090930701809306010F5F1F4F2091080217
+:10FD1000309109020217130748F384E10E945D7CC9
+:10FD200080E10E945D7CFBCE0E948F7C8093090263
+:10FD30000E948F7C809308028091060190910701B8
+:10FD400097FD9CC020910C022D7F20930C02880F00
+:10FD5000991F90930701809306010E948F7C853440
+:10FD600009F486C080910C028E7F80930C020E9461
+:10FD70008F7C803209F0D3CE84E10E945D7C20919B
+:10FD800008023091090221153105D1F100E010E09F
+:10FD900080910601909107010CC041FF5CC0019663
+:10FDA00090930701809306010F5F1F4F02171307FF
+:10FDB00038F540910C0240FFF0CF0E94BD7F0E94B9
+:10FDC0005D7C809106019091070101969093070157
+:10FDD000809306012091080230910902E5CF0E942C
+:10FDE0008F7C803209F0C5CE84E10E945D7C8EE17B
+:10FDF0000E945D7C86E90E945D7C8AE00E945D7CB9
+:10FE000080E10E945D7C8BCE83E00E94227D87CEC4
+:10FE100082E00E94227D83CE81E00E94227D7FCEFF
+:10FE200080E10E94227D7BCE0E948F7C0E948F7C8D
+:10FE3000082F0E948F7C002309F497C0013009F439
+:10FE400098C08AE00E94227D6ACE80910C02816077
+:10FE500080930C0211CFFC0184910E945D7C209163
+:10FE6000080230910902809106019091070197CF15
+:10FE700080910C02816080930C0279CF20910C025A
+:10FE8000226020930C0263CF80910701880F880BBA
+:10FE9000817080930B028091060190910701880F79
+:10FEA000991F90930701809306018091080280FFBB
+:10FEB00009C080910802909109020196909309026D
+:10FEC00080930802F894F999FECF1127E09106017A
+:10FED000F0910701C8E0D1E08091080290910902F9
+:10FEE000103091F40091570001700130D9F303E014
+:10FEF00000935700E8950091570001700130D9F345
+:10FF000001E100935700E89509901990009157007E
+:10FF100001700130D9F301E000935700E895139583
+:10FF2000103898F011270091570001700130D9F373
+:10FF300005E000935700E8950091570001700130EB
+:10FF4000D9F301E100935700E8953296029709F042
+:10FF5000C7CF103011F00296E5CF112484E10E9442
+:10FF60005D7C80E10E945D7CDACD8EE10E94227D85
+:10FF7000D6CD86E90E94227DD2CDF999FECF92BDE1
+:10FF800081BDF89A992780B50895262FF999FECF5B
+:10FF90001FBA92BD81BD20BD0FB6F894FA9AF99AA6
+:0AFFA0000FBE01960895F894FFCFFC
+:02FFAA008000D5
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/Makefile b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/Makefile
new file mode 100644
index 0000000..3f2bb61
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega/Makefile
@@ -0,0 +1,254 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+#
+# Instructions
+#
+# To make bootloader .hex file:
+# make diecimila
+# make lilypad
+# make ng
+# etc...
+#
+# To burn bootloader .hex file:
+# make diecimila_isp
+# make lilypad_isp
+# make ng_isp
+# etc...
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_168
+
+# enter the parameters for the avrdude isp tool
+ISPTOOL	   = stk500v2
+ISPPORT	   = usb
+ISPSPEED   = -b 115200
+
+MCU_TARGET = atmega168
+LDSECTION  = --section-start=.text=0x3800
+
+# the efuse should really be 0xf8; since, however, only the lower
+# three bits of that byte are used on the atmega168, avrdude gets
+# confused if you specify 1's for the higher bits, see:
+# http://tinker.it/now/2007/02/24/the-tale-of-avrdude-atmega168-and-extended-bits-fuses/
+#
+# similarly, the lock bits should be 0xff instead of 0x3f (to
+# unlock the bootloader section) and 0xcf instead of 0x0f (to
+# lock it), but since the high two bits of the lock byte are
+# unused, avrdude would get confused.
+
+ISPFUSES    = avrdude -c $(ISPTOOL) -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
+-e -u -U lock:w:0x3f:m -U efuse:w:0x$(EFUSE):m -U hfuse:w:0x$(HFUSE):m -U lfuse:w:0x$(LFUSE):m
+ISPFLASH    = avrdude -c $(ISPTOOL) -p $(MCU_TARGET) -P $(ISPPORT) $(ISPSPEED) \
+-U flash:w:$(PROGRAM)_$(TARGET).hex -U lock:w:0x0f:m
+
+STK500 = "C:\Program Files\Atmel\AVR Tools\STK500\Stk500.exe"
+STK500-1 = $(STK500) -e -d$(MCU_TARGET) -pf -vf -if$(PROGRAM)_$(TARGET).hex \
+-lFF -LFF -f$(HFUSE)$(LFUSE) -EF8 -ms -q -cUSB -I200kHz -s -wt
+STK500-2 = $(STK500) -d$(MCU_TARGET) -ms -q -lCF -LCF -cUSB -I200kHz -s -wt
+
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       =
+
+CC         = avr-gcc
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all:
+
+lilypad: TARGET = lilypad
+lilypad: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>1' '-DNUM_LED_FLASHES=3'
+lilypad: AVR_FREQ = 8000000L
+lilypad: $(PROGRAM)_lilypad.hex
+
+lilypad_isp: lilypad
+lilypad_isp: TARGET = lilypad
+lilypad_isp: HFUSE = DD
+lilypad_isp: LFUSE = E2
+lilypad_isp: EFUSE = 00
+lilypad_isp: isp
+
+lilypad_resonator: TARGET = lilypad_resonator
+lilypad_resonator: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=3'
+lilypad_resonator: AVR_FREQ = 8000000L
+lilypad_resonator: $(PROGRAM)_lilypad_resonator.hex
+
+lilypad_resonator_isp: lilypad_resonator
+lilypad_resonator_isp: TARGET = lilypad_resonator
+lilypad_resonator_isp: HFUSE = DD
+lilypad_resonator_isp: LFUSE = C6
+lilypad_resonator_isp: EFUSE = 00
+lilypad_resonator_isp: isp
+
+pro8: TARGET = pro_8MHz
+pro8: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
+pro8: AVR_FREQ = 8000000L
+pro8: $(PROGRAM)_pro_8MHz.hex
+
+pro8_isp: pro8
+pro8_isp: TARGET = pro_8MHz
+pro8_isp: HFUSE = DD
+pro8_isp: LFUSE = C6
+pro8_isp: EFUSE = 00
+pro8_isp: isp
+
+pro16: TARGET = pro_16MHz
+pro16: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
+pro16: AVR_FREQ = 16000000L
+pro16: $(PROGRAM)_pro_16MHz.hex
+
+pro16_isp: pro16
+pro16_isp: TARGET = pro_16MHz
+pro16_isp: HFUSE = DD
+pro16_isp: LFUSE = C6
+pro16_isp: EFUSE = 00
+pro16_isp: isp
+
+pro20: TARGET = pro_20mhz
+pro20: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' '-DWATCHDOG_MODS'
+pro20: AVR_FREQ = 20000000L
+pro20: $(PROGRAM)_pro_20mhz.hex
+
+pro20_isp: pro20
+pro20_isp: TARGET = pro_20mhz
+pro20_isp: HFUSE = DD
+pro20_isp: LFUSE = C6
+pro20_isp: EFUSE = 00
+pro20_isp: isp
+
+diecimila: TARGET = diecimila
+diecimila: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1'
+diecimila: AVR_FREQ = 16000000L 
+diecimila: $(PROGRAM)_diecimila.hex
+
+diecimila_isp: diecimila
+diecimila_isp: TARGET = diecimila
+diecimila_isp: HFUSE = DD
+diecimila_isp: LFUSE = FF
+diecimila_isp: EFUSE = 00
+diecimila_isp: isp
+
+ng: TARGET = ng
+ng: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>1' '-DNUM_LED_FLASHES=3'
+ng: AVR_FREQ = 16000000L
+ng: $(PROGRAM)_ng.hex
+
+ng_isp: ng
+ng_isp: TARGET = ng
+ng_isp: HFUSE = DD
+ng_isp: LFUSE = FF
+ng_isp: EFUSE = 00
+ng_isp: isp
+
+atmega328: TARGET = atmega328
+atmega328: MCU_TARGET = atmega328p
+atmega328: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' -DBAUD_RATE=57600
+atmega328: AVR_FREQ = 16000000L 
+atmega328: LDSECTION  = --section-start=.text=0x7800
+atmega328: $(PROGRAM)_atmega328.hex
+
+atmega328_isp: atmega328
+atmega328_isp: TARGET = atmega328
+atmega328_isp: MCU_TARGET = atmega328p
+atmega328_isp: HFUSE = DA
+atmega328_isp: LFUSE = FF
+atmega328_isp: EFUSE = 05
+atmega328_isp: isp
+
+atmega328_pro8: TARGET = atmega328_pro_8MHz
+atmega328_pro8: MCU_TARGET = atmega328p
+atmega328_pro8: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=1' -DBAUD_RATE=57600 -DDOUBLE_SPEED
+atmega328_pro8: AVR_FREQ = 8000000L 
+atmega328_pro8: LDSECTION  = --section-start=.text=0x7800
+atmega328_pro8: $(PROGRAM)_atmega328_pro_8MHz.hex
+
+atmega328_pro8_isp: atmega328_pro8
+atmega328_pro8_isp: TARGET = atmega328_pro_8MHz
+atmega328_pro8_isp: MCU_TARGET = atmega328p
+atmega328_pro8_isp: HFUSE = DA
+atmega328_pro8_isp: LFUSE = FF
+atmega328_pro8_isp: EFUSE = 05
+atmega328_pro8_isp: isp
+
+mega: TARGET = atmega1280
+mega: MCU_TARGET = atmega1280
+mega: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' -DBAUD_RATE=57600
+mega: AVR_FREQ = 16000000L 
+mega: LDSECTION  = --section-start=.text=0x1F000
+mega: $(PROGRAM)_atmega1280.hex
+
+mega_isp: mega
+mega_isp: TARGET = atmega1280
+mega_isp: MCU_TARGET = atmega1280
+mega_isp: HFUSE = DA
+mega_isp: LFUSE = FF
+mega_isp: EFUSE = F5
+mega_isp: isp
+
+atmega1284p: TARGET = atmega1284p
+atmega1284p: MCU_TARGET = atmega1284p
+atmega1284p: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=57600'
+atmega1284p: AVR_FREQ = 16000000L 
+atmega1284p: LDSECTION  = --section-start=.text=0x1F000
+atmega1284p: $(PROGRAM)_atmega1284p.hex
+
+atmega1284p_8m: TARGET = atmega1284p
+atmega1284p_8m: MCU_TARGET = atmega1284p
+atmega1284p_8m: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=19200'
+atmega1284p_8m: AVR_FREQ = 8000000L
+atmega1284p_8m: LDSECTION  = --section-start=.text=0x1F000
+atmega1284p_8m: $(PROGRAM)_atmega1284p_8m.hex
+
+atmega644p: TARGET = atmega644p
+atmega644p: MCU_TARGET = atmega644p
+atmega644p: CFLAGS += '-DMAX_TIME_COUNT=F_CPU>>4' '-DNUM_LED_FLASHES=0' '-DBAUD_RATE=57600'
+atmega644p: AVR_FREQ = 16000000L
+atmega644p: LDSECTION  = --section-start=.text=0xF800
+atmega644p: $(PROGRAM)_atmega644p.hex
+
+
+atmega1284p_isp: atmega1284p
+atmega1284p_isp: TARGET = atmega1284p
+atmega1284p_isp: MCU_TARGET = atmega1284p
+atmega1284p_isp: HFUSE = DC
+atmega1284p_isp: LFUSE = FF
+atmega1284p_isp: EFUSE = FD
+atmega1284p_isp: isp
+
+isp: $(TARGET)
+	$(ISPFUSES)
+	$(ISPFLASH)
+
+isp-stk500: $(PROGRAM)_$(TARGET).hex
+	$(STK500-1)
+	$(STK500-2)
+
+%.elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.hex: %.elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+	
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..51bd8d5
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,717 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega1284P__)
+#define SIG2	0x97
+#define SIG3	0x05
+#elif defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
new file mode 100644
index 0000000..7e0adff
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
@@ -0,0 +1,388 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+#include <util/delay.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega1284P__)
+#define SIG2	0x97
+#define SIG3	0x05
+#elif defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+          putch('\r');
+          _delay_ms(500);
+        }
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf
new file mode 100644
index 0000000..0ec5c7b
Binary files /dev/null and b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.elf differ
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..849c78f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,110 @@
+:020000021000EC
+:10F000000C943EF80C9450F80C9450F80C9450F872
+:10F010000C9450F80C9450F80C9450F80C9450F850
+:10F020000C9450F80C9450F80C9450F80C9450F840
+:10F030000C9450F80C9450F80C9450F80C9450F830
+:10F040000C9450F80C9450F80C9450F80C9450F820
+:10F050000C9450F80C9450F80C9450F80C9450F810
+:10F060000C9450F80C9450F80C9450F80C9450F800
+:10F070000C9450F80C9450F80C9450F811241FBEC6
+:10F08000CFEFD0E1DEBFCDBF12E0A0E0B1E001C024
+:10F090001D92A930B107E1F70E9471F90C944FFB62
+:10F0A0000C9400F89091C00095FFFCCF8093C600AF
+:10F0B00008951F93282F332727FD3095207F307028
+:10F0C00094E0359527959A95E1F72A3014F0295A5E
+:10F0D00001C0205D182F1F701A3014F0195A01C09A
+:10F0E000105D822F0E9452F8812F0E9452F81F91CA
+:10F0F0000895EF92FF920F931F932898EE24FF2418
+:10F10000870113C00894E11CF11C011D111D81E051
+:10F11000E81689E0F8068DE3080780E0180728F074
+:10F12000E0910101F091020109958091C00087FFF3
+:10F13000E9CF289A8091C6001F910F91FF90EF9020
+:10F1400008950F931F930E9479F8082F0E9452F898
+:10F150000E9479F8182F0E9452F8013614F00755D2
+:10F1600003C000330CF00053113614F0175503C0E0
+:10F1700010330CF01053802F8295807F810F1F91E8
+:10F180000F91089590E007C02091C00027FFFCCFA9
+:10F190002091C6009F5F9817B8F308951F93182F0A
+:10F1A0000E9479F8803251F484E10E9452F8812F54
+:10F1B0000E9452F880E10E9452F80CC08091000138
+:10F1C0008F5F80930001853029F4E0910101F09177
+:10F1D000020109951F9108950E9479F8803239F44F
+:10F1E00084E10E9452F880E10E9452F808958091D3
+:10F1F00000018F5F80930001853029F4E0910101C7
+:10F20000F091020109950895DF93CF9300D000D0CB
+:10F21000CDB7DEB7882309F481E090E03DC0289A9D
+:10F2200019821A821B821C820CC029813A814B816F
+:10F230005C812F5F3F4F4F4F5F4F29833A834B8352
+:10F240005C8329813A814B815C8120386EE33607EB
+:10F2500060E0460760E0560740F3289819821A825A
+:10F260001B821C820CC029813A814B815C812F5FFB
+:10F270003F4F4F4F5F4F29833A834B835C832981F4
+:10F280003A814B815C8120306AEF360760E04607A7
+:10F2900060E0560740F39F5F981709F619821A82BB
+:10F2A0001B821C820BC089819A81AB81BC81019633
+:10F2B000A11DB11D89839A83AB83BC8389819A8107
+:10F2C000AB81BC81803021E7920722E0A20720E0D9
+:10F2D000B20748F30F900F900F900F90CF91DF91EE
+:10F2E0000895CF92DF92EF92FF920F931F93CF93E7
+:10F2F000DF93000094B714BE809160008861809312
+:10F3000060001092600091FD05C0E0910101F09154
+:10F310000201099589E18093C4001092C50088E13B
+:10F320008093C10086E08093C2005098589A209A3A
+:10F3300083E00E9404F981E00E9404F90E9479F8B8
+:10F34000803309F441C08133E1F40E9479F88032BE
+:10F3500009F097C184E10E9452F881E40E9452F8BA
+:10F3600086E50E9452F882E50E9452F880E20E94EF
+:10F3700052F889E40E9452F883E50E9452F880E531
+:10F380000BC1803439F40E9479F88638E8F00E9485
+:10F3900079F81AC0813499F40E9479F8803811F410
+:10F3A00082E06CC1813811F481E068C1823811F4C7
+:10F3B00080E164C1883909F060C183E05FC18234B3
+:10F3C00031F484E10E94C2F80E94ECF8B7CF853492
+:10F3D00011F485E0F7CF8035B9F3813531F40E941F
+:10F3E000ECF888E080936000FFCF823569F38535C3
+:10F3F00049F40E9479F8809303010E9479F8809380
+:10F400000401E2CF863521F484E00E94C2F835C1C0
+:10F41000843609F0C7C00E9479F8809306020E94E2
+:10F4200079F880930502809108028E7F809308020C
+:10F430000E9479F8853429F48091080281608093D4
+:10F44000080205E011E0F801119281E0E538F807C3
+:10F45000D9F745E0C42E41E0D42EEE24FF2408C0A5
+:10F460000E9479F8F60181936F010894E11CF11C68
+:10F470008091050290910602E816F90688F30E9431
+:10F4800079F8803209F0FDC08091080280FD17C034
+:10F4900020C0F999FECF209103013091040132BDC3
+:10F4A00021BDF80141918F0140BDFA9AF99A2F5F71
+:10F4B0003F4F3093040120930301019602C080E086
+:10F4C00090E020910502309106028217930708F31D
+:10F4D00062C08091030190910401880F991F90935D
+:10F4E0000401809303018091050280FF09C080918F
+:10F4F0000502909106020196909306028093050200
+:10F50000F999FECF1127E0910301F0910401C5E0C4
+:10F51000D1E08091050290910602103091F40091A3
+:10F52000570001700130D9F303E000935700E895CC
+:10F530000091570001700130D9F301E100935700A9
+:10F54000E895099019900091570001700130D9F3A6
+:10F5500001E000935700E8951395103898F01127B3
+:10F560000091570001700130D9F305E00093570076
+:10F57000E8950091570001700130D9F301E1009343
+:10F580005700E8953296029709F0C7CF103011F076
+:10F590000296E5CF112484E10E9452F880E10E9496
+:10F5A00052F8CCCE843709F055C00E9479F8809388
+:10F5B00006020E9479F8809305020E9479F89091E2
+:10F5C0000802853421F49160909308020DC09E7F5B
+:10F5D000909308028091030190910401880F991F74
+:10F5E00090930401809303010E9479F8803209F01E
+:10F5F000A5CE84E10E9452F800E010E023C0809183
+:10F60000080280FF0BC0F999FECF80910301909111
+:10F61000040192BD81BDF89A80B507C081FD07C085
+:10F62000E0910301F091040184910E9452F88091CD
+:10F6300003019091040101969093040180930301CA
+:10F640000F5F1F4F8091050290910602081719075E
+:10F65000B0F2A4CF853779F40E9479F8803289F42A
+:10F6600084E10E9452F88EE10E9452F886E90E94DD
+:10F6700052F88AE091CF863721F480E00E94CEF8DC
+:10F680005DCE809100018F5F80930001853009F08D
+:10F6900055CEE0910101F091020109954FCEF89409
+:02F6A000FFCF9A
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..2bb5e0e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+#Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0x1F000
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -Os
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -Os -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Arduino.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Arduino.h
new file mode 100644
index 0000000..b265825
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Arduino.h
@@ -0,0 +1,215 @@
+#ifndef Arduino_h
+#define Arduino_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/pgmspace.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+#define INPUT_PULLUP 0x2
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
+#define DEFAULT 0
+#define EXTERNAL 1
+#define INTERNAL 2
+#else  
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+#endif
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+
+#define analogInPinToBit(P) (P)
+
+// On the ATmega1280, the addresses of some of the port registers are
+// greater than 255, so we can't store them in uint8_t's.
+extern const uint16_t PROGMEM port_to_mode_PGM[];
+extern const uint16_t PROGMEM port_to_input_PGM[];
+extern const uint16_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#ifdef ARDUINO_MAIN
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+#define PE 5
+#define PF 6
+#define PG 7
+#define PH 8
+#define PJ 10
+#define PK 11
+#define PL 12
+#endif
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+#define TIMER3A 8
+#define TIMER3B 9
+#define TIMER3C 10
+#define TIMER4A 11
+#define TIMER4B 12
+#define TIMER4C 13
+#define TIMER4D 14	
+#define TIMER5A 15
+#define TIMER5B 16
+#define TIMER5C 17
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#endif
+
+#include "pins_arduino.h"
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/CDC.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/CDC.cpp
new file mode 100644
index 0000000..701e483
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/CDC.cpp
@@ -0,0 +1,239 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include <avr/wdt.h>
+
+#if defined(USBCON)
+#ifdef CDC_ENABLED
+
+#if (RAMEND < 1000)
+#define SERIAL_BUFFER_SIZE 16
+#else
+#define SERIAL_BUFFER_SIZE 64
+#endif
+
+struct ring_buffer
+{
+	unsigned char buffer[SERIAL_BUFFER_SIZE];
+	volatile int head;
+	volatile int tail;
+};
+
+ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
+
+typedef struct
+{
+	u32	dwDTERate;
+	u8	bCharFormat;
+	u8 	bParityType;
+	u8 	bDataBits;
+	u8	lineState;
+} LineInfo;
+
+static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
+
+#define WEAK __attribute__ ((weak))
+
+extern const CDCDescriptor _cdcInterface PROGMEM;
+const CDCDescriptor _cdcInterface =
+{
+	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
+
+	//	CDC communication interface
+	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
+	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
+	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
+	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported
+	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, data interface is slave 0
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
+
+	//	CDC data interface
+	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
+	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
+};
+
+int WEAK CDC_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 2;	// uses 2
+	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
+}
+
+bool WEAK CDC_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_GET_LINE_CODING == r)
+		{
+			USB_SendControl(0,(void*)&_usbLineInfo,7);
+			return true;
+		}
+	}
+
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_SET_LINE_CODING == r)
+		{
+			USB_RecvControl((void*)&_usbLineInfo,7);
+			return true;
+		}
+
+		if (CDC_SET_CONTROL_LINE_STATE == r)
+		{
+			_usbLineInfo.lineState = setup.wValueL;
+
+			// auto-reset into the bootloader is triggered when the port, already 
+			// open at 1200 bps, is closed.  this is the signal to start the watchdog
+			// with a relatively long period so it can finish housekeeping tasks
+			// like servicing endpoints before the sketch ends
+			if (1200 == _usbLineInfo.dwDTERate) {
+				// We check DTR state to determine if host port is open (bit 0 of lineState).
+				if ((_usbLineInfo.lineState & 0x01) == 0) {
+					*(uint16_t *)0x0800 = 0x7777;
+					wdt_enable(WDTO_120MS);
+				} else {
+					// Most OSs do some intermediate steps when configuring ports and DTR can
+					// twiggle more than once before stabilizing.
+					// To avoid spurious resets we set the watchdog to 250ms and eventually
+					// cancel if DTR goes back high.
+	
+					wdt_disable();
+					wdt_reset();
+					*(uint16_t *)0x0800 = 0x0;
+				}
+			}
+			return true;
+		}
+	}
+	return false;
+}
+
+
+int _serialPeek = -1;
+void Serial_::begin(uint16_t baud_count)
+{
+}
+
+void Serial_::end(void)
+{
+}
+
+void Serial_::accept(void) 
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
+	
+	// if we should be storing the received character into the location
+	// just before the tail (meaning that the head would advance to the
+	// current location of the tail), we're about to overflow the buffer
+	// and so we don't write the character or advance the head.
+
+	// while we have room to store a byte
+	while (i != buffer->tail) {
+		int c = USB_Recv(CDC_RX);
+		if (c == -1)
+			break;	// no more data
+		buffer->buffer[buffer->head] = c;
+		buffer->head = i;
+
+		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
+	}
+}
+
+int Serial_::available(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int Serial_::peek(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		return buffer->buffer[buffer->tail];
+	}
+}
+
+int Serial_::read(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	// if the head isn't ahead of the tail, we don't have any characters
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		unsigned char c = buffer->buffer[buffer->tail];
+		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+		return c;
+	}	
+}
+
+void Serial_::flush(void)
+{
+	USB_Flush(CDC_TX);
+}
+
+size_t Serial_::write(uint8_t c)
+{
+	/* only try to send bytes if the high-level CDC connection itself 
+	 is open (not just the pipe) - the OS should set lineState when the port
+	 is opened and clear lineState when the port is closed.
+	 bytes sent before the user opens the connection or after
+	 the connection is closed are lost - just like with a UART. */
+	
+	// TODO - ZE - check behavior on different OSes and test what happens if an
+	// open connection isn't broken cleanly (cable is yanked out, host dies
+	// or locks up, or host virtual serial port hangs)
+	if (_usbLineInfo.lineState > 0)	{
+		int r = USB_Send(CDC_TX,&c,1);
+		if (r > 0) {
+			return r;
+		} else {
+			setWriteError();
+			return 0;
+		}
+	}
+	setWriteError();
+	return 0;
+}
+
+// This operator is a convenient way for a sketch to check whether the
+// port has actually been configured and opened by the host (as opposed
+// to just being connected to the host).  It can be used, for example, in 
+// setup() before printing to ensure that an application on the host is
+// actually ready to receive and display the data.
+// We add a short delay before returning to fix a bug observed by Federico
+// where the port is configured (lineState != 0) but not quite opened.
+Serial_::operator bool() {
+	bool result = false;
+	if (_usbLineInfo.lineState > 0) 
+		result = true;
+	delay(10);
+	return result;
+}
+
+Serial_ Serial;
+
+#endif
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Client.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Client.h
new file mode 100644
index 0000000..ea13483
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Client.h
@@ -0,0 +1,26 @@
+#ifndef client_h
+#define client_h
+#include "Print.h"
+#include "Stream.h"
+#include "IPAddress.h"
+
+class Client : public Stream {
+
+public:
+  virtual int connect(IPAddress ip, uint16_t port) =0;
+  virtual int connect(const char *host, uint16_t port) =0;
+  virtual size_t write(uint8_t) =0;
+  virtual size_t write(const uint8_t *buf, size_t size) =0;
+  virtual int available() = 0;
+  virtual int read() = 0;
+  virtual int read(uint8_t *buf, size_t size) = 0;
+  virtual int peek() = 0;
+  virtual void flush() = 0;
+  virtual void stop() = 0;
+  virtual uint8_t connected() = 0;
+  virtual operator bool() = 0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HID.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HID.cpp
new file mode 100644
index 0000000..ac63608
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HID.cpp
@@ -0,0 +1,520 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+#ifdef HID_ENABLED
+
+//#define RAWHID_ENABLED
+
+//	Singletons for mouse and keyboard
+
+Mouse_ Mouse;
+Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+
+//	HID report descriptor
+
+#define LSB(_x) ((_x) & 0xFF)
+#define MSB(_x) ((_x) >> 8)
+
+#define RAWHID_USAGE_PAGE	0xFFC0
+#define RAWHID_USAGE		0x0C00
+#define RAWHID_TX_SIZE 64
+#define RAWHID_RX_SIZE 64
+
+extern const u8 _hidReportDescriptor[] PROGMEM;
+const u8 _hidReportDescriptor[] = {
+	
+	//	Mouse
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 54
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xa1, 0x00,                    //   COLLECTION (Physical)
+    0x85, 0x01,                    //     REPORT_ID (1)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
+    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xc0,                          //   END_COLLECTION
+    0xc0,                          // END_COLLECTION
+
+	//	Keyboard
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 47
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x85, 0x02,                    //   REPORT_ID (2)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+   
+	0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    
+	0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
+    
+	0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+    
+	0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0,                          // END_COLLECTION
+
+#if RAWHID_ENABLED
+	//	RAW HID
+	0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),	// 30
+	0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
+
+	0xA1, 0x01,				// Collection 0x01
+    0x85, 0x03,             // REPORT_ID (3)
+	0x75, 0x08,				// report size = 8 bits
+	0x15, 0x00,				// logical minimum = 0
+	0x26, 0xFF, 0x00,		// logical maximum = 255
+
+	0x95, 64,				// report count TX
+	0x09, 0x01,				// usage
+	0x81, 0x02,				// Input (array)
+
+	0x95, 64,				// report count RX
+	0x09, 0x02,				// usage
+	0x91, 0x02,				// Output (array)
+	0xC0					// end collection
+#endif
+};
+
+extern const HIDDescriptor _hidInterface PROGMEM;
+const HIDDescriptor _hidInterface =
+{
+	D_INTERFACE(HID_INTERFACE,1,3,0,0),
+	D_HIDREPORT(sizeof(_hidReportDescriptor)),
+	D_ENDPOINT(USB_ENDPOINT_IN (HID_ENDPOINT_INT),USB_ENDPOINT_TYPE_INTERRUPT,0x40,0x01)
+};
+
+//================================================================================
+//================================================================================
+//	Driver
+
+u8 _hid_protocol = 1;
+u8 _hid_idle = 1;
+
+#define WEAK __attribute__ ((weak))
+
+int WEAK HID_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 1;	// uses 1
+	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
+}
+
+int WEAK HID_GetDescriptor(int i)
+{
+	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
+}
+
+void WEAK HID_SendReport(u8 id, const void* data, int len)
+{
+	USB_Send(HID_TX, &id, 1);
+	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
+}
+
+bool WEAK HID_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (HID_GET_REPORT == r)
+		{
+			//HID_GetReport();
+			return true;
+		}
+		if (HID_GET_PROTOCOL == r)
+		{
+			//Send8(_hid_protocol);	// TODO
+			return true;
+		}
+	}
+	
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (HID_SET_PROTOCOL == r)
+		{
+			_hid_protocol = setup.wValueL;
+			return true;
+		}
+
+		if (HID_SET_IDLE == r)
+		{
+			_hid_idle = setup.wValueL;
+			return true;
+		}
+	}
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+Mouse_::Mouse_(void) : _buttons(0)
+{
+}
+
+void Mouse_::begin(void) 
+{
+}
+
+void Mouse_::end(void) 
+{
+}
+
+void Mouse_::click(uint8_t b)
+{
+	_buttons = b;
+	move(0,0,0);
+	_buttons = 0;
+	move(0,0,0);
+}
+
+void Mouse_::move(signed char x, signed char y, signed char wheel)
+{
+	u8 m[4];
+	m[0] = _buttons;
+	m[1] = x;
+	m[2] = y;
+	m[3] = wheel;
+	HID_SendReport(1,m,4);
+}
+
+void Mouse_::buttons(uint8_t b)
+{
+	if (b != _buttons)
+	{
+		_buttons = b;
+		move(0,0,0);
+	}
+}
+
+void Mouse_::press(uint8_t b) 
+{
+	buttons(_buttons | b);
+}
+
+void Mouse_::release(uint8_t b)
+{
+	buttons(_buttons & ~b);
+}
+
+bool Mouse_::isPressed(uint8_t b)
+{
+	if ((b & _buttons) > 0) 
+		return true;
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+Keyboard_::Keyboard_(void) 
+{
+}
+
+void Keyboard_::begin(void) 
+{
+}
+
+void Keyboard_::end(void) 
+{
+}
+
+void Keyboard_::sendReport(KeyReport* keys)
+{
+	HID_SendReport(2,keys,sizeof(KeyReport));
+}
+
+extern
+const uint8_t _asciimap[128] PROGMEM;
+
+#define SHIFT 0x80
+const uint8_t _asciimap[128] =
+{
+	0x00,             // NUL
+	0x00,             // SOH
+	0x00,             // STX
+	0x00,             // ETX
+	0x00,             // EOT
+	0x00,             // ENQ
+	0x00,             // ACK  
+	0x00,             // BEL
+	0x2a,			// BS	Backspace
+	0x2b,			// TAB	Tab
+	0x28,			// LF	Enter
+	0x00,             // VT 
+	0x00,             // FF 
+	0x00,             // CR 
+	0x00,             // SO 
+	0x00,             // SI 
+	0x00,             // DEL
+	0x00,             // DC1
+	0x00,             // DC2
+	0x00,             // DC3
+	0x00,             // DC4
+	0x00,             // NAK
+	0x00,             // SYN
+	0x00,             // ETB
+	0x00,             // CAN
+	0x00,             // EM 
+	0x00,             // SUB
+	0x00,             // ESC
+	0x00,             // FS 
+	0x00,             // GS 
+	0x00,             // RS 
+	0x00,             // US 
+
+	0x2c,		   //  ' '
+	0x1e|SHIFT,	   // !
+	0x34|SHIFT,	   // "
+	0x20|SHIFT,    // #
+	0x21|SHIFT,    // $
+	0x22|SHIFT,    // %
+	0x24|SHIFT,    // &
+	0x34,          // '
+	0x26|SHIFT,    // (
+	0x27|SHIFT,    // )
+	0x25|SHIFT,    // *
+	0x2e|SHIFT,    // +
+	0x36,          // ,
+	0x2d,          // -
+	0x37,          // .
+	0x38,          // /
+	0x27,          // 0
+	0x1e,          // 1
+	0x1f,          // 2
+	0x20,          // 3
+	0x21,          // 4
+	0x22,          // 5
+	0x23,          // 6
+	0x24,          // 7
+	0x25,          // 8
+	0x26,          // 9
+	0x33|SHIFT,      // :
+	0x33,          // ;
+	0x36|SHIFT,      // <
+	0x2e,          // =
+	0x37|SHIFT,      // >
+	0x38|SHIFT,      // ?
+	0x1f|SHIFT,      // @
+	0x04|SHIFT,      // A
+	0x05|SHIFT,      // B
+	0x06|SHIFT,      // C
+	0x07|SHIFT,      // D
+	0x08|SHIFT,      // E
+	0x09|SHIFT,      // F
+	0x0a|SHIFT,      // G
+	0x0b|SHIFT,      // H
+	0x0c|SHIFT,      // I
+	0x0d|SHIFT,      // J
+	0x0e|SHIFT,      // K
+	0x0f|SHIFT,      // L
+	0x10|SHIFT,      // M
+	0x11|SHIFT,      // N
+	0x12|SHIFT,      // O
+	0x13|SHIFT,      // P
+	0x14|SHIFT,      // Q
+	0x15|SHIFT,      // R
+	0x16|SHIFT,      // S
+	0x17|SHIFT,      // T
+	0x18|SHIFT,      // U
+	0x19|SHIFT,      // V
+	0x1a|SHIFT,      // W
+	0x1b|SHIFT,      // X
+	0x1c|SHIFT,      // Y
+	0x1d|SHIFT,      // Z
+	0x2f,          // [
+	0x31,          // bslash
+	0x30,          // ]
+	0x23|SHIFT,    // ^
+	0x2d|SHIFT,    // _
+	0x35,          // `
+	0x04,          // a
+	0x05,          // b
+	0x06,          // c
+	0x07,          // d
+	0x08,          // e
+	0x09,          // f
+	0x0a,          // g
+	0x0b,          // h
+	0x0c,          // i
+	0x0d,          // j
+	0x0e,          // k
+	0x0f,          // l
+	0x10,          // m
+	0x11,          // n
+	0x12,          // o
+	0x13,          // p
+	0x14,          // q
+	0x15,          // r
+	0x16,          // s
+	0x17,          // t
+	0x18,          // u
+	0x19,          // v
+	0x1a,          // w
+	0x1b,          // x
+	0x1c,          // y
+	0x1d,          // z
+	0x2f|SHIFT,    // 
+	0x31|SHIFT,    // |
+	0x30|SHIFT,    // }
+	0x35|SHIFT,    // ~
+	0				// DEL
+};
+
+uint8_t USBPutChar(uint8_t c);
+
+// press() adds the specified key (printing, non-printing, or modifier)
+// to the persistent key report and sends the report.  Because of the way 
+// USB HID works, the host acts like the key remains pressed until we 
+// call release(), releaseAll(), or otherwise clear the report and resend.
+size_t Keyboard_::press(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers |= (1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			setWriteError();
+			return 0;
+		}
+		if (k & 0x80) {						// it's a capital letter or other character reached with shift
+			_keyReport.modifiers |= 0x02;	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Add k to the key report only if it's not already present
+	// and if there is an empty slot.
+	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
+		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
+		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
+		
+		for (i=0; i<6; i++) {
+			if (_keyReport.keys[i] == 0x00) {
+				_keyReport.keys[i] = k;
+				break;
+			}
+		}
+		if (i == 6) {
+			setWriteError();
+			return 0;
+		}	
+	}
+	sendReport(&_keyReport);
+	return 1;
+}
+
+// release() takes the specified key out of the persistent key report and
+// sends the report.  This tells the OS the key is no longer pressed and that
+// it shouldn't be repeated any more.
+size_t Keyboard_::release(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers &= ~(1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			return 0;
+		}
+		if (k & 0x80) {							// it's a capital letter or other character reached with shift
+			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Test the key report to see if k is present.  Clear it if it exists.
+	// Check all positions in case the key is present more than once (which it shouldn't be)
+	for (i=0; i<6; i++) {
+		if (0 != k && _keyReport.keys[i] == k) {
+			_keyReport.keys[i] = 0x00;
+		}
+	}
+
+	sendReport(&_keyReport);
+	return 1;
+}
+
+void Keyboard_::releaseAll(void)
+{
+	_keyReport.keys[0] = 0;
+	_keyReport.keys[1] = 0;	
+	_keyReport.keys[2] = 0;
+	_keyReport.keys[3] = 0;	
+	_keyReport.keys[4] = 0;
+	_keyReport.keys[5] = 0;	
+	_keyReport.modifiers = 0;
+	sendReport(&_keyReport);
+}
+
+size_t Keyboard_::write(uint8_t c)
+{	
+	uint8_t p = press(c);		// Keydown
+	uint8_t r = release(c);		// Keyup
+	return (p);					// just return the result of press() since release() almost always returns 1
+}
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..794a7be
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,519 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+  Modified 14 August 2012 by Alarus
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "Arduino.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+/*
+ * on ATmega8, the uart and its bits are not numbered, so there is no "TXC0"
+ * definition.
+ */
+#if !defined(TXC0)
+#if defined(TXC)
+#define TXC0 TXC
+#elif defined(TXC1)
+// Some devices have uart1 but no uart0
+#define TXC0 TXC1
+#else
+#error TXC0 not definable in HardwareSerial.h
+#endif
+#endif
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which head is the index of the location
+// to which to write the next incoming character and tail is the index of the
+// location from which to read.
+#if (RAMEND < 1000)
+  #define SERIAL_BUFFER_SIZE 16
+#else
+  #define SERIAL_BUFFER_SIZE 64
+#endif
+
+struct ring_buffer
+{
+  unsigned char buffer[SERIAL_BUFFER_SIZE];
+  volatile unsigned int head;
+  volatile unsigned int tail;
+};
+
+#if defined(USBCON)
+  ring_buffer rx_buffer = { { 0 }, 0, 0};
+  ring_buffer tx_buffer = { { 0 }, 0, 0};
+#endif
+#if defined(UBRRH) || defined(UBRR0H)
+  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR1H)
+  ring_buffer rx_buffer1  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR2H)
+  ring_buffer rx_buffer2  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer2  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR3H)
+  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *buffer)
+{
+  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != buffer->tail) {
+    buffer->buffer[buffer->head] = c;
+    buffer->head = i;
+  }
+}
+
+#if !defined(USART0_RX_vect) && defined(USART1_RX_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(USART_RX_vect) && !defined(SIG_USART0_RECV) && \
+    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
+	!defined(SIG_UART_RECV)
+  #error "Don't know what the Data Received vector is called for the first UART"
+#else
+  void serialEvent() __attribute__((weak));
+  void serialEvent() {}
+  #define serialEvent_implemented
+#if defined(USART_RX_vect)
+  SIGNAL(USART_RX_vect)
+#elif defined(SIG_USART0_RECV)
+  SIGNAL(SIG_USART0_RECV)
+#elif defined(SIG_UART0_RECV)
+  SIGNAL(SIG_UART0_RECV)
+#elif defined(USART0_RX_vect)
+  SIGNAL(USART0_RX_vect)
+#elif defined(SIG_UART_RECV)
+  SIGNAL(SIG_UART_RECV)
+#endif
+  {
+  #if defined(UDR0)
+    if (bit_is_clear(UCSR0A, UPE0)) {
+      unsigned char c = UDR0;
+      store_char(c, &rx_buffer);
+    } else {
+      unsigned char c = UDR0;
+    };
+  #elif defined(UDR)
+    if (bit_is_clear(UCSRA, PE)) {
+      unsigned char c = UDR;
+      store_char(c, &rx_buffer);
+    } else {
+      unsigned char c = UDR;
+    };
+  #else
+    #error UDR not defined
+  #endif
+  }
+#endif
+#endif
+
+#if defined(USART1_RX_vect)
+  void serialEvent1() __attribute__((weak));
+  void serialEvent1() {}
+  #define serialEvent1_implemented
+  SIGNAL(USART1_RX_vect)
+  {
+    if (bit_is_clear(UCSR1A, UPE1)) {
+      unsigned char c = UDR1;
+      store_char(c, &rx_buffer1);
+    } else {
+      unsigned char c = UDR1;
+    };
+  }
+#elif defined(SIG_USART1_RECV)
+  #error SIG_USART1_RECV
+#endif
+
+#if defined(USART2_RX_vect) && defined(UDR2)
+  void serialEvent2() __attribute__((weak));
+  void serialEvent2() {}
+  #define serialEvent2_implemented
+  SIGNAL(USART2_RX_vect)
+  {
+    if (bit_is_clear(UCSR2A, UPE2)) {
+      unsigned char c = UDR2;
+      store_char(c, &rx_buffer2);
+    } else {
+      unsigned char c = UDR2;
+    };
+  }
+#elif defined(SIG_USART2_RECV)
+  #error SIG_USART2_RECV
+#endif
+
+#if defined(USART3_RX_vect) && defined(UDR3)
+  void serialEvent3() __attribute__((weak));
+  void serialEvent3() {}
+  #define serialEvent3_implemented
+  SIGNAL(USART3_RX_vect)
+  {
+    if (bit_is_clear(UCSR3A, UPE3)) {
+      unsigned char c = UDR3;
+      store_char(c, &rx_buffer3);
+    } else {
+      unsigned char c = UDR3;
+    };
+  }
+#elif defined(SIG_USART3_RECV)
+  #error SIG_USART3_RECV
+#endif
+
+void serialEventRun(void)
+{
+#ifdef serialEvent_implemented
+  if (Serial.available()) serialEvent();
+#endif
+#ifdef serialEvent1_implemented
+  if (Serial1.available()) serialEvent1();
+#endif
+#ifdef serialEvent2_implemented
+  if (Serial2.available()) serialEvent2();
+#endif
+#ifdef serialEvent3_implemented
+  if (Serial3.available()) serialEvent3();
+#endif
+}
+
+
+#if !defined(USART0_UDRE_vect) && defined(USART1_UDRE_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(UART0_UDRE_vect) && !defined(UART_UDRE_vect) && !defined(USART0_UDRE_vect) && !defined(USART_UDRE_vect)
+  #error "Don't know what the Data Register Empty vector is called for the first UART"
+#else
+#if defined(UART0_UDRE_vect)
+ISR(UART0_UDRE_vect)
+#elif defined(UART_UDRE_vect)
+ISR(UART_UDRE_vect)
+#elif defined(USART0_UDRE_vect)
+ISR(USART0_UDRE_vect)
+#elif defined(USART_UDRE_vect)
+ISR(USART_UDRE_vect)
+#endif
+{
+  if (tx_buffer.head == tx_buffer.tail) {
+	// Buffer empty, so disable interrupts
+#if defined(UCSR0B)
+    cbi(UCSR0B, UDRIE0);
+#else
+    cbi(UCSRB, UDRIE);
+#endif
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
+    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+  #if defined(UDR0)
+    UDR0 = c;
+  #elif defined(UDR)
+    UDR = c;
+  #else
+    #error UDR not defined
+  #endif
+  }
+}
+#endif
+#endif
+
+#ifdef USART1_UDRE_vect
+ISR(USART1_UDRE_vect)
+{
+  if (tx_buffer1.head == tx_buffer1.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR1B, UDRIE1);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
+    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR1 = c;
+  }
+}
+#endif
+
+#ifdef USART2_UDRE_vect
+ISR(USART2_UDRE_vect)
+{
+  if (tx_buffer2.head == tx_buffer2.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR2B, UDRIE2);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
+    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR2 = c;
+  }
+}
+#endif
+
+#ifdef USART3_UDRE_vect
+ISR(USART3_UDRE_vect)
+{
+  if (tx_buffer3.head == tx_buffer3.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR3B, UDRIE3);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
+    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR3 = c;
+  }
+}
+#endif
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *ucsrc, volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _tx_buffer = tx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _ucsrc = ucsrc;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udrie = udrie;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(unsigned long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+
+try_again:
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+  
+  if ((baud_setting > 4095) && use_u2x)
+  {
+    use_u2x = false;
+    goto try_again;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  transmitting = false;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+  cbi(*_ucsrb, _udrie);
+}
+
+void HardwareSerial::begin(unsigned long baud, byte config)
+{
+  uint16_t baud_setting;
+  uint8_t current_config;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+
+try_again:
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+  
+  if ((baud_setting > 4095) && use_u2x)
+  {
+    use_u2x = false;
+    goto try_again;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  //set the data bits, parity, and stop bits
+#if defined(__AVR_ATmega8__)
+  config |= 0x80; // select UCSRC register (shared with UBRRH)
+#endif
+  *_ucsrc = config;
+  
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+  cbi(*_ucsrb, _udrie);
+}
+
+void HardwareSerial::end()
+{
+  // wait for transmission of outgoing data
+  while (_tx_buffer->head != _tx_buffer->tail)
+    ;
+
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+  cbi(*_ucsrb, _udrie);
+  
+  // clear any received data
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
+  while (transmitting && ! (*_ucsra & _BV(TXC0)));
+  transmitting = false;
+}
+
+size_t HardwareSerial::write(uint8_t c)
+{
+  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
+	
+  // If the output buffer is full, there's nothing for it other than to 
+  // wait for the interrupt handler to empty it a bit
+  // ???: return 0 here instead?
+  while (i == _tx_buffer->tail)
+    ;
+	
+  _tx_buffer->buffer[_tx_buffer->head] = c;
+  _tx_buffer->head = i;
+	
+  sbi(*_ucsrb, _udrie);
+  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
+  transmitting = true;
+  sbi(*_ucsra, TXC0);
+  
+  return 1;
+}
+
+HardwareSerial::operator bool() {
+	return true;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(UBRRH) && defined(UBRRL)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
+#elif defined(UBRR0H) && defined(UBRR0L)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
+#elif defined(USBCON)
+  // do nothing - Serial object and buffers are initialized in CDC code
+#else
+  #error no serial port defined  (port 0)
+#endif
+
+#if defined(UBRR1H)
+  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
+#endif
+#if defined(UBRR2H)
+  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
+#endif
+#if defined(UBRR3H)
+  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
+#endif
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..a73117f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/HardwareSerial.h
@@ -0,0 +1,115 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+  Modified 14 August 2012 by Alarus
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    ring_buffer *_tx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_ucsrc;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udrie;
+    uint8_t _u2x;
+    bool transmitting;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *ucsrc, volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x);
+    void begin(unsigned long);
+    void begin(unsigned long, uint8_t);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    virtual size_t write(uint8_t);
+    inline size_t write(unsigned long n) { return write((uint8_t)n); }
+    inline size_t write(long n) { return write((uint8_t)n); }
+    inline size_t write(unsigned int n) { return write((uint8_t)n); }
+    inline size_t write(int n) { return write((uint8_t)n); }
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+    operator bool();
+};
+
+// Define config for Serial.begin(baud, config);
+#define SERIAL_5N1 0x00
+#define SERIAL_6N1 0x02
+#define SERIAL_7N1 0x04
+#define SERIAL_8N1 0x06
+#define SERIAL_5N2 0x08
+#define SERIAL_6N2 0x0A
+#define SERIAL_7N2 0x0C
+#define SERIAL_8N2 0x0E
+#define SERIAL_5E1 0x20
+#define SERIAL_6E1 0x22
+#define SERIAL_7E1 0x24
+#define SERIAL_8E1 0x26
+#define SERIAL_5E2 0x28
+#define SERIAL_6E2 0x2A
+#define SERIAL_7E2 0x2C
+#define SERIAL_8E2 0x2E
+#define SERIAL_5O1 0x30
+#define SERIAL_6O1 0x32
+#define SERIAL_7O1 0x34
+#define SERIAL_8O1 0x36
+#define SERIAL_5O2 0x38
+#define SERIAL_6O2 0x3A
+#define SERIAL_7O2 0x3C
+#define SERIAL_8O2 0x3E
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "USBAPI.h"
+//  extern HardwareSerial Serial_;  
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+extern void serialEventRun(void) __attribute__((weak));
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.cpp
new file mode 100644
index 0000000..fe3deb7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.cpp
@@ -0,0 +1,56 @@
+
+#include <Arduino.h>
+#include <IPAddress.h>
+
+IPAddress::IPAddress()
+{
+    memset(_address, 0, sizeof(_address));
+}
+
+IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
+{
+    _address[0] = first_octet;
+    _address[1] = second_octet;
+    _address[2] = third_octet;
+    _address[3] = fourth_octet;
+}
+
+IPAddress::IPAddress(uint32_t address)
+{
+    memcpy(_address, &address, sizeof(_address));
+}
+
+IPAddress::IPAddress(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+}
+
+IPAddress& IPAddress::operator=(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+    return *this;
+}
+
+IPAddress& IPAddress::operator=(uint32_t address)
+{
+    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
+    return *this;
+}
+
+bool IPAddress::operator==(const uint8_t* addr)
+{
+    return memcmp(addr, _address, sizeof(_address)) == 0;
+}
+
+size_t IPAddress::printTo(Print& p) const
+{
+    size_t n = 0;
+    for (int i =0; i < 3; i++)
+    {
+        n += p.print(_address[i], DEC);
+        n += p.print('.');
+    }
+    n += p.print(_address[3], DEC);
+    return n;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.h
new file mode 100644
index 0000000..2585aec
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/IPAddress.h
@@ -0,0 +1,76 @@
+/*
+ *
+ * MIT License:
+ * Copyright (c) 2011 Adrian McEwen
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * adrianm@mcqn.com 1/1/2011
+ */
+
+#ifndef IPAddress_h
+#define IPAddress_h
+
+#include <Printable.h>
+
+// A class to make it easier to handle and pass around IP addresses
+
+class IPAddress : public Printable {
+private:
+    uint8_t _address[4];  // IPv4 address
+    // Access the raw byte array containing the address.  Because this returns a pointer
+    // to the internal structure rather than a copy of the address this function should only
+    // be used when you know that the usage of the returned uint8_t* will be transient and not
+    // stored.
+    uint8_t* raw_address() { return _address; };
+
+public:
+    // Constructors
+    IPAddress();
+    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
+    IPAddress(uint32_t address);
+    IPAddress(const uint8_t *address);
+
+    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
+    // to a four-byte uint8_t array is expected
+    operator uint32_t() { return *((uint32_t*)_address); };
+    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
+    bool operator==(const uint8_t* addr);
+
+    // Overloaded index operator to allow getting and setting individual octets of the address
+    uint8_t operator[](int index) const { return _address[index]; };
+    uint8_t& operator[](int index) { return _address[index]; };
+
+    // Overloaded copy operators to allow initialisation of IPAddress objects from other types
+    IPAddress& operator=(const uint8_t *address);
+    IPAddress& operator=(uint32_t address);
+
+    virtual size_t printTo(Print& p) const;
+
+    friend class EthernetClass;
+    friend class UDP;
+    friend class Client;
+    friend class Server;
+    friend class DhcpClass;
+    friend class DNSClient;
+};
+
+const IPAddress INADDR_NONE(0,0,0,0);
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Platform.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Platform.h
new file mode 100644
index 0000000..8b8f742
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Platform.h
@@ -0,0 +1,23 @@
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#include <inttypes.h>
+#include <avr/pgmspace.h>
+#include <avr/eeprom.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned long u32;
+
+#include "Arduino.h"
+
+#if defined(USBCON)
+	#include "USBDesc.h"
+	#include "USBCore.h"
+	#include "USBAPI.h"
+#endif /* if defined(USBCON) */
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.cpp
new file mode 100644
index 0000000..53961ec
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.cpp
@@ -0,0 +1,268 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "Arduino.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+size_t Print::write(const uint8_t *buffer, size_t size)
+{
+  size_t n = 0;
+  while (size--) {
+    n += write(*buffer++);
+  }
+  return n;
+}
+
+size_t Print::print(const __FlashStringHelper *ifsh)
+{
+  const char PROGMEM *p = (const char PROGMEM *)ifsh;
+  size_t n = 0;
+  while (1) {
+    unsigned char c = pgm_read_byte(p++);
+    if (c == 0) break;
+    n += write(c);
+  }
+  return n;
+}
+
+size_t Print::print(const String &s)
+{
+  size_t n = 0;
+  for (uint16_t i = 0; i < s.length(); i++) {
+    n += write(s[i]);
+  }
+  return n;
+}
+
+size_t Print::print(const char str[])
+{
+  return write(str);
+}
+
+size_t Print::print(char c)
+{
+  return write(c);
+}
+
+size_t Print::print(unsigned char b, int base)
+{
+  return print((unsigned long) b, base);
+}
+
+size_t Print::print(int n, int base)
+{
+  return print((long) n, base);
+}
+
+size_t Print::print(unsigned int n, int base)
+{
+  return print((unsigned long) n, base);
+}
+
+size_t Print::print(long n, int base)
+{
+  if (base == 0) {
+    return write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      int t = print('-');
+      n = -n;
+      return printNumber(n, 10) + t;
+    }
+    return printNumber(n, 10);
+  } else {
+    return printNumber(n, base);
+  }
+}
+
+size_t Print::print(unsigned long n, int base)
+{
+  if (base == 0) return write(n);
+  else return printNumber(n, base);
+}
+
+size_t Print::print(double n, int digits)
+{
+  return printFloat(n, digits);
+}
+
+size_t Print::println(const __FlashStringHelper *ifsh)
+{
+  size_t n = print(ifsh);
+  n += println();
+  return n;
+}
+
+size_t Print::print(const Printable& x)
+{
+  return x.printTo(*this);
+}
+
+size_t Print::println(void)
+{
+  size_t n = print('\r');
+  n += print('\n');
+  return n;
+}
+
+size_t Print::println(const String &s)
+{
+  size_t n = print(s);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const char c[])
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(char c)
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned char b, int base)
+{
+  size_t n = print(b, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(double num, int digits)
+{
+  size_t n = print(num, digits);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const Printable& x)
+{
+  size_t n = print(x);
+  n += println();
+  return n;
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+size_t Print::printNumber(unsigned long n, uint8_t base) {
+  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
+  char *str = &buf[sizeof(buf) - 1];
+
+  *str = '\0';
+
+  // prevent crash if called with base == 1
+  if (base < 2) base = 10;
+
+  do {
+    unsigned long m = n;
+    n /= base;
+    char c = m - base * n;
+    *--str = c < 10 ? c + '0' : c + 'A' - 10;
+  } while(n);
+
+  return write(str);
+}
+
+size_t Print::printFloat(double number, uint8_t digits) 
+{ 
+  size_t n = 0;
+  
+  if (isnan(number)) return print("nan");
+  if (isinf(number)) return print("inf");
+  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
+  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
+  
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     n += print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  n += print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0) {
+    n += print("."); 
+  }
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    n += print(toPrint);
+    remainder -= toPrint; 
+  } 
+  
+  return n;
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.h
new file mode 100644
index 0000000..dc76150
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Print.h
@@ -0,0 +1,81 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+#include "Printable.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+
+class Print
+{
+  private:
+    int write_error;
+    size_t printNumber(unsigned long, uint8_t);
+    size_t printFloat(double, uint8_t);
+  protected:
+    void setWriteError(int err = 1) { write_error = err; }
+  public:
+    Print() : write_error(0) {}
+  
+    int getWriteError() { return write_error; }
+    void clearWriteError() { setWriteError(0); }
+  
+    virtual size_t write(uint8_t) = 0;
+    size_t write(const char *str) {
+      if (str == NULL) return 0;
+      return write((const uint8_t *)str, strlen(str));
+    }
+    virtual size_t write(const uint8_t *buffer, size_t size);
+    
+    size_t print(const __FlashStringHelper *);
+    size_t print(const String &);
+    size_t print(const char[]);
+    size_t print(char);
+    size_t print(unsigned char, int = DEC);
+    size_t print(int, int = DEC);
+    size_t print(unsigned int, int = DEC);
+    size_t print(long, int = DEC);
+    size_t print(unsigned long, int = DEC);
+    size_t print(double, int = 2);
+    size_t print(const Printable&);
+
+    size_t println(const __FlashStringHelper *);
+    size_t println(const String &s);
+    size_t println(const char[]);
+    size_t println(char);
+    size_t println(unsigned char, int = DEC);
+    size_t println(int, int = DEC);
+    size_t println(unsigned int, int = DEC);
+    size_t println(long, int = DEC);
+    size_t println(unsigned long, int = DEC);
+    size_t println(double, int = 2);
+    size_t println(const Printable&);
+    size_t println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Printable.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Printable.h
new file mode 100644
index 0000000..d03c9af
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Printable.h
@@ -0,0 +1,40 @@
+/*
+  Printable.h - Interface class that allows printing of complex types
+  Copyright (c) 2011 Adrian McEwen.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Printable_h
+#define Printable_h
+
+#include <new.h>
+
+class Print;
+
+/** The Printable class provides a way for new classes to allow themselves to be printed.
+    By deriving from Printable and implementing the printTo method, it will then be possible
+    for users to print out instances of this class by passing them into the usual
+    Print::print and Print::println methods.
+*/
+
+class Printable
+{
+  public:
+    virtual size_t printTo(Print& p) const = 0;
+};
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Server.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Server.h
new file mode 100644
index 0000000..9674c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Server.h
@@ -0,0 +1,9 @@
+#ifndef server_h
+#define server_h
+
+class Server : public Print {
+public:
+  virtual void begin() =0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.cpp
new file mode 100644
index 0000000..aafb7fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.cpp
@@ -0,0 +1,270 @@
+/*
+ Stream.cpp - adds parsing methods to Stream class
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Created July 2011
+ parsing functions based on TextFinder library by Michael Margolis
+ */
+
+#include "Arduino.h"
+#include "Stream.h"
+
+#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
+#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
+
+// private method to read stream with timeout
+int Stream::timedRead()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = read();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// private method to peek stream with timeout
+int Stream::timedPeek()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = peek();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// returns peek of the next digit in the stream or -1 if timeout
+// discards non-numeric characters
+int Stream::peekNextDigit()
+{
+  int c;
+  while (1) {
+    c = timedPeek();
+    if (c < 0) return c;  // timeout
+    if (c == '-') return c;
+    if (c >= '0' && c <= '9') return c;
+    read();  // discard non-numeric
+  }
+}
+
+// Public Methods
+//////////////////////////////////////////////////////////////
+
+void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
+{
+  _timeout = timeout;
+}
+
+ // find returns true if the target string is found
+bool  Stream::find(char *target)
+{
+  return findUntil(target, NULL);
+}
+
+// reads data from the stream until the target string of given length is found
+// returns true if target string is found, false if timed out
+bool Stream::find(char *target, size_t length)
+{
+  return findUntil(target, length, NULL, 0);
+}
+
+// as find but search ends if the terminator string is found
+bool  Stream::findUntil(char *target, char *terminator)
+{
+  return findUntil(target, strlen(target), terminator, strlen(terminator));
+}
+
+// reads data from the stream until the target string of the given length is found
+// search terminated if the terminator string is found
+// returns true if target string is found, false if terminated or timed out
+bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
+{
+  size_t index = 0;  // maximum target string length is 64k bytes!
+  size_t termIndex = 0;
+  int c;
+  
+  if( *target == 0)
+    return true;   // return true if target is a null string
+  while( (c = timedRead()) > 0){
+    
+    if(c != target[index])
+      index = 0; // reset index if any char does not match
+    
+    if( c == target[index]){
+      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
+      if(++index >= targetLen){ // return true if all chars in the target match
+        return true;
+      }
+    }
+    
+    if(termLen > 0 && c == terminator[termIndex]){
+      if(++termIndex >= termLen)
+        return false;       // return false if terminate string found before target string
+    }
+    else
+      termIndex = 0;
+  }
+  return false;
+}
+
+
+// returns the first valid (long) integer value from the current position.
+// initial characters that are not digits (or the minus sign) are skipped
+// function is terminated by the first character that is not a digit.
+long Stream::parseInt()
+{
+  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
+}
+
+// as above but a given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+long Stream::parseInt(char skipChar)
+{
+  boolean isNegative = false;
+  long value = 0;
+  int c;
+
+  c = peekNextDigit();
+  // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore this charactor
+    else if(c == '-')
+      isNegative = true;
+    else if(c >= '0' && c <= '9')        // is c a digit?
+      value = value * 10 + c - '0';
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9') || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  return value;
+}
+
+
+// as parseInt but returns a floating point value
+float Stream::parseFloat()
+{
+  return parseFloat(NO_SKIP_CHAR);
+}
+
+// as above but the given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+float Stream::parseFloat(char skipChar){
+  boolean isNegative = false;
+  boolean isFraction = false;
+  long value = 0;
+  char c;
+  float fraction = 1.0;
+
+  c = peekNextDigit();
+    // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore
+    else if(c == '-')
+      isNegative = true;
+    else if (c == '.')
+      isFraction = true;
+    else if(c >= '0' && c <= '9')  {      // is c a digit?
+      value = value * 10 + c - '0';
+      if(isFraction)
+         fraction *= 0.1;
+    }
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  if(isFraction)
+    return value * fraction;
+  else
+    return value;
+}
+
+// read characters from stream into buffer
+// terminates if length characters have been read, or timeout (see setTimeout)
+// returns the number of characters placed in the buffer
+// the buffer is NOT null terminated.
+//
+size_t Stream::readBytes(char *buffer, size_t length)
+{
+  size_t count = 0;
+  while (count < length) {
+    int c = timedRead();
+    if (c < 0) break;
+    *buffer++ = (char)c;
+    count++;
+  }
+  return count;
+}
+
+
+// as readBytes with terminator character
+// terminates if length characters have been read, timeout, or if the terminator character  detected
+// returns the number of characters placed in the buffer (0 means no valid data found)
+
+size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
+{
+  if (length < 1) return 0;
+  size_t index = 0;
+  while (index < length) {
+    int c = timedRead();
+    if (c < 0 || c == terminator) break;
+    *buffer++ = (char)c;
+    index++;
+  }
+  return index; // return number of characters, not including null terminator
+}
+
+String Stream::readString()
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
+String Stream::readStringUntil(char terminator)
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0 && c != terminator)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.h
new file mode 100644
index 0000000..58bbf75
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Stream.h
@@ -0,0 +1,96 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  parsing functions based on TextFinder library by Michael Margolis
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// compatability macros for testing
+/*
+#define   getInt()            parseInt()
+#define   getInt(skipChar)    parseInt(skipchar)
+#define   getFloat()          parseFloat()
+#define   getFloat(skipChar)  parseFloat(skipChar)
+#define   getString( pre_string, post_string, buffer, length)
+readBytesBetween( pre_string, terminator, buffer, length)
+*/
+
+class Stream : public Print
+{
+  private:
+    unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
+    unsigned long _startMillis;  // used for timeout measurement
+    int timedRead();    // private method to read stream with timeout
+    int timedPeek();    // private method to peek stream with timeout
+    int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
+
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+
+    Stream() {_timeout=1000;}
+
+// parsing methods
+
+  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
+
+  bool find(char *target);   // reads data from the stream until the target string is found
+  // returns true if target string is found, false if timed out (see setTimeout)
+
+  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
+  // returns true if target string is found, false if timed out
+
+  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
+
+  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
+
+
+  long parseInt(); // returns the first valid (long) integer value from the current position.
+  // initial characters that are not digits (or the minus sign) are skipped
+  // integer is terminated by the first character that is not a digit.
+
+  float parseFloat();               // float version of parseInt
+
+  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
+  // terminates if length characters have been read or timeout (see setTimeout)
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
+  // terminates if length characters have been read, timeout, or if the terminator character  detected
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  // Arduino String functions to be added here
+  String readString();
+  String readStringUntil(char terminator);
+
+  protected:
+  long parseInt(char skipChar); // as above but the given skipChar is ignored
+  // as above but the given skipChar is ignored
+  // this allows format characters (typically commas) in values to be ignored
+
+  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..9bb6fe7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Tone.cpp
@@ -0,0 +1,616 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+0008    S Kanemoto  12/06/22 Fixed for Leonardo by @maris_HY
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "Arduino.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#elif defined(__AVR_ATmega32U4__)
+ 
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER3
+ 
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 3 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+ 
+#else
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#ifdef USE_TIMER0
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER1
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER2
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER3
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER4
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER5
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBAPI.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBAPI.h
new file mode 100644
index 0000000..eb2e593
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBAPI.h
@@ -0,0 +1,196 @@
+
+
+#ifndef __USBAPI__
+#define __USBAPI__
+
+#if defined(USBCON)
+
+//================================================================================
+//================================================================================
+//	USB
+
+class USBDevice_
+{
+public:
+	USBDevice_();
+	bool configured();
+
+	void attach();
+	void detach();	// Serial port goes down too...
+	void poll();
+};
+extern USBDevice_ USBDevice;
+
+//================================================================================
+//================================================================================
+//	Serial over CDC (Serial1 is the physical port)
+
+class Serial_ : public Stream
+{
+private:
+	ring_buffer *_cdc_rx_buffer;
+public:
+	void begin(uint16_t baud_count);
+	void end(void);
+
+	virtual int available(void);
+	virtual void accept(void);
+	virtual int peek(void);
+	virtual int read(void);
+	virtual void flush(void);
+	virtual size_t write(uint8_t);
+	using Print::write; // pull in write(str) and write(buf, size) from Print
+	operator bool();
+};
+extern Serial_ Serial;
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+#define MOUSE_LEFT 1
+#define MOUSE_RIGHT 2
+#define MOUSE_MIDDLE 4
+#define MOUSE_ALL (MOUSE_LEFT | MOUSE_RIGHT | MOUSE_MIDDLE)
+
+class Mouse_
+{
+private:
+	uint8_t _buttons;
+	void buttons(uint8_t b);
+public:
+	Mouse_(void);
+	void begin(void);
+	void end(void);
+	void click(uint8_t b = MOUSE_LEFT);
+	void move(signed char x, signed char y, signed char wheel = 0);	
+	void press(uint8_t b = MOUSE_LEFT);		// press LEFT by default
+	void release(uint8_t b = MOUSE_LEFT);	// release LEFT by default
+	bool isPressed(uint8_t b = MOUSE_LEFT);	// check LEFT by default
+};
+extern Mouse_ Mouse;
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+#define KEY_LEFT_CTRL		0x80
+#define KEY_LEFT_SHIFT		0x81
+#define KEY_LEFT_ALT		0x82
+#define KEY_LEFT_GUI		0x83
+#define KEY_RIGHT_CTRL		0x84
+#define KEY_RIGHT_SHIFT		0x85
+#define KEY_RIGHT_ALT		0x86
+#define KEY_RIGHT_GUI		0x87
+
+#define KEY_UP_ARROW		0xDA
+#define KEY_DOWN_ARROW		0xD9
+#define KEY_LEFT_ARROW		0xD8
+#define KEY_RIGHT_ARROW		0xD7
+#define KEY_BACKSPACE		0xB2
+#define KEY_TAB				0xB3
+#define KEY_RETURN			0xB0
+#define KEY_ESC				0xB1
+#define KEY_INSERT			0xD1
+#define KEY_DELETE			0xD4
+#define KEY_PAGE_UP			0xD3
+#define KEY_PAGE_DOWN		0xD6
+#define KEY_HOME			0xD2
+#define KEY_END				0xD5
+#define KEY_CAPS_LOCK		0xC1
+#define KEY_F1				0xC2
+#define KEY_F2				0xC3
+#define KEY_F3				0xC4
+#define KEY_F4				0xC5
+#define KEY_F5				0xC6
+#define KEY_F6				0xC7
+#define KEY_F7				0xC8
+#define KEY_F8				0xC9
+#define KEY_F9				0xCA
+#define KEY_F10				0xCB
+#define KEY_F11				0xCC
+#define KEY_F12				0xCD
+
+//	Low level key report: up to 6 keys and shift, ctrl etc at once
+typedef struct
+{
+	uint8_t modifiers;
+	uint8_t reserved;
+	uint8_t keys[6];
+} KeyReport;
+
+class Keyboard_ : public Print
+{
+private:
+	KeyReport _keyReport;
+	void sendReport(KeyReport* keys);
+public:
+	Keyboard_(void);
+	void begin(void);
+	void end(void);
+	virtual size_t write(uint8_t k);
+	virtual size_t press(uint8_t k);
+	virtual size_t release(uint8_t k);
+	virtual void releaseAll(void);
+};
+extern Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+//	Low level API
+
+typedef struct
+{
+	uint8_t bmRequestType;
+	uint8_t bRequest;
+	uint8_t wValueL;
+	uint8_t wValueH;
+	uint16_t wIndex;
+	uint16_t wLength;
+} Setup;
+
+//================================================================================
+//================================================================================
+//	HID 'Driver'
+
+int		HID_GetInterface(uint8_t* interfaceNum);
+int		HID_GetDescriptor(int i);
+bool	HID_Setup(Setup& setup);
+void	HID_SendReport(uint8_t id, const void* data, int len);
+
+//================================================================================
+//================================================================================
+//	MSC 'Driver'
+
+int		MSC_GetInterface(uint8_t* interfaceNum);
+int		MSC_GetDescriptor(int i);
+bool	MSC_Setup(Setup& setup);
+bool	MSC_Data(uint8_t rx,uint8_t tx);
+
+//================================================================================
+//================================================================================
+//	CSC 'Driver'
+
+int		CDC_GetInterface(uint8_t* interfaceNum);
+int		CDC_GetDescriptor(int i);
+bool	CDC_Setup(Setup& setup);
+
+//================================================================================
+//================================================================================
+
+#define TRANSFER_PGM		0x80
+#define TRANSFER_RELEASE	0x40
+#define TRANSFER_ZERO		0x20
+
+int USB_SendControl(uint8_t flags, const void* d, int len);
+int USB_RecvControl(void* d, int len);
+
+uint8_t	USB_Available(uint8_t ep);
+int USB_Send(uint8_t ep, const void* data, int len);	// blocking
+int USB_Recv(uint8_t ep, void* data, int len);		// non-blocking
+int USB_Recv(uint8_t ep);							// non-blocking
+void USB_Flush(uint8_t ep);
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.cpp
new file mode 100644
index 0000000..d3e0170
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.cpp
@@ -0,0 +1,684 @@
+
+
+/* Copyright (c) 2010, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+
+#define EP_TYPE_CONTROL				0x00
+#define EP_TYPE_BULK_IN				0x81
+#define EP_TYPE_BULK_OUT			0x80
+#define EP_TYPE_INTERRUPT_IN		0xC1
+#define EP_TYPE_INTERRUPT_OUT		0xC0
+#define EP_TYPE_ISOCHRONOUS_IN		0x41
+#define EP_TYPE_ISOCHRONOUS_OUT		0x40
+
+/** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse type */
+#define TX_RX_LED_PULSE_MS 100
+volatile u8 TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
+volatile u8 RxLEDPulse; /**< Milliseconds remaining for data Rx LED pulse */
+
+//==================================================================
+//==================================================================
+
+extern const u16 STRING_LANGUAGE[] PROGMEM;
+extern const u16 STRING_IPRODUCT[] PROGMEM;
+extern const u16 STRING_IMANUFACTURER[] PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptor PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptorA PROGMEM;
+
+const u16 STRING_LANGUAGE[2] = {
+	(3<<8) | (2+2),
+	0x0409	// English
+};
+
+const u16 STRING_IPRODUCT[17] = {
+	(3<<8) | (2+2*16),
+#if USB_PID == 0x8036	
+	'A','r','d','u','i','n','o',' ','L','e','o','n','a','r','d','o'
+#elif USB_PID == 0x8037
+	'A','r','d','u','i','n','o',' ','M','i','c','r','o',' ',' ',' '
+#elif USB_PID == 0x803C
+	'A','r','d','u','i','n','o',' ','E','s','p','l','o','r','a',' '
+#elif USB_PID == 0x9208
+	'L','i','l','y','P','a','d','U','S','B',' ',' ',' ',' ',' ',' '
+#else
+	'U','S','B',' ','I','O',' ','B','o','a','r','d',' ',' ',' ',' '
+#endif
+};
+
+const u16 STRING_IMANUFACTURER[12] = {
+	(3<<8) | (2+2*11),
+#if USB_VID == 0x2341
+	'A','r','d','u','i','n','o',' ','L','L','C'
+#elif USB_VID == 0x1b4f
+	'S','p','a','r','k','F','u','n',' ',' ',' '
+#else
+	'U','n','k','n','o','w','n',' ',' ',' ',' '
+#endif
+};
+
+#ifdef CDC_ENABLED
+#define DEVICE_CLASS 0x02
+#else
+#define DEVICE_CLASS 0x00
+#endif
+
+//	DEVICE DESCRIPTOR
+const DeviceDescriptor USB_DeviceDescriptor =
+	D_DEVICE(0x00,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+const DeviceDescriptor USB_DeviceDescriptorA =
+	D_DEVICE(DEVICE_CLASS,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+//==================================================================
+//==================================================================
+
+volatile u8 _usbConfiguration = 0;
+
+static inline void WaitIN(void)
+{
+	while (!(UEINTX & (1<<TXINI)));
+}
+
+static inline void ClearIN(void)
+{
+	UEINTX = ~(1<<TXINI);
+}
+
+static inline void WaitOUT(void)
+{
+	while (!(UEINTX & (1<<RXOUTI)))
+		;
+}
+
+static inline u8 WaitForINOrOUT()
+{
+	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
+		;
+	return (UEINTX & (1<<RXOUTI)) == 0;
+}
+
+static inline void ClearOUT(void)
+{
+	UEINTX = ~(1<<RXOUTI);
+}
+
+void Recv(volatile u8* data, u8 count)
+{
+	while (count--)
+		*data++ = UEDATX;
+	
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;	
+}
+
+static inline u8 Recv8()
+{
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;
+
+	return UEDATX;	
+}
+
+static inline void Send8(u8 d)
+{
+	UEDATX = d;
+}
+
+static inline void SetEP(u8 ep)
+{
+	UENUM = ep;
+}
+
+static inline u8 FifoByteCount()
+{
+	return UEBCLX;
+}
+
+static inline u8 ReceivedSetupInt()
+{
+	return UEINTX & (1<<RXSTPI);
+}
+
+static inline void ClearSetupInt()
+{
+	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
+}
+
+static inline void Stall()
+{
+	UECONX = (1<<STALLRQ) | (1<<EPEN);
+}
+
+static inline u8 ReadWriteAllowed()
+{
+	return UEINTX & (1<<RWAL);
+}
+
+static inline u8 Stalled()
+{
+	return UEINTX & (1<<STALLEDI);
+}
+
+static inline u8 FifoFree()
+{
+	return UEINTX & (1<<FIFOCON);
+}
+
+static inline void ReleaseRX()
+{
+	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
+}
+
+static inline void ReleaseTX()
+{
+	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
+}
+
+static inline u8 FrameNumber()
+{
+	return UDFNUML;
+}
+
+//==================================================================
+//==================================================================
+
+u8 USBGetConfiguration(void)
+{
+	return _usbConfiguration;
+}
+
+#define USB_RECV_TIMEOUT
+class LockEP
+{
+	u8 _sreg;
+public:
+	LockEP(u8 ep) : _sreg(SREG)
+	{
+		cli();
+		SetEP(ep & 7);
+	}
+	~LockEP()
+	{
+		SREG = _sreg;
+	}
+};
+
+//	Number of bytes, assumes a rx endpoint
+u8 USB_Available(u8 ep)
+{
+	LockEP lock(ep);
+	return FifoByteCount();
+}
+
+//	Non Blocking receive
+//	Return number of bytes read
+int USB_Recv(u8 ep, void* d, int len)
+{
+	if (!_usbConfiguration || len < 0)
+		return -1;
+	
+	LockEP lock(ep);
+	u8 n = FifoByteCount();
+	len = min(n,len);
+	n = len;
+	u8* dst = (u8*)d;
+	while (n--)
+		*dst++ = Recv8();
+	if (len && !FifoByteCount())	// release empty buffer
+		ReleaseRX();
+	
+	return len;
+}
+
+//	Recv 1 byte if ready
+int USB_Recv(u8 ep)
+{
+	u8 c;
+	if (USB_Recv(ep,&c,1) != 1)
+		return -1;
+	return c;
+}
+
+//	Space in send EP
+u8 USB_SendSpace(u8 ep)
+{
+	LockEP lock(ep);
+	if (!ReadWriteAllowed())
+		return 0;
+	return 64 - FifoByteCount();
+}
+
+//	Blocking Send of data to an endpoint
+int USB_Send(u8 ep, const void* d, int len)
+{
+	if (!_usbConfiguration)
+		return -1;
+
+	int r = len;
+	const u8* data = (const u8*)d;
+	u8 zero = ep & TRANSFER_ZERO;
+	u8 timeout = 250;		// 250ms timeout on send? TODO
+	while (len)
+	{
+		u8 n = USB_SendSpace(ep);
+		if (n == 0)
+		{
+			if (!(--timeout))
+				return -1;
+			delay(1);
+			continue;
+		}
+
+		if (n > len)
+			n = len;
+		len -= n;
+		{
+			LockEP lock(ep);
+			if (ep & TRANSFER_ZERO)
+			{
+				while (n--)
+					Send8(0);
+			}
+			else if (ep & TRANSFER_PGM)
+			{
+				while (n--)
+					Send8(pgm_read_byte(data++));
+			}
+			else
+			{
+				while (n--)
+					Send8(*data++);
+			}
+			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
+				ReleaseTX();
+		}
+	}
+	TXLED1;					// light the TX LED
+	TxLEDPulse = TX_RX_LED_PULSE_MS;
+	return r;
+}
+
+extern const u8 _initEndpoints[] PROGMEM;
+const u8 _initEndpoints[] = 
+{
+	0,
+	
+#ifdef CDC_ENABLED
+	EP_TYPE_INTERRUPT_IN,		// CDC_ENDPOINT_ACM
+	EP_TYPE_BULK_OUT,			// CDC_ENDPOINT_OUT
+	EP_TYPE_BULK_IN,			// CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+	EP_TYPE_INTERRUPT_IN		// HID_ENDPOINT_INT
+#endif
+};
+
+#define EP_SINGLE_64 0x32	// EP0
+#define EP_DOUBLE_64 0x36	// Other endpoints
+
+static
+void InitEP(u8 index, u8 type, u8 size)
+{
+	UENUM = index;
+	UECONX = 1;
+	UECFG0X = type;
+	UECFG1X = size;
+}
+
+static
+void InitEndpoints()
+{
+	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
+	{
+		UENUM = i;
+		UECONX = 1;
+		UECFG0X = pgm_read_byte(_initEndpoints+i);
+		UECFG1X = EP_DOUBLE_64;
+	}
+	UERST = 0x7E;	// And reset them
+	UERST = 0;
+}
+
+//	Handle CLASS_INTERFACE requests
+static
+bool ClassInterfaceRequest(Setup& setup)
+{
+	u8 i = setup.wIndex;
+
+#ifdef CDC_ENABLED
+	if (CDC_ACM_INTERFACE == i)
+		return CDC_Setup(setup);
+#endif
+
+#ifdef HID_ENABLED
+	if (HID_INTERFACE == i)
+		return HID_Setup(setup);
+#endif
+	return false;
+}
+
+int _cmark;
+int _cend;
+void InitControl(int end)
+{
+	SetEP(0);
+	_cmark = 0;
+	_cend = end;
+}
+
+static
+bool SendControl(u8 d)
+{
+	if (_cmark < _cend)
+	{
+		if (!WaitForINOrOUT())
+			return false;
+		Send8(d);
+		if (!((_cmark + 1) & 0x3F))
+			ClearIN();	// Fifo is full, release this packet
+	}
+	_cmark++;
+	return true;
+};
+
+//	Clipped by _cmark/_cend
+int USB_SendControl(u8 flags, const void* d, int len)
+{
+	int sent = len;
+	const u8* data = (const u8*)d;
+	bool pgm = flags & TRANSFER_PGM;
+	while (len--)
+	{
+		u8 c = pgm ? pgm_read_byte(data++) : *data++;
+		if (!SendControl(c))
+			return -1;
+	}
+	return sent;
+}
+
+//	Does not timeout or cross fifo boundaries
+//	Will only work for transfers <= 64 bytes
+//	TODO
+int USB_RecvControl(void* d, int len)
+{
+	WaitOUT();
+	Recv((u8*)d,len);
+	ClearOUT();
+	return len;
+}
+
+int SendInterfaces()
+{
+	int total = 0;
+	u8 interfaces = 0;
+
+#ifdef CDC_ENABLED
+	total = CDC_GetInterface(&interfaces);
+#endif
+
+#ifdef HID_ENABLED
+	total += HID_GetInterface(&interfaces);
+#endif
+
+	return interfaces;
+}
+
+//	Construct a dynamic configuration descriptor
+//	This really needs dynamic endpoint allocation etc
+//	TODO
+static
+bool SendConfiguration(int maxlen)
+{
+	//	Count and measure interfaces
+	InitControl(0);	
+	int interfaces = SendInterfaces();
+	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
+
+	//	Now send them
+	InitControl(maxlen);
+	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
+	SendInterfaces();
+	return true;
+}
+
+u8 _cdcComposite = 0;
+
+static
+bool SendDescriptor(Setup& setup)
+{
+	u8 t = setup.wValueH;
+	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
+		return SendConfiguration(setup.wLength);
+
+	InitControl(setup.wLength);
+#ifdef HID_ENABLED
+	if (HID_REPORT_DESCRIPTOR_TYPE == t)
+		return HID_GetDescriptor(t);
+#endif
+
+	u8 desc_length = 0;
+	const u8* desc_addr = 0;
+	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wLength == 8)
+			_cdcComposite = 1;
+		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
+	}
+	else if (USB_STRING_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wValueL == 0)
+			desc_addr = (const u8*)&STRING_LANGUAGE;
+		else if (setup.wValueL == IPRODUCT) 
+			desc_addr = (const u8*)&STRING_IPRODUCT;
+		else if (setup.wValueL == IMANUFACTURER)
+			desc_addr = (const u8*)&STRING_IMANUFACTURER;
+		else
+			return false;
+	}
+
+	if (desc_addr == 0)
+		return false;
+	if (desc_length == 0)
+		desc_length = pgm_read_byte(desc_addr);
+
+	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
+	return true;
+}
+
+//	Endpoint 0 interrupt
+ISR(USB_COM_vect)
+{
+    SetEP(0);
+	if (!ReceivedSetupInt())
+		return;
+
+	Setup setup;
+	Recv((u8*)&setup,8);
+	ClearSetupInt();
+
+	u8 requestType = setup.bmRequestType;
+	if (requestType & REQUEST_DEVICETOHOST)
+		WaitIN();
+	else
+		ClearIN();
+
+    bool ok = true;
+	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
+	{
+		//	Standard Requests
+		u8 r = setup.bRequest;
+		if (GET_STATUS == r)
+		{
+			Send8(0);		// TODO
+			Send8(0);
+		}
+		else if (CLEAR_FEATURE == r)
+		{
+		}
+		else if (SET_FEATURE == r)
+		{
+		}
+		else if (SET_ADDRESS == r)
+		{
+			WaitIN();
+			UDADDR = setup.wValueL | (1<<ADDEN);
+		}
+		else if (GET_DESCRIPTOR == r)
+		{
+			ok = SendDescriptor(setup);
+		}
+		else if (SET_DESCRIPTOR == r)
+		{
+			ok = false;
+		}
+		else if (GET_CONFIGURATION == r)
+		{
+			Send8(1);
+		}
+		else if (SET_CONFIGURATION == r)
+		{
+			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
+			{
+				InitEndpoints();
+				_usbConfiguration = setup.wValueL;
+			} else
+				ok = false;
+		}
+		else if (GET_INTERFACE == r)
+		{
+		}
+		else if (SET_INTERFACE == r)
+		{
+		}
+	}
+	else
+	{
+		InitControl(setup.wLength);		//	Max length of transfer
+		ok = ClassInterfaceRequest(setup);
+	}
+
+	if (ok)
+		ClearIN();
+	else
+	{
+		Stall();
+	}
+}
+
+void USB_Flush(u8 ep)
+{
+	SetEP(ep);
+	if (FifoByteCount())
+		ReleaseTX();
+}
+
+//	General interrupt
+ISR(USB_GEN_vect)
+{
+	u8 udint = UDINT;
+	UDINT = 0;
+
+	//	End of Reset
+	if (udint & (1<<EORSTI))
+	{
+		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
+		_usbConfiguration = 0;			// not configured yet
+		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
+	}
+
+	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
+	if (udint & (1<<SOFI))
+	{
+#ifdef CDC_ENABLED
+		USB_Flush(CDC_TX);				// Send a tx frame if found
+		if (USB_Available(CDC_RX))	// Handle received bytes (if any)
+			Serial.accept();
+#endif
+		
+		// check whether the one-shot period has elapsed.  if so, turn off the LED
+		if (TxLEDPulse && !(--TxLEDPulse))
+			TXLED0;
+		if (RxLEDPulse && !(--RxLEDPulse))
+			RXLED0;
+	}
+}
+
+//	VBUS or counting frames
+//	Any frame counting?
+u8 USBConnected()
+{
+	u8 f = UDFNUML;
+	delay(3);
+	return f != UDFNUML;
+}
+
+//=======================================================================
+//=======================================================================
+
+USBDevice_ USBDevice;
+
+USBDevice_::USBDevice_()
+{
+}
+
+void USBDevice_::attach()
+{
+	_usbConfiguration = 0;
+	UHWCON = 0x01;						// power internal reg
+	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
+#if F_CPU == 16000000UL
+	PLLCSR = 0x12;						// Need 16 MHz xtal
+#elif F_CPU == 8000000UL
+	PLLCSR = 0x02;						// Need 8 MHz xtal
+#endif
+	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
+		;
+
+	// Some tests on specific versions of macosx (10.7.3), reported some
+	// strange behaviuors when the board is reset using the serial
+	// port touch at 1200 bps. This delay fixes this behaviour.
+	delay(1);
+
+	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
+	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
+	UDCON = 0;							// enable attach resistor
+	
+	TX_RX_LED_INIT;
+}
+
+void USBDevice_::detach()
+{
+}
+
+//	Check for interrupts
+//	TODO: VBUS detection
+bool USBDevice_::configured()
+{
+	return _usbConfiguration;
+}
+
+void USBDevice_::poll()
+{
+}
+
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.h
new file mode 100644
index 0000000..8d13806
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBCore.h
@@ -0,0 +1,303 @@
+
+// Copyright (c) 2010, Peter Barrett 
+/*
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+**  
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#ifndef __USBCORE_H__
+#define __USBCORE_H__
+
+//	Standard requests
+#define GET_STATUS			0
+#define CLEAR_FEATURE		1
+#define SET_FEATURE			3
+#define SET_ADDRESS			5
+#define GET_DESCRIPTOR		6
+#define SET_DESCRIPTOR		7
+#define GET_CONFIGURATION	8
+#define SET_CONFIGURATION	9
+#define GET_INTERFACE		10
+#define SET_INTERFACE		11
+
+
+// bmRequestType
+#define REQUEST_HOSTTODEVICE	0x00
+#define REQUEST_DEVICETOHOST	0x80
+#define REQUEST_DIRECTION		0x80
+
+#define REQUEST_STANDARD		0x00
+#define REQUEST_CLASS			0x20
+#define REQUEST_VENDOR			0x40
+#define REQUEST_TYPE			0x60
+
+#define REQUEST_DEVICE			0x00
+#define REQUEST_INTERFACE		0x01
+#define REQUEST_ENDPOINT		0x02
+#define REQUEST_OTHER			0x03
+#define REQUEST_RECIPIENT		0x03
+
+#define REQUEST_DEVICETOHOST_CLASS_INTERFACE  (REQUEST_DEVICETOHOST + REQUEST_CLASS + REQUEST_INTERFACE)
+#define REQUEST_HOSTTODEVICE_CLASS_INTERFACE  (REQUEST_HOSTTODEVICE + REQUEST_CLASS + REQUEST_INTERFACE)
+
+//	Class requests
+
+#define CDC_SET_LINE_CODING			0x20
+#define CDC_GET_LINE_CODING			0x21
+#define CDC_SET_CONTROL_LINE_STATE	0x22
+
+#define MSC_RESET					0xFF
+#define MSC_GET_MAX_LUN				0xFE
+
+#define HID_GET_REPORT				0x01
+#define HID_GET_IDLE				0x02
+#define HID_GET_PROTOCOL			0x03
+#define HID_SET_REPORT				0x09
+#define HID_SET_IDLE				0x0A
+#define HID_SET_PROTOCOL			0x0B
+
+//	Descriptors
+
+#define USB_DEVICE_DESC_SIZE 18
+#define USB_CONFIGUARTION_DESC_SIZE 9
+#define USB_INTERFACE_DESC_SIZE 9
+#define USB_ENDPOINT_DESC_SIZE 7
+
+#define USB_DEVICE_DESCRIPTOR_TYPE             1
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
+#define USB_STRING_DESCRIPTOR_TYPE             3
+#define USB_INTERFACE_DESCRIPTOR_TYPE          4
+#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
+
+#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
+#define USB_DEVICE_CLASS_STORAGE               0x08
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
+
+#define USB_CONFIG_POWERED_MASK                0x40
+#define USB_CONFIG_BUS_POWERED                 0x80
+#define USB_CONFIG_SELF_POWERED                0xC0
+#define USB_CONFIG_REMOTE_WAKEUP               0x20
+
+// bMaxPower in Configuration Descriptor
+#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
+
+// bEndpointAddress in Endpoint Descriptor
+#define USB_ENDPOINT_DIRECTION_MASK            0x80
+#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
+#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
+
+#define USB_ENDPOINT_TYPE_MASK                 0x03
+#define USB_ENDPOINT_TYPE_CONTROL              0x00
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
+#define USB_ENDPOINT_TYPE_BULK                 0x02
+#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
+
+#define TOBYTES(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+
+#define CDC_V1_10                               0x0110
+#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
+
+#define CDC_CALL_MANAGEMENT                     0x01
+#define CDC_ABSTRACT_CONTROL_MODEL              0x02
+#define CDC_HEADER                              0x00
+#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
+#define CDC_UNION                               0x06
+#define CDC_CS_INTERFACE                        0x24
+#define CDC_CS_ENDPOINT                         0x25
+#define CDC_DATA_INTERFACE_CLASS                0x0A
+
+#define MSC_SUBCLASS_SCSI						0x06 
+#define MSC_PROTOCOL_BULK_ONLY					0x50 
+
+#define HID_HID_DESCRIPTOR_TYPE					0x21
+#define HID_REPORT_DESCRIPTOR_TYPE				0x22
+#define HID_PHYSICAL_DESCRIPTOR_TYPE			0x23
+
+
+//	Device
+typedef struct {
+	u8 len;				// 18
+	u8 dtype;			// 1 USB_DEVICE_DESCRIPTOR_TYPE
+	u16 usbVersion;		// 0x200
+	u8	deviceClass;
+	u8	deviceSubClass;
+	u8	deviceProtocol;
+	u8	packetSize0;	// Packet 0
+	u16	idVendor;
+	u16	idProduct;
+	u16	deviceVersion;	// 0x100
+	u8	iManufacturer;
+	u8	iProduct;
+	u8	iSerialNumber;
+	u8	bNumConfigurations;
+} DeviceDescriptor;
+
+//	Config
+typedef struct {
+	u8	len;			// 9
+	u8	dtype;			// 2
+	u16 clen;			// total length
+	u8	numInterfaces;
+	u8	config;
+	u8	iconfig;
+	u8	attributes;
+	u8	maxPower;
+} ConfigDescriptor;
+
+//	String
+
+//	Interface
+typedef struct
+{
+	u8 len;		// 9
+	u8 dtype;	// 4
+	u8 number;
+	u8 alternate;
+	u8 numEndpoints;
+	u8 interfaceClass;
+	u8 interfaceSubClass;
+	u8 protocol;
+	u8 iInterface;
+} InterfaceDescriptor;
+
+//	Endpoint
+typedef struct
+{
+	u8 len;		// 7
+	u8 dtype;	// 5
+	u8 addr;
+	u8 attr;
+	u16 packetSize;
+	u8 interval;
+} EndpointDescriptor;
+
+// Interface Association Descriptor
+// Used to bind 2 interfaces together in CDC compostite device
+typedef struct
+{
+	u8 len;				// 8
+	u8 dtype;			// 11
+	u8 firstInterface;
+	u8 interfaceCount;
+	u8 functionClass;
+	u8 funtionSubClass;
+	u8 functionProtocol;
+	u8 iInterface;
+} IADDescriptor;
+
+//	CDC CS interface descriptor
+typedef struct
+{
+	u8 len;		// 5
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+	u8 d1;
+} CDCCSInterfaceDescriptor;
+
+typedef struct
+{
+	u8 len;		// 4
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+} CDCCSInterfaceDescriptor4;
+
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+    u8 	bDataInterface;
+} CMFunctionalDescriptor;
+	
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+} ACMFunctionalDescriptor;
+
+typedef struct 
+{
+	//	IAD
+	IADDescriptor				iad;	// Only needed on compound device
+
+	//	Control
+	InterfaceDescriptor			cif;	// 
+	CDCCSInterfaceDescriptor	header;
+	CMFunctionalDescriptor		callManagement;			// Call Management
+	ACMFunctionalDescriptor		controlManagement;		// ACM
+	CDCCSInterfaceDescriptor	functionalDescriptor;	// CDC_UNION
+	EndpointDescriptor			cifin;
+
+	//	Data
+	InterfaceDescriptor			dif;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} CDCDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			msc;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} MSCDescriptor;
+
+typedef struct
+{
+	u8 len;			// 9
+	u8 dtype;		// 0x21
+	u8 addr;
+	u8	versionL;	// 0x101
+	u8	versionH;	// 0x101
+	u8	country;
+	u8	desctype;	// 0x22 report
+	u8	descLenL;
+	u8	descLenH;
+} HIDDescDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			hid;
+	HIDDescDescriptor			desc;
+	EndpointDescriptor			in;
+} HIDDescriptor;
+
+
+#define D_DEVICE(_class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs) \
+	{ 18, 1, 0x200, _class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs }
+
+#define D_CONFIG(_totalLength,_interfaces) \
+	{ 9, 2, _totalLength,_interfaces, 1, 0, USB_CONFIG_BUS_POWERED, USB_CONFIG_POWER_MA(500) }
+
+#define D_INTERFACE(_n,_numEndpoints,_class,_subClass,_protocol) \
+	{ 9, 4, _n, 0, _numEndpoints, _class,_subClass, _protocol, 0 }
+
+#define D_ENDPOINT(_addr,_attr,_packetSize, _interval) \
+	{ 7, 5, _addr,_attr,_packetSize, _interval }
+
+#define D_IAD(_firstInterface, _count, _class, _subClass, _protocol) \
+	{ 8, 11, _firstInterface, _count, _class, _subClass, _protocol, 0 }
+
+#define D_HIDREPORT(_descriptorLength) \
+	{ 9, 0x21, 0x1, 0x1, 0, 1, 0x22, _descriptorLength, 0 }
+
+#define D_CDCCS(_subtype,_d0,_d1)	{ 5, 0x24, _subtype, _d0, _d1 }
+#define D_CDCCS4(_subtype,_d0)		{ 4, 0x24, _subtype, _d0 }
+
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBDesc.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBDesc.h
new file mode 100644
index 0000000..900713e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/USBDesc.h
@@ -0,0 +1,63 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#define CDC_ENABLED
+#define HID_ENABLED
+
+
+#ifdef CDC_ENABLED
+#define CDC_INTERFACE_COUNT	2
+#define CDC_ENPOINT_COUNT	3
+#else
+#define CDC_INTERFACE_COUNT	0
+#define CDC_ENPOINT_COUNT	0
+#endif
+
+#ifdef HID_ENABLED
+#define HID_INTERFACE_COUNT	1
+#define HID_ENPOINT_COUNT	1
+#else
+#define HID_INTERFACE_COUNT	0
+#define HID_ENPOINT_COUNT	0
+#endif
+
+#define CDC_ACM_INTERFACE	0	// CDC ACM
+#define CDC_DATA_INTERFACE	1	// CDC Data
+#define CDC_FIRST_ENDPOINT	1
+#define CDC_ENDPOINT_ACM	(CDC_FIRST_ENDPOINT)							// CDC First
+#define CDC_ENDPOINT_OUT	(CDC_FIRST_ENDPOINT+1)
+#define CDC_ENDPOINT_IN		(CDC_FIRST_ENDPOINT+2)
+
+#define HID_INTERFACE		(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT)		// HID Interface
+#define HID_FIRST_ENDPOINT	(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT)
+#define HID_ENDPOINT_INT	(HID_FIRST_ENDPOINT)
+
+#define INTERFACE_COUNT		(MSC_INTERFACE + MSC_INTERFACE_COUNT)
+
+#ifdef CDC_ENABLED
+#define CDC_RX CDC_ENDPOINT_OUT
+#define CDC_TX CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+#define HID_TX HID_ENDPOINT_INT
+#endif
+
+#define IMANUFACTURER	1
+#define IPRODUCT		2
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Udp.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Udp.h
new file mode 100644
index 0000000..dc5644b
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/Udp.h
@@ -0,0 +1,88 @@
+/*
+ *  Udp.cpp: Library to send/receive UDP packets.
+ *
+ * NOTE: UDP is fast, but has some important limitations (thanks to Warren Gray for mentioning these)
+ * 1) UDP does not guarantee the order in which assembled UDP packets are received. This
+ * might not happen often in practice, but in larger network topologies, a UDP
+ * packet can be received out of sequence. 
+ * 2) UDP does not guard against lost packets - so packets *can* disappear without the sender being
+ * aware of it. Again, this may not be a concern in practice on small local networks.
+ * For more information, see http://www.cafeaulait.org/course/week12/35.html
+ *
+ * MIT License:
+ * Copyright (c) 2008 Bjoern Hartmann
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * bjoern@cs.stanford.edu 12/30/2008
+ */
+
+#ifndef udp_h
+#define udp_h
+
+#include <Stream.h>
+#include <IPAddress.h>
+
+class UDP : public Stream {
+
+public:
+  virtual uint8_t begin(uint16_t) =0;	// initialize, start listening on specified port. Returns 1 if successful, 0 if there are no sockets available to use
+  virtual void stop() =0;  // Finish with the UDP socket
+
+  // Sending UDP packets
+  
+  // Start building up a packet to send to the remote host specific in ip and port
+  // Returns 1 if successful, 0 if there was a problem with the supplied IP address or port
+  virtual int beginPacket(IPAddress ip, uint16_t port) =0;
+  // Start building up a packet to send to the remote host specific in host and port
+  // Returns 1 if successful, 0 if there was a problem resolving the hostname or port
+  virtual int beginPacket(const char *host, uint16_t port) =0;
+  // Finish off this packet and send it
+  // Returns 1 if the packet was sent successfully, 0 if there was an error
+  virtual int endPacket() =0;
+  // Write a single byte into the packet
+  virtual size_t write(uint8_t) =0;
+  // Write size bytes from buffer into the packet
+  virtual size_t write(const uint8_t *buffer, size_t size) =0;
+
+  // Start processing the next available incoming packet
+  // Returns the size of the packet in bytes, or 0 if no packets are available
+  virtual int parsePacket() =0;
+  // Number of bytes remaining in the current packet
+  virtual int available() =0;
+  // Read a single byte from the current packet
+  virtual int read() =0;
+  // Read up to len bytes from the current packet and place them into buffer
+  // Returns the number of bytes read, or 0 if none are available
+  virtual int read(unsigned char* buffer, size_t len) =0;
+  // Read up to len characters from the current packet and place them into buffer
+  // Returns the number of characters read, or 0 if none are available
+  virtual int read(char* buffer, size_t len) =0;
+  // Return the next byte from the current packet without moving on to the next byte
+  virtual int peek() =0;
+  virtual void flush() =0;	// Finish reading the current packet
+
+  // Return the IP address of the host who sent the current incoming packet
+  virtual IPAddress remoteIP() =0;
+  // Return the port of the host who sent the current incoming packet
+  virtual uint16_t remotePort() =0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..62efc9c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WInterrupts.c
@@ -0,0 +1,322 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "wiring_private.h"
+
+static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+	// I hate doing this, but the register assignment differs between the 1280/2560
+	// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't 
+	// even present on the 32U4 this is the only way to distinguish between them.
+	case 0:
+		EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);
+		EIMSK |= (1<<INT0);
+		break;
+	case 1:
+		EICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);
+		EIMSK |= (1<<INT1);
+		break;	
+    case 2:
+        EICRA = (EICRA & ~((1<<ISC20) | (1<<ISC21))) | (mode << ISC20);
+        EIMSK |= (1<<INT2);
+        break;
+    case 3:
+        EICRA = (EICRA & ~((1<<ISC30) | (1<<ISC31))) | (mode << ISC30);
+        EIMSK |= (1<<INT3);
+        break;
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else		
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+    
+    case 2:
+    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GICR |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GIMSK |= (1 << INT2);
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+    case 0:
+        EIMSK &= ~(1<<INT0);
+        break;
+    case 1:
+        EIMSK &= ~(1<<INT1);
+        break;
+    case 2:
+        EIMSK &= ~(1<<INT2);
+        break;
+    case 3:
+        EIMSK &= ~(1<<INT3);
+        break;		
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(__AVR_ATmega32U4__)
+SIGNAL(INT0_vect) {
+	if(intFunc[EXTERNAL_INT_0])
+		intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+	if(intFunc[EXTERNAL_INT_1])
+		intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT2_vect) {
+    if(intFunc[EXTERNAL_INT_2])
+		intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT3_vect) {
+    if(intFunc[EXTERNAL_INT_3])
+		intFunc[EXTERNAL_INT_3]();
+}
+
+#elif defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#if defined(EICRA) && defined(ISC20)
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+#endif
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.cpp
new file mode 100644
index 0000000..c6839fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.cpp
@@ -0,0 +1,645 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "WString.h"
+
+
+/*********************************************/
+/*  Constructors                             */
+/*********************************************/
+
+String::String(const char *cstr)
+{
+	init();
+	if (cstr) copy(cstr, strlen(cstr));
+}
+
+String::String(const String &value)
+{
+	init();
+	*this = value;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String::String(String &&rval)
+{
+	init();
+	move(rval);
+}
+String::String(StringSumHelper &&rval)
+{
+	init();
+	move(rval);
+}
+#endif
+
+String::String(char c)
+{
+	init();
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	*this = buf;
+}
+
+String::String(unsigned char value, unsigned char base)
+{
+	init();
+	char buf[9];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(int value, unsigned char base)
+{
+	init();
+	char buf[18];
+	itoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned int value, unsigned char base)
+{
+	init();
+	char buf[17];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(long value, unsigned char base)
+{
+	init();
+	char buf[34];
+	ltoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned long value, unsigned char base)
+{
+	init();
+	char buf[33];
+	ultoa(value, buf, base);
+	*this = buf;
+}
+
+String::~String()
+{
+	free(buffer);
+}
+
+/*********************************************/
+/*  Memory Management                        */
+/*********************************************/
+
+inline void String::init(void)
+{
+	buffer = NULL;
+	capacity = 0;
+	len = 0;
+	flags = 0;
+}
+
+void String::invalidate(void)
+{
+	if (buffer) free(buffer);
+	buffer = NULL;
+	capacity = len = 0;
+}
+
+unsigned char String::reserve(unsigned int size)
+{
+	if (buffer && capacity >= size) return 1;
+	if (changeBuffer(size)) {
+		if (len == 0) buffer[0] = 0;
+		return 1;
+	}
+	return 0;
+}
+
+unsigned char String::changeBuffer(unsigned int maxStrLen)
+{
+	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
+	if (newbuffer) {
+		buffer = newbuffer;
+		capacity = maxStrLen;
+		return 1;
+	}
+	return 0;
+}
+
+/*********************************************/
+/*  Copy and Move                            */
+/*********************************************/
+
+String & String::copy(const char *cstr, unsigned int length)
+{
+	if (!reserve(length)) {
+		invalidate();
+		return *this;
+	}
+	len = length;
+	strcpy(buffer, cstr);
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+void String::move(String &rhs)
+{
+	if (buffer) {
+		if (capacity >= rhs.len) {
+			strcpy(buffer, rhs.buffer);
+			len = rhs.len;
+			rhs.len = 0;
+			return;
+		} else {
+			free(buffer);
+		}
+	}
+	buffer = rhs.buffer;
+	capacity = rhs.capacity;
+	len = rhs.len;
+	rhs.buffer = NULL;
+	rhs.capacity = 0;
+	rhs.len = 0;
+}
+#endif
+
+String & String::operator = (const String &rhs)
+{
+	if (this == &rhs) return *this;
+	
+	if (rhs.buffer) copy(rhs.buffer, rhs.len);
+	else invalidate();
+	
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String & String::operator = (String &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+
+String & String::operator = (StringSumHelper &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+#endif
+
+String & String::operator = (const char *cstr)
+{
+	if (cstr) copy(cstr, strlen(cstr));
+	else invalidate();
+	
+	return *this;
+}
+
+/*********************************************/
+/*  concat                                   */
+/*********************************************/
+
+unsigned char String::concat(const String &s)
+{
+	return concat(s.buffer, s.len);
+}
+
+unsigned char String::concat(const char *cstr, unsigned int length)
+{
+	unsigned int newlen = len + length;
+	if (!cstr) return 0;
+	if (length == 0) return 1;
+	if (!reserve(newlen)) return 0;
+	strcpy(buffer + len, cstr);
+	len = newlen;
+	return 1;
+}
+
+unsigned char String::concat(const char *cstr)
+{
+	if (!cstr) return 0;
+	return concat(cstr, strlen(cstr));
+}
+
+unsigned char String::concat(char c)
+{
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	return concat(buf, 1);
+}
+
+unsigned char String::concat(unsigned char num)
+{
+	char buf[4];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(int num)
+{
+	char buf[7];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned int num)
+{
+	char buf[6];
+	utoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(long num)
+{
+	char buf[12];
+	ltoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned long num)
+{
+	char buf[11];
+	ultoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+/*********************************************/
+/*  Concatenate                              */
+/*********************************************/
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, char c)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(c)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+/*********************************************/
+/*  Comparison                               */
+/*********************************************/
+
+int String::compareTo(const String &s) const
+{
+	if (!buffer || !s.buffer) {
+		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
+		if (buffer && len > 0) return *(unsigned char *)buffer;
+		return 0;
+	}
+	return strcmp(buffer, s.buffer);
+}
+
+unsigned char String::equals(const String &s2) const
+{
+	return (len == s2.len && compareTo(s2) == 0);
+}
+
+unsigned char String::equals(const char *cstr) const
+{
+	if (len == 0) return (cstr == NULL || *cstr == 0);
+	if (cstr == NULL) return buffer[0] == 0;
+	return strcmp(buffer, cstr) == 0;
+}
+
+unsigned char String::operator<(const String &rhs) const
+{
+	return compareTo(rhs) < 0;
+}
+
+unsigned char String::operator>(const String &rhs) const
+{
+	return compareTo(rhs) > 0;
+}
+
+unsigned char String::operator<=(const String &rhs) const
+{
+	return compareTo(rhs) <= 0;
+}
+
+unsigned char String::operator>=(const String &rhs) const
+{
+	return compareTo(rhs) >= 0;
+}
+
+unsigned char String::equalsIgnoreCase( const String &s2 ) const
+{
+	if (this == &s2) return 1;
+	if (len != s2.len) return 0;
+	if (len == 0) return 1;
+	const char *p1 = buffer;
+	const char *p2 = s2.buffer;
+	while (*p1) {
+		if (tolower(*p1++) != tolower(*p2++)) return 0;
+	} 
+	return 1;
+}
+
+unsigned char String::startsWith( const String &s2 ) const
+{
+	if (len < s2.len) return 0;
+	return startsWith(s2, 0);
+}
+
+unsigned char String::startsWith( const String &s2, unsigned int offset ) const
+{
+	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
+	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
+}
+
+unsigned char String::endsWith( const String &s2 ) const
+{
+	if ( len < s2.len || !buffer || !s2.buffer) return 0;
+	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
+}
+
+/*********************************************/
+/*  Character Access                         */
+/*********************************************/
+
+char String::charAt(unsigned int loc) const
+{
+	return operator[](loc);
+}
+
+void String::setCharAt(unsigned int loc, char c) 
+{
+	if (loc < len) buffer[loc] = c;
+}
+
+char & String::operator[](unsigned int index)
+{
+	static char dummy_writable_char;
+	if (index >= len || !buffer) {
+		dummy_writable_char = 0;
+		return dummy_writable_char;
+	}
+	return buffer[index];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+	if (index >= len || !buffer) return 0;
+	return buffer[index];
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
+{
+	if (!bufsize || !buf) return;
+	if (index >= len) {
+		buf[0] = 0;
+		return;
+	}
+	unsigned int n = bufsize - 1;
+	if (n > len - index) n = len - index;
+	strncpy((char *)buf, buffer + index, n);
+	buf[n] = 0;
+}
+
+/*********************************************/
+/*  Search                                   */
+/*********************************************/
+
+int String::indexOf(char c) const
+{
+	return indexOf(c, 0);
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+	if (fromIndex >= len) return -1;
+	const char* temp = strchr(buffer + fromIndex, ch);
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::indexOf(const String &s2) const
+{
+	return indexOf(s2, 0);
+}
+
+int String::indexOf(const String &s2, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	const char *found = strstr(buffer + fromIndex, s2.buffer);
+	if (found == NULL) return -1;
+	return found - buffer;
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+	return lastIndexOf(theChar, len - 1);
+}
+
+int String::lastIndexOf(char ch, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	char tempchar = buffer[fromIndex + 1];
+	buffer[fromIndex + 1] = '\0';
+	char* temp = strrchr( buffer, ch );
+	buffer[fromIndex + 1] = tempchar;
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::lastIndexOf(const String &s2) const
+{
+	return lastIndexOf(s2, len - s2.len);
+}
+
+int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
+{
+  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
+	if (fromIndex >= len) fromIndex = len - 1;
+	int found = -1;
+	for (char *p = buffer; p <= buffer + fromIndex; p++) {
+		p = strstr(p, s2.buffer);
+		if (!p) break;
+		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
+	}
+	return found;
+}
+
+String String::substring( unsigned int left ) const
+{
+	return substring(left, len);
+}
+
+String String::substring(unsigned int left, unsigned int right) const
+{
+	if (left > right) {
+		unsigned int temp = right;
+		right = left;
+		left = temp;
+	}
+	String out;
+	if (left > len) return out;
+	if (right > len) right = len;
+	char temp = buffer[right];  // save the replaced character
+	buffer[right] = '\0';	
+	out = buffer + left;  // pointer arithmetic
+	buffer[right] = temp;  //restore character
+	return out;
+}
+
+/*********************************************/
+/*  Modification                             */
+/*********************************************/
+
+void String::replace(char find, char replace)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		if (*p == find) *p = replace;
+	}
+}
+
+void String::replace(const String& find, const String& replace)
+{
+	if (len == 0 || find.len == 0) return;
+	int diff = replace.len - find.len;
+	char *readFrom = buffer;
+	char *foundAt;
+	if (diff == 0) {
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			memcpy(foundAt, replace.buffer, replace.len);
+			readFrom = foundAt + replace.len;
+		}
+	} else if (diff < 0) {
+		char *writeTo = buffer;
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			unsigned int n = foundAt - readFrom;
+			memcpy(writeTo, readFrom, n);
+			writeTo += n;
+			memcpy(writeTo, replace.buffer, replace.len);
+			writeTo += replace.len;
+			readFrom = foundAt + find.len;
+			len += diff;
+		}
+		strcpy(writeTo, readFrom);
+	} else {
+		unsigned int size = len; // compute size needed for result
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			readFrom = foundAt + find.len;
+			size += diff;
+		}
+		if (size == len) return;
+		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
+		int index = len - 1;
+		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
+			readFrom = buffer + index + find.len;
+			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
+			len += diff;
+			buffer[len] = 0;
+			memcpy(buffer + index, replace.buffer, replace.len);
+			index--;
+		}
+	}
+}
+
+void String::toLowerCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = tolower(*p);
+	}
+}
+
+void String::toUpperCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = toupper(*p);
+	}
+}
+
+void String::trim(void)
+{
+	if (!buffer || len == 0) return;
+	char *begin = buffer;
+	while (isspace(*begin)) begin++;
+	char *end = buffer + len - 1;
+	while (isspace(*end) && end >= begin) end--;
+	len = end + 1 - begin;
+	if (begin > buffer) memcpy(buffer, begin, len);
+	buffer[len] = 0;
+}
+
+/*********************************************/
+/*  Parsing / Conversion                     */
+/*********************************************/
+
+long String::toInt(void) const
+{
+	if (buffer) return atol(buffer);
+	return 0;
+}
+
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.h
new file mode 100644
index 0000000..947325e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/WString.h
@@ -0,0 +1,205 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_class_h
+#define String_class_h
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <avr/pgmspace.h>
+
+// When compiling programs with this class, the following gcc parameters
+// dramatically increase performance and memory (RAM) efficiency, typically
+// with little or no increase in code size.
+//     -felide-constructors
+//     -std=c++0x
+
+class __FlashStringHelper;
+#define F(string_literal) (reinterpret_cast<const __FlashStringHelper *>(PSTR(string_literal)))
+
+// An inherited class for holding the result of a concatenation.  These
+// result objects are assumed to be writable by subsequent concatenations.
+class StringSumHelper;
+
+// The string class
+class String
+{
+	// use a function pointer to allow for "if (s)" without the
+	// complications of an operator bool(). for more information, see:
+	// http://www.artima.com/cppsource/safebool.html
+	typedef void (String::*StringIfHelperType)() const;
+	void StringIfHelper() const {}
+
+public:
+	// constructors
+	// creates a copy of the initial value.
+	// if the initial value is null or invalid, or if memory allocation
+	// fails, the string will be marked as invalid (i.e. "if (s)" will
+	// be false).
+	String(const char *cstr = "");
+	String(const String &str);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String(String &&rval);
+	String(StringSumHelper &&rval);
+	#endif
+	explicit String(char c);
+	explicit String(unsigned char, unsigned char base=10);
+	explicit String(int, unsigned char base=10);
+	explicit String(unsigned int, unsigned char base=10);
+	explicit String(long, unsigned char base=10);
+	explicit String(unsigned long, unsigned char base=10);
+	~String(void);
+
+	// memory management
+	// return true on success, false on failure (in which case, the string
+	// is left unchanged).  reserve(0), if successful, will validate an
+	// invalid string (i.e., "if (s)" will be true afterwards)
+	unsigned char reserve(unsigned int size);
+	inline unsigned int length(void) const {return len;}
+
+	// creates a copy of the assigned value.  if the value is null or
+	// invalid, or if the memory allocation fails, the string will be 
+	// marked as invalid ("if (s)" will be false).
+	String & operator = (const String &rhs);
+	String & operator = (const char *cstr);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String & operator = (String &&rval);
+	String & operator = (StringSumHelper &&rval);
+	#endif
+
+	// concatenate (works w/ built-in types)
+	
+	// returns true on success, false on failure (in which case, the string
+	// is left unchanged).  if the argument is null or invalid, the 
+	// concatenation is considered unsucessful.  
+	unsigned char concat(const String &str);
+	unsigned char concat(const char *cstr);
+	unsigned char concat(char c);
+	unsigned char concat(unsigned char c);
+	unsigned char concat(int num);
+	unsigned char concat(unsigned int num);
+	unsigned char concat(long num);
+	unsigned char concat(unsigned long num);
+	
+	// if there's not enough memory for the concatenated value, the string
+	// will be left unchanged (but this isn't signalled in any way)
+	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
+	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
+	String & operator += (char c)			{concat(c); return (*this);}
+	String & operator += (unsigned char num)		{concat(num); return (*this);}
+	String & operator += (int num)			{concat(num); return (*this);}
+	String & operator += (unsigned int num)		{concat(num); return (*this);}
+	String & operator += (long num)			{concat(num); return (*this);}
+	String & operator += (unsigned long num)	{concat(num); return (*this);}
+
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, char c);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, long num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num);
+
+	// comparison (only works w/ Strings and "strings")
+	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
+	int compareTo(const String &s) const;
+	unsigned char equals(const String &s) const;
+	unsigned char equals(const char *cstr) const;
+	unsigned char operator == (const String &rhs) const {return equals(rhs);}
+	unsigned char operator == (const char *cstr) const {return equals(cstr);}
+	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
+	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
+	unsigned char operator <  (const String &rhs) const;
+	unsigned char operator >  (const String &rhs) const;
+	unsigned char operator <= (const String &rhs) const;
+	unsigned char operator >= (const String &rhs) const;
+	unsigned char equalsIgnoreCase(const String &s) const;
+	unsigned char startsWith( const String &prefix) const;
+	unsigned char startsWith(const String &prefix, unsigned int offset) const;
+	unsigned char endsWith(const String &suffix) const;
+
+	// character acccess
+	char charAt(unsigned int index) const;
+	void setCharAt(unsigned int index, char c);
+	char operator [] (unsigned int index) const;
+	char& operator [] (unsigned int index);
+	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
+	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
+		{getBytes((unsigned char *)buf, bufsize, index);}
+
+	// search
+	int indexOf( char ch ) const;
+	int indexOf( char ch, unsigned int fromIndex ) const;
+	int indexOf( const String &str ) const;
+	int indexOf( const String &str, unsigned int fromIndex ) const;
+	int lastIndexOf( char ch ) const;
+	int lastIndexOf( char ch, unsigned int fromIndex ) const;
+	int lastIndexOf( const String &str ) const;
+	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
+	String substring( unsigned int beginIndex ) const;
+	String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+
+	// modification
+	void replace(char find, char replace);
+	void replace(const String& find, const String& replace);
+	void toLowerCase(void);
+	void toUpperCase(void);
+	void trim(void);
+
+	// parsing/conversion
+	long toInt(void) const;
+
+protected:
+	char *buffer;	        // the actual char array
+	unsigned int capacity;  // the array length minus one (for the '\0')
+	unsigned int len;       // the String length (not counting the '\0')
+	unsigned char flags;    // unused, for future features
+protected:
+	void init(void);
+	void invalidate(void);
+	unsigned char changeBuffer(unsigned int maxStrLen);
+	unsigned char concat(const char *cstr, unsigned int length);
+
+	// copy and move
+	String & copy(const char *cstr, unsigned int length);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	void move(String &rhs);
+	#endif
+};
+
+class StringSumHelper : public String
+{
+public:
+	StringSumHelper(const String &s) : String(s) {}
+	StringSumHelper(const char *p) : String(p) {}
+	StringSumHelper(char c) : String(c) {}
+	StringSumHelper(unsigned char num) : String(num) {}
+	StringSumHelper(int num) : String(num) {}
+	StringSumHelper(unsigned int num) : String(num) {}
+	StringSumHelper(long num) : String(num) {}
+	StringSumHelper(unsigned long num) : String(num) {}
+};
+
+#endif  // __cplusplus
+#endif  // String_class_h
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/binary.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/main.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/main.cpp
new file mode 100644
index 0000000..3d4e079
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/main.cpp
@@ -0,0 +1,20 @@
+#include <Arduino.h>
+
+int main(void)
+{
+	init();
+
+#if defined(USBCON)
+	USBDevice.attach();
+#endif
+	
+	setup();
+    
+	for (;;) {
+		loop();
+		if (serialEventRun) serialEventRun();
+	}
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.cpp
new file mode 100644
index 0000000..0f6d422
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.cpp
@@ -0,0 +1,18 @@
+#include <new.h>
+
+void * operator new(size_t size)
+{
+  return malloc(size);
+}
+
+void operator delete(void * ptr)
+{
+  free(ptr);
+} 
+
+int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
+void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
+void __cxa_guard_abort (__guard *) {}; 
+
+void __cxa_pure_virtual(void) {};
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.h
new file mode 100644
index 0000000..cd940ce
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/new.h
@@ -0,0 +1,22 @@
+/* Header to define new/delete operators as they aren't provided by avr-gcc by default
+   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=59453 
+ */
+
+#ifndef NEW_H
+#define NEW_H
+
+#include <stdlib.h>
+
+void * operator new(size_t size);
+void operator delete(void * ptr); 
+
+__extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+extern "C" int __cxa_guard_acquire(__guard *);
+extern "C" void __cxa_guard_release (__guard *);
+extern "C" void __cxa_guard_abort (__guard *); 
+
+extern "C" void __cxa_pure_virtual(void);
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring.c
new file mode 100644
index 0000000..ac8bb6f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring.c
@@ -0,0 +1,324 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
+SIGNAL(TIM0_OVF_vect)
+#else
+SIGNAL(TIMER0_OVF_vect)
+#endif
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+#if F_CPU >= 20000000L
+	// for the 20 MHz clock on rare Arduino boards
+
+	// for a one-microsecond delay, simply wait 2 cycle and return. The overhead
+	// of the function call yields a delay of exactly a one microsecond.
+	__asm__ __volatile__ (
+		"nop" "\n\t"
+		"nop"); //just waiting 2 cycle
+	if (--us == 0)
+		return;
+
+	// the following loop takes a 1/5 of a microsecond (4 cycles)
+	// per iteration, so execute it five times for each microsecond of
+	// delay requested.
+	us = (us<<2) + us; // x5 us
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+
+#elif F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1B, CS10);
+#endif
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1, CS10);
+#endif
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
+	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
+	sbi(TCCR4B, CS41);
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
+	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
+	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
+#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+#endif /* end timer4 block for ATMEGA1280/2560 and similar */	
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..23b01c6
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_analog.c
@@ -0,0 +1,282 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega32U4__)
+	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+	
+#if defined(__AVR_ATmega32U4__)
+	pin = analogPinToChannel(pin);
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#elif defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A)
+			case TIMER4A:
+				//connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				#if defined(COM4A0)		// only used on 32U4
+				cbi(TCCR4A, COM4A0);
+				#endif
+				OCR4A = val;	// set pwm duty
+				break;
+			#endif
+			
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+				
+			#if defined(TCCR4C) && defined(COM4D1)
+			case TIMER4D:				
+				// connect pwm to pin on timer 4, channel D
+				sbi(TCCR4C, COM4D1);
+				#if defined(COM4D0)		// only used on 32U4
+				cbi(TCCR4C, COM4D0);
+				#endif
+				OCR4D = val;	// set pwm duty
+				break;
+			#endif
+
+							
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..be323b1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_digital.c
@@ -0,0 +1,178 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#define ARDUINO_MAIN
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg, *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+	out = portOutputRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else if (mode == INPUT_PULLUP) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out |= bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif					
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif			
+		#if defined(TCCR4C) && defined(COM4D1)
+		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
+		#endif			
+			
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	uint8_t oldSREG = SREG;
+	cli();
+
+	if (val == LOW) {
+		*out &= ~bit;
+	} else {
+		*out |= bit;
+	}
+
+	SREG = oldSREG;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..f678265
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_private.h
@@ -0,0 +1,71 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Arduino.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+#define EXTERNAL_NUM_INTERRUPTS 3
+#elif defined(__AVR_ATmega32U4__)
+#define EXTERNAL_NUM_INTERRUPTS 4
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/variants/standard/pins_arduino.h b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/variants/standard/pins_arduino.h
new file mode 100644
index 0000000..499952d
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/Sanguino/variants/standard/pins_arduino.h
@@ -0,0 +1,285 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+
+  Changelog
+  -----------
+  11/25/11  - ryan@ryanmsutton.com - Add pins for Sanguino 644P and 1284P
+  07/15/12  - ryan@ryanmsutton.com - Updated for arduino0101
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+#define TIMER3A 8
+#define TIMER3B 9
+#define TIMER3C 10
+#define TIMER4A 11
+#define TIMER4B 12
+#define TIMER4C 13
+#define TIMER5A 14
+#define TIMER5B 15
+#define TIMER5C 16
+
+const static uint8_t SS   = 4;
+const static uint8_t MOSI = 5;
+const static uint8_t MISO = 6;
+const static uint8_t SCK  = 7;
+
+static const uint8_t SDA = 17;
+static const uint8_t SCL = 16;
+static const uint8_t LED_BUILTIN = 13;
+
+static const uint8_t A0 = 31;
+static const uint8_t A1 = 30;
+static const uint8_t A2 = 29;
+static const uint8_t A3 = 28;
+static const uint8_t A4 = 27;
+static const uint8_t A5 = 26;
+static const uint8_t A6 = 25;
+static const uint8_t A7 = 24;
+
+// On the ATmega1280, the addresses of some of the port registers are
+// greater than 255, so we can't store them in uint8_t's.
+// extern const uint16_t PROGMEM port_to_mode_PGM[];
+// extern const uint16_t PROGMEM port_to_input_PGM[];
+// extern const uint16_t PROGMEM port_to_output_PGM[];
+
+// extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+#define NUM_DIGITAL_PINS            24
+#define NUM_ANALOG_INPUTS           8
+#define analogInputToDigitalPin(p)  ((p < 7) ? (p) + 24 : -1)
+
+#define digitalPinHasPWM(p)         ((p) == 3 || (p) == 4 || (p) == 12 || (p) == 13 || (p) == 14 || (p) == 15 )
+
+#define digitalPinToPCICR(p)    ( (((p) >= 0) && ((p) <= 31)) ? (&PCICR) : ((uint8_t *)0) )
+
+#define digitalPinToPCICRbit(p) ( (((p) >= 24) && ((p) <= 31)) ? 0 : \
+                                ( (((p) >=  0) && ((p) <=  7)) ? 1 : \
+                                ( (((p) >= 16) && ((p) <= 23)) ? 2 : \
+                                ( (((p) >=  8) && ((p) <= 15)) ? 3 : \
+                                0 ) ) ) )
+
+#define digitalPinToPCMSK(p)    ( (((p) >= 24) && ((p) <= 31)) ? (&PCMSK0) : \
+                                ( (((p) >=  0) && ((p) <=  7)) ? (&PCMSK1) : \
+                                ( (((p) >= 16) && ((p) <= 23)) ? (&PCMSK2) : \
+                                ( (((p) >=  8) && ((p) <= 15)) ? (&PCMSK3) : \
+                                ((uint8_t *)0) ) ) ) )
+
+
+#define digitalPinToPCMSKbit(p) ( (((p) >= 24) && ((p) <= 31)) ? (31 - (p)) : \
+                                ( (((p) >=  0) && ((p) <=  7)) ? (p) : \
+                                ( (((p) >= 16) && ((p) <= 23)) ? ((p) - 16) : \
+                                ( (((p) >=  8) && ((p) <= 15)) ? ((p) - 8) : \
+                                0 ) ) ) )
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+#define PE 5
+#define PF 6
+#define PG 7
+#define PH 8
+#define PJ 10
+#define PK 11
+#define PL 12
+
+#ifdef ARDUINO_MAIN
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint16_t PROGMEM port_to_mode_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &DDRA,
+        (uint16_t) &DDRB,
+        (uint16_t) &DDRC,
+        (uint16_t) &DDRD,
+};
+
+const uint16_t PROGMEM port_to_output_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &PORTA,
+        (uint16_t) &PORTB,
+        (uint16_t) &PORTC,
+        (uint16_t) &PORTD,
+};
+const uint16_t PROGMEM port_to_input_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &PINA,
+        (uint16_t) &PINB,
+        (uint16_t) &PINC,
+        (uint16_t) &PIND,
+};
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+        PB, /* 0 */
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PD, /* 8 */
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PC, /* 16 */
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PA, /* 24 */
+        PA,
+        PA,
+        PA,
+        PA,
+        PA,
+        PA,
+        PA  /* 31 */
+};
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+        _BV(0), /* 0, port B */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(0), /* 8, port D */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(0), /* 16, port C */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(7), /* 24, port A */
+        _BV(6),
+        _BV(5),
+        _BV(4),
+        _BV(3),
+        _BV(2),
+        _BV(1),
+        _BV(0)
+};
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+        NOT_ON_TIMER,   /* 0  - PB0 */
+        NOT_ON_TIMER,   /* 1  - PB1 */
+        NOT_ON_TIMER,   /* 2  - PB2 */
+        TIMER0A,        /* 3  - PB3 */
+        TIMER0B,                /* 4  - PB4 */
+        NOT_ON_TIMER,   /* 5  - PB5 */
+        NOT_ON_TIMER,   /* 6  - PB6 */
+        NOT_ON_TIMER,   /* 7  - PB7 */
+        NOT_ON_TIMER,   /* 8  - PD0 */
+        NOT_ON_TIMER,   /* 9  - PD1 */
+        NOT_ON_TIMER,   /* 10 - PD2 */
+        NOT_ON_TIMER,   /* 11 - PD3 */
+        TIMER1B,        /* 12 - PD4 */
+        TIMER1A,        /* 13 - PD5 */
+        TIMER2B,        /* 14 - PD6 */
+        TIMER2A,        /* 15 - PD7 */
+        NOT_ON_TIMER,   /* 16 - PC0 */
+        NOT_ON_TIMER,   /* 17 - PC1 */
+        NOT_ON_TIMER,   /* 18 - PC2 */
+        NOT_ON_TIMER,   /* 19 - PC3 */
+        NOT_ON_TIMER,   /* 20 - PC4 */
+        NOT_ON_TIMER,   /* 21 - PC5 */
+        NOT_ON_TIMER,   /* 22 - PC6 */
+        NOT_ON_TIMER,   /* 23 - PC7 */
+        NOT_ON_TIMER,   /* 24 - PA0 */
+        NOT_ON_TIMER,   /* 25 - PA1 */
+        NOT_ON_TIMER,   /* 26 - PA2 */
+        NOT_ON_TIMER,   /* 27 - PA3 */
+        NOT_ON_TIMER,   /* 28 - PA4 */
+        NOT_ON_TIMER,   /* 29 - PA5 */
+        NOT_ON_TIMER,   /* 30 - PA6 */
+        NOT_ON_TIMER   /* 31 - PA7 */
+};
+#endif
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/boards.txt b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/boards.txt
new file mode 100644
index 0000000..d090165
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/boards.txt
@@ -0,0 +1,22 @@
+# See: http://code.google.com/p/arduino/wiki/Platforms
+
+##############################################################
+
+mega2560.name=RAMBo
+
+mega2560.upload.protocol=wiring
+mega2560.upload.maximum_size=258048
+mega2560.upload.speed=115200
+
+mega2560.bootloader.low_fuses=0xFF
+mega2560.bootloader.high_fuses=0xD8
+mega2560.bootloader.extended_fuses=0xFD
+mega2560.bootloader.path=stk500v2
+mega2560.bootloader.file=stk500boot_v2_mega2560.hex
+mega2560.bootloader.unlock_bits=0x3F
+mega2560.bootloader.lock_bits=0x0F
+
+mega2560.build.mcu=atmega2560
+mega2560.build.f_cpu=16000000L
+mega2560.build.core=arduino
+mega2560.build.variant=standard
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Arduino.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Arduino.h
new file mode 100644
index 0000000..b265825
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Arduino.h
@@ -0,0 +1,215 @@
+#ifndef Arduino_h
+#define Arduino_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/pgmspace.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+#define INPUT_PULLUP 0x2
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
+#define DEFAULT 0
+#define EXTERNAL 1
+#define INTERNAL 2
+#else  
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+#endif
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+
+#define analogInPinToBit(P) (P)
+
+// On the ATmega1280, the addresses of some of the port registers are
+// greater than 255, so we can't store them in uint8_t's.
+extern const uint16_t PROGMEM port_to_mode_PGM[];
+extern const uint16_t PROGMEM port_to_input_PGM[];
+extern const uint16_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#ifdef ARDUINO_MAIN
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+#define PE 5
+#define PF 6
+#define PG 7
+#define PH 8
+#define PJ 10
+#define PK 11
+#define PL 12
+#endif
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+#define TIMER3A 8
+#define TIMER3B 9
+#define TIMER3C 10
+#define TIMER4A 11
+#define TIMER4B 12
+#define TIMER4C 13
+#define TIMER4D 14	
+#define TIMER5A 15
+#define TIMER5B 16
+#define TIMER5C 17
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#endif
+
+#include "pins_arduino.h"
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/CDC.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/CDC.cpp
new file mode 100644
index 0000000..701e483
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/CDC.cpp
@@ -0,0 +1,239 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include <avr/wdt.h>
+
+#if defined(USBCON)
+#ifdef CDC_ENABLED
+
+#if (RAMEND < 1000)
+#define SERIAL_BUFFER_SIZE 16
+#else
+#define SERIAL_BUFFER_SIZE 64
+#endif
+
+struct ring_buffer
+{
+	unsigned char buffer[SERIAL_BUFFER_SIZE];
+	volatile int head;
+	volatile int tail;
+};
+
+ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
+
+typedef struct
+{
+	u32	dwDTERate;
+	u8	bCharFormat;
+	u8 	bParityType;
+	u8 	bDataBits;
+	u8	lineState;
+} LineInfo;
+
+static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
+
+#define WEAK __attribute__ ((weak))
+
+extern const CDCDescriptor _cdcInterface PROGMEM;
+const CDCDescriptor _cdcInterface =
+{
+	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
+
+	//	CDC communication interface
+	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
+	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
+	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
+	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported
+	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, data interface is slave 0
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
+
+	//	CDC data interface
+	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
+	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
+};
+
+int WEAK CDC_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 2;	// uses 2
+	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
+}
+
+bool WEAK CDC_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_GET_LINE_CODING == r)
+		{
+			USB_SendControl(0,(void*)&_usbLineInfo,7);
+			return true;
+		}
+	}
+
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_SET_LINE_CODING == r)
+		{
+			USB_RecvControl((void*)&_usbLineInfo,7);
+			return true;
+		}
+
+		if (CDC_SET_CONTROL_LINE_STATE == r)
+		{
+			_usbLineInfo.lineState = setup.wValueL;
+
+			// auto-reset into the bootloader is triggered when the port, already 
+			// open at 1200 bps, is closed.  this is the signal to start the watchdog
+			// with a relatively long period so it can finish housekeeping tasks
+			// like servicing endpoints before the sketch ends
+			if (1200 == _usbLineInfo.dwDTERate) {
+				// We check DTR state to determine if host port is open (bit 0 of lineState).
+				if ((_usbLineInfo.lineState & 0x01) == 0) {
+					*(uint16_t *)0x0800 = 0x7777;
+					wdt_enable(WDTO_120MS);
+				} else {
+					// Most OSs do some intermediate steps when configuring ports and DTR can
+					// twiggle more than once before stabilizing.
+					// To avoid spurious resets we set the watchdog to 250ms and eventually
+					// cancel if DTR goes back high.
+	
+					wdt_disable();
+					wdt_reset();
+					*(uint16_t *)0x0800 = 0x0;
+				}
+			}
+			return true;
+		}
+	}
+	return false;
+}
+
+
+int _serialPeek = -1;
+void Serial_::begin(uint16_t baud_count)
+{
+}
+
+void Serial_::end(void)
+{
+}
+
+void Serial_::accept(void) 
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
+	
+	// if we should be storing the received character into the location
+	// just before the tail (meaning that the head would advance to the
+	// current location of the tail), we're about to overflow the buffer
+	// and so we don't write the character or advance the head.
+
+	// while we have room to store a byte
+	while (i != buffer->tail) {
+		int c = USB_Recv(CDC_RX);
+		if (c == -1)
+			break;	// no more data
+		buffer->buffer[buffer->head] = c;
+		buffer->head = i;
+
+		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
+	}
+}
+
+int Serial_::available(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int Serial_::peek(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		return buffer->buffer[buffer->tail];
+	}
+}
+
+int Serial_::read(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	// if the head isn't ahead of the tail, we don't have any characters
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		unsigned char c = buffer->buffer[buffer->tail];
+		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+		return c;
+	}	
+}
+
+void Serial_::flush(void)
+{
+	USB_Flush(CDC_TX);
+}
+
+size_t Serial_::write(uint8_t c)
+{
+	/* only try to send bytes if the high-level CDC connection itself 
+	 is open (not just the pipe) - the OS should set lineState when the port
+	 is opened and clear lineState when the port is closed.
+	 bytes sent before the user opens the connection or after
+	 the connection is closed are lost - just like with a UART. */
+	
+	// TODO - ZE - check behavior on different OSes and test what happens if an
+	// open connection isn't broken cleanly (cable is yanked out, host dies
+	// or locks up, or host virtual serial port hangs)
+	if (_usbLineInfo.lineState > 0)	{
+		int r = USB_Send(CDC_TX,&c,1);
+		if (r > 0) {
+			return r;
+		} else {
+			setWriteError();
+			return 0;
+		}
+	}
+	setWriteError();
+	return 0;
+}
+
+// This operator is a convenient way for a sketch to check whether the
+// port has actually been configured and opened by the host (as opposed
+// to just being connected to the host).  It can be used, for example, in 
+// setup() before printing to ensure that an application on the host is
+// actually ready to receive and display the data.
+// We add a short delay before returning to fix a bug observed by Federico
+// where the port is configured (lineState != 0) but not quite opened.
+Serial_::operator bool() {
+	bool result = false;
+	if (_usbLineInfo.lineState > 0) 
+		result = true;
+	delay(10);
+	return result;
+}
+
+Serial_ Serial;
+
+#endif
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Client.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Client.h
new file mode 100644
index 0000000..ea13483
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Client.h
@@ -0,0 +1,26 @@
+#ifndef client_h
+#define client_h
+#include "Print.h"
+#include "Stream.h"
+#include "IPAddress.h"
+
+class Client : public Stream {
+
+public:
+  virtual int connect(IPAddress ip, uint16_t port) =0;
+  virtual int connect(const char *host, uint16_t port) =0;
+  virtual size_t write(uint8_t) =0;
+  virtual size_t write(const uint8_t *buf, size_t size) =0;
+  virtual int available() = 0;
+  virtual int read() = 0;
+  virtual int read(uint8_t *buf, size_t size) = 0;
+  virtual int peek() = 0;
+  virtual void flush() = 0;
+  virtual void stop() = 0;
+  virtual uint8_t connected() = 0;
+  virtual operator bool() = 0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HID.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HID.cpp
new file mode 100644
index 0000000..ac63608
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HID.cpp
@@ -0,0 +1,520 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+#ifdef HID_ENABLED
+
+//#define RAWHID_ENABLED
+
+//	Singletons for mouse and keyboard
+
+Mouse_ Mouse;
+Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+
+//	HID report descriptor
+
+#define LSB(_x) ((_x) & 0xFF)
+#define MSB(_x) ((_x) >> 8)
+
+#define RAWHID_USAGE_PAGE	0xFFC0
+#define RAWHID_USAGE		0x0C00
+#define RAWHID_TX_SIZE 64
+#define RAWHID_RX_SIZE 64
+
+extern const u8 _hidReportDescriptor[] PROGMEM;
+const u8 _hidReportDescriptor[] = {
+	
+	//	Mouse
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 54
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xa1, 0x00,                    //   COLLECTION (Physical)
+    0x85, 0x01,                    //     REPORT_ID (1)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
+    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xc0,                          //   END_COLLECTION
+    0xc0,                          // END_COLLECTION
+
+	//	Keyboard
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 47
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x85, 0x02,                    //   REPORT_ID (2)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+   
+	0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    
+	0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
+    
+	0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+    
+	0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0,                          // END_COLLECTION
+
+#if RAWHID_ENABLED
+	//	RAW HID
+	0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),	// 30
+	0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
+
+	0xA1, 0x01,				// Collection 0x01
+    0x85, 0x03,             // REPORT_ID (3)
+	0x75, 0x08,				// report size = 8 bits
+	0x15, 0x00,				// logical minimum = 0
+	0x26, 0xFF, 0x00,		// logical maximum = 255
+
+	0x95, 64,				// report count TX
+	0x09, 0x01,				// usage
+	0x81, 0x02,				// Input (array)
+
+	0x95, 64,				// report count RX
+	0x09, 0x02,				// usage
+	0x91, 0x02,				// Output (array)
+	0xC0					// end collection
+#endif
+};
+
+extern const HIDDescriptor _hidInterface PROGMEM;
+const HIDDescriptor _hidInterface =
+{
+	D_INTERFACE(HID_INTERFACE,1,3,0,0),
+	D_HIDREPORT(sizeof(_hidReportDescriptor)),
+	D_ENDPOINT(USB_ENDPOINT_IN (HID_ENDPOINT_INT),USB_ENDPOINT_TYPE_INTERRUPT,0x40,0x01)
+};
+
+//================================================================================
+//================================================================================
+//	Driver
+
+u8 _hid_protocol = 1;
+u8 _hid_idle = 1;
+
+#define WEAK __attribute__ ((weak))
+
+int WEAK HID_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 1;	// uses 1
+	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
+}
+
+int WEAK HID_GetDescriptor(int i)
+{
+	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
+}
+
+void WEAK HID_SendReport(u8 id, const void* data, int len)
+{
+	USB_Send(HID_TX, &id, 1);
+	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
+}
+
+bool WEAK HID_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (HID_GET_REPORT == r)
+		{
+			//HID_GetReport();
+			return true;
+		}
+		if (HID_GET_PROTOCOL == r)
+		{
+			//Send8(_hid_protocol);	// TODO
+			return true;
+		}
+	}
+	
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (HID_SET_PROTOCOL == r)
+		{
+			_hid_protocol = setup.wValueL;
+			return true;
+		}
+
+		if (HID_SET_IDLE == r)
+		{
+			_hid_idle = setup.wValueL;
+			return true;
+		}
+	}
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+Mouse_::Mouse_(void) : _buttons(0)
+{
+}
+
+void Mouse_::begin(void) 
+{
+}
+
+void Mouse_::end(void) 
+{
+}
+
+void Mouse_::click(uint8_t b)
+{
+	_buttons = b;
+	move(0,0,0);
+	_buttons = 0;
+	move(0,0,0);
+}
+
+void Mouse_::move(signed char x, signed char y, signed char wheel)
+{
+	u8 m[4];
+	m[0] = _buttons;
+	m[1] = x;
+	m[2] = y;
+	m[3] = wheel;
+	HID_SendReport(1,m,4);
+}
+
+void Mouse_::buttons(uint8_t b)
+{
+	if (b != _buttons)
+	{
+		_buttons = b;
+		move(0,0,0);
+	}
+}
+
+void Mouse_::press(uint8_t b) 
+{
+	buttons(_buttons | b);
+}
+
+void Mouse_::release(uint8_t b)
+{
+	buttons(_buttons & ~b);
+}
+
+bool Mouse_::isPressed(uint8_t b)
+{
+	if ((b & _buttons) > 0) 
+		return true;
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+Keyboard_::Keyboard_(void) 
+{
+}
+
+void Keyboard_::begin(void) 
+{
+}
+
+void Keyboard_::end(void) 
+{
+}
+
+void Keyboard_::sendReport(KeyReport* keys)
+{
+	HID_SendReport(2,keys,sizeof(KeyReport));
+}
+
+extern
+const uint8_t _asciimap[128] PROGMEM;
+
+#define SHIFT 0x80
+const uint8_t _asciimap[128] =
+{
+	0x00,             // NUL
+	0x00,             // SOH
+	0x00,             // STX
+	0x00,             // ETX
+	0x00,             // EOT
+	0x00,             // ENQ
+	0x00,             // ACK  
+	0x00,             // BEL
+	0x2a,			// BS	Backspace
+	0x2b,			// TAB	Tab
+	0x28,			// LF	Enter
+	0x00,             // VT 
+	0x00,             // FF 
+	0x00,             // CR 
+	0x00,             // SO 
+	0x00,             // SI 
+	0x00,             // DEL
+	0x00,             // DC1
+	0x00,             // DC2
+	0x00,             // DC3
+	0x00,             // DC4
+	0x00,             // NAK
+	0x00,             // SYN
+	0x00,             // ETB
+	0x00,             // CAN
+	0x00,             // EM 
+	0x00,             // SUB
+	0x00,             // ESC
+	0x00,             // FS 
+	0x00,             // GS 
+	0x00,             // RS 
+	0x00,             // US 
+
+	0x2c,		   //  ' '
+	0x1e|SHIFT,	   // !
+	0x34|SHIFT,	   // "
+	0x20|SHIFT,    // #
+	0x21|SHIFT,    // $
+	0x22|SHIFT,    // %
+	0x24|SHIFT,    // &
+	0x34,          // '
+	0x26|SHIFT,    // (
+	0x27|SHIFT,    // )
+	0x25|SHIFT,    // *
+	0x2e|SHIFT,    // +
+	0x36,          // ,
+	0x2d,          // -
+	0x37,          // .
+	0x38,          // /
+	0x27,          // 0
+	0x1e,          // 1
+	0x1f,          // 2
+	0x20,          // 3
+	0x21,          // 4
+	0x22,          // 5
+	0x23,          // 6
+	0x24,          // 7
+	0x25,          // 8
+	0x26,          // 9
+	0x33|SHIFT,      // :
+	0x33,          // ;
+	0x36|SHIFT,      // <
+	0x2e,          // =
+	0x37|SHIFT,      // >
+	0x38|SHIFT,      // ?
+	0x1f|SHIFT,      // @
+	0x04|SHIFT,      // A
+	0x05|SHIFT,      // B
+	0x06|SHIFT,      // C
+	0x07|SHIFT,      // D
+	0x08|SHIFT,      // E
+	0x09|SHIFT,      // F
+	0x0a|SHIFT,      // G
+	0x0b|SHIFT,      // H
+	0x0c|SHIFT,      // I
+	0x0d|SHIFT,      // J
+	0x0e|SHIFT,      // K
+	0x0f|SHIFT,      // L
+	0x10|SHIFT,      // M
+	0x11|SHIFT,      // N
+	0x12|SHIFT,      // O
+	0x13|SHIFT,      // P
+	0x14|SHIFT,      // Q
+	0x15|SHIFT,      // R
+	0x16|SHIFT,      // S
+	0x17|SHIFT,      // T
+	0x18|SHIFT,      // U
+	0x19|SHIFT,      // V
+	0x1a|SHIFT,      // W
+	0x1b|SHIFT,      // X
+	0x1c|SHIFT,      // Y
+	0x1d|SHIFT,      // Z
+	0x2f,          // [
+	0x31,          // bslash
+	0x30,          // ]
+	0x23|SHIFT,    // ^
+	0x2d|SHIFT,    // _
+	0x35,          // `
+	0x04,          // a
+	0x05,          // b
+	0x06,          // c
+	0x07,          // d
+	0x08,          // e
+	0x09,          // f
+	0x0a,          // g
+	0x0b,          // h
+	0x0c,          // i
+	0x0d,          // j
+	0x0e,          // k
+	0x0f,          // l
+	0x10,          // m
+	0x11,          // n
+	0x12,          // o
+	0x13,          // p
+	0x14,          // q
+	0x15,          // r
+	0x16,          // s
+	0x17,          // t
+	0x18,          // u
+	0x19,          // v
+	0x1a,          // w
+	0x1b,          // x
+	0x1c,          // y
+	0x1d,          // z
+	0x2f|SHIFT,    // 
+	0x31|SHIFT,    // |
+	0x30|SHIFT,    // }
+	0x35|SHIFT,    // ~
+	0				// DEL
+};
+
+uint8_t USBPutChar(uint8_t c);
+
+// press() adds the specified key (printing, non-printing, or modifier)
+// to the persistent key report and sends the report.  Because of the way 
+// USB HID works, the host acts like the key remains pressed until we 
+// call release(), releaseAll(), or otherwise clear the report and resend.
+size_t Keyboard_::press(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers |= (1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			setWriteError();
+			return 0;
+		}
+		if (k & 0x80) {						// it's a capital letter or other character reached with shift
+			_keyReport.modifiers |= 0x02;	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Add k to the key report only if it's not already present
+	// and if there is an empty slot.
+	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
+		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
+		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
+		
+		for (i=0; i<6; i++) {
+			if (_keyReport.keys[i] == 0x00) {
+				_keyReport.keys[i] = k;
+				break;
+			}
+		}
+		if (i == 6) {
+			setWriteError();
+			return 0;
+		}	
+	}
+	sendReport(&_keyReport);
+	return 1;
+}
+
+// release() takes the specified key out of the persistent key report and
+// sends the report.  This tells the OS the key is no longer pressed and that
+// it shouldn't be repeated any more.
+size_t Keyboard_::release(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers &= ~(1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			return 0;
+		}
+		if (k & 0x80) {							// it's a capital letter or other character reached with shift
+			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Test the key report to see if k is present.  Clear it if it exists.
+	// Check all positions in case the key is present more than once (which it shouldn't be)
+	for (i=0; i<6; i++) {
+		if (0 != k && _keyReport.keys[i] == k) {
+			_keyReport.keys[i] = 0x00;
+		}
+	}
+
+	sendReport(&_keyReport);
+	return 1;
+}
+
+void Keyboard_::releaseAll(void)
+{
+	_keyReport.keys[0] = 0;
+	_keyReport.keys[1] = 0;	
+	_keyReport.keys[2] = 0;
+	_keyReport.keys[3] = 0;	
+	_keyReport.keys[4] = 0;
+	_keyReport.keys[5] = 0;	
+	_keyReport.modifiers = 0;
+	sendReport(&_keyReport);
+}
+
+size_t Keyboard_::write(uint8_t c)
+{	
+	uint8_t p = press(c);		// Keydown
+	uint8_t r = release(c);		// Keyup
+	return (p);					// just return the result of press() since release() almost always returns 1
+}
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..794a7be
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,519 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+  Modified 14 August 2012 by Alarus
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "Arduino.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+/*
+ * on ATmega8, the uart and its bits are not numbered, so there is no "TXC0"
+ * definition.
+ */
+#if !defined(TXC0)
+#if defined(TXC)
+#define TXC0 TXC
+#elif defined(TXC1)
+// Some devices have uart1 but no uart0
+#define TXC0 TXC1
+#else
+#error TXC0 not definable in HardwareSerial.h
+#endif
+#endif
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which head is the index of the location
+// to which to write the next incoming character and tail is the index of the
+// location from which to read.
+#if (RAMEND < 1000)
+  #define SERIAL_BUFFER_SIZE 16
+#else
+  #define SERIAL_BUFFER_SIZE 64
+#endif
+
+struct ring_buffer
+{
+  unsigned char buffer[SERIAL_BUFFER_SIZE];
+  volatile unsigned int head;
+  volatile unsigned int tail;
+};
+
+#if defined(USBCON)
+  ring_buffer rx_buffer = { { 0 }, 0, 0};
+  ring_buffer tx_buffer = { { 0 }, 0, 0};
+#endif
+#if defined(UBRRH) || defined(UBRR0H)
+  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR1H)
+  ring_buffer rx_buffer1  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR2H)
+  ring_buffer rx_buffer2  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer2  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR3H)
+  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *buffer)
+{
+  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != buffer->tail) {
+    buffer->buffer[buffer->head] = c;
+    buffer->head = i;
+  }
+}
+
+#if !defined(USART0_RX_vect) && defined(USART1_RX_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(USART_RX_vect) && !defined(SIG_USART0_RECV) && \
+    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
+	!defined(SIG_UART_RECV)
+  #error "Don't know what the Data Received vector is called for the first UART"
+#else
+  void serialEvent() __attribute__((weak));
+  void serialEvent() {}
+  #define serialEvent_implemented
+#if defined(USART_RX_vect)
+  SIGNAL(USART_RX_vect)
+#elif defined(SIG_USART0_RECV)
+  SIGNAL(SIG_USART0_RECV)
+#elif defined(SIG_UART0_RECV)
+  SIGNAL(SIG_UART0_RECV)
+#elif defined(USART0_RX_vect)
+  SIGNAL(USART0_RX_vect)
+#elif defined(SIG_UART_RECV)
+  SIGNAL(SIG_UART_RECV)
+#endif
+  {
+  #if defined(UDR0)
+    if (bit_is_clear(UCSR0A, UPE0)) {
+      unsigned char c = UDR0;
+      store_char(c, &rx_buffer);
+    } else {
+      unsigned char c = UDR0;
+    };
+  #elif defined(UDR)
+    if (bit_is_clear(UCSRA, PE)) {
+      unsigned char c = UDR;
+      store_char(c, &rx_buffer);
+    } else {
+      unsigned char c = UDR;
+    };
+  #else
+    #error UDR not defined
+  #endif
+  }
+#endif
+#endif
+
+#if defined(USART1_RX_vect)
+  void serialEvent1() __attribute__((weak));
+  void serialEvent1() {}
+  #define serialEvent1_implemented
+  SIGNAL(USART1_RX_vect)
+  {
+    if (bit_is_clear(UCSR1A, UPE1)) {
+      unsigned char c = UDR1;
+      store_char(c, &rx_buffer1);
+    } else {
+      unsigned char c = UDR1;
+    };
+  }
+#elif defined(SIG_USART1_RECV)
+  #error SIG_USART1_RECV
+#endif
+
+#if defined(USART2_RX_vect) && defined(UDR2)
+  void serialEvent2() __attribute__((weak));
+  void serialEvent2() {}
+  #define serialEvent2_implemented
+  SIGNAL(USART2_RX_vect)
+  {
+    if (bit_is_clear(UCSR2A, UPE2)) {
+      unsigned char c = UDR2;
+      store_char(c, &rx_buffer2);
+    } else {
+      unsigned char c = UDR2;
+    };
+  }
+#elif defined(SIG_USART2_RECV)
+  #error SIG_USART2_RECV
+#endif
+
+#if defined(USART3_RX_vect) && defined(UDR3)
+  void serialEvent3() __attribute__((weak));
+  void serialEvent3() {}
+  #define serialEvent3_implemented
+  SIGNAL(USART3_RX_vect)
+  {
+    if (bit_is_clear(UCSR3A, UPE3)) {
+      unsigned char c = UDR3;
+      store_char(c, &rx_buffer3);
+    } else {
+      unsigned char c = UDR3;
+    };
+  }
+#elif defined(SIG_USART3_RECV)
+  #error SIG_USART3_RECV
+#endif
+
+void serialEventRun(void)
+{
+#ifdef serialEvent_implemented
+  if (Serial.available()) serialEvent();
+#endif
+#ifdef serialEvent1_implemented
+  if (Serial1.available()) serialEvent1();
+#endif
+#ifdef serialEvent2_implemented
+  if (Serial2.available()) serialEvent2();
+#endif
+#ifdef serialEvent3_implemented
+  if (Serial3.available()) serialEvent3();
+#endif
+}
+
+
+#if !defined(USART0_UDRE_vect) && defined(USART1_UDRE_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(UART0_UDRE_vect) && !defined(UART_UDRE_vect) && !defined(USART0_UDRE_vect) && !defined(USART_UDRE_vect)
+  #error "Don't know what the Data Register Empty vector is called for the first UART"
+#else
+#if defined(UART0_UDRE_vect)
+ISR(UART0_UDRE_vect)
+#elif defined(UART_UDRE_vect)
+ISR(UART_UDRE_vect)
+#elif defined(USART0_UDRE_vect)
+ISR(USART0_UDRE_vect)
+#elif defined(USART_UDRE_vect)
+ISR(USART_UDRE_vect)
+#endif
+{
+  if (tx_buffer.head == tx_buffer.tail) {
+	// Buffer empty, so disable interrupts
+#if defined(UCSR0B)
+    cbi(UCSR0B, UDRIE0);
+#else
+    cbi(UCSRB, UDRIE);
+#endif
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
+    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+  #if defined(UDR0)
+    UDR0 = c;
+  #elif defined(UDR)
+    UDR = c;
+  #else
+    #error UDR not defined
+  #endif
+  }
+}
+#endif
+#endif
+
+#ifdef USART1_UDRE_vect
+ISR(USART1_UDRE_vect)
+{
+  if (tx_buffer1.head == tx_buffer1.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR1B, UDRIE1);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
+    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR1 = c;
+  }
+}
+#endif
+
+#ifdef USART2_UDRE_vect
+ISR(USART2_UDRE_vect)
+{
+  if (tx_buffer2.head == tx_buffer2.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR2B, UDRIE2);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
+    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR2 = c;
+  }
+}
+#endif
+
+#ifdef USART3_UDRE_vect
+ISR(USART3_UDRE_vect)
+{
+  if (tx_buffer3.head == tx_buffer3.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR3B, UDRIE3);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
+    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR3 = c;
+  }
+}
+#endif
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *ucsrc, volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _tx_buffer = tx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _ucsrc = ucsrc;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udrie = udrie;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(unsigned long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+
+try_again:
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+  
+  if ((baud_setting > 4095) && use_u2x)
+  {
+    use_u2x = false;
+    goto try_again;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  transmitting = false;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+  cbi(*_ucsrb, _udrie);
+}
+
+void HardwareSerial::begin(unsigned long baud, byte config)
+{
+  uint16_t baud_setting;
+  uint8_t current_config;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+
+try_again:
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+  
+  if ((baud_setting > 4095) && use_u2x)
+  {
+    use_u2x = false;
+    goto try_again;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  //set the data bits, parity, and stop bits
+#if defined(__AVR_ATmega8__)
+  config |= 0x80; // select UCSRC register (shared with UBRRH)
+#endif
+  *_ucsrc = config;
+  
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+  cbi(*_ucsrb, _udrie);
+}
+
+void HardwareSerial::end()
+{
+  // wait for transmission of outgoing data
+  while (_tx_buffer->head != _tx_buffer->tail)
+    ;
+
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+  cbi(*_ucsrb, _udrie);
+  
+  // clear any received data
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
+  while (transmitting && ! (*_ucsra & _BV(TXC0)));
+  transmitting = false;
+}
+
+size_t HardwareSerial::write(uint8_t c)
+{
+  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
+	
+  // If the output buffer is full, there's nothing for it other than to 
+  // wait for the interrupt handler to empty it a bit
+  // ???: return 0 here instead?
+  while (i == _tx_buffer->tail)
+    ;
+	
+  _tx_buffer->buffer[_tx_buffer->head] = c;
+  _tx_buffer->head = i;
+	
+  sbi(*_ucsrb, _udrie);
+  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
+  transmitting = true;
+  sbi(*_ucsra, TXC0);
+  
+  return 1;
+}
+
+HardwareSerial::operator bool() {
+	return true;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(UBRRH) && defined(UBRRL)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
+#elif defined(UBRR0H) && defined(UBRR0L)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
+#elif defined(USBCON)
+  // do nothing - Serial object and buffers are initialized in CDC code
+#else
+  #error no serial port defined  (port 0)
+#endif
+
+#if defined(UBRR1H)
+  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
+#endif
+#if defined(UBRR2H)
+  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
+#endif
+#if defined(UBRR3H)
+  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
+#endif
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..a73117f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/HardwareSerial.h
@@ -0,0 +1,115 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+  Modified 14 August 2012 by Alarus
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    ring_buffer *_tx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_ucsrc;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udrie;
+    uint8_t _u2x;
+    bool transmitting;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *ucsrc, volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x);
+    void begin(unsigned long);
+    void begin(unsigned long, uint8_t);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    virtual size_t write(uint8_t);
+    inline size_t write(unsigned long n) { return write((uint8_t)n); }
+    inline size_t write(long n) { return write((uint8_t)n); }
+    inline size_t write(unsigned int n) { return write((uint8_t)n); }
+    inline size_t write(int n) { return write((uint8_t)n); }
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+    operator bool();
+};
+
+// Define config for Serial.begin(baud, config);
+#define SERIAL_5N1 0x00
+#define SERIAL_6N1 0x02
+#define SERIAL_7N1 0x04
+#define SERIAL_8N1 0x06
+#define SERIAL_5N2 0x08
+#define SERIAL_6N2 0x0A
+#define SERIAL_7N2 0x0C
+#define SERIAL_8N2 0x0E
+#define SERIAL_5E1 0x20
+#define SERIAL_6E1 0x22
+#define SERIAL_7E1 0x24
+#define SERIAL_8E1 0x26
+#define SERIAL_5E2 0x28
+#define SERIAL_6E2 0x2A
+#define SERIAL_7E2 0x2C
+#define SERIAL_8E2 0x2E
+#define SERIAL_5O1 0x30
+#define SERIAL_6O1 0x32
+#define SERIAL_7O1 0x34
+#define SERIAL_8O1 0x36
+#define SERIAL_5O2 0x38
+#define SERIAL_6O2 0x3A
+#define SERIAL_7O2 0x3C
+#define SERIAL_8O2 0x3E
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "USBAPI.h"
+//  extern HardwareSerial Serial_;  
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+extern void serialEventRun(void) __attribute__((weak));
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.cpp
new file mode 100644
index 0000000..fe3deb7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.cpp
@@ -0,0 +1,56 @@
+
+#include <Arduino.h>
+#include <IPAddress.h>
+
+IPAddress::IPAddress()
+{
+    memset(_address, 0, sizeof(_address));
+}
+
+IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
+{
+    _address[0] = first_octet;
+    _address[1] = second_octet;
+    _address[2] = third_octet;
+    _address[3] = fourth_octet;
+}
+
+IPAddress::IPAddress(uint32_t address)
+{
+    memcpy(_address, &address, sizeof(_address));
+}
+
+IPAddress::IPAddress(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+}
+
+IPAddress& IPAddress::operator=(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+    return *this;
+}
+
+IPAddress& IPAddress::operator=(uint32_t address)
+{
+    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
+    return *this;
+}
+
+bool IPAddress::operator==(const uint8_t* addr)
+{
+    return memcmp(addr, _address, sizeof(_address)) == 0;
+}
+
+size_t IPAddress::printTo(Print& p) const
+{
+    size_t n = 0;
+    for (int i =0; i < 3; i++)
+    {
+        n += p.print(_address[i], DEC);
+        n += p.print('.');
+    }
+    n += p.print(_address[3], DEC);
+    return n;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.h
new file mode 100644
index 0000000..2585aec
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/IPAddress.h
@@ -0,0 +1,76 @@
+/*
+ *
+ * MIT License:
+ * Copyright (c) 2011 Adrian McEwen
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * adrianm@mcqn.com 1/1/2011
+ */
+
+#ifndef IPAddress_h
+#define IPAddress_h
+
+#include <Printable.h>
+
+// A class to make it easier to handle and pass around IP addresses
+
+class IPAddress : public Printable {
+private:
+    uint8_t _address[4];  // IPv4 address
+    // Access the raw byte array containing the address.  Because this returns a pointer
+    // to the internal structure rather than a copy of the address this function should only
+    // be used when you know that the usage of the returned uint8_t* will be transient and not
+    // stored.
+    uint8_t* raw_address() { return _address; };
+
+public:
+    // Constructors
+    IPAddress();
+    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
+    IPAddress(uint32_t address);
+    IPAddress(const uint8_t *address);
+
+    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
+    // to a four-byte uint8_t array is expected
+    operator uint32_t() { return *((uint32_t*)_address); };
+    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
+    bool operator==(const uint8_t* addr);
+
+    // Overloaded index operator to allow getting and setting individual octets of the address
+    uint8_t operator[](int index) const { return _address[index]; };
+    uint8_t& operator[](int index) { return _address[index]; };
+
+    // Overloaded copy operators to allow initialisation of IPAddress objects from other types
+    IPAddress& operator=(const uint8_t *address);
+    IPAddress& operator=(uint32_t address);
+
+    virtual size_t printTo(Print& p) const;
+
+    friend class EthernetClass;
+    friend class UDP;
+    friend class Client;
+    friend class Server;
+    friend class DhcpClass;
+    friend class DNSClient;
+};
+
+const IPAddress INADDR_NONE(0,0,0,0);
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Platform.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Platform.h
new file mode 100644
index 0000000..8b8f742
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Platform.h
@@ -0,0 +1,23 @@
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#include <inttypes.h>
+#include <avr/pgmspace.h>
+#include <avr/eeprom.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned long u32;
+
+#include "Arduino.h"
+
+#if defined(USBCON)
+	#include "USBDesc.h"
+	#include "USBCore.h"
+	#include "USBAPI.h"
+#endif /* if defined(USBCON) */
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.cpp
new file mode 100644
index 0000000..53961ec
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.cpp
@@ -0,0 +1,268 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "Arduino.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+size_t Print::write(const uint8_t *buffer, size_t size)
+{
+  size_t n = 0;
+  while (size--) {
+    n += write(*buffer++);
+  }
+  return n;
+}
+
+size_t Print::print(const __FlashStringHelper *ifsh)
+{
+  const char PROGMEM *p = (const char PROGMEM *)ifsh;
+  size_t n = 0;
+  while (1) {
+    unsigned char c = pgm_read_byte(p++);
+    if (c == 0) break;
+    n += write(c);
+  }
+  return n;
+}
+
+size_t Print::print(const String &s)
+{
+  size_t n = 0;
+  for (uint16_t i = 0; i < s.length(); i++) {
+    n += write(s[i]);
+  }
+  return n;
+}
+
+size_t Print::print(const char str[])
+{
+  return write(str);
+}
+
+size_t Print::print(char c)
+{
+  return write(c);
+}
+
+size_t Print::print(unsigned char b, int base)
+{
+  return print((unsigned long) b, base);
+}
+
+size_t Print::print(int n, int base)
+{
+  return print((long) n, base);
+}
+
+size_t Print::print(unsigned int n, int base)
+{
+  return print((unsigned long) n, base);
+}
+
+size_t Print::print(long n, int base)
+{
+  if (base == 0) {
+    return write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      int t = print('-');
+      n = -n;
+      return printNumber(n, 10) + t;
+    }
+    return printNumber(n, 10);
+  } else {
+    return printNumber(n, base);
+  }
+}
+
+size_t Print::print(unsigned long n, int base)
+{
+  if (base == 0) return write(n);
+  else return printNumber(n, base);
+}
+
+size_t Print::print(double n, int digits)
+{
+  return printFloat(n, digits);
+}
+
+size_t Print::println(const __FlashStringHelper *ifsh)
+{
+  size_t n = print(ifsh);
+  n += println();
+  return n;
+}
+
+size_t Print::print(const Printable& x)
+{
+  return x.printTo(*this);
+}
+
+size_t Print::println(void)
+{
+  size_t n = print('\r');
+  n += print('\n');
+  return n;
+}
+
+size_t Print::println(const String &s)
+{
+  size_t n = print(s);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const char c[])
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(char c)
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned char b, int base)
+{
+  size_t n = print(b, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(double num, int digits)
+{
+  size_t n = print(num, digits);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const Printable& x)
+{
+  size_t n = print(x);
+  n += println();
+  return n;
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+size_t Print::printNumber(unsigned long n, uint8_t base) {
+  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
+  char *str = &buf[sizeof(buf) - 1];
+
+  *str = '\0';
+
+  // prevent crash if called with base == 1
+  if (base < 2) base = 10;
+
+  do {
+    unsigned long m = n;
+    n /= base;
+    char c = m - base * n;
+    *--str = c < 10 ? c + '0' : c + 'A' - 10;
+  } while(n);
+
+  return write(str);
+}
+
+size_t Print::printFloat(double number, uint8_t digits) 
+{ 
+  size_t n = 0;
+  
+  if (isnan(number)) return print("nan");
+  if (isinf(number)) return print("inf");
+  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
+  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
+  
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     n += print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  n += print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0) {
+    n += print("."); 
+  }
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    n += print(toPrint);
+    remainder -= toPrint; 
+  } 
+  
+  return n;
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.h
new file mode 100644
index 0000000..dc76150
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Print.h
@@ -0,0 +1,81 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+#include "Printable.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+
+class Print
+{
+  private:
+    int write_error;
+    size_t printNumber(unsigned long, uint8_t);
+    size_t printFloat(double, uint8_t);
+  protected:
+    void setWriteError(int err = 1) { write_error = err; }
+  public:
+    Print() : write_error(0) {}
+  
+    int getWriteError() { return write_error; }
+    void clearWriteError() { setWriteError(0); }
+  
+    virtual size_t write(uint8_t) = 0;
+    size_t write(const char *str) {
+      if (str == NULL) return 0;
+      return write((const uint8_t *)str, strlen(str));
+    }
+    virtual size_t write(const uint8_t *buffer, size_t size);
+    
+    size_t print(const __FlashStringHelper *);
+    size_t print(const String &);
+    size_t print(const char[]);
+    size_t print(char);
+    size_t print(unsigned char, int = DEC);
+    size_t print(int, int = DEC);
+    size_t print(unsigned int, int = DEC);
+    size_t print(long, int = DEC);
+    size_t print(unsigned long, int = DEC);
+    size_t print(double, int = 2);
+    size_t print(const Printable&);
+
+    size_t println(const __FlashStringHelper *);
+    size_t println(const String &s);
+    size_t println(const char[]);
+    size_t println(char);
+    size_t println(unsigned char, int = DEC);
+    size_t println(int, int = DEC);
+    size_t println(unsigned int, int = DEC);
+    size_t println(long, int = DEC);
+    size_t println(unsigned long, int = DEC);
+    size_t println(double, int = 2);
+    size_t println(const Printable&);
+    size_t println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Printable.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Printable.h
new file mode 100644
index 0000000..d03c9af
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Printable.h
@@ -0,0 +1,40 @@
+/*
+  Printable.h - Interface class that allows printing of complex types
+  Copyright (c) 2011 Adrian McEwen.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Printable_h
+#define Printable_h
+
+#include <new.h>
+
+class Print;
+
+/** The Printable class provides a way for new classes to allow themselves to be printed.
+    By deriving from Printable and implementing the printTo method, it will then be possible
+    for users to print out instances of this class by passing them into the usual
+    Print::print and Print::println methods.
+*/
+
+class Printable
+{
+  public:
+    virtual size_t printTo(Print& p) const = 0;
+};
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Server.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Server.h
new file mode 100644
index 0000000..9674c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Server.h
@@ -0,0 +1,9 @@
+#ifndef server_h
+#define server_h
+
+class Server : public Print {
+public:
+  virtual void begin() =0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.cpp
new file mode 100644
index 0000000..aafb7fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.cpp
@@ -0,0 +1,270 @@
+/*
+ Stream.cpp - adds parsing methods to Stream class
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Created July 2011
+ parsing functions based on TextFinder library by Michael Margolis
+ */
+
+#include "Arduino.h"
+#include "Stream.h"
+
+#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
+#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
+
+// private method to read stream with timeout
+int Stream::timedRead()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = read();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// private method to peek stream with timeout
+int Stream::timedPeek()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = peek();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// returns peek of the next digit in the stream or -1 if timeout
+// discards non-numeric characters
+int Stream::peekNextDigit()
+{
+  int c;
+  while (1) {
+    c = timedPeek();
+    if (c < 0) return c;  // timeout
+    if (c == '-') return c;
+    if (c >= '0' && c <= '9') return c;
+    read();  // discard non-numeric
+  }
+}
+
+// Public Methods
+//////////////////////////////////////////////////////////////
+
+void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
+{
+  _timeout = timeout;
+}
+
+ // find returns true if the target string is found
+bool  Stream::find(char *target)
+{
+  return findUntil(target, NULL);
+}
+
+// reads data from the stream until the target string of given length is found
+// returns true if target string is found, false if timed out
+bool Stream::find(char *target, size_t length)
+{
+  return findUntil(target, length, NULL, 0);
+}
+
+// as find but search ends if the terminator string is found
+bool  Stream::findUntil(char *target, char *terminator)
+{
+  return findUntil(target, strlen(target), terminator, strlen(terminator));
+}
+
+// reads data from the stream until the target string of the given length is found
+// search terminated if the terminator string is found
+// returns true if target string is found, false if terminated or timed out
+bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
+{
+  size_t index = 0;  // maximum target string length is 64k bytes!
+  size_t termIndex = 0;
+  int c;
+  
+  if( *target == 0)
+    return true;   // return true if target is a null string
+  while( (c = timedRead()) > 0){
+    
+    if(c != target[index])
+      index = 0; // reset index if any char does not match
+    
+    if( c == target[index]){
+      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
+      if(++index >= targetLen){ // return true if all chars in the target match
+        return true;
+      }
+    }
+    
+    if(termLen > 0 && c == terminator[termIndex]){
+      if(++termIndex >= termLen)
+        return false;       // return false if terminate string found before target string
+    }
+    else
+      termIndex = 0;
+  }
+  return false;
+}
+
+
+// returns the first valid (long) integer value from the current position.
+// initial characters that are not digits (or the minus sign) are skipped
+// function is terminated by the first character that is not a digit.
+long Stream::parseInt()
+{
+  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
+}
+
+// as above but a given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+long Stream::parseInt(char skipChar)
+{
+  boolean isNegative = false;
+  long value = 0;
+  int c;
+
+  c = peekNextDigit();
+  // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore this charactor
+    else if(c == '-')
+      isNegative = true;
+    else if(c >= '0' && c <= '9')        // is c a digit?
+      value = value * 10 + c - '0';
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9') || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  return value;
+}
+
+
+// as parseInt but returns a floating point value
+float Stream::parseFloat()
+{
+  return parseFloat(NO_SKIP_CHAR);
+}
+
+// as above but the given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+float Stream::parseFloat(char skipChar){
+  boolean isNegative = false;
+  boolean isFraction = false;
+  long value = 0;
+  char c;
+  float fraction = 1.0;
+
+  c = peekNextDigit();
+    // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore
+    else if(c == '-')
+      isNegative = true;
+    else if (c == '.')
+      isFraction = true;
+    else if(c >= '0' && c <= '9')  {      // is c a digit?
+      value = value * 10 + c - '0';
+      if(isFraction)
+         fraction *= 0.1;
+    }
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  if(isFraction)
+    return value * fraction;
+  else
+    return value;
+}
+
+// read characters from stream into buffer
+// terminates if length characters have been read, or timeout (see setTimeout)
+// returns the number of characters placed in the buffer
+// the buffer is NOT null terminated.
+//
+size_t Stream::readBytes(char *buffer, size_t length)
+{
+  size_t count = 0;
+  while (count < length) {
+    int c = timedRead();
+    if (c < 0) break;
+    *buffer++ = (char)c;
+    count++;
+  }
+  return count;
+}
+
+
+// as readBytes with terminator character
+// terminates if length characters have been read, timeout, or if the terminator character  detected
+// returns the number of characters placed in the buffer (0 means no valid data found)
+
+size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
+{
+  if (length < 1) return 0;
+  size_t index = 0;
+  while (index < length) {
+    int c = timedRead();
+    if (c < 0 || c == terminator) break;
+    *buffer++ = (char)c;
+    index++;
+  }
+  return index; // return number of characters, not including null terminator
+}
+
+String Stream::readString()
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
+String Stream::readStringUntil(char terminator)
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0 && c != terminator)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.h
new file mode 100644
index 0000000..58bbf75
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Stream.h
@@ -0,0 +1,96 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  parsing functions based on TextFinder library by Michael Margolis
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// compatability macros for testing
+/*
+#define   getInt()            parseInt()
+#define   getInt(skipChar)    parseInt(skipchar)
+#define   getFloat()          parseFloat()
+#define   getFloat(skipChar)  parseFloat(skipChar)
+#define   getString( pre_string, post_string, buffer, length)
+readBytesBetween( pre_string, terminator, buffer, length)
+*/
+
+class Stream : public Print
+{
+  private:
+    unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
+    unsigned long _startMillis;  // used for timeout measurement
+    int timedRead();    // private method to read stream with timeout
+    int timedPeek();    // private method to peek stream with timeout
+    int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
+
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+
+    Stream() {_timeout=1000;}
+
+// parsing methods
+
+  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
+
+  bool find(char *target);   // reads data from the stream until the target string is found
+  // returns true if target string is found, false if timed out (see setTimeout)
+
+  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
+  // returns true if target string is found, false if timed out
+
+  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
+
+  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
+
+
+  long parseInt(); // returns the first valid (long) integer value from the current position.
+  // initial characters that are not digits (or the minus sign) are skipped
+  // integer is terminated by the first character that is not a digit.
+
+  float parseFloat();               // float version of parseInt
+
+  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
+  // terminates if length characters have been read or timeout (see setTimeout)
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
+  // terminates if length characters have been read, timeout, or if the terminator character  detected
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  // Arduino String functions to be added here
+  String readString();
+  String readStringUntil(char terminator);
+
+  protected:
+  long parseInt(char skipChar); // as above but the given skipChar is ignored
+  // as above but the given skipChar is ignored
+  // this allows format characters (typically commas) in values to be ignored
+
+  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..9bb6fe7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Tone.cpp
@@ -0,0 +1,616 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+0008    S Kanemoto  12/06/22 Fixed for Leonardo by @maris_HY
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "Arduino.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#elif defined(__AVR_ATmega32U4__)
+ 
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER3
+ 
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 3 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+ 
+#else
+
+#define AVAILABLE_TONE_PINS 1
+#define USE_TIMER2
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#ifdef USE_TIMER0
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER1
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER2
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER3
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER4
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+#ifdef USE_TIMER5
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBAPI.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBAPI.h
new file mode 100644
index 0000000..eb2e593
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBAPI.h
@@ -0,0 +1,196 @@
+
+
+#ifndef __USBAPI__
+#define __USBAPI__
+
+#if defined(USBCON)
+
+//================================================================================
+//================================================================================
+//	USB
+
+class USBDevice_
+{
+public:
+	USBDevice_();
+	bool configured();
+
+	void attach();
+	void detach();	// Serial port goes down too...
+	void poll();
+};
+extern USBDevice_ USBDevice;
+
+//================================================================================
+//================================================================================
+//	Serial over CDC (Serial1 is the physical port)
+
+class Serial_ : public Stream
+{
+private:
+	ring_buffer *_cdc_rx_buffer;
+public:
+	void begin(uint16_t baud_count);
+	void end(void);
+
+	virtual int available(void);
+	virtual void accept(void);
+	virtual int peek(void);
+	virtual int read(void);
+	virtual void flush(void);
+	virtual size_t write(uint8_t);
+	using Print::write; // pull in write(str) and write(buf, size) from Print
+	operator bool();
+};
+extern Serial_ Serial;
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+#define MOUSE_LEFT 1
+#define MOUSE_RIGHT 2
+#define MOUSE_MIDDLE 4
+#define MOUSE_ALL (MOUSE_LEFT | MOUSE_RIGHT | MOUSE_MIDDLE)
+
+class Mouse_
+{
+private:
+	uint8_t _buttons;
+	void buttons(uint8_t b);
+public:
+	Mouse_(void);
+	void begin(void);
+	void end(void);
+	void click(uint8_t b = MOUSE_LEFT);
+	void move(signed char x, signed char y, signed char wheel = 0);	
+	void press(uint8_t b = MOUSE_LEFT);		// press LEFT by default
+	void release(uint8_t b = MOUSE_LEFT);	// release LEFT by default
+	bool isPressed(uint8_t b = MOUSE_LEFT);	// check LEFT by default
+};
+extern Mouse_ Mouse;
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+#define KEY_LEFT_CTRL		0x80
+#define KEY_LEFT_SHIFT		0x81
+#define KEY_LEFT_ALT		0x82
+#define KEY_LEFT_GUI		0x83
+#define KEY_RIGHT_CTRL		0x84
+#define KEY_RIGHT_SHIFT		0x85
+#define KEY_RIGHT_ALT		0x86
+#define KEY_RIGHT_GUI		0x87
+
+#define KEY_UP_ARROW		0xDA
+#define KEY_DOWN_ARROW		0xD9
+#define KEY_LEFT_ARROW		0xD8
+#define KEY_RIGHT_ARROW		0xD7
+#define KEY_BACKSPACE		0xB2
+#define KEY_TAB				0xB3
+#define KEY_RETURN			0xB0
+#define KEY_ESC				0xB1
+#define KEY_INSERT			0xD1
+#define KEY_DELETE			0xD4
+#define KEY_PAGE_UP			0xD3
+#define KEY_PAGE_DOWN		0xD6
+#define KEY_HOME			0xD2
+#define KEY_END				0xD5
+#define KEY_CAPS_LOCK		0xC1
+#define KEY_F1				0xC2
+#define KEY_F2				0xC3
+#define KEY_F3				0xC4
+#define KEY_F4				0xC5
+#define KEY_F5				0xC6
+#define KEY_F6				0xC7
+#define KEY_F7				0xC8
+#define KEY_F8				0xC9
+#define KEY_F9				0xCA
+#define KEY_F10				0xCB
+#define KEY_F11				0xCC
+#define KEY_F12				0xCD
+
+//	Low level key report: up to 6 keys and shift, ctrl etc at once
+typedef struct
+{
+	uint8_t modifiers;
+	uint8_t reserved;
+	uint8_t keys[6];
+} KeyReport;
+
+class Keyboard_ : public Print
+{
+private:
+	KeyReport _keyReport;
+	void sendReport(KeyReport* keys);
+public:
+	Keyboard_(void);
+	void begin(void);
+	void end(void);
+	virtual size_t write(uint8_t k);
+	virtual size_t press(uint8_t k);
+	virtual size_t release(uint8_t k);
+	virtual void releaseAll(void);
+};
+extern Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+//	Low level API
+
+typedef struct
+{
+	uint8_t bmRequestType;
+	uint8_t bRequest;
+	uint8_t wValueL;
+	uint8_t wValueH;
+	uint16_t wIndex;
+	uint16_t wLength;
+} Setup;
+
+//================================================================================
+//================================================================================
+//	HID 'Driver'
+
+int		HID_GetInterface(uint8_t* interfaceNum);
+int		HID_GetDescriptor(int i);
+bool	HID_Setup(Setup& setup);
+void	HID_SendReport(uint8_t id, const void* data, int len);
+
+//================================================================================
+//================================================================================
+//	MSC 'Driver'
+
+int		MSC_GetInterface(uint8_t* interfaceNum);
+int		MSC_GetDescriptor(int i);
+bool	MSC_Setup(Setup& setup);
+bool	MSC_Data(uint8_t rx,uint8_t tx);
+
+//================================================================================
+//================================================================================
+//	CSC 'Driver'
+
+int		CDC_GetInterface(uint8_t* interfaceNum);
+int		CDC_GetDescriptor(int i);
+bool	CDC_Setup(Setup& setup);
+
+//================================================================================
+//================================================================================
+
+#define TRANSFER_PGM		0x80
+#define TRANSFER_RELEASE	0x40
+#define TRANSFER_ZERO		0x20
+
+int USB_SendControl(uint8_t flags, const void* d, int len);
+int USB_RecvControl(void* d, int len);
+
+uint8_t	USB_Available(uint8_t ep);
+int USB_Send(uint8_t ep, const void* data, int len);	// blocking
+int USB_Recv(uint8_t ep, void* data, int len);		// non-blocking
+int USB_Recv(uint8_t ep);							// non-blocking
+void USB_Flush(uint8_t ep);
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.cpp
new file mode 100644
index 0000000..d3e0170
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.cpp
@@ -0,0 +1,684 @@
+
+
+/* Copyright (c) 2010, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+
+#define EP_TYPE_CONTROL				0x00
+#define EP_TYPE_BULK_IN				0x81
+#define EP_TYPE_BULK_OUT			0x80
+#define EP_TYPE_INTERRUPT_IN		0xC1
+#define EP_TYPE_INTERRUPT_OUT		0xC0
+#define EP_TYPE_ISOCHRONOUS_IN		0x41
+#define EP_TYPE_ISOCHRONOUS_OUT		0x40
+
+/** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse type */
+#define TX_RX_LED_PULSE_MS 100
+volatile u8 TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
+volatile u8 RxLEDPulse; /**< Milliseconds remaining for data Rx LED pulse */
+
+//==================================================================
+//==================================================================
+
+extern const u16 STRING_LANGUAGE[] PROGMEM;
+extern const u16 STRING_IPRODUCT[] PROGMEM;
+extern const u16 STRING_IMANUFACTURER[] PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptor PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptorA PROGMEM;
+
+const u16 STRING_LANGUAGE[2] = {
+	(3<<8) | (2+2),
+	0x0409	// English
+};
+
+const u16 STRING_IPRODUCT[17] = {
+	(3<<8) | (2+2*16),
+#if USB_PID == 0x8036	
+	'A','r','d','u','i','n','o',' ','L','e','o','n','a','r','d','o'
+#elif USB_PID == 0x8037
+	'A','r','d','u','i','n','o',' ','M','i','c','r','o',' ',' ',' '
+#elif USB_PID == 0x803C
+	'A','r','d','u','i','n','o',' ','E','s','p','l','o','r','a',' '
+#elif USB_PID == 0x9208
+	'L','i','l','y','P','a','d','U','S','B',' ',' ',' ',' ',' ',' '
+#else
+	'U','S','B',' ','I','O',' ','B','o','a','r','d',' ',' ',' ',' '
+#endif
+};
+
+const u16 STRING_IMANUFACTURER[12] = {
+	(3<<8) | (2+2*11),
+#if USB_VID == 0x2341
+	'A','r','d','u','i','n','o',' ','L','L','C'
+#elif USB_VID == 0x1b4f
+	'S','p','a','r','k','F','u','n',' ',' ',' '
+#else
+	'U','n','k','n','o','w','n',' ',' ',' ',' '
+#endif
+};
+
+#ifdef CDC_ENABLED
+#define DEVICE_CLASS 0x02
+#else
+#define DEVICE_CLASS 0x00
+#endif
+
+//	DEVICE DESCRIPTOR
+const DeviceDescriptor USB_DeviceDescriptor =
+	D_DEVICE(0x00,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+const DeviceDescriptor USB_DeviceDescriptorA =
+	D_DEVICE(DEVICE_CLASS,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+//==================================================================
+//==================================================================
+
+volatile u8 _usbConfiguration = 0;
+
+static inline void WaitIN(void)
+{
+	while (!(UEINTX & (1<<TXINI)));
+}
+
+static inline void ClearIN(void)
+{
+	UEINTX = ~(1<<TXINI);
+}
+
+static inline void WaitOUT(void)
+{
+	while (!(UEINTX & (1<<RXOUTI)))
+		;
+}
+
+static inline u8 WaitForINOrOUT()
+{
+	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
+		;
+	return (UEINTX & (1<<RXOUTI)) == 0;
+}
+
+static inline void ClearOUT(void)
+{
+	UEINTX = ~(1<<RXOUTI);
+}
+
+void Recv(volatile u8* data, u8 count)
+{
+	while (count--)
+		*data++ = UEDATX;
+	
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;	
+}
+
+static inline u8 Recv8()
+{
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;
+
+	return UEDATX;	
+}
+
+static inline void Send8(u8 d)
+{
+	UEDATX = d;
+}
+
+static inline void SetEP(u8 ep)
+{
+	UENUM = ep;
+}
+
+static inline u8 FifoByteCount()
+{
+	return UEBCLX;
+}
+
+static inline u8 ReceivedSetupInt()
+{
+	return UEINTX & (1<<RXSTPI);
+}
+
+static inline void ClearSetupInt()
+{
+	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
+}
+
+static inline void Stall()
+{
+	UECONX = (1<<STALLRQ) | (1<<EPEN);
+}
+
+static inline u8 ReadWriteAllowed()
+{
+	return UEINTX & (1<<RWAL);
+}
+
+static inline u8 Stalled()
+{
+	return UEINTX & (1<<STALLEDI);
+}
+
+static inline u8 FifoFree()
+{
+	return UEINTX & (1<<FIFOCON);
+}
+
+static inline void ReleaseRX()
+{
+	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
+}
+
+static inline void ReleaseTX()
+{
+	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
+}
+
+static inline u8 FrameNumber()
+{
+	return UDFNUML;
+}
+
+//==================================================================
+//==================================================================
+
+u8 USBGetConfiguration(void)
+{
+	return _usbConfiguration;
+}
+
+#define USB_RECV_TIMEOUT
+class LockEP
+{
+	u8 _sreg;
+public:
+	LockEP(u8 ep) : _sreg(SREG)
+	{
+		cli();
+		SetEP(ep & 7);
+	}
+	~LockEP()
+	{
+		SREG = _sreg;
+	}
+};
+
+//	Number of bytes, assumes a rx endpoint
+u8 USB_Available(u8 ep)
+{
+	LockEP lock(ep);
+	return FifoByteCount();
+}
+
+//	Non Blocking receive
+//	Return number of bytes read
+int USB_Recv(u8 ep, void* d, int len)
+{
+	if (!_usbConfiguration || len < 0)
+		return -1;
+	
+	LockEP lock(ep);
+	u8 n = FifoByteCount();
+	len = min(n,len);
+	n = len;
+	u8* dst = (u8*)d;
+	while (n--)
+		*dst++ = Recv8();
+	if (len && !FifoByteCount())	// release empty buffer
+		ReleaseRX();
+	
+	return len;
+}
+
+//	Recv 1 byte if ready
+int USB_Recv(u8 ep)
+{
+	u8 c;
+	if (USB_Recv(ep,&c,1) != 1)
+		return -1;
+	return c;
+}
+
+//	Space in send EP
+u8 USB_SendSpace(u8 ep)
+{
+	LockEP lock(ep);
+	if (!ReadWriteAllowed())
+		return 0;
+	return 64 - FifoByteCount();
+}
+
+//	Blocking Send of data to an endpoint
+int USB_Send(u8 ep, const void* d, int len)
+{
+	if (!_usbConfiguration)
+		return -1;
+
+	int r = len;
+	const u8* data = (const u8*)d;
+	u8 zero = ep & TRANSFER_ZERO;
+	u8 timeout = 250;		// 250ms timeout on send? TODO
+	while (len)
+	{
+		u8 n = USB_SendSpace(ep);
+		if (n == 0)
+		{
+			if (!(--timeout))
+				return -1;
+			delay(1);
+			continue;
+		}
+
+		if (n > len)
+			n = len;
+		len -= n;
+		{
+			LockEP lock(ep);
+			if (ep & TRANSFER_ZERO)
+			{
+				while (n--)
+					Send8(0);
+			}
+			else if (ep & TRANSFER_PGM)
+			{
+				while (n--)
+					Send8(pgm_read_byte(data++));
+			}
+			else
+			{
+				while (n--)
+					Send8(*data++);
+			}
+			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
+				ReleaseTX();
+		}
+	}
+	TXLED1;					// light the TX LED
+	TxLEDPulse = TX_RX_LED_PULSE_MS;
+	return r;
+}
+
+extern const u8 _initEndpoints[] PROGMEM;
+const u8 _initEndpoints[] = 
+{
+	0,
+	
+#ifdef CDC_ENABLED
+	EP_TYPE_INTERRUPT_IN,		// CDC_ENDPOINT_ACM
+	EP_TYPE_BULK_OUT,			// CDC_ENDPOINT_OUT
+	EP_TYPE_BULK_IN,			// CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+	EP_TYPE_INTERRUPT_IN		// HID_ENDPOINT_INT
+#endif
+};
+
+#define EP_SINGLE_64 0x32	// EP0
+#define EP_DOUBLE_64 0x36	// Other endpoints
+
+static
+void InitEP(u8 index, u8 type, u8 size)
+{
+	UENUM = index;
+	UECONX = 1;
+	UECFG0X = type;
+	UECFG1X = size;
+}
+
+static
+void InitEndpoints()
+{
+	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
+	{
+		UENUM = i;
+		UECONX = 1;
+		UECFG0X = pgm_read_byte(_initEndpoints+i);
+		UECFG1X = EP_DOUBLE_64;
+	}
+	UERST = 0x7E;	// And reset them
+	UERST = 0;
+}
+
+//	Handle CLASS_INTERFACE requests
+static
+bool ClassInterfaceRequest(Setup& setup)
+{
+	u8 i = setup.wIndex;
+
+#ifdef CDC_ENABLED
+	if (CDC_ACM_INTERFACE == i)
+		return CDC_Setup(setup);
+#endif
+
+#ifdef HID_ENABLED
+	if (HID_INTERFACE == i)
+		return HID_Setup(setup);
+#endif
+	return false;
+}
+
+int _cmark;
+int _cend;
+void InitControl(int end)
+{
+	SetEP(0);
+	_cmark = 0;
+	_cend = end;
+}
+
+static
+bool SendControl(u8 d)
+{
+	if (_cmark < _cend)
+	{
+		if (!WaitForINOrOUT())
+			return false;
+		Send8(d);
+		if (!((_cmark + 1) & 0x3F))
+			ClearIN();	// Fifo is full, release this packet
+	}
+	_cmark++;
+	return true;
+};
+
+//	Clipped by _cmark/_cend
+int USB_SendControl(u8 flags, const void* d, int len)
+{
+	int sent = len;
+	const u8* data = (const u8*)d;
+	bool pgm = flags & TRANSFER_PGM;
+	while (len--)
+	{
+		u8 c = pgm ? pgm_read_byte(data++) : *data++;
+		if (!SendControl(c))
+			return -1;
+	}
+	return sent;
+}
+
+//	Does not timeout or cross fifo boundaries
+//	Will only work for transfers <= 64 bytes
+//	TODO
+int USB_RecvControl(void* d, int len)
+{
+	WaitOUT();
+	Recv((u8*)d,len);
+	ClearOUT();
+	return len;
+}
+
+int SendInterfaces()
+{
+	int total = 0;
+	u8 interfaces = 0;
+
+#ifdef CDC_ENABLED
+	total = CDC_GetInterface(&interfaces);
+#endif
+
+#ifdef HID_ENABLED
+	total += HID_GetInterface(&interfaces);
+#endif
+
+	return interfaces;
+}
+
+//	Construct a dynamic configuration descriptor
+//	This really needs dynamic endpoint allocation etc
+//	TODO
+static
+bool SendConfiguration(int maxlen)
+{
+	//	Count and measure interfaces
+	InitControl(0);	
+	int interfaces = SendInterfaces();
+	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
+
+	//	Now send them
+	InitControl(maxlen);
+	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
+	SendInterfaces();
+	return true;
+}
+
+u8 _cdcComposite = 0;
+
+static
+bool SendDescriptor(Setup& setup)
+{
+	u8 t = setup.wValueH;
+	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
+		return SendConfiguration(setup.wLength);
+
+	InitControl(setup.wLength);
+#ifdef HID_ENABLED
+	if (HID_REPORT_DESCRIPTOR_TYPE == t)
+		return HID_GetDescriptor(t);
+#endif
+
+	u8 desc_length = 0;
+	const u8* desc_addr = 0;
+	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wLength == 8)
+			_cdcComposite = 1;
+		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
+	}
+	else if (USB_STRING_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wValueL == 0)
+			desc_addr = (const u8*)&STRING_LANGUAGE;
+		else if (setup.wValueL == IPRODUCT) 
+			desc_addr = (const u8*)&STRING_IPRODUCT;
+		else if (setup.wValueL == IMANUFACTURER)
+			desc_addr = (const u8*)&STRING_IMANUFACTURER;
+		else
+			return false;
+	}
+
+	if (desc_addr == 0)
+		return false;
+	if (desc_length == 0)
+		desc_length = pgm_read_byte(desc_addr);
+
+	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
+	return true;
+}
+
+//	Endpoint 0 interrupt
+ISR(USB_COM_vect)
+{
+    SetEP(0);
+	if (!ReceivedSetupInt())
+		return;
+
+	Setup setup;
+	Recv((u8*)&setup,8);
+	ClearSetupInt();
+
+	u8 requestType = setup.bmRequestType;
+	if (requestType & REQUEST_DEVICETOHOST)
+		WaitIN();
+	else
+		ClearIN();
+
+    bool ok = true;
+	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
+	{
+		//	Standard Requests
+		u8 r = setup.bRequest;
+		if (GET_STATUS == r)
+		{
+			Send8(0);		// TODO
+			Send8(0);
+		}
+		else if (CLEAR_FEATURE == r)
+		{
+		}
+		else if (SET_FEATURE == r)
+		{
+		}
+		else if (SET_ADDRESS == r)
+		{
+			WaitIN();
+			UDADDR = setup.wValueL | (1<<ADDEN);
+		}
+		else if (GET_DESCRIPTOR == r)
+		{
+			ok = SendDescriptor(setup);
+		}
+		else if (SET_DESCRIPTOR == r)
+		{
+			ok = false;
+		}
+		else if (GET_CONFIGURATION == r)
+		{
+			Send8(1);
+		}
+		else if (SET_CONFIGURATION == r)
+		{
+			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
+			{
+				InitEndpoints();
+				_usbConfiguration = setup.wValueL;
+			} else
+				ok = false;
+		}
+		else if (GET_INTERFACE == r)
+		{
+		}
+		else if (SET_INTERFACE == r)
+		{
+		}
+	}
+	else
+	{
+		InitControl(setup.wLength);		//	Max length of transfer
+		ok = ClassInterfaceRequest(setup);
+	}
+
+	if (ok)
+		ClearIN();
+	else
+	{
+		Stall();
+	}
+}
+
+void USB_Flush(u8 ep)
+{
+	SetEP(ep);
+	if (FifoByteCount())
+		ReleaseTX();
+}
+
+//	General interrupt
+ISR(USB_GEN_vect)
+{
+	u8 udint = UDINT;
+	UDINT = 0;
+
+	//	End of Reset
+	if (udint & (1<<EORSTI))
+	{
+		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
+		_usbConfiguration = 0;			// not configured yet
+		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
+	}
+
+	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
+	if (udint & (1<<SOFI))
+	{
+#ifdef CDC_ENABLED
+		USB_Flush(CDC_TX);				// Send a tx frame if found
+		if (USB_Available(CDC_RX))	// Handle received bytes (if any)
+			Serial.accept();
+#endif
+		
+		// check whether the one-shot period has elapsed.  if so, turn off the LED
+		if (TxLEDPulse && !(--TxLEDPulse))
+			TXLED0;
+		if (RxLEDPulse && !(--RxLEDPulse))
+			RXLED0;
+	}
+}
+
+//	VBUS or counting frames
+//	Any frame counting?
+u8 USBConnected()
+{
+	u8 f = UDFNUML;
+	delay(3);
+	return f != UDFNUML;
+}
+
+//=======================================================================
+//=======================================================================
+
+USBDevice_ USBDevice;
+
+USBDevice_::USBDevice_()
+{
+}
+
+void USBDevice_::attach()
+{
+	_usbConfiguration = 0;
+	UHWCON = 0x01;						// power internal reg
+	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
+#if F_CPU == 16000000UL
+	PLLCSR = 0x12;						// Need 16 MHz xtal
+#elif F_CPU == 8000000UL
+	PLLCSR = 0x02;						// Need 8 MHz xtal
+#endif
+	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
+		;
+
+	// Some tests on specific versions of macosx (10.7.3), reported some
+	// strange behaviuors when the board is reset using the serial
+	// port touch at 1200 bps. This delay fixes this behaviour.
+	delay(1);
+
+	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
+	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
+	UDCON = 0;							// enable attach resistor
+	
+	TX_RX_LED_INIT;
+}
+
+void USBDevice_::detach()
+{
+}
+
+//	Check for interrupts
+//	TODO: VBUS detection
+bool USBDevice_::configured()
+{
+	return _usbConfiguration;
+}
+
+void USBDevice_::poll()
+{
+}
+
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.h
new file mode 100644
index 0000000..8d13806
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBCore.h
@@ -0,0 +1,303 @@
+
+// Copyright (c) 2010, Peter Barrett 
+/*
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+**  
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#ifndef __USBCORE_H__
+#define __USBCORE_H__
+
+//	Standard requests
+#define GET_STATUS			0
+#define CLEAR_FEATURE		1
+#define SET_FEATURE			3
+#define SET_ADDRESS			5
+#define GET_DESCRIPTOR		6
+#define SET_DESCRIPTOR		7
+#define GET_CONFIGURATION	8
+#define SET_CONFIGURATION	9
+#define GET_INTERFACE		10
+#define SET_INTERFACE		11
+
+
+// bmRequestType
+#define REQUEST_HOSTTODEVICE	0x00
+#define REQUEST_DEVICETOHOST	0x80
+#define REQUEST_DIRECTION		0x80
+
+#define REQUEST_STANDARD		0x00
+#define REQUEST_CLASS			0x20
+#define REQUEST_VENDOR			0x40
+#define REQUEST_TYPE			0x60
+
+#define REQUEST_DEVICE			0x00
+#define REQUEST_INTERFACE		0x01
+#define REQUEST_ENDPOINT		0x02
+#define REQUEST_OTHER			0x03
+#define REQUEST_RECIPIENT		0x03
+
+#define REQUEST_DEVICETOHOST_CLASS_INTERFACE  (REQUEST_DEVICETOHOST + REQUEST_CLASS + REQUEST_INTERFACE)
+#define REQUEST_HOSTTODEVICE_CLASS_INTERFACE  (REQUEST_HOSTTODEVICE + REQUEST_CLASS + REQUEST_INTERFACE)
+
+//	Class requests
+
+#define CDC_SET_LINE_CODING			0x20
+#define CDC_GET_LINE_CODING			0x21
+#define CDC_SET_CONTROL_LINE_STATE	0x22
+
+#define MSC_RESET					0xFF
+#define MSC_GET_MAX_LUN				0xFE
+
+#define HID_GET_REPORT				0x01
+#define HID_GET_IDLE				0x02
+#define HID_GET_PROTOCOL			0x03
+#define HID_SET_REPORT				0x09
+#define HID_SET_IDLE				0x0A
+#define HID_SET_PROTOCOL			0x0B
+
+//	Descriptors
+
+#define USB_DEVICE_DESC_SIZE 18
+#define USB_CONFIGUARTION_DESC_SIZE 9
+#define USB_INTERFACE_DESC_SIZE 9
+#define USB_ENDPOINT_DESC_SIZE 7
+
+#define USB_DEVICE_DESCRIPTOR_TYPE             1
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
+#define USB_STRING_DESCRIPTOR_TYPE             3
+#define USB_INTERFACE_DESCRIPTOR_TYPE          4
+#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
+
+#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
+#define USB_DEVICE_CLASS_STORAGE               0x08
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
+
+#define USB_CONFIG_POWERED_MASK                0x40
+#define USB_CONFIG_BUS_POWERED                 0x80
+#define USB_CONFIG_SELF_POWERED                0xC0
+#define USB_CONFIG_REMOTE_WAKEUP               0x20
+
+// bMaxPower in Configuration Descriptor
+#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
+
+// bEndpointAddress in Endpoint Descriptor
+#define USB_ENDPOINT_DIRECTION_MASK            0x80
+#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
+#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
+
+#define USB_ENDPOINT_TYPE_MASK                 0x03
+#define USB_ENDPOINT_TYPE_CONTROL              0x00
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
+#define USB_ENDPOINT_TYPE_BULK                 0x02
+#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
+
+#define TOBYTES(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+
+#define CDC_V1_10                               0x0110
+#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
+
+#define CDC_CALL_MANAGEMENT                     0x01
+#define CDC_ABSTRACT_CONTROL_MODEL              0x02
+#define CDC_HEADER                              0x00
+#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
+#define CDC_UNION                               0x06
+#define CDC_CS_INTERFACE                        0x24
+#define CDC_CS_ENDPOINT                         0x25
+#define CDC_DATA_INTERFACE_CLASS                0x0A
+
+#define MSC_SUBCLASS_SCSI						0x06 
+#define MSC_PROTOCOL_BULK_ONLY					0x50 
+
+#define HID_HID_DESCRIPTOR_TYPE					0x21
+#define HID_REPORT_DESCRIPTOR_TYPE				0x22
+#define HID_PHYSICAL_DESCRIPTOR_TYPE			0x23
+
+
+//	Device
+typedef struct {
+	u8 len;				// 18
+	u8 dtype;			// 1 USB_DEVICE_DESCRIPTOR_TYPE
+	u16 usbVersion;		// 0x200
+	u8	deviceClass;
+	u8	deviceSubClass;
+	u8	deviceProtocol;
+	u8	packetSize0;	// Packet 0
+	u16	idVendor;
+	u16	idProduct;
+	u16	deviceVersion;	// 0x100
+	u8	iManufacturer;
+	u8	iProduct;
+	u8	iSerialNumber;
+	u8	bNumConfigurations;
+} DeviceDescriptor;
+
+//	Config
+typedef struct {
+	u8	len;			// 9
+	u8	dtype;			// 2
+	u16 clen;			// total length
+	u8	numInterfaces;
+	u8	config;
+	u8	iconfig;
+	u8	attributes;
+	u8	maxPower;
+} ConfigDescriptor;
+
+//	String
+
+//	Interface
+typedef struct
+{
+	u8 len;		// 9
+	u8 dtype;	// 4
+	u8 number;
+	u8 alternate;
+	u8 numEndpoints;
+	u8 interfaceClass;
+	u8 interfaceSubClass;
+	u8 protocol;
+	u8 iInterface;
+} InterfaceDescriptor;
+
+//	Endpoint
+typedef struct
+{
+	u8 len;		// 7
+	u8 dtype;	// 5
+	u8 addr;
+	u8 attr;
+	u16 packetSize;
+	u8 interval;
+} EndpointDescriptor;
+
+// Interface Association Descriptor
+// Used to bind 2 interfaces together in CDC compostite device
+typedef struct
+{
+	u8 len;				// 8
+	u8 dtype;			// 11
+	u8 firstInterface;
+	u8 interfaceCount;
+	u8 functionClass;
+	u8 funtionSubClass;
+	u8 functionProtocol;
+	u8 iInterface;
+} IADDescriptor;
+
+//	CDC CS interface descriptor
+typedef struct
+{
+	u8 len;		// 5
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+	u8 d1;
+} CDCCSInterfaceDescriptor;
+
+typedef struct
+{
+	u8 len;		// 4
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+} CDCCSInterfaceDescriptor4;
+
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+    u8 	bDataInterface;
+} CMFunctionalDescriptor;
+	
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+} ACMFunctionalDescriptor;
+
+typedef struct 
+{
+	//	IAD
+	IADDescriptor				iad;	// Only needed on compound device
+
+	//	Control
+	InterfaceDescriptor			cif;	// 
+	CDCCSInterfaceDescriptor	header;
+	CMFunctionalDescriptor		callManagement;			// Call Management
+	ACMFunctionalDescriptor		controlManagement;		// ACM
+	CDCCSInterfaceDescriptor	functionalDescriptor;	// CDC_UNION
+	EndpointDescriptor			cifin;
+
+	//	Data
+	InterfaceDescriptor			dif;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} CDCDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			msc;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} MSCDescriptor;
+
+typedef struct
+{
+	u8 len;			// 9
+	u8 dtype;		// 0x21
+	u8 addr;
+	u8	versionL;	// 0x101
+	u8	versionH;	// 0x101
+	u8	country;
+	u8	desctype;	// 0x22 report
+	u8	descLenL;
+	u8	descLenH;
+} HIDDescDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			hid;
+	HIDDescDescriptor			desc;
+	EndpointDescriptor			in;
+} HIDDescriptor;
+
+
+#define D_DEVICE(_class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs) \
+	{ 18, 1, 0x200, _class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs }
+
+#define D_CONFIG(_totalLength,_interfaces) \
+	{ 9, 2, _totalLength,_interfaces, 1, 0, USB_CONFIG_BUS_POWERED, USB_CONFIG_POWER_MA(500) }
+
+#define D_INTERFACE(_n,_numEndpoints,_class,_subClass,_protocol) \
+	{ 9, 4, _n, 0, _numEndpoints, _class,_subClass, _protocol, 0 }
+
+#define D_ENDPOINT(_addr,_attr,_packetSize, _interval) \
+	{ 7, 5, _addr,_attr,_packetSize, _interval }
+
+#define D_IAD(_firstInterface, _count, _class, _subClass, _protocol) \
+	{ 8, 11, _firstInterface, _count, _class, _subClass, _protocol, 0 }
+
+#define D_HIDREPORT(_descriptorLength) \
+	{ 9, 0x21, 0x1, 0x1, 0, 1, 0x22, _descriptorLength, 0 }
+
+#define D_CDCCS(_subtype,_d0,_d1)	{ 5, 0x24, _subtype, _d0, _d1 }
+#define D_CDCCS4(_subtype,_d0)		{ 4, 0x24, _subtype, _d0 }
+
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBDesc.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBDesc.h
new file mode 100644
index 0000000..900713e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/USBDesc.h
@@ -0,0 +1,63 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#define CDC_ENABLED
+#define HID_ENABLED
+
+
+#ifdef CDC_ENABLED
+#define CDC_INTERFACE_COUNT	2
+#define CDC_ENPOINT_COUNT	3
+#else
+#define CDC_INTERFACE_COUNT	0
+#define CDC_ENPOINT_COUNT	0
+#endif
+
+#ifdef HID_ENABLED
+#define HID_INTERFACE_COUNT	1
+#define HID_ENPOINT_COUNT	1
+#else
+#define HID_INTERFACE_COUNT	0
+#define HID_ENPOINT_COUNT	0
+#endif
+
+#define CDC_ACM_INTERFACE	0	// CDC ACM
+#define CDC_DATA_INTERFACE	1	// CDC Data
+#define CDC_FIRST_ENDPOINT	1
+#define CDC_ENDPOINT_ACM	(CDC_FIRST_ENDPOINT)							// CDC First
+#define CDC_ENDPOINT_OUT	(CDC_FIRST_ENDPOINT+1)
+#define CDC_ENDPOINT_IN		(CDC_FIRST_ENDPOINT+2)
+
+#define HID_INTERFACE		(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT)		// HID Interface
+#define HID_FIRST_ENDPOINT	(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT)
+#define HID_ENDPOINT_INT	(HID_FIRST_ENDPOINT)
+
+#define INTERFACE_COUNT		(MSC_INTERFACE + MSC_INTERFACE_COUNT)
+
+#ifdef CDC_ENABLED
+#define CDC_RX CDC_ENDPOINT_OUT
+#define CDC_TX CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+#define HID_TX HID_ENDPOINT_INT
+#endif
+
+#define IMANUFACTURER	1
+#define IPRODUCT		2
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Udp.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Udp.h
new file mode 100644
index 0000000..dc5644b
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/Udp.h
@@ -0,0 +1,88 @@
+/*
+ *  Udp.cpp: Library to send/receive UDP packets.
+ *
+ * NOTE: UDP is fast, but has some important limitations (thanks to Warren Gray for mentioning these)
+ * 1) UDP does not guarantee the order in which assembled UDP packets are received. This
+ * might not happen often in practice, but in larger network topologies, a UDP
+ * packet can be received out of sequence. 
+ * 2) UDP does not guard against lost packets - so packets *can* disappear without the sender being
+ * aware of it. Again, this may not be a concern in practice on small local networks.
+ * For more information, see http://www.cafeaulait.org/course/week12/35.html
+ *
+ * MIT License:
+ * Copyright (c) 2008 Bjoern Hartmann
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * bjoern@cs.stanford.edu 12/30/2008
+ */
+
+#ifndef udp_h
+#define udp_h
+
+#include <Stream.h>
+#include <IPAddress.h>
+
+class UDP : public Stream {
+
+public:
+  virtual uint8_t begin(uint16_t) =0;	// initialize, start listening on specified port. Returns 1 if successful, 0 if there are no sockets available to use
+  virtual void stop() =0;  // Finish with the UDP socket
+
+  // Sending UDP packets
+  
+  // Start building up a packet to send to the remote host specific in ip and port
+  // Returns 1 if successful, 0 if there was a problem with the supplied IP address or port
+  virtual int beginPacket(IPAddress ip, uint16_t port) =0;
+  // Start building up a packet to send to the remote host specific in host and port
+  // Returns 1 if successful, 0 if there was a problem resolving the hostname or port
+  virtual int beginPacket(const char *host, uint16_t port) =0;
+  // Finish off this packet and send it
+  // Returns 1 if the packet was sent successfully, 0 if there was an error
+  virtual int endPacket() =0;
+  // Write a single byte into the packet
+  virtual size_t write(uint8_t) =0;
+  // Write size bytes from buffer into the packet
+  virtual size_t write(const uint8_t *buffer, size_t size) =0;
+
+  // Start processing the next available incoming packet
+  // Returns the size of the packet in bytes, or 0 if no packets are available
+  virtual int parsePacket() =0;
+  // Number of bytes remaining in the current packet
+  virtual int available() =0;
+  // Read a single byte from the current packet
+  virtual int read() =0;
+  // Read up to len bytes from the current packet and place them into buffer
+  // Returns the number of bytes read, or 0 if none are available
+  virtual int read(unsigned char* buffer, size_t len) =0;
+  // Read up to len characters from the current packet and place them into buffer
+  // Returns the number of characters read, or 0 if none are available
+  virtual int read(char* buffer, size_t len) =0;
+  // Return the next byte from the current packet without moving on to the next byte
+  virtual int peek() =0;
+  virtual void flush() =0;	// Finish reading the current packet
+
+  // Return the IP address of the host who sent the current incoming packet
+  virtual IPAddress remoteIP() =0;
+  // Return the port of the host who sent the current incoming packet
+  virtual uint16_t remotePort() =0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..62efc9c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WInterrupts.c
@@ -0,0 +1,322 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "wiring_private.h"
+
+static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+	// I hate doing this, but the register assignment differs between the 1280/2560
+	// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't 
+	// even present on the 32U4 this is the only way to distinguish between them.
+	case 0:
+		EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);
+		EIMSK |= (1<<INT0);
+		break;
+	case 1:
+		EICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);
+		EIMSK |= (1<<INT1);
+		break;	
+    case 2:
+        EICRA = (EICRA & ~((1<<ISC20) | (1<<ISC21))) | (mode << ISC20);
+        EIMSK |= (1<<INT2);
+        break;
+    case 3:
+        EICRA = (EICRA & ~((1<<ISC30) | (1<<ISC31))) | (mode << ISC30);
+        EIMSK |= (1<<INT3);
+        break;
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else		
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+    
+    case 2:
+    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GICR |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GIMSK |= (1 << INT2);
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+    case 0:
+        EIMSK &= ~(1<<INT0);
+        break;
+    case 1:
+        EIMSK &= ~(1<<INT1);
+        break;
+    case 2:
+        EIMSK &= ~(1<<INT2);
+        break;
+    case 3:
+        EIMSK &= ~(1<<INT3);
+        break;		
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(__AVR_ATmega32U4__)
+SIGNAL(INT0_vect) {
+	if(intFunc[EXTERNAL_INT_0])
+		intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+	if(intFunc[EXTERNAL_INT_1])
+		intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT2_vect) {
+    if(intFunc[EXTERNAL_INT_2])
+		intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT3_vect) {
+    if(intFunc[EXTERNAL_INT_3])
+		intFunc[EXTERNAL_INT_3]();
+}
+
+#elif defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#if defined(EICRA) && defined(ISC20)
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+#endif
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.cpp
new file mode 100644
index 0000000..c6839fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.cpp
@@ -0,0 +1,645 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "WString.h"
+
+
+/*********************************************/
+/*  Constructors                             */
+/*********************************************/
+
+String::String(const char *cstr)
+{
+	init();
+	if (cstr) copy(cstr, strlen(cstr));
+}
+
+String::String(const String &value)
+{
+	init();
+	*this = value;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String::String(String &&rval)
+{
+	init();
+	move(rval);
+}
+String::String(StringSumHelper &&rval)
+{
+	init();
+	move(rval);
+}
+#endif
+
+String::String(char c)
+{
+	init();
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	*this = buf;
+}
+
+String::String(unsigned char value, unsigned char base)
+{
+	init();
+	char buf[9];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(int value, unsigned char base)
+{
+	init();
+	char buf[18];
+	itoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned int value, unsigned char base)
+{
+	init();
+	char buf[17];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(long value, unsigned char base)
+{
+	init();
+	char buf[34];
+	ltoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned long value, unsigned char base)
+{
+	init();
+	char buf[33];
+	ultoa(value, buf, base);
+	*this = buf;
+}
+
+String::~String()
+{
+	free(buffer);
+}
+
+/*********************************************/
+/*  Memory Management                        */
+/*********************************************/
+
+inline void String::init(void)
+{
+	buffer = NULL;
+	capacity = 0;
+	len = 0;
+	flags = 0;
+}
+
+void String::invalidate(void)
+{
+	if (buffer) free(buffer);
+	buffer = NULL;
+	capacity = len = 0;
+}
+
+unsigned char String::reserve(unsigned int size)
+{
+	if (buffer && capacity >= size) return 1;
+	if (changeBuffer(size)) {
+		if (len == 0) buffer[0] = 0;
+		return 1;
+	}
+	return 0;
+}
+
+unsigned char String::changeBuffer(unsigned int maxStrLen)
+{
+	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
+	if (newbuffer) {
+		buffer = newbuffer;
+		capacity = maxStrLen;
+		return 1;
+	}
+	return 0;
+}
+
+/*********************************************/
+/*  Copy and Move                            */
+/*********************************************/
+
+String & String::copy(const char *cstr, unsigned int length)
+{
+	if (!reserve(length)) {
+		invalidate();
+		return *this;
+	}
+	len = length;
+	strcpy(buffer, cstr);
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+void String::move(String &rhs)
+{
+	if (buffer) {
+		if (capacity >= rhs.len) {
+			strcpy(buffer, rhs.buffer);
+			len = rhs.len;
+			rhs.len = 0;
+			return;
+		} else {
+			free(buffer);
+		}
+	}
+	buffer = rhs.buffer;
+	capacity = rhs.capacity;
+	len = rhs.len;
+	rhs.buffer = NULL;
+	rhs.capacity = 0;
+	rhs.len = 0;
+}
+#endif
+
+String & String::operator = (const String &rhs)
+{
+	if (this == &rhs) return *this;
+	
+	if (rhs.buffer) copy(rhs.buffer, rhs.len);
+	else invalidate();
+	
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String & String::operator = (String &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+
+String & String::operator = (StringSumHelper &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+#endif
+
+String & String::operator = (const char *cstr)
+{
+	if (cstr) copy(cstr, strlen(cstr));
+	else invalidate();
+	
+	return *this;
+}
+
+/*********************************************/
+/*  concat                                   */
+/*********************************************/
+
+unsigned char String::concat(const String &s)
+{
+	return concat(s.buffer, s.len);
+}
+
+unsigned char String::concat(const char *cstr, unsigned int length)
+{
+	unsigned int newlen = len + length;
+	if (!cstr) return 0;
+	if (length == 0) return 1;
+	if (!reserve(newlen)) return 0;
+	strcpy(buffer + len, cstr);
+	len = newlen;
+	return 1;
+}
+
+unsigned char String::concat(const char *cstr)
+{
+	if (!cstr) return 0;
+	return concat(cstr, strlen(cstr));
+}
+
+unsigned char String::concat(char c)
+{
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	return concat(buf, 1);
+}
+
+unsigned char String::concat(unsigned char num)
+{
+	char buf[4];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(int num)
+{
+	char buf[7];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned int num)
+{
+	char buf[6];
+	utoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(long num)
+{
+	char buf[12];
+	ltoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned long num)
+{
+	char buf[11];
+	ultoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+/*********************************************/
+/*  Concatenate                              */
+/*********************************************/
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, char c)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(c)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+/*********************************************/
+/*  Comparison                               */
+/*********************************************/
+
+int String::compareTo(const String &s) const
+{
+	if (!buffer || !s.buffer) {
+		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
+		if (buffer && len > 0) return *(unsigned char *)buffer;
+		return 0;
+	}
+	return strcmp(buffer, s.buffer);
+}
+
+unsigned char String::equals(const String &s2) const
+{
+	return (len == s2.len && compareTo(s2) == 0);
+}
+
+unsigned char String::equals(const char *cstr) const
+{
+	if (len == 0) return (cstr == NULL || *cstr == 0);
+	if (cstr == NULL) return buffer[0] == 0;
+	return strcmp(buffer, cstr) == 0;
+}
+
+unsigned char String::operator<(const String &rhs) const
+{
+	return compareTo(rhs) < 0;
+}
+
+unsigned char String::operator>(const String &rhs) const
+{
+	return compareTo(rhs) > 0;
+}
+
+unsigned char String::operator<=(const String &rhs) const
+{
+	return compareTo(rhs) <= 0;
+}
+
+unsigned char String::operator>=(const String &rhs) const
+{
+	return compareTo(rhs) >= 0;
+}
+
+unsigned char String::equalsIgnoreCase( const String &s2 ) const
+{
+	if (this == &s2) return 1;
+	if (len != s2.len) return 0;
+	if (len == 0) return 1;
+	const char *p1 = buffer;
+	const char *p2 = s2.buffer;
+	while (*p1) {
+		if (tolower(*p1++) != tolower(*p2++)) return 0;
+	} 
+	return 1;
+}
+
+unsigned char String::startsWith( const String &s2 ) const
+{
+	if (len < s2.len) return 0;
+	return startsWith(s2, 0);
+}
+
+unsigned char String::startsWith( const String &s2, unsigned int offset ) const
+{
+	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
+	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
+}
+
+unsigned char String::endsWith( const String &s2 ) const
+{
+	if ( len < s2.len || !buffer || !s2.buffer) return 0;
+	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
+}
+
+/*********************************************/
+/*  Character Access                         */
+/*********************************************/
+
+char String::charAt(unsigned int loc) const
+{
+	return operator[](loc);
+}
+
+void String::setCharAt(unsigned int loc, char c) 
+{
+	if (loc < len) buffer[loc] = c;
+}
+
+char & String::operator[](unsigned int index)
+{
+	static char dummy_writable_char;
+	if (index >= len || !buffer) {
+		dummy_writable_char = 0;
+		return dummy_writable_char;
+	}
+	return buffer[index];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+	if (index >= len || !buffer) return 0;
+	return buffer[index];
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
+{
+	if (!bufsize || !buf) return;
+	if (index >= len) {
+		buf[0] = 0;
+		return;
+	}
+	unsigned int n = bufsize - 1;
+	if (n > len - index) n = len - index;
+	strncpy((char *)buf, buffer + index, n);
+	buf[n] = 0;
+}
+
+/*********************************************/
+/*  Search                                   */
+/*********************************************/
+
+int String::indexOf(char c) const
+{
+	return indexOf(c, 0);
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+	if (fromIndex >= len) return -1;
+	const char* temp = strchr(buffer + fromIndex, ch);
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::indexOf(const String &s2) const
+{
+	return indexOf(s2, 0);
+}
+
+int String::indexOf(const String &s2, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	const char *found = strstr(buffer + fromIndex, s2.buffer);
+	if (found == NULL) return -1;
+	return found - buffer;
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+	return lastIndexOf(theChar, len - 1);
+}
+
+int String::lastIndexOf(char ch, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	char tempchar = buffer[fromIndex + 1];
+	buffer[fromIndex + 1] = '\0';
+	char* temp = strrchr( buffer, ch );
+	buffer[fromIndex + 1] = tempchar;
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::lastIndexOf(const String &s2) const
+{
+	return lastIndexOf(s2, len - s2.len);
+}
+
+int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
+{
+  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
+	if (fromIndex >= len) fromIndex = len - 1;
+	int found = -1;
+	for (char *p = buffer; p <= buffer + fromIndex; p++) {
+		p = strstr(p, s2.buffer);
+		if (!p) break;
+		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
+	}
+	return found;
+}
+
+String String::substring( unsigned int left ) const
+{
+	return substring(left, len);
+}
+
+String String::substring(unsigned int left, unsigned int right) const
+{
+	if (left > right) {
+		unsigned int temp = right;
+		right = left;
+		left = temp;
+	}
+	String out;
+	if (left > len) return out;
+	if (right > len) right = len;
+	char temp = buffer[right];  // save the replaced character
+	buffer[right] = '\0';	
+	out = buffer + left;  // pointer arithmetic
+	buffer[right] = temp;  //restore character
+	return out;
+}
+
+/*********************************************/
+/*  Modification                             */
+/*********************************************/
+
+void String::replace(char find, char replace)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		if (*p == find) *p = replace;
+	}
+}
+
+void String::replace(const String& find, const String& replace)
+{
+	if (len == 0 || find.len == 0) return;
+	int diff = replace.len - find.len;
+	char *readFrom = buffer;
+	char *foundAt;
+	if (diff == 0) {
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			memcpy(foundAt, replace.buffer, replace.len);
+			readFrom = foundAt + replace.len;
+		}
+	} else if (diff < 0) {
+		char *writeTo = buffer;
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			unsigned int n = foundAt - readFrom;
+			memcpy(writeTo, readFrom, n);
+			writeTo += n;
+			memcpy(writeTo, replace.buffer, replace.len);
+			writeTo += replace.len;
+			readFrom = foundAt + find.len;
+			len += diff;
+		}
+		strcpy(writeTo, readFrom);
+	} else {
+		unsigned int size = len; // compute size needed for result
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			readFrom = foundAt + find.len;
+			size += diff;
+		}
+		if (size == len) return;
+		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
+		int index = len - 1;
+		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
+			readFrom = buffer + index + find.len;
+			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
+			len += diff;
+			buffer[len] = 0;
+			memcpy(buffer + index, replace.buffer, replace.len);
+			index--;
+		}
+	}
+}
+
+void String::toLowerCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = tolower(*p);
+	}
+}
+
+void String::toUpperCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = toupper(*p);
+	}
+}
+
+void String::trim(void)
+{
+	if (!buffer || len == 0) return;
+	char *begin = buffer;
+	while (isspace(*begin)) begin++;
+	char *end = buffer + len - 1;
+	while (isspace(*end) && end >= begin) end--;
+	len = end + 1 - begin;
+	if (begin > buffer) memcpy(buffer, begin, len);
+	buffer[len] = 0;
+}
+
+/*********************************************/
+/*  Parsing / Conversion                     */
+/*********************************************/
+
+long String::toInt(void) const
+{
+	if (buffer) return atol(buffer);
+	return 0;
+}
+
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.h
new file mode 100644
index 0000000..947325e
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/WString.h
@@ -0,0 +1,205 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_class_h
+#define String_class_h
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <avr/pgmspace.h>
+
+// When compiling programs with this class, the following gcc parameters
+// dramatically increase performance and memory (RAM) efficiency, typically
+// with little or no increase in code size.
+//     -felide-constructors
+//     -std=c++0x
+
+class __FlashStringHelper;
+#define F(string_literal) (reinterpret_cast<const __FlashStringHelper *>(PSTR(string_literal)))
+
+// An inherited class for holding the result of a concatenation.  These
+// result objects are assumed to be writable by subsequent concatenations.
+class StringSumHelper;
+
+// The string class
+class String
+{
+	// use a function pointer to allow for "if (s)" without the
+	// complications of an operator bool(). for more information, see:
+	// http://www.artima.com/cppsource/safebool.html
+	typedef void (String::*StringIfHelperType)() const;
+	void StringIfHelper() const {}
+
+public:
+	// constructors
+	// creates a copy of the initial value.
+	// if the initial value is null or invalid, or if memory allocation
+	// fails, the string will be marked as invalid (i.e. "if (s)" will
+	// be false).
+	String(const char *cstr = "");
+	String(const String &str);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String(String &&rval);
+	String(StringSumHelper &&rval);
+	#endif
+	explicit String(char c);
+	explicit String(unsigned char, unsigned char base=10);
+	explicit String(int, unsigned char base=10);
+	explicit String(unsigned int, unsigned char base=10);
+	explicit String(long, unsigned char base=10);
+	explicit String(unsigned long, unsigned char base=10);
+	~String(void);
+
+	// memory management
+	// return true on success, false on failure (in which case, the string
+	// is left unchanged).  reserve(0), if successful, will validate an
+	// invalid string (i.e., "if (s)" will be true afterwards)
+	unsigned char reserve(unsigned int size);
+	inline unsigned int length(void) const {return len;}
+
+	// creates a copy of the assigned value.  if the value is null or
+	// invalid, or if the memory allocation fails, the string will be 
+	// marked as invalid ("if (s)" will be false).
+	String & operator = (const String &rhs);
+	String & operator = (const char *cstr);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String & operator = (String &&rval);
+	String & operator = (StringSumHelper &&rval);
+	#endif
+
+	// concatenate (works w/ built-in types)
+	
+	// returns true on success, false on failure (in which case, the string
+	// is left unchanged).  if the argument is null or invalid, the 
+	// concatenation is considered unsucessful.  
+	unsigned char concat(const String &str);
+	unsigned char concat(const char *cstr);
+	unsigned char concat(char c);
+	unsigned char concat(unsigned char c);
+	unsigned char concat(int num);
+	unsigned char concat(unsigned int num);
+	unsigned char concat(long num);
+	unsigned char concat(unsigned long num);
+	
+	// if there's not enough memory for the concatenated value, the string
+	// will be left unchanged (but this isn't signalled in any way)
+	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
+	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
+	String & operator += (char c)			{concat(c); return (*this);}
+	String & operator += (unsigned char num)		{concat(num); return (*this);}
+	String & operator += (int num)			{concat(num); return (*this);}
+	String & operator += (unsigned int num)		{concat(num); return (*this);}
+	String & operator += (long num)			{concat(num); return (*this);}
+	String & operator += (unsigned long num)	{concat(num); return (*this);}
+
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, char c);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, long num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num);
+
+	// comparison (only works w/ Strings and "strings")
+	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
+	int compareTo(const String &s) const;
+	unsigned char equals(const String &s) const;
+	unsigned char equals(const char *cstr) const;
+	unsigned char operator == (const String &rhs) const {return equals(rhs);}
+	unsigned char operator == (const char *cstr) const {return equals(cstr);}
+	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
+	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
+	unsigned char operator <  (const String &rhs) const;
+	unsigned char operator >  (const String &rhs) const;
+	unsigned char operator <= (const String &rhs) const;
+	unsigned char operator >= (const String &rhs) const;
+	unsigned char equalsIgnoreCase(const String &s) const;
+	unsigned char startsWith( const String &prefix) const;
+	unsigned char startsWith(const String &prefix, unsigned int offset) const;
+	unsigned char endsWith(const String &suffix) const;
+
+	// character acccess
+	char charAt(unsigned int index) const;
+	void setCharAt(unsigned int index, char c);
+	char operator [] (unsigned int index) const;
+	char& operator [] (unsigned int index);
+	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
+	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
+		{getBytes((unsigned char *)buf, bufsize, index);}
+
+	// search
+	int indexOf( char ch ) const;
+	int indexOf( char ch, unsigned int fromIndex ) const;
+	int indexOf( const String &str ) const;
+	int indexOf( const String &str, unsigned int fromIndex ) const;
+	int lastIndexOf( char ch ) const;
+	int lastIndexOf( char ch, unsigned int fromIndex ) const;
+	int lastIndexOf( const String &str ) const;
+	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
+	String substring( unsigned int beginIndex ) const;
+	String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+
+	// modification
+	void replace(char find, char replace);
+	void replace(const String& find, const String& replace);
+	void toLowerCase(void);
+	void toUpperCase(void);
+	void trim(void);
+
+	// parsing/conversion
+	long toInt(void) const;
+
+protected:
+	char *buffer;	        // the actual char array
+	unsigned int capacity;  // the array length minus one (for the '\0')
+	unsigned int len;       // the String length (not counting the '\0')
+	unsigned char flags;    // unused, for future features
+protected:
+	void init(void);
+	void invalidate(void);
+	unsigned char changeBuffer(unsigned int maxStrLen);
+	unsigned char concat(const char *cstr, unsigned int length);
+
+	// copy and move
+	String & copy(const char *cstr, unsigned int length);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	void move(String &rhs);
+	#endif
+};
+
+class StringSumHelper : public String
+{
+public:
+	StringSumHelper(const String &s) : String(s) {}
+	StringSumHelper(const char *p) : String(p) {}
+	StringSumHelper(char c) : String(c) {}
+	StringSumHelper(unsigned char num) : String(num) {}
+	StringSumHelper(int num) : String(num) {}
+	StringSumHelper(unsigned int num) : String(num) {}
+	StringSumHelper(long num) : String(num) {}
+	StringSumHelper(unsigned long num) : String(num) {}
+};
+
+#endif  // __cplusplus
+#endif  // String_class_h
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/binary.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/main.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/main.cpp
new file mode 100644
index 0000000..3d4e079
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/main.cpp
@@ -0,0 +1,20 @@
+#include <Arduino.h>
+
+int main(void)
+{
+	init();
+
+#if defined(USBCON)
+	USBDevice.attach();
+#endif
+	
+	setup();
+    
+	for (;;) {
+		loop();
+		if (serialEventRun) serialEventRun();
+	}
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.cpp b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.cpp
new file mode 100644
index 0000000..0f6d422
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.cpp
@@ -0,0 +1,18 @@
+#include <new.h>
+
+void * operator new(size_t size)
+{
+  return malloc(size);
+}
+
+void operator delete(void * ptr)
+{
+  free(ptr);
+} 
+
+int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
+void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
+void __cxa_guard_abort (__guard *) {}; 
+
+void __cxa_pure_virtual(void) {};
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.h
new file mode 100644
index 0000000..cd940ce
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/new.h
@@ -0,0 +1,22 @@
+/* Header to define new/delete operators as they aren't provided by avr-gcc by default
+   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=59453 
+ */
+
+#ifndef NEW_H
+#define NEW_H
+
+#include <stdlib.h>
+
+void * operator new(size_t size);
+void operator delete(void * ptr); 
+
+__extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+extern "C" int __cxa_guard_acquire(__guard *);
+extern "C" void __cxa_guard_release (__guard *);
+extern "C" void __cxa_guard_abort (__guard *); 
+
+extern "C" void __cxa_pure_virtual(void);
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring.c
new file mode 100644
index 0000000..ac8bb6f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring.c
@@ -0,0 +1,324 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
+SIGNAL(TIM0_OVF_vect)
+#else
+SIGNAL(TIMER0_OVF_vect)
+#endif
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+#if F_CPU >= 20000000L
+	// for the 20 MHz clock on rare Arduino boards
+
+	// for a one-microsecond delay, simply wait 2 cycle and return. The overhead
+	// of the function call yields a delay of exactly a one microsecond.
+	__asm__ __volatile__ (
+		"nop" "\n\t"
+		"nop"); //just waiting 2 cycle
+	if (--us == 0)
+		return;
+
+	// the following loop takes a 1/5 of a microsecond (4 cycles)
+	// per iteration, so execute it five times for each microsecond of
+	// delay requested.
+	us = (us<<2) + us; // x5 us
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+
+#elif F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1B, CS10);
+#endif
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1, CS10);
+#endif
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
+	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
+	sbi(TCCR4B, CS41);
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
+	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
+	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
+#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+#endif /* end timer4 block for ATMEGA1280/2560 and similar */	
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..23b01c6
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_analog.c
@@ -0,0 +1,282 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega32U4__)
+	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+	
+#if defined(__AVR_ATmega32U4__)
+	pin = analogPinToChannel(pin);
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#elif defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A)
+			case TIMER4A:
+				//connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				#if defined(COM4A0)		// only used on 32U4
+				cbi(TCCR4A, COM4A0);
+				#endif
+				OCR4A = val;	// set pwm duty
+				break;
+			#endif
+			
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+				
+			#if defined(TCCR4C) && defined(COM4D1)
+			case TIMER4D:				
+				// connect pwm to pin on timer 4, channel D
+				sbi(TCCR4C, COM4D1);
+				#if defined(COM4D0)		// only used on 32U4
+				cbi(TCCR4C, COM4D0);
+				#endif
+				OCR4D = val;	// set pwm duty
+				break;
+			#endif
+
+							
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
+
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..be323b1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_digital.c
@@ -0,0 +1,178 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#define ARDUINO_MAIN
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg, *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+	out = portOutputRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else if (mode == INPUT_PULLUP) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out |= bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif					
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif			
+		#if defined(TCCR4C) && defined(COM4D1)
+		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
+		#endif			
+			
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	uint8_t oldSREG = SREG;
+	cli();
+
+	if (val == LOW) {
+		*out &= ~bit;
+	} else {
+		*out |= bit;
+	}
+
+	SREG = oldSREG;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..f678265
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_private.h
@@ -0,0 +1,71 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Arduino.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
+#define EXTERNAL_NUM_INTERRUPTS 3
+#elif defined(__AVR_ATmega32U4__)
+#define EXTERNAL_NUM_INTERRUPTS 4
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_1.x.x/hardware/rambo/variants/standard/pins_arduino.h b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/variants/standard/pins_arduino.h
new file mode 100644
index 0000000..f49a23f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.x.x/hardware/rambo/variants/standard/pins_arduino.h
@@ -0,0 +1,411 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NUM_DIGITAL_PINS            82
+#define NUM_ANALOG_INPUTS           16
+#define analogInputToDigitalPin(p)  ((p < 16) ? (p) + 54 : -1)
+#define digitalPinHasPWM(p)         (((p) >= 2 && (p) <= 13) || ((p) >= 44 && (p)<= 46))
+
+static const uint8_t SS   = 53;
+static const uint8_t MOSI = 51;
+static const uint8_t MISO = 50;
+static const uint8_t SCK  = 52;
+
+static const uint8_t SDA = 20;
+static const uint8_t SCL = 21;
+static const uint8_t LED_BUILTIN = 13;
+
+static const uint8_t A0 = 54;
+static const uint8_t A1 = 55;
+static const uint8_t A2 = 56;
+static const uint8_t A3 = 57;
+static const uint8_t A4 = 58;
+static const uint8_t A5 = 59;
+static const uint8_t A6 = 60;
+static const uint8_t A7 = 61;
+static const uint8_t A8 = 62;
+static const uint8_t A9 = 63;
+static const uint8_t A10 = 64;
+static const uint8_t A11 = 65;
+static const uint8_t A12 = 66;
+static const uint8_t A13 = 67;
+static const uint8_t A14 = 68;
+static const uint8_t A15 = 69;
+
+// A majority of the pins are NOT PCINTs, SO BE WARNED (i.e. you cannot use them as receive pins)
+// Only pins available for RECEIVE (TRANSMIT can be on any pin):
+// (I've deliberately left out pin mapping to the Hardware USARTs - seems senseless to me)
+// Pins: 10, 11, 12, 13,  50, 51, 52, 53,  62, 63, 64, 65, 66, 67, 68, 69
+
+#define digitalPinToPCICR(p)    ( (((p) >= 10) && ((p) <= 13)) || \
+                                  (((p) >= 50) && ((p) <= 53)) || \
+                                  (((p) >= 62) && ((p) <= 69)) ? (&PCICR) : ((uint8_t *)0) )
+
+#define digitalPinToPCICRbit(p) ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? 0 : \
+                                ( (((p) >= 62) && ((p) <= 69)) ? 2 : \
+                                0 ) )
+
+#define digitalPinToPCMSK(p)    ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? (&PCMSK0) : \
+                                ( (((p) >= 62) && ((p) <= 69)) ? (&PCMSK2) : \
+                                ((uint8_t *)0) ) )
+
+#define digitalPinToPCMSKbit(p) ( (((p) >= 10) && ((p) <= 13)) ? ((p) - 6) : \
+                                ( ((p) == 50) ? 3 : \
+                                ( ((p) == 51) ? 2 : \
+                                ( ((p) == 52) ? 1 : \
+                                ( ((p) == 53) ? 0 : \
+                                ( (((p) >= 62) && ((p) <= 69)) ? ((p) - 62) : \
+                                0 ) ) ) ) ) )
+
+#ifdef ARDUINO_MAIN
+
+const uint16_t PROGMEM port_to_mode_PGM[] = {
+	NOT_A_PORT,
+	(uint16_t) &DDRA,
+	(uint16_t) &DDRB,
+	(uint16_t) &DDRC,
+	(uint16_t) &DDRD,
+	(uint16_t) &DDRE,
+	(uint16_t) &DDRF,
+	(uint16_t) &DDRG,
+	(uint16_t) &DDRH,
+	NOT_A_PORT,
+	(uint16_t) &DDRJ,
+	(uint16_t) &DDRK,
+	(uint16_t) &DDRL,
+};
+
+const uint16_t PROGMEM port_to_output_PGM[] = {
+	NOT_A_PORT,
+	(uint16_t) &PORTA,
+	(uint16_t) &PORTB,
+	(uint16_t) &PORTC,
+	(uint16_t) &PORTD,
+	(uint16_t) &PORTE,
+	(uint16_t) &PORTF,
+	(uint16_t) &PORTG,
+	(uint16_t) &PORTH,
+	NOT_A_PORT,
+	(uint16_t) &PORTJ,
+	(uint16_t) &PORTK,
+	(uint16_t) &PORTL,
+};
+
+const uint16_t PROGMEM port_to_input_PGM[] = {
+	NOT_A_PIN,
+	(uint16_t) &PINA,
+	(uint16_t) &PINB,
+	(uint16_t) &PINC,
+	(uint16_t) &PIND,
+	(uint16_t) &PINE,
+	(uint16_t) &PINF,
+	(uint16_t) &PING,
+	(uint16_t) &PINH,
+	NOT_A_PIN,
+	(uint16_t) &PINJ,
+	(uint16_t) &PINK,
+	(uint16_t) &PINL,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] = {
+	// PORTLIST
+	// -------------------------------------------
+	PE	, // PE 0 ** 0 ** USART0_RX
+	PE	, // PE 1 ** 1 ** USART0_TX
+	PE	, // PE 4 ** 2 ** PWM2
+	PE	, // PE 5 ** 3 ** PWM3
+	PG	, // PG 5 ** 4 ** PWM4
+	PE	, // PE 3 ** 5 ** PWM5
+	PH	, // PH 3 ** 6 ** PWM6
+	PH	, // PH 4 ** 7 ** PWM7
+	PH	, // PH 5 ** 8 ** PWM8
+	PH	, // PH 6 ** 9 ** PWM9
+	PB	, // PB 4 ** 10 ** PWM10
+	PB	, // PB 5 ** 11 ** PWM11
+	PB	, // PB 6 ** 12 ** PWM12
+	PB	, // PB 7 ** 13 ** PWM13
+	PJ	, // PJ 1 ** 14 ** USART3_TX
+	PJ	, // PJ 0 ** 15 ** USART3_RX
+	PH	, // PH 1 ** 16 ** USART2_TX
+	PH	, // PH 0 ** 17 ** USART2_RX
+	PD	, // PD 3 ** 18 ** USART1_TX
+	PD	, // PD 2 ** 19 ** USART1_RX
+	PD	, // PD 1 ** 20 ** I2C_SDA
+	PD	, // PD 0 ** 21 ** I2C_SCL
+	PA	, // PA 0 ** 22 ** D22
+	PA	, // PA 1 ** 23 ** D23
+	PA	, // PA 2 ** 24 ** D24
+	PA	, // PA 3 ** 25 ** D25
+	PA	, // PA 4 ** 26 ** D26
+	PA	, // PA 5 ** 27 ** D27
+	PA	, // PA 6 ** 28 ** D28
+	PA	, // PA 7 ** 29 ** D29
+	PC	, // PC 7 ** 30 ** D30
+	PC	, // PC 6 ** 31 ** D31
+	PC	, // PC 5 ** 32 ** D32
+	PC	, // PC 4 ** 33 ** D33
+	PC	, // PC 3 ** 34 ** D34
+	PC	, // PC 2 ** 35 ** D35
+	PC	, // PC 1 ** 36 ** D36
+	PC	, // PC 0 ** 37 ** D37
+	PD	, // PD 7 ** 38 ** D38
+	PG	, // PG 2 ** 39 ** D39
+	PG	, // PG 1 ** 40 ** D40
+	PG	, // PG 0 ** 41 ** D41
+	PL	, // PL 7 ** 42 ** D42
+	PL	, // PL 6 ** 43 ** D43
+	PL	, // PL 5 ** 44 ** D44
+	PL	, // PL 4 ** 45 ** D45
+	PL	, // PL 3 ** 46 ** D46
+	PL	, // PL 2 ** 47 ** D47
+	PL	, // PL 1 ** 48 ** D48
+	PL	, // PL 0 ** 49 ** D49
+	PB	, // PB 3 ** 50 ** SPI_MISO
+	PB	, // PB 2 ** 51 ** SPI_MOSI
+	PB	, // PB 1 ** 52 ** SPI_SCK
+	PB	, // PB 0 ** 53 ** SPI_SS
+	PF	, // PF 0 ** 54 ** A0
+	PF	, // PF 1 ** 55 ** A1
+	PF	, // PF 2 ** 56 ** A2
+	PF	, // PF 3 ** 57 ** A3
+	PF	, // PF 4 ** 58 ** A4
+	PF	, // PF 5 ** 59 ** A5
+	PF	, // PF 6 ** 60 ** A6
+	PF	, // PF 7 ** 61 ** A7
+	PK	, // PK 0 ** 62 ** A8
+	PK	, // PK 1 ** 63 ** A9
+	PK	, // PK 2 ** 64 ** A10
+	PK	, // PK 3 ** 65 ** A11
+	PK	, // PK 4 ** 66 ** A12
+	PK	, // PK 5 ** 67 ** A13
+	PK	, // PK 6 ** 68 ** A14
+	PK	, // PK 7 ** 69 ** A15
+	PG 	, // PG 4 ** 70 ** D70
+	PG 	, // PG 3 ** 71 ** D71
+	PJ 	, // PJ 2 ** 72 ** D72
+	PJ 	, // PJ 3 ** 73 ** D73
+	PJ 	, // PJ 7 ** 74 ** D74
+	PJ 	, // PJ 4 ** 75 ** D75
+	PJ 	, // PJ 5 ** 76 ** D76
+	PJ 	, // PJ 6 ** 77 ** D77
+	PE 	, // PE 2 ** 78 ** D78
+	PE 	, // PE 6 ** 79 ** D79
+	PE 	, // PE 7 ** 80 ** D80
+	PD 	, // PD 4 ** 81 ** D81
+	PD 	, // PD 5 ** 82 ** D82
+	PD 	, // PD 6 ** 83 ** D83
+	PH 	, // PH 2 ** 84 ** D84
+	PH 	, // PH 7 ** 85 ** D85
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {
+	// PIN IN PORT
+	// -------------------------------------------
+	_BV( 0 )	, // PE 0 ** 0 ** USART0_RX
+	_BV( 1 )	, // PE 1 ** 1 ** USART0_TX
+	_BV( 4 )	, // PE 4 ** 2 ** PWM2
+	_BV( 5 )	, // PE 5 ** 3 ** PWM3
+	_BV( 5 )	, // PG 5 ** 4 ** PWM4
+	_BV( 3 )	, // PE 3 ** 5 ** PWM5
+	_BV( 3 )	, // PH 3 ** 6 ** PWM6
+	_BV( 4 )	, // PH 4 ** 7 ** PWM7
+	_BV( 5 )	, // PH 5 ** 8 ** PWM8
+	_BV( 6 )	, // PH 6 ** 9 ** PWM9
+	_BV( 4 )	, // PB 4 ** 10 ** PWM10
+	_BV( 5 )	, // PB 5 ** 11 ** PWM11
+	_BV( 6 )	, // PB 6 ** 12 ** PWM12
+	_BV( 7 )	, // PB 7 ** 13 ** PWM13
+	_BV( 1 )	, // PJ 1 ** 14 ** USART3_TX
+	_BV( 0 )	, // PJ 0 ** 15 ** USART3_RX
+	_BV( 1 )	, // PH 1 ** 16 ** USART2_TX
+	_BV( 0 )	, // PH 0 ** 17 ** USART2_RX
+	_BV( 3 )	, // PD 3 ** 18 ** USART1_TX
+	_BV( 2 )	, // PD 2 ** 19 ** USART1_RX
+	_BV( 1 )	, // PD 1 ** 20 ** I2C_SDA
+	_BV( 0 )	, // PD 0 ** 21 ** I2C_SCL
+	_BV( 0 )	, // PA 0 ** 22 ** D22
+	_BV( 1 )	, // PA 1 ** 23 ** D23
+	_BV( 2 )	, // PA 2 ** 24 ** D24
+	_BV( 3 )	, // PA 3 ** 25 ** D25
+	_BV( 4 )	, // PA 4 ** 26 ** D26
+	_BV( 5 )	, // PA 5 ** 27 ** D27
+	_BV( 6 )	, // PA 6 ** 28 ** D28
+	_BV( 7 )	, // PA 7 ** 29 ** D29
+	_BV( 7 )	, // PC 7 ** 30 ** D30
+	_BV( 6 )	, // PC 6 ** 31 ** D31
+	_BV( 5 )	, // PC 5 ** 32 ** D32
+	_BV( 4 )	, // PC 4 ** 33 ** D33
+	_BV( 3 )	, // PC 3 ** 34 ** D34
+	_BV( 2 )	, // PC 2 ** 35 ** D35
+	_BV( 1 )	, // PC 1 ** 36 ** D36
+	_BV( 0 )	, // PC 0 ** 37 ** D37
+	_BV( 7 )	, // PD 7 ** 38 ** D38
+	_BV( 2 )	, // PG 2 ** 39 ** D39
+	_BV( 1 )	, // PG 1 ** 40 ** D40
+	_BV( 0 )	, // PG 0 ** 41 ** D41
+	_BV( 7 )	, // PL 7 ** 42 ** D42
+	_BV( 6 )	, // PL 6 ** 43 ** D43
+	_BV( 5 )	, // PL 5 ** 44 ** D44
+	_BV( 4 )	, // PL 4 ** 45 ** D45
+	_BV( 3 )	, // PL 3 ** 46 ** D46
+	_BV( 2 )	, // PL 2 ** 47 ** D47
+	_BV( 1 )	, // PL 1 ** 48 ** D48
+	_BV( 0 )	, // PL 0 ** 49 ** D49
+	_BV( 3 )	, // PB 3 ** 50 ** SPI_MISO
+	_BV( 2 )	, // PB 2 ** 51 ** SPI_MOSI
+	_BV( 1 )	, // PB 1 ** 52 ** SPI_SCK
+	_BV( 0 )	, // PB 0 ** 53 ** SPI_SS
+	_BV( 0 )	, // PF 0 ** 54 ** A0
+	_BV( 1 )	, // PF 1 ** 55 ** A1
+	_BV( 2 )	, // PF 2 ** 56 ** A2
+	_BV( 3 )	, // PF 3 ** 57 ** A3
+	_BV( 4 )	, // PF 4 ** 58 ** A4
+	_BV( 5 )	, // PF 5 ** 59 ** A5
+	_BV( 6 )	, // PF 6 ** 60 ** A6
+	_BV( 7 )	, // PF 7 ** 61 ** A7
+	_BV( 0 )	, // PK 0 ** 62 ** A8
+	_BV( 1 )	, // PK 1 ** 63 ** A9
+	_BV( 2 )	, // PK 2 ** 64 ** A10
+	_BV( 3 )	, // PK 3 ** 65 ** A11
+	_BV( 4 )	, // PK 4 ** 66 ** A12
+	_BV( 5 )	, // PK 5 ** 67 ** A13
+	_BV( 6 )	, // PK 6 ** 68 ** A14
+	_BV( 7 )	, // PK 7 ** 69 ** A15
+	_BV( 4 )	, // PG 4 ** 70 ** D70
+	_BV( 3 )	, // PG 3 ** 71 ** D71
+	_BV( 2 )	, // PJ 2 ** 72 ** D72
+	_BV( 3 )	, // PJ 3 ** 73 ** D73
+	_BV( 7 )	, // PJ 7 ** 74 ** D74
+	_BV( 4 )	, // PJ 4 ** 75 ** D75
+	_BV( 5 )	, // PJ 5 ** 76 ** D76
+	_BV( 6 )	, // PJ 6 ** 77 ** D77
+	_BV( 2 )	, // PE 2 ** 78 ** D78
+	_BV( 6 )	, // PE 6 ** 79 ** D79
+	_BV( 7 )	, // PE 7 ** 80 ** D80
+	_BV( 4 )	, // PD 4 ** 81 ** D81
+	_BV( 5 ) 	, // PD 5 ** 82 ** D82
+	_BV( 6 ) 	, // PD 6 ** 83 ** D83
+	_BV( 2 ) 	, // PH 2 ** 84 ** D84
+	_BV( 7 ) 	, // PH 7 ** 85 ** D85
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] = {
+	// TIMERS
+	// -------------------------------------------
+	NOT_ON_TIMER	, // PE 0 ** 0 ** USART0_RX
+	NOT_ON_TIMER	, // PE 1 ** 1 ** USART0_TX
+	TIMER3B		, // PE 4 ** 2 ** PWM2
+	TIMER3C		, // PE 5 ** 3 ** PWM3
+	TIMER0B		, // PG 5 ** 4 ** PWM4
+	TIMER3A		, // PE 3 ** 5 ** PWM5
+	TIMER4A		, // PH 3 ** 6 ** PWM6
+	TIMER4B		, // PH 4 ** 7 ** PWM7
+	TIMER4C		, // PH 5 ** 8 ** PWM8
+	TIMER2B		, // PH 6 ** 9 ** PWM9
+	TIMER2A		, // PB 4 ** 10 ** PWM10
+	TIMER1A		, // PB 5 ** 11 ** PWM11
+	TIMER1B		, // PB 6 ** 12 ** PWM12
+	TIMER0A		, // PB 7 ** 13 ** PWM13
+	NOT_ON_TIMER	, // PJ 1 ** 14 ** USART3_TX
+	NOT_ON_TIMER	, // PJ 0 ** 15 ** USART3_RX
+	NOT_ON_TIMER	, // PH 1 ** 16 ** USART2_TX
+	NOT_ON_TIMER	, // PH 0 ** 17 ** USART2_RX
+	NOT_ON_TIMER	, // PD 3 ** 18 ** USART1_TX
+	NOT_ON_TIMER	, // PD 2 ** 19 ** USART1_RX
+	NOT_ON_TIMER	, // PD 1 ** 20 ** I2C_SDA
+	NOT_ON_TIMER	, // PD 0 ** 21 ** I2C_SCL
+	NOT_ON_TIMER	, // PA 0 ** 22 ** D22
+	NOT_ON_TIMER	, // PA 1 ** 23 ** D23
+	NOT_ON_TIMER	, // PA 2 ** 24 ** D24
+	NOT_ON_TIMER	, // PA 3 ** 25 ** D25
+	NOT_ON_TIMER	, // PA 4 ** 26 ** D26
+	NOT_ON_TIMER	, // PA 5 ** 27 ** D27
+	NOT_ON_TIMER	, // PA 6 ** 28 ** D28
+	NOT_ON_TIMER	, // PA 7 ** 29 ** D29
+	NOT_ON_TIMER	, // PC 7 ** 30 ** D30
+	NOT_ON_TIMER	, // PC 6 ** 31 ** D31
+	NOT_ON_TIMER	, // PC 5 ** 32 ** D32
+	NOT_ON_TIMER	, // PC 4 ** 33 ** D33
+	NOT_ON_TIMER	, // PC 3 ** 34 ** D34
+	NOT_ON_TIMER	, // PC 2 ** 35 ** D35
+	NOT_ON_TIMER	, // PC 1 ** 36 ** D36
+	NOT_ON_TIMER	, // PC 0 ** 37 ** D37
+	NOT_ON_TIMER	, // PD 7 ** 38 ** D38
+	NOT_ON_TIMER	, // PG 2 ** 39 ** D39
+	NOT_ON_TIMER	, // PG 1 ** 40 ** D40
+	NOT_ON_TIMER	, // PG 0 ** 41 ** D41
+	NOT_ON_TIMER	, // PL 7 ** 42 ** D42
+	NOT_ON_TIMER	, // PL 6 ** 43 ** D43
+	TIMER5C		, // PL 5 ** 44 ** D44
+	TIMER5B		, // PL 4 ** 45 ** D45
+	TIMER5A		, // PL 3 ** 46 ** D46
+	NOT_ON_TIMER	, // PL 2 ** 47 ** D47
+	NOT_ON_TIMER	, // PL 1 ** 48 ** D48
+	NOT_ON_TIMER	, // PL 0 ** 49 ** D49
+	NOT_ON_TIMER	, // PB 3 ** 50 ** SPI_MISO
+	NOT_ON_TIMER	, // PB 2 ** 51 ** SPI_MOSI
+	NOT_ON_TIMER	, // PB 1 ** 52 ** SPI_SCK
+	NOT_ON_TIMER	, // PB 0 ** 53 ** SPI_SS
+	NOT_ON_TIMER	, // PF 0 ** 54 ** A0	
+	NOT_ON_TIMER	, // PF 1 ** 55 ** A1	
+	NOT_ON_TIMER	, // PF 2 ** 56 ** A2	
+	NOT_ON_TIMER	, // PF 3 ** 57 ** A3	
+	NOT_ON_TIMER	, // PF 4 ** 58 ** A4	
+	NOT_ON_TIMER	, // PF 5 ** 59 ** A5	
+	NOT_ON_TIMER	, // PF 6 ** 60 ** A6	
+	NOT_ON_TIMER	, // PF 7 ** 61 ** A7	
+	NOT_ON_TIMER	, // PK 0 ** 62 ** A8	
+	NOT_ON_TIMER	, // PK 1 ** 63 ** A9	
+	NOT_ON_TIMER	, // PK 2 ** 64 ** A10	
+	NOT_ON_TIMER	, // PK 3 ** 65 ** A11	
+	NOT_ON_TIMER	, // PK 4 ** 66 ** A12	
+	NOT_ON_TIMER	, // PK 5 ** 67 ** A13	
+	NOT_ON_TIMER	, // PK 6 ** 68 ** A14	
+	NOT_ON_TIMER	, // PK 7 ** 69 ** A15
+	NOT_ON_TIMER	, // PG 4 ** 70 ** D70
+	NOT_ON_TIMER	, // PG 3 ** 71 ** D71
+	NOT_ON_TIMER	, // PJ 2 ** 72 ** D72
+	NOT_ON_TIMER	, // PJ 3 ** 73 ** D73
+	NOT_ON_TIMER	, // PJ 7 ** 74 ** D74
+	NOT_ON_TIMER	, // PJ 4 ** 75 ** D75
+	NOT_ON_TIMER	, // PJ 5 ** 76 ** D76
+	NOT_ON_TIMER	, // PJ 6 ** 77 ** D77
+	NOT_ON_TIMER	, // PE 2 ** 78 ** D78
+	NOT_ON_TIMER	, // PE 6 ** 79 ** D79
+	NOT_ON_TIMER	, // PE 7 ** 80 ** D80
+	NOT_ON_TIMER	, // PD 4 ** 81 ** D81
+	NOT_ON_TIMER 	, // PD 5 ** 82 ** D82
+	NOT_ON_TIMER 	, // PD 6 ** 83 ** D83
+	NOT_ON_TIMER 	, // PH 2 ** 84 ** D84
+	NOT_ON_TIMER 	, // PH 7 ** 85 ** D85
+};
+
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/boards.txt b/ArduinoAddons/Arduino_1.x.x/rambo/boards.txt
deleted file mode 100644
index d090165..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/boards.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-# See: http://code.google.com/p/arduino/wiki/Platforms
-
-##############################################################
-
-mega2560.name=RAMBo
-
-mega2560.upload.protocol=wiring
-mega2560.upload.maximum_size=258048
-mega2560.upload.speed=115200
-
-mega2560.bootloader.low_fuses=0xFF
-mega2560.bootloader.high_fuses=0xD8
-mega2560.bootloader.extended_fuses=0xFD
-mega2560.bootloader.path=stk500v2
-mega2560.bootloader.file=stk500boot_v2_mega2560.hex
-mega2560.bootloader.unlock_bits=0x3F
-mega2560.bootloader.lock_bits=0x0F
-
-mega2560.build.mcu=atmega2560
-mega2560.build.f_cpu=16000000L
-mega2560.build.core=arduino
-mega2560.build.variant=standard
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Arduino.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Arduino.h
deleted file mode 100644
index b265825..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Arduino.h
+++ /dev/null
@@ -1,215 +0,0 @@
-#ifndef Arduino_h
-#define Arduino_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/pgmspace.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-#define INPUT_PULLUP 0x2
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
-#define DEFAULT 0
-#define EXTERNAL 1
-#define INTERNAL 2
-#else  
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-#endif
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
-#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-
-#define analogInPinToBit(P) (P)
-
-// On the ATmega1280, the addresses of some of the port registers are
-// greater than 255, so we can't store them in uint8_t's.
-extern const uint16_t PROGMEM port_to_mode_PGM[];
-extern const uint16_t PROGMEM port_to_input_PGM[];
-extern const uint16_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#ifdef ARDUINO_MAIN
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-#define PE 5
-#define PF 6
-#define PG 7
-#define PH 8
-#define PJ 10
-#define PK 11
-#define PL 12
-#endif
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-#define TIMER3A 8
-#define TIMER3B 9
-#define TIMER3C 10
-#define TIMER4A 11
-#define TIMER4B 12
-#define TIMER4C 13
-#define TIMER4D 14	
-#define TIMER5A 15
-#define TIMER5B 16
-#define TIMER5C 17
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-
-#endif
-
-#include "pins_arduino.h"
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/CDC.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/CDC.cpp
deleted file mode 100644
index 701e483..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/CDC.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include <avr/wdt.h>
-
-#if defined(USBCON)
-#ifdef CDC_ENABLED
-
-#if (RAMEND < 1000)
-#define SERIAL_BUFFER_SIZE 16
-#else
-#define SERIAL_BUFFER_SIZE 64
-#endif
-
-struct ring_buffer
-{
-	unsigned char buffer[SERIAL_BUFFER_SIZE];
-	volatile int head;
-	volatile int tail;
-};
-
-ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
-
-typedef struct
-{
-	u32	dwDTERate;
-	u8	bCharFormat;
-	u8 	bParityType;
-	u8 	bDataBits;
-	u8	lineState;
-} LineInfo;
-
-static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
-
-#define WEAK __attribute__ ((weak))
-
-extern const CDCDescriptor _cdcInterface PROGMEM;
-const CDCDescriptor _cdcInterface =
-{
-	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
-
-	//	CDC communication interface
-	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
-	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
-	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
-	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported
-	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, data interface is slave 0
-	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
-
-	//	CDC data interface
-	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
-	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
-	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
-};
-
-int WEAK CDC_GetInterface(u8* interfaceNum)
-{
-	interfaceNum[0] += 2;	// uses 2
-	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
-}
-
-bool WEAK CDC_Setup(Setup& setup)
-{
-	u8 r = setup.bRequest;
-	u8 requestType = setup.bmRequestType;
-
-	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
-	{
-		if (CDC_GET_LINE_CODING == r)
-		{
-			USB_SendControl(0,(void*)&_usbLineInfo,7);
-			return true;
-		}
-	}
-
-	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
-	{
-		if (CDC_SET_LINE_CODING == r)
-		{
-			USB_RecvControl((void*)&_usbLineInfo,7);
-			return true;
-		}
-
-		if (CDC_SET_CONTROL_LINE_STATE == r)
-		{
-			_usbLineInfo.lineState = setup.wValueL;
-
-			// auto-reset into the bootloader is triggered when the port, already 
-			// open at 1200 bps, is closed.  this is the signal to start the watchdog
-			// with a relatively long period so it can finish housekeeping tasks
-			// like servicing endpoints before the sketch ends
-			if (1200 == _usbLineInfo.dwDTERate) {
-				// We check DTR state to determine if host port is open (bit 0 of lineState).
-				if ((_usbLineInfo.lineState & 0x01) == 0) {
-					*(uint16_t *)0x0800 = 0x7777;
-					wdt_enable(WDTO_120MS);
-				} else {
-					// Most OSs do some intermediate steps when configuring ports and DTR can
-					// twiggle more than once before stabilizing.
-					// To avoid spurious resets we set the watchdog to 250ms and eventually
-					// cancel if DTR goes back high.
-	
-					wdt_disable();
-					wdt_reset();
-					*(uint16_t *)0x0800 = 0x0;
-				}
-			}
-			return true;
-		}
-	}
-	return false;
-}
-
-
-int _serialPeek = -1;
-void Serial_::begin(uint16_t baud_count)
-{
-}
-
-void Serial_::end(void)
-{
-}
-
-void Serial_::accept(void) 
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
-	
-	// if we should be storing the received character into the location
-	// just before the tail (meaning that the head would advance to the
-	// current location of the tail), we're about to overflow the buffer
-	// and so we don't write the character or advance the head.
-
-	// while we have room to store a byte
-	while (i != buffer->tail) {
-		int c = USB_Recv(CDC_RX);
-		if (c == -1)
-			break;	// no more data
-		buffer->buffer[buffer->head] = c;
-		buffer->head = i;
-
-		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
-	}
-}
-
-int Serial_::available(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
-}
-
-int Serial_::peek(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	if (buffer->head == buffer->tail) {
-		return -1;
-	} else {
-		return buffer->buffer[buffer->tail];
-	}
-}
-
-int Serial_::read(void)
-{
-	ring_buffer *buffer = &cdc_rx_buffer;
-	// if the head isn't ahead of the tail, we don't have any characters
-	if (buffer->head == buffer->tail) {
-		return -1;
-	} else {
-		unsigned char c = buffer->buffer[buffer->tail];
-		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
-		return c;
-	}	
-}
-
-void Serial_::flush(void)
-{
-	USB_Flush(CDC_TX);
-}
-
-size_t Serial_::write(uint8_t c)
-{
-	/* only try to send bytes if the high-level CDC connection itself 
-	 is open (not just the pipe) - the OS should set lineState when the port
-	 is opened and clear lineState when the port is closed.
-	 bytes sent before the user opens the connection or after
-	 the connection is closed are lost - just like with a UART. */
-	
-	// TODO - ZE - check behavior on different OSes and test what happens if an
-	// open connection isn't broken cleanly (cable is yanked out, host dies
-	// or locks up, or host virtual serial port hangs)
-	if (_usbLineInfo.lineState > 0)	{
-		int r = USB_Send(CDC_TX,&c,1);
-		if (r > 0) {
-			return r;
-		} else {
-			setWriteError();
-			return 0;
-		}
-	}
-	setWriteError();
-	return 0;
-}
-
-// This operator is a convenient way for a sketch to check whether the
-// port has actually been configured and opened by the host (as opposed
-// to just being connected to the host).  It can be used, for example, in 
-// setup() before printing to ensure that an application on the host is
-// actually ready to receive and display the data.
-// We add a short delay before returning to fix a bug observed by Federico
-// where the port is configured (lineState != 0) but not quite opened.
-Serial_::operator bool() {
-	bool result = false;
-	if (_usbLineInfo.lineState > 0) 
-		result = true;
-	delay(10);
-	return result;
-}
-
-Serial_ Serial;
-
-#endif
-#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Client.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Client.h
deleted file mode 100644
index ea13483..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Client.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef client_h
-#define client_h
-#include "Print.h"
-#include "Stream.h"
-#include "IPAddress.h"
-
-class Client : public Stream {
-
-public:
-  virtual int connect(IPAddress ip, uint16_t port) =0;
-  virtual int connect(const char *host, uint16_t port) =0;
-  virtual size_t write(uint8_t) =0;
-  virtual size_t write(const uint8_t *buf, size_t size) =0;
-  virtual int available() = 0;
-  virtual int read() = 0;
-  virtual int read(uint8_t *buf, size_t size) = 0;
-  virtual int peek() = 0;
-  virtual void flush() = 0;
-  virtual void stop() = 0;
-  virtual uint8_t connected() = 0;
-  virtual operator bool() = 0;
-protected:
-  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HID.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HID.cpp
deleted file mode 100644
index ac63608..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HID.cpp
+++ /dev/null
@@ -1,520 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include "USBDesc.h"
-
-#if defined(USBCON)
-#ifdef HID_ENABLED
-
-//#define RAWHID_ENABLED
-
-//	Singletons for mouse and keyboard
-
-Mouse_ Mouse;
-Keyboard_ Keyboard;
-
-//================================================================================
-//================================================================================
-
-//	HID report descriptor
-
-#define LSB(_x) ((_x) & 0xFF)
-#define MSB(_x) ((_x) >> 8)
-
-#define RAWHID_USAGE_PAGE	0xFFC0
-#define RAWHID_USAGE		0x0C00
-#define RAWHID_TX_SIZE 64
-#define RAWHID_RX_SIZE 64
-
-extern const u8 _hidReportDescriptor[] PROGMEM;
-const u8 _hidReportDescriptor[] = {
-	
-	//	Mouse
-    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 54
-    0x09, 0x02,                    // USAGE (Mouse)
-    0xa1, 0x01,                    // COLLECTION (Application)
-    0x09, 0x01,                    //   USAGE (Pointer)
-    0xa1, 0x00,                    //   COLLECTION (Physical)
-    0x85, 0x01,                    //     REPORT_ID (1)
-    0x05, 0x09,                    //     USAGE_PAGE (Button)
-    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
-    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
-    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
-    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
-    0x95, 0x03,                    //     REPORT_COUNT (3)
-    0x75, 0x01,                    //     REPORT_SIZE (1)
-    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
-    0x95, 0x01,                    //     REPORT_COUNT (1)
-    0x75, 0x05,                    //     REPORT_SIZE (5)
-    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
-    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
-    0x09, 0x30,                    //     USAGE (X)
-    0x09, 0x31,                    //     USAGE (Y)
-    0x09, 0x38,                    //     USAGE (Wheel)
-    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
-    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
-    0x75, 0x08,                    //     REPORT_SIZE (8)
-    0x95, 0x03,                    //     REPORT_COUNT (3)
-    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
-    0xc0,                          //   END_COLLECTION
-    0xc0,                          // END_COLLECTION
-
-	//	Keyboard
-    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 47
-    0x09, 0x06,                    // USAGE (Keyboard)
-    0xa1, 0x01,                    // COLLECTION (Application)
-    0x85, 0x02,                    //   REPORT_ID (2)
-    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
-   
-	0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
-    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
-    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
-    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
-    0x75, 0x01,                    //   REPORT_SIZE (1)
-    
-	0x95, 0x08,                    //   REPORT_COUNT (8)
-    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
-    0x95, 0x01,                    //   REPORT_COUNT (1)
-    0x75, 0x08,                    //   REPORT_SIZE (8)
-    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
-    
-	0x95, 0x06,                    //   REPORT_COUNT (6)
-    0x75, 0x08,                    //   REPORT_SIZE (8)
-    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
-    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
-    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
-    
-	0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
-    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
-    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
-    0xc0,                          // END_COLLECTION
-
-#if RAWHID_ENABLED
-	//	RAW HID
-	0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),	// 30
-	0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
-
-	0xA1, 0x01,				// Collection 0x01
-    0x85, 0x03,             // REPORT_ID (3)
-	0x75, 0x08,				// report size = 8 bits
-	0x15, 0x00,				// logical minimum = 0
-	0x26, 0xFF, 0x00,		// logical maximum = 255
-
-	0x95, 64,				// report count TX
-	0x09, 0x01,				// usage
-	0x81, 0x02,				// Input (array)
-
-	0x95, 64,				// report count RX
-	0x09, 0x02,				// usage
-	0x91, 0x02,				// Output (array)
-	0xC0					// end collection
-#endif
-};
-
-extern const HIDDescriptor _hidInterface PROGMEM;
-const HIDDescriptor _hidInterface =
-{
-	D_INTERFACE(HID_INTERFACE,1,3,0,0),
-	D_HIDREPORT(sizeof(_hidReportDescriptor)),
-	D_ENDPOINT(USB_ENDPOINT_IN (HID_ENDPOINT_INT),USB_ENDPOINT_TYPE_INTERRUPT,0x40,0x01)
-};
-
-//================================================================================
-//================================================================================
-//	Driver
-
-u8 _hid_protocol = 1;
-u8 _hid_idle = 1;
-
-#define WEAK __attribute__ ((weak))
-
-int WEAK HID_GetInterface(u8* interfaceNum)
-{
-	interfaceNum[0] += 1;	// uses 1
-	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
-}
-
-int WEAK HID_GetDescriptor(int i)
-{
-	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
-}
-
-void WEAK HID_SendReport(u8 id, const void* data, int len)
-{
-	USB_Send(HID_TX, &id, 1);
-	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
-}
-
-bool WEAK HID_Setup(Setup& setup)
-{
-	u8 r = setup.bRequest;
-	u8 requestType = setup.bmRequestType;
-	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
-	{
-		if (HID_GET_REPORT == r)
-		{
-			//HID_GetReport();
-			return true;
-		}
-		if (HID_GET_PROTOCOL == r)
-		{
-			//Send8(_hid_protocol);	// TODO
-			return true;
-		}
-	}
-	
-	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
-	{
-		if (HID_SET_PROTOCOL == r)
-		{
-			_hid_protocol = setup.wValueL;
-			return true;
-		}
-
-		if (HID_SET_IDLE == r)
-		{
-			_hid_idle = setup.wValueL;
-			return true;
-		}
-	}
-	return false;
-}
-
-//================================================================================
-//================================================================================
-//	Mouse
-
-Mouse_::Mouse_(void) : _buttons(0)
-{
-}
-
-void Mouse_::begin(void) 
-{
-}
-
-void Mouse_::end(void) 
-{
-}
-
-void Mouse_::click(uint8_t b)
-{
-	_buttons = b;
-	move(0,0,0);
-	_buttons = 0;
-	move(0,0,0);
-}
-
-void Mouse_::move(signed char x, signed char y, signed char wheel)
-{
-	u8 m[4];
-	m[0] = _buttons;
-	m[1] = x;
-	m[2] = y;
-	m[3] = wheel;
-	HID_SendReport(1,m,4);
-}
-
-void Mouse_::buttons(uint8_t b)
-{
-	if (b != _buttons)
-	{
-		_buttons = b;
-		move(0,0,0);
-	}
-}
-
-void Mouse_::press(uint8_t b) 
-{
-	buttons(_buttons | b);
-}
-
-void Mouse_::release(uint8_t b)
-{
-	buttons(_buttons & ~b);
-}
-
-bool Mouse_::isPressed(uint8_t b)
-{
-	if ((b & _buttons) > 0) 
-		return true;
-	return false;
-}
-
-//================================================================================
-//================================================================================
-//	Keyboard
-
-Keyboard_::Keyboard_(void) 
-{
-}
-
-void Keyboard_::begin(void) 
-{
-}
-
-void Keyboard_::end(void) 
-{
-}
-
-void Keyboard_::sendReport(KeyReport* keys)
-{
-	HID_SendReport(2,keys,sizeof(KeyReport));
-}
-
-extern
-const uint8_t _asciimap[128] PROGMEM;
-
-#define SHIFT 0x80
-const uint8_t _asciimap[128] =
-{
-	0x00,             // NUL
-	0x00,             // SOH
-	0x00,             // STX
-	0x00,             // ETX
-	0x00,             // EOT
-	0x00,             // ENQ
-	0x00,             // ACK  
-	0x00,             // BEL
-	0x2a,			// BS	Backspace
-	0x2b,			// TAB	Tab
-	0x28,			// LF	Enter
-	0x00,             // VT 
-	0x00,             // FF 
-	0x00,             // CR 
-	0x00,             // SO 
-	0x00,             // SI 
-	0x00,             // DEL
-	0x00,             // DC1
-	0x00,             // DC2
-	0x00,             // DC3
-	0x00,             // DC4
-	0x00,             // NAK
-	0x00,             // SYN
-	0x00,             // ETB
-	0x00,             // CAN
-	0x00,             // EM 
-	0x00,             // SUB
-	0x00,             // ESC
-	0x00,             // FS 
-	0x00,             // GS 
-	0x00,             // RS 
-	0x00,             // US 
-
-	0x2c,		   //  ' '
-	0x1e|SHIFT,	   // !
-	0x34|SHIFT,	   // "
-	0x20|SHIFT,    // #
-	0x21|SHIFT,    // $
-	0x22|SHIFT,    // %
-	0x24|SHIFT,    // &
-	0x34,          // '
-	0x26|SHIFT,    // (
-	0x27|SHIFT,    // )
-	0x25|SHIFT,    // *
-	0x2e|SHIFT,    // +
-	0x36,          // ,
-	0x2d,          // -
-	0x37,          // .
-	0x38,          // /
-	0x27,          // 0
-	0x1e,          // 1
-	0x1f,          // 2
-	0x20,          // 3
-	0x21,          // 4
-	0x22,          // 5
-	0x23,          // 6
-	0x24,          // 7
-	0x25,          // 8
-	0x26,          // 9
-	0x33|SHIFT,      // :
-	0x33,          // ;
-	0x36|SHIFT,      // <
-	0x2e,          // =
-	0x37|SHIFT,      // >
-	0x38|SHIFT,      // ?
-	0x1f|SHIFT,      // @
-	0x04|SHIFT,      // A
-	0x05|SHIFT,      // B
-	0x06|SHIFT,      // C
-	0x07|SHIFT,      // D
-	0x08|SHIFT,      // E
-	0x09|SHIFT,      // F
-	0x0a|SHIFT,      // G
-	0x0b|SHIFT,      // H
-	0x0c|SHIFT,      // I
-	0x0d|SHIFT,      // J
-	0x0e|SHIFT,      // K
-	0x0f|SHIFT,      // L
-	0x10|SHIFT,      // M
-	0x11|SHIFT,      // N
-	0x12|SHIFT,      // O
-	0x13|SHIFT,      // P
-	0x14|SHIFT,      // Q
-	0x15|SHIFT,      // R
-	0x16|SHIFT,      // S
-	0x17|SHIFT,      // T
-	0x18|SHIFT,      // U
-	0x19|SHIFT,      // V
-	0x1a|SHIFT,      // W
-	0x1b|SHIFT,      // X
-	0x1c|SHIFT,      // Y
-	0x1d|SHIFT,      // Z
-	0x2f,          // [
-	0x31,          // bslash
-	0x30,          // ]
-	0x23|SHIFT,    // ^
-	0x2d|SHIFT,    // _
-	0x35,          // `
-	0x04,          // a
-	0x05,          // b
-	0x06,          // c
-	0x07,          // d
-	0x08,          // e
-	0x09,          // f
-	0x0a,          // g
-	0x0b,          // h
-	0x0c,          // i
-	0x0d,          // j
-	0x0e,          // k
-	0x0f,          // l
-	0x10,          // m
-	0x11,          // n
-	0x12,          // o
-	0x13,          // p
-	0x14,          // q
-	0x15,          // r
-	0x16,          // s
-	0x17,          // t
-	0x18,          // u
-	0x19,          // v
-	0x1a,          // w
-	0x1b,          // x
-	0x1c,          // y
-	0x1d,          // z
-	0x2f|SHIFT,    // 
-	0x31|SHIFT,    // |
-	0x30|SHIFT,    // }
-	0x35|SHIFT,    // ~
-	0				// DEL
-};
-
-uint8_t USBPutChar(uint8_t c);
-
-// press() adds the specified key (printing, non-printing, or modifier)
-// to the persistent key report and sends the report.  Because of the way 
-// USB HID works, the host acts like the key remains pressed until we 
-// call release(), releaseAll(), or otherwise clear the report and resend.
-size_t Keyboard_::press(uint8_t k) 
-{
-	uint8_t i;
-	if (k >= 136) {			// it's a non-printing key (not a modifier)
-		k = k - 136;
-	} else if (k >= 128) {	// it's a modifier key
-		_keyReport.modifiers |= (1<<(k-128));
-		k = 0;
-	} else {				// it's a printing key
-		k = pgm_read_byte(_asciimap + k);
-		if (!k) {
-			setWriteError();
-			return 0;
-		}
-		if (k & 0x80) {						// it's a capital letter or other character reached with shift
-			_keyReport.modifiers |= 0x02;	// the left shift modifier
-			k &= 0x7F;
-		}
-	}
-	
-	// Add k to the key report only if it's not already present
-	// and if there is an empty slot.
-	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
-		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
-		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
-		
-		for (i=0; i<6; i++) {
-			if (_keyReport.keys[i] == 0x00) {
-				_keyReport.keys[i] = k;
-				break;
-			}
-		}
-		if (i == 6) {
-			setWriteError();
-			return 0;
-		}	
-	}
-	sendReport(&_keyReport);
-	return 1;
-}
-
-// release() takes the specified key out of the persistent key report and
-// sends the report.  This tells the OS the key is no longer pressed and that
-// it shouldn't be repeated any more.
-size_t Keyboard_::release(uint8_t k) 
-{
-	uint8_t i;
-	if (k >= 136) {			// it's a non-printing key (not a modifier)
-		k = k - 136;
-	} else if (k >= 128) {	// it's a modifier key
-		_keyReport.modifiers &= ~(1<<(k-128));
-		k = 0;
-	} else {				// it's a printing key
-		k = pgm_read_byte(_asciimap + k);
-		if (!k) {
-			return 0;
-		}
-		if (k & 0x80) {							// it's a capital letter or other character reached with shift
-			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
-			k &= 0x7F;
-		}
-	}
-	
-	// Test the key report to see if k is present.  Clear it if it exists.
-	// Check all positions in case the key is present more than once (which it shouldn't be)
-	for (i=0; i<6; i++) {
-		if (0 != k && _keyReport.keys[i] == k) {
-			_keyReport.keys[i] = 0x00;
-		}
-	}
-
-	sendReport(&_keyReport);
-	return 1;
-}
-
-void Keyboard_::releaseAll(void)
-{
-	_keyReport.keys[0] = 0;
-	_keyReport.keys[1] = 0;	
-	_keyReport.keys[2] = 0;
-	_keyReport.keys[3] = 0;	
-	_keyReport.keys[4] = 0;
-	_keyReport.keys[5] = 0;	
-	_keyReport.modifiers = 0;
-	sendReport(&_keyReport);
-}
-
-size_t Keyboard_::write(uint8_t c)
-{	
-	uint8_t p = press(c);		// Keydown
-	uint8_t r = release(c);		// Keyup
-	return (p);					// just return the result of press() since release() almost always returns 1
-}
-
-#endif
-
-#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index 794a7be..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-  Modified 28 September 2010 by Mark Sproul
-  Modified 14 August 2012 by Alarus
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "Arduino.h"
-#include "wiring_private.h"
-
-// this next line disables the entire HardwareSerial.cpp, 
-// this is so I can support Attiny series and any other chip without a uart
-#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
-
-#include "HardwareSerial.h"
-
-/*
- * on ATmega8, the uart and its bits are not numbered, so there is no "TXC0"
- * definition.
- */
-#if !defined(TXC0)
-#if defined(TXC)
-#define TXC0 TXC
-#elif defined(TXC1)
-// Some devices have uart1 but no uart0
-#define TXC0 TXC1
-#else
-#error TXC0 not definable in HardwareSerial.h
-#endif
-#endif
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which head is the index of the location
-// to which to write the next incoming character and tail is the index of the
-// location from which to read.
-#if (RAMEND < 1000)
-  #define SERIAL_BUFFER_SIZE 16
-#else
-  #define SERIAL_BUFFER_SIZE 64
-#endif
-
-struct ring_buffer
-{
-  unsigned char buffer[SERIAL_BUFFER_SIZE];
-  volatile unsigned int head;
-  volatile unsigned int tail;
-};
-
-#if defined(USBCON)
-  ring_buffer rx_buffer = { { 0 }, 0, 0};
-  ring_buffer tx_buffer = { { 0 }, 0, 0};
-#endif
-#if defined(UBRRH) || defined(UBRR0H)
-  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR1H)
-  ring_buffer rx_buffer1  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR2H)
-  ring_buffer rx_buffer2  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer2  =  { { 0 }, 0, 0 };
-#endif
-#if defined(UBRR3H)
-  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
-  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
-#endif
-
-inline void store_char(unsigned char c, ring_buffer *buffer)
-{
-  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != buffer->tail) {
-    buffer->buffer[buffer->head] = c;
-    buffer->head = i;
-  }
-}
-
-#if !defined(USART0_RX_vect) && defined(USART1_RX_vect)
-// do nothing - on the 32u4 the first USART is USART1
-#else
-#if !defined(USART_RX_vect) && !defined(SIG_USART0_RECV) && \
-    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
-	!defined(SIG_UART_RECV)
-  #error "Don't know what the Data Received vector is called for the first UART"
-#else
-  void serialEvent() __attribute__((weak));
-  void serialEvent() {}
-  #define serialEvent_implemented
-#if defined(USART_RX_vect)
-  SIGNAL(USART_RX_vect)
-#elif defined(SIG_USART0_RECV)
-  SIGNAL(SIG_USART0_RECV)
-#elif defined(SIG_UART0_RECV)
-  SIGNAL(SIG_UART0_RECV)
-#elif defined(USART0_RX_vect)
-  SIGNAL(USART0_RX_vect)
-#elif defined(SIG_UART_RECV)
-  SIGNAL(SIG_UART_RECV)
-#endif
-  {
-  #if defined(UDR0)
-    if (bit_is_clear(UCSR0A, UPE0)) {
-      unsigned char c = UDR0;
-      store_char(c, &rx_buffer);
-    } else {
-      unsigned char c = UDR0;
-    };
-  #elif defined(UDR)
-    if (bit_is_clear(UCSRA, PE)) {
-      unsigned char c = UDR;
-      store_char(c, &rx_buffer);
-    } else {
-      unsigned char c = UDR;
-    };
-  #else
-    #error UDR not defined
-  #endif
-  }
-#endif
-#endif
-
-#if defined(USART1_RX_vect)
-  void serialEvent1() __attribute__((weak));
-  void serialEvent1() {}
-  #define serialEvent1_implemented
-  SIGNAL(USART1_RX_vect)
-  {
-    if (bit_is_clear(UCSR1A, UPE1)) {
-      unsigned char c = UDR1;
-      store_char(c, &rx_buffer1);
-    } else {
-      unsigned char c = UDR1;
-    };
-  }
-#elif defined(SIG_USART1_RECV)
-  #error SIG_USART1_RECV
-#endif
-
-#if defined(USART2_RX_vect) && defined(UDR2)
-  void serialEvent2() __attribute__((weak));
-  void serialEvent2() {}
-  #define serialEvent2_implemented
-  SIGNAL(USART2_RX_vect)
-  {
-    if (bit_is_clear(UCSR2A, UPE2)) {
-      unsigned char c = UDR2;
-      store_char(c, &rx_buffer2);
-    } else {
-      unsigned char c = UDR2;
-    };
-  }
-#elif defined(SIG_USART2_RECV)
-  #error SIG_USART2_RECV
-#endif
-
-#if defined(USART3_RX_vect) && defined(UDR3)
-  void serialEvent3() __attribute__((weak));
-  void serialEvent3() {}
-  #define serialEvent3_implemented
-  SIGNAL(USART3_RX_vect)
-  {
-    if (bit_is_clear(UCSR3A, UPE3)) {
-      unsigned char c = UDR3;
-      store_char(c, &rx_buffer3);
-    } else {
-      unsigned char c = UDR3;
-    };
-  }
-#elif defined(SIG_USART3_RECV)
-  #error SIG_USART3_RECV
-#endif
-
-void serialEventRun(void)
-{
-#ifdef serialEvent_implemented
-  if (Serial.available()) serialEvent();
-#endif
-#ifdef serialEvent1_implemented
-  if (Serial1.available()) serialEvent1();
-#endif
-#ifdef serialEvent2_implemented
-  if (Serial2.available()) serialEvent2();
-#endif
-#ifdef serialEvent3_implemented
-  if (Serial3.available()) serialEvent3();
-#endif
-}
-
-
-#if !defined(USART0_UDRE_vect) && defined(USART1_UDRE_vect)
-// do nothing - on the 32u4 the first USART is USART1
-#else
-#if !defined(UART0_UDRE_vect) && !defined(UART_UDRE_vect) && !defined(USART0_UDRE_vect) && !defined(USART_UDRE_vect)
-  #error "Don't know what the Data Register Empty vector is called for the first UART"
-#else
-#if defined(UART0_UDRE_vect)
-ISR(UART0_UDRE_vect)
-#elif defined(UART_UDRE_vect)
-ISR(UART_UDRE_vect)
-#elif defined(USART0_UDRE_vect)
-ISR(USART0_UDRE_vect)
-#elif defined(USART_UDRE_vect)
-ISR(USART_UDRE_vect)
-#endif
-{
-  if (tx_buffer.head == tx_buffer.tail) {
-	// Buffer empty, so disable interrupts
-#if defined(UCSR0B)
-    cbi(UCSR0B, UDRIE0);
-#else
-    cbi(UCSRB, UDRIE);
-#endif
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
-    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-  #if defined(UDR0)
-    UDR0 = c;
-  #elif defined(UDR)
-    UDR = c;
-  #else
-    #error UDR not defined
-  #endif
-  }
-}
-#endif
-#endif
-
-#ifdef USART1_UDRE_vect
-ISR(USART1_UDRE_vect)
-{
-  if (tx_buffer1.head == tx_buffer1.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR1B, UDRIE1);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
-    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR1 = c;
-  }
-}
-#endif
-
-#ifdef USART2_UDRE_vect
-ISR(USART2_UDRE_vect)
-{
-  if (tx_buffer2.head == tx_buffer2.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR2B, UDRIE2);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
-    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR2 = c;
-  }
-}
-#endif
-
-#ifdef USART3_UDRE_vect
-ISR(USART3_UDRE_vect)
-{
-  if (tx_buffer3.head == tx_buffer3.tail) {
-	// Buffer empty, so disable interrupts
-    cbi(UCSR3B, UDRIE3);
-  }
-  else {
-    // There is more data in the output buffer. Send the next byte
-    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
-    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
-	
-    UDR3 = c;
-  }
-}
-#endif
-
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *ucsrc, volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _tx_buffer = tx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _ucsrc = ucsrc;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udrie = udrie;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(unsigned long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-
-try_again:
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-  
-  if ((baud_setting > 4095) && use_u2x)
-  {
-    use_u2x = false;
-    goto try_again;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  transmitting = false;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-  cbi(*_ucsrb, _udrie);
-}
-
-void HardwareSerial::begin(unsigned long baud, byte config)
-{
-  uint16_t baud_setting;
-  uint8_t current_config;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-
-try_again:
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-  
-  if ((baud_setting > 4095) && use_u2x)
-  {
-    use_u2x = false;
-    goto try_again;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  //set the data bits, parity, and stop bits
-#if defined(__AVR_ATmega8__)
-  config |= 0x80; // select UCSRC register (shared with UBRRH)
-#endif
-  *_ucsrc = config;
-  
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-  cbi(*_ucsrb, _udrie);
-}
-
-void HardwareSerial::end()
-{
-  // wait for transmission of outgoing data
-  while (_tx_buffer->head != _tx_buffer->tail)
-    ;
-
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-  cbi(*_ucsrb, _udrie);
-  
-  // clear any received data
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-int HardwareSerial::available(void)
-{
-  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
-}
-
-int HardwareSerial::peek(void)
-{
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    return _rx_buffer->buffer[_rx_buffer->tail];
-  }
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // UDR is kept full while the buffer is not empty, so TXC triggers when EMPTY && SENT
-  while (transmitting && ! (*_ucsra & _BV(TXC0)));
-  transmitting = false;
-}
-
-size_t HardwareSerial::write(uint8_t c)
-{
-  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
-	
-  // If the output buffer is full, there's nothing for it other than to 
-  // wait for the interrupt handler to empty it a bit
-  // ???: return 0 here instead?
-  while (i == _tx_buffer->tail)
-    ;
-	
-  _tx_buffer->buffer[_tx_buffer->head] = c;
-  _tx_buffer->head = i;
-	
-  sbi(*_ucsrb, _udrie);
-  // clear the TXC bit -- "can be cleared by writing a one to its bit location"
-  transmitting = true;
-  sbi(*_ucsra, TXC0);
-  
-  return 1;
-}
-
-HardwareSerial::operator bool() {
-	return true;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-
-#if defined(UBRRH) && defined(UBRRL)
-  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UCSRC, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
-#elif defined(UBRR0H) && defined(UBRR0L)
-  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UCSR0C, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
-#elif defined(USBCON)
-  // do nothing - Serial object and buffers are initialized in CDC code
-#else
-  #error no serial port defined  (port 0)
-#endif
-
-#if defined(UBRR1H)
-  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
-#endif
-#if defined(UBRR2H)
-  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
-#endif
-#if defined(UBRR3H)
-  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
-#endif
-
-#endif // whole file
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.h
deleted file mode 100644
index a73117f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  Modified 28 September 2010 by Mark Sproul
-  Modified 14 August 2012 by Alarus
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Stream.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Stream
-{
-  private:
-    ring_buffer *_rx_buffer;
-    ring_buffer *_tx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_ucsrc;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udrie;
-    uint8_t _u2x;
-    bool transmitting;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *ucsrc, volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x);
-    void begin(unsigned long);
-    void begin(unsigned long, uint8_t);
-    void end();
-    virtual int available(void);
-    virtual int peek(void);
-    virtual int read(void);
-    virtual void flush(void);
-    virtual size_t write(uint8_t);
-    inline size_t write(unsigned long n) { return write((uint8_t)n); }
-    inline size_t write(long n) { return write((uint8_t)n); }
-    inline size_t write(unsigned int n) { return write((uint8_t)n); }
-    inline size_t write(int n) { return write((uint8_t)n); }
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-    operator bool();
-};
-
-// Define config for Serial.begin(baud, config);
-#define SERIAL_5N1 0x00
-#define SERIAL_6N1 0x02
-#define SERIAL_7N1 0x04
-#define SERIAL_8N1 0x06
-#define SERIAL_5N2 0x08
-#define SERIAL_6N2 0x0A
-#define SERIAL_7N2 0x0C
-#define SERIAL_8N2 0x0E
-#define SERIAL_5E1 0x20
-#define SERIAL_6E1 0x22
-#define SERIAL_7E1 0x24
-#define SERIAL_8E1 0x26
-#define SERIAL_5E2 0x28
-#define SERIAL_6E2 0x2A
-#define SERIAL_7E2 0x2C
-#define SERIAL_8E2 0x2E
-#define SERIAL_5O1 0x30
-#define SERIAL_6O1 0x32
-#define SERIAL_7O1 0x34
-#define SERIAL_8O1 0x36
-#define SERIAL_5O2 0x38
-#define SERIAL_6O2 0x3A
-#define SERIAL_7O2 0x3C
-#define SERIAL_8O2 0x3E
-
-#if defined(UBRRH) || defined(UBRR0H)
-  extern HardwareSerial Serial;
-#elif defined(USBCON)
-  #include "USBAPI.h"
-//  extern HardwareSerial Serial_;  
-#endif
-#if defined(UBRR1H)
-  extern HardwareSerial Serial1;
-#endif
-#if defined(UBRR2H)
-  extern HardwareSerial Serial2;
-#endif
-#if defined(UBRR3H)
-  extern HardwareSerial Serial3;
-#endif
-
-extern void serialEventRun(void) __attribute__((weak));
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.cpp
deleted file mode 100644
index fe3deb7..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-
-#include <Arduino.h>
-#include <IPAddress.h>
-
-IPAddress::IPAddress()
-{
-    memset(_address, 0, sizeof(_address));
-}
-
-IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
-{
-    _address[0] = first_octet;
-    _address[1] = second_octet;
-    _address[2] = third_octet;
-    _address[3] = fourth_octet;
-}
-
-IPAddress::IPAddress(uint32_t address)
-{
-    memcpy(_address, &address, sizeof(_address));
-}
-
-IPAddress::IPAddress(const uint8_t *address)
-{
-    memcpy(_address, address, sizeof(_address));
-}
-
-IPAddress& IPAddress::operator=(const uint8_t *address)
-{
-    memcpy(_address, address, sizeof(_address));
-    return *this;
-}
-
-IPAddress& IPAddress::operator=(uint32_t address)
-{
-    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
-    return *this;
-}
-
-bool IPAddress::operator==(const uint8_t* addr)
-{
-    return memcmp(addr, _address, sizeof(_address)) == 0;
-}
-
-size_t IPAddress::printTo(Print& p) const
-{
-    size_t n = 0;
-    for (int i =0; i < 3; i++)
-    {
-        n += p.print(_address[i], DEC);
-        n += p.print('.');
-    }
-    n += p.print(_address[3], DEC);
-    return n;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.h
deleted file mode 100644
index 2585aec..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/IPAddress.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- *
- * MIT License:
- * Copyright (c) 2011 Adrian McEwen
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * adrianm@mcqn.com 1/1/2011
- */
-
-#ifndef IPAddress_h
-#define IPAddress_h
-
-#include <Printable.h>
-
-// A class to make it easier to handle and pass around IP addresses
-
-class IPAddress : public Printable {
-private:
-    uint8_t _address[4];  // IPv4 address
-    // Access the raw byte array containing the address.  Because this returns a pointer
-    // to the internal structure rather than a copy of the address this function should only
-    // be used when you know that the usage of the returned uint8_t* will be transient and not
-    // stored.
-    uint8_t* raw_address() { return _address; };
-
-public:
-    // Constructors
-    IPAddress();
-    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
-    IPAddress(uint32_t address);
-    IPAddress(const uint8_t *address);
-
-    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
-    // to a four-byte uint8_t array is expected
-    operator uint32_t() { return *((uint32_t*)_address); };
-    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
-    bool operator==(const uint8_t* addr);
-
-    // Overloaded index operator to allow getting and setting individual octets of the address
-    uint8_t operator[](int index) const { return _address[index]; };
-    uint8_t& operator[](int index) { return _address[index]; };
-
-    // Overloaded copy operators to allow initialisation of IPAddress objects from other types
-    IPAddress& operator=(const uint8_t *address);
-    IPAddress& operator=(uint32_t address);
-
-    virtual size_t printTo(Print& p) const;
-
-    friend class EthernetClass;
-    friend class UDP;
-    friend class Client;
-    friend class Server;
-    friend class DhcpClass;
-    friend class DNSClient;
-};
-
-const IPAddress INADDR_NONE(0,0,0,0);
-
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Platform.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Platform.h
deleted file mode 100644
index 8b8f742..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Platform.h
+++ /dev/null
@@ -1,23 +0,0 @@
-
-#ifndef __PLATFORM_H__
-#define __PLATFORM_H__
-
-#include <inttypes.h>
-#include <avr/pgmspace.h>
-#include <avr/eeprom.h>
-#include <avr/interrupt.h>
-#include <util/delay.h>
-
-typedef unsigned char u8;
-typedef unsigned short u16;
-typedef unsigned long u32;
-
-#include "Arduino.h"
-
-#if defined(USBCON)
-	#include "USBDesc.h"
-	#include "USBCore.h"
-	#include "USBAPI.h"
-#endif /* if defined(USBCON) */
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.cpp
deleted file mode 100644
index 53961ec..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include "Arduino.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-/* default implementation: may be overridden */
-size_t Print::write(const uint8_t *buffer, size_t size)
-{
-  size_t n = 0;
-  while (size--) {
-    n += write(*buffer++);
-  }
-  return n;
-}
-
-size_t Print::print(const __FlashStringHelper *ifsh)
-{
-  const char PROGMEM *p = (const char PROGMEM *)ifsh;
-  size_t n = 0;
-  while (1) {
-    unsigned char c = pgm_read_byte(p++);
-    if (c == 0) break;
-    n += write(c);
-  }
-  return n;
-}
-
-size_t Print::print(const String &s)
-{
-  size_t n = 0;
-  for (uint16_t i = 0; i < s.length(); i++) {
-    n += write(s[i]);
-  }
-  return n;
-}
-
-size_t Print::print(const char str[])
-{
-  return write(str);
-}
-
-size_t Print::print(char c)
-{
-  return write(c);
-}
-
-size_t Print::print(unsigned char b, int base)
-{
-  return print((unsigned long) b, base);
-}
-
-size_t Print::print(int n, int base)
-{
-  return print((long) n, base);
-}
-
-size_t Print::print(unsigned int n, int base)
-{
-  return print((unsigned long) n, base);
-}
-
-size_t Print::print(long n, int base)
-{
-  if (base == 0) {
-    return write(n);
-  } else if (base == 10) {
-    if (n < 0) {
-      int t = print('-');
-      n = -n;
-      return printNumber(n, 10) + t;
-    }
-    return printNumber(n, 10);
-  } else {
-    return printNumber(n, base);
-  }
-}
-
-size_t Print::print(unsigned long n, int base)
-{
-  if (base == 0) return write(n);
-  else return printNumber(n, base);
-}
-
-size_t Print::print(double n, int digits)
-{
-  return printFloat(n, digits);
-}
-
-size_t Print::println(const __FlashStringHelper *ifsh)
-{
-  size_t n = print(ifsh);
-  n += println();
-  return n;
-}
-
-size_t Print::print(const Printable& x)
-{
-  return x.printTo(*this);
-}
-
-size_t Print::println(void)
-{
-  size_t n = print('\r');
-  n += print('\n');
-  return n;
-}
-
-size_t Print::println(const String &s)
-{
-  size_t n = print(s);
-  n += println();
-  return n;
-}
-
-size_t Print::println(const char c[])
-{
-  size_t n = print(c);
-  n += println();
-  return n;
-}
-
-size_t Print::println(char c)
-{
-  size_t n = print(c);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned char b, int base)
-{
-  size_t n = print(b, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(int num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned int num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(long num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(unsigned long num, int base)
-{
-  size_t n = print(num, base);
-  n += println();
-  return n;
-}
-
-size_t Print::println(double num, int digits)
-{
-  size_t n = print(num, digits);
-  n += println();
-  return n;
-}
-
-size_t Print::println(const Printable& x)
-{
-  size_t n = print(x);
-  n += println();
-  return n;
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-size_t Print::printNumber(unsigned long n, uint8_t base) {
-  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
-  char *str = &buf[sizeof(buf) - 1];
-
-  *str = '\0';
-
-  // prevent crash if called with base == 1
-  if (base < 2) base = 10;
-
-  do {
-    unsigned long m = n;
-    n /= base;
-    char c = m - base * n;
-    *--str = c < 10 ? c + '0' : c + 'A' - 10;
-  } while(n);
-
-  return write(str);
-}
-
-size_t Print::printFloat(double number, uint8_t digits) 
-{ 
-  size_t n = 0;
-  
-  if (isnan(number)) return print("nan");
-  if (isinf(number)) return print("inf");
-  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
-  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
-  
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     n += print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  n += print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0) {
-    n += print("."); 
-  }
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    n += print(toPrint);
-    remainder -= toPrint; 
-  } 
-  
-  return n;
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.h
deleted file mode 100644
index dc76150..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Print.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-#include <stdio.h> // for size_t
-
-#include "WString.h"
-#include "Printable.h"
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-
-class Print
-{
-  private:
-    int write_error;
-    size_t printNumber(unsigned long, uint8_t);
-    size_t printFloat(double, uint8_t);
-  protected:
-    void setWriteError(int err = 1) { write_error = err; }
-  public:
-    Print() : write_error(0) {}
-  
-    int getWriteError() { return write_error; }
-    void clearWriteError() { setWriteError(0); }
-  
-    virtual size_t write(uint8_t) = 0;
-    size_t write(const char *str) {
-      if (str == NULL) return 0;
-      return write((const uint8_t *)str, strlen(str));
-    }
-    virtual size_t write(const uint8_t *buffer, size_t size);
-    
-    size_t print(const __FlashStringHelper *);
-    size_t print(const String &);
-    size_t print(const char[]);
-    size_t print(char);
-    size_t print(unsigned char, int = DEC);
-    size_t print(int, int = DEC);
-    size_t print(unsigned int, int = DEC);
-    size_t print(long, int = DEC);
-    size_t print(unsigned long, int = DEC);
-    size_t print(double, int = 2);
-    size_t print(const Printable&);
-
-    size_t println(const __FlashStringHelper *);
-    size_t println(const String &s);
-    size_t println(const char[]);
-    size_t println(char);
-    size_t println(unsigned char, int = DEC);
-    size_t println(int, int = DEC);
-    size_t println(unsigned int, int = DEC);
-    size_t println(long, int = DEC);
-    size_t println(unsigned long, int = DEC);
-    size_t println(double, int = 2);
-    size_t println(const Printable&);
-    size_t println(void);
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Printable.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Printable.h
deleted file mode 100644
index d03c9af..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Printable.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  Printable.h - Interface class that allows printing of complex types
-  Copyright (c) 2011 Adrian McEwen.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Printable_h
-#define Printable_h
-
-#include <new.h>
-
-class Print;
-
-/** The Printable class provides a way for new classes to allow themselves to be printed.
-    By deriving from Printable and implementing the printTo method, it will then be possible
-    for users to print out instances of this class by passing them into the usual
-    Print::print and Print::println methods.
-*/
-
-class Printable
-{
-  public:
-    virtual size_t printTo(Print& p) const = 0;
-};
-
-#endif
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Server.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Server.h
deleted file mode 100644
index 9674c76..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Server.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef server_h
-#define server_h
-
-class Server : public Print {
-public:
-  virtual void begin() =0;
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.cpp
deleted file mode 100644
index aafb7fc..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.cpp
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- Stream.cpp - adds parsing methods to Stream class
- Copyright (c) 2008 David A. Mellis.  All right reserved.
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
-
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
- Created July 2011
- parsing functions based on TextFinder library by Michael Margolis
- */
-
-#include "Arduino.h"
-#include "Stream.h"
-
-#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
-#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
-
-// private method to read stream with timeout
-int Stream::timedRead()
-{
-  int c;
-  _startMillis = millis();
-  do {
-    c = read();
-    if (c >= 0) return c;
-  } while(millis() - _startMillis < _timeout);
-  return -1;     // -1 indicates timeout
-}
-
-// private method to peek stream with timeout
-int Stream::timedPeek()
-{
-  int c;
-  _startMillis = millis();
-  do {
-    c = peek();
-    if (c >= 0) return c;
-  } while(millis() - _startMillis < _timeout);
-  return -1;     // -1 indicates timeout
-}
-
-// returns peek of the next digit in the stream or -1 if timeout
-// discards non-numeric characters
-int Stream::peekNextDigit()
-{
-  int c;
-  while (1) {
-    c = timedPeek();
-    if (c < 0) return c;  // timeout
-    if (c == '-') return c;
-    if (c >= '0' && c <= '9') return c;
-    read();  // discard non-numeric
-  }
-}
-
-// Public Methods
-//////////////////////////////////////////////////////////////
-
-void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
-{
-  _timeout = timeout;
-}
-
- // find returns true if the target string is found
-bool  Stream::find(char *target)
-{
-  return findUntil(target, NULL);
-}
-
-// reads data from the stream until the target string of given length is found
-// returns true if target string is found, false if timed out
-bool Stream::find(char *target, size_t length)
-{
-  return findUntil(target, length, NULL, 0);
-}
-
-// as find but search ends if the terminator string is found
-bool  Stream::findUntil(char *target, char *terminator)
-{
-  return findUntil(target, strlen(target), terminator, strlen(terminator));
-}
-
-// reads data from the stream until the target string of the given length is found
-// search terminated if the terminator string is found
-// returns true if target string is found, false if terminated or timed out
-bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
-{
-  size_t index = 0;  // maximum target string length is 64k bytes!
-  size_t termIndex = 0;
-  int c;
-  
-  if( *target == 0)
-    return true;   // return true if target is a null string
-  while( (c = timedRead()) > 0){
-    
-    if(c != target[index])
-      index = 0; // reset index if any char does not match
-    
-    if( c == target[index]){
-      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
-      if(++index >= targetLen){ // return true if all chars in the target match
-        return true;
-      }
-    }
-    
-    if(termLen > 0 && c == terminator[termIndex]){
-      if(++termIndex >= termLen)
-        return false;       // return false if terminate string found before target string
-    }
-    else
-      termIndex = 0;
-  }
-  return false;
-}
-
-
-// returns the first valid (long) integer value from the current position.
-// initial characters that are not digits (or the minus sign) are skipped
-// function is terminated by the first character that is not a digit.
-long Stream::parseInt()
-{
-  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
-}
-
-// as above but a given skipChar is ignored
-// this allows format characters (typically commas) in values to be ignored
-long Stream::parseInt(char skipChar)
-{
-  boolean isNegative = false;
-  long value = 0;
-  int c;
-
-  c = peekNextDigit();
-  // ignore non numeric leading characters
-  if(c < 0)
-    return 0; // zero returned if timeout
-
-  do{
-    if(c == skipChar)
-      ; // ignore this charactor
-    else if(c == '-')
-      isNegative = true;
-    else if(c >= '0' && c <= '9')        // is c a digit?
-      value = value * 10 + c - '0';
-    read();  // consume the character we got with peek
-    c = timedPeek();
-  }
-  while( (c >= '0' && c <= '9') || c == skipChar );
-
-  if(isNegative)
-    value = -value;
-  return value;
-}
-
-
-// as parseInt but returns a floating point value
-float Stream::parseFloat()
-{
-  return parseFloat(NO_SKIP_CHAR);
-}
-
-// as above but the given skipChar is ignored
-// this allows format characters (typically commas) in values to be ignored
-float Stream::parseFloat(char skipChar){
-  boolean isNegative = false;
-  boolean isFraction = false;
-  long value = 0;
-  char c;
-  float fraction = 1.0;
-
-  c = peekNextDigit();
-    // ignore non numeric leading characters
-  if(c < 0)
-    return 0; // zero returned if timeout
-
-  do{
-    if(c == skipChar)
-      ; // ignore
-    else if(c == '-')
-      isNegative = true;
-    else if (c == '.')
-      isFraction = true;
-    else if(c >= '0' && c <= '9')  {      // is c a digit?
-      value = value * 10 + c - '0';
-      if(isFraction)
-         fraction *= 0.1;
-    }
-    read();  // consume the character we got with peek
-    c = timedPeek();
-  }
-  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
-
-  if(isNegative)
-    value = -value;
-  if(isFraction)
-    return value * fraction;
-  else
-    return value;
-}
-
-// read characters from stream into buffer
-// terminates if length characters have been read, or timeout (see setTimeout)
-// returns the number of characters placed in the buffer
-// the buffer is NOT null terminated.
-//
-size_t Stream::readBytes(char *buffer, size_t length)
-{
-  size_t count = 0;
-  while (count < length) {
-    int c = timedRead();
-    if (c < 0) break;
-    *buffer++ = (char)c;
-    count++;
-  }
-  return count;
-}
-
-
-// as readBytes with terminator character
-// terminates if length characters have been read, timeout, or if the terminator character  detected
-// returns the number of characters placed in the buffer (0 means no valid data found)
-
-size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
-{
-  if (length < 1) return 0;
-  size_t index = 0;
-  while (index < length) {
-    int c = timedRead();
-    if (c < 0 || c == terminator) break;
-    *buffer++ = (char)c;
-    index++;
-  }
-  return index; // return number of characters, not including null terminator
-}
-
-String Stream::readString()
-{
-  String ret;
-  int c = timedRead();
-  while (c >= 0)
-  {
-    ret += (char)c;
-    c = timedRead();
-  }
-  return ret;
-}
-
-String Stream::readStringUntil(char terminator)
-{
-  String ret;
-  int c = timedRead();
-  while (c >= 0 && c != terminator)
-  {
-    ret += (char)c;
-    c = timedRead();
-  }
-  return ret;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.h
deleted file mode 100644
index 58bbf75..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Stream.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-  Stream.h - base class for character-based streams.
-  Copyright (c) 2010 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  parsing functions based on TextFinder library by Michael Margolis
-*/
-
-#ifndef Stream_h
-#define Stream_h
-
-#include <inttypes.h>
-#include "Print.h"
-
-// compatability macros for testing
-/*
-#define   getInt()            parseInt()
-#define   getInt(skipChar)    parseInt(skipchar)
-#define   getFloat()          parseFloat()
-#define   getFloat(skipChar)  parseFloat(skipChar)
-#define   getString( pre_string, post_string, buffer, length)
-readBytesBetween( pre_string, terminator, buffer, length)
-*/
-
-class Stream : public Print
-{
-  private:
-    unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
-    unsigned long _startMillis;  // used for timeout measurement
-    int timedRead();    // private method to read stream with timeout
-    int timedPeek();    // private method to peek stream with timeout
-    int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
-
-  public:
-    virtual int available() = 0;
-    virtual int read() = 0;
-    virtual int peek() = 0;
-    virtual void flush() = 0;
-
-    Stream() {_timeout=1000;}
-
-// parsing methods
-
-  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
-
-  bool find(char *target);   // reads data from the stream until the target string is found
-  // returns true if target string is found, false if timed out (see setTimeout)
-
-  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
-  // returns true if target string is found, false if timed out
-
-  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
-
-  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
-
-
-  long parseInt(); // returns the first valid (long) integer value from the current position.
-  // initial characters that are not digits (or the minus sign) are skipped
-  // integer is terminated by the first character that is not a digit.
-
-  float parseFloat();               // float version of parseInt
-
-  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
-  // terminates if length characters have been read or timeout (see setTimeout)
-  // returns the number of characters placed in the buffer (0 means no valid data found)
-
-  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
-  // terminates if length characters have been read, timeout, or if the terminator character  detected
-  // returns the number of characters placed in the buffer (0 means no valid data found)
-
-  // Arduino String functions to be added here
-  String readString();
-  String readStringUntil(char terminator);
-
-  protected:
-  long parseInt(char skipChar); // as above but the given skipChar is ignored
-  // as above but the given skipChar is ignored
-  // this allows format characters (typically commas) in values to be ignored
-
-  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Tone.cpp
deleted file mode 100644
index 9bb6fe7..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,616 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
-0008    S Kanemoto  12/06/22 Fixed for Leonardo by @maris_HY
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include "Arduino.h"
-#include "pins_arduino.h"
-
-#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(TIMSK3)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-#endif
-
-#if defined(TIMSK4)
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-#endif
-
-#if defined(TIMSK5)
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#elif defined(__AVR_ATmega32U4__)
- 
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER3
- 
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 3 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
- 
-#else
-
-#define AVAILABLE_TONE_PINS 1
-#define USE_TIMER2
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-      #if defined(TCCR0A) && defined(TCCR0B)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR2A) && defined(TCCR2B)
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        #if defined(WGM42)
-          bitWrite(TCCR4B, WGM42, 1);
-        #elif defined(CS43)
-          #warning this may not be correct
-          // atmega32u4
-          bitWrite(TCCR4B, CS43, 1);
-        #endif
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if defined(TCCR0B)
-      if (_timer == 0)
-      {
-        TCCR0B = prescalarbits;
-      }
-      else
-#endif
-#if defined(TCCR2B)
-      {
-        TCCR2B = prescalarbits;
-      }
-#else
-      {
-        // dummy place holder to make the above ifdefs work
-      }
-#endif
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-      {
-#if defined(TCCR1B)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#endif
-      }
-#if defined(TCCR3B)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR4B)
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR5B)
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
-        // this combination is for at least the ATmega32
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK, OCIE1A, 1);
-#endif
-        break;
-
-#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-#endif
-
-#if defined(TIMSK3)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-#endif
-
-#if defined(TIMSK4)
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-#endif
-
-#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-// XXX: this function only works properly for timer 2 (the only one we use
-// currently).  for the others, it should end the tone, but won't restore
-// proper PWM functionality for the timer.
-void disableTimer(uint8_t _timer)
-{
-  switch (_timer)
-  {
-    case 0:
-      #if defined(TIMSK0)
-        TIMSK0 = 0;
-      #elif defined(TIMSK)
-        TIMSK = 0; // atmega32
-      #endif
-      break;
-
-#if defined(TIMSK1) && defined(OCIE1A)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-#endif
-
-    case 2:
-      #if defined(TIMSK2) && defined(OCIE2A)
-        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
-      #endif
-      #if defined(TCCR2A) && defined(WGM20)
-        TCCR2A = (1 << WGM20);
-      #endif
-      #if defined(TCCR2B) && defined(CS22)
-        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
-      #endif
-      #if defined(OCR2A)
-        OCR2A = 0;
-      #endif
-      break;
-
-#if defined(TIMSK3)
-    case 3:
-      TIMSK3 = 0;
-      break;
-#endif
-
-#if defined(TIMSK4)
-    case 4:
-      TIMSK4 = 0;
-      break;
-#endif
-
-#if defined(TIMSK5)
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  disableTimer(_timer);
-
-  digitalWrite(_pin, 0);
-}
-
-#ifdef USE_TIMER0
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    disableTimer(0);
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER1
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    disableTimer(1);
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER2
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    // need to call noTone() so that the tone_pins[] entry is reset, so the
-    // timer gets initialized next time we call tone().
-    // XXX: this assumes timer 2 is always the first one used.
-    noTone(tone_pins[0]);
-//    disableTimer(2);
-//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER3
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    disableTimer(3);
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER4
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    disableTimer(4);
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-#ifdef USE_TIMER5
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    disableTimer(5);
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBAPI.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBAPI.h
deleted file mode 100644
index eb2e593..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBAPI.h
+++ /dev/null
@@ -1,196 +0,0 @@
-
-
-#ifndef __USBAPI__
-#define __USBAPI__
-
-#if defined(USBCON)
-
-//================================================================================
-//================================================================================
-//	USB
-
-class USBDevice_
-{
-public:
-	USBDevice_();
-	bool configured();
-
-	void attach();
-	void detach();	// Serial port goes down too...
-	void poll();
-};
-extern USBDevice_ USBDevice;
-
-//================================================================================
-//================================================================================
-//	Serial over CDC (Serial1 is the physical port)
-
-class Serial_ : public Stream
-{
-private:
-	ring_buffer *_cdc_rx_buffer;
-public:
-	void begin(uint16_t baud_count);
-	void end(void);
-
-	virtual int available(void);
-	virtual void accept(void);
-	virtual int peek(void);
-	virtual int read(void);
-	virtual void flush(void);
-	virtual size_t write(uint8_t);
-	using Print::write; // pull in write(str) and write(buf, size) from Print
-	operator bool();
-};
-extern Serial_ Serial;
-
-//================================================================================
-//================================================================================
-//	Mouse
-
-#define MOUSE_LEFT 1
-#define MOUSE_RIGHT 2
-#define MOUSE_MIDDLE 4
-#define MOUSE_ALL (MOUSE_LEFT | MOUSE_RIGHT | MOUSE_MIDDLE)
-
-class Mouse_
-{
-private:
-	uint8_t _buttons;
-	void buttons(uint8_t b);
-public:
-	Mouse_(void);
-	void begin(void);
-	void end(void);
-	void click(uint8_t b = MOUSE_LEFT);
-	void move(signed char x, signed char y, signed char wheel = 0);	
-	void press(uint8_t b = MOUSE_LEFT);		// press LEFT by default
-	void release(uint8_t b = MOUSE_LEFT);	// release LEFT by default
-	bool isPressed(uint8_t b = MOUSE_LEFT);	// check LEFT by default
-};
-extern Mouse_ Mouse;
-
-//================================================================================
-//================================================================================
-//	Keyboard
-
-#define KEY_LEFT_CTRL		0x80
-#define KEY_LEFT_SHIFT		0x81
-#define KEY_LEFT_ALT		0x82
-#define KEY_LEFT_GUI		0x83
-#define KEY_RIGHT_CTRL		0x84
-#define KEY_RIGHT_SHIFT		0x85
-#define KEY_RIGHT_ALT		0x86
-#define KEY_RIGHT_GUI		0x87
-
-#define KEY_UP_ARROW		0xDA
-#define KEY_DOWN_ARROW		0xD9
-#define KEY_LEFT_ARROW		0xD8
-#define KEY_RIGHT_ARROW		0xD7
-#define KEY_BACKSPACE		0xB2
-#define KEY_TAB				0xB3
-#define KEY_RETURN			0xB0
-#define KEY_ESC				0xB1
-#define KEY_INSERT			0xD1
-#define KEY_DELETE			0xD4
-#define KEY_PAGE_UP			0xD3
-#define KEY_PAGE_DOWN		0xD6
-#define KEY_HOME			0xD2
-#define KEY_END				0xD5
-#define KEY_CAPS_LOCK		0xC1
-#define KEY_F1				0xC2
-#define KEY_F2				0xC3
-#define KEY_F3				0xC4
-#define KEY_F4				0xC5
-#define KEY_F5				0xC6
-#define KEY_F6				0xC7
-#define KEY_F7				0xC8
-#define KEY_F8				0xC9
-#define KEY_F9				0xCA
-#define KEY_F10				0xCB
-#define KEY_F11				0xCC
-#define KEY_F12				0xCD
-
-//	Low level key report: up to 6 keys and shift, ctrl etc at once
-typedef struct
-{
-	uint8_t modifiers;
-	uint8_t reserved;
-	uint8_t keys[6];
-} KeyReport;
-
-class Keyboard_ : public Print
-{
-private:
-	KeyReport _keyReport;
-	void sendReport(KeyReport* keys);
-public:
-	Keyboard_(void);
-	void begin(void);
-	void end(void);
-	virtual size_t write(uint8_t k);
-	virtual size_t press(uint8_t k);
-	virtual size_t release(uint8_t k);
-	virtual void releaseAll(void);
-};
-extern Keyboard_ Keyboard;
-
-//================================================================================
-//================================================================================
-//	Low level API
-
-typedef struct
-{
-	uint8_t bmRequestType;
-	uint8_t bRequest;
-	uint8_t wValueL;
-	uint8_t wValueH;
-	uint16_t wIndex;
-	uint16_t wLength;
-} Setup;
-
-//================================================================================
-//================================================================================
-//	HID 'Driver'
-
-int		HID_GetInterface(uint8_t* interfaceNum);
-int		HID_GetDescriptor(int i);
-bool	HID_Setup(Setup& setup);
-void	HID_SendReport(uint8_t id, const void* data, int len);
-
-//================================================================================
-//================================================================================
-//	MSC 'Driver'
-
-int		MSC_GetInterface(uint8_t* interfaceNum);
-int		MSC_GetDescriptor(int i);
-bool	MSC_Setup(Setup& setup);
-bool	MSC_Data(uint8_t rx,uint8_t tx);
-
-//================================================================================
-//================================================================================
-//	CSC 'Driver'
-
-int		CDC_GetInterface(uint8_t* interfaceNum);
-int		CDC_GetDescriptor(int i);
-bool	CDC_Setup(Setup& setup);
-
-//================================================================================
-//================================================================================
-
-#define TRANSFER_PGM		0x80
-#define TRANSFER_RELEASE	0x40
-#define TRANSFER_ZERO		0x20
-
-int USB_SendControl(uint8_t flags, const void* d, int len);
-int USB_RecvControl(void* d, int len);
-
-uint8_t	USB_Available(uint8_t ep);
-int USB_Send(uint8_t ep, const void* data, int len);	// blocking
-int USB_Recv(uint8_t ep, void* data, int len);		// non-blocking
-int USB_Recv(uint8_t ep);							// non-blocking
-void USB_Flush(uint8_t ep);
-
-#endif
-
-#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.cpp
deleted file mode 100644
index d3e0170..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.cpp
+++ /dev/null
@@ -1,684 +0,0 @@
-
-
-/* Copyright (c) 2010, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#include "Platform.h"
-#include "USBAPI.h"
-#include "USBDesc.h"
-
-#if defined(USBCON)
-
-#define EP_TYPE_CONTROL				0x00
-#define EP_TYPE_BULK_IN				0x81
-#define EP_TYPE_BULK_OUT			0x80
-#define EP_TYPE_INTERRUPT_IN		0xC1
-#define EP_TYPE_INTERRUPT_OUT		0xC0
-#define EP_TYPE_ISOCHRONOUS_IN		0x41
-#define EP_TYPE_ISOCHRONOUS_OUT		0x40
-
-/** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse type */
-#define TX_RX_LED_PULSE_MS 100
-volatile u8 TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
-volatile u8 RxLEDPulse; /**< Milliseconds remaining for data Rx LED pulse */
-
-//==================================================================
-//==================================================================
-
-extern const u16 STRING_LANGUAGE[] PROGMEM;
-extern const u16 STRING_IPRODUCT[] PROGMEM;
-extern const u16 STRING_IMANUFACTURER[] PROGMEM;
-extern const DeviceDescriptor USB_DeviceDescriptor PROGMEM;
-extern const DeviceDescriptor USB_DeviceDescriptorA PROGMEM;
-
-const u16 STRING_LANGUAGE[2] = {
-	(3<<8) | (2+2),
-	0x0409	// English
-};
-
-const u16 STRING_IPRODUCT[17] = {
-	(3<<8) | (2+2*16),
-#if USB_PID == 0x8036	
-	'A','r','d','u','i','n','o',' ','L','e','o','n','a','r','d','o'
-#elif USB_PID == 0x8037
-	'A','r','d','u','i','n','o',' ','M','i','c','r','o',' ',' ',' '
-#elif USB_PID == 0x803C
-	'A','r','d','u','i','n','o',' ','E','s','p','l','o','r','a',' '
-#elif USB_PID == 0x9208
-	'L','i','l','y','P','a','d','U','S','B',' ',' ',' ',' ',' ',' '
-#else
-	'U','S','B',' ','I','O',' ','B','o','a','r','d',' ',' ',' ',' '
-#endif
-};
-
-const u16 STRING_IMANUFACTURER[12] = {
-	(3<<8) | (2+2*11),
-#if USB_VID == 0x2341
-	'A','r','d','u','i','n','o',' ','L','L','C'
-#elif USB_VID == 0x1b4f
-	'S','p','a','r','k','F','u','n',' ',' ',' '
-#else
-	'U','n','k','n','o','w','n',' ',' ',' ',' '
-#endif
-};
-
-#ifdef CDC_ENABLED
-#define DEVICE_CLASS 0x02
-#else
-#define DEVICE_CLASS 0x00
-#endif
-
-//	DEVICE DESCRIPTOR
-const DeviceDescriptor USB_DeviceDescriptor =
-	D_DEVICE(0x00,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
-
-const DeviceDescriptor USB_DeviceDescriptorA =
-	D_DEVICE(DEVICE_CLASS,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
-
-//==================================================================
-//==================================================================
-
-volatile u8 _usbConfiguration = 0;
-
-static inline void WaitIN(void)
-{
-	while (!(UEINTX & (1<<TXINI)));
-}
-
-static inline void ClearIN(void)
-{
-	UEINTX = ~(1<<TXINI);
-}
-
-static inline void WaitOUT(void)
-{
-	while (!(UEINTX & (1<<RXOUTI)))
-		;
-}
-
-static inline u8 WaitForINOrOUT()
-{
-	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
-		;
-	return (UEINTX & (1<<RXOUTI)) == 0;
-}
-
-static inline void ClearOUT(void)
-{
-	UEINTX = ~(1<<RXOUTI);
-}
-
-void Recv(volatile u8* data, u8 count)
-{
-	while (count--)
-		*data++ = UEDATX;
-	
-	RXLED1;					// light the RX LED
-	RxLEDPulse = TX_RX_LED_PULSE_MS;	
-}
-
-static inline u8 Recv8()
-{
-	RXLED1;					// light the RX LED
-	RxLEDPulse = TX_RX_LED_PULSE_MS;
-
-	return UEDATX;	
-}
-
-static inline void Send8(u8 d)
-{
-	UEDATX = d;
-}
-
-static inline void SetEP(u8 ep)
-{
-	UENUM = ep;
-}
-
-static inline u8 FifoByteCount()
-{
-	return UEBCLX;
-}
-
-static inline u8 ReceivedSetupInt()
-{
-	return UEINTX & (1<<RXSTPI);
-}
-
-static inline void ClearSetupInt()
-{
-	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
-}
-
-static inline void Stall()
-{
-	UECONX = (1<<STALLRQ) | (1<<EPEN);
-}
-
-static inline u8 ReadWriteAllowed()
-{
-	return UEINTX & (1<<RWAL);
-}
-
-static inline u8 Stalled()
-{
-	return UEINTX & (1<<STALLEDI);
-}
-
-static inline u8 FifoFree()
-{
-	return UEINTX & (1<<FIFOCON);
-}
-
-static inline void ReleaseRX()
-{
-	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
-}
-
-static inline void ReleaseTX()
-{
-	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
-}
-
-static inline u8 FrameNumber()
-{
-	return UDFNUML;
-}
-
-//==================================================================
-//==================================================================
-
-u8 USBGetConfiguration(void)
-{
-	return _usbConfiguration;
-}
-
-#define USB_RECV_TIMEOUT
-class LockEP
-{
-	u8 _sreg;
-public:
-	LockEP(u8 ep) : _sreg(SREG)
-	{
-		cli();
-		SetEP(ep & 7);
-	}
-	~LockEP()
-	{
-		SREG = _sreg;
-	}
-};
-
-//	Number of bytes, assumes a rx endpoint
-u8 USB_Available(u8 ep)
-{
-	LockEP lock(ep);
-	return FifoByteCount();
-}
-
-//	Non Blocking receive
-//	Return number of bytes read
-int USB_Recv(u8 ep, void* d, int len)
-{
-	if (!_usbConfiguration || len < 0)
-		return -1;
-	
-	LockEP lock(ep);
-	u8 n = FifoByteCount();
-	len = min(n,len);
-	n = len;
-	u8* dst = (u8*)d;
-	while (n--)
-		*dst++ = Recv8();
-	if (len && !FifoByteCount())	// release empty buffer
-		ReleaseRX();
-	
-	return len;
-}
-
-//	Recv 1 byte if ready
-int USB_Recv(u8 ep)
-{
-	u8 c;
-	if (USB_Recv(ep,&c,1) != 1)
-		return -1;
-	return c;
-}
-
-//	Space in send EP
-u8 USB_SendSpace(u8 ep)
-{
-	LockEP lock(ep);
-	if (!ReadWriteAllowed())
-		return 0;
-	return 64 - FifoByteCount();
-}
-
-//	Blocking Send of data to an endpoint
-int USB_Send(u8 ep, const void* d, int len)
-{
-	if (!_usbConfiguration)
-		return -1;
-
-	int r = len;
-	const u8* data = (const u8*)d;
-	u8 zero = ep & TRANSFER_ZERO;
-	u8 timeout = 250;		// 250ms timeout on send? TODO
-	while (len)
-	{
-		u8 n = USB_SendSpace(ep);
-		if (n == 0)
-		{
-			if (!(--timeout))
-				return -1;
-			delay(1);
-			continue;
-		}
-
-		if (n > len)
-			n = len;
-		len -= n;
-		{
-			LockEP lock(ep);
-			if (ep & TRANSFER_ZERO)
-			{
-				while (n--)
-					Send8(0);
-			}
-			else if (ep & TRANSFER_PGM)
-			{
-				while (n--)
-					Send8(pgm_read_byte(data++));
-			}
-			else
-			{
-				while (n--)
-					Send8(*data++);
-			}
-			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
-				ReleaseTX();
-		}
-	}
-	TXLED1;					// light the TX LED
-	TxLEDPulse = TX_RX_LED_PULSE_MS;
-	return r;
-}
-
-extern const u8 _initEndpoints[] PROGMEM;
-const u8 _initEndpoints[] = 
-{
-	0,
-	
-#ifdef CDC_ENABLED
-	EP_TYPE_INTERRUPT_IN,		// CDC_ENDPOINT_ACM
-	EP_TYPE_BULK_OUT,			// CDC_ENDPOINT_OUT
-	EP_TYPE_BULK_IN,			// CDC_ENDPOINT_IN
-#endif
-
-#ifdef HID_ENABLED
-	EP_TYPE_INTERRUPT_IN		// HID_ENDPOINT_INT
-#endif
-};
-
-#define EP_SINGLE_64 0x32	// EP0
-#define EP_DOUBLE_64 0x36	// Other endpoints
-
-static
-void InitEP(u8 index, u8 type, u8 size)
-{
-	UENUM = index;
-	UECONX = 1;
-	UECFG0X = type;
-	UECFG1X = size;
-}
-
-static
-void InitEndpoints()
-{
-	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
-	{
-		UENUM = i;
-		UECONX = 1;
-		UECFG0X = pgm_read_byte(_initEndpoints+i);
-		UECFG1X = EP_DOUBLE_64;
-	}
-	UERST = 0x7E;	// And reset them
-	UERST = 0;
-}
-
-//	Handle CLASS_INTERFACE requests
-static
-bool ClassInterfaceRequest(Setup& setup)
-{
-	u8 i = setup.wIndex;
-
-#ifdef CDC_ENABLED
-	if (CDC_ACM_INTERFACE == i)
-		return CDC_Setup(setup);
-#endif
-
-#ifdef HID_ENABLED
-	if (HID_INTERFACE == i)
-		return HID_Setup(setup);
-#endif
-	return false;
-}
-
-int _cmark;
-int _cend;
-void InitControl(int end)
-{
-	SetEP(0);
-	_cmark = 0;
-	_cend = end;
-}
-
-static
-bool SendControl(u8 d)
-{
-	if (_cmark < _cend)
-	{
-		if (!WaitForINOrOUT())
-			return false;
-		Send8(d);
-		if (!((_cmark + 1) & 0x3F))
-			ClearIN();	// Fifo is full, release this packet
-	}
-	_cmark++;
-	return true;
-};
-
-//	Clipped by _cmark/_cend
-int USB_SendControl(u8 flags, const void* d, int len)
-{
-	int sent = len;
-	const u8* data = (const u8*)d;
-	bool pgm = flags & TRANSFER_PGM;
-	while (len--)
-	{
-		u8 c = pgm ? pgm_read_byte(data++) : *data++;
-		if (!SendControl(c))
-			return -1;
-	}
-	return sent;
-}
-
-//	Does not timeout or cross fifo boundaries
-//	Will only work for transfers <= 64 bytes
-//	TODO
-int USB_RecvControl(void* d, int len)
-{
-	WaitOUT();
-	Recv((u8*)d,len);
-	ClearOUT();
-	return len;
-}
-
-int SendInterfaces()
-{
-	int total = 0;
-	u8 interfaces = 0;
-
-#ifdef CDC_ENABLED
-	total = CDC_GetInterface(&interfaces);
-#endif
-
-#ifdef HID_ENABLED
-	total += HID_GetInterface(&interfaces);
-#endif
-
-	return interfaces;
-}
-
-//	Construct a dynamic configuration descriptor
-//	This really needs dynamic endpoint allocation etc
-//	TODO
-static
-bool SendConfiguration(int maxlen)
-{
-	//	Count and measure interfaces
-	InitControl(0);	
-	int interfaces = SendInterfaces();
-	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
-
-	//	Now send them
-	InitControl(maxlen);
-	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
-	SendInterfaces();
-	return true;
-}
-
-u8 _cdcComposite = 0;
-
-static
-bool SendDescriptor(Setup& setup)
-{
-	u8 t = setup.wValueH;
-	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
-		return SendConfiguration(setup.wLength);
-
-	InitControl(setup.wLength);
-#ifdef HID_ENABLED
-	if (HID_REPORT_DESCRIPTOR_TYPE == t)
-		return HID_GetDescriptor(t);
-#endif
-
-	u8 desc_length = 0;
-	const u8* desc_addr = 0;
-	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
-	{
-		if (setup.wLength == 8)
-			_cdcComposite = 1;
-		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
-	}
-	else if (USB_STRING_DESCRIPTOR_TYPE == t)
-	{
-		if (setup.wValueL == 0)
-			desc_addr = (const u8*)&STRING_LANGUAGE;
-		else if (setup.wValueL == IPRODUCT) 
-			desc_addr = (const u8*)&STRING_IPRODUCT;
-		else if (setup.wValueL == IMANUFACTURER)
-			desc_addr = (const u8*)&STRING_IMANUFACTURER;
-		else
-			return false;
-	}
-
-	if (desc_addr == 0)
-		return false;
-	if (desc_length == 0)
-		desc_length = pgm_read_byte(desc_addr);
-
-	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
-	return true;
-}
-
-//	Endpoint 0 interrupt
-ISR(USB_COM_vect)
-{
-    SetEP(0);
-	if (!ReceivedSetupInt())
-		return;
-
-	Setup setup;
-	Recv((u8*)&setup,8);
-	ClearSetupInt();
-
-	u8 requestType = setup.bmRequestType;
-	if (requestType & REQUEST_DEVICETOHOST)
-		WaitIN();
-	else
-		ClearIN();
-
-    bool ok = true;
-	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
-	{
-		//	Standard Requests
-		u8 r = setup.bRequest;
-		if (GET_STATUS == r)
-		{
-			Send8(0);		// TODO
-			Send8(0);
-		}
-		else if (CLEAR_FEATURE == r)
-		{
-		}
-		else if (SET_FEATURE == r)
-		{
-		}
-		else if (SET_ADDRESS == r)
-		{
-			WaitIN();
-			UDADDR = setup.wValueL | (1<<ADDEN);
-		}
-		else if (GET_DESCRIPTOR == r)
-		{
-			ok = SendDescriptor(setup);
-		}
-		else if (SET_DESCRIPTOR == r)
-		{
-			ok = false;
-		}
-		else if (GET_CONFIGURATION == r)
-		{
-			Send8(1);
-		}
-		else if (SET_CONFIGURATION == r)
-		{
-			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
-			{
-				InitEndpoints();
-				_usbConfiguration = setup.wValueL;
-			} else
-				ok = false;
-		}
-		else if (GET_INTERFACE == r)
-		{
-		}
-		else if (SET_INTERFACE == r)
-		{
-		}
-	}
-	else
-	{
-		InitControl(setup.wLength);		//	Max length of transfer
-		ok = ClassInterfaceRequest(setup);
-	}
-
-	if (ok)
-		ClearIN();
-	else
-	{
-		Stall();
-	}
-}
-
-void USB_Flush(u8 ep)
-{
-	SetEP(ep);
-	if (FifoByteCount())
-		ReleaseTX();
-}
-
-//	General interrupt
-ISR(USB_GEN_vect)
-{
-	u8 udint = UDINT;
-	UDINT = 0;
-
-	//	End of Reset
-	if (udint & (1<<EORSTI))
-	{
-		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
-		_usbConfiguration = 0;			// not configured yet
-		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
-	}
-
-	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
-	if (udint & (1<<SOFI))
-	{
-#ifdef CDC_ENABLED
-		USB_Flush(CDC_TX);				// Send a tx frame if found
-		if (USB_Available(CDC_RX))	// Handle received bytes (if any)
-			Serial.accept();
-#endif
-		
-		// check whether the one-shot period has elapsed.  if so, turn off the LED
-		if (TxLEDPulse && !(--TxLEDPulse))
-			TXLED0;
-		if (RxLEDPulse && !(--RxLEDPulse))
-			RXLED0;
-	}
-}
-
-//	VBUS or counting frames
-//	Any frame counting?
-u8 USBConnected()
-{
-	u8 f = UDFNUML;
-	delay(3);
-	return f != UDFNUML;
-}
-
-//=======================================================================
-//=======================================================================
-
-USBDevice_ USBDevice;
-
-USBDevice_::USBDevice_()
-{
-}
-
-void USBDevice_::attach()
-{
-	_usbConfiguration = 0;
-	UHWCON = 0x01;						// power internal reg
-	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
-#if F_CPU == 16000000UL
-	PLLCSR = 0x12;						// Need 16 MHz xtal
-#elif F_CPU == 8000000UL
-	PLLCSR = 0x02;						// Need 8 MHz xtal
-#endif
-	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
-		;
-
-	// Some tests on specific versions of macosx (10.7.3), reported some
-	// strange behaviuors when the board is reset using the serial
-	// port touch at 1200 bps. This delay fixes this behaviour.
-	delay(1);
-
-	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
-	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
-	UDCON = 0;							// enable attach resistor
-	
-	TX_RX_LED_INIT;
-}
-
-void USBDevice_::detach()
-{
-}
-
-//	Check for interrupts
-//	TODO: VBUS detection
-bool USBDevice_::configured()
-{
-	return _usbConfiguration;
-}
-
-void USBDevice_::poll()
-{
-}
-
-#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.h
deleted file mode 100644
index 8d13806..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBCore.h
+++ /dev/null
@@ -1,303 +0,0 @@
-
-// Copyright (c) 2010, Peter Barrett 
-/*
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-**  
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#ifndef __USBCORE_H__
-#define __USBCORE_H__
-
-//	Standard requests
-#define GET_STATUS			0
-#define CLEAR_FEATURE		1
-#define SET_FEATURE			3
-#define SET_ADDRESS			5
-#define GET_DESCRIPTOR		6
-#define SET_DESCRIPTOR		7
-#define GET_CONFIGURATION	8
-#define SET_CONFIGURATION	9
-#define GET_INTERFACE		10
-#define SET_INTERFACE		11
-
-
-// bmRequestType
-#define REQUEST_HOSTTODEVICE	0x00
-#define REQUEST_DEVICETOHOST	0x80
-#define REQUEST_DIRECTION		0x80
-
-#define REQUEST_STANDARD		0x00
-#define REQUEST_CLASS			0x20
-#define REQUEST_VENDOR			0x40
-#define REQUEST_TYPE			0x60
-
-#define REQUEST_DEVICE			0x00
-#define REQUEST_INTERFACE		0x01
-#define REQUEST_ENDPOINT		0x02
-#define REQUEST_OTHER			0x03
-#define REQUEST_RECIPIENT		0x03
-
-#define REQUEST_DEVICETOHOST_CLASS_INTERFACE  (REQUEST_DEVICETOHOST + REQUEST_CLASS + REQUEST_INTERFACE)
-#define REQUEST_HOSTTODEVICE_CLASS_INTERFACE  (REQUEST_HOSTTODEVICE + REQUEST_CLASS + REQUEST_INTERFACE)
-
-//	Class requests
-
-#define CDC_SET_LINE_CODING			0x20
-#define CDC_GET_LINE_CODING			0x21
-#define CDC_SET_CONTROL_LINE_STATE	0x22
-
-#define MSC_RESET					0xFF
-#define MSC_GET_MAX_LUN				0xFE
-
-#define HID_GET_REPORT				0x01
-#define HID_GET_IDLE				0x02
-#define HID_GET_PROTOCOL			0x03
-#define HID_SET_REPORT				0x09
-#define HID_SET_IDLE				0x0A
-#define HID_SET_PROTOCOL			0x0B
-
-//	Descriptors
-
-#define USB_DEVICE_DESC_SIZE 18
-#define USB_CONFIGUARTION_DESC_SIZE 9
-#define USB_INTERFACE_DESC_SIZE 9
-#define USB_ENDPOINT_DESC_SIZE 7
-
-#define USB_DEVICE_DESCRIPTOR_TYPE             1
-#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
-#define USB_STRING_DESCRIPTOR_TYPE             3
-#define USB_INTERFACE_DESCRIPTOR_TYPE          4
-#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
-
-#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
-#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
-#define USB_DEVICE_CLASS_STORAGE               0x08
-#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
-
-#define USB_CONFIG_POWERED_MASK                0x40
-#define USB_CONFIG_BUS_POWERED                 0x80
-#define USB_CONFIG_SELF_POWERED                0xC0
-#define USB_CONFIG_REMOTE_WAKEUP               0x20
-
-// bMaxPower in Configuration Descriptor
-#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
-
-// bEndpointAddress in Endpoint Descriptor
-#define USB_ENDPOINT_DIRECTION_MASK            0x80
-#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
-#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
-
-#define USB_ENDPOINT_TYPE_MASK                 0x03
-#define USB_ENDPOINT_TYPE_CONTROL              0x00
-#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
-#define USB_ENDPOINT_TYPE_BULK                 0x02
-#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
-
-#define TOBYTES(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
-
-#define CDC_V1_10                               0x0110
-#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
-
-#define CDC_CALL_MANAGEMENT                     0x01
-#define CDC_ABSTRACT_CONTROL_MODEL              0x02
-#define CDC_HEADER                              0x00
-#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
-#define CDC_UNION                               0x06
-#define CDC_CS_INTERFACE                        0x24
-#define CDC_CS_ENDPOINT                         0x25
-#define CDC_DATA_INTERFACE_CLASS                0x0A
-
-#define MSC_SUBCLASS_SCSI						0x06 
-#define MSC_PROTOCOL_BULK_ONLY					0x50 
-
-#define HID_HID_DESCRIPTOR_TYPE					0x21
-#define HID_REPORT_DESCRIPTOR_TYPE				0x22
-#define HID_PHYSICAL_DESCRIPTOR_TYPE			0x23
-
-
-//	Device
-typedef struct {
-	u8 len;				// 18
-	u8 dtype;			// 1 USB_DEVICE_DESCRIPTOR_TYPE
-	u16 usbVersion;		// 0x200
-	u8	deviceClass;
-	u8	deviceSubClass;
-	u8	deviceProtocol;
-	u8	packetSize0;	// Packet 0
-	u16	idVendor;
-	u16	idProduct;
-	u16	deviceVersion;	// 0x100
-	u8	iManufacturer;
-	u8	iProduct;
-	u8	iSerialNumber;
-	u8	bNumConfigurations;
-} DeviceDescriptor;
-
-//	Config
-typedef struct {
-	u8	len;			// 9
-	u8	dtype;			// 2
-	u16 clen;			// total length
-	u8	numInterfaces;
-	u8	config;
-	u8	iconfig;
-	u8	attributes;
-	u8	maxPower;
-} ConfigDescriptor;
-
-//	String
-
-//	Interface
-typedef struct
-{
-	u8 len;		// 9
-	u8 dtype;	// 4
-	u8 number;
-	u8 alternate;
-	u8 numEndpoints;
-	u8 interfaceClass;
-	u8 interfaceSubClass;
-	u8 protocol;
-	u8 iInterface;
-} InterfaceDescriptor;
-
-//	Endpoint
-typedef struct
-{
-	u8 len;		// 7
-	u8 dtype;	// 5
-	u8 addr;
-	u8 attr;
-	u16 packetSize;
-	u8 interval;
-} EndpointDescriptor;
-
-// Interface Association Descriptor
-// Used to bind 2 interfaces together in CDC compostite device
-typedef struct
-{
-	u8 len;				// 8
-	u8 dtype;			// 11
-	u8 firstInterface;
-	u8 interfaceCount;
-	u8 functionClass;
-	u8 funtionSubClass;
-	u8 functionProtocol;
-	u8 iInterface;
-} IADDescriptor;
-
-//	CDC CS interface descriptor
-typedef struct
-{
-	u8 len;		// 5
-	u8 dtype;	// 0x24
-	u8 subtype;
-	u8 d0;
-	u8 d1;
-} CDCCSInterfaceDescriptor;
-
-typedef struct
-{
-	u8 len;		// 4
-	u8 dtype;	// 0x24
-	u8 subtype;
-	u8 d0;
-} CDCCSInterfaceDescriptor4;
-
-typedef struct 
-{
-    u8	len;
-    u8 	dtype;		// 0x24
-    u8 	subtype;	// 1
-    u8 	bmCapabilities;
-    u8 	bDataInterface;
-} CMFunctionalDescriptor;
-	
-typedef struct 
-{
-    u8	len;
-    u8 	dtype;		// 0x24
-    u8 	subtype;	// 1
-    u8 	bmCapabilities;
-} ACMFunctionalDescriptor;
-
-typedef struct 
-{
-	//	IAD
-	IADDescriptor				iad;	// Only needed on compound device
-
-	//	Control
-	InterfaceDescriptor			cif;	// 
-	CDCCSInterfaceDescriptor	header;
-	CMFunctionalDescriptor		callManagement;			// Call Management
-	ACMFunctionalDescriptor		controlManagement;		// ACM
-	CDCCSInterfaceDescriptor	functionalDescriptor;	// CDC_UNION
-	EndpointDescriptor			cifin;
-
-	//	Data
-	InterfaceDescriptor			dif;
-	EndpointDescriptor			in;
-	EndpointDescriptor			out;
-} CDCDescriptor;
-
-typedef struct 
-{
-	InterfaceDescriptor			msc;
-	EndpointDescriptor			in;
-	EndpointDescriptor			out;
-} MSCDescriptor;
-
-typedef struct
-{
-	u8 len;			// 9
-	u8 dtype;		// 0x21
-	u8 addr;
-	u8	versionL;	// 0x101
-	u8	versionH;	// 0x101
-	u8	country;
-	u8	desctype;	// 0x22 report
-	u8	descLenL;
-	u8	descLenH;
-} HIDDescDescriptor;
-
-typedef struct 
-{
-	InterfaceDescriptor			hid;
-	HIDDescDescriptor			desc;
-	EndpointDescriptor			in;
-} HIDDescriptor;
-
-
-#define D_DEVICE(_class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs) \
-	{ 18, 1, 0x200, _class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs }
-
-#define D_CONFIG(_totalLength,_interfaces) \
-	{ 9, 2, _totalLength,_interfaces, 1, 0, USB_CONFIG_BUS_POWERED, USB_CONFIG_POWER_MA(500) }
-
-#define D_INTERFACE(_n,_numEndpoints,_class,_subClass,_protocol) \
-	{ 9, 4, _n, 0, _numEndpoints, _class,_subClass, _protocol, 0 }
-
-#define D_ENDPOINT(_addr,_attr,_packetSize, _interval) \
-	{ 7, 5, _addr,_attr,_packetSize, _interval }
-
-#define D_IAD(_firstInterface, _count, _class, _subClass, _protocol) \
-	{ 8, 11, _firstInterface, _count, _class, _subClass, _protocol, 0 }
-
-#define D_HIDREPORT(_descriptorLength) \
-	{ 9, 0x21, 0x1, 0x1, 0, 1, 0x22, _descriptorLength, 0 }
-
-#define D_CDCCS(_subtype,_d0,_d1)	{ 5, 0x24, _subtype, _d0, _d1 }
-#define D_CDCCS4(_subtype,_d0)		{ 4, 0x24, _subtype, _d0 }
-
-
-#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBDesc.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBDesc.h
deleted file mode 100644
index 900713e..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/USBDesc.h
+++ /dev/null
@@ -1,63 +0,0 @@
-
-
-/* Copyright (c) 2011, Peter Barrett  
-**  
-** Permission to use, copy, modify, and/or distribute this software for  
-** any purpose with or without fee is hereby granted, provided that the  
-** above copyright notice and this permission notice appear in all copies.  
-** 
-** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
-** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
-** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
-** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
-** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
-** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
-** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
-** SOFTWARE.  
-*/
-
-#define CDC_ENABLED
-#define HID_ENABLED
-
-
-#ifdef CDC_ENABLED
-#define CDC_INTERFACE_COUNT	2
-#define CDC_ENPOINT_COUNT	3
-#else
-#define CDC_INTERFACE_COUNT	0
-#define CDC_ENPOINT_COUNT	0
-#endif
-
-#ifdef HID_ENABLED
-#define HID_INTERFACE_COUNT	1
-#define HID_ENPOINT_COUNT	1
-#else
-#define HID_INTERFACE_COUNT	0
-#define HID_ENPOINT_COUNT	0
-#endif
-
-#define CDC_ACM_INTERFACE	0	// CDC ACM
-#define CDC_DATA_INTERFACE	1	// CDC Data
-#define CDC_FIRST_ENDPOINT	1
-#define CDC_ENDPOINT_ACM	(CDC_FIRST_ENDPOINT)							// CDC First
-#define CDC_ENDPOINT_OUT	(CDC_FIRST_ENDPOINT+1)
-#define CDC_ENDPOINT_IN		(CDC_FIRST_ENDPOINT+2)
-
-#define HID_INTERFACE		(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT)		// HID Interface
-#define HID_FIRST_ENDPOINT	(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT)
-#define HID_ENDPOINT_INT	(HID_FIRST_ENDPOINT)
-
-#define INTERFACE_COUNT		(MSC_INTERFACE + MSC_INTERFACE_COUNT)
-
-#ifdef CDC_ENABLED
-#define CDC_RX CDC_ENDPOINT_OUT
-#define CDC_TX CDC_ENDPOINT_IN
-#endif
-
-#ifdef HID_ENABLED
-#define HID_TX HID_ENDPOINT_INT
-#endif
-
-#define IMANUFACTURER	1
-#define IPRODUCT		2
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Udp.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Udp.h
deleted file mode 100644
index dc5644b..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/Udp.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- *  Udp.cpp: Library to send/receive UDP packets.
- *
- * NOTE: UDP is fast, but has some important limitations (thanks to Warren Gray for mentioning these)
- * 1) UDP does not guarantee the order in which assembled UDP packets are received. This
- * might not happen often in practice, but in larger network topologies, a UDP
- * packet can be received out of sequence. 
- * 2) UDP does not guard against lost packets - so packets *can* disappear without the sender being
- * aware of it. Again, this may not be a concern in practice on small local networks.
- * For more information, see http://www.cafeaulait.org/course/week12/35.html
- *
- * MIT License:
- * Copyright (c) 2008 Bjoern Hartmann
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- *
- * bjoern@cs.stanford.edu 12/30/2008
- */
-
-#ifndef udp_h
-#define udp_h
-
-#include <Stream.h>
-#include <IPAddress.h>
-
-class UDP : public Stream {
-
-public:
-  virtual uint8_t begin(uint16_t) =0;	// initialize, start listening on specified port. Returns 1 if successful, 0 if there are no sockets available to use
-  virtual void stop() =0;  // Finish with the UDP socket
-
-  // Sending UDP packets
-  
-  // Start building up a packet to send to the remote host specific in ip and port
-  // Returns 1 if successful, 0 if there was a problem with the supplied IP address or port
-  virtual int beginPacket(IPAddress ip, uint16_t port) =0;
-  // Start building up a packet to send to the remote host specific in host and port
-  // Returns 1 if successful, 0 if there was a problem resolving the hostname or port
-  virtual int beginPacket(const char *host, uint16_t port) =0;
-  // Finish off this packet and send it
-  // Returns 1 if the packet was sent successfully, 0 if there was an error
-  virtual int endPacket() =0;
-  // Write a single byte into the packet
-  virtual size_t write(uint8_t) =0;
-  // Write size bytes from buffer into the packet
-  virtual size_t write(const uint8_t *buffer, size_t size) =0;
-
-  // Start processing the next available incoming packet
-  // Returns the size of the packet in bytes, or 0 if no packets are available
-  virtual int parsePacket() =0;
-  // Number of bytes remaining in the current packet
-  virtual int available() =0;
-  // Read a single byte from the current packet
-  virtual int read() =0;
-  // Read up to len bytes from the current packet and place them into buffer
-  // Returns the number of bytes read, or 0 if none are available
-  virtual int read(unsigned char* buffer, size_t len) =0;
-  // Read up to len characters from the current packet and place them into buffer
-  // Returns the number of characters read, or 0 if none are available
-  virtual int read(char* buffer, size_t len) =0;
-  // Return the next byte from the current packet without moving on to the next byte
-  virtual int peek() =0;
-  virtual void flush() =0;	// Finish reading the current packet
-
-  // Return the IP address of the host who sent the current incoming packet
-  virtual IPAddress remoteIP() =0;
-  // Return the port of the host who sent the current incoming packet
-  virtual uint16_t remotePort() =0;
-protected:
-  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
-};
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WInterrupts.c
deleted file mode 100644
index 62efc9c..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-  Modified 1 August 2010 by Mark Sproul
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "wiring_private.h"
-
-static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    intFunc[interruptNum] = userFunc;
-    
-    // Configure the interrupt mode (trigger on low input, any change, rising
-    // edge, or falling edge).  The mode constants were chosen to correspond
-    // to the configuration bits in the hardware register, so we simply shift
-    // the mode into place.
-      
-    // Enable the interrupt.
-      
-    switch (interruptNum) {
-#if defined(__AVR_ATmega32U4__)
-	// I hate doing this, but the register assignment differs between the 1280/2560
-	// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't 
-	// even present on the 32U4 this is the only way to distinguish between them.
-	case 0:
-		EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);
-		EIMSK |= (1<<INT0);
-		break;
-	case 1:
-		EICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);
-		EIMSK |= (1<<INT1);
-		break;	
-    case 2:
-        EICRA = (EICRA & ~((1<<ISC20) | (1<<ISC21))) | (mode << ISC20);
-        EIMSK |= (1<<INT2);
-        break;
-    case 3:
-        EICRA = (EICRA & ~((1<<ISC30) | (1<<ISC31))) | (mode << ISC30);
-        EIMSK |= (1<<INT3);
-        break;
-#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-      break;
-    case 3:
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-      break;
-    case 4:
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-      break;
-    case 5:
-      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
-      EIMSK |= (1 << INT3);
-      break;
-    case 0:
-      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
-      EIMSK |= (1 << INT4);
-      break;
-    case 1:
-      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
-      EIMSK |= (1 << INT5);
-      break;
-    case 6:
-      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
-      EIMSK |= (1 << INT6);
-      break;
-    case 7:
-      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
-      EIMSK |= (1 << INT7);
-      break;
-#else		
-    case 0:
-    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GICR |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GIMSK |= (1 << INT0);
-    #else
-      #error attachInterrupt not finished for this CPU (case 0)
-    #endif
-      break;
-
-    case 1:
-    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GICR |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GIMSK |= (1 << INT1);
-    #else
-      #warning attachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-    
-    case 2:
-    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      GICR |= (1 << INT2);
-    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      GIMSK |= (1 << INT2);
-    #endif
-      break;
-#endif
-    }
-  }
-}
-
-void detachInterrupt(uint8_t interruptNum) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    // Disable the interrupt.  (We can't assume that interruptNum is equal
-    // to the number of the EIMSK bit to clear, as this isn't true on the 
-    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
-    switch (interruptNum) {
-#if defined(__AVR_ATmega32U4__)
-    case 0:
-        EIMSK &= ~(1<<INT0);
-        break;
-    case 1:
-        EIMSK &= ~(1<<INT1);
-        break;
-    case 2:
-        EIMSK &= ~(1<<INT2);
-        break;
-    case 3:
-        EIMSK &= ~(1<<INT3);
-        break;		
-#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EIMSK &= ~(1 << INT0);
-      break;
-    case 3:
-      EIMSK &= ~(1 << INT1);
-      break;
-    case 4:
-      EIMSK &= ~(1 << INT2);
-      break;
-    case 5:
-      EIMSK &= ~(1 << INT3);
-      break;
-    case 0:
-      EIMSK &= ~(1 << INT4);
-      break;
-    case 1:
-      EIMSK &= ~(1 << INT5);
-      break;
-    case 6:
-      EIMSK &= ~(1 << INT6);
-      break;
-    case 7:
-      EIMSK &= ~(1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EIMSK) && defined(INT0)
-      EIMSK &= ~(1 << INT0);
-    #elif defined(GICR) && defined(ISC00)
-      GICR &= ~(1 << INT0); // atmega32
-    #elif defined(GIMSK) && defined(INT0)
-      GIMSK &= ~(1 << INT0);
-    #else
-      #error detachInterrupt not finished for this cpu
-    #endif
-      break;
-
-    case 1:
-    #if defined(EIMSK) && defined(INT1)
-      EIMSK &= ~(1 << INT1);
-    #elif defined(GICR) && defined(INT1)
-      GICR &= ~(1 << INT1); // atmega32
-    #elif defined(GIMSK) && defined(INT1)
-      GIMSK &= ~(1 << INT1);
-    #else
-      #warning detachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-      
-    intFunc[interruptNum] = 0;
-  }
-}
-
-/*
-void attachInterruptTwi(void (*userFunc)(void) ) {
-  twiIntFunc = userFunc;
-}
-*/
-
-#if defined(__AVR_ATmega32U4__)
-SIGNAL(INT0_vect) {
-	if(intFunc[EXTERNAL_INT_0])
-		intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-	if(intFunc[EXTERNAL_INT_1])
-		intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT2_vect) {
-    if(intFunc[EXTERNAL_INT_2])
-		intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT3_vect) {
-    if(intFunc[EXTERNAL_INT_3])
-		intFunc[EXTERNAL_INT_3]();
-}
-
-#elif defined(EICRA) && defined(EICRB)
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_3])
-    intFunc[EXTERNAL_INT_3]();
-}
-
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_4])
-    intFunc[EXTERNAL_INT_4]();
-}
-
-SIGNAL(INT3_vect) {
-  if(intFunc[EXTERNAL_INT_5])
-    intFunc[EXTERNAL_INT_5]();
-}
-
-SIGNAL(INT4_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT5_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT6_vect) {
-  if(intFunc[EXTERNAL_INT_6])
-    intFunc[EXTERNAL_INT_6]();
-}
-
-SIGNAL(INT7_vect) {
-  if(intFunc[EXTERNAL_INT_7])
-    intFunc[EXTERNAL_INT_7]();
-}
-
-#else
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-#if defined(EICRA) && defined(ISC20)
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-#endif
-
-#endif
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WMath.cpp
deleted file mode 100644
index 2120c4c..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0) {
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.cpp
deleted file mode 100644
index c6839fc..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,645 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  ...mostly rewritten by Paul Stoffregen...
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-  Copyright 2011, Paul Stoffregen, paul@pjrc.com
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include "WString.h"
-
-
-/*********************************************/
-/*  Constructors                             */
-/*********************************************/
-
-String::String(const char *cstr)
-{
-	init();
-	if (cstr) copy(cstr, strlen(cstr));
-}
-
-String::String(const String &value)
-{
-	init();
-	*this = value;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-String::String(String &&rval)
-{
-	init();
-	move(rval);
-}
-String::String(StringSumHelper &&rval)
-{
-	init();
-	move(rval);
-}
-#endif
-
-String::String(char c)
-{
-	init();
-	char buf[2];
-	buf[0] = c;
-	buf[1] = 0;
-	*this = buf;
-}
-
-String::String(unsigned char value, unsigned char base)
-{
-	init();
-	char buf[9];
-	utoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(int value, unsigned char base)
-{
-	init();
-	char buf[18];
-	itoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(unsigned int value, unsigned char base)
-{
-	init();
-	char buf[17];
-	utoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(long value, unsigned char base)
-{
-	init();
-	char buf[34];
-	ltoa(value, buf, base);
-	*this = buf;
-}
-
-String::String(unsigned long value, unsigned char base)
-{
-	init();
-	char buf[33];
-	ultoa(value, buf, base);
-	*this = buf;
-}
-
-String::~String()
-{
-	free(buffer);
-}
-
-/*********************************************/
-/*  Memory Management                        */
-/*********************************************/
-
-inline void String::init(void)
-{
-	buffer = NULL;
-	capacity = 0;
-	len = 0;
-	flags = 0;
-}
-
-void String::invalidate(void)
-{
-	if (buffer) free(buffer);
-	buffer = NULL;
-	capacity = len = 0;
-}
-
-unsigned char String::reserve(unsigned int size)
-{
-	if (buffer && capacity >= size) return 1;
-	if (changeBuffer(size)) {
-		if (len == 0) buffer[0] = 0;
-		return 1;
-	}
-	return 0;
-}
-
-unsigned char String::changeBuffer(unsigned int maxStrLen)
-{
-	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
-	if (newbuffer) {
-		buffer = newbuffer;
-		capacity = maxStrLen;
-		return 1;
-	}
-	return 0;
-}
-
-/*********************************************/
-/*  Copy and Move                            */
-/*********************************************/
-
-String & String::copy(const char *cstr, unsigned int length)
-{
-	if (!reserve(length)) {
-		invalidate();
-		return *this;
-	}
-	len = length;
-	strcpy(buffer, cstr);
-	return *this;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-void String::move(String &rhs)
-{
-	if (buffer) {
-		if (capacity >= rhs.len) {
-			strcpy(buffer, rhs.buffer);
-			len = rhs.len;
-			rhs.len = 0;
-			return;
-		} else {
-			free(buffer);
-		}
-	}
-	buffer = rhs.buffer;
-	capacity = rhs.capacity;
-	len = rhs.len;
-	rhs.buffer = NULL;
-	rhs.capacity = 0;
-	rhs.len = 0;
-}
-#endif
-
-String & String::operator = (const String &rhs)
-{
-	if (this == &rhs) return *this;
-	
-	if (rhs.buffer) copy(rhs.buffer, rhs.len);
-	else invalidate();
-	
-	return *this;
-}
-
-#ifdef __GXX_EXPERIMENTAL_CXX0X__
-String & String::operator = (String &&rval)
-{
-	if (this != &rval) move(rval);
-	return *this;
-}
-
-String & String::operator = (StringSumHelper &&rval)
-{
-	if (this != &rval) move(rval);
-	return *this;
-}
-#endif
-
-String & String::operator = (const char *cstr)
-{
-	if (cstr) copy(cstr, strlen(cstr));
-	else invalidate();
-	
-	return *this;
-}
-
-/*********************************************/
-/*  concat                                   */
-/*********************************************/
-
-unsigned char String::concat(const String &s)
-{
-	return concat(s.buffer, s.len);
-}
-
-unsigned char String::concat(const char *cstr, unsigned int length)
-{
-	unsigned int newlen = len + length;
-	if (!cstr) return 0;
-	if (length == 0) return 1;
-	if (!reserve(newlen)) return 0;
-	strcpy(buffer + len, cstr);
-	len = newlen;
-	return 1;
-}
-
-unsigned char String::concat(const char *cstr)
-{
-	if (!cstr) return 0;
-	return concat(cstr, strlen(cstr));
-}
-
-unsigned char String::concat(char c)
-{
-	char buf[2];
-	buf[0] = c;
-	buf[1] = 0;
-	return concat(buf, 1);
-}
-
-unsigned char String::concat(unsigned char num)
-{
-	char buf[4];
-	itoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(int num)
-{
-	char buf[7];
-	itoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(unsigned int num)
-{
-	char buf[6];
-	utoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(long num)
-{
-	char buf[12];
-	ltoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-unsigned char String::concat(unsigned long num)
-{
-	char buf[11];
-	ultoa(num, buf, 10);
-	return concat(buf, strlen(buf));
-}
-
-/*********************************************/
-/*  Concatenate                              */
-/*********************************************/
-
-StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, char c)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(c)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, int num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, long num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
-{
-	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
-	if (!a.concat(num)) a.invalidate();
-	return a;
-}
-
-/*********************************************/
-/*  Comparison                               */
-/*********************************************/
-
-int String::compareTo(const String &s) const
-{
-	if (!buffer || !s.buffer) {
-		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
-		if (buffer && len > 0) return *(unsigned char *)buffer;
-		return 0;
-	}
-	return strcmp(buffer, s.buffer);
-}
-
-unsigned char String::equals(const String &s2) const
-{
-	return (len == s2.len && compareTo(s2) == 0);
-}
-
-unsigned char String::equals(const char *cstr) const
-{
-	if (len == 0) return (cstr == NULL || *cstr == 0);
-	if (cstr == NULL) return buffer[0] == 0;
-	return strcmp(buffer, cstr) == 0;
-}
-
-unsigned char String::operator<(const String &rhs) const
-{
-	return compareTo(rhs) < 0;
-}
-
-unsigned char String::operator>(const String &rhs) const
-{
-	return compareTo(rhs) > 0;
-}
-
-unsigned char String::operator<=(const String &rhs) const
-{
-	return compareTo(rhs) <= 0;
-}
-
-unsigned char String::operator>=(const String &rhs) const
-{
-	return compareTo(rhs) >= 0;
-}
-
-unsigned char String::equalsIgnoreCase( const String &s2 ) const
-{
-	if (this == &s2) return 1;
-	if (len != s2.len) return 0;
-	if (len == 0) return 1;
-	const char *p1 = buffer;
-	const char *p2 = s2.buffer;
-	while (*p1) {
-		if (tolower(*p1++) != tolower(*p2++)) return 0;
-	} 
-	return 1;
-}
-
-unsigned char String::startsWith( const String &s2 ) const
-{
-	if (len < s2.len) return 0;
-	return startsWith(s2, 0);
-}
-
-unsigned char String::startsWith( const String &s2, unsigned int offset ) const
-{
-	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
-	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
-}
-
-unsigned char String::endsWith( const String &s2 ) const
-{
-	if ( len < s2.len || !buffer || !s2.buffer) return 0;
-	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
-}
-
-/*********************************************/
-/*  Character Access                         */
-/*********************************************/
-
-char String::charAt(unsigned int loc) const
-{
-	return operator[](loc);
-}
-
-void String::setCharAt(unsigned int loc, char c) 
-{
-	if (loc < len) buffer[loc] = c;
-}
-
-char & String::operator[](unsigned int index)
-{
-	static char dummy_writable_char;
-	if (index >= len || !buffer) {
-		dummy_writable_char = 0;
-		return dummy_writable_char;
-	}
-	return buffer[index];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-	if (index >= len || !buffer) return 0;
-	return buffer[index];
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
-{
-	if (!bufsize || !buf) return;
-	if (index >= len) {
-		buf[0] = 0;
-		return;
-	}
-	unsigned int n = bufsize - 1;
-	if (n > len - index) n = len - index;
-	strncpy((char *)buf, buffer + index, n);
-	buf[n] = 0;
-}
-
-/*********************************************/
-/*  Search                                   */
-/*********************************************/
-
-int String::indexOf(char c) const
-{
-	return indexOf(c, 0);
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-	if (fromIndex >= len) return -1;
-	const char* temp = strchr(buffer + fromIndex, ch);
-	if (temp == NULL) return -1;
-	return temp - buffer;
-}
-
-int String::indexOf(const String &s2) const
-{
-	return indexOf(s2, 0);
-}
-
-int String::indexOf(const String &s2, unsigned int fromIndex) const
-{
-	if (fromIndex >= len) return -1;
-	const char *found = strstr(buffer + fromIndex, s2.buffer);
-	if (found == NULL) return -1;
-	return found - buffer;
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-	return lastIndexOf(theChar, len - 1);
-}
-
-int String::lastIndexOf(char ch, unsigned int fromIndex) const
-{
-	if (fromIndex >= len) return -1;
-	char tempchar = buffer[fromIndex + 1];
-	buffer[fromIndex + 1] = '\0';
-	char* temp = strrchr( buffer, ch );
-	buffer[fromIndex + 1] = tempchar;
-	if (temp == NULL) return -1;
-	return temp - buffer;
-}
-
-int String::lastIndexOf(const String &s2) const
-{
-	return lastIndexOf(s2, len - s2.len);
-}
-
-int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
-{
-  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
-	if (fromIndex >= len) fromIndex = len - 1;
-	int found = -1;
-	for (char *p = buffer; p <= buffer + fromIndex; p++) {
-		p = strstr(p, s2.buffer);
-		if (!p) break;
-		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
-	}
-	return found;
-}
-
-String String::substring( unsigned int left ) const
-{
-	return substring(left, len);
-}
-
-String String::substring(unsigned int left, unsigned int right) const
-{
-	if (left > right) {
-		unsigned int temp = right;
-		right = left;
-		left = temp;
-	}
-	String out;
-	if (left > len) return out;
-	if (right > len) right = len;
-	char temp = buffer[right];  // save the replaced character
-	buffer[right] = '\0';	
-	out = buffer + left;  // pointer arithmetic
-	buffer[right] = temp;  //restore character
-	return out;
-}
-
-/*********************************************/
-/*  Modification                             */
-/*********************************************/
-
-void String::replace(char find, char replace)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		if (*p == find) *p = replace;
-	}
-}
-
-void String::replace(const String& find, const String& replace)
-{
-	if (len == 0 || find.len == 0) return;
-	int diff = replace.len - find.len;
-	char *readFrom = buffer;
-	char *foundAt;
-	if (diff == 0) {
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			memcpy(foundAt, replace.buffer, replace.len);
-			readFrom = foundAt + replace.len;
-		}
-	} else if (diff < 0) {
-		char *writeTo = buffer;
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			unsigned int n = foundAt - readFrom;
-			memcpy(writeTo, readFrom, n);
-			writeTo += n;
-			memcpy(writeTo, replace.buffer, replace.len);
-			writeTo += replace.len;
-			readFrom = foundAt + find.len;
-			len += diff;
-		}
-		strcpy(writeTo, readFrom);
-	} else {
-		unsigned int size = len; // compute size needed for result
-		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
-			readFrom = foundAt + find.len;
-			size += diff;
-		}
-		if (size == len) return;
-		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
-		int index = len - 1;
-		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
-			readFrom = buffer + index + find.len;
-			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
-			len += diff;
-			buffer[len] = 0;
-			memcpy(buffer + index, replace.buffer, replace.len);
-			index--;
-		}
-	}
-}
-
-void String::toLowerCase(void)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		*p = tolower(*p);
-	}
-}
-
-void String::toUpperCase(void)
-{
-	if (!buffer) return;
-	for (char *p = buffer; *p; p++) {
-		*p = toupper(*p);
-	}
-}
-
-void String::trim(void)
-{
-	if (!buffer || len == 0) return;
-	char *begin = buffer;
-	while (isspace(*begin)) begin++;
-	char *end = buffer + len - 1;
-	while (isspace(*end) && end >= begin) end--;
-	len = end + 1 - begin;
-	if (begin > buffer) memcpy(buffer, begin, len);
-	buffer[len] = 0;
-}
-
-/*********************************************/
-/*  Parsing / Conversion                     */
-/*********************************************/
-
-long String::toInt(void) const
-{
-	if (buffer) return atol(buffer);
-	return 0;
-}
-
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.h
deleted file mode 100644
index 947325e..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/WString.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  ...mostly rewritten by Paul Stoffregen...
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-  Copyright 2011, Paul Stoffregen, paul@pjrc.com
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_class_h
-#define String_class_h
-#ifdef __cplusplus
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include <avr/pgmspace.h>
-
-// When compiling programs with this class, the following gcc parameters
-// dramatically increase performance and memory (RAM) efficiency, typically
-// with little or no increase in code size.
-//     -felide-constructors
-//     -std=c++0x
-
-class __FlashStringHelper;
-#define F(string_literal) (reinterpret_cast<const __FlashStringHelper *>(PSTR(string_literal)))
-
-// An inherited class for holding the result of a concatenation.  These
-// result objects are assumed to be writable by subsequent concatenations.
-class StringSumHelper;
-
-// The string class
-class String
-{
-	// use a function pointer to allow for "if (s)" without the
-	// complications of an operator bool(). for more information, see:
-	// http://www.artima.com/cppsource/safebool.html
-	typedef void (String::*StringIfHelperType)() const;
-	void StringIfHelper() const {}
-
-public:
-	// constructors
-	// creates a copy of the initial value.
-	// if the initial value is null or invalid, or if memory allocation
-	// fails, the string will be marked as invalid (i.e. "if (s)" will
-	// be false).
-	String(const char *cstr = "");
-	String(const String &str);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	String(String &&rval);
-	String(StringSumHelper &&rval);
-	#endif
-	explicit String(char c);
-	explicit String(unsigned char, unsigned char base=10);
-	explicit String(int, unsigned char base=10);
-	explicit String(unsigned int, unsigned char base=10);
-	explicit String(long, unsigned char base=10);
-	explicit String(unsigned long, unsigned char base=10);
-	~String(void);
-
-	// memory management
-	// return true on success, false on failure (in which case, the string
-	// is left unchanged).  reserve(0), if successful, will validate an
-	// invalid string (i.e., "if (s)" will be true afterwards)
-	unsigned char reserve(unsigned int size);
-	inline unsigned int length(void) const {return len;}
-
-	// creates a copy of the assigned value.  if the value is null or
-	// invalid, or if the memory allocation fails, the string will be 
-	// marked as invalid ("if (s)" will be false).
-	String & operator = (const String &rhs);
-	String & operator = (const char *cstr);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	String & operator = (String &&rval);
-	String & operator = (StringSumHelper &&rval);
-	#endif
-
-	// concatenate (works w/ built-in types)
-	
-	// returns true on success, false on failure (in which case, the string
-	// is left unchanged).  if the argument is null or invalid, the 
-	// concatenation is considered unsucessful.  
-	unsigned char concat(const String &str);
-	unsigned char concat(const char *cstr);
-	unsigned char concat(char c);
-	unsigned char concat(unsigned char c);
-	unsigned char concat(int num);
-	unsigned char concat(unsigned int num);
-	unsigned char concat(long num);
-	unsigned char concat(unsigned long num);
-	
-	// if there's not enough memory for the concatenated value, the string
-	// will be left unchanged (but this isn't signalled in any way)
-	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
-	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
-	String & operator += (char c)			{concat(c); return (*this);}
-	String & operator += (unsigned char num)		{concat(num); return (*this);}
-	String & operator += (int num)			{concat(num); return (*this);}
-	String & operator += (unsigned int num)		{concat(num); return (*this);}
-	String & operator += (long num)			{concat(num); return (*this);}
-	String & operator += (unsigned long num)	{concat(num); return (*this);}
-
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, char c);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, int num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, long num);
-	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num);
-
-	// comparison (only works w/ Strings and "strings")
-	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
-	int compareTo(const String &s) const;
-	unsigned char equals(const String &s) const;
-	unsigned char equals(const char *cstr) const;
-	unsigned char operator == (const String &rhs) const {return equals(rhs);}
-	unsigned char operator == (const char *cstr) const {return equals(cstr);}
-	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
-	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
-	unsigned char operator <  (const String &rhs) const;
-	unsigned char operator >  (const String &rhs) const;
-	unsigned char operator <= (const String &rhs) const;
-	unsigned char operator >= (const String &rhs) const;
-	unsigned char equalsIgnoreCase(const String &s) const;
-	unsigned char startsWith( const String &prefix) const;
-	unsigned char startsWith(const String &prefix, unsigned int offset) const;
-	unsigned char endsWith(const String &suffix) const;
-
-	// character acccess
-	char charAt(unsigned int index) const;
-	void setCharAt(unsigned int index, char c);
-	char operator [] (unsigned int index) const;
-	char& operator [] (unsigned int index);
-	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
-	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
-		{getBytes((unsigned char *)buf, bufsize, index);}
-
-	// search
-	int indexOf( char ch ) const;
-	int indexOf( char ch, unsigned int fromIndex ) const;
-	int indexOf( const String &str ) const;
-	int indexOf( const String &str, unsigned int fromIndex ) const;
-	int lastIndexOf( char ch ) const;
-	int lastIndexOf( char ch, unsigned int fromIndex ) const;
-	int lastIndexOf( const String &str ) const;
-	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
-	String substring( unsigned int beginIndex ) const;
-	String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-
-	// modification
-	void replace(char find, char replace);
-	void replace(const String& find, const String& replace);
-	void toLowerCase(void);
-	void toUpperCase(void);
-	void trim(void);
-
-	// parsing/conversion
-	long toInt(void) const;
-
-protected:
-	char *buffer;	        // the actual char array
-	unsigned int capacity;  // the array length minus one (for the '\0')
-	unsigned int len;       // the String length (not counting the '\0')
-	unsigned char flags;    // unused, for future features
-protected:
-	void init(void);
-	void invalidate(void);
-	unsigned char changeBuffer(unsigned int maxStrLen);
-	unsigned char concat(const char *cstr, unsigned int length);
-
-	// copy and move
-	String & copy(const char *cstr, unsigned int length);
-	#ifdef __GXX_EXPERIMENTAL_CXX0X__
-	void move(String &rhs);
-	#endif
-};
-
-class StringSumHelper : public String
-{
-public:
-	StringSumHelper(const String &s) : String(s) {}
-	StringSumHelper(const char *p) : String(p) {}
-	StringSumHelper(char c) : String(c) {}
-	StringSumHelper(unsigned char num) : String(num) {}
-	StringSumHelper(int num) : String(num) {}
-	StringSumHelper(unsigned int num) : String(num) {}
-	StringSumHelper(long num) : String(num) {}
-	StringSumHelper(unsigned long num) : String(num) {}
-};
-
-#endif  // __cplusplus
-#endif  // String_class_h
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/binary.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/main.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/main.cpp
deleted file mode 100644
index 3d4e079..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/main.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#include <Arduino.h>
-
-int main(void)
-{
-	init();
-
-#if defined(USBCON)
-	USBDevice.attach();
-#endif
-	
-	setup();
-    
-	for (;;) {
-		loop();
-		if (serialEventRun) serialEventRun();
-	}
-        
-	return 0;
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.cpp b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.cpp
deleted file mode 100644
index 0f6d422..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-#include <new.h>
-
-void * operator new(size_t size)
-{
-  return malloc(size);
-}
-
-void operator delete(void * ptr)
-{
-  free(ptr);
-} 
-
-int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
-void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
-void __cxa_guard_abort (__guard *) {}; 
-
-void __cxa_pure_virtual(void) {};
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.h
deleted file mode 100644
index cd940ce..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/new.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* Header to define new/delete operators as they aren't provided by avr-gcc by default
-   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=59453 
- */
-
-#ifndef NEW_H
-#define NEW_H
-
-#include <stdlib.h>
-
-void * operator new(size_t size);
-void operator delete(void * ptr); 
-
-__extension__ typedef int __guard __attribute__((mode (__DI__)));
-
-extern "C" int __cxa_guard_acquire(__guard *);
-extern "C" void __cxa_guard_release (__guard *);
-extern "C" void __cxa_guard_abort (__guard *); 
-
-extern "C" void __cxa_pure_virtual(void);
-
-#endif
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring.c
deleted file mode 100644
index ac8bb6f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#include "wiring_private.h"
-
-// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
-// the overflow handler is called every 256 ticks.
-#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
-
-// the whole number of milliseconds per timer0 overflow
-#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
-
-// the fractional number of milliseconds per timer0 overflow. we shift right
-// by three to fit these numbers into a byte. (for the clock speeds we care
-// about - 8 and 16 MHz - this doesn't lose precision.)
-#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
-#define FRACT_MAX (1000 >> 3)
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_millis = 0;
-static unsigned char timer0_fract = 0;
-
-#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
-SIGNAL(TIM0_OVF_vect)
-#else
-SIGNAL(TIMER0_OVF_vect)
-#endif
-{
-	// copy these to local variables so they can be stored in registers
-	// (volatile variables must be read from memory on every access)
-	unsigned long m = timer0_millis;
-	unsigned char f = timer0_fract;
-
-	m += MILLIS_INC;
-	f += FRACT_INC;
-	if (f >= FRACT_MAX) {
-		f -= FRACT_MAX;
-		m += 1;
-	}
-
-	timer0_fract = f;
-	timer0_millis = m;
-	timer0_overflow_count++;
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of a write to timer0_millis)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m;
-	uint8_t oldSREG = SREG, t;
-	
-	cli();
-	m = timer0_overflow_count;
-#if defined(TCNT0)
-	t = TCNT0;
-#elif defined(TCNT0L)
-	t = TCNT0L;
-#else
-	#error TIMER 0 not defined
-#endif
-
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t < 255))
-		m++;
-#else
-	if ((TIFR & _BV(TOV0)) && (t < 255))
-		m++;
-#endif
-
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	uint16_t start = (uint16_t)micros();
-
-	while (ms > 0) {
-		if (((uint16_t)micros() - start) >= 1000) {
-			ms--;
-			start += 1000;
-		}
-	}
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
-void delayMicroseconds(unsigned int us)
-{
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-#if F_CPU >= 20000000L
-	// for the 20 MHz clock on rare Arduino boards
-
-	// for a one-microsecond delay, simply wait 2 cycle and return. The overhead
-	// of the function call yields a delay of exactly a one microsecond.
-	__asm__ __volatile__ (
-		"nop" "\n\t"
-		"nop"); //just waiting 2 cycle
-	if (--us == 0)
-		return;
-
-	// the following loop takes a 1/5 of a microsecond (4 cycles)
-	// per iteration, so execute it five times for each microsecond of
-	// delay requested.
-	us = (us<<2) + us; // x5 us
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-
-#elif F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-    
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-#if defined(TCCR0A) && defined(WGM01)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-#endif  
-
-	// set timer 0 prescale factor to 64
-#if defined(__AVR_ATmega128__)
-	// CPU specific: different values for the ATmega128
-	sbi(TCCR0, CS02);
-#elif defined(TCCR0) && defined(CS01) && defined(CS00)
-	// this combination is for the standard atmega8
-	sbi(TCCR0, CS01);
-	sbi(TCCR0, CS00);
-#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
-	// this combination is for the standard 168/328/1280/2560
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
-	// this combination is for the __AVR_ATmega645__ series
-	sbi(TCCR0A, CS01);
-	sbi(TCCR0A, CS00);
-#else
-	#error Timer 0 prescale factor 64 not set correctly
-#endif
-
-	// enable timer 0 overflow interrupt
-#if defined(TIMSK) && defined(TOIE0)
-	sbi(TIMSK, TOIE0);
-#elif defined(TIMSK0) && defined(TOIE0)
-	sbi(TIMSK0, TOIE0);
-#else
-	#error	Timer 0 overflow interrupt not set correctly
-#endif
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-#if defined(TCCR1B) && defined(CS11) && defined(CS10)
-	TCCR1B = 0;
-
-	// set timer 1 prescale factor to 64
-	sbi(TCCR1B, CS11);
-#if F_CPU >= 8000000L
-	sbi(TCCR1B, CS10);
-#endif
-#elif defined(TCCR1) && defined(CS11) && defined(CS10)
-	sbi(TCCR1, CS11);
-#if F_CPU >= 8000000L
-	sbi(TCCR1, CS10);
-#endif
-#endif
-	// put timer 1 in 8-bit phase correct pwm mode
-#if defined(TCCR1A) && defined(WGM10)
-	sbi(TCCR1A, WGM10);
-#elif defined(TCCR1)
-	#warning this needs to be finished
-#endif
-
-	// set timer 2 prescale factor to 64
-#if defined(TCCR2) && defined(CS22)
-	sbi(TCCR2, CS22);
-#elif defined(TCCR2B) && defined(CS22)
-	sbi(TCCR2B, CS22);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-	// configure timer 2 for phase correct pwm (8-bit)
-#if defined(TCCR2) && defined(WGM20)
-	sbi(TCCR2, WGM20);
-#elif defined(TCCR2A) && defined(WGM20)
-	sbi(TCCR2A, WGM20);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
-	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
-	sbi(TCCR3B, CS30);
-	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
-	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
-	sbi(TCCR4B, CS41);
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
-	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
-	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
-#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
-#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
-	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
-#endif
-#endif /* end timer4 block for ATMEGA1280/2560 and similar */	
-
-#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
-	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
-	sbi(TCCR5B, CS50);
-	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(ADCSRA)
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-#endif
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-#if defined(UCSRB)
-	UCSRB = 0;
-#elif defined(UCSR0B)
-	UCSR0B = 0;
-#endif
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_analog.c
deleted file mode 100644
index 23b01c6..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high;
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
-#elif defined(__AVR_ATmega32U4__)
-	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
-#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
-#else
-	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
-#endif
-	
-#if defined(__AVR_ATmega32U4__)
-	pin = analogPinToChannel(pin);
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#elif defined(ADCSRB) && defined(MUX5)
-	// the MUX5 bit of ADCSRB selects whether we're reading from channels
-	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#endif
-  
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-#if defined(ADMUX)
-	ADMUX = (analog_reference << 6) | (pin & 0x07);
-#endif
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-#if defined(ADCSRA) && defined(ADCL)
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low  = ADCL;
-	high = ADCH;
-#else
-	// we dont have an ADC, return 0
-	low  = 0;
-	high = 0;
-#endif
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	if (val == 0)
-	{
-		digitalWrite(pin, LOW);
-	}
-	else if (val == 255)
-	{
-		digitalWrite(pin, HIGH);
-	}
-	else
-	{
-		switch(digitalPinToTimer(pin))
-		{
-			// XXX fix needed for atmega8
-			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
-			case TIMER0A:
-				// connect pwm to pin on timer 0
-				sbi(TCCR0, COM00);
-				OCR0 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0A1)
-			case TIMER0A:
-				// connect pwm to pin on timer 0, channel A
-				sbi(TCCR0A, COM0A1);
-				OCR0A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0B1)
-			case TIMER0B:
-				// connect pwm to pin on timer 0, channel B
-				sbi(TCCR0A, COM0B1);
-				OCR0B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1A1)
-			case TIMER1A:
-				// connect pwm to pin on timer 1, channel A
-				sbi(TCCR1A, COM1A1);
-				OCR1A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1B1)
-			case TIMER1B:
-				// connect pwm to pin on timer 1, channel B
-				sbi(TCCR1A, COM1B1);
-				OCR1B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2) && defined(COM21)
-			case TIMER2:
-				// connect pwm to pin on timer 2
-				sbi(TCCR2, COM21);
-				OCR2 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2A1)
-			case TIMER2A:
-				// connect pwm to pin on timer 2, channel A
-				sbi(TCCR2A, COM2A1);
-				OCR2A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2B1)
-			case TIMER2B:
-				// connect pwm to pin on timer 2, channel B
-				sbi(TCCR2A, COM2B1);
-				OCR2B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3A1)
-			case TIMER3A:
-				// connect pwm to pin on timer 3, channel A
-				sbi(TCCR3A, COM3A1);
-				OCR3A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3B1)
-			case TIMER3B:
-				// connect pwm to pin on timer 3, channel B
-				sbi(TCCR3A, COM3B1);
-				OCR3B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3C1)
-			case TIMER3C:
-				// connect pwm to pin on timer 3, channel C
-				sbi(TCCR3A, COM3C1);
-				OCR3C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A)
-			case TIMER4A:
-				//connect pwm to pin on timer 4, channel A
-				sbi(TCCR4A, COM4A1);
-				#if defined(COM4A0)		// only used on 32U4
-				cbi(TCCR4A, COM4A0);
-				#endif
-				OCR4A = val;	// set pwm duty
-				break;
-			#endif
-			
-			#if defined(TCCR4A) && defined(COM4B1)
-			case TIMER4B:
-				// connect pwm to pin on timer 4, channel B
-				sbi(TCCR4A, COM4B1);
-				OCR4B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4C1)
-			case TIMER4C:
-				// connect pwm to pin on timer 4, channel C
-				sbi(TCCR4A, COM4C1);
-				OCR4C = val; // set pwm duty
-				break;
-			#endif
-				
-			#if defined(TCCR4C) && defined(COM4D1)
-			case TIMER4D:				
-				// connect pwm to pin on timer 4, channel D
-				sbi(TCCR4C, COM4D1);
-				#if defined(COM4D0)		// only used on 32U4
-				cbi(TCCR4C, COM4D0);
-				#endif
-				OCR4D = val;	// set pwm duty
-				break;
-			#endif
-
-							
-			#if defined(TCCR5A) && defined(COM5A1)
-			case TIMER5A:
-				// connect pwm to pin on timer 5, channel A
-				sbi(TCCR5A, COM5A1);
-				OCR5A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5B1)
-			case TIMER5B:
-				// connect pwm to pin on timer 5, channel B
-				sbi(TCCR5A, COM5B1);
-				OCR5B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5C1)
-			case TIMER5C:
-				// connect pwm to pin on timer 5, channel C
-				sbi(TCCR5A, COM5C1);
-				OCR5C = val; // set pwm duty
-				break;
-			#endif
-
-			case NOT_ON_TIMER:
-			default:
-				if (val < 128) {
-					digitalWrite(pin, LOW);
-				} else {
-					digitalWrite(pin, HIGH);
-				}
-		}
-	}
-}
-
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_digital.c
deleted file mode 100644
index be323b1..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#define ARDUINO_MAIN
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg, *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-	out = portOutputRegister(port);
-
-	if (mode == INPUT) { 
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		*out &= ~bit;
-		SREG = oldSREG;
-	} else if (mode == INPUT_PULLUP) {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		*out |= bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg |= bit;
-		SREG = oldSREG;
-	}
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-// Mark Sproul:
-// - Removed inline. Save 170 bytes on atmega1280
-// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
-// - Added more #ifdefs, now compiles for atmega645
-//
-//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-//static inline void turnOffPWM(uint8_t timer)
-static void turnOffPWM(uint8_t timer)
-{
-	switch (timer)
-	{
-		#if defined(TCCR1A) && defined(COM1A1)
-		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
-		#endif
-		#if defined(TCCR1A) && defined(COM1B1)
-		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
-		#endif
-		
-		#if defined(TCCR2) && defined(COM21)
-		case  TIMER2:   cbi(TCCR2, COM21);      break;
-		#endif
-		
-		#if defined(TCCR0A) && defined(COM0A1)
-		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
-		#endif
-		
-		#if defined(TIMER0B) && defined(COM0B1)
-		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2A1)
-		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2B1)
-		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
-		#endif
-		
-		#if defined(TCCR3A) && defined(COM3A1)
-		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3B1)
-		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3C1)
-		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
-		#endif
-
-		#if defined(TCCR4A) && defined(COM4A1)
-		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
-		#endif					
-		#if defined(TCCR4A) && defined(COM4B1)
-		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4C1)
-		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
-		#endif			
-		#if defined(TCCR4C) && defined(COM4D1)
-		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
-		#endif			
-			
-		#if defined(TCCR5A)
-		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
-		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
-		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
-		#endif
-	}
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	uint8_t oldSREG = SREG;
-	cli();
-
-	if (val == LOW) {
-		*out &= ~bit;
-	} else {
-		*out |= bit;
-	}
-
-	SREG = oldSREG;
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	return LOW;
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_private.h
deleted file mode 100644
index f678265..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "Arduino.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-#define EXTERNAL_INT_3 3
-#define EXTERNAL_INT_4 4
-#define EXTERNAL_INT_5 5
-#define EXTERNAL_INT_6 6
-#define EXTERNAL_INT_7 7
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define EXTERNAL_NUM_INTERRUPTS 8
-#elif defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644P__)
-#define EXTERNAL_NUM_INTERRUPTS 3
-#elif defined(__AVR_ATmega32U4__)
-#define EXTERNAL_NUM_INTERRUPTS 4
-#else
-#define EXTERNAL_NUM_INTERRUPTS 2
-#endif
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 0d96886..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask) {
-		if (numloops++ == maxloops)
-			return 0;
-		width++;
-	}
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 20 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 21 + 16); 
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_shift.c
deleted file mode 100644
index cfe7867..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
-	uint8_t value = 0;
-	uint8_t i;
-
-	for (i = 0; i < 8; ++i) {
-		digitalWrite(clockPin, HIGH);
-		if (bitOrder == LSBFIRST)
-			value |= digitalRead(dataPin) << i;
-		else
-			value |= digitalRead(dataPin) << (7 - i);
-		digitalWrite(clockPin, LOW);
-	}
-	return value;
-}
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
-{
-	uint8_t i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/ArduinoAddons/Arduino_1.x.x/rambo/variants/standard/pins_arduino.h b/ArduinoAddons/Arduino_1.x.x/rambo/variants/standard/pins_arduino.h
deleted file mode 100644
index f49a23f..0000000
--- a/ArduinoAddons/Arduino_1.x.x/rambo/variants/standard/pins_arduino.h
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NUM_DIGITAL_PINS            82
-#define NUM_ANALOG_INPUTS           16
-#define analogInputToDigitalPin(p)  ((p < 16) ? (p) + 54 : -1)
-#define digitalPinHasPWM(p)         (((p) >= 2 && (p) <= 13) || ((p) >= 44 && (p)<= 46))
-
-static const uint8_t SS   = 53;
-static const uint8_t MOSI = 51;
-static const uint8_t MISO = 50;
-static const uint8_t SCK  = 52;
-
-static const uint8_t SDA = 20;
-static const uint8_t SCL = 21;
-static const uint8_t LED_BUILTIN = 13;
-
-static const uint8_t A0 = 54;
-static const uint8_t A1 = 55;
-static const uint8_t A2 = 56;
-static const uint8_t A3 = 57;
-static const uint8_t A4 = 58;
-static const uint8_t A5 = 59;
-static const uint8_t A6 = 60;
-static const uint8_t A7 = 61;
-static const uint8_t A8 = 62;
-static const uint8_t A9 = 63;
-static const uint8_t A10 = 64;
-static const uint8_t A11 = 65;
-static const uint8_t A12 = 66;
-static const uint8_t A13 = 67;
-static const uint8_t A14 = 68;
-static const uint8_t A15 = 69;
-
-// A majority of the pins are NOT PCINTs, SO BE WARNED (i.e. you cannot use them as receive pins)
-// Only pins available for RECEIVE (TRANSMIT can be on any pin):
-// (I've deliberately left out pin mapping to the Hardware USARTs - seems senseless to me)
-// Pins: 10, 11, 12, 13,  50, 51, 52, 53,  62, 63, 64, 65, 66, 67, 68, 69
-
-#define digitalPinToPCICR(p)    ( (((p) >= 10) && ((p) <= 13)) || \
-                                  (((p) >= 50) && ((p) <= 53)) || \
-                                  (((p) >= 62) && ((p) <= 69)) ? (&PCICR) : ((uint8_t *)0) )
-
-#define digitalPinToPCICRbit(p) ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? 0 : \
-                                ( (((p) >= 62) && ((p) <= 69)) ? 2 : \
-                                0 ) )
-
-#define digitalPinToPCMSK(p)    ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? (&PCMSK0) : \
-                                ( (((p) >= 62) && ((p) <= 69)) ? (&PCMSK2) : \
-                                ((uint8_t *)0) ) )
-
-#define digitalPinToPCMSKbit(p) ( (((p) >= 10) && ((p) <= 13)) ? ((p) - 6) : \
-                                ( ((p) == 50) ? 3 : \
-                                ( ((p) == 51) ? 2 : \
-                                ( ((p) == 52) ? 1 : \
-                                ( ((p) == 53) ? 0 : \
-                                ( (((p) >= 62) && ((p) <= 69)) ? ((p) - 62) : \
-                                0 ) ) ) ) ) )
-
-#ifdef ARDUINO_MAIN
-
-const uint16_t PROGMEM port_to_mode_PGM[] = {
-	NOT_A_PORT,
-	(uint16_t) &DDRA,
-	(uint16_t) &DDRB,
-	(uint16_t) &DDRC,
-	(uint16_t) &DDRD,
-	(uint16_t) &DDRE,
-	(uint16_t) &DDRF,
-	(uint16_t) &DDRG,
-	(uint16_t) &DDRH,
-	NOT_A_PORT,
-	(uint16_t) &DDRJ,
-	(uint16_t) &DDRK,
-	(uint16_t) &DDRL,
-};
-
-const uint16_t PROGMEM port_to_output_PGM[] = {
-	NOT_A_PORT,
-	(uint16_t) &PORTA,
-	(uint16_t) &PORTB,
-	(uint16_t) &PORTC,
-	(uint16_t) &PORTD,
-	(uint16_t) &PORTE,
-	(uint16_t) &PORTF,
-	(uint16_t) &PORTG,
-	(uint16_t) &PORTH,
-	NOT_A_PORT,
-	(uint16_t) &PORTJ,
-	(uint16_t) &PORTK,
-	(uint16_t) &PORTL,
-};
-
-const uint16_t PROGMEM port_to_input_PGM[] = {
-	NOT_A_PIN,
-	(uint16_t) &PINA,
-	(uint16_t) &PINB,
-	(uint16_t) &PINC,
-	(uint16_t) &PIND,
-	(uint16_t) &PINE,
-	(uint16_t) &PINF,
-	(uint16_t) &PING,
-	(uint16_t) &PINH,
-	NOT_A_PIN,
-	(uint16_t) &PINJ,
-	(uint16_t) &PINK,
-	(uint16_t) &PINL,
-};
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] = {
-	// PORTLIST
-	// -------------------------------------------
-	PE	, // PE 0 ** 0 ** USART0_RX
-	PE	, // PE 1 ** 1 ** USART0_TX
-	PE	, // PE 4 ** 2 ** PWM2
-	PE	, // PE 5 ** 3 ** PWM3
-	PG	, // PG 5 ** 4 ** PWM4
-	PE	, // PE 3 ** 5 ** PWM5
-	PH	, // PH 3 ** 6 ** PWM6
-	PH	, // PH 4 ** 7 ** PWM7
-	PH	, // PH 5 ** 8 ** PWM8
-	PH	, // PH 6 ** 9 ** PWM9
-	PB	, // PB 4 ** 10 ** PWM10
-	PB	, // PB 5 ** 11 ** PWM11
-	PB	, // PB 6 ** 12 ** PWM12
-	PB	, // PB 7 ** 13 ** PWM13
-	PJ	, // PJ 1 ** 14 ** USART3_TX
-	PJ	, // PJ 0 ** 15 ** USART3_RX
-	PH	, // PH 1 ** 16 ** USART2_TX
-	PH	, // PH 0 ** 17 ** USART2_RX
-	PD	, // PD 3 ** 18 ** USART1_TX
-	PD	, // PD 2 ** 19 ** USART1_RX
-	PD	, // PD 1 ** 20 ** I2C_SDA
-	PD	, // PD 0 ** 21 ** I2C_SCL
-	PA	, // PA 0 ** 22 ** D22
-	PA	, // PA 1 ** 23 ** D23
-	PA	, // PA 2 ** 24 ** D24
-	PA	, // PA 3 ** 25 ** D25
-	PA	, // PA 4 ** 26 ** D26
-	PA	, // PA 5 ** 27 ** D27
-	PA	, // PA 6 ** 28 ** D28
-	PA	, // PA 7 ** 29 ** D29
-	PC	, // PC 7 ** 30 ** D30
-	PC	, // PC 6 ** 31 ** D31
-	PC	, // PC 5 ** 32 ** D32
-	PC	, // PC 4 ** 33 ** D33
-	PC	, // PC 3 ** 34 ** D34
-	PC	, // PC 2 ** 35 ** D35
-	PC	, // PC 1 ** 36 ** D36
-	PC	, // PC 0 ** 37 ** D37
-	PD	, // PD 7 ** 38 ** D38
-	PG	, // PG 2 ** 39 ** D39
-	PG	, // PG 1 ** 40 ** D40
-	PG	, // PG 0 ** 41 ** D41
-	PL	, // PL 7 ** 42 ** D42
-	PL	, // PL 6 ** 43 ** D43
-	PL	, // PL 5 ** 44 ** D44
-	PL	, // PL 4 ** 45 ** D45
-	PL	, // PL 3 ** 46 ** D46
-	PL	, // PL 2 ** 47 ** D47
-	PL	, // PL 1 ** 48 ** D48
-	PL	, // PL 0 ** 49 ** D49
-	PB	, // PB 3 ** 50 ** SPI_MISO
-	PB	, // PB 2 ** 51 ** SPI_MOSI
-	PB	, // PB 1 ** 52 ** SPI_SCK
-	PB	, // PB 0 ** 53 ** SPI_SS
-	PF	, // PF 0 ** 54 ** A0
-	PF	, // PF 1 ** 55 ** A1
-	PF	, // PF 2 ** 56 ** A2
-	PF	, // PF 3 ** 57 ** A3
-	PF	, // PF 4 ** 58 ** A4
-	PF	, // PF 5 ** 59 ** A5
-	PF	, // PF 6 ** 60 ** A6
-	PF	, // PF 7 ** 61 ** A7
-	PK	, // PK 0 ** 62 ** A8
-	PK	, // PK 1 ** 63 ** A9
-	PK	, // PK 2 ** 64 ** A10
-	PK	, // PK 3 ** 65 ** A11
-	PK	, // PK 4 ** 66 ** A12
-	PK	, // PK 5 ** 67 ** A13
-	PK	, // PK 6 ** 68 ** A14
-	PK	, // PK 7 ** 69 ** A15
-	PG 	, // PG 4 ** 70 ** D70
-	PG 	, // PG 3 ** 71 ** D71
-	PJ 	, // PJ 2 ** 72 ** D72
-	PJ 	, // PJ 3 ** 73 ** D73
-	PJ 	, // PJ 7 ** 74 ** D74
-	PJ 	, // PJ 4 ** 75 ** D75
-	PJ 	, // PJ 5 ** 76 ** D76
-	PJ 	, // PJ 6 ** 77 ** D77
-	PE 	, // PE 2 ** 78 ** D78
-	PE 	, // PE 6 ** 79 ** D79
-	PE 	, // PE 7 ** 80 ** D80
-	PD 	, // PD 4 ** 81 ** D81
-	PD 	, // PD 5 ** 82 ** D82
-	PD 	, // PD 6 ** 83 ** D83
-	PH 	, // PH 2 ** 84 ** D84
-	PH 	, // PH 7 ** 85 ** D85
-};
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {
-	// PIN IN PORT
-	// -------------------------------------------
-	_BV( 0 )	, // PE 0 ** 0 ** USART0_RX
-	_BV( 1 )	, // PE 1 ** 1 ** USART0_TX
-	_BV( 4 )	, // PE 4 ** 2 ** PWM2
-	_BV( 5 )	, // PE 5 ** 3 ** PWM3
-	_BV( 5 )	, // PG 5 ** 4 ** PWM4
-	_BV( 3 )	, // PE 3 ** 5 ** PWM5
-	_BV( 3 )	, // PH 3 ** 6 ** PWM6
-	_BV( 4 )	, // PH 4 ** 7 ** PWM7
-	_BV( 5 )	, // PH 5 ** 8 ** PWM8
-	_BV( 6 )	, // PH 6 ** 9 ** PWM9
-	_BV( 4 )	, // PB 4 ** 10 ** PWM10
-	_BV( 5 )	, // PB 5 ** 11 ** PWM11
-	_BV( 6 )	, // PB 6 ** 12 ** PWM12
-	_BV( 7 )	, // PB 7 ** 13 ** PWM13
-	_BV( 1 )	, // PJ 1 ** 14 ** USART3_TX
-	_BV( 0 )	, // PJ 0 ** 15 ** USART3_RX
-	_BV( 1 )	, // PH 1 ** 16 ** USART2_TX
-	_BV( 0 )	, // PH 0 ** 17 ** USART2_RX
-	_BV( 3 )	, // PD 3 ** 18 ** USART1_TX
-	_BV( 2 )	, // PD 2 ** 19 ** USART1_RX
-	_BV( 1 )	, // PD 1 ** 20 ** I2C_SDA
-	_BV( 0 )	, // PD 0 ** 21 ** I2C_SCL
-	_BV( 0 )	, // PA 0 ** 22 ** D22
-	_BV( 1 )	, // PA 1 ** 23 ** D23
-	_BV( 2 )	, // PA 2 ** 24 ** D24
-	_BV( 3 )	, // PA 3 ** 25 ** D25
-	_BV( 4 )	, // PA 4 ** 26 ** D26
-	_BV( 5 )	, // PA 5 ** 27 ** D27
-	_BV( 6 )	, // PA 6 ** 28 ** D28
-	_BV( 7 )	, // PA 7 ** 29 ** D29
-	_BV( 7 )	, // PC 7 ** 30 ** D30
-	_BV( 6 )	, // PC 6 ** 31 ** D31
-	_BV( 5 )	, // PC 5 ** 32 ** D32
-	_BV( 4 )	, // PC 4 ** 33 ** D33
-	_BV( 3 )	, // PC 3 ** 34 ** D34
-	_BV( 2 )	, // PC 2 ** 35 ** D35
-	_BV( 1 )	, // PC 1 ** 36 ** D36
-	_BV( 0 )	, // PC 0 ** 37 ** D37
-	_BV( 7 )	, // PD 7 ** 38 ** D38
-	_BV( 2 )	, // PG 2 ** 39 ** D39
-	_BV( 1 )	, // PG 1 ** 40 ** D40
-	_BV( 0 )	, // PG 0 ** 41 ** D41
-	_BV( 7 )	, // PL 7 ** 42 ** D42
-	_BV( 6 )	, // PL 6 ** 43 ** D43
-	_BV( 5 )	, // PL 5 ** 44 ** D44
-	_BV( 4 )	, // PL 4 ** 45 ** D45
-	_BV( 3 )	, // PL 3 ** 46 ** D46
-	_BV( 2 )	, // PL 2 ** 47 ** D47
-	_BV( 1 )	, // PL 1 ** 48 ** D48
-	_BV( 0 )	, // PL 0 ** 49 ** D49
-	_BV( 3 )	, // PB 3 ** 50 ** SPI_MISO
-	_BV( 2 )	, // PB 2 ** 51 ** SPI_MOSI
-	_BV( 1 )	, // PB 1 ** 52 ** SPI_SCK
-	_BV( 0 )	, // PB 0 ** 53 ** SPI_SS
-	_BV( 0 )	, // PF 0 ** 54 ** A0
-	_BV( 1 )	, // PF 1 ** 55 ** A1
-	_BV( 2 )	, // PF 2 ** 56 ** A2
-	_BV( 3 )	, // PF 3 ** 57 ** A3
-	_BV( 4 )	, // PF 4 ** 58 ** A4
-	_BV( 5 )	, // PF 5 ** 59 ** A5
-	_BV( 6 )	, // PF 6 ** 60 ** A6
-	_BV( 7 )	, // PF 7 ** 61 ** A7
-	_BV( 0 )	, // PK 0 ** 62 ** A8
-	_BV( 1 )	, // PK 1 ** 63 ** A9
-	_BV( 2 )	, // PK 2 ** 64 ** A10
-	_BV( 3 )	, // PK 3 ** 65 ** A11
-	_BV( 4 )	, // PK 4 ** 66 ** A12
-	_BV( 5 )	, // PK 5 ** 67 ** A13
-	_BV( 6 )	, // PK 6 ** 68 ** A14
-	_BV( 7 )	, // PK 7 ** 69 ** A15
-	_BV( 4 )	, // PG 4 ** 70 ** D70
-	_BV( 3 )	, // PG 3 ** 71 ** D71
-	_BV( 2 )	, // PJ 2 ** 72 ** D72
-	_BV( 3 )	, // PJ 3 ** 73 ** D73
-	_BV( 7 )	, // PJ 7 ** 74 ** D74
-	_BV( 4 )	, // PJ 4 ** 75 ** D75
-	_BV( 5 )	, // PJ 5 ** 76 ** D76
-	_BV( 6 )	, // PJ 6 ** 77 ** D77
-	_BV( 2 )	, // PE 2 ** 78 ** D78
-	_BV( 6 )	, // PE 6 ** 79 ** D79
-	_BV( 7 )	, // PE 7 ** 80 ** D80
-	_BV( 4 )	, // PD 4 ** 81 ** D81
-	_BV( 5 ) 	, // PD 5 ** 82 ** D82
-	_BV( 6 ) 	, // PD 6 ** 83 ** D83
-	_BV( 2 ) 	, // PH 2 ** 84 ** D84
-	_BV( 7 ) 	, // PH 7 ** 85 ** D85
-};
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] = {
-	// TIMERS
-	// -------------------------------------------
-	NOT_ON_TIMER	, // PE 0 ** 0 ** USART0_RX
-	NOT_ON_TIMER	, // PE 1 ** 1 ** USART0_TX
-	TIMER3B		, // PE 4 ** 2 ** PWM2
-	TIMER3C		, // PE 5 ** 3 ** PWM3
-	TIMER0B		, // PG 5 ** 4 ** PWM4
-	TIMER3A		, // PE 3 ** 5 ** PWM5
-	TIMER4A		, // PH 3 ** 6 ** PWM6
-	TIMER4B		, // PH 4 ** 7 ** PWM7
-	TIMER4C		, // PH 5 ** 8 ** PWM8
-	TIMER2B		, // PH 6 ** 9 ** PWM9
-	TIMER2A		, // PB 4 ** 10 ** PWM10
-	TIMER1A		, // PB 5 ** 11 ** PWM11
-	TIMER1B		, // PB 6 ** 12 ** PWM12
-	TIMER0A		, // PB 7 ** 13 ** PWM13
-	NOT_ON_TIMER	, // PJ 1 ** 14 ** USART3_TX
-	NOT_ON_TIMER	, // PJ 0 ** 15 ** USART3_RX
-	NOT_ON_TIMER	, // PH 1 ** 16 ** USART2_TX
-	NOT_ON_TIMER	, // PH 0 ** 17 ** USART2_RX
-	NOT_ON_TIMER	, // PD 3 ** 18 ** USART1_TX
-	NOT_ON_TIMER	, // PD 2 ** 19 ** USART1_RX
-	NOT_ON_TIMER	, // PD 1 ** 20 ** I2C_SDA
-	NOT_ON_TIMER	, // PD 0 ** 21 ** I2C_SCL
-	NOT_ON_TIMER	, // PA 0 ** 22 ** D22
-	NOT_ON_TIMER	, // PA 1 ** 23 ** D23
-	NOT_ON_TIMER	, // PA 2 ** 24 ** D24
-	NOT_ON_TIMER	, // PA 3 ** 25 ** D25
-	NOT_ON_TIMER	, // PA 4 ** 26 ** D26
-	NOT_ON_TIMER	, // PA 5 ** 27 ** D27
-	NOT_ON_TIMER	, // PA 6 ** 28 ** D28
-	NOT_ON_TIMER	, // PA 7 ** 29 ** D29
-	NOT_ON_TIMER	, // PC 7 ** 30 ** D30
-	NOT_ON_TIMER	, // PC 6 ** 31 ** D31
-	NOT_ON_TIMER	, // PC 5 ** 32 ** D32
-	NOT_ON_TIMER	, // PC 4 ** 33 ** D33
-	NOT_ON_TIMER	, // PC 3 ** 34 ** D34
-	NOT_ON_TIMER	, // PC 2 ** 35 ** D35
-	NOT_ON_TIMER	, // PC 1 ** 36 ** D36
-	NOT_ON_TIMER	, // PC 0 ** 37 ** D37
-	NOT_ON_TIMER	, // PD 7 ** 38 ** D38
-	NOT_ON_TIMER	, // PG 2 ** 39 ** D39
-	NOT_ON_TIMER	, // PG 1 ** 40 ** D40
-	NOT_ON_TIMER	, // PG 0 ** 41 ** D41
-	NOT_ON_TIMER	, // PL 7 ** 42 ** D42
-	NOT_ON_TIMER	, // PL 6 ** 43 ** D43
-	TIMER5C		, // PL 5 ** 44 ** D44
-	TIMER5B		, // PL 4 ** 45 ** D45
-	TIMER5A		, // PL 3 ** 46 ** D46
-	NOT_ON_TIMER	, // PL 2 ** 47 ** D47
-	NOT_ON_TIMER	, // PL 1 ** 48 ** D48
-	NOT_ON_TIMER	, // PL 0 ** 49 ** D49
-	NOT_ON_TIMER	, // PB 3 ** 50 ** SPI_MISO
-	NOT_ON_TIMER	, // PB 2 ** 51 ** SPI_MOSI
-	NOT_ON_TIMER	, // PB 1 ** 52 ** SPI_SCK
-	NOT_ON_TIMER	, // PB 0 ** 53 ** SPI_SS
-	NOT_ON_TIMER	, // PF 0 ** 54 ** A0	
-	NOT_ON_TIMER	, // PF 1 ** 55 ** A1	
-	NOT_ON_TIMER	, // PF 2 ** 56 ** A2	
-	NOT_ON_TIMER	, // PF 3 ** 57 ** A3	
-	NOT_ON_TIMER	, // PF 4 ** 58 ** A4	
-	NOT_ON_TIMER	, // PF 5 ** 59 ** A5	
-	NOT_ON_TIMER	, // PF 6 ** 60 ** A6	
-	NOT_ON_TIMER	, // PF 7 ** 61 ** A7	
-	NOT_ON_TIMER	, // PK 0 ** 62 ** A8	
-	NOT_ON_TIMER	, // PK 1 ** 63 ** A9	
-	NOT_ON_TIMER	, // PK 2 ** 64 ** A10	
-	NOT_ON_TIMER	, // PK 3 ** 65 ** A11	
-	NOT_ON_TIMER	, // PK 4 ** 66 ** A12	
-	NOT_ON_TIMER	, // PK 5 ** 67 ** A13	
-	NOT_ON_TIMER	, // PK 6 ** 68 ** A14	
-	NOT_ON_TIMER	, // PK 7 ** 69 ** A15
-	NOT_ON_TIMER	, // PG 4 ** 70 ** D70
-	NOT_ON_TIMER	, // PG 3 ** 71 ** D71
-	NOT_ON_TIMER	, // PJ 2 ** 72 ** D72
-	NOT_ON_TIMER	, // PJ 3 ** 73 ** D73
-	NOT_ON_TIMER	, // PJ 7 ** 74 ** D74
-	NOT_ON_TIMER	, // PJ 4 ** 75 ** D75
-	NOT_ON_TIMER	, // PJ 5 ** 76 ** D76
-	NOT_ON_TIMER	, // PJ 6 ** 77 ** D77
-	NOT_ON_TIMER	, // PE 2 ** 78 ** D78
-	NOT_ON_TIMER	, // PE 6 ** 79 ** D79
-	NOT_ON_TIMER	, // PE 7 ** 80 ** D80
-	NOT_ON_TIMER	, // PD 4 ** 81 ** D81
-	NOT_ON_TIMER 	, // PD 5 ** 82 ** D82
-	NOT_ON_TIMER 	, // PD 6 ** 83 ** D83
-	NOT_ON_TIMER 	, // PH 2 ** 84 ** D84
-	NOT_ON_TIMER 	, // PH 7 ** 85 ** D85
-};
-
-#endif
-
-#endif
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 5d235bc..bf7f38d 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -52,8 +52,10 @@
 // 65 = Azteeg X1
 // 66 = Melzi with ATmega1284 (MaKr3d version)
 // 67 = Azteeg X3
+// 68 = Azteeg X3 Pro
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 72 = Ultimainboard 2.x (Uses TEMP_SENSOR 20)
 // 77 = 3Drag Controller
 // 8  = Teensylu
 // 80 = Rumba
@@ -113,6 +115,7 @@
 // 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
 // 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
 // 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 20 is the PT100 circuit found in the Ultimainboard V2.x
 // 60 is 100k Maker's Tool Works Kapton Bed Thermister
 //
 //    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
@@ -161,6 +164,10 @@
 // HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
 //#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
 
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R
+//#define BED_WATTS (12.0*12.0/1.1)      // P=I^2/R
+
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
@@ -173,7 +180,7 @@
                                   // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
-  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
+  #define PID_dT ((OVERSAMPLENR * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
 
 // If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
@@ -375,12 +382,12 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   // with accurate bed leveling, the bed is sampled in a ACCURATE_BED_LEVELING_POINTSxACCURATE_BED_LEVELING_POINTS grid and least squares solution is calculated
   // Note: this feature occupies 10'206 byte
   #define ACCURATE_BED_LEVELING
-  
+
   #ifdef ACCURATE_BED_LEVELING
      // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
     #define ACCURATE_BED_LEVELING_POINTS 2
   #endif
-  
+
 #endif
 
 
@@ -452,6 +459,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
+//#define LCD_FEEDBACK_FREQUENCY_HZ 1000	// this is the tone frequency the buzzer plays when on UI feedback. ie Screen Click
+//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100 // the duration the buzzer plays the UI feedback sound. ie Screen Click
 
 // The MaKr3d Makr-Panel with graphic controller and SD support
 // http://reprap.org/wiki/MaKr3d_MaKrPanel
@@ -537,6 +546,21 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
   #define NEWPANEL
   #define ULTIPANEL
+
+  #ifndef ENCODER_PULSES_PER_STEP
+	#define ENCODER_PULSES_PER_STEP 4
+  #endif
+
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+	#define ENCODER_STEPS_PER_MENU_ITEM 1
+  #endif
+
+
+  #ifdef LCD_USE_I2C_BUZZER
+	#define LCD_FEEDBACK_FREQUENCY_HZ 1000
+	#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
+  #endif
+
 #endif
 
 // Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 4e5d829..dc986fa 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -12,7 +12,7 @@
 
 //// Heating sanity check:
 // This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
-// If the temperature has not increased at the end of that period, the target temperature is set to zero. 
+// If the temperature has not increased at the end of that period, the target temperature is set to zero.
 // It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
 //  differ by at least 2x WATCH_TEMP_INCREASE
 //#define WATCH_TEMP_PERIOD 40000 //40 seconds
@@ -21,7 +21,7 @@
 #ifdef PIDTEMP
   // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
   // if Kc is choosen well, the additional required power due to increased melting should be compensated.
-  #define PID_ADD_EXTRUSION_RATE  
+  #define PID_ADD_EXTRUSION_RATE
   #ifdef PID_ADD_EXTRUSION_RATE
     #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)
   #endif
@@ -44,10 +44,10 @@
 //The M105 command return, besides traditional information, the ADC value read from temperature sensors.
 //#define SHOW_TEMP_ADC_VALUES
 
-//  extruder run-out prevention. 
+//  extruder run-out prevention.
 //if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
-//#define EXTRUDER_RUNOUT_PREVENT  
-#define EXTRUDER_RUNOUT_MINTEMP 190  
+//#define EXTRUDER_RUNOUT_PREVENT
+#define EXTRUDER_RUNOUT_MINTEMP 190
 #define EXTRUDER_RUNOUT_SECONDS 30.
 #define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
 #define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed
@@ -73,7 +73,7 @@
 // Extruder cooling fans
 // Configure fan pin outputs to automatically turn on/off when the associated
 // extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case 
+// Multiple extruders can be assigned to the same pin in which case
 // the fan will turn on when any selected extruder is above the threshold.
 #define EXTRUDER_0_AUTO_FAN_PIN   -1
 #define EXTRUDER_1_AUTO_FAN_PIN   -1
@@ -103,14 +103,14 @@
     #else
       #define X_HOME_POS X_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else    
+  #else
     #ifdef BED_CENTER_AT_0_0
       #define X_HOME_POS X_MAX_LENGTH * 0.5
     #else
       #define X_HOME_POS X_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //X_HOME_DIR == -1
-  
+
   //Y axis
   #if Y_HOME_DIR == -1
     #ifdef BED_CENTER_AT_0_0
@@ -118,18 +118,18 @@
     #else
       #define Y_HOME_POS Y_MIN_POS
     #endif //BED_CENTER_AT_0_0
-  #else    
+  #else
     #ifdef BED_CENTER_AT_0_0
       #define Y_HOME_POS Y_MAX_LENGTH * 0.5
     #else
       #define Y_HOME_POS Y_MAX_POS
     #endif //BED_CENTER_AT_0_0
   #endif //Y_HOME_DIR == -1
-  
+
   // Z axis
   #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
     #define Z_HOME_POS Z_MIN_POS
-  #else    
+  #else
     #define Z_HOME_POS Z_MAX_POS
   #endif //Z_HOME_DIR == -1
 #endif //End auto min/max positions
@@ -165,7 +165,7 @@
   #error "You cannot have dual drivers for both Y and Z"
 #endif
 
-// Enable this for dual x-carriage printers. 
+// Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
 // allowing faster printing speeds.
@@ -175,10 +175,10 @@
 // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
 // the second x-carriage always homes to the maximum endstop.
 #define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
-#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed 
+#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed
 #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
-#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
-    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software
     // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
     // without modifying the firmware (through the "M218 T1 X???" command).
     // Remember: you should set the second extruder x-offset to 0 in your slicer.
@@ -193,17 +193,17 @@
 //                           as long as it supports dual x-carriages. (M605 S0)
 //    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
 //                           that additional slicer support is not required. (M605 S1)
-//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all  
+//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all
 //                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
 //                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
 
-// This is the default power-up mode which can be later using M605. 
-#define DEFAULT_DUAL_X_CARRIAGE_MODE 0 
+// This is the default power-up mode which can be later using M605.
+#define DEFAULT_DUAL_X_CARRIAGE_MODE 0
 
 // As the x-carriages are independent we can now account for any relative Z offset
 #define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0
 
-// Default settings in "Auto-park Mode" 
+// Default settings in "Auto-park Mode"
 #define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
 #define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
 
@@ -211,11 +211,11 @@
 #define DEFAULT_DUPLICATION_X_OFFSET 100
 
 #endif //DUAL_X_CARRIAGE
-    
+
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
-#define X_HOME_RETRACT_MM 5 
-#define Y_HOME_RETRACT_MM 5 
-#define Z_HOME_RETRACT_MM 1 
+#define X_HOME_RETRACT_MM 5
+#define Y_HOME_RETRACT_MM 5
+#define Z_HOME_RETRACT_MM 1
 //#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
 
 #define AXIS_RELATIVE_MODES {false, false, false, false}
@@ -268,6 +268,12 @@
 // Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
 #define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
 
+// uncomment to enable an I2C based DIGIPOT like on the Azteeg X3 Pro
+//#define DIGIPOT_I2C
+// Number of channels available for I2C digipot, For Azteeg X3 Pro we have 8
+#define DIGIPOT_I2C_NUM_CHANNELS 8
+// actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
+#define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}
 
 //===========================================================================
 //=============================Additional Features===========================
@@ -276,7 +282,7 @@
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
 #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
-#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order. 
+#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order.
 // if a file is deleted, it frees a block. hence, the order is not purely cronological. To still have auto0.g accessible, there is again the option to do that.
 // using:
 //#define MENU_ADDAUTOSTART
@@ -302,7 +308,7 @@
   #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
   #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
   #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
-  
+
   #ifdef COREXY
     #error BABYSTEPPING not implemented for COREXY yet.
   #endif
@@ -340,10 +346,10 @@
 const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
-// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
+// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT
 // in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
 // be commented out otherwise
-#define SDCARDDETECTINVERTED 
+#define SDCARDDETECTINVERTED
 
 #ifdef ULTIPANEL
  #undef SDCARDDETECTINVERTED
@@ -355,12 +361,12 @@ const unsigned int dropsegments=5; //everything with less than this number of st
   #define POWER_SUPPLY 1
 #endif
 // 1 = ATX
-#if (POWER_SUPPLY == 1) 
+#if (POWER_SUPPLY == 1)
   #define PS_ON_AWAKE  LOW
   #define PS_ON_ASLEEP HIGH
 #endif
 // 2 = X-Box 360 203W
-#if (POWER_SUPPLY == 2) 
+#if (POWER_SUPPLY == 2)
   #define PS_ON_AWAKE  HIGH
   #define PS_ON_ASLEEP LOW
 #endif
@@ -372,7 +378,7 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 //=============================Buffers           ============================
 //===========================================================================
 
-// The number of linear motions that can be in the plan at any give time.  
+// The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
 #if defined SDSUPPORT
   #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
@@ -387,9 +393,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 
 
 // Firmware based and LCD controled retract
-// M207 and M208 can be used to define parameters for the retraction. 
+// M207 and M208 can be used to define parameters for the retraction.
 // The retraction can be called by the slicer using G10 and G11
-// until then, intended retractions can be detected by moves that only extrude and the direction. 
+// until then, intended retractions can be detected by moves that only extrude and the direction.
 // the moves are than replaced by the firmware controlled ones.
 
 // #define FWRETRACT  //ONLY PARTIALLY TESTED
@@ -411,9 +417,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 #ifdef FILAMENTCHANGEENABLE
   #ifdef EXTRUDER_RUNOUT_PREVENT
     #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
-  #endif 
+  #endif
 #endif
- 
+
 //===========================================================================
 //=============================  Define Defines  ============================
 //===========================================================================
diff --git a/Marlin/Makefile b/Marlin/Makefile
index 59ec4d4..3bd0ae3 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -14,7 +14,7 @@
 #
 #  1. Modify the line containg "ARDUINO_INSTALL_DIR" to point to the directory that
 #     contains the Arduino installation (for example, under Mac OS X, this
-#     might be /Applications/arduino-0012).
+#     might be /Applications/Arduino.app/Contents/Resources/Java).
 #
 #  2. Modify the line containing "UPLOAD_PORT" to refer to the filename
 #     representing the USB or serial connection to your Arduino board
@@ -40,8 +40,8 @@
 HARDWARE_MOTHERBOARD ?= 11
 
 # Arduino source install directory, and version number
-ARDUINO_INSTALL_DIR  ?= ../../arduino-0022
-ARDUINO_VERSION      ?= 22
+ARDUINO_INSTALL_DIR  ?= /Applications/Arduino.app/Contents/Resources/Java
+ARDUINO_VERSION      ?= 105
 
 # You can optionally set a path to the avr-gcc tools. Requires a trailing slash. (ex: /usr/local/avr-gcc/bin)
 AVR_TOOLS_PATH ?=
@@ -55,7 +55,10 @@ UPLOAD_PORT        ?= /dev/arduino
 BUILD_DIR          ?= applet
 
 # This defines whether Liquid_TWI2 support will be built
-LIQUID_TWI2 ?= 0
+LIQUID_TWI2        ?= 0
+
+# this defines if Wire is needed
+WIRE               ?= 0
 
 ############################################################################
 # Below here nothing should be changed...
@@ -142,6 +145,12 @@ MCU              ?= at90usb1286
 else ifeq  ($(HARDWARE_MOTHERBOARD),82)
 HARDWARE_VARIANT ?= Teensy
 MCU              ?= at90usb646
+else ifeq  ($(HARDWARE_MOTHERBOARD),83)
+HARDWARE_VARIANT ?= Teensy
+MCU              ?= at90usb1286
+else ifeq  ($(HARDWARE_MOTHERBOARD),84)
+HARDWARE_VARIANT ?= Teensy
+MCU              ?= at90usb1286
 
 #Gen3+
 else ifeq  ($(HARDWARE_MOTHERBOARD),9)
@@ -168,6 +177,14 @@ else ifeq  ($(HARDWARE_MOTHERBOARD),301)
 HARDWARE_VARIANT ?= arduino
 MCU              ?= atmega2560
 
+# Azteeg
+else ifeq  ($(HARDWARE_MOTHERBOARD),67)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+else ifeq  ($(HARDWARE_MOTHERBOARD),68)
+HARDWARE_VARIANT ?= arduino
+MCU              ?= atmega2560
+
 endif
 
 # Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
@@ -207,6 +224,10 @@ VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire
 VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire/utility
 VPATH += $(ARDUINO_INSTALL_DIR)/libraries/LiquidTWI2
 endif
+ifeq ($(WIRE), 1)
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire
+VPATH += $(ARDUINO_INSTALL_DIR)/libraries/Wire/utility
+endif
 else
 VPATH += $(HARDWARE_DIR)/libraries/LiquidCrystal
 VPATH += $(HARDWARE_DIR)/libraries/SPI
@@ -215,6 +236,10 @@ VPATH += $(HARDWARE_DIR)/libraries/Wire
 VPATH += $(HARDWARE_DIR)/libraries/Wire/utility
 VPATH += $(HARDWARE_DIR)/libraries/LiquidTWI2
 endif
+ifeq ($(WIRE), 1)
+VPATH += $(HARDWARE_DIR)/libraries/Wire
+VPATH += $(HARDWARE_DIR)/libraries/Wire/utility
+endif
 endif
 ifeq ($(HARDWARE_VARIANT), arduino)
 HARDWARE_SUB_VARIANT ?= mega
@@ -227,11 +252,16 @@ SRC = wiring.c \
 	wiring_analog.c wiring_digital.c \
 	wiring_pulse.c \
 	wiring_shift.c WInterrupts.c
+ifeq ($(HARDWARE_VARIANT), Teensy)
+SRC = wiring.c
+VPATH += $(ARDUINO_INSTALL_DIR)/hardware/teensy/cores/teensy
+endif
 CXXSRC = WMath.cpp WString.cpp Print.cpp Marlin_main.cpp	\
 	MarlinSerial.cpp Sd2Card.cpp SdBaseFile.cpp SdFatUtil.cpp	\
 	SdFile.cpp SdVolume.cpp motion_control.cpp planner.cpp		\
 	stepper.cpp temperature.cpp cardreader.cpp ConfigurationStore.cpp \
-	watchdog.cpp SPI.cpp Servo.cpp Tone.cpp ultralcd.cpp
+	watchdog.cpp SPI.cpp Servo.cpp Tone.cpp ultralcd.cpp digipot_mcp4451.cpp \
+	vector_3.cpp qr_solve.cpp
 ifeq ($(LIQUID_TWI2), 0)
 CXXSRC += LiquidCrystal.cpp
 else
@@ -239,6 +269,11 @@ SRC += twi.c
 CXXSRC += Wire.cpp LiquidTWI2.cpp
 endif
 
+ifeq ($(WIRE), 1)
+SRC += twi.c
+CXXSRC += Wire.cpp
+endif
+
 #Check for Arduino 1.0.0 or higher and use the correct sourcefiles for that version
 ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
 CXXSRC += main.cpp
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 4d6b227..7a4b864 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -204,6 +204,7 @@ extern float homing_feedrate[];
 extern bool axis_relative_modes[];
 extern int feedmultiply;
 extern int extrudemultiply; // Sets extrude multiply factor (in percent)
+extern float volumetric_multiplier[EXTRUDERS]; // reciprocal of cross-sectional area of filament (in square millimeters), stored this way to reduce computational burden in planner
 extern float current_position[NUM_AXIS] ;
 extern float add_homeing[3];
 #ifdef DELTA
@@ -236,4 +237,9 @@ extern unsigned long stoptime;
 // Handling multiple extruders pins
 extern uint8_t active_extruder;
 
+#ifdef DIGIPOT_I2C
+extern void digipot_i2c_set_current( int channel, float current );
+extern void digipot_i2c_init();
+#endif
+
 #endif
diff --git a/Marlin/Marlin.ino b/Marlin/Marlin.ino
index 2d6211c..79c934b 100644
--- a/Marlin/Marlin.ino
+++ b/Marlin/Marlin.ino
@@ -3,17 +3,17 @@
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
+
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
- 
+
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
- 
+
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -22,8 +22,8 @@
  This firmware is a mashup between Sprinter and grbl.
   (https://github.com/kliment/Sprinter)
   (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
+
+ It has preliminary support for Matthew Roberts advance algorithm
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
@@ -50,3 +50,7 @@
 #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
+
+#if defined(DIGIPOT_I2C)
+  #include <Wire.h>
+#endif
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 2d6211c..79c934b 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -3,17 +3,17 @@
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
+
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
- 
+
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
- 
+
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -22,8 +22,8 @@
  This firmware is a mashup between Sprinter and grbl.
   (https://github.com/kliment/Sprinter)
   (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
+
+ It has preliminary support for Matthew Roberts advance algorithm
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
@@ -50,3 +50,7 @@
 #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
+
+#if defined(DIGIPOT_I2C)
+  #include <Wire.h>
+#endif
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index bf13f8e..498adfd 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -130,15 +130,15 @@
 // M150 - Set BlinkM Colour Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
 // M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 //        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
-// M200 - Set filament diameter
+// M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
 // M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 // M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 // M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 // M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
 // M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
 // M206 - set additional homeing offset
-// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+// M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
 // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 // M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 // M220 S<factor in percent>- set speed factor override percentage
@@ -188,6 +188,14 @@ bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
 int feedmultiply=100; //100->1 200->2
 int saved_feedmultiply;
 int extrudemultiply=100; //100->1 200->2
+float volumetric_multiplier[EXTRUDERS] = {1.0
+  #if EXTRUDERS > 1
+    , 1.0
+    #if EXTRUDERS > 2
+      , 1.0
+    #endif
+  #endif
+};
 float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
 float add_homeing[3]={0,0,0};
 #ifdef DELTA
@@ -241,7 +249,7 @@ int EtoPPressure=0;
 float delta[3] = {0.0, 0.0, 0.0};
 #endif
 
-  
+
 //===========================================================================
 //=============================private variables=============================
 //===========================================================================
@@ -484,6 +492,10 @@ void setup()
   #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
     SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
   #endif
+
+  #ifdef DIGIPOT_I2C
+    digipot_i2c_init();
+  #endif
 }
 
 
@@ -781,7 +793,7 @@ static unsigned long delayed_move_time = 0; // used in mode 1
 static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
 static float duplicate_extruder_temp_offset = 0; // used in mode 2
 bool extruder_duplication_enabled = false; // used in mode 2
-#endif //DUAL_X_CARRIAGE    
+#endif //DUAL_X_CARRIAGE
 
 static void axis_is_at_home(int axis) {
 #ifdef DUAL_X_CARRIAGE
@@ -794,8 +806,8 @@ static void axis_is_at_home(int axis) {
     }
     else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
       current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];
-      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS]; 
-      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS], 
+      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS];
+      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS],
                                   max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
       return;
     }
@@ -887,7 +899,7 @@ static void run_z_probe() {
     st_synchronize();
 
     // move back down slowly to find bed
-    feedrate = homing_feedrate[Z_AXIS]/4; 
+    feedrate = homing_feedrate[Z_AXIS]/4;
     zPosition -= home_retract_mm(Z_AXIS) * 2;
     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
@@ -966,6 +978,28 @@ static void retract_z_probe() {
     #endif
 }
 
+/// Probe bed height at position (x,y), returns the measured z value
+static float probe_pt(float x, float y, float z_before) {
+  // move to right place
+  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_before);
+  do_blocking_move_to(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
+
+  engage_z_probe();   // Engage Z Servo endstop if available
+  run_z_probe();
+  float measured_z = current_position[Z_AXIS];
+  retract_z_probe();
+
+  SERIAL_PROTOCOLPGM(MSG_BED);
+  SERIAL_PROTOCOLPGM(" x: ");
+  SERIAL_PROTOCOL(x);
+  SERIAL_PROTOCOLPGM(" y: ");
+  SERIAL_PROTOCOL(y);
+  SERIAL_PROTOCOLPGM(" z: ");
+  SERIAL_PROTOCOL(measured_z);
+  SERIAL_PROTOCOLPGM("\n");
+  return measured_z;
+}
+
 #endif // #ifdef ENABLE_AUTO_BED_LEVELING
 
 static void homeaxis(int axis) {
@@ -984,7 +1018,7 @@ static void homeaxis(int axis) {
 
     current_position[axis] = 0;
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-	
+
 
     // Engage Servo endstop if enabled
     #ifdef SERVO_ENDSTOPS
@@ -1042,7 +1076,7 @@ static void homeaxis(int axis) {
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
     if (axis==Z_AXIS) retract_z_probe();
 #endif
-    
+
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
@@ -1105,11 +1139,15 @@ void process_commands()
         destination[X_AXIS]=current_position[X_AXIS];
         destination[Y_AXIS]=current_position[Y_AXIS];
         destination[Z_AXIS]=current_position[Z_AXIS];
-        current_position[Z_AXIS]+=-retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]-retract_length;
+        current_position[Z_AXIS]-=retract_zlift;
+        destination[E_AXIS]=current_position[E_AXIS];
+        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
+        plan_set_e_position(current_position[E_AXIS]);
+        float oldFeedrate = feedrate;
         feedrate=retract_feedrate;
         retracted=true;
         prepare_move();
+        feedrate = oldFeedrate;
       }
 
       break;
@@ -1120,10 +1158,14 @@ void process_commands()
         destination[Y_AXIS]=current_position[Y_AXIS];
         destination[Z_AXIS]=current_position[Z_AXIS];
         current_position[Z_AXIS]+=retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]+retract_length+retract_recover_length; 
+        destination[E_AXIS]=current_position[E_AXIS];
+        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
+        plan_set_e_position(current_position[E_AXIS]);
+        float oldFeedrate = feedrate;
         feedrate=retract_recover_feedrate;
         retracted=false;
         prepare_move();
+        feedrate = oldFeedrate;
       }
       break;
       #endif //FWRETRACT
@@ -1234,10 +1276,10 @@ void process_commands()
         // reset state used by the different modes
         memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
         delayed_move_time = 0;
-        active_extruder_parked = true; 
-      #else      
+        active_extruder_parked = true;
+      #else
         HOMEAXIS(X);
-      #endif         
+      #endif
       }
 
       if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
@@ -1256,7 +1298,7 @@ void process_commands()
           current_position[Y_AXIS]=code_value()+add_homeing[1];
         }
       }
-      
+
       #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
         #ifndef Z_SAFE_HOMING
           if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
@@ -1268,14 +1310,14 @@ void process_commands()
             #endif
             HOMEAXIS(Z);
           }
-        #else                      // Z Safe mode activated. 
+        #else                      // Z Safe mode activated.
           if(home_all_axis) {
             destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
             feedrate = XY_TRAVEL_SPEED;
             current_position[Z_AXIS] = 0;
-			
+
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
             plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
             st_synchronize();
@@ -1293,7 +1335,7 @@ void process_commands()
               && (current_position[Y_AXIS]+Y_PROBE_OFFSET_FROM_EXTRUDER <= Y_MAX_POS)) {
 
               current_position[Z_AXIS] = 0;
-              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);			  
+              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
               destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
               feedrate = max_feedrate[Z_AXIS];
               plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
@@ -1313,8 +1355,8 @@ void process_commands()
         #endif
       #endif
 
-      
-     
+
+
       if(code_seen(axis_codes[Z_AXIS])) {
         if(code_value_long() != 0) {
           current_position[Z_AXIS]=code_value()+add_homeing[2];
@@ -1360,26 +1402,26 @@ void process_commands()
 
             feedrate = homing_feedrate[Z_AXIS];
 #ifdef ACCURATE_BED_LEVELING
-            
+
             int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
             int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
-            
-            
+
+
             // solve the plane equation ax + by + d = z
             // A is the matrix with rows [x y 1] for all the probed points
             // B is the vector of the Z positions
             // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
             // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
-            
+
             // "A" matrix of the linear system of equations
             double eqnAMatrix[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS*3];
             // "B" vector of Z points
             double eqnBVector[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS];
-            
-            
+
+
             int probePointCounter = 0;
             bool zig = true;
-            
+
             for (int yProbe=FRONT_PROBE_BED_POSITION; yProbe <= BACK_PROBE_BED_POSITION; yProbe += yGridSpacing)
             {
               int xProbe, xInc;
@@ -1396,35 +1438,24 @@ void process_commands()
                 xInc = -xGridSpacing;
                 zig = true;
               }
-              
+
               for (int xCount=0; xCount < ACCURATE_BED_LEVELING_POINTS; xCount++)
               {
+                float z_before;
                 if (probePointCounter == 0)
                 {
                   // raise before probing
-                  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
+                  z_before = Z_RAISE_BEFORE_PROBING;
                 } else
-                {               
+                {
                   // raise extruder
-                  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+                  z_before = current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS;
                 }
-                
-                
-                do_blocking_move_to(xProbe - X_PROBE_OFFSET_FROM_EXTRUDER, yProbe - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
-    
-                engage_z_probe();   // Engage Z Servo endstop if available
-                run_z_probe();
-                eqnBVector[probePointCounter] = current_position[Z_AXIS];
-                retract_z_probe();
-    
-                SERIAL_PROTOCOLPGM("Bed x: ");
-                SERIAL_PROTOCOL(xProbe);
-                SERIAL_PROTOCOLPGM(" y: ");
-                SERIAL_PROTOCOL(yProbe);
-                SERIAL_PROTOCOLPGM(" z: ");
-                SERIAL_PROTOCOL(current_position[Z_AXIS]);
-                SERIAL_PROTOCOLPGM("\n");
-                
+
+                float measured_z = probe_pt(xProbe, yProbe, z_before);
+
+                eqnBVector[probePointCounter] = measured_z;
+
                 eqnAMatrix[probePointCounter + 0*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = xProbe;
                 eqnAMatrix[probePointCounter + 1*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = yProbe;
                 eqnAMatrix[probePointCounter + 2*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = 1;
@@ -1433,87 +1464,44 @@ void process_commands()
               }
             }
             clean_up_after_endstop_move();
-            
+
             // solve lsq problem
             double *plane_equation_coefficients = qr_solve(ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS, 3, eqnAMatrix, eqnBVector);
-            
+
             SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[0]);
             SERIAL_PROTOCOLPGM(" b: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[1]);
             SERIAL_PROTOCOLPGM(" d: ");
             SERIAL_PROTOCOLLN(plane_equation_coefficients[2]);
-            
-            
+
+
             set_bed_level_equation_lsq(plane_equation_coefficients);
-            
+
             free(plane_equation_coefficients);
-            
+
 #else // ACCURATE_BED_LEVELING not defined
-            
-            
-            // prob 1
-            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
-            do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, BACK_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
 
-            engage_z_probe();   // Engage Z Servo endstop if available
-            run_z_probe();
-            float z_at_xLeft_yBack = current_position[Z_AXIS];
-            retract_z_probe();
-
-            SERIAL_PROTOCOLPGM("Bed x: ");
-            SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" y: ");
-            SERIAL_PROTOCOL(BACK_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" z: ");
-            SERIAL_PROTOCOL(current_position[Z_AXIS]);
-            SERIAL_PROTOCOLPGM("\n");
 
-            // prob 2
-            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
-            do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, FRONT_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
+            // prob 1
+            float z_at_xLeft_yBack = probe_pt(LEFT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION, Z_RAISE_BEFORE_PROBING);
 
-            engage_z_probe();   // Engage Z Servo endstop if available
-            run_z_probe();
-            float z_at_xLeft_yFront = current_position[Z_AXIS];
-            retract_z_probe();
-            
-            SERIAL_PROTOCOLPGM("Bed x: ");
-            SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" y: ");
-            SERIAL_PROTOCOL(FRONT_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" z: ");
-            SERIAL_PROTOCOL(current_position[Z_AXIS]);
-            SERIAL_PROTOCOLPGM("\n");
+            // prob 2
+            float z_at_xLeft_yFront = probe_pt(LEFT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
 
             // prob 3
-            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
-            // the current position will be updated by the blocking move so the head will not lower on this next call.
-            do_blocking_move_to(RIGHT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, FRONT_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
-
-            engage_z_probe();   // Engage Z Servo endstop if available
-            run_z_probe();
-            float z_at_xRight_yFront = current_position[Z_AXIS];
-            retract_z_probe(); // Retract Z Servo endstop if available
-            
-            SERIAL_PROTOCOLPGM("Bed x: ");
-            SERIAL_PROTOCOL(RIGHT_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" y: ");
-            SERIAL_PROTOCOL(FRONT_PROBE_BED_POSITION);
-            SERIAL_PROTOCOLPGM(" z: ");
-            SERIAL_PROTOCOL(current_position[Z_AXIS]);
-            SERIAL_PROTOCOLPGM("\n");
+            float z_at_xRight_yFront = probe_pt(RIGHT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
 
             clean_up_after_endstop_move();
 
             set_bed_level_equation(z_at_xLeft_yFront, z_at_xRight_yFront, z_at_xLeft_yBack);
-         
-            
+
+
 #endif // ACCURATE_BED_LEVELING
-            st_synchronize();            
+            st_synchronize();
 
             // The following code correct the Z height difference from z-probe position and hotend tip position.
-            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend. 
+            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend.
             // When the bed is uneven, this height must be corrected.
             real_z = float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS];  //get the real Z (since the auto bed leveling is already correcting the plane)
             x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER;
@@ -1525,11 +1513,11 @@ void process_commands()
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         }
         break;
-        
+
     case 30: // G30 Single Z Probe
         {
             engage_z_probe(); // Engage Z Servo endstop if available
-            
+
             st_synchronize();
             // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
             setup_for_endstop_move();
@@ -1537,7 +1525,8 @@ void process_commands()
             feedrate = homing_feedrate[Z_AXIS];
 
             run_z_probe();
-            SERIAL_PROTOCOLPGM("Bed Position X: ");
+            SERIAL_PROTOCOLPGM(MSG_BED);
+            SERIAL_PROTOCOLPGM(" X: ");
             SERIAL_PROTOCOL(current_position[X_AXIS]);
             SERIAL_PROTOCOLPGM(" Y: ");
             SERIAL_PROTOCOL(current_position[Y_AXIS]);
@@ -1680,14 +1669,14 @@ void process_commands()
         card.removeFile(strchr_pointer + 4);
       }
       break;
-    case 32: //M32 - Select file and start SD print 
+    case 32: //M32 - Select file and start SD print
     {
       if(card.sdprinting) {
         st_synchronize();
 
       }
-      starpos = (strchr(strchr_pointer + 4,'*')); 
-      
+      starpos = (strchr(strchr_pointer + 4,'*'));
+
       char* namestartpos = (strchr(strchr_pointer + 4,'!'));   //find ! to indicate filename string start.
       if(namestartpos==NULL)
       {
@@ -1695,16 +1684,16 @@ void process_commands()
       }
       else
         namestartpos++; //to skip the '!'
-        
+
       if(starpos!=NULL)
         *(starpos-1)='\0';
-            
+
       bool call_procedure=(code_seen('P'));
-      
-      if(strchr_pointer>namestartpos) 
+
+      if(strchr_pointer>namestartpos)
         call_procedure=false;  //false alert, 'P' found within filename
-      
-      if( card.cardOK ) 
+
+      if( card.cardOK )
       {
         card.openFile(namestartpos,true,!call_procedure);
         if(code_seen('S'))
@@ -1777,7 +1766,7 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
         setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
       setWatch();
       break;
     case 140: // M140 set bed temp
@@ -1812,10 +1801,20 @@ void process_commands()
       #endif
 
         SERIAL_PROTOCOLPGM(" @:");
+      #ifdef EXTRUDER_WATTS
+        SERIAL_PROTOCOL((EXTRUDER_WATTS * getHeaterPower(tmp_extruder))/127);
+        SERIAL_PROTOCOLPGM("W");
+      #else
         SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));
+      #endif
 
         SERIAL_PROTOCOLPGM(" B@:");
+      #ifdef BED_WATTS
+        SERIAL_PROTOCOL((BED_WATTS * getHeaterPower(-1))/127);
+        SERIAL_PROTOCOLPGM("W");
+      #else
         SERIAL_PROTOCOL(getHeaterPower(-1));
+      #endif
 
         #ifdef SHOW_TEMP_ADC_VALUES
           #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
@@ -1833,7 +1832,7 @@ void process_commands()
             SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);
           }
         #endif
-		
+
         SERIAL_PROTOCOLLN("");
       return;
       break;
@@ -1851,14 +1850,14 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = true;
       } else if (code_seen('R')) {
         setTargetHotend(code_value(), tmp_extruder);
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = false;
       }
       #ifdef AUTOTEMP
@@ -2022,7 +2021,7 @@ void process_commands()
             SET_OUTPUT(SUICIDE_PIN);
             WRITE(SUICIDE_PIN, HIGH);
         #endif
-        
+
         #ifdef ULTIPANEL
           powersupply = true;
           LCD_MESSAGEPGM(WELCOME_MSG);
@@ -2179,21 +2178,49 @@ void process_commands()
       #endif
       break;
       //TODO: update for all axis, use for loop
-    #ifdef BLINKM  
+    #ifdef BLINKM
     case 150: // M150
       {
         byte red;
         byte grn;
         byte blu;
-        
+
         if(code_seen('R')) red = code_value();
         if(code_seen('U')) grn = code_value();
         if(code_seen('B')) blu = code_value();
-        
-        SendColors(red,grn,blu);        
+
+        SendColors(red,grn,blu);
       }
       break;
     #endif //BLINKM
+    case 200: // M200 D<millimeters> set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
+      {
+        float area = .0;
+        float radius = .0;
+        if(code_seen('D')) {
+          radius = (float)code_value() * .5;
+          if(radius == 0) {
+            area = 1;
+          } else {
+            area = M_PI * pow(radius, 2);
+          }
+        } else {
+          //reserved for setting filament diameter via UFID or filament measuring device
+          break;
+        }
+        tmp_extruder = active_extruder;
+        if(code_seen('T')) {
+          tmp_extruder = code_value();
+          if(tmp_extruder >= EXTRUDERS) {
+            SERIAL_ECHO_START;
+            SERIAL_ECHO(MSG_M200_INVALID_EXTRUDER);
+          }
+          SERIAL_ECHOLN(tmp_extruder);
+          break;
+        }
+        volumetric_multiplier[tmp_extruder] = 1 / area;
+      }
+      break;
     case 201: // M201
       for(int8_t i=0; i < NUM_AXIS; i++)
       {
@@ -2312,7 +2339,7 @@ void process_commands()
       {
         extruder_offset[Z_AXIS][tmp_extruder] = code_value();
       }
-      #endif       
+      #endif
       SERIAL_ECHO_START;
       SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
       for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++)
@@ -2345,17 +2372,17 @@ void process_commands()
       }
     }
     break;
-	
+
 	case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
 	{
       if(code_seen('P')){
         int pin_number = code_value(); // pin number
         int pin_state = -1; // required pin state - default is inverted
-        
+
         if(code_seen('S')) pin_state = code_value(); // required pin state
-      
+
         if(pin_state >= -1 && pin_state <= 1){
-        
+
           for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
           {
             if (sensitive_pins[i] == pin_number)
@@ -2364,28 +2391,28 @@ void process_commands()
               break;
             }
           }
-        
+
           if (pin_number > -1)
           {
             st_synchronize();
-            
+
             pinMode(pin_number, INPUT);
-            
+
             int target;
             switch(pin_state){
             case 1:
               target = HIGH;
               break;
-            
+
             case 0:
               target = LOW;
               break;
-            
+
             case -1:
               target = !digitalRead(pin_number);
               break;
             }
-            
+
             while(digitalRead(pin_number) != target){
               manage_heater();
               manage_inactivity();
@@ -2395,7 +2422,7 @@ void process_commands()
         }
       }
     }
-    break;	
+    break;
 
     #if NUM_SERVOS > 0
     case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
@@ -2435,7 +2462,7 @@ void process_commands()
       break;
     #endif // NUM_SERVOS > 0
 
-    #if LARGE_FLASH == true && ( BEEPER > 0 || defined(ULTRALCD) )
+    #if (LARGE_FLASH == true && ( BEEPER > 0 || defined(ULTRALCD) || defined(LCD_USE_I2C_BUZZER)))
     case 300: // M300
     {
       int beepS = code_seen('S') ? code_value() : 110;
@@ -2447,7 +2474,9 @@ void process_commands()
           delay(beepP);
           noTone(BEEPER);
         #elif defined(ULTRALCD)
-          lcd_buzz(beepS, beepP);
+		  lcd_buzz(beepS, beepP);
+		#elif defined(LCD_USE_I2C_BUZZER)
+		  lcd_buzz(beepP, beepS);
         #endif
       }
       else
@@ -2571,13 +2600,13 @@ void process_commands()
         engage_z_probe();    // Engage Z Servo endstop if available
     }
     break;
-    
+
     case 402:
     {
         retract_z_probe();    // Retract Z Servo endstop if enabled
     }
     break;
-#endif    
+#endif
     case 500: // M500 Store settings in EEPROM
     {
         Config_StoreSettings();
@@ -2705,7 +2734,11 @@ void process_commands()
             WRITE(BEEPER,LOW);
             delay(3);
           #else
-            lcd_buzz(1000/6,100);
+			#if !defined(LCD_FEEDBACK_FREQUENCY_HZ) || !defined(LCD_FEEDBACK_FREQUENCY_DURATION_MS)
+              lcd_buzz(1000/6,100);
+			#else
+			  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS,LCD_FEEDBACK_FREQUENCY_HZ);
+			#endif
           #endif
           }
         }
@@ -2735,14 +2768,14 @@ void process_commands()
               //    M605 S0: Full control mode. The slicer has full control over x-carriage movement
               //    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
               //    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
-              //                         millimeters x-offset and an optional differential hotend temperature of 
+              //                         millimeters x-offset and an optional differential hotend temperature of
               //                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
               //                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
               //
               //    Note: the X axis should be homed after changing dual x-carriage mode.
     {
         st_synchronize();
-        
+
         if (code_seen('S'))
           dual_x_carriage_mode = code_value();
 
@@ -2753,7 +2786,7 @@ void process_commands()
 
           if (code_seen('R'))
             duplicate_extruder_temp_offset = code_value();
-            
+
           SERIAL_ECHO_START;
           SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
           SERIAL_ECHO(" ");
@@ -2769,13 +2802,13 @@ void process_commands()
         {
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
         }
-        
+
         active_extruder_parked = false;
         extruder_duplication_enabled = false;
         delayed_move_time = 0;
     }
     break;
-    #endif //DUAL_X_CARRIAGE         
+    #endif //DUAL_X_CARRIAGE
 
     case 907: // M907 Set digital trimpot motor current using axis codes.
     {
@@ -2793,6 +2826,12 @@ void process_commands()
       #ifdef MOTOR_CURRENT_PWM_E_PIN
         if(code_seen('E')) digipot_current(2, code_value());
       #endif
+      #ifdef DIGIPOT_I2C
+        // this one uses actual amps in floating point
+        for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());
+        // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
+        for(int i=NUM_AXIS;i<DIGIPOT_I2C_NUM_CHANNELS;i++) if(code_seen('B'+i-NUM_AXIS)) digipot_i2c_set_current(i, code_value());
+      #endif
     }
     break;
     case 908: // M908 Control digital trimpot directly.
@@ -2865,19 +2904,19 @@ void process_commands()
         // Save current position to return to after applying extruder offset
         memcpy(destination, current_position, sizeof(destination));
       #ifdef DUAL_X_CARRIAGE
-        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false && 
+        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
             (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
         {
           // Park old head: 1) raise 2) move to park position 3) lower
-          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS], 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
           st_synchronize();
         }
-        
+
         // apply Y & Z extruder offset (x offset is already used in determining home pos)
         current_position[Y_AXIS] = current_position[Y_AXIS] -
                      extruder_offset[Y_AXIS][active_extruder] +
@@ -2885,7 +2924,7 @@ void process_commands()
         current_position[Z_AXIS] = current_position[Z_AXIS] -
                      extruder_offset[Z_AXIS][active_extruder] +
                      extruder_offset[Z_AXIS][tmp_extruder];
-                     
+
         active_extruder = tmp_extruder;
 
         // This function resets the max/min values - the current position may be overwritten below.
@@ -2893,18 +2932,18 @@ void process_commands()
 
         if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)
         {
-          current_position[X_AXIS] = inactive_extruder_x_pos; 
+          current_position[X_AXIS] = inactive_extruder_x_pos;
           inactive_extruder_x_pos = destination[X_AXIS];
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
         {
           active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
           if (active_extruder == 0 || active_extruder_parked)
-            current_position[X_AXIS] = inactive_extruder_x_pos; 
+            current_position[X_AXIS] = inactive_extruder_x_pos;
           else
-            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset; 
+            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
           inactive_extruder_x_pos = destination[X_AXIS];
-          extruder_duplication_enabled = false; 
+          extruder_duplication_enabled = false;
         }
         else
         {
@@ -2914,7 +2953,7 @@ void process_commands()
           active_extruder_parked = true;
           delayed_move_time = 0;
         }
-      #else    
+      #else
         // Offset extruder (only by XY)
         int i;
         for(i = 0; i < 2; i++) {
@@ -3127,13 +3166,13 @@ void prepare_move()
     {
       // move duplicate extruder into correct duplication position.
       plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[X_AXIS], 1);
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
       st_synchronize();
       extruder_duplication_enabled = true;
       active_extruder_parked = false;
-    }  
+    }
     else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head
     {
       if (current_position[E_AXIS] == destination[E_AXIS])
@@ -3142,7 +3181,7 @@ void prepare_move()
         // be used as start of first non-travel move)
         if (delayed_move_time != 0xFFFFFFFFUL)
         {
-          memcpy(current_position, destination, sizeof(current_position)); 
+          memcpy(current_position, destination, sizeof(current_position));
           if (destination[Z_AXIS] > raised_parked_position[Z_AXIS])
             raised_parked_position[Z_AXIS] = destination[Z_AXIS];
           delayed_move_time = millis();
@@ -3152,9 +3191,9 @@ void prepare_move()
       delayed_move_time = 0;
       // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
       plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS],
           current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
       active_extruder_parked = false;
     }
@@ -3302,8 +3341,8 @@ void manage_inactivity()
      enable_e0();
      float oldepos=current_position[E_AXIS];
      float oldedes=destination[E_AXIS];
-     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], 
-                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
+                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                       EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
      current_position[E_AXIS]=oldepos;
      destination[E_AXIS]=oldedes;
@@ -3320,7 +3359,7 @@ void manage_inactivity()
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       memcpy(destination,current_position,sizeof(destination));
-      prepare_move(); 
+      prepare_move();
     }
   #endif
   #ifdef TEMP_STAT_LEDS
diff --git a/Marlin/createTemperatureLookupMarlin.py b/Marlin/createTemperatureLookupMarlin.py
old mode 100644
new mode 100755
index e09294e..77187b8
--- a/Marlin/createTemperatureLookupMarlin.py
+++ b/Marlin/createTemperatureLookupMarlin.py
@@ -54,9 +54,25 @@ class Thermistor:
         self.c2 = c2
         self.c3 = c3
 
+    def res(self,adc):
+        "Convert ADC reading into a resolution"
+        res = self.temp(adc)-self.temp(adc+1)
+        return res
+
+    def v(self,adc):
+        "Convert ADC reading into a Voltage"
+        v = adc * self.vadc / (1024 )   # convert the 10 bit ADC value to a voltage
+        return v
+
+    def r(self,adc):
+        "Convert ADC reading into a resistance in Ohms"
+        v = adc * self.vadc / (1024 )   # convert the 10 bit ADC value to a voltage
+        r = self.rp * v / (self.vcc - v)    # resistance of thermistor
+        return r
+
     def temp(self,adc):
         "Convert ADC reading into a temperature in Celcius"
-        v = adc * self.vadc / (1024 * 16)   # convert the 10 bit ADC value to a voltage
+        v = adc * self.vadc / (1024 )   # convert the 10 bit ADC value to a voltage
         r = self.rp * v / (self.vcc - v)    # resistance of thermistor
         lnr = log(r)
         Tinv = self.c1 + (self.c2*lnr) + (self.c3*pow(lnr,3))
@@ -67,7 +83,7 @@ class Thermistor:
         y = (self.c1 - (1/(temp+273.15))) / (2*self.c3)
 	x = sqrt(pow(self.c2 / (3*self.c3),3) + pow(y,2))
         r = exp(pow(x-y,1.0/3) - pow(x+y,1.0/3)) # resistance of thermistor
-        return (r / (self.rp + r)) * (1024*16)
+        return (r / (self.rp + r)) * (1024)
 
 def main(argv):
 
@@ -107,7 +123,7 @@ def main(argv):
         elif opt == "--num-temps":
             num_temps =  int(arg)
 
-    max_adc = (1024 * 16) - 1
+    max_adc = (1024 ) - 1
     min_temp = 0
     max_temp = 350
     increment = int(max_adc/(num_temps-1));
@@ -118,17 +134,18 @@ def main(argv):
     temps = range(max_temp, min_temp + tmp, tmp);
 
     print "// Thermistor lookup table for Marlin"
-    print "// ./createTemperatureLookup.py --rp=%s --t1=%s:%s --t2=%s:%s --t3=%s:%s --num-temps=%s" % (rp, t1, r1, t2, r2, t3, r3, num_temps)
-    print "#define NUMTEMPS %s" % (len(temps))
-    print "short temptable[NUMTEMPS][2] = {"
+    print "// ./createTemperatureLookupMarlin.py --rp=%s --t1=%s:%s --t2=%s:%s --t3=%s:%s --num-temps=%s" % (rp, t1, r1, t2, r2, t3, r3, num_temps)
+    print "// Steinhart-Hart Coefficients: %.15g, %.15g,  %.15g " % (t.c1, t.c2, t.c3)
+    print "//#define NUMTEMPS %s" % (len(temps))
+    print "const short temptable[NUMTEMPS][2] PROGMEM = {"
 
     counter = 0
     for temp in temps:
         counter = counter +1
         if counter == len(temps):
-            print "   {%s, %s}" % (int(t.adc(temp)), temp)
+            print "   {(short)(%.2f*OVERSAMPLENR), %s}  // v=%s r=%s res=%s C/count" % ((t.adc(temp)), temp, t.v(t.adc(temp)), t.r(t.adc(temp)),t.res(t.adc(temp)))
         else:
-            print "   {%s, %s}," % (int(t.adc(temp)), temp)
+            print "   {(short)(%.2f*OVERSAMPLENR), %s}, // v=%s r=%s res=%s C/count" % ((t.adc(temp)), temp, t.v(t.adc(temp)), t.r(t.adc(temp)),t.res(t.adc(temp)))
     print "};"
     
 def usage():
diff --git a/Marlin/digipot_mcp4451.cpp b/Marlin/digipot_mcp4451.cpp
new file mode 100644
index 0000000..11ee684
--- /dev/null
+++ b/Marlin/digipot_mcp4451.cpp
@@ -0,0 +1,54 @@
+#include "Configuration.h"
+
+#ifdef DIGIPOT_I2C
+#include "Stream.h"
+#include "utility/twi.h"
+#include "Wire.h"
+
+// Settings for the I2C based DIGIPOT (MCP4451) on Azteeg X3 Pro
+#define DIGIPOT_I2C_FACTOR 106.7
+#define DIGIPOT_I2C_MAX_CURRENT 2.5
+
+static byte current_to_wiper( float current ){
+    return byte(ceil(float((DIGIPOT_I2C_FACTOR*current))));
+}
+
+static void i2c_send(byte addr, byte a, byte b)
+{
+	Wire.beginTransmission(addr);
+    Wire.write(a);
+    Wire.write(b);
+    Wire.endTransmission();
+}
+
+// This is for the MCP4451 I2C based digipot
+void digipot_i2c_set_current( int channel, float current )
+{
+    current = min( (float) max( current, 0.0f ), DIGIPOT_I2C_MAX_CURRENT);
+    // these addresses are specific to Azteeg X3 Pro, can be set to others,
+    // In this case first digipot is at address A0=0, A1= 0, second one is at A0=0, A1= 1
+    byte addr= 0x2C; // channel 0-3
+    if(channel >= 4) {
+    	addr= 0x2E; // channel 4-7
+    	channel-= 4;
+    }
+
+    // Initial setup
+    i2c_send( addr, 0x40, 0xff );
+    i2c_send( addr, 0xA0, 0xff );
+
+    // Set actual wiper value
+    byte addresses[4] = { 0x00, 0x10, 0x60, 0x70 };
+    i2c_send( addr, addresses[channel], current_to_wiper(current) );
+}
+
+void digipot_i2c_init()
+{
+    const float digipot_motor_current[] = DIGIPOT_I2C_MOTOR_CURRENTS;
+    Wire.begin();
+    // setup initial currents as defined in Configuration_adv.h
+    for(int i=0;i<=sizeof(digipot_motor_current)/sizeof(float);i++) {
+        digipot_i2c_set_current(i, digipot_motor_current[i]);
+    }
+}
+#endif
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index f26a9f8..a969d56 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -2035,6 +2035,10 @@ pins
 /*
 pins
 */
+
+//#define AT90USBxx_TEENSYPP_ASSIGNMENTS // Use Teensy++ 2.0 assignments 
+#ifndef AT90USBxx_TEENSYPP_ASSIGNMENTS // Use traditional Marlin pin assignments
+
 #define DIO0_PIN        PINA0
 #define DIO0_RPORT      PINA
 #define DIO0_WPORT      PORTA
@@ -2667,7 +2671,653 @@ pins
 #define PF7_WPORT		PORTF
 #define PF7_PWM			NULL
 #define PF7_DDR			DDRF
-#endif
+
+#else // AT90USBxx_TEENSYPP_ASSIGNMENTS -- Use Teensyduino Teensy++2.0 assignments.
+
+/*
+
+AT90USB  51 50 49 48 47 46 45 44 10 11 12 13 14 15 16 17 35 36 37 38 39 40 41 42 25 26 27 28 29 30 31 32 33 34 43 09 18 19 01 02 61 60 59 58 57 56 55 54 
+Port     A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 C0 C1 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7 E0 E1 E2 E3 E4 E5 E6 E7 F0 F1 F2 F3 F4 F5 F6 F7 
+Marlin   00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
+Teensy   28 29 30 31 32 33 34 35 20 21 22 23 24 25 26 27 10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07 08 09(46*47)36 37 18 19 38 39 40 41 42 43 44 45
+         The pins 46 and 47 are not supported by Teensyduino, but are supported below.
+*/
+
+#define DIO0_PIN PIND0
+#define DIO0_RPORT PIND
+#define DIO0_WPORT PORTD
+#define DIO0_PWM NULL
+#define DIO0_DDR DDRD
+
+#define DIO1_PIN PIND1
+#define DIO1_RPORT PIND
+#define DIO1_WPORT PORTD
+#define DIO1_PWM NULL
+#define DIO1_DDR DDRD
+
+#define DIO2_PIN PIND2
+#define DIO2_RPORT PIND
+#define DIO2_WPORT PORTD
+#define DIO2_PWM NULL
+#define DIO2_DDR DDRD
+
+#define DIO3_PIN PIND3
+#define DIO3_RPORT PIND
+#define DIO3_WPORT PORTD
+#define DIO3_PWM NULL
+#define DIO3_DDR DDRD
+
+#define DIO4_PIN PIND4
+#define DIO4_RPORT PIND
+#define DIO4_WPORT PORTD
+#define DIO4_PWM NULL
+#define DIO4_DDR DDRD
+
+#define DIO5_PIN PIND5
+#define DIO5_RPORT PIND
+#define DIO5_WPORT PORTD
+#define DIO5_PWM NULL
+#define DIO5_DDR DDRD
+
+#define DIO6_PIN PIND6
+#define DIO6_RPORT PIND
+#define DIO6_WPORT PORTD
+#define DIO6_PWM NULL
+#define DIO6_DDR DDRD
+
+#define DIO7_PIN PIND7
+#define DIO7_RPORT PIND
+#define DIO7_WPORT PORTD
+#define DIO7_PWM NULL
+#define DIO7_DDR DDRD
+
+#define DIO8_PIN PINE0
+#define DIO8_RPORT PINE
+#define DIO8_WPORT PORTE
+#define DIO8_PWM NULL
+#define DIO8_DDR DDRE
+
+#define DIO9_PIN PINE1
+#define DIO9_RPORT PINE
+#define DIO9_WPORT PORTE
+#define DIO9_PWM NULL
+#define DIO9_DDR DDRE
+
+#define DIO10_PIN PINC0
+#define DIO10_RPORT PINC
+#define DIO10_WPORT PORTC
+#define DIO10_PWM NULL
+#define DIO10_DDR DDRC
+
+#define DIO11_PIN PINC1
+#define DIO11_RPORT PINC
+#define DIO11_WPORT PORTC
+#define DIO11_PWM NULL
+#define DIO11_DDR DDRC
+
+#define DIO12_PIN PINC2
+#define DIO12_RPORT PINC
+#define DIO12_WPORT PORTC
+#define DIO12_PWM NULL
+#define DIO12_DDR DDRC
+
+#define DIO13_PIN PINC3
+#define DIO13_RPORT PINC
+#define DIO13_WPORT PORTC
+#define DIO13_PWM NULL
+#define DIO13_DDR DDRC
+
+#define DIO14_PIN PINC4
+#define DIO14_RPORT PINC
+#define DIO14_WPORT PORTC
+#define DIO14_PWM NULL
+#define DIO14_DDR DDRC
+
+#define DIO15_PIN PINC5
+#define DIO15_RPORT PINC
+#define DIO15_WPORT PORTC
+#define DIO15_PWM NULL
+#define DIO15_DDR DDRC
+
+#define DIO16_PIN PINC6
+#define DIO16_RPORT PINC
+#define DIO16_WPORT PORTC
+#define DIO16_PWM NULL
+#define DIO16_DDR DDRC
+
+#define DIO17_PIN PINC7
+#define DIO17_RPORT PINC
+#define DIO17_WPORT PORTC
+#define DIO17_PWM NULL
+#define DIO17_DDR DDRC
+
+#define DIO18_PIN PINE6
+#define DIO18_RPORT PINE
+#define DIO18_WPORT PORTE
+#define DIO18_PWM NULL
+#define DIO18_DDR DDRE
+
+#define DIO19_PIN PINE7
+#define DIO19_RPORT PINE
+#define DIO19_WPORT PORTE
+#define DIO19_PWM NULL
+#define DIO19_DDR DDRE
+
+#define DIO20_PIN PINB0
+#define DIO20_RPORT PINB
+#define DIO20_WPORT PORTB
+#define DIO20_PWM NULL
+#define DIO20_DDR DDRB
+
+#define DIO21_PIN PINB1
+#define DIO21_RPORT PINB
+#define DIO21_WPORT PORTB
+#define DIO21_PWM NULL
+#define DIO21_DDR DDRB
+
+#define DIO22_PIN PINB2
+#define DIO22_RPORT PINB
+#define DIO22_WPORT PORTB
+#define DIO22_PWM NULL
+#define DIO22_DDR DDRB
+
+#define DIO23_PIN PINB3
+#define DIO23_RPORT PINB
+#define DIO23_WPORT PORTB
+#define DIO23_PWM NULL
+#define DIO23_DDR DDRB
+
+#define DIO24_PIN PINB4
+#define DIO24_RPORT PINB
+#define DIO24_WPORT PORTB
+#define DIO24_PWM NULL
+#define DIO24_DDR DDRB
+
+#define DIO25_PIN PINB5
+#define DIO25_RPORT PINB
+#define DIO25_WPORT PORTB
+#define DIO25_PWM NULL
+#define DIO25_DDR DDRB
+
+#define DIO26_PIN PINB6
+#define DIO26_RPORT PINB
+#define DIO26_WPORT PORTB
+#define DIO26_PWM NULL
+#define DIO26_DDR DDRB
+
+#define DIO27_PIN PINB7
+#define DIO27_RPORT PINB
+#define DIO27_WPORT PORTB
+#define DIO27_PWM NULL
+#define DIO27_DDR DDRB
+
+#define DIO28_PIN PINA0
+#define DIO28_RPORT PINA
+#define DIO28_WPORT PORTA
+#define DIO28_PWM NULL
+#define DIO28_DDR DDRA
+
+#define DIO29_PIN PINA1
+#define DIO29_RPORT PINA
+#define DIO29_WPORT PORTA
+#define DIO29_PWM NULL
+#define DIO29_DDR DDRA
+
+#define DIO30_PIN PINA2
+#define DIO30_RPORT PINA
+#define DIO30_WPORT PORTA
+#define DIO30_PWM NULL
+#define DIO30_DDR DDRA
+
+#define DIO31_PIN PINA3
+#define DIO31_RPORT PINA
+#define DIO31_WPORT PORTA
+#define DIO31_PWM NULL
+#define DIO31_DDR DDRA
+
+#define DIO32_PIN PINA4
+#define DIO32_RPORT PINA
+#define DIO32_WPORT PORTA
+#define DIO32_PWM NULL
+#define DIO32_DDR DDRA
+
+#define DIO33_PIN PINA5
+#define DIO33_RPORT PINA
+#define DIO33_WPORT PORTA
+#define DIO33_PWM NULL
+#define DIO33_DDR DDRA
+
+#define DIO34_PIN PINA6
+#define DIO34_RPORT PINA
+#define DIO34_WPORT PORTA
+#define DIO34_PWM NULL
+#define DIO34_DDR DDRA
+
+#define DIO35_PIN PINA7
+#define DIO35_RPORT PINA
+#define DIO35_WPORT PORTA
+#define DIO35_PWM NULL
+#define DIO35_DDR DDRA
+
+#define DIO36_PIN PINE4
+#define DIO36_RPORT PINE
+#define DIO36_WPORT PORTE
+#define DIO36_PWM NULL
+#define DIO36_DDR DDRE
+
+#define DIO37_PIN PINE5
+#define DIO37_RPORT PINE
+#define DIO37_WPORT PORTE
+#define DIO37_PWM NULL
+#define DIO37_DDR DDRE
+
+#define DIO38_PIN PINF0
+#define DIO38_RPORT PINF
+#define DIO38_WPORT PORTF
+#define DIO38_PWM NULL
+#define DIO38_DDR DDRF
+
+#define DIO39_PIN PINF1
+#define DIO39_RPORT PINF
+#define DIO39_WPORT PORTF
+#define DIO39_PWM NULL
+#define DIO39_DDR DDRF
+
+#define DIO40_PIN PINF2
+#define DIO40_RPORT PINF
+#define DIO40_WPORT PORTF
+#define DIO40_PWM NULL
+#define DIO40_DDR DDRF
+
+#define DIO41_PIN PINF3
+#define DIO41_RPORT PINF
+#define DIO41_WPORT PORTF
+#define DIO41_PWM NULL
+#define DIO41_DDR DDRF
+
+#define DIO42_PIN PINF4
+#define DIO42_RPORT PINF
+#define DIO42_WPORT PORTF
+#define DIO42_PWM NULL
+#define DIO42_DDR DDRF
+
+#define DIO43_PIN PINF5
+#define DIO43_RPORT PINF
+#define DIO43_WPORT PORTF
+#define DIO43_PWM NULL
+#define DIO43_DDR DDRF
+
+#define DIO44_PIN PINF6
+#define DIO44_RPORT PINF
+#define DIO44_WPORT PORTF
+#define DIO44_PWM NULL
+#define DIO44_DDR DDRF
+
+#define DIO45_PIN PINF7
+#define DIO45_RPORT PINF
+#define DIO45_WPORT PORTF
+#define DIO45_PWM NULL
+#define DIO45_DDR DDRF
+
+#define AIO0_PIN PINF0
+#define AIO0_RPORT PINF
+#define AIO0_WPORT PORTF
+#define AIO0_PWM NULL
+#define AIO0_DDR DDRF
+
+#define AIO1_PIN PINF1
+#define AIO1_RPORT PINF
+#define AIO1_WPORT PORTF
+#define AIO1_PWM NULL
+#define AIO1_DDR DDRF
+
+#define AIO2_PIN PINF2
+#define AIO2_RPORT PINF
+#define AIO2_WPORT PORTF
+#define AIO2_PWM NULL
+#define AIO2_DDR DDRF
+
+#define AIO3_PIN PINF3
+#define AIO3_RPORT PINF
+#define AIO3_WPORT PORTF
+#define AIO3_PWM NULL
+#define AIO3_DDR DDRF
+
+#define AIO4_PIN PINF4
+#define AIO4_RPORT PINF
+#define AIO4_WPORT PORTF
+#define AIO4_PWM NULL
+#define AIO4_DDR DDRF
+
+#define AIO5_PIN PINF5
+#define AIO5_RPORT PINF
+#define AIO5_WPORT PORTF
+#define AIO5_PWM NULL
+#define AIO5_DDR DDRF
+
+#define AIO6_PIN PINF6
+#define AIO6_RPORT PINF
+#define AIO6_WPORT PORTF
+#define AIO6_PWM NULL
+#define AIO6_DDR DDRF
+
+#define AIO7_PIN PINF7
+#define AIO7_RPORT PINF
+#define AIO7_WPORT PORTF
+#define AIO7_PWM NULL
+#define AIO7_DDR DDRF
+
+//-- Begin not supported by Teensyduino
+//-- don't use Arduino functions on these pins pinMode/digitalWrite/etc
+#define DIO46_PIN PINE2
+#define DIO46_RPORT PINE
+#define DIO46_WPORT PORTE
+#define DIO46_PWM NULL
+#define DIO46_DDR DDRE
+
+#define DIO47_PIN PINE3
+#define DIO47_RPORT PINE
+#define DIO47_WPORT PORTE
+#define DIO47_PWM NULL
+#define DIO47_DDR DDRE
+//-- end not supported by Teensyduino
+
+#undef PA0
+#define PA0_PIN PINA0
+#define PA0_RPORT PINA
+#define PA0_WPORT PORTA
+#define PA0_PWM NULL
+#define PA0_DDR DDRA
+#undef PA1
+#define PA1_PIN PINA1
+#define PA1_RPORT PINA
+#define PA1_WPORT PORTA
+#define PA1_PWM NULL
+#define PA1_DDR DDRA
+#undef PA2
+#define PA2_PIN PINA2
+#define PA2_RPORT PINA
+#define PA2_WPORT PORTA
+#define PA2_PWM NULL
+#define PA2_DDR DDRA
+#undef PA3
+#define PA3_PIN PINA3
+#define PA3_RPORT PINA
+#define PA3_WPORT PORTA
+#define PA3_PWM NULL
+#define PA3_DDR DDRA
+#undef PA4
+#define PA4_PIN PINA4
+#define PA4_RPORT PINA
+#define PA4_WPORT PORTA
+#define PA4_PWM NULL
+#define PA4_DDR DDRA
+#undef PA5
+#define PA5_PIN PINA5
+#define PA5_RPORT PINA
+#define PA5_WPORT PORTA
+#define PA5_PWM NULL
+#define PA5_DDR DDRA
+#undef PA6
+#define PA6_PIN PINA6
+#define PA6_RPORT PINA
+#define PA6_WPORT PORTA
+#define PA6_PWM NULL
+#define PA6_DDR DDRA
+#undef PA7
+#define PA7_PIN PINA7
+#define PA7_RPORT PINA
+#define PA7_WPORT PORTA
+#define PA7_PWM NULL
+#define PA7_DDR DDRA
+
+#undef PB0
+#define PB0_PIN PINB0
+#define PB0_RPORT PINB
+#define PB0_WPORT PORTB
+#define PB0_PWM NULL
+#define PB0_DDR DDRB
+#undef PB1
+#define PB1_PIN PINB1
+#define PB1_RPORT PINB
+#define PB1_WPORT PORTB
+#define PB1_PWM NULL
+#define PB1_DDR DDRB
+#undef PB2
+#define PB2_PIN PINB2
+#define PB2_RPORT PINB
+#define PB2_WPORT PORTB
+#define PB2_PWM NULL
+#define PB2_DDR DDRB
+#undef PB3
+#define PB3_PIN PINB3
+#define PB3_RPORT PINB
+#define PB3_WPORT PORTB
+#define PB3_PWM NULL
+#define PB3_DDR DDRB
+#undef PB4
+#define PB4_PIN PINB4
+#define PB4_RPORT PINB
+#define PB4_WPORT PORTB
+#define PB4_PWM NULL
+#define PB4_DDR DDRB
+#undef PB5
+#define PB5_PIN PINB5
+#define PB5_RPORT PINB
+#define PB5_WPORT PORTB
+#define PB5_PWM NULL
+#define PB5_DDR DDRB
+#undef PB6
+#define PB6_PIN PINB6
+#define PB6_RPORT PINB
+#define PB6_WPORT PORTB
+#define PB6_PWM NULL
+#define PB6_DDR DDRB
+#undef PB7
+#define PB7_PIN PINB7
+#define PB7_RPORT PINB
+#define PB7_WPORT PORTB
+#define PB7_PWM NULL
+#define PB7_DDR DDRB
+
+#undef PC0
+#define PC0_PIN PINC0
+#define PC0_RPORT PINC
+#define PC0_WPORT PORTC
+#define PC0_PWM NULL
+#define PC0_DDR DDRC
+#undef PC1
+#define PC1_PIN PINC1
+#define PC1_RPORT PINC
+#define PC1_WPORT PORTC
+#define PC1_PWM NULL
+#define PC1_DDR DDRC
+#undef PC2
+#define PC2_PIN PINC2
+#define PC2_RPORT PINC
+#define PC2_WPORT PORTC
+#define PC2_PWM NULL
+#define PC2_DDR DDRC
+#undef PC3
+#define PC3_PIN PINC3
+#define PC3_RPORT PINC
+#define PC3_WPORT PORTC
+#define PC3_PWM NULL
+#define PC3_DDR DDRC
+#undef PC4
+#define PC4_PIN PINC4
+#define PC4_RPORT PINC
+#define PC4_WPORT PORTC
+#define PC4_PWM NULL
+#define PC4_DDR DDRC
+#undef PC5
+#define PC5_PIN PINC5
+#define PC5_RPORT PINC
+#define PC5_WPORT PORTC
+#define PC5_PWM NULL
+#define PC5_DDR DDRC
+#undef PC6
+#define PC6_PIN PINC6
+#define PC6_RPORT PINC
+#define PC6_WPORT PORTC
+#define PC6_PWM NULL
+#define PC6_DDR DDRC
+#undef PC7
+#define PC7_PIN PINC7
+#define PC7_RPORT PINC
+#define PC7_WPORT PORTC
+#define PC7_PWM NULL
+#define PC7_DDR DDRC
+
+#undef PD0
+#define PD0_PIN PIND0
+#define PD0_RPORT PIND
+#define PD0_WPORT PORTD
+#define PD0_PWM NULL
+#define PD0_DDR DDRD
+#undef PD1
+#define PD1_PIN PIND1
+#define PD1_RPORT PIND
+#define PD1_WPORT PORTD
+#define PD1_PWM NULL
+#define PD1_DDR DDRD
+#undef PD2
+#define PD2_PIN PIND2
+#define PD2_RPORT PIND
+#define PD2_WPORT PORTD
+#define PD2_PWM NULL
+#define PD2_DDR DDRD
+#undef PD3
+#define PD3_PIN PIND3
+#define PD3_RPORT PIND
+#define PD3_WPORT PORTD
+#define PD3_PWM NULL
+#define PD3_DDR DDRD
+#undef PD4
+#define PD4_PIN PIND4
+#define PD4_RPORT PIND
+#define PD4_WPORT PORTD
+#define PD4_PWM NULL
+#define PD4_DDR DDRD
+#undef PD5
+#define PD5_PIN PIND5
+#define PD5_RPORT PIND
+#define PD5_WPORT PORTD
+#define PD5_PWM NULL
+#define PD5_DDR DDRD
+#undef PD6
+#define PD6_PIN PIND6
+#define PD6_RPORT PIND
+#define PD6_WPORT PORTD
+#define PD6_PWM NULL
+#define PD6_DDR DDRD
+#undef PD7
+#define PD7_PIN PIND7
+#define PD7_RPORT PIND
+#define PD7_WPORT PORTD
+#define PD7_PWM NULL
+#define PD7_DDR DDRD
+
+#undef PE0
+#define PE0_PIN PINE0
+#define PE0_RPORT PINE
+#define PE0_WPORT PORTE
+#define PE0_PWM NULL
+#define PE0_DDR DDRE
+#undef PE1
+#define PE1_PIN PINE1
+#define PE1_RPORT PINE
+#define PE1_WPORT PORTE
+#define PE1_PWM NULL
+#define PE1_DDR DDRE
+#undef PE2
+#define PE2_PIN PINE2
+#define PE2_RPORT PINE
+#define PE2_WPORT PORTE
+#define PE2_PWM NULL
+#define PE2_DDR DDRE
+#undef PE3
+#define PE3_PIN PINE3
+#define PE3_RPORT PINE
+#define PE3_WPORT PORTE
+#define PE3_PWM NULL
+#define PE3_DDR DDRE
+#undef PE4
+#define PE4_PIN PINE4
+#define PE4_RPORT PINE
+#define PE4_WPORT PORTE
+#define PE4_PWM NULL
+#define PE4_DDR DDRE
+#undef PE5
+#define PE5_PIN PINE5
+#define PE5_RPORT PINE
+#define PE5_WPORT PORTE
+#define PE5_PWM NULL
+#define PE5_DDR DDRE
+#undef PE6
+#define PE6_PIN PINE6
+#define PE6_RPORT PINE
+#define PE6_WPORT PORTE
+#define PE6_PWM NULL
+#define PE6_DDR DDRE
+#undef PE7
+#define PE7_PIN PINE7
+#define PE7_RPORT PINE
+#define PE7_WPORT PORTE
+#define PE7_PWM NULL
+#define PE7_DDR DDRE
+
+#undef PF0
+#define PF0_PIN PINF0
+#define PF0_RPORT PINF
+#define PF0_WPORT PORTF
+#define PF0_PWM NULL
+#define PF0_DDR DDRF
+#undef PF1
+#define PF1_PIN PINF1
+#define PF1_RPORT PINF
+#define PF1_WPORT PORTF
+#define PF1_PWM NULL
+#define PF1_DDR DDRF
+#undef PF2
+#define PF2_PIN PINF2
+#define PF2_RPORT PINF
+#define PF2_WPORT PORTF
+#define PF2_PWM NULL
+#define PF2_DDR DDRF
+#undef PF3
+#define PF3_PIN PINF3
+#define PF3_RPORT PINF
+#define PF3_WPORT PORTF
+#define PF3_PWM NULL
+#define PF3_DDR DDRF
+#undef PF4
+#define PF4_PIN PINF4
+#define PF4_RPORT PINF
+#define PF4_WPORT PORTF
+#define PF4_PWM NULL
+#define PF4_DDR DDRF
+#undef PF5
+#define PF5_PIN PINF5
+#define PF5_RPORT PINF
+#define PF5_WPORT PORTF
+#define PF5_PWM NULL
+#define PF5_DDR DDRF
+#undef PF6
+#define PF6_PIN PINF6
+#define PF6_RPORT PINF
+#define PF6_WPORT PORTF
+#define PF6_PWM NULL
+#define PF6_DDR DDRF
+#undef PF7
+#define PF7_PIN PINF7
+#define PF7_RPORT PINF
+#define PF7_WPORT PORTF
+#define PF7_PWM NULL
+#define PF7_DDR DDRF
+
+#endif // AT90USBxx_TEENSYPP_ASSIGNMENTS Teensyduino assignments
+#endif // __AVR_AT90usbxxx__
 
 
 #if defined (__AVR_ATmega1281__) || defined (__AVR_ATmega2561__)
diff --git a/Marlin/language.h b/Marlin/language.h
index 52b1b16..2126f7f 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -16,9 +16,10 @@
 // 7  Italian
 // 8  Portuguese
 // 9  Finnish
+// 10 Aragonese
 
 #ifndef LANGUAGE_CHOICE
-#define LANGUAGE_CHOICE 1  // Pick your language from the list above
+	#define LANGUAGE_CHOICE 1  // Pick your language from the list above
 #endif
 
 #define PROTOCOL_VERSION "1.0"
@@ -39,37 +40,58 @@
 		#define MACHINE_NAME "Mendel"
 	#endif
 
-	#define FIRMWARE_URL "http://www.mendel-parts.com"
+// Default firmware set to Mendel	
+	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
 #endif
 
+
 #ifndef MACHINE_UUID
    #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
 #endif
 
+
 #define STRINGIFY_(n) #n
 #define STRINGIFY(n) STRINGIFY_(n)
 
+
+// Common LCD messages
+/* nothing here as of yet */
+
+// Common serial messages
+#define MSG_MARLIN "Marlin"
+
+
+
 #if LANGUAGE_CHOICE == 1
 
 // LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Ready."
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " ready."
 	#define MSG_SD_INSERTED "Card inserted"
 	#define MSG_SD_REMOVED "Card removed"
 	#define MSG_MAIN "Main"
 	#define MSG_AUTOSTART "Autostart"
-	#define MSG_DISABLE_STEPPERS "Disable Steppers"
-	#define MSG_AUTO_HOME "Auto Home"
-	#define MSG_SET_ORIGIN "Set Origin"
+	#define MSG_DISABLE_STEPPERS "Disable steppers"
+	#define MSG_AUTO_HOME "Auto home"
+	#define MSG_SET_ORIGIN "Set origin"
 	#define MSG_PREHEAT_PLA "Preheat PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA conf"
 	#define MSG_PREHEAT_ABS "Preheat ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS conf"
 	#define MSG_COOLDOWN "Cooldown"
-	#define MSG_SWITCH_PS_ON "Switch Power On"
-	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_SWITCH_PS_ON "Switch power on"
+	#define MSG_SWITCH_PS_OFF "Switch power off"
 	#define MSG_EXTRUDE "Extrude"
 	#define MSG_RETRACT "Retract"
-	#define MSG_MOVE_AXIS "Move Axis"
+	#define MSG_MOVE_AXIS "Move axis"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
 	#define MSG_SPEED "Speed"
 	#define MSG_NOZZLE "Nozzle"
 	#define MSG_NOZZLE1 "Nozzle2"
@@ -111,16 +133,16 @@
 	#define MSG_CONTRAST "LCD contrast"
 	#define MSG_STORE_EPROM "Store memory"
 	#define MSG_LOAD_EPROM "Load memory"
-	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
+	#define MSG_RESTORE_FAILSAFE "Restore failsafe"
 	#define MSG_REFRESH "Refresh"
 	#define MSG_WATCH "Info screen"
 	#define MSG_PREPARE "Prepare"
 	#define MSG_TUNE "Tune"
-	#define MSG_PAUSE_PRINT "Pause Print"
-	#define MSG_RESUME_PRINT "Resume Print"
-	#define MSG_STOP_PRINT "Stop Print"
+	#define MSG_PAUSE_PRINT "Pause print"
+	#define MSG_RESUME_PRINT "Resume print"
+	#define MSG_STOP_PRINT "Stop print"
 	#define MSG_CARD_MENU "Print from SD"
-	#define MSG_NO_CARD "No Card"
+	#define MSG_NO_CARD "No SD card"
 	#define MSG_DWELL "Sleep..."
 	#define MSG_USERWAIT "Wait for user..."
 	#define MSG_RESUMING "Resuming print"
@@ -134,11 +156,16 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
+	#define MSG_INIT_SDCARD "Init. SD card"	
+	#define MSG_CNG_SDCARD "Change SD card"
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
     #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+
 // Serial Console Messages
 
 	#define MSG_Enqueing "enqueing \""
@@ -147,7 +174,6 @@
 	#define MSG_BROWNOUT_RESET " Brown out Reset"
 	#define MSG_WATCHDOG_RESET " Watchdog Reset"
 	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Author: "
 	#define MSG_CONFIGURATION_VER " Last Updated: "
 	#define MSG_FREE_MEMORY " Free Memory: "
@@ -163,6 +189,7 @@
 	#define MSG_END_FILE_LIST "End file list"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Invalid extruder "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
 	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
@@ -209,35 +236,49 @@
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
 
 
 #if LANGUAGE_CHOICE == 2
 
+
 // LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Gotowe."
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " gotowy."
 	#define MSG_SD_INSERTED "Karta wlozona"
 	#define MSG_SD_REMOVED "Karta usunieta"
-	#define MSG_MAIN "Main"
+	#define MSG_MAIN "Menu glowne"
 	#define MSG_AUTOSTART "Autostart"
 	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
 	#define MSG_AUTO_HOME "Auto. poz. zerowa"
-	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
+	#define MSG_SET_ORIGIN "Ustaw punkt zero"
 	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Ustaw. rozg. PLA"
 	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Ustaw. rozg. ABS"
 	#define MSG_COOLDOWN "Chlodzenie"
-	#define MSG_SWITCH_PS_ON "Switch Power On"
-	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_SWITCH_PS_ON "Wlacz zasilacz"
+	#define MSG_SWITCH_PS_OFF "Wylacz zasilacz"
 	#define MSG_EXTRUDE "Ekstruzja"
 	#define MSG_RETRACT "Cofanie"
 	#define MSG_MOVE_AXIS "Ruch osi"
+	#define MSG_MOVE_X "Przesun w X"
+	#define MSG_MOVE_Y "Przesun w Y"
+	#define MSG_MOVE_Z "Przesun w Z"
+	#define MSG_MOVE_E "Ekstruzja (os E)"
+	#define MSG_MOVE_01MM "Przesuwaj co .1mm"
+	#define MSG_MOVE_1MM "Przesuwaj co 1mm"
+	#define MSG_MOVE_10MM "Przesuwaj co 10mm"
 	#define MSG_SPEED "Predkosc"
 	#define MSG_NOZZLE "Dysza"
-	#define MSG_NOZZLE1 "Dysza2"
-	#define MSG_NOZZLE2 "Dysza3"
+	#define MSG_NOZZLE1 "Dysza 2"
+	#define MSG_NOZZLE2 "Dysza 3"
 	#define MSG_BED "Loze"
 	#define MSG_FAN_SPEED "Obroty wiatraka"
 	#define MSG_FLOW "Przeplyw"
@@ -245,14 +286,14 @@
 	#define MSG_MIN " \002 Min"
 	#define MSG_MAX " \002 Max"
 	#define MSG_FACTOR " \002 Mnoznik"
-	#define MSG_AUTOTEMP "Auto. temp."
+	#define MSG_AUTOTEMP "Auto. temperatura"
 	#define MSG_ON "Wl. "
 	#define MSG_OFF "Wyl."
 	#define MSG_PID_P "PID-P"
 	#define MSG_PID_I "PID-I"
 	#define MSG_PID_D "PID-D"
 	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Acc"
+	#define MSG_ACC  "Przyspieszenie"
 	#define MSG_VXY_JERK "Zryw Vxy"
 	#define MSG_VZ_JERK "Zryw Vz"
 	#define MSG_VE_JERK "Zryw Ve"
@@ -272,25 +313,24 @@
 	#define MSG_RECTRACT "Wycofanie"
 	#define MSG_TEMPERATURE "Temperatura"
 	#define MSG_MOTION "Ruch"
-	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_CONTRAST "Kontrast LCD"
 	#define MSG_STORE_EPROM "Zapisz w pamieci"
 	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
-	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_RESTORE_FAILSAFE "Ustaw. fabryczne"
 	#define MSG_REFRESH "\004Odswiez"
-	#define MSG_WATCH "Obserwuj"
+	#define MSG_WATCH "Ekran glowny"
 	#define MSG_PREPARE "Przygotuj"
-	#define MSG_CONTROL "Kontroluj"
+	#define MSG_CONTROL "Ustawienia"
 	#define MSG_TUNE "Strojenie"
 	#define MSG_PAUSE_PRINT "Pauza"
 	#define MSG_RESUME_PRINT "Wznowienie"
 	#define MSG_STOP_PRINT "Stop"
-	#define MSG_CARD_MENU "Menu SDCard"
+	#define MSG_CARD_MENU "Menu karty SD"
 	#define MSG_NO_CARD "Brak karty"
 	#define MSG_DWELL "Uspij..."
-	#define MSG_USERWAIT "Czekaj na uzytkownika..."
-	#define MSG_RESUMING "Wznawiam drukowanie"
-	#define MSG_NO_MOVE "Brak ruchu."
-	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
+	#define MSG_USERWAIT "Oczekiwanie..."
+	#define MSG_RESUMING "Wznawianie druku"
+	#define MSG_NO_MOVE "Brak ruchu"
 	#define MSG_KILLED "Ubity. "
 	#define MSG_STOPPED "Zatrzymany. "
 	#define MSG_STEPPER_RELEASED "Zwolniony."
@@ -300,12 +340,17 @@
 	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
 	#define MSG_AUTORETRACT "Auto. wycofanie"
-	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_FILAMENTCHANGE "Zmien filament"
+	#define MSG_INIT_SDCARD "Inicjal. karty SD"
+	#define MSG_CNG_SDCARD "Zmiana karty SD"
+    #define MSG_ZPROBE_OUT "Sonda Z za lozem"
+    #define MSG_POSITION_UNKNOWN "Wroc w XY przed Z"
+    #define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Blad wyl. kranc."
+	#define MSG_CONTRAST "Kontrast"
 
 // Serial Console Messages
 
@@ -315,12 +360,11 @@
 	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
 	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
 	#define MSG_SOFTWARE_RESET " Reset (programowy)"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Autor: "
 	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
 	#define MSG_FREE_MEMORY " Wolna pamiec: "
 	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
-	#define MSG_OK "ok"
+	#define MSG_OK "OK"
 	#define MSG_FILE_SAVED "Plik zapisany."
 	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
 	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
@@ -331,6 +375,7 @@
 	#define MSG_END_FILE_LIST "Koniec listy plikow"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Niepoprawny ekstruder "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
 	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
 	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
@@ -339,7 +384,7 @@
 	#define MSG_BED_HEATING "Nagrzewanie loza..."
 	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
 	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Liczenie X: "
+	#define MSG_COUNT_X " Licznik X: "
 	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
 	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
 	#define MSG_RESEND "Wyslij ponownie: "
@@ -353,9 +398,9 @@
 	#define MSG_Z_MIN "z_min: "
 	#define MSG_Z_MAX "z_max: "
 	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
-	#define MSG_ENDSTOP_HIT "WYZWOLONY"
-	#define MSG_ENDSTOP_OPEN "otwarty"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+	#define MSG_ENDSTOP_HIT "Wyzwolony"
+	#define MSG_ENDSTOP_OPEN "Otwarty"
+	#define MSG_HOTEND_OFFSET "Offsety dysz:"
 
 	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
 	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
@@ -370,19 +415,26 @@
 	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
 	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
 	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Wystapil blad podczas zapisu do pliku"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
 
 	#define MSG_STEPPER_TOO_HIGH "Za duza czestotliwosc krokow: "
 	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
+	#define MSG_BABYSTEPPING_X "Babystepping w osi X"
+	#define MSG_BABYSTEPPING_Y "Babystepping w osi Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping w osi Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
 
 
 #if LANGUAGE_CHOICE == 3
 
+// LCD Menu Messages
+// Please note these are limited to 17 characters!
+
 	#define WELCOME_MSG MACHINE_NAME " prete."
 	#define MSG_SD_INSERTED "Carte inseree"
 	#define MSG_SD_REMOVED "Carte retiree"
@@ -392,9 +444,9 @@
 	#define MSG_AUTO_HOME "Home auto."
 	#define MSG_SET_ORIGIN "Regler origine"
 	#define MSG_PREHEAT_PLA " Prechauffage PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " Regl. prech. PLA"
 	#define MSG_PREHEAT_ABS "Prechauffage ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Regl. prechauffe ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Regl. prech. ABS"
 	#define MSG_COOLDOWN "Refroidir"
 	#define MSG_SWITCH_PS_ON "Allumer alim."
 	#define MSG_SWITCH_PS_OFF "Eteindre alim."
@@ -403,12 +455,19 @@
 	#define MSG_PREHEAT_PLA "Prechauffage PLA"
 	#define MSG_PREHEAT_ABS "Prechauffage ABS"
 	#define MSG_MOVE_AXIS "Deplacer un axe"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
 	#define MSG_SPEED " Vitesse"
 	#define MSG_NOZZLE "Buse"
 	#define MSG_NOZZLE1 "Buse2"
 	#define MSG_NOZZLE2 "Buse3"
 	#define MSG_BED "Plateau"
-	#define MSG_FAN_SPEED "Vitesse ventilateur"
+	#define MSG_FAN_SPEED "Vite. ventilateur"
 	#define MSG_FLOW "Flux"
 	#define MSG_CONTROL "Controler"
 	#define MSG_MIN " \002 Min"
@@ -454,10 +513,9 @@
 	#define MSG_CARD_MENU "Impr. depuis SD"
 	#define MSG_NO_CARD "Pas de carte"
 	#define MSG_DWELL "Repos..."
-	#define MSG_USERWAIT "Attente de l'utilisateur..."
-	#define MSG_RESUMING "Reprise de l'impression"
+	#define MSG_USERWAIT "Atten. de l'util."
+	#define MSG_RESUMING "Repri. de l'impr."
 	#define MSG_NO_MOVE "Aucun mouvement."
-	#define MSG_PART_RELEASE "Relache partielle"
 	#define MSG_KILLED "MORT."
 	#define MSG_STOPPED "STOPPE."
 	#define MSG_STEPPER_RELEASED "RELACHE."
@@ -469,10 +527,15 @@
 	#define MSG_AUTORETRACT "Retract. Auto."
 	#define MSG_FILAMENTCHANGE "Changer filament"
 	#define MSG_INIT_SDCARD "Init. la carte SD"	
-	#define MSG_CNG_SDCARD "Changer de carte SD"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_CNG_SDCARD "Changer de carte"
+    #define MSG_ZPROBE_OUT "Z sonde exte. lit"
+    #define MSG_POSITION_UNKNOWN "Rev. dans XY av.Z"
+    #define MSG_ZPROBE_ZOFFSET "Offset Z"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Butee abandon"
+	#define MSG_CONTRAST "Contrast"
 
 // Serial Console Messages
 
@@ -482,7 +545,6 @@
 	#define MSG_BROWNOUT_RESET " RAZ defaut alim."
 	#define MSG_WATCHDOG_RESET " RAZ Watchdog"
 	#define MSG_SOFTWARE_RESET " RAZ logicielle"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Auteur: "
 	#define MSG_CONFIGURATION_VER " Derniere MaJ: "
 	#define MSG_FREE_MEMORY " Memoire libre: "
@@ -498,6 +560,7 @@
 	#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
 	#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
+	#define MSG_M200_INVALID_EXTRUDER "M200 Extruder invalide"
 	#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
 	#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
@@ -544,6 +607,10 @@
 	#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 	
 #endif
 
@@ -551,6 +618,7 @@
 #if LANGUAGE_CHOICE == 4
 
 // LCD Menu Messages
+// Please note these are limited to 17 characters!
 
 	#define WELCOME_MSG MACHINE_NAME " Bereit."
 
@@ -558,19 +626,26 @@
 	#define MSG_SD_REMOVED       "SDKarte entfernt"
 	#define MSG_MAIN             "Hauptmenü"
 	#define MSG_AUTOSTART        "Autostart"
-	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
+	#define MSG_DISABLE_STEPPERS "Stepper abschalt."
 	#define MSG_AUTO_HOME        "Auto Nullpunkt"
 	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
 	#define MSG_PREHEAT_PLA      "Vorwärmen PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Vorwärmen PLA Einstellungen"
+	#define MSG_PREHEAT_PLA_SETTINGS "Vorwärm. PLA Ein."
 	#define MSG_PREHEAT_ABS      "Vorwärmen ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Vorwärmen ABS Einstellungen"
+	#define MSG_PREHEAT_ABS_SETTINGS "Vorwärm. ABS Ein."
 	#define MSG_COOLDOWN         "Abkühlen"
 	#define MSG_SWITCH_PS_ON     "Switch Power On"
 	#define MSG_SWITCH_PS_OFF    "Switch Power Off"
 	#define MSG_EXTRUDE          "Extrude"
 	#define MSG_RETRACT          "Retract"
 	#define MSG_MOVE_AXIS        "Achsen bewegen"
+	#define MSG_MOVE_X           "X bewegen"
+	#define MSG_MOVE_Y           "Y bewegen"
+	#define MSG_MOVE_Z           "Z bewegen"
+	#define MSG_MOVE_E           "Extruder"
+	#define MSG_MOVE_01MM        "0.1mm bewegen"
+	#define MSG_MOVE_1MM         "1mm bewegen"
+	#define MSG_MOVE_10MM        "10mm bewegen"
 	#define MSG_SPEED            "Geschw"
 	#define MSG_NOZZLE           "Düse"
 	#define MSG_NOZZLE1          "Düse2"
@@ -624,10 +699,9 @@
 	#define MSG_CARD_MENU        "SDKarten Menü"
 	#define MSG_NO_CARD          "Keine SDKarte"
 	#define MSG_DWELL            "Warten..."		
-	#define MSG_USERWAIT         "Warte auf Nutzer..."
+	#define MSG_USERWAIT         "Warte auf Nutzer"
 	#define MSG_RESUMING         "Druck fortsetzung"
 	#define MSG_NO_MOVE          "Kein Zug."
-	#define MSG_PART_RELEASE     "Stepper tlw frei"
 	#define MSG_KILLED           "KILLED"
 	#define MSG_STOPPED          "GESTOPPT"
 	#define MSG_STEPPER_RELEASED "Stepper frei"
@@ -640,9 +714,14 @@
 	#define MSG_FILAMENTCHANGE "Filament wechseln"
 	#define MSG_INIT_SDCARD "Init. SD-Card"	
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
     #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
 	
 // Serial Console Messages
 
@@ -652,7 +731,6 @@
 	#define MSG_BROWNOUT_RESET " Brown out Reset"
 	#define MSG_WATCHDOG_RESET " Watchdog Reset"
 	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin: "
 	#define MSG_AUTHOR " | Author: "
 	#define MSG_CONFIGURATION_VER " Last Updated: "
 	#define MSG_FREE_MEMORY " Free Memory: "
@@ -668,6 +746,7 @@
 	#define MSG_END_FILE_LIST "End file list"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Invalid extruder "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
 	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
@@ -714,6 +793,10 @@
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
 
@@ -721,14 +804,16 @@
 #if LANGUAGE_CHOICE == 5
 
 // LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME "Lista."
-	#define MSG_SD_INSERTED "Tarjeta SD Colocada"
-	#define MSG_SD_REMOVED "Tarjeta SD Retirada"
-	#define MSG_MAIN "Menu Principal"
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " lista."
+	#define MSG_SD_INSERTED "Tarjeta colocada"
+	#define MSG_SD_REMOVED "Tarjeta retirada"
+	#define MSG_MAIN "Menu principal"
 	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS "Apagar Motores"
-	#define MSG_AUTO_HOME "Llevar al Origen" // "Llevar Ejes al Cero"
-	#define MSG_SET_ORIGIN "Establecer Cero"
+	#define MSG_DISABLE_STEPPERS "Apagar motores"
+	#define MSG_AUTO_HOME "Llevar al origen"
+	#define MSG_SET_ORIGIN "Establecer cero"
 	#define MSG_PREHEAT_PLA "Precalentar PLA"
 	#define MSG_PREHEAT_PLA_SETTINGS "Ajustar temp. PLA"
 	#define MSG_PREHEAT_ABS "Precalentar ABS"
@@ -738,7 +823,14 @@
 	#define MSG_SWITCH_PS_OFF "Switch Power Off"
 	#define MSG_EXTRUDE "Extruir"
 	#define MSG_RETRACT "Retraer"
-	#define MSG_MOVE_AXIS "Mover Ejes"
+	#define MSG_MOVE_AXIS "Mover ejes"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
 	#define MSG_SPEED "Velocidad"
 	#define MSG_NOZZLE "Nozzle"
 	#define MSG_NOZZLE1 "Nozzle2"
@@ -777,24 +869,24 @@
 	#define MSG_RECTRACT "Retraer"
 	#define MSG_TEMPERATURE "Temperatura"
 	#define MSG_MOTION "Movimiento"
-	#define MSG_STORE_EPROM "Guardar Memoria"
-	#define MSG_LOAD_EPROM "Cargar Memoria"
-	#define MSG_RESTORE_FAILSAFE "Rest. de emergencia"
+	#define MSG_STORE_EPROM "Guardar memoria"
+	#define MSG_LOAD_EPROM "Cargar memoria"
+	#define MSG_RESTORE_FAILSAFE "Rest. de emergen."
 	#define MSG_REFRESH "Volver a cargar"
 	#define MSG_WATCH "Monitorizar"
 	#define MSG_PREPARE "Preparar"
 	#define MSG_TUNE "Ajustar"
-	#define MSG_PAUSE_PRINT "Pausar Impresion"
-	#define MSG_RESUME_PRINT "Reanudar Impresion"
-	#define MSG_STOP_PRINT "Detener Impresion"
+	#define MSG_PAUSE_PRINT "Pausar impresion"
+	#define MSG_RESUME_PRINT "Reanudar impres."
+	#define MSG_STOP_PRINT "Detener impresion"
 	#define MSG_CARD_MENU "Menu de SD"
-	#define MSG_NO_CARD "No hay Tarjeta SD"
+	#define MSG_NO_CARD "No hay tarjeta SD"
 	#define MSG_DWELL "Reposo..."
-	#define MSG_USERWAIT "Esperando Ordenes..."
-	#define MSG_RESUMING "Resumiendo Impresion"
+	#define MSG_USERWAIT "Esperando ordenes"
+	#define MSG_RESUMING "Resumiendo impre."
 	#define MSG_NO_MOVE "Sin movimiento"
-	#define MSG_KILLED "PARADA DE EMERGENCIA. "
-	#define MSG_STOPPED "PARADA."
+	#define MSG_KILLED "PARADA DE EMERG."
+	#define MSG_STOPPED "PARADA"
 	#define MSG_CONTROL_RETRACT  "Retraer mm"
 	#define MSG_CONTROL_RETRACTF "Retraer  F"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Levantar mm"
@@ -802,21 +894,25 @@
 	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Iniciando. Tarjeta-SD"
-	#define MSG_CNG_SDCARD "Cambiar Tarjeta-SD"
+	#define MSG_INIT_SDCARD "Iniciando tarjeta"
+	#define MSG_CNG_SDCARD "Cambiar tarjeta"
 	#define MSG_RECTRACT_WIDE "Retraer"
 	#define MSG_TEMPERATURE_WIDE "Temperatura"
 	#define MSG_TEMPERATURE_RTN  "Temperatura"
-	#define MSG_MAIN_WIDE "Menu Principal"
+	#define MSG_MAIN_WIDE "Menu principal"
 	#define MSG_MOTION_WIDE "Movimiento"
 	#define MSG_PREPARE_ALT "Preparar"
 	#define MSG_CONTROL_ARROW "Control"
 	#define MSG_RETRACT_ARROW "Retraer"
-	#define MSG_PART_RELEASE "Desacople Parcial"
 	#define MSG_STEPPER_RELEASED "Desacoplada."
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
     #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
 
 // Serial Console Messages
 
@@ -826,7 +922,6 @@
 	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
 	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
 	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Autor: "
 	#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
 	#define MSG_FREE_MEMORY " Memoria libre: "
@@ -842,6 +937,7 @@
 	#define MSG_END_FILE_LIST "Fin de la lista de archivos"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor Invalido "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
 	#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
@@ -887,100 +983,118 @@
 	#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
 
 #if LANGUAGE_CHOICE == 6
 
-	// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME			" Готов"
+
+// LCD Menu Messages
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME			" Готов."
 	#define MSG_SD_INSERTED						"Карта вставлена"
 	#define MSG_SD_REMOVED						"Карта извлечена"
-	#define MSG_MAIN							" Меню              \003"
-	#define MSG_AUTOSTART						" Автостарт          "
-	#define MSG_DISABLE_STEPPERS				" Выключить двигатели"
-	#define MSG_AUTO_HOME						" Парковка           "
-	#define MSG_SET_ORIGIN						" Запомнить ноль     "
-	#define MSG_PREHEAT_PLA						" Преднагрев PLA     "
-	#define MSG_PREHEAT_PLA_SETTINGS			" Настр. преднагр.PLA"
-	#define MSG_PREHEAT_ABS						" Преднагрев ABS     "
-	#define MSG_PREHEAT_ABS_SETTINGS			" Настр. преднагр.ABS"
-	#define MSG_COOLDOWN						" Охлаждение         "
+	#define MSG_MAIN							"Меню            \003"
+	#define MSG_AUTOSTART						"Автостарт"
+	#define MSG_DISABLE_STEPPERS 				"Выкл. двигатели"
+	#define MSG_AUTO_HOME						"Парковка"
+	#define MSG_SET_ORIGIN						"Запомнить ноль"
+	#define MSG_PREHEAT_PLA 					"Преднагрев PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS  			"Настройки PLA"
+	#define MSG_PREHEAT_ABS						"Преднагрев ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS  			"Настройки ABS"
+	#define MSG_COOLDOWN						"Охлаждение"
 	#define MSG_SWITCH_PS_ON					"Switch Power On"
 	#define MSG_SWITCH_PS_OFF					"Switch Power Off"
-	#define MSG_EXTRUDE							" Экструзия          "
-	#define MSG_RETRACT							" Откат"
-	#define MSG_MOVE_AXIS						" Движение по осям  \x7E"
-	#define MSG_SPEED							" Скорость:"
-	#define MSG_NOZZLE							" \002 Фильера:"
-	#define MSG_NOZZLE1							" \002 Фильера2:"
-	#define MSG_NOZZLE2							" \002 Фильера3:"
-	#define MSG_BED								" \002 Кровать:"
-	#define MSG_FAN_SPEED						" Куллер:"
-	#define MSG_FLOW							" Поток:"
-	#define MSG_CONTROL							" Настройки \003"
-	#define MSG_MIN								" \002 Минимум:"
-	#define MSG_MAX								" \002 Максимум:"
-	#define MSG_FACTOR							" \002 Фактор:"
-	#define MSG_AUTOTEMP						" Autotemp:"
+	#define MSG_EXTRUDE							"Экструзия"
+	#define MSG_RETRACT							"Откат"
+	#define MSG_MOVE_AXIS  						"Движение по осям"
+	#define MSG_MOVE_X                          "Move X"
+	#define MSG_MOVE_Y                          "Move Y"
+	#define MSG_MOVE_Z                          "Move Z"
+	#define MSG_MOVE_E                          "Extruder"
+	#define MSG_MOVE_01MM                       "Move 0.1mm"
+	#define MSG_MOVE_1MM                        "Move 1mm"
+	#define MSG_MOVE_10MM                       "Move 10mm"
+	#define MSG_SPEED							"Скорость:"
+	#define MSG_NOZZLE							"\002 Фильера:"
+	#define MSG_NOZZLE1							"\002 Фильера2:"
+	#define MSG_NOZZLE2							"\002 Фильера3:"
+	#define MSG_BED								"\002 Кровать:"
+	#define MSG_FAN_SPEED						"Куллер:"
+	#define MSG_FLOW							"Поток:"
+	#define MSG_CONTROL							"Настройки \003"
+	#define MSG_MIN								"\002 Минимум:"
+	#define MSG_MAX								"\002 Максимум:"
+	#define MSG_FACTOR							"\002 Фактор:"
+	#define MSG_AUTOTEMP						"Autotemp:"
 	#define MSG_ON								"Вкл. "
 	#define MSG_OFF								"Выкл. "
-	#define MSG_PID_P							" PID-P: "
-	#define MSG_PID_I							" PID-I: "
-	#define MSG_PID_D							" PID-D: "
-	#define MSG_PID_C							" PID-C: "
-	#define MSG_ACC								" Acc:"
-	#define MSG_VXY_JERK						" Vxy-jerk: "
+	#define MSG_PID_P							"PID-P: "
+	#define MSG_PID_I							"PID-I: "
+	#define MSG_PID_D							"PID-D: "
+	#define MSG_PID_C							"PID-C: "
+	#define MSG_ACC								"Acc:"
+	#define MSG_VXY_JERK						"Vxy-jerk: "
 	#define MSG_VZ_JERK                         "Vz-jerk"
 	#define MSG_VE_JERK                         "Ve-jerk"
-	#define MSG_VMAX							" Vmax "
+	#define MSG_VMAX							"Vmax "
 	#define MSG_X								"x:"
 	#define MSG_Y								"y:"
 	#define MSG_Z								"z:"
 	#define MSG_E								"e:"
-	#define MSG_VMIN							" Vmin:"
-	#define MSG_VTRAV_MIN						" VTrav min:"
-	#define MSG_AMAX							" Amax "
-	#define MSG_A_RETRACT						" A-retract:"
-	#define MSG_XSTEPS							" X шаг/mm:"
-	#define MSG_YSTEPS							" Y шаг/mm:"
-	#define MSG_ZSTEPS							" Z шаг/mm:"
-	#define MSG_ESTEPS							" E шаг/mm:"
-	#define MSG_RECTRACT    					" Откат подачи      \x7E"
-	#define MSG_TEMPERATURE  				" Температура       \x7E"
-	#define MSG_MOTION						" Скорости          \x7E"
-		#define MSG_CONTRAST "LCD contrast"
-	#define MSG_STORE_EPROM						" Сохранить настройки"
-	#define MSG_LOAD_EPROM						" Загрузить настройки"
-	#define MSG_RESTORE_FAILSAFE				" Сброс настроек     "
-	#define MSG_REFRESH							"\004Обновить           "
-	#define MSG_WATCH							" Обзор             \003"
-	#define MSG_PREPARE							" Действия          \x7E"
-	#define MSG_TUNE					" Настройки         \x7E"
-	#define MSG_PAUSE_PRINT						" Пауза печати      \x7E"
-	#define MSG_RESUME_PRINT					" Продолжить печать \x7E"
-	#define MSG_STOP_PRINT						" Остановить печать \x7E"
-	#define MSG_CARD_MENU						" Меню карты        \x7E"
-	#define MSG_NO_CARD							" Нет карты"
+	#define MSG_VMIN							"Vmin:"
+	#define MSG_VTRAV_MIN						"VTrav min:"
+	#define MSG_AMAX							"Amax "
+	#define MSG_A_RETRACT						"A-retract:"
+	#define MSG_XSTEPS							"X шаг/mm:"
+	#define MSG_YSTEPS							"Y шаг/mm:"
+	#define MSG_ZSTEPS							"Z шаг/mm:"
+	#define MSG_ESTEPS							"E шаг/mm:"
+	#define MSG_RECTRACT    					"Откат подачи    \x7E"
+	#define MSG_TEMPERATURE  					"Температура     \x7E"
+	#define MSG_MOTION							"Скорости        \x7E"
+	#define MSG_CONTRAST  						"LCD contrast"
+	#define MSG_STORE_EPROM  					"Сохранить в EPROM"
+	#define MSG_LOAD_EPROM  					"Загруз. из EPROM"
+	#define MSG_RESTORE_FAILSAFE				"Сброс настроек"
+	#define MSG_REFRESH							"\004Обновить"
+	#define MSG_WATCH							"Обзор           \003"
+	#define MSG_PREPARE							"Действия        \x7E"
+	#define MSG_TUNE							"Настройки       \x7E"
+	#define MSG_RESUME_PRINT  					"Продолжить печать"
+	#define MSG_RESUME_PRINT					"Продолжить печать"
+	#define MSG_STOP_PRINT 						"Остановить печать"
+	#define MSG_CARD_MENU						"Меню карты      \x7E"
+	#define MSG_NO_CARD							"Нет карты"
 	#define MSG_DWELL							"Сон..."
-	#define MSG_USERWAIT						"Нажмите для продолж."
-	#define MSG_RESUMING "Resuming print"
-	#define MSG_NO_MOVE							"Нет движения.       "
-	#define MSG_PART_RELEASE					" Извлечение принта  "
-	#define MSG_KILLED							"УБИТО. "
-	#define MSG_STOPPED							"ОСТАНОВЛЕНО. "
-	#define MSG_CONTROL_RETRACT					" Откат mm:"
-	#define MSG_CONTROL_RETRACTF				" Откат  F:"
-	#define MSG_CONTROL_RETRACT_ZLIFT			" Прыжок mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER			" Возврат +mm:"
-	#define MSG_CONTROL_RETRACT_RECOVERF		" Возврат  F:"
-	#define MSG_AUTORETRACT						" АвтоОткат:"
-	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
-    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
-    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_USERWAIT  						"Ожиданиие"
+	#define MSG_RESUMING 						"Resuming print"
+	#define MSG_NO_MOVE							"Нет движения."
+	#define MSG_KILLED							"УБИТО."
+	#define MSG_STOPPED							"ОСТАНОВЛЕНО."
+	#define MSG_CONTROL_RETRACT					"Откат mm:"
+	#define MSG_CONTROL_RETRACTF				"Откат  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT			"Прыжок mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER			"Возврат +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF		"Возврат  F:"
+	#define MSG_AUTORETRACT						"АвтоОткат:"
+	#define MSG_FILAMENTCHANGE 					"Change filament"
+	#define MSG_INIT_SDCARD 					"Init. SD-Card"	
+	#define MSG_CNG_SDCARD 						"Change SD-Card"
+    #define MSG_ZPROBE_OUT 						"Z probe out. bed"
+    #define MSG_POSITION_UNKNOWN 				"Home X/Y before Z"
+    #define MSG_ZPROBE_ZOFFSET 					"Z Offset"
+	#define MSG_BABYSTEP_X 						"Babystep X"
+	#define MSG_BABYSTEP_Y 						"Babystep Y"
+	#define MSG_BABYSTEP_Z 						"Babystep Z"
+	#define MSG_ENDSTOP_ABORT 					"Endstop abort"
+	#define MSG_CONTRAST 						"Contrast"
 
 // Serial Console Messages
 
@@ -990,7 +1104,6 @@
 	#define MSG_BROWNOUT_RESET					" Brown out сброс"
 	#define MSG_WATCHDOG_RESET					" Watchdog сброс"
 	#define MSG_SOFTWARE_RESET					" программный сброс"
-	#define MSG_MARLIN							"Marlin "
 	#define MSG_AUTHOR							" | Автор: "
 	#define MSG_CONFIGURATION_VER				" Последнее обновление: "
 	#define MSG_FREE_MEMORY						" Памяти свободно: "
@@ -1006,6 +1119,7 @@
 	#define MSG_END_FILE_LIST					"Конец списка файлов"
 	#define MSG_M104_INVALID_EXTRUDER			"M104 ошибка экструдера "
 	#define MSG_M105_INVALID_EXTRUDER			"M105 ошибка экструдера "
+	#define MSG_M200_INVALID_EXTRUDER			"M200 ошибка экструдера "
 	#define MSG_M218_INVALID_EXTRUDER			"M218 ошибка экструдера "
 	#define MSG_ERR_NO_THERMISTORS				"Нет термистра - нет температуры"
 	#define MSG_M109_INVALID_EXTRUDER			"M109 ошибка экструдера "
@@ -1050,14 +1164,20 @@
 	#define MSG_ENDSTOPS_HIT					"концевик сработал: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
 	#define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
 
 
 #if LANGUAGE_CHOICE == 7
 
-	// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronta"
+// LCD Menu Messages
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " pronto."
 	#define MSG_SD_INSERTED          "SD Card inserita"
 	#define MSG_SD_REMOVED           "SD Card rimossa"
 	#define MSG_MAIN                 "Menu principale"
@@ -1075,6 +1195,13 @@
 	#define MSG_EXTRUDE              "Estrudi"
 	#define MSG_RETRACT              "Ritrai"
 	#define MSG_MOVE_AXIS            "Muovi Asse"
+	#define MSG_MOVE_X               "Move X"
+	#define MSG_MOVE_Y               "Move Y"
+	#define MSG_MOVE_Z               "Move Z"
+	#define MSG_MOVE_E               "Extruder"
+	#define MSG_MOVE_01MM            "Move 0.1mm"
+	#define MSG_MOVE_1MM             "Move 1mm"
+	#define MSG_MOVE_10MM            "Move 10mm"
 	#define MSG_SPEED                "Velcità"
 	#define MSG_NOZZLE               "Ugello"
 	#define MSG_NOZZLE1              "Ugello2"
@@ -1138,15 +1265,19 @@
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT          "AutoArretramento"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
 	#define MSG_FILAMENTCHANGE       "Cambia filamento"
 	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
 	#define MSG_CNG_SDCARD           "Cambia SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
     #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
 
-	// Serial Console Messages
+// Serial Console Messages
 
 	#define MSG_Enqueing             "accodamento \""
 	#define MSG_POWERUP              "Accensione"
@@ -1154,7 +1285,6 @@
 	#define MSG_BROWNOUT_RESET       " Brown out Reset"
 	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
 	#define MSG_SOFTWARE_RESET       " Software Reset"
-	#define MSG_MARLIN               "Marlin "
 	#define MSG_AUTHOR               " | Autore: "
 	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
 	#define MSG_FREE_MEMORY          " Memoria Libera: "
@@ -1170,6 +1300,7 @@
 	#define MSG_END_FILE_LIST        "Fine Lista File"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Estrusore non valido "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
 	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
@@ -1216,6 +1347,10 @@
 	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
 
 #endif
 
@@ -1223,46 +1358,55 @@
 #if LANGUAGE_CHOICE == 8
 
 // LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronta."
-	#define MSG_SD_INSERTED "Cartao SD inserido"
-	#define MSG_SD_REMOVED "Cartao SD removido"
-	#define MSG_MAIN " Menu Principal \003"
-	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS " Apagar Motores"
-	#define MSG_AUTO_HOME " Ir para Origen"
-	#define MSG_SET_ORIGIN " Estabelecer Origen"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
-	#define MSG_COOLDOWN " Esfriar"
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " pronto."
+	#define MSG_SD_INSERTED "Cartao inserido"
+	#define MSG_SD_REMOVED "Cartao removido"
+	#define MSG_MAIN " Menu principal \003"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS " Apagar motores"
+	#define MSG_AUTO_HOME "Ir para origen"
+	#define MSG_SET_ORIGIN "Estabelecer orig."
+	#define MSG_PREHEAT_PLA "Pre-aquecer PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "PLA setting"
+	#define MSG_PREHEAT_ABS "Pre-aquecer ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "ABS setting"
+	#define MSG_COOLDOWN "Esfriar"
 	#define MSG_SWITCH_PS_ON "Switch Power On"
 	#define MSG_SWITCH_PS_OFF "Switch Power Off"
-	#define MSG_EXTRUDE " Extrudar"
-	#define MSG_RETRACT " Retrair"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
-	#define MSG_SPEED " Velocidade:"
-	#define MSG_NOZZLE " \002Nozzle:"
-	#define MSG_NOZZLE1 " \002Nozzle2:"
-	#define MSG_NOZZLE2 " \002Nozzle3:"
-	#define MSG_BED " \002Base:"
-	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
-	#define MSG_FLOW " Fluxo:"
-	#define MSG_CONTROL " Controle \003"
-	#define MSG_MIN " \002 Min:"
-	#define MSG_MAX " \002 Max:"
-	#define MSG_FACTOR " \002 Fact:"
-	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_EXTRUDE "Extrudar"
+	#define MSG_RETRACT "Retrair"
+	#define MSG_PREHEAT_PLA "Pre-aquecer PLA"
+	#define MSG_PREHEAT_ABS "Pre-aquecer ABS"
+	#define MSG_MOVE_AXIS "Mover eixo      \x7E"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
+	#define MSG_SPEED "Velocidade:"
+	#define MSG_NOZZLE "\002Nozzle:"
+	#define MSG_NOZZLE1 "\002Nozzle2:"
+	#define MSG_NOZZLE2 "\002Nozzle3:"
+	#define MSG_BED "\002Base:"
+	#define MSG_FAN_SPEED "Velocidade vento."
+	#define MSG_FLOW "Fluxo:"
+	#define MSG_CONTROL "Controle \003"
+	#define MSG_MIN "\002 Min:"
+	#define MSG_MAX "\002 Max:"
+	#define MSG_FACTOR "\002 Fact:"
+	#define MSG_AUTOTEMP "Autotemp:"
 	#define MSG_ON "On "
 	#define MSG_OFF "Off"
-	#define MSG_PID_P " PID-P: "
-	#define MSG_PID_I " PID-I: "
-	#define MSG_PID_D " PID-D: "
-	#define MSG_PID_C " PID-C: "
-	#define MSG_ACC  " Acc:"
-	#define MSG_VXY_JERK " Vxy-jerk: "
+	#define MSG_PID_P "PID-P: "
+	#define MSG_PID_I "PID-I: "
+	#define MSG_PID_D "PID-D: "
+	#define MSG_PID_C "PID-C: "
+	#define MSG_ACC  "Acc:"
+	#define MSG_VXY_JERK "Vxy-jerk: "
 	#define MSG_VZ_JERK "Vz-jerk"
 	#define MSG_VE_JERK "Ve-jerk"
 	#define MSG_VMAX " Vmax "
@@ -1270,39 +1414,38 @@
 	#define MSG_Y "y:"
 	#define MSG_Z "z:"
 	#define MSG_E "e:"
-	#define MSG_VMIN " Vmin:"
-	#define MSG_VTRAV_MIN " VTrav min:"
-	#define MSG_AMAX " Amax "
-	#define MSG_A_RETRACT " A-retract:"
-	#define MSG_XSTEPS " Xpasso/mm:"
-	#define MSG_YSTEPS " Ypasso/mm:"
-	#define MSG_ZSTEPS " Zpasso/mm:"
-	#define MSG_ESTEPS " Epasso/mm:"
-	#define MSG_MAIN_WIDE " Menu Principal  \003"
+	#define MSG_VMIN "Vmin:"
+	#define MSG_VTRAV_MIN "VTrav min:"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-retract:"
+	#define MSG_XSTEPS "Xpasso/mm:"
+	#define MSG_YSTEPS "Ypasso/mm:"
+	#define MSG_ZSTEPS "Zpasso/mm:"
+	#define MSG_ESTEPS "Epasso/mm:"
+	#define MSG_MAIN_WIDE "Menu Principal  \003"
 	#define MSG_RECTRACT "Retrair"
 	#define MSG_TEMPERATURE "Temperatura"
 	#define MSG_MOTION "Movimento"
-	#define MSG_STORE_EPROM " Guardar memoria"
-	#define MSG_LOAD_EPROM " Carregar memoria"
-	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+	#define MSG_STORE_EPROM "Guardar memoria"
+	#define MSG_LOAD_EPROM "Carregar memoria"
+	#define MSG_RESTORE_FAILSAFE "Rest. de emergen."
 	#define MSG_REFRESH "\004Recarregar"
-	#define MSG_WATCH " Monitorar   \003"
-	#define MSG_PREPARE " Preparar \x7E"
-	#define MSG_PREPARE_ALT " Preparar \003"
-	#define MSG_CONTROL_ARROW " Controle \x7E"
-	#define MSG_RETRACT_ARROW " Retrair \x7E"
-	#define MSG_TUNE " Tune    \x7E"
-	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
-	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
-	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
-	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
-	#define MSG_NO_CARD " Sem cartao SD"
+	#define MSG_WATCH "Monitorar   \003"
+	#define MSG_PREPARE "Preparar \x7E"
+	#define MSG_PREPARE_ALT "Preparar \003"
+	#define MSG_CONTROL_ARROW "Controle \x7E"
+	#define MSG_RETRACT_ARROW "Retrair \x7E"
+	#define MSG_TUNE "Tune    \x7E"
+	#define MSG_PAUSE_PRINT "Pausar impressao"
+	#define MSG_RESUME_PRINT "Resumir impressao"
+	#define MSG_STOP_PRINT "Parar impressao"
+	#define MSG_CARD_MENU "Menu cartao SD"
+	#define MSG_NO_CARD "Sem cartao SD"
 	#define MSG_DWELL "Repouso..."
-	#define MSG_USERWAIT "Esperando Ordem..."
+	#define MSG_USERWAIT "Esperando ordem"
 	#define MSG_RESUMING "Resuming print"
-	#define MSG_NO_MOVE "Sem movimento."
-	#define MSG_PART_RELEASE "Lancamento Parcial"
-	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_NO_MOVE "Sem movimento"
+	#define MSG_KILLED "PARADA DE EMERG."
 	#define MSG_STOPPED "PARADA. "
 	#define MSG_STEPPER_RELEASED "Lancado."
 	#define MSG_CONTROL_RETRACT  " Retrair mm:"
@@ -1311,13 +1454,17 @@
 	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
 	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
 	#define MSG_AUTORETRACT " AutoRetr.:"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
 	#define MSG_FILAMENTCHANGE "Change filament"
 	#define MSG_INIT_SDCARD "Init. SD-Card"	
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "Sonda fora da mesa"
-    #define MSG_POSITION_UNKNOWN "Home X/Y antes de Z"
+    #define MSG_ZPROBE_OUT "Son. fora da mesa"
+    #define MSG_POSITION_UNKNOWN "XY antes de Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
 
 // Serial Console Messages
 
@@ -1327,7 +1474,6 @@
 	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
 	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
 	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Author: "
 	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
 	#define MSG_FREE_MEMORY " memoria Livre: "
@@ -1343,6 +1489,7 @@
 	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor inválido "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor inválido "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor inválido "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor inválido "
 	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor inválido "
@@ -1389,7 +1536,10 @@
 	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
-
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
 
 #endif
 
@@ -1397,10 +1547,10 @@
 
 #if LANGUAGE_CHOICE == 9
 
-// Finnish
-
 // LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " valmis"
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " valmis."
 	#define MSG_SD_INSERTED "Kortti asetettu"
 	#define MSG_SD_REMOVED "Kortti poistettu"
 	#define MSG_MAIN "Palaa"
@@ -1409,15 +1559,22 @@
 	#define MSG_AUTO_HOME "Aja referenssiin"
 	#define MSG_SET_ORIGIN "Aseta origo"
 	#define MSG_PREHEAT_PLA "Esilammita PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"
+	#define MSG_PREHEAT_PLA_SETTINGS "Esilamm. PLA konf"
 	#define MSG_PREHEAT_ABS "Esilammita ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"
+	#define MSG_PREHEAT_ABS_SETTINGS "Esilamm. ABS konf"
 	#define MSG_COOLDOWN "Jaahdyta"
 	#define MSG_SWITCH_PS_ON "Switch Power On"
 	#define MSG_SWITCH_PS_OFF "Switch Power Off"
 	#define MSG_EXTRUDE "Pursota"
 	#define MSG_RETRACT "Veda takaisin"
 	#define MSG_MOVE_AXIS "Liikuta akseleita"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
 	#define MSG_SPEED "Nopeus"
 	#define MSG_NOZZLE "Suutin"
 	#define MSG_NOZZLE1 "Suutin2"
@@ -1470,8 +1627,8 @@
 	#define MSG_CARD_MENU "Korttivalikko"
 	#define MSG_NO_CARD "Ei korttia"
 	#define MSG_DWELL "Nukkumassa..."
-	#define MSG_USERWAIT "Odotetaan valintaa..."
-	#define MSG_RESUMING "Jatketaan tulostusta"
+	#define MSG_USERWAIT "Odotet. valintaa"
+	#define MSG_RESUMING "Jatke. tulostusta"
 	#define MSG_NO_MOVE "Ei liiketta."
 	#define MSG_KILLED "KILLED. "
 	#define MSG_STOPPED "STOPPED. "
@@ -1484,9 +1641,14 @@
 	#define MSG_FILAMENTCHANGE "Change filament"
 	#define MSG_INIT_SDCARD "Init. SD-Card"	
 	#define MSG_CNG_SDCARD "Change SD-Card"
-    #define MSG_ZPROBE_OUT "ZProbe Outside Bed"
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
     #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
     #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
 
 // Serial Console Messages
 
@@ -1496,7 +1658,6 @@
 	#define MSG_BROWNOUT_RESET " Alajannite Reset"
 	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
 	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
-	#define MSG_MARLIN "Marlin "
 	#define MSG_AUTHOR " | Author: "
 	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
 	#define MSG_FREE_MEMORY " Vapaata muistia: "
@@ -1512,6 +1673,7 @@
 	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
 	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
 	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Virheellinen suutin "
 	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
 	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
 	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
@@ -1558,6 +1720,202 @@
 	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #endif
+
+#if LANGUAGE_CHOICE == 10
+
+// LCD Menu Messages
+// Please note these are limited to 17 characters!
+
+	#define WELCOME_MSG MACHINE_NAME " parada."
+	#define MSG_SD_INSERTED "Tarcheta colocada"
+	#define MSG_SD_REMOVED "Tarcheta retirada"
+	#define MSG_MAIN "Menu prencipal"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS "Amortar motors"
+	#define MSG_AUTO_HOME "Levar a l'orichen"
+	#define MSG_SET_ORIGIN "Establir zero"
+	#define MSG_PREHEAT_PLA "Precalentar PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Achustar tem. PLA"
+	#define MSG_PREHEAT_ABS "Precalentar ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Achustar tem. ABS"
+	#define MSG_COOLDOWN "Enfriar"
+	#define MSG_SWITCH_PS_ON "Enchegar Fuent"
+	#define MSG_SWITCH_PS_OFF "Desenchegar Fuent"
+	#define MSG_EXTRUDE "Extruir"
+	#define MSG_RETRACT "Retraer"
+	#define MSG_MOVE_AXIS "Mover Eixes"
+	#define MSG_MOVE_X "Move X"
+	#define MSG_MOVE_Y "Move Y"
+	#define MSG_MOVE_Z "Move Z"
+	#define MSG_MOVE_E "Extruder"
+	#define MSG_MOVE_01MM "Move 0.1mm"
+	#define MSG_MOVE_1MM "Move 1mm"
+	#define MSG_MOVE_10MM "Move 10mm"
+	#define MSG_SPEED "Velocidat"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Base"
+	#define MSG_FAN_SPEED "Ixoriador"
+	#define MSG_FLOW "Fluxo"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN "\002 Min"
+	#define MSG_MAX "\002 Max"
+	#define MSG_FACTOR "\002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On"
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Acel"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VZ_JERK "Vz-jerk"
+	#define MSG_VE_JERK "Ves-jerk"
+	#define MSG_VMAX "Vmax"
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "y"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax"
+	#define MSG_A_RETRACT "A-retrac."
+	#define MSG_XSTEPS "X trangos/mm"
+	#define MSG_YSTEPS "Y trangos/mm"
+	#define MSG_ZSTEPS "Z trangos/mm"
+	#define MSG_ESTEPS "E trangos/mm"
+	#define MSG_RECTRACT "Retraer"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Movimiento"
+	#define MSG_STORE_EPROM "Alzar Memoria"
+	#define MSG_LOAD_EPROM "Cargar Memoria"
+	#define MSG_RESTORE_FAILSAFE "Rest. d'emerchen."
+	#define MSG_REFRESH "Tornar a cargar"
+	#define MSG_WATCH "Monitorizar"
+	#define MSG_PREPARE "Preparar"
+	#define MSG_TUNE "Achustar"
+	#define MSG_PAUSE_PRINT "Pausar impresion"
+	#define MSG_RESUME_PRINT "Contin. impresion"
+	#define MSG_STOP_PRINT "Detener Impresion"
+	#define MSG_CARD_MENU "Menu de SD"
+	#define MSG_NO_CARD "No i hai tarcheta"
+	#define MSG_DWELL "Reposo..."
+	#define MSG_USERWAIT "Asperan. ordines"
+	#define MSG_RESUMING "Contin. impresion"
+	#define MSG_NO_MOVE "Sin movimiento"
+	#define MSG_KILLED "ATURADA D'EMERCH."
+	#define MSG_STOPPED "ATURADA."
+	#define MSG_CONTROL_RETRACT  "Retraer mm"
+	#define MSG_CONTROL_RETRACTF "Retraer  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Devantar mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet F"
+	#define MSG_AUTORETRACT "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Cambear"
+	#define MSG_INIT_SDCARD "Encetan. tarcheta"
+	#define MSG_CNG_SDCARD "Cambiar tarcheta"
+	#define MSG_RECTRACT_WIDE "Retraer"
+	#define MSG_TEMPERATURE_WIDE "Temperatura"
+	#define MSG_TEMPERATURE_RTN  "Temperatura"
+	#define MSG_MAIN_WIDE "Menu Prencipal"
+	#define MSG_MOTION_WIDE "Movimiento"
+	#define MSG_PREPARE_ALT "Preparar"
+	#define MSG_CONTROL_ARROW "Control"
+	#define MSG_RETRACT_ARROW "Retraer"
+	#define MSG_STEPPER_RELEASED "Desacoplada."
+    #define MSG_ZPROBE_OUT "Z probe out. bed"
+    #define MSG_POSITION_UNKNOWN "Home X/Y before Z"
+    #define MSG_ZPROBE_ZOFFSET "Z Offset"
+	#define MSG_BABYSTEP_X "Babystep X"
+	#define MSG_BABYSTEP_Y "Babystep Y"
+	#define MSG_BABYSTEP_Z "Babystep Z"
+	#define MSG_ENDSTOP_ABORT "Endstop abort"
+	#define MSG_CONTRAST "Contrast"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "En coda \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Zaguer esvielle: "
+	#define MSG_FREE_MEMORY " Memoria libre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardau."
+	#define MSG_ERR_LINE_NO "O Numero de Linea no ye igual a l'Ultimo Numero de Linea+1, Ultima Linea:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "o checksum no coincide, Ultima Linea:"
+	#define MSG_ERR_NO_CHECKSUM "No se podió trobar o Checksum con o numero de linea, Ultima Linea:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se trobo o Numero de Linea con o Checksum, Ultima Linea:"
+	#define MSG_FILE_PRINTED "Impresion rematada"
+	#define MSG_BEGIN_FILE_LIST "Prencipio d'a lista de fichero"
+	#define MSG_END_FILE_LIST "Fin d'a lista de fichero"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
+	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor Invalido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
+	#define MSG_ERR_NO_THERMISTORS "No i hai termistores - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
+	#define MSG_HEATING "Calentando..."
+	#define MSG_HEATING_COMPLETE "Calentamiento Feito."
+	#define MSG_BED_HEATING "Calentando la base."
+	#define MSG_BED_DONE "Base Calient."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
+	#define MSG_COUNT_X " Cuenta X:"
+	#define MSG_ERR_KILLED "Impresora Aturada con kill()!!"
+	#define MSG_ERR_STOPPED "Impresora aturada por errors. Apanye a error y use M999 Ta reiniciar!. (a temperatura se reestablece. Ajustela antes de continar)"
+	#define MSG_RESEND "Reninviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando Desconoixiu:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Comprobando fins de corrida."
+	#define MSG_ENDSTOP_HIT "PULSAU"
+	#define MSG_ENDSTOP_OPEN "ubierto"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+	#define MSG_SD_CANT_OPEN_SUBDIR "No se podió ubrir a subcarpeta."
+	#define MSG_SD_INIT_FAIL "Fallo en encetar a SD"
+	#define MSG_SD_VOL_INIT_FAIL "Fallo en amontar o volumen"
+	#define MSG_SD_OPENROOT_FAIL "Fallo en ubrir a carpeta raiz"
+	#define MSG_SD_CARD_OK "Tarcheta SD OK"
+	#define MSG_SD_WORKDIR_FAIL "Fallo en ubrir a carpeta de treballo"
+	#define MSG_SD_OPEN_FILE_FAIL "Error en ubrir, Fichero: "
+	#define MSG_SD_FILE_OPENED "Fichero ubierto:"
+	#define MSG_SD_SIZE " Grandaria:"
+	#define MSG_SD_FILE_SELECTED "Fichero Seleccionau"
+	#define MSG_SD_WRITE_TO_FILE "Escribindo en o fichero: "
+	#define MSG_SD_PRINTING_BYTE "SD imprentando o byte "
+	#define MSG_SD_NOT_PRINTING "No se ye imprentando con SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Error en escribir en o fichero"
+	#define MSG_SD_CANT_ENTER_SUBDIR "No se puede ubrir a carpeta:"
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate masiau alto : "
+	#define MSG_ENDSTOPS_HIT "S'ha tocau a fin de carril: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria privada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion masiau larga privada"
+	#define MSG_BABYSTEPPING_X "Babystepping X"
+	#define MSG_BABYSTEPPING_Y "Babystepping Y"
+	#define MSG_BABYSTEPPING_Z "Babystepping Z"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
+
+#endif
+
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index d896bca..995fa54 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -375,7 +375,7 @@
 * Arduino Mega pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67
+#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 #define KNOWN_BOARD 1
 
 //////////////////FIX THIS//////////////
@@ -391,10 +391,10 @@
 // #define RAMPS_V_1_0
 
 
-#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67
+#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67 || MOTHERBOARD == 68
 
   #define LARGE_FLASH true
-  
+
   #if MOTHERBOARD == 77
     #define X_STEP_PIN         54
     #define X_DIR_PIN          55
@@ -434,7 +434,7 @@
     #define SDSS               25//53
     #define LED_PIN            13
 
-    #define BEEPER             33    
+    #define BEEPER             33
 
   #else
 
@@ -472,21 +472,35 @@
     #define E1_DIR_PIN         34
     #define E1_ENABLE_PIN      30
 
+    #if MOTHERBOARD == 68
+      #define E2_STEP_PIN        23
+      #define E2_DIR_PIN         25
+      #define E2_ENABLE_PIN      40
+
+      #define E3_STEP_PIN        27
+      #define E3_DIR_PIN         29
+      #define E3_ENABLE_PIN      41
+
+      #define E4_STEP_PIN        43
+      #define E4_DIR_PIN         37
+      #define E4_ENABLE_PIN      42
+    #endif
+
     #define SDPOWER            -1
     #define SDSS               53
     #define LED_PIN            13
   #endif
 
-  #if MOTHERBOARD == 33 || MOTHERBOARD == 35 || MOTHERBOARD == 67
+  #if MOTHERBOARD == 33 || MOTHERBOARD == 35 || MOTHERBOARD == 67 || MOTHERBOARD == 68
     #define FAN_PIN            9 // (Sprinter config)
   #else
     #define FAN_PIN            4 // IO pin. Buffer needed
   #endif
 
   #if MOTHERBOARD == 77
-    #define FAN_PIN            8 
+    #define FAN_PIN            8
   #endif
-  
+
   #if MOTHERBOARD == 35
     #define CONTROLLERFAN_PIN  10 //Pin used for the fan to cool controller
   #endif
@@ -511,17 +525,33 @@
     #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
   #endif
 
-  #define HEATER_2_PIN       -1 
 
   #if MOTHERBOARD == 77
-    #define HEATER_0_PIN       10   
-    #define HEATER_1_PIN       12 
-    #define HEATER_2_PIN       6   
+    #define HEATER_0_PIN       10
+    #define HEATER_1_PIN       12
+    #define HEATER_2_PIN       6
+  #elif MOTHERBOARD == 68
+    #define HEATER_2_PIN       16
+    #define HEATER_3_PIN       17
+    #define HEATER_4_PIN       4
+    #define HEATER_5_PIN       5
+    #define HEATER_6_PIN       6
+    #define HEATER_7_PIN       11
+  #else
+    #define HEATER_2_PIN       -1
   #endif
 
   #define TEMP_0_PIN         13   // ANALOG NUMBERING
   #define TEMP_1_PIN         15   // ANALOG NUMBERING
-  #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+  #if MOTHERBOARD == 68
+    #define TEMP_2_PIN         12   // ANALOG NUMBERING
+    #define TEMP_3_PIN         11   // ANALOG NUMBERING
+    #define TEMP_4_PIN         10   // ANALOG NUMBERING
+    #define TC1                4    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+    #define TC2                5    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+  #else
+    #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+  #endif
 
   #if MOTHERBOARD == 35
     #define HEATER_BED_PIN     -1    // NO BED
@@ -532,9 +562,8 @@
       #define HEATER_BED_PIN     8    // BED
     #endif
   #endif
-  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
-
 
+  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
   #ifdef NUM_SERVOS
     #define SERVO0_PIN         11
@@ -552,20 +581,24 @@
     #endif
   #endif
 
+  #if MOTHERBOARD == 68
+    #define BEEPER 33
+  #endif
+
   #ifdef TEMP_STAT_LEDS
     #if MOTHERBOARD == 67
       #define STAT_LED_RED       6
       #define STAT_LED_BLUE     11
     #endif
   #endif
-  
+
   #ifdef ULTRA_LCD
 
     #ifdef NEWPANEL
-      #define LCD_PINS_RS 16 
+      #define LCD_PINS_RS 16
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D5 25
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
 
@@ -613,25 +646,25 @@
         #else
           #define SDCARDDETECT -1  // Ramps does not use this port
         #endif
-    
+
       #endif
-    
-      #if MOTHERBOARD == 77 
-        #define BEEPER -1 
-
-        #define LCD_PINS_RS 27 
-        #define LCD_PINS_ENABLE 29 
-        #define LCD_PINS_D4 37 
-        #define LCD_PINS_D5 35 
-        #define LCD_PINS_D6 33 
-        #define LCD_PINS_D7 31 
-
-       //buttons 
-       #define BTN_EN1 16 
-       #define BTN_EN2 17 
-       #define BTN_ENC 23 //the click 
-
-    #endif 
+
+      #if MOTHERBOARD == 77
+        #define BEEPER -1
+
+        #define LCD_PINS_RS 27
+        #define LCD_PINS_ENABLE 29
+        #define LCD_PINS_D4 37
+        #define LCD_PINS_D5 35
+        #define LCD_PINS_D6 33
+        #define LCD_PINS_D7 31
+
+       //buttons
+       #define BTN_EN1 16
+       #define BTN_EN2 17
+       #define BTN_ENC 23 //the click
+
+    #endif
     #else //old style panel with shift register
       //arduino pin witch triggers an piezzo beeper
       #define BEEPER 33		//No Beeper added
@@ -642,14 +675,14 @@
       //#define SHIFT_LD 42
       //#define SHIFT_OUT 40
       //#define SHIFT_EN 17
-    
-      #define LCD_PINS_RS 16 
+
+      #define LCD_PINS_RS 16
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D5 25
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
-    #endif 
+    #endif
   #endif //ULTRA_LCD
 
 #else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
@@ -694,16 +727,16 @@
 #define HEATER_1_PIN        -1
 #define HEATER_2_PIN        -1
 #define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          -1   
-#define TEMP_2_PIN          -1   
+#define TEMP_1_PIN          -1
+#define TEMP_2_PIN          -1
 #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
 
 #endif // MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 
-// SPI for Max6675 Thermocouple 
+// SPI for Max6675 Thermocouple
 
 #ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  
+// these pins are defined in the SD library if building with SD support
   #define MAX_SCK_PIN          52
   #define MAX_MISO_PIN         50
   #define MAX_MOSI_PIN         51
@@ -837,17 +870,17 @@
   #define BTN_EN1          14
   #define BTN_EN2          39
   #define BTN_ENC          15  //the click
-    
+
   #define BLEN_C           2
   #define BLEN_B           1
   #define BLEN_A           0
-    
+
   //encoder rotation values
   #define encrot0          0
   #define encrot1          2
   #define encrot2          3
   #define encrot3          1
-  
+
 #endif //RA_CONTROL_PANEL
 
 #ifdef RA_DISCO
@@ -861,7 +894,7 @@
   //This currently only works with the RA Board.
   #define TLC_CLOCK_BIT 3 //bit 3 on port A
   #define TLC_CLOCK_PORT &PORTA //bit 3 on port A
-  
+
   #define TLC_BLANK_BIT 1 //bit 1 on port A
   #define TLC_BLANK_PORT &PORTA //bit 1 on port A
 
@@ -871,12 +904,12 @@
   #define TLC_XLAT_BIT 0 //bit 0 on port A
   #define TLC_XLAT_PORT &PORTA //bit 0 on port A
 
-  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful 
+  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful
   //Leave it at at least 1 if you have enabled RA_LIGHTING
   //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.
-  #define NUM_TLCS 2 
+  #define NUM_TLCS 2
 
-  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions. 
+  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions.
   //Modify them according to your specific situation.
   //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.
   #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards
@@ -971,6 +1004,10 @@
 #undef MOTHERBOARD
 #define MOTHERBOARD 6
 #define SANGUINOLOLU_V_1_2
+
+#if defined(__AVR_ATmega1284P__)
+	#define LARGE_FLASH true
+#endif
 #endif
 #if MOTHERBOARD == 6
 #define KNOWN_BOARD 1
@@ -1081,8 +1118,8 @@
        #define LCD_PINS_D7        27
      #endif
      //The encoder and click button
-     #define BTN_EN1 11  
-     #define BTN_EN2 10 
+     #define BTN_EN1 11
+     #define BTN_EN2 10
      #ifdef LCD_I2C_PANELOLU2
        #ifdef MELZI
          #define BTN_ENC 29 //the click switch
@@ -1094,8 +1131,8 @@
        #define BTN_ENC 16  //the click switch
      #endif //Panelolu2
      //not connected to a pin
-     #define SDCARDDETECT -1    
-    
+     #define SDCARDDETECT -1
+
    #endif //Newpanel
  #endif //Ultipanel
 
@@ -1117,7 +1154,7 @@
      #define BTN_EN2 10
      #define BTN_ENC 16  //the click switch
      //not connected to a pin
-     #define SDCARDDETECT -1    
+     #define SDCARDDETECT -1
  #endif //Makrpanel
 
 #endif
@@ -1200,9 +1237,9 @@
     #define BTN_EN1 40
     #define BTN_EN2 42
     #define BTN_ENC 19  //the click
-    
+
     #define SDCARDDETECT 38
-    
+
   #else //old style panel with shift register
     //arduino pin witch triggers an piezzo beeper
     #define BEEPER 18
@@ -1219,9 +1256,9 @@
     #define LCD_PINS_D5 21
     #define LCD_PINS_D6 20
     #define LCD_PINS_D7 19
-  
+
     #define SDCARDDETECT -1
-  #endif 
+  #endif
 #endif //ULTRA_LCD
 
 #endif
@@ -1344,7 +1381,7 @@
 #define SDSS               53
 #define LED_PIN            8
 #define FAN_PIN            7
-#define PS_ON_PIN          12
+#define PS_ON_PIN          -1
 #define KILL_PIN           -1
 #define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.
 #define SAFETY_TRIGGERED_PIN     28 //PIN to detect the safety circuit has triggered
@@ -1354,7 +1391,7 @@
 #define MOTOR_CURRENT_PWM_Z_PIN 45
 #define MOTOR_CURRENT_PWM_E_PIN 46
 //Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
-#define MOTOR_CURRENT_PWM_RANGE 2000
+#define MOTOR_CURRENT_PWM_RANGE 2000
 #define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}
 
 //arduino pin witch triggers an piezzo beeper
@@ -1439,7 +1476,7 @@
  #else
   #define TEMP_0_PIN         15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used
  #endif
-#endif 
+#endif
 
 #if (TEMP_SENSOR_1==0)
  #define TEMP_1_PIN         -1
@@ -2149,13 +2186,13 @@
     #define BTN_EN1 59
     #define BTN_EN2 64
     #define BTN_ENC 43  //the click
-    
+
     #define BLEN_C 2
     #define BLEN_B 1
     #define BLEN_A 0
-    
+
     #define SDCARDDETECT -1		// Ramps does not use this port
-    
+
       //encoder rotation values
     #define encrot0 0
     #define encrot1 2
@@ -2172,102 +2209,102 @@
 ****************************************************************************************/
 #if MOTHERBOARD == 701
  #define KNOWN_BOARD 1
- 
- 
+
+
  #ifndef __AVR_ATmega2560__
  #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
  #endif
- 
+
  #define LARGE_FLASH        true
- 
+
  #define X_STEP_PIN 26
  #define X_DIR_PIN 27
  #define X_ENABLE_PIN 25
  #define X_MIN_PIN 37
  #define X_MAX_PIN 40 //2 //Max endstops default to disabled "-1", set to commented value to enable.
- 
+
  #define Y_STEP_PIN 4 // A6
  #define Y_DIR_PIN 54 // A0
  #define Y_ENABLE_PIN 5
  #define Y_MIN_PIN 41
  #define Y_MAX_PIN 38 //15
- 
+
  #define Z_STEP_PIN 56 // A2
  #define Z_DIR_PIN 60 // A6
  #define Z_ENABLE_PIN 55 // A1
  #define Z_MIN_PIN 18
  #define Z_MAX_PIN 19
- 
+
  #define E0_STEP_PIN 35
  #define E0_DIR_PIN 36
  #define E0_ENABLE_PIN 34
- 
+
  #define E1_STEP_PIN 29
  #define E1_DIR_PIN 39
  #define E1_ENABLE_PIN 28
- 
+
  #define E2_STEP_PIN 23
  #define E2_DIR_PIN 24
  #define E2_ENABLE_PIN 22
- 
+
  #define SDPOWER -1
  #define SDSS 53
  #define LED_PIN 13
- 
+
  #define FAN_PIN 7
  #define FAN2_PIN 6
  #define PS_ON_PIN 12
  #define KILL_PIN -1
- 
+
  #define HEATER_0_PIN 9 // EXTRUDER 1
  #define HEATER_1_PIN 8 // EXTRUDER 2
  #define HEATER_2_PIN -1
- 
+
  #if TEMP_SENSOR_0 == -1
    #define TEMP_0_PIN 4 // ANALOG NUMBERING
  #else
    #define TEMP_0_PIN 13 // ANALOG NUMBERING
  #endif
- 
- 
+
+
  #if TEMP_SENSOR_1 == -1
    #define TEMP_1_PIN 8 // ANALOG NUMBERING
  #else
    #define TEMP_1_PIN 15 // ANALOG NUMBERING
  #endif
- 
+
  #define TEMP_2_PIN -1 // ANALOG NUMBERING
- 
+
  #define HEATER_BED_PIN 10 // BED
- 
+
  #if TEMP_SENSOR_BED == -1
    #define TEMP_BED_PIN 8 // ANALOG NUMBERING
- #else 
+ #else
    #define TEMP_BED_PIN 14 // ANALOG NUMBERING
  #endif
- 
- #define BEEPER 64	
- 
- 
+
+ #define BEEPER 64
+
+
  #define LCD_PINS_RS 14
  #define LCD_PINS_ENABLE 15
  #define LCD_PINS_D4 30
  #define LCD_PINS_D5 31
  #define LCD_PINS_D6 32
  #define LCD_PINS_D7 33
- 
- 
+
+
  //buttons are directly attached using keypad
  #define BTN_EN1 61
  #define BTN_EN2 59
  #define BTN_ENC 43 //the click
- 
+
  #define BLEN_C 2
  #define BLEN_B 1
  #define BLEN_A 0
- 
+
  #define SDCARDDETECT -1	// Megatronics does not use this port
- 
+
    //encoder rotation values
  #define encrot0 0
  #define encrot1 2
@@ -2283,87 +2320,87 @@
 ****************************************************************************************/
 #if MOTHERBOARD == 702
  #define KNOWN_BOARD 1
- 
- 
+
+
  #ifndef __AVR_ATmega1281__
  #error Oops! Make sure you have 'Minitronics ' selected from the 'Tools -> Boards' menu.
  #endif
- 
+
  #define LARGE_FLASH        true
- 
+
  #define X_STEP_PIN 48
  #define X_DIR_PIN 47
  #define X_ENABLE_PIN 49
  #define X_MIN_PIN 5
  #define X_MAX_PIN -1 //2 //Max endstops default to disabled "-1", set to commented value to enable.
- 
+
  #define Y_STEP_PIN 39 // A6
  #define Y_DIR_PIN 40 // A0
  #define Y_ENABLE_PIN 38
  #define Y_MIN_PIN 2
  #define Y_MAX_PIN -1 //15
- 
+
  #define Z_STEP_PIN 42 // A2
  #define Z_DIR_PIN 43 // A6
  #define Z_ENABLE_PIN 41 // A1
  #define Z_MIN_PIN 6
  #define Z_MAX_PIN -1
- 
+
  #define E0_STEP_PIN 45
  #define E0_DIR_PIN 44
  #define E0_ENABLE_PIN 27
- 
+
  #define E1_STEP_PIN 36
  #define E1_DIR_PIN 35
  #define E1_ENABLE_PIN 37
- 
+
  #define E2_STEP_PIN -1
  #define E2_DIR_PIN -1
  #define E2_ENABLE_PIN -1
- 
+
  #define SDPOWER -1
  #define SDSS 16
  #define LED_PIN 46
- 
+
  #define FAN_PIN 9
  #define FAN2_PIN -1
  #define PS_ON_PIN -1
  #define KILL_PIN -1
- 
+
  #define HEATER_0_PIN 7 // EXTRUDER 1
  #define HEATER_1_PIN 8 // EXTRUDER 2
  #define HEATER_2_PIN -1
- 
+
 
  #define TEMP_0_PIN 7 // ANALOG NUMBERING
  #define TEMP_1_PIN 6 // ANALOG NUMBERING
  #define TEMP_2_PIN -1 // ANALOG NUMBERING
- 
+
  #define HEATER_BED_PIN 3 // BED
  #define TEMP_BED_PIN 6 // ANALOG NUMBERING
- 
- #define BEEPER -1	
- 
- 
+
+ #define BEEPER -1
+
+
  #define LCD_PINS_RS -1
  #define LCD_PINS_ENABLE -1
  #define LCD_PINS_D4 -1
  #define LCD_PINS_D5 -1
  #define LCD_PINS_D6 -1
  #define LCD_PINS_D7 -1
- 
- 
+
+
  //buttons are directly attached using keypad
  #define BTN_EN1 -1
  #define BTN_EN2 -1
  #define BTN_ENC -1 //the click
- 
+
  #define BLEN_C 2
  #define BLEN_B 1
  #define BLEN_A 0
- 
+
  #define SDCARDDETECT -1	// Megatronics does not use this port
- 
+
    //encoder rotation values
  #define encrot0 0
  #define encrot1 2
@@ -2389,7 +2426,7 @@
  #define X_STEP_PIN 14
  #define X_DIR_PIN 15
  #define X_ENABLE_PIN 24
- 
+
  //X endstop
  #define X_MIN_PIN 3
  #define X_MAX_PIN -1
@@ -2402,7 +2439,7 @@
  //Y endstop
  #define Y_MIN_PIN 2
  #define Y_MAX_PIN -1
- 
+
  //Z motor stepper
  #define Z_STEP_PIN 40
  #define Z_DIR_PIN 41
@@ -2411,7 +2448,7 @@
  //Z endstop
  #define Z_MIN_PIN 5
  #define Z_MAX_PIN -1
- 
+
  //Extruder 0 stepper
  #define E0_STEP_PIN 26
  #define E0_DIR_PIN 28
@@ -2438,7 +2475,7 @@
  #define HEATER_BED_PIN 22
  //Cheaptronic v1.0 hasent EXTRUDER 3
  #define HEATER_2_PIN -1
- 
+
  //Temperature sensors
  #define TEMP_0_PIN 15
  #define TEMP_1_PIN 14
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index a9da533..bfc7132 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -593,6 +593,7 @@ block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-positi
 #endif
   block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
   block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
+  block->steps_e *= volumetric_multiplier[active_extruder];
   block->steps_e *= extrudemultiply;
   block->steps_e /= 100;
   block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));
@@ -682,7 +683,7 @@ block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-positi
     delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];
   #endif
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
-  delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
+  delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*volumetric_multiplier[active_extruder]*extrudemultiply/100.0;
   if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
   {
     block->millimeters = fabs(delta_mm[E_AXIS]);
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 308ac5e..66a097d 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1190,7 +1190,7 @@ ISR(TIMER0_COMPB_vect)
 //      break;
   }
     
-  if(temp_count >= 16) // 8 ms * 16 = 128ms.
+  if(temp_count >= OVERSAMPLENR) // 8 * 16 * 1/(16000000/64/256)  = 131ms.
   {
     if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.
     {
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index acbc8d6..8961b67 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -344,7 +344,7 @@ static void lcd_babystep_x()
     }
     if (lcdDrawUpdate)
     {
-        lcd_implementation_drawedit(PSTR("Babystepping X"),"");
+        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_X),"");
     }
     if (LCD_CLICKED)
     {
@@ -364,7 +364,7 @@ static void lcd_babystep_y()
     }
     if (lcdDrawUpdate)
     {
-        lcd_implementation_drawedit(PSTR("Babystepping Y"),"");
+        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_Y),"");
     }
     if (LCD_CLICKED)
     {
@@ -384,7 +384,7 @@ static void lcd_babystep_z()
     }
     if (lcdDrawUpdate)
     {
-        lcd_implementation_drawedit(PSTR("Babystepping Z"),"");
+        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_Z),"");
     }
     if (LCD_CLICKED)
     {
@@ -415,10 +415,10 @@ static void lcd_tune_menu()
 
 #ifdef BABYSTEPPING
     #ifdef BABYSTEP_XY
-      MENU_ITEM(submenu, "Babystep X", lcd_babystep_x);
-      MENU_ITEM(submenu, "Babystep Y", lcd_babystep_y);
+      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
+      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
     #endif //BABYSTEP_XY
-    MENU_ITEM(submenu, "Babystep Z", lcd_babystep_z);
+    MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
 #endif
 #ifdef FILAMENTCHANGEENABLE
      MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));
@@ -576,12 +576,12 @@ static void lcd_move_menu_axis()
 {
     START_MENU();
     MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);
-    MENU_ITEM(submenu, "Move X", lcd_move_x);
-    MENU_ITEM(submenu, "Move Y", lcd_move_y);
+    MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
+    MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
     if (move_menu_scale < 10.0)
     {
-        MENU_ITEM(submenu, "Move Z", lcd_move_z);
-        MENU_ITEM(submenu, "Extruder", lcd_move_e);
+        MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
+        MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
     }
     END_MENU();
 }
@@ -606,9 +606,9 @@ static void lcd_move_menu()
 {
     START_MENU();
     MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
-    MENU_ITEM(submenu, "Move 10mm", lcd_move_menu_10mm);
-    MENU_ITEM(submenu, "Move 1mm", lcd_move_menu_1mm);
-    MENU_ITEM(submenu, "Move 0.1mm", lcd_move_menu_01mm);
+    MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
+    MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
+    MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
     //TODO:X,Y,Z,E
     END_MENU();
 }
@@ -708,8 +708,10 @@ static void lcd_control_temperature_preheat_abs_settings_menu()
 static void lcd_control_motion_menu()
 {
     START_MENU();
-    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
-    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
+    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+#ifdef ENABLE_AUTO_BED_LEVELING
+    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
+#endif
     MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
     MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);
     MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);
@@ -730,7 +732,7 @@ static void lcd_control_motion_menu()
     MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);
     MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);
 #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
-    MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);
+    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);
 #endif
     END_MENU();
 }
@@ -749,7 +751,7 @@ static void lcd_set_contrast()
     }
     if (lcdDrawUpdate)
     {
-        lcd_implementation_drawedit(PSTR("Contrast"), itostr2(lcd_contrast));
+        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
     }
     if (LCD_CLICKED)
     {
@@ -992,7 +994,6 @@ void lcd_init()
 #ifdef NEWPANEL
     pinMode(BTN_EN1,INPUT);
     pinMode(BTN_EN2,INPUT);
-    pinMode(SDCARDDETECT,INPUT);
     WRITE(BTN_EN1,HIGH);
     WRITE(BTN_EN2,HIGH);
   #if BTN_ENC > 0
@@ -1006,11 +1007,11 @@ void lcd_init()
     WRITE(SHIFT_OUT,HIGH);
     WRITE(SHIFT_LD,HIGH);
   #endif
-#else
-  #ifdef SR_LCD_2W_NL
+#else  // Not NEWPANEL
+  #ifdef SR_LCD_2W_NL // Non latching 2 wire shiftregister
      pinMode (SR_DATA_PIN, OUTPUT);
      pinMode (SR_CLK_PIN, OUTPUT);
-  #else
+  #elif defined(SHIFT_CLK) 
      pinMode(SHIFT_CLK,OUTPUT);
      pinMode(SHIFT_LD,OUTPUT);
      pinMode(SHIFT_EN,OUTPUT);
@@ -1018,16 +1019,21 @@ void lcd_init()
      WRITE(SHIFT_OUT,HIGH);
      WRITE(SHIFT_LD,HIGH);
      WRITE(SHIFT_EN,LOW);
-   #endif // SR_LCD_2W_NL
+  #else
+     #ifdef ULTIPANEL
+     #error ULTIPANEL requires an encoder
+     #endif
+  #endif // SR_LCD_2W_NL
 #endif//!NEWPANEL
 
-#if (SDCARDDETECT > 0)
+#if defined (SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0)
+    pinMode(SDCARDDETECT,INPUT);
     WRITE(SDCARDDETECT, HIGH);
     lcd_oldcardstatus = IS_SD_INSERTED;
 #endif//(SDCARDDETECT > 0)
-    #ifdef LCD_HAS_SLOW_BUTTONS
+#ifdef LCD_HAS_SLOW_BUTTONS
     slow_buttons = 0;
-    #endif
+#endif
     lcd_buttons_update();
 #ifdef ULTIPANEL
     encoderDiff = 0;
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index c0d4989..ccb820b 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -711,16 +711,30 @@ static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pst
 static void lcd_implementation_quick_feedback()
 {
 #ifdef LCD_USE_I2C_BUZZER
-    lcd.buzz(60,1000/6);
+	#if !defined(LCD_FEEDBACK_FREQUENCY_HZ) || !defined(LCD_FEEDBACK_FREQUENCY_DURATION_MS)
+	  lcd_buzz(1000/6,100);
+	#else
+	  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS,LCD_FEEDBACK_FREQUENCY_HZ);
+	#endif
 #elif defined(BEEPER) && BEEPER > -1
     SET_OUTPUT(BEEPER);
+	#if !defined(LCD_FEEDBACK_FREQUENCY_HZ) || !defined(LCD_FEEDBACK_FREQUENCY_DURATION_MS)
     for(int8_t i=0;i<10;i++)
     {
       WRITE(BEEPER,HIGH);
       delayMicroseconds(100);
       WRITE(BEEPER,LOW);
       delayMicroseconds(100);
-    }
+    }
+    #else
+    for(int8_t i=0;i<(LCD_FEEDBACK_FREQUENCY_DURATION_MS / (1000 / LCD_FEEDBACK_FREQUENCY_HZ));i++)
+    {
+      WRITE(BEEPER,HIGH);
+      delayMicroseconds(1000000 / LCD_FEEDBACK_FREQUENCY_HZ / 2);
+      WRITE(BEEPER,LOW);
+      delayMicroseconds(1000000 / LCD_FEEDBACK_FREQUENCY_HZ / 2);
+    }
+    #endif
 #endif
 }
 
diff --git a/Marlin/vector_3.cpp b/Marlin/vector_3.cpp
index c143e01..82b6925 100644
--- a/Marlin/vector_3.cpp
+++ b/Marlin/vector_3.cpp
@@ -22,19 +22,9 @@
 #ifdef ENABLE_AUTO_BED_LEVELING
 #include "vector_3.h"
 
-vector_3::vector_3()
-{
-  this->x = 0;
-  this->y = 0;
-  this->z = 0;
-}
+vector_3::vector_3() : x(0), y(0), z(0) { }
 
-vector_3::vector_3(float x, float y, float z)
-{
-	this->x = x;
-	this->y = y;
-	this->z = z;
-}
+vector_3::vector_3(float x_, float y_, float z_) : x(x_), y(y_), z(z_) { }
 
 vector_3 vector_3::cross(vector_3 left, vector_3 right)
 {
@@ -62,7 +52,7 @@ vector_3 vector_3::get_normal()
 
 float vector_3::get_length() 
 {
-        float length = sqrt((x * x) + (y * y) + (z * z));
+	float length = sqrt((x * x) + (y * y) + (z * z));
 	return length;
 }
  

