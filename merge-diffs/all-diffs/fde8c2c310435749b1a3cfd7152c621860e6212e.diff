commit fde8c2c310435749b1a3cfd7152c621860e6212e (from 1aa10a5f1822a6385801baaa7025e821f97c1fa6)
Merge: 1aa10a5 fdce911
Author: ErikZalm <erik@vdzalm.eu>
Date:   Tue Feb 25 18:49:41 2014 +0100

    Merge pull request #807 from Cylindric3D/typofixes_upstream5
    
    Various typo fixes #5 - only in comments, no code changes.

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 7a4b864..5998cef 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -1,5 +1,5 @@
 // Tonokip RepRap firmware rewrite based off of Hydra-mmm firmware.
-// Licence: GPL
+// License: GPL
 
 #ifndef MARLIN_H
 #define MARLIN_H
@@ -30,7 +30,7 @@
 # include "Arduino.h"
 #else
 # include "WProgram.h"
-  //Arduino < 1.0.0 does not define this, so we need to do it ourselfs
+  //Arduino < 1.0.0 does not define this, so we need to do it ourselves
 # define analogInputToDigitalPin(p) ((p) + A0)
 #endif
 
@@ -87,7 +87,7 @@ void serial_echopair_P(const char *s_P, double v);
 void serial_echopair_P(const char *s_P, unsigned long v);
 
 
-//things to write to serial from Programmemory. saves 400 to 2k of RAM.
+//Things to write to serial from Program memory. Saves 400 to 2k of RAM.
 FORCE_INLINE void serialprintPGM(const char *str)
 {
   char ch=pgm_read_byte(str);
@@ -184,8 +184,8 @@ void Stop();
 
 bool IsStopped();
 
-void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.
-void enquecommand_P(const char *cmd); //put an ascii command at the end of the current buffer, read from flash
+void enquecommand(const char *cmd); //put an ASCII command at the end of the current buffer.
+void enquecommand_P(const char *cmd); //put an ASCII command at the end of the current buffer, read from flash
 void prepare_arc_move(char isclockwise);
 void clamp_to_software_endstops(float target[3]);
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 9fe6411..13f8615 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -63,7 +63,7 @@
 
 #define VERSION_STRING  "1.0.0"
 
-// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
+// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html
 // http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
 
 //Implemented Codes
@@ -80,7 +80,7 @@
 // G30 - Single Z Probe, probes bed at current XY location.
 // G90 - Use Absolute Coordinates
 // G91 - Use Relative Coordinates
-// G92 - Set current position to cordinates given
+// G92 - Set current position to coordinates given
 
 // M Codes
 // M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
@@ -101,7 +101,7 @@
 // M31  - Output time since last M109 or SD card start to serial
 // M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
 //        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
-//        Call gcode file : "M32 P !filename#" and return to caller file after finishing (simiarl to #include).
+//        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
 //        The '#' is necessary when calling from within sd files, as it stops buffer prereading
 // M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
 // M80  - Turn on Power Supply
@@ -127,18 +127,18 @@
 // M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 // M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 // M140 - Set bed target temp
-// M150 - Set BlinkM Colour Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
+// M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
 // M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 //        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
 // M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
 // M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 // M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 // M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
 // M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-// M206 - set additional homeing offset
+// M206 - set additional homing offset
 // M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
-// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
+// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
 // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 // M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 // M220 S<factor in percent>- set speed factor override percentage
@@ -147,7 +147,7 @@
 // M240 - Trigger a camera to take a photograph
 // M250 - Set LCD contrast C<contrast value> (value 0..63)
 // M280 - set servo position absolute. P: servo index, S: angle or microseconds
-// M300 - Play beepsound S<frequency Hz> P<duration ms>
+// M300 - Play beep sound S<frequency Hz> P<duration ms>
 // M301 - Set PID parameters P I and D
 // M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
 // M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
@@ -155,13 +155,13 @@
 // M400 - Finish all moves
 // M401 - Lower z-probe if present
 // M402 - Raise z-probe if present
-// M500 - stores paramters in EEPROM
+// M500 - stores parameters in EEPROM
 // M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-// M503 - print the current settings (from memory not from eeprom)
+// M503 - print the current settings (from memory not from EEPROM)
 // M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
 // M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
-// M666 - set delta endstop adjustemnt
+// M666 - set delta endstop adjustment
 // M605 - Set dual x-carriage movement mode: S<mode> [ X<duplication x-offset> R<duplication temp offset> ]
 // M907 - Set digital trimpot motor current using axis codes.
 // M908 - Control digital trimpot directly.
@@ -254,7 +254,7 @@ float delta[3] = {0.0, 0.0, 0.0};
 
 
 //===========================================================================
-//=============================private variables=============================
+//=============================Private Variables=============================
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
@@ -274,7 +274,7 @@ static int buflen = 0;
 static char serial_char;
 static int serial_count = 0;
 static boolean comment_mode = false;
-static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc
+static char *strchr_pointer; // just a pointer to find chars in the command string like X, Y, Z, E, etc
 
 const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42
 
@@ -302,7 +302,7 @@ bool CooldownNoWait = true;
 bool target_direction;
 
 //===========================================================================
-//=============================ROUTINES=============================
+//=============================Routines======================================
 //===========================================================================
 
 void get_arc_coordinates();
@@ -339,7 +339,7 @@ void enquecommand(const char *cmd)
 {
   if(buflen < BUFSIZE)
   {
-    //this is dangerous if a mixing of serial and this happsens
+    //this is dangerous if a mixing of serial and this happens
     strcpy(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("enqueing \"");
@@ -354,7 +354,7 @@ void enquecommand_P(const char *cmd)
 {
   if(buflen < BUFSIZE)
   {
-    //this is dangerous if a mixing of serial and this happsens
+    //this is dangerous if a mixing of serial and this happens
     strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("enqueing \"");
@@ -661,9 +661,9 @@ void get_command()
     return;
   }
 
-  //'#' stops reading from sd to the buffer prematurely, so procedural macro calls are possible
-  // if it occures, stop_buffering is triggered and the buffer is ran dry.
-  // this character _can_ occure in serial com, due to checksums. however, no checksums are used in sd printing
+  //'#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible
+  // if it occurs, stop_buffering is triggered and the buffer is ran dry.
+  // this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing
 
   static bool stop_buffering=false;
   if(buflen==0) stop_buffering=false;
diff --git a/Marlin/qr_solve.cpp b/Marlin/qr_solve.cpp
index 55dcf64..f19d989 100644
--- a/Marlin/qr_solve.cpp
+++ b/Marlin/qr_solve.cpp
@@ -1171,7 +1171,7 @@ void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[],
 
   Discussion:
 
-    DQRLSS must be preceeded by a call to DQRANK.
+    DQRLSS must be preceded by a call to DQRANK.
 
     The system is to be solved is
       A * X = B
@@ -1223,7 +1223,7 @@ void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[],
     linear system.
 
     Output, double RSD[M], the residual, B - A*X.  RSD may
-    overwite B.
+    overwrite B.
 
     Input, int JPVT[N], the pivot information from DQRANK.
     Columns JPVT[0], ..., JPVT[KR-1] of the original matrix are linearly
@@ -1312,7 +1312,7 @@ int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[],
     can be replaced by dummy variables in the calling program.
     To save storage, the user may in some cases use the same
     array for different parameters in the calling sequence.  A
-    frequently occuring example is when one wishes to compute
+    frequently occurring example is when one wishes to compute
     any of B, RSD, or AB and does not need Y or QTY.  In this
     case one may identify Y, QTY, and one of B, RSD, or AB, while
     providing separate arrays for anything else that is to be

commit fde8c2c310435749b1a3cfd7152c621860e6212e (from fdce91192eeea86b9e46aef7141c336836ceb047)
Merge: 1aa10a5 fdce911
Author: ErikZalm <erik@vdzalm.eu>
Date:   Tue Feb 25 18:49:41 2014 +0100

    Merge pull request #807 from Cylindric3D/typofixes_upstream5
    
    Various typo fixes #5 - only in comments, no code changes.

diff --git a/Marlin/Servo.h b/Marlin/Servo.h
index 35e040c..204497a 100644
--- a/Marlin/Servo.h
+++ b/Marlin/Servo.h
@@ -24,7 +24,7 @@
 
   Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
   Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.
-  The sequence used to sieze timers is defined in timers.h
+  The sequence used to seize timers is defined in timers.h
 
   The methods are:
 
@@ -50,7 +50,7 @@
 /*
  * Defines for 16 bit timers used with  Servo library
  *
- * If _useTimerX is defined then TimerX is a 16 bit timer on the curent board
+ * If _useTimerX is defined then TimerX is a 16 bit timer on the current board
  * timer16_Sequence_t enumerates the sequence that the timers should be allocated
  * _Nbr_16timers indicates how many 16 bit timers are available.
  *
@@ -89,12 +89,12 @@ typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;
 typedef enum { _Nbr_16timers } timer16_Sequence_t ;
 #endif
 
-#define Servo_VERSION           2      // software version of this library
+#define Servo_VERSION           2     // software version of this library
 
 #define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo
 #define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo
 #define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
-#define REFRESH_INTERVAL    20000     // minumim time to refresh servos in microseconds
+#define REFRESH_INTERVAL    20000     // minimum time to refresh servos in microseconds
 
 #define SERVOS_PER_TIMER       12     // the maximum number of servos controlled by one timer
 #define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)
@@ -118,13 +118,13 @@ public:
   uint8_t attach(int pin);           // attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure
   uint8_t attach(int pin, int min, int max); // as above but also sets min and max values for writes.
   void detach();
-  void write(int value);             // if value is < 200 its treated as an angle, otherwise as pulse width in microseconds
+  void write(int value);             // if value is < 200 it is treated as an angle, otherwise as pulse width in microseconds
   void writeMicroseconds(int value); // Write pulse width in microseconds
   int read();                        // returns current pulse width as an angle between 0 and 180 degrees
   int readMicroseconds();            // returns current pulse width in microseconds for this servo (was read_us() in first release)
   bool attached();                   // return true if this servo is attached, otherwise false
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
-  int pin;                           // store the hw pin of the servo
+  int pin;                           // store the hardware pin of the servo
 #endif
 private:
    uint8_t servoIndex;               // index into the channel data for this servo
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index a969d56..53f8221 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -1,5 +1,5 @@
 /*
-  This code contibuted by Triffid_Hunter and modified by Kliment
+  This code contributed by Triffid_Hunter and modified by Kliment
   why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
 */
 
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 3a1cb0b..1477a6e 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -71,8 +71,8 @@ float st_get_position_mm(uint8_t axis);
 void st_wake_up();
 
   
-void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered
-void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();
+void checkHitEndstops(); //call from somewhere to create an serial error message with the locations the endstops where hit, in case they were triggered
+void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homing and before a routine call of checkHitEndstops();
 
 void enable_endstops(bool check); // Enable/disable endstop checking
 
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 82de240..a8580de 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -28,7 +28,7 @@
 #endif
 
 // public functions
-void tp_init();  //initialise the heating
+void tp_init();  //initialize the heating
 void manage_heater(); //it is critical that this is called periodically.
 
 // low level conversion routines

