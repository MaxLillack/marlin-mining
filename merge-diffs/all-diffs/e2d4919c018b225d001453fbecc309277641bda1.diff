commit e2d4919c018b225d001453fbecc309277641bda1 (from 4a212f707b6bd9b6014f28914f2e9e6e1bfb9015)
Merge: 4a212f7 72c6f29
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 9 20:57:01 2016 -0700

    Merge pull request #3991 from thinkyhead/rc_axis_units
    
    Rename some vars to clarify their relationship to acceleration

diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index 74e0d1c..ac15968 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -420,7 +420,7 @@
    */
   #if ENABLED(ADVANCE)
     #define EXTRUSION_AREA (0.25 * (D_FILAMENT) * (D_FILAMENT) * M_PI)
-    #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS] / (EXTRUSION_AREA))
+    #define STEPS_PER_CUBIC_MM_E (axis_steps_per_mm[E_AXIS] / (EXTRUSION_AREA))
   #endif
 
   #if ENABLED(ULTIPANEL) && DISABLED(ELB_FULL_GRAPHIC_CONTROLLER)
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 7142d96..73c7478 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -155,7 +155,7 @@
  * M84  - Disable steppers until next move,
  *        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
- * M92  - Set planner.axis_steps_per_unit - same syntax as G92
+ * M92  - Set planner.axis_steps_per_mm - same syntax as G92
  * M104 - Set extruder target temp
  * M105 - Read current temp
  * M106 - Fan on
@@ -1683,7 +1683,7 @@ static void setup_for_endstop_move() {
        * is not where we said to go.
        */
       long stop_steps = stepper.position(Z_AXIS);
-      float mm = start_z - float(start_steps - stop_steps) / planner.axis_steps_per_unit[Z_AXIS];
+      float mm = start_z - float(start_steps - stop_steps) / planner.axis_steps_per_mm[Z_AXIS];
       current_position[Z_AXIS] = mm;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -5155,15 +5155,15 @@ inline void gcode_M92() {
       if (i == E_AXIS) {
         float value = code_value_per_axis_unit(i);
         if (value < 20.0) {
-          float factor = planner.axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
+          float factor = planner.axis_steps_per_mm[i] / value; // increase e constants if M92 E14 is given for netfab.
           planner.max_e_jerk *= factor;
           planner.max_feedrate[i] *= factor;
-          planner.axis_steps_per_sqr_second[i] *= factor;
+          planner.max_acceleration_steps_per_s2[i] *= factor;
         }
-        planner.axis_steps_per_unit[i] = value;
+        planner.axis_steps_per_mm[i] = value;
       }
       else {
-        planner.axis_steps_per_unit[i] = code_value_per_axis_unit(i);
+        planner.axis_steps_per_mm[i] = code_value_per_axis_unit(i);
       }
     }
   }
@@ -5198,9 +5198,9 @@ static void report_current_position() {
     SERIAL_EOL;
 
     SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
-    SERIAL_PROTOCOL(delta[X_AXIS] / 90 * planner.axis_steps_per_unit[X_AXIS]);
+    SERIAL_PROTOCOL(delta[X_AXIS] / 90 * planner.axis_steps_per_mm[X_AXIS]);
     SERIAL_PROTOCOLPGM("   Psi+Theta:");
-    SERIAL_PROTOCOL((delta[Y_AXIS] - delta[X_AXIS]) / 90 * planner.axis_steps_per_unit[Y_AXIS]);
+    SERIAL_PROTOCOL((delta[Y_AXIS] - delta[X_AXIS]) / 90 * planner.axis_steps_per_mm[Y_AXIS]);
     SERIAL_EOL; SERIAL_EOL;
   #endif
 }
@@ -5345,7 +5345,7 @@ inline void gcode_M200() {
 inline void gcode_M201() {
   for (int8_t i = 0; i < NUM_AXIS; i++) {
     if (code_seen(axis_codes[i])) {
-      planner.max_acceleration_units_per_sq_second[i] = code_value_axis_units(i);
+      planner.max_acceleration_mm_per_s2[i] = code_value_axis_units(i);
     }
   }
   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
@@ -5355,7 +5355,7 @@ inline void gcode_M201() {
 #if 0 // Not used for Sprinter/grbl gen6
   inline void gcode_M202() {
     for (int8_t i = 0; i < NUM_AXIS; i++) {
-      if (code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value_axis_units(i) * planner.axis_steps_per_unit[i];
+      if (code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value_axis_units(i) * planner.axis_steps_per_mm[i];
     }
   }
 #endif
@@ -8226,8 +8226,8 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
         }
         float oldepos = current_position[E_AXIS], oldedes = destination[E_AXIS];
         planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
-                         destination[E_AXIS] + (EXTRUDER_RUNOUT_EXTRUDE) * (EXTRUDER_RUNOUT_ESTEPS) / planner.axis_steps_per_unit[E_AXIS],
-                         (EXTRUDER_RUNOUT_SPEED) / 60. * (EXTRUDER_RUNOUT_ESTEPS) / planner.axis_steps_per_unit[E_AXIS], active_extruder);
+                         destination[E_AXIS] + (EXTRUDER_RUNOUT_EXTRUDE) * (EXTRUDER_RUNOUT_ESTEPS) / planner.axis_steps_per_mm[E_AXIS],
+                         (EXTRUDER_RUNOUT_SPEED) / 60. * (EXTRUDER_RUNOUT_ESTEPS) / planner.axis_steps_per_mm[E_AXIS], active_extruder);
       current_position[E_AXIS] = oldepos;
       destination[E_AXIS] = oldedes;
       planner.set_e_position_mm(oldepos);
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index 977fd31..1307631 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -43,9 +43,9 @@
  *
  *  100  Version (char x4)
  *
- *  104  M92 XYZE  planner.axis_steps_per_unit (float x4)
+ *  104  M92 XYZE  planner.axis_steps_per_mm (float x4)
  *  120  M203 XYZE planner.max_feedrate (float x4)
- *  136  M201 XYZE planner.max_acceleration_units_per_sq_second (uint32_t x4)
+ *  136  M201 XYZE planner.max_acceleration_mm_per_s2 (uint32_t x4)
  *  152  M204 P    planner.acceleration (float)
  *  156  M204 R    planner.retract_acceleration (float)
  *  160  M204 T    planner.travel_acceleration (float)
@@ -173,9 +173,9 @@ void Config_StoreSettings()  {
   char ver[4] = "000";
   int i = EEPROM_OFFSET;
   EEPROM_WRITE_VAR(i, ver); // invalidate data first
-  EEPROM_WRITE_VAR(i, planner.axis_steps_per_unit);
+  EEPROM_WRITE_VAR(i, planner.axis_steps_per_mm);
   EEPROM_WRITE_VAR(i, planner.max_feedrate);
-  EEPROM_WRITE_VAR(i, planner.max_acceleration_units_per_sq_second);
+  EEPROM_WRITE_VAR(i, planner.max_acceleration_mm_per_s2);
   EEPROM_WRITE_VAR(i, planner.acceleration);
   EEPROM_WRITE_VAR(i, planner.retract_acceleration);
   EEPROM_WRITE_VAR(i, planner.travel_acceleration);
@@ -353,9 +353,9 @@ void Config_RetrieveSettings() {
     float dummy = 0;
 
     // version number match
-    EEPROM_READ_VAR(i, planner.axis_steps_per_unit);
+    EEPROM_READ_VAR(i, planner.axis_steps_per_mm);
     EEPROM_READ_VAR(i, planner.max_feedrate);
-    EEPROM_READ_VAR(i, planner.max_acceleration_units_per_sq_second);
+    EEPROM_READ_VAR(i, planner.max_acceleration_mm_per_s2);
 
     // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
     planner.reset_acceleration_rates();
@@ -527,9 +527,9 @@ void Config_ResetDefault() {
   float tmp2[] = DEFAULT_MAX_FEEDRATE;
   long tmp3[] = DEFAULT_MAX_ACCELERATION;
   for (uint8_t i = 0; i < NUM_AXIS; i++) {
-    planner.axis_steps_per_unit[i] = tmp1[i];
+    planner.axis_steps_per_mm[i] = tmp1[i];
     planner.max_feedrate[i] = tmp2[i];
-    planner.max_acceleration_units_per_sq_second[i] = tmp3[i];
+    planner.max_acceleration_mm_per_s2[i] = tmp3[i];
     #if ENABLED(SCARA)
       if (i < COUNT(axis_scaling))
         axis_scaling[i] = 1;
@@ -652,10 +652,10 @@ void Config_PrintSettings(bool forReplay) {
     SERIAL_ECHOLNPGM("Steps per unit:");
     CONFIG_ECHO_START;
   }
-  SERIAL_ECHOPAIR("  M92 X", planner.axis_steps_per_unit[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", planner.axis_steps_per_unit[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", planner.axis_steps_per_unit[Z_AXIS]);
-  SERIAL_ECHOPAIR(" E", planner.axis_steps_per_unit[E_AXIS]);
+  SERIAL_ECHOPAIR("  M92 X", planner.axis_steps_per_mm[X_AXIS]);
+  SERIAL_ECHOPAIR(" Y", planner.axis_steps_per_mm[Y_AXIS]);
+  SERIAL_ECHOPAIR(" Z", planner.axis_steps_per_mm[Z_AXIS]);
+  SERIAL_ECHOPAIR(" E", planner.axis_steps_per_mm[E_AXIS]);
   SERIAL_EOL;
 
   CONFIG_ECHO_START;
@@ -687,10 +687,10 @@ void Config_PrintSettings(bool forReplay) {
     SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
     CONFIG_ECHO_START;
   }
-  SERIAL_ECHOPAIR("  M201 X", planner.max_acceleration_units_per_sq_second[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", planner.max_acceleration_units_per_sq_second[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", planner.max_acceleration_units_per_sq_second[Z_AXIS]);
-  SERIAL_ECHOPAIR(" E", planner.max_acceleration_units_per_sq_second[E_AXIS]);
+  SERIAL_ECHOPAIR("  M201 X", planner.max_acceleration_mm_per_s2[X_AXIS]);
+  SERIAL_ECHOPAIR(" Y", planner.max_acceleration_mm_per_s2[Y_AXIS]);
+  SERIAL_ECHOPAIR(" Z", planner.max_acceleration_mm_per_s2[Z_AXIS]);
+  SERIAL_ECHOPAIR(" E", planner.max_acceleration_mm_per_s2[E_AXIS]);
   SERIAL_EOL;
   CONFIG_ECHO_START;
   if (!forReplay) {
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index d5e8312..bd60d75 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -81,9 +81,9 @@ volatile uint8_t Planner::block_buffer_head = 0;           // Index of the next
 volatile uint8_t Planner::block_buffer_tail = 0;
 
 float Planner::max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
-float Planner::axis_steps_per_unit[NUM_AXIS];
-unsigned long Planner::axis_steps_per_sqr_second[NUM_AXIS];
-unsigned long Planner::max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
+float Planner::axis_steps_per_mm[NUM_AXIS];
+unsigned long Planner::max_acceleration_steps_per_s2[NUM_AXIS];
+unsigned long Planner::max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
 
 millis_t Planner::min_segment_time;
 float Planner::min_feedrate;
@@ -155,7 +155,7 @@ void Planner::calculate_trapezoid_for_block(block_t* block, float entry_factor,
   NOLESS(initial_rate, 120);
   NOLESS(final_rate, 120);
 
-  long accel = block->acceleration_st;
+  long accel = block->acceleration_steps_per_s2;
   int32_t accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel));
   int32_t decelerate_steps = floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
 
@@ -549,10 +549,10 @@ void Planner::check_axes_activity() {
   // Calculate target position in absolute steps
   //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
   long target[NUM_AXIS] = {
-    lround(x * axis_steps_per_unit[X_AXIS]),
-    lround(y * axis_steps_per_unit[Y_AXIS]),
-    lround(z * axis_steps_per_unit[Z_AXIS]),
-    lround(e * axis_steps_per_unit[E_AXIS])
+    lround(x * axis_steps_per_mm[X_AXIS]),
+    lround(y * axis_steps_per_mm[Y_AXIS]),
+    lround(z * axis_steps_per_mm[Z_AXIS]),
+    lround(e * axis_steps_per_mm[E_AXIS])
   };
 
   long dx = target[X_AXIS] - position[X_AXIS],
@@ -574,7 +574,7 @@ void Planner::check_axes_activity() {
         SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
       }
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (labs(de) > axis_steps_per_unit[E_AXIS] * (EXTRUDE_MAXLENGTH)) {
+        if (labs(de) > axis_steps_per_mm[E_AXIS] * (EXTRUDE_MAXLENGTH)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START;
@@ -771,31 +771,31 @@ void Planner::check_axes_activity() {
   #if ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ)
     float delta_mm[6];
     #if ENABLED(COREXY)
-      delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];
-      delta_mm[Y_HEAD] = dy / axis_steps_per_unit[B_AXIS];
-      delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];
-      delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_unit[A_AXIS];
-      delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_unit[B_AXIS];
+      delta_mm[X_HEAD] = dx / axis_steps_per_mm[A_AXIS];
+      delta_mm[Y_HEAD] = dy / axis_steps_per_mm[B_AXIS];
+      delta_mm[Z_AXIS] = dz / axis_steps_per_mm[Z_AXIS];
+      delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_mm[A_AXIS];
+      delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_mm[B_AXIS];
     #elif ENABLED(COREXZ)
-      delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];
-      delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];
-      delta_mm[Z_HEAD] = dz / axis_steps_per_unit[C_AXIS];
-      delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_unit[A_AXIS];
-      delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_unit[C_AXIS];
+      delta_mm[X_HEAD] = dx / axis_steps_per_mm[A_AXIS];
+      delta_mm[Y_AXIS] = dy / axis_steps_per_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dz / axis_steps_per_mm[C_AXIS];
+      delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_mm[A_AXIS];
+      delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_mm[C_AXIS];
     #elif ENABLED(COREYZ)
-      delta_mm[X_AXIS] = dx / axis_steps_per_unit[A_AXIS];
-      delta_mm[Y_HEAD] = dy / axis_steps_per_unit[Y_AXIS];
-      delta_mm[Z_HEAD] = dz / axis_steps_per_unit[C_AXIS];
-      delta_mm[B_AXIS] = (dy + dz) / axis_steps_per_unit[B_AXIS];
-      delta_mm[C_AXIS] = (dy - dz) / axis_steps_per_unit[C_AXIS];
+      delta_mm[X_AXIS] = dx / axis_steps_per_mm[A_AXIS];
+      delta_mm[Y_HEAD] = dy / axis_steps_per_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dz / axis_steps_per_mm[C_AXIS];
+      delta_mm[B_AXIS] = (dy + dz) / axis_steps_per_mm[B_AXIS];
+      delta_mm[C_AXIS] = (dy - dz) / axis_steps_per_mm[C_AXIS];
     #endif
   #else
     float delta_mm[4];
-    delta_mm[X_AXIS] = dx / axis_steps_per_unit[X_AXIS];
-    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];
-    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];
+    delta_mm[X_AXIS] = dx / axis_steps_per_mm[X_AXIS];
+    delta_mm[Y_AXIS] = dy / axis_steps_per_mm[Y_AXIS];
+    delta_mm[Z_AXIS] = dz / axis_steps_per_mm[Z_AXIS];
   #endif
-  delta_mm[E_AXIS] = (de / axis_steps_per_unit[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;
+  delta_mm[E_AXIS] = (de / axis_steps_per_mm[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;
 
   if (block->steps[X_AXIS] <= dropsegments && block->steps[Y_AXIS] <= dropsegments && block->steps[Z_AXIS] <= dropsegments) {
     block->millimeters = fabs(delta_mm[E_AXIS]);
@@ -936,27 +936,27 @@ void Planner::check_axes_activity() {
   float steps_per_mm = block->step_event_count / block->millimeters;
   long bsx = block->steps[X_AXIS], bsy = block->steps[Y_AXIS], bsz = block->steps[Z_AXIS], bse = block->steps[E_AXIS];
   if (bsx == 0 && bsy == 0 && bsz == 0) {
-    block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    block->acceleration_steps_per_s2 = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
   else if (bse == 0) {
-    block->acceleration_st = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    block->acceleration_steps_per_s2 = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
   else {
-    block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    block->acceleration_steps_per_s2 = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
   // Limit acceleration per axis
-  unsigned long acc_st = block->acceleration_st,
-                xsteps = axis_steps_per_sqr_second[X_AXIS],
-                ysteps = axis_steps_per_sqr_second[Y_AXIS],
-                zsteps = axis_steps_per_sqr_second[Z_AXIS],
-                esteps = axis_steps_per_sqr_second[E_AXIS],
+  unsigned long acc_st = block->acceleration_steps_per_s2,
+                x_acc_st = max_acceleration_steps_per_s2[X_AXIS],
+                y_acc_st = max_acceleration_steps_per_s2[Y_AXIS],
+                z_acc_st = max_acceleration_steps_per_s2[Z_AXIS],
+                e_acc_st = max_acceleration_steps_per_s2[E_AXIS],
                 allsteps = block->step_event_count;
-  if (xsteps < (acc_st * bsx) / allsteps) acc_st = (xsteps * allsteps) / bsx;
-  if (ysteps < (acc_st * bsy) / allsteps) acc_st = (ysteps * allsteps) / bsy;
-  if (zsteps < (acc_st * bsz) / allsteps) acc_st = (zsteps * allsteps) / bsz;
-  if (esteps < (acc_st * bse) / allsteps) acc_st = (esteps * allsteps) / bse;
+  if (x_acc_st < (acc_st * bsx) / allsteps) acc_st = (x_acc_st * allsteps) / bsx;
+  if (y_acc_st < (acc_st * bsy) / allsteps) acc_st = (y_acc_st * allsteps) / bsy;
+  if (z_acc_st < (acc_st * bsz) / allsteps) acc_st = (z_acc_st * allsteps) / bsz;
+  if (e_acc_st < (acc_st * bse) / allsteps) acc_st = (e_acc_st * allsteps) / bse;
 
-  block->acceleration_st = acc_st;
+  block->acceleration_steps_per_s2 = acc_st;
   block->acceleration = acc_st / steps_per_mm;
   block->acceleration_rate = (long)(acc_st * 16777216.0 / (F_CPU / 8.0));
 
@@ -1057,7 +1057,7 @@ void Planner::check_axes_activity() {
       block->advance = 0;
     }
     else {
-      long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
+      long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_steps_per_s2);
       float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * (cse * cse * (EXTRUSION_AREA) * (EXTRUSION_AREA)) * 256;
       block->advance = advance;
       block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
@@ -1127,10 +1127,10 @@ void Planner::check_axes_activity() {
       apply_rotation_xyz(bed_level_matrix, x, y, z);
     #endif
 
-    long nx = position[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]),
-         ny = position[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]),
-         nz = position[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]),
-         ne = position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);
+    long nx = position[X_AXIS] = lround(x * axis_steps_per_mm[X_AXIS]),
+         ny = position[Y_AXIS] = lround(y * axis_steps_per_mm[Y_AXIS]),
+         nz = position[Z_AXIS] = lround(z * axis_steps_per_mm[Z_AXIS]),
+         ne = position[E_AXIS] = lround(e * axis_steps_per_mm[E_AXIS]);
     stepper.set_position(nx, ny, nz, ne);
     previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
 
@@ -1141,14 +1141,14 @@ void Planner::check_axes_activity() {
  * Directly set the planner E position (hence the stepper E position).
  */
 void Planner::set_e_position_mm(const float& e) {
-  position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);
+  position[E_AXIS] = lround(e * axis_steps_per_mm[E_AXIS]);
   stepper.set_e_position(position[E_AXIS]);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   for (int i = 0; i < NUM_AXIS; i++)
-    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
+    max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
 }
 
 #if ENABLED(AUTOTEMP)
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 48773c5..07de371 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -58,9 +58,9 @@ typedef struct {
   long steps[NUM_AXIS];                     // Step count along each axis
   unsigned long step_event_count;           // The number of step events required to complete this block
 
-  long accelerate_until;                    // The index of the step event on which to stop acceleration
-  long decelerate_after;                    // The index of the step event on which to start decelerating
-  long acceleration_rate;                   // The acceleration rate used for acceleration calculation
+  long accelerate_until,                    // The index of the step event on which to stop acceleration
+       decelerate_after,                    // The index of the step event on which to start decelerating
+       acceleration_rate;                   // The acceleration rate used for acceleration calculation
 
   unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
@@ -72,27 +72,26 @@ typedef struct {
   #endif
 
   // Fields used by the motion planner to manage acceleration
-  float nominal_speed;                               // The nominal speed for this block in mm/sec
-  float entry_speed;                                 // Entry speed at previous-current junction in mm/sec
-  float max_entry_speed;                             // Maximum allowable junction entry speed in mm/sec
-  float millimeters;                                 // The total travel of this block in mm
-  float acceleration;                                // acceleration mm/sec^2
-  unsigned char recalculate_flag;                    // Planner flag to recalculate trapezoids on entry junction
-  unsigned char nominal_length_flag;                 // Planner flag for nominal speed always reached
+  float nominal_speed,                               // The nominal speed for this block in mm/sec
+        entry_speed,                                 // Entry speed at previous-current junction in mm/sec
+        max_entry_speed,                             // Maximum allowable junction entry speed in mm/sec
+        millimeters,                                 // The total travel of this block in mm
+        acceleration;                                // acceleration mm/sec^2
+  unsigned char recalculate_flag,                    // Planner flag to recalculate trapezoids on entry junction
+                nominal_length_flag;                 // Planner flag for nominal speed always reached
 
   // Settings for the trapezoid generator
-  unsigned long nominal_rate;                        // The nominal step rate for this block in step_events/sec
-  unsigned long initial_rate;                        // The jerk-adjusted step rate at start of block
-  unsigned long final_rate;                          // The minimal rate at exit
-  unsigned long acceleration_st;                     // acceleration steps/sec^2
+  unsigned long nominal_rate,                        // The nominal step rate for this block in step_events/sec
+                initial_rate,                        // The jerk-adjusted step rate at start of block
+                final_rate,                          // The minimal rate at exit
+                acceleration_steps_per_s2;           // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
     unsigned long fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
-    unsigned long valve_pressure;
-    unsigned long e_to_p_pressure;
+    unsigned long valve_pressure, e_to_p_pressure;
   #endif
 
   volatile char busy;
@@ -113,9 +112,9 @@ class Planner {
     static volatile uint8_t block_buffer_tail;
 
     static float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
-    static float axis_steps_per_unit[NUM_AXIS];
-    static unsigned long axis_steps_per_sqr_second[NUM_AXIS];
-    static unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
+    static float axis_steps_per_mm[NUM_AXIS];
+    static unsigned long max_acceleration_steps_per_s2[NUM_AXIS];
+    static unsigned long max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
 
     static millis_t min_segment_time;
     static float min_feedrate;
@@ -135,7 +134,7 @@ class Planner {
 
     /**
      * The current position of the tool in absolute steps
-     * Reclculated if any axis_steps_per_unit are changed by gcode
+     * Reclculated if any axis_steps_per_mm are changed by gcode
      */
     static long position[NUM_AXIS];
 
@@ -213,7 +212,7 @@ class Planner {
        * Set the planner.position and individual stepper positions.
        * Used by G92, G28, G29, and other procedures.
        *
-       * Multiplies by axis_steps_per_unit[] and does necessary conversion
+       * Multiplies by axis_steps_per_mm[] and does necessary conversion
        * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
        *
        * Clears previous speed values.
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 7695e3c..f8e8a85 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -754,7 +754,7 @@ float Stepper::get_axis_position_mm(AxisEnum axis) {
   #else
     axis_steps = position(axis);
   #endif
-  return axis_steps / planner.axis_steps_per_unit[axis];
+  return axis_steps / planner.axis_steps_per_mm[axis];
 }
 
 void Stepper::finish_and_disable() {
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 13c753f..1aebe36 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -243,7 +243,7 @@ class Stepper {
     // Triggered position of an axis in mm (not core-savvy)
     //
     static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
-      return endstops_trigsteps[axis] / planner.axis_steps_per_unit[axis];
+      return endstops_trigsteps[axis] / planner.axis_steps_per_mm[axis];
     }
 
   private:
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index bb6e1e6..1d6db5c 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -559,7 +559,7 @@ float Temperature::get_pid_output(int e) {
               lpq[lpq_ptr++] = 0;
             }
             if (lpq_ptr >= lpq_len) lpq_ptr = 0;
-            cTerm[_CTERM_INDEX] = (lpq[lpq_ptr] / planner.axis_steps_per_unit[E_AXIS]) * PID_PARAM(Kc, e);
+            cTerm[_CTERM_INDEX] = (lpq[lpq_ptr] / planner.axis_steps_per_mm[E_AXIS]) * PID_PARAM(Kc, e);
             pid_output += cTerm[e];
           }
         #endif //PID_ADD_EXTRUSION_RATE
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 0838c76..6f19ce5 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1686,20 +1686,20 @@ static void lcd_control_motion_menu() {
   MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate[E_AXIS], 1, 999);
   MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate, 0, 999);
   MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate, 0, 999);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_units_per_sq_second[Z_AXIS], 10, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, _reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
   MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
   MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
-  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &planner.axis_steps_per_unit[X_AXIS], 5, 9999);
-  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &planner.axis_steps_per_unit[Y_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999);
   #if ENABLED(DELTA)
-    MENU_ITEM_EDIT(float52, MSG_ZSTEPS, &planner.axis_steps_per_unit[Z_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float52, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
   #else
-    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &planner.axis_steps_per_unit[Z_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
   #endif
-  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &planner.axis_steps_per_unit[E_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999);
   #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
     MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
   #endif

commit e2d4919c018b225d001453fbecc309277641bda1 (from 72c6f2923f6495ca59d3c4431838200b038042f2)
Merge: 4a212f7 72c6f29
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 9 20:57:01 2016 -0700

    Merge pull request #3991 from thinkyhead/rc_axis_units
    
    Rename some vars to clarify their relationship to acceleration

diff --git a/.travis.yml b/.travis.yml
index 088f1c5..2464091 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -121,8 +121,28 @@ script:
   - opt_enable_adv DUAL_X_CARRIAGE
   - build_marlin
   #
+  # Test SPEAKER with BOARD_BQ_ZUM_MEGA_3D and BQ_LCD_SMART_CONTROLLER
+  #
+  - restore_configs
+  - opt_set MOTHERBOARD BOARD_BQ_ZUM_MEGA_3D
+  - opt_set LCD_FEEDBACK_FREQUENCY_DURATION_MS 10
+  - opt_set LCD_FEEDBACK_FREQUENCY_HZ 100
+  - opt_enable BQ_LCD_SMART_CONTROLLER SPEAKER
+  - build_marlin
+  #
   ### LCDS ###
   #
+  # ULTRA_LCD
+  #
+  - restore_configs
+  - opt_enable ULTRA_LCD
+  - build_marlin
+  #
+  # DOGLCD
+  #
+  - restore_configs
+  - opt_enable DOGLCD
+  - build_marlin
   #
   # ULTIMAKERCONTROLLER
   #
diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index fa780f2..ac15968 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -43,8 +43,7 @@
 #endif
 
 #ifndef CONFIGURATION_LCD // Get the LCD defines which are needed first
-
-  #define CONFIGURATION_LCD
+#define CONFIGURATION_LCD
 
   #define LCD_HAS_DIRECTIONAL_BUTTONS (BUTTON_EXISTS(UP) || BUTTON_EXISTS(DWN) || BUTTON_EXISTS(LFT) || BUTTON_EXISTS(RT))
 
@@ -154,11 +153,6 @@
       #define ENCODER_STEPS_PER_MENU_ITEM 1
     #endif
 
-    #if ENABLED(LCD_USE_I2C_BUZZER)
-      #define LCD_FEEDBACK_FREQUENCY_HZ 1000
-      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
-    #endif
-
     #define ULTIPANEL
     #define NEWPANEL
   #endif
@@ -806,5 +800,27 @@
     #endif
   #endif
 
+  /**
+   * Buzzer/Speaker
+   */
+  #if ENABLED(LCD_USE_I2C_BUZZER)
+    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
+      #define LCD_FEEDBACK_FREQUENCY_HZ 1000
+    #endif
+    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
+      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
+    #endif
+  #elif PIN_EXISTS(BEEPER)
+    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
+      #define LCD_FEEDBACK_FREQUENCY_HZ 5000
+    #endif
+    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
+      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
+    #endif
+  #else
+    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
+      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
+    #endif
+  #endif
 #endif //CONFIGURATION_LCD
 #endif //CONDITIONALS_H
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 7b275b0..1a3a170 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -373,4 +373,15 @@ extern uint8_t active_extruder;
 
 void calculate_volumetric_multipliers();
 
+// Buzzer
+#if HAS_BUZZER
+  #if ENABLED(SPEAKER)
+    #include "speaker.h"
+    extern Speaker buzzer;
+  #else
+    #include "buzzer.h"
+    extern Buzzer buzzer;
+  #endif
+#endif
+
 #endif //MARLIN_H
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ccfe672..73c7478 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -59,7 +59,6 @@
 #include "language.h"
 #include "pins_arduino.h"
 #include "math.h"
-#include "buzzer.h"
 
 #if ENABLED(USE_WATCHDOG)
   #include "watchdog.h"
@@ -354,6 +353,15 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
   Stopwatch print_job_timer = Stopwatch();
 #endif
 
+// Buzzer
+#if HAS_BUZZER
+  #if ENABLED(SPEAKER)
+    Speaker buzzer;
+  #else
+    Buzzer buzzer;
+  #endif
+#endif
+
 static uint8_t target_extruder;
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
@@ -1233,7 +1241,7 @@ inline bool code_value_bool() { return code_value_byte() > 0; }
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
-  
+
   float code_value_temp_abs() {
     switch (input_temp_units) {
       case TEMPUNIT_C:
@@ -5689,10 +5697,13 @@ inline void gcode_M226() {
    * M300: Play beep sound S<frequency Hz> P<duration ms>
    */
   inline void gcode_M300() {
-    uint16_t beepS = code_seen('S') ? code_value_ushort() : 110;
-    uint32_t beepP = code_seen('P') ? code_value_ulong() : 1000;
-    if (beepP > 5000) beepP = 5000; // limit to 5 seconds
-    buzz(beepP, beepS);
+    uint16_t const frequency = code_seen('S') ? code_value_ushort() : 260;
+    uint16_t duration = code_seen('P') ? code_value_ushort() : 1000;
+
+    // Limits the tone duration to 0-5 seconds.
+    NOMORE(duration, 5000);
+
+    buzzer.tone(duration, frequency);
   }
 
 #endif // HAS_BUZZER
@@ -6173,7 +6184,7 @@ inline void gcode_M428() {
         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
         LCD_ALERTMESSAGEPGM("Err: Too far!");
         #if HAS_BUZZER
-          buzz(200, 40);
+          buzzer.tone(200, 40);
         #endif
         err = true;
         break;
@@ -6190,8 +6201,8 @@ inline void gcode_M428() {
     report_current_position();
     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
     #if HAS_BUZZER
-      buzz(200, 659);
-      buzz(200, 698);
+      buzzer.tone(200, 659);
+      buzzer.tone(200, 698);
     #endif
   }
 }
@@ -8076,17 +8087,23 @@ void idle(
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
-  thermalManager.manage_heater();
+  lcd_update();
+  host_keepalive();
   manage_inactivity(
     #if ENABLED(FILAMENTCHANGEENABLE)
       no_stepper_sleep
     #endif
   );
-  host_keepalive();
-  lcd_update();
+
+  thermalManager.manage_heater();
+
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
+
+  #if HAS_BUZZER
+    buzzer.tick();
+  #endif
 }
 
 /**
diff --git a/Marlin/buzzer.cpp b/Marlin/buzzer.cpp
deleted file mode 100644
index 776ea4d..0000000
--- a/Marlin/buzzer.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "Marlin.h"
-#if HAS_BUZZER
-  #include "buzzer.h"
-  #include "ultralcd.h"
-
-  void buzz(long duration, uint16_t freq) {
-    if (freq > 0) {
-      #if ENABLED(LCD_USE_I2C_BUZZER)
-        lcd_buzz(duration, freq);
-      #elif PIN_EXISTS(BEEPER) // on-board buzzers have no further condition
-        SET_OUTPUT(BEEPER_PIN);
-        #if ENABLED(SPEAKER) // a speaker needs a AC ore a pulsed DC
-          //tone(BEEPER_PIN, freq, duration); // needs a PWMable pin
-          unsigned int delay = 1000000 / freq / 2;
-          int i = duration * freq / 1000;
-          while (i--) {
-            WRITE(BEEPER_PIN, HIGH);
-            delayMicroseconds(delay);
-            WRITE(BEEPER_PIN, LOW);
-            delayMicroseconds(delay);
-           }
-        #else // buzzer has its own resonator - needs a DC
-          WRITE(BEEPER_PIN, HIGH);
-          delay(duration);
-          WRITE(BEEPER_PIN, LOW);
-        #endif
-      #else
-        delay(duration);
-      #endif
-    }
-    else {
-      delay(duration);
-    }
-  }
-#endif
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index ec568ec..2e43625 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -20,11 +20,114 @@
  *
  */
 
-#ifndef BUZZER_H
-  #define BUZZER_H
+#ifndef __BUZZER_H__
+#define __BUZZER_H__
 
-  #if HAS_BUZZER
-    void buzz(long duration, uint16_t freq);
-  #endif
+#include "fastio.h"
+#include "watchdog.h"
+#include "circularqueue.h"
 
-#endif //BUZZER_H
+#define TONE_QUEUE_LENGTH 4
+
+/**
+ * @brief Tone structure
+ * @details Simple abstration of a tone based on a duration and a frequency.
+ *
+ */
+struct tone_t {
+  uint16_t duration;
+  uint16_t frequency;
+};
+
+/**
+ * @brief Buzzer class
+ */
+class Buzzer {
+  private:
+    struct state_t {
+      tone_t   tone;
+      uint32_t timestamp;
+    } state;
+
+  protected:
+    CircularQueue<tone_t, TONE_QUEUE_LENGTH> buffer;
+
+    /**
+     * @brief Inverts the sate of a digital PIN
+     * @details This will invert the current state of an digital IO pin.
+     */
+    void invert() {
+      WRITE(BEEPER_PIN, !READ(BEEPER_PIN));
+    }
+
+    /**
+     * @brief Turn off a digital PIN
+     * @details Alias of digitalWrite(PIN, LOW) using FastIO
+     */
+    void off() {
+      WRITE(BEEPER_PIN, LOW);
+    }
+
+    /**
+     * @brief Turn on a digital PIN
+     * @details Alias of digitalWrite(PIN, HIGH) using FastIO
+     */
+    void on() {
+      WRITE(BEEPER_PIN, HIGH);
+    }
+
+    /**
+     * @brief Resets the state of the class
+     * @details Brings the class state to a known one.
+     */
+    void reset() {
+      this->off();
+      this->state.timestamp = 0;
+    }
+
+  public:
+    /**
+     * @brief Class constructor
+     */
+    Buzzer() {
+      SET_OUTPUT(BEEPER_PIN);
+      this->reset();
+    }
+
+    /**
+     * @brief Add a tone to the queue
+     * @details Adds a tone_t structure to the ring buffer, will block IO if the
+     * queue is full waiting for one slot to get available.
+     *
+     * @param duration Duration of the tone in milliseconds
+     * @param frequency Frequency of the tone in hertz
+     */
+    void tone(uint16_t const &duration, uint16_t const &frequency = 0) {
+      while (buffer.isFull()) {
+        delay(5);
+        this->tick();
+        #if ENABLED(USE_WATCHDOG)
+          watchdog_reset();
+        #endif
+      }
+      this->buffer.enqueue((tone_t) { duration, frequency });
+    }
+
+    /**
+     * @brief Loop function
+     * @details This function should be called at loop, it will take care of
+     * playing the tones in the queue.
+     */
+    virtual void tick() {
+      if (!this->state.timestamp) {
+        if (this->buffer.isEmpty()) return;
+
+        this->state.tone = this->buffer.dequeue();
+        this->state.timestamp = millis() + this->state.tone.duration;
+        if (this->state.tone.frequency > 0) this->on();
+      }
+      else if (millis() >= this->state.timestamp) this->reset();
+    }
+};
+
+#endif
diff --git a/Marlin/circularqueue.h b/Marlin/circularqueue.h
new file mode 100644
index 0000000..99efd24
--- /dev/null
+++ b/Marlin/circularqueue.h
@@ -0,0 +1,146 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __CIRCULARQUEUE_H__
+#define __CIRCULARQUEUE_H__
+
+#include <Arduino.h>
+
+/**
+ * @brief Circular Queue class
+ * @details Implementation of the classic ring buffer data structure
+ */
+template<typename T, int N>
+class CircularQueue {
+  private:
+
+    /**
+     * @brief Buffer structure
+     * @details This structure consolidates all the overhead required to handle
+     * a circular queue such as the pointers and the buffer vector.
+     */
+    struct buffer_t {
+      uint8_t head;
+      uint8_t tail;
+      uint8_t size;
+      uint8_t length;
+      T queue[N];
+    } buffer;
+
+  public:
+    /**
+     * @brief Class constructor
+     * @details This class requires two template parameters, T defines the type
+     * of the items this queue will handle and N defines the maximum number of
+     * items that can be stored on the queue.
+     */
+    CircularQueue<T, N>() {
+      this->buffer.length = N;
+      this->buffer.size = this->buffer.head = this->buffer.tail = 0;
+    }
+
+    /**
+     * @brief Removes and returns a item from the queue
+     * @details Removes the oldest item on the queue which is pointed by the
+     * buffer_t head variable, this item is then returned to the caller.
+     * @return type T item
+     */
+    T dequeue() {
+      if (this->isEmpty()) return T();
+
+      T const item = this->buffer.queue[this->buffer.head++];
+      --this->buffer.size;
+
+      if (this->buffer.head == this->buffer.length)
+        this->buffer.head = 0;
+
+      return item;
+    }
+
+    /**
+     * @brief Adds an item to the queue
+     * @details Adds a item to the queue on the location pointed by the buffer_t
+     * tail vairable, will return false if there is no queue space available.
+     *
+     * @param item Item to be added to the queue
+     * @return true if the operation was successfull
+     */
+    bool enqueue(T const &item) {
+      if (this->isFull()) return false;
+
+      this->buffer.queue[this->buffer.tail++] = item;
+      ++this->buffer.size;
+
+      if (this->buffer.tail == this->buffer.length)
+        this->buffer.tail = 0;
+
+      return true;
+    }
+
+    /**
+     * @brief Checks if the queue has no items
+     * @details Returns true if there are no items on the queue, false otherwise.
+     * @return true if queue is empty
+     */
+    bool isEmpty() {
+      return this->buffer.size == 0;
+    }
+
+    /**
+     * @brief Checks if the queue is full
+     * @details Returns true if the queue is full, false otherwise.
+     * @return true if queue is full
+     */
+    bool isFull() {
+      return this->buffer.size == this->buffer.length;
+    }
+
+    /**
+     * @brief Gets the queue size
+     * @details Returns the maximum number of items a queue can have.
+     * @return the queue lenght
+     */
+    uint8_t length() {
+      return this->buffer.length;
+    }
+
+    /**
+     * @brief Gets the next item from the queue without removing it
+     * @details Returns the next item on the queue but the item is not removed
+     * from the queue nor the pointers updated.
+     * @return the queue size
+     */
+    uint8_t peek() {
+      return this->buffer.queue[this->buffer.head];
+    }
+
+    /**
+     * @brief Gets the number of items on the queue
+     * @details Returns the current number of items stored on the queue.
+     * @return type T item
+     */
+    uint8_t size() {
+      return this->buffer.size;
+    }
+};
+
+#endif
diff --git a/Marlin/pins_BQ_ZUM_MEGA_3D.h b/Marlin/pins_BQ_ZUM_MEGA_3D.h
index c6b53d8..13f81a9 100644
--- a/Marlin/pins_BQ_ZUM_MEGA_3D.h
+++ b/Marlin/pins_BQ_ZUM_MEGA_3D.h
@@ -59,23 +59,6 @@
 #undef PS_ON_PIN             // 12
 #define PS_ON_PIN         81 // External Power Supply
 
-#if ENABLED(BQ_LCD_SMART_CONTROLLER) // Most similar to REPRAP_DISCOUNT_SMART_CONTROLLER
-  #define KILL_PIN        41
-
-  #define BEEPER_PIN      37
-
-  #define BTN_EN1         31
-  #define BTN_EN2         33
-  #define BTN_ENC         35
-
-  #define LCD_PIN_BL      39
-  #define LCD_PINS_RS     16
-  #define LCD_PINS_ENABLE 17
-  #define LCD_PINS_D4     23
-
-  #define SD_DETECT_PIN   49
-#endif
-
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   #undef Z_MIN_PIN
   #undef Z_MAX_PIN
diff --git a/Marlin/pins_MEGATRONICS.h b/Marlin/pins_MEGATRONICS.h
index 3cd467d..b8022e6 100644
--- a/Marlin/pins_MEGATRONICS.h
+++ b/Marlin/pins_MEGATRONICS.h
@@ -74,7 +74,8 @@
 #define TEMP_1_PIN         15   // ANALOG NUMBERING
 #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
-#define BEEPER_PIN         33   // AUX-4
+// AUX-4
+#define BEEPER_PIN         33
 
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
 
diff --git a/Marlin/pins_MINIRAMBO.h b/Marlin/pins_MINIRAMBO.h
index 1485c72..29bc9df 100644
--- a/Marlin/pins_MINIRAMBO.h
+++ b/Marlin/pins_MINIRAMBO.h
@@ -94,7 +94,9 @@
 
   #if ENABLED(NEWPANEL)
 
-    #define BEEPER_PIN      84  // Beeper on AUX-4
+    // Beeper on AUX-4
+    #define BEEPER_PIN      84
+
     #define LCD_PINS_RS     82
     #define LCD_PINS_ENABLE 18
     #define LCD_PINS_D4     19
diff --git a/Marlin/pins_PRINTRBOARD.h b/Marlin/pins_PRINTRBOARD.h
index 5534589..91455a6 100644
--- a/Marlin/pins_PRINTRBOARD.h
+++ b/Marlin/pins_PRINTRBOARD.h
@@ -121,7 +121,8 @@
 #endif // ULTRA_LCD && NEWPANEL
 
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
-  #define BEEPER_PIN 32 //FastIO
+  //FastIO
+  #define BEEPER_PIN 32
   // Pins for DOGM SPI LCD Support
   #define DOGLCD_A0  42 //Non-FastIO
   #define DOGLCD_CS  43 //Non-FastIO
diff --git a/Marlin/pins_RAMBO.h b/Marlin/pins_RAMBO.h
index a42731a..0e7c7aa 100644
--- a/Marlin/pins_RAMBO.h
+++ b/Marlin/pins_RAMBO.h
@@ -112,7 +112,8 @@
 
   #if ENABLED(NEWPANEL)
 
-    #define BEEPER_PIN 79      // Beeper on AUX-4
+    // Beeper on AUX-4
+    #define BEEPER_PIN 79
 
     #define LCD_PINS_RS 70
     #define LCD_PINS_ENABLE 71
@@ -134,7 +135,8 @@
 
   #else //!NEWPANEL - old style panel with shift register
 
-    #define BEEPER_PIN 33    // No Beeper added
+    // No Beeper added
+    #define BEEPER_PIN 33
 
     //buttons are attached to a shift register
     // Not wired yet
diff --git a/Marlin/pins_RAMPS_14.h b/Marlin/pins_RAMPS_14.h
index 9c8caa2..32232af 100644
--- a/Marlin/pins_RAMPS_14.h
+++ b/Marlin/pins_RAMPS_14.h
@@ -116,10 +116,6 @@
 
 #define PS_ON_PIN          12
 
-#if ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER) || ENABLED(G3D_PANEL)
-  #define KILL_PIN         41
-#endif
-
 #if MB(RAMPS_14_EFF) || MB(RAMPS_13_EFF)
   #define HEATER_0_PIN      8
 #else
@@ -168,6 +164,12 @@
       #define BTN_ENC 35
 
       #define SD_DETECT_PIN 49
+      #define KILL_PIN 41
+
+      #if ENABLED(BQ_LCD_SMART_CONTROLLER)
+        #define LCD_PIN_BL 39
+      #endif
+
     #elif ENABLED(LCD_I2C_PANELOLU2)
       #define BTN_EN1 47  // reverse if the encoder turns the wrong way.
       #define BTN_EN2 43
@@ -218,7 +220,8 @@
 
     #else
 
-      #define BEEPER_PIN 33  // Beeper on AUX-4
+      // Beeper on AUX-4
+      #define BEEPER_PIN 33
 
       // buttons are directly attached using AUX-2
       #if ENABLED(REPRAPWORLD_KEYPAD)
@@ -240,6 +243,7 @@
 
       #if ENABLED(G3D_PANEL)
         #define SD_DETECT_PIN 49
+        #define KILL_PIN 41
       #else
         //        #define SD_DETECT_PIN -1  // Ramps doesn't use this
       #endif
@@ -247,7 +251,8 @@
     #endif
   #else // !NEWPANEL (Old-style panel with shift register)
 
-    #define BEEPER_PIN 33   // No Beeper added
+    // No Beeper added
+    #define BEEPER_PIN 33
 
     // Buttons are attached to a shift register
     // Not wired yet
@@ -280,7 +285,3 @@
   #define MISO_PIN         50
   #define MOSI_PIN         51
 #endif
-
-#ifndef KILL_PIN
-  //  #define KILL_PIN         -1
-#endif
diff --git a/Marlin/pins_SANGUINOLOLU_11.h b/Marlin/pins_SANGUINOLOLU_11.h
index bd77226..9b00788 100644
--- a/Marlin/pins_SANGUINOLOLU_11.h
+++ b/Marlin/pins_SANGUINOLOLU_11.h
@@ -105,7 +105,10 @@
         #define LCD_PINS_RS     30 //CS chip select /SS chip slave select
         #define LCD_PINS_ENABLE 29 //SID (MOSI)
         #define LCD_PINS_D4     17 //SCK (CLK) clock
-        #define BEEPER_PIN      27 // Pin 27 is taken by LED_PIN, but Melzi LED does nothing with Marlin so this can be used for BEEPER_PIN. You can use this pin with M42 instead of BEEPER_PIN.
+        // Pin 27 is taken by LED_PIN, but Melzi LED does nothing with
+        // Marlin so this can be used for BEEPER_PIN. You can use this pin
+        // with M42 instead of BEEPER_PIN.
+        #define BEEPER_PIN      27
       #else         // Sanguinololu 1.3
         #define LCD_PINS_RS      4
         #define LCD_PINS_ENABLE 17
diff --git a/Marlin/speaker.h b/Marlin/speaker.h
new file mode 100644
index 0000000..93aa6f7
--- /dev/null
+++ b/Marlin/speaker.h
@@ -0,0 +1,92 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __SPEAKER_H__
+#define __SPEAKER_H__
+
+#include "buzzer.h"
+
+class Speaker: public Buzzer {
+  private:
+    typedef Buzzer super;
+
+    struct state_t {
+      tone_t   tone;
+      uint16_t period;
+      uint16_t cycles;
+    } state;
+
+  protected:
+    /**
+     * @brief Resets the state of the class
+     * @details Brings the class state to a known one.
+     */
+    void reset() {
+      super::reset();
+      this->state.period = 0;
+      this->state.cycles = 0;
+    }
+
+  public:
+    /**
+     * @brief Class constructor
+     */
+    Speaker() {
+      this->reset();
+    }
+
+    /**
+     * @brief Loop function
+     * @details This function should be called at loop, it will take care of
+     * playing the tones in the queue.
+     */
+    virtual void tick() {
+      if (!this->state.cycles) {
+        if (this->buffer.isEmpty()) return;
+
+        this->reset();
+        this->state.tone = this->buffer.dequeue();
+
+        // Period is uint16, min frequency will be ~16Hz
+        this->state.period = 1000000UL / this->state.tone.frequency;
+
+        this->state.cycles =
+          (this->state.tone.duration * 1000L) / this->state.period;
+
+        this->state.period >>= 1;
+        this->state.cycles <<= 1;
+
+      }
+      else {
+        uint32_t const us = micros();
+        static uint32_t next = us + this->state.period;
+
+        if (us >= next) {
+          --this->state.cycles;
+          next = us + this->state.period;
+          if (this->state.tone.frequency > 0) this->invert();
+        }
+      }
+    }
+};
+
+#endif
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index c923535..1d6db5c 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -206,15 +206,18 @@ unsigned char Temperature::soft_pwm[HOTENDS];
       next_auto_fan_check_ms = temp_ms + 2500UL;
     #endif
 
-    if (false
-      #if ENABLED(PIDTEMP)
-         || hotend >= HOTENDS
-      #else
-         || hotend >= 0
-      #endif
-      #if DISABLED(PIDTEMPBED)
-         || hotend < 0
-      #endif
+    if (hotend >=
+        #if ENABLED(PIDTEMP)
+          HOTENDS
+        #else
+          0
+        #endif
+      || hotend <
+        #if ENABLED(PIDTEMPBED)
+          -1
+        #else
+          0
+        #endif
     ) {
       SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
       return;
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index a891f90..6f19ce5 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -978,8 +978,8 @@ void lcd_cooldown() {
           lcd_return_to_status();
           //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
           #if HAS_BUZZER
-            buzz(200, 659);
-            buzz(200, 698);
+            buzzer.tone(200, 659);
+            buzzer.tone(200, 698);
           #endif
         }
         else {
@@ -1978,25 +1978,10 @@ void lcd_quick_feedback() {
   next_button_update_ms = millis() + 500;
 
   #if ENABLED(LCD_USE_I2C_BUZZER)
-    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
-      #define LCD_FEEDBACK_FREQUENCY_HZ 100
-    #endif
-    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
-      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS (1000/6)
-    #endif
     lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
   #elif PIN_EXISTS(BEEPER)
-    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
-      #define LCD_FEEDBACK_FREQUENCY_HZ 5000
-    #endif
-    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
-      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
-    #endif
-    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+    buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
   #else
-    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
-      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
-    #endif
     delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);
   #endif
 }

