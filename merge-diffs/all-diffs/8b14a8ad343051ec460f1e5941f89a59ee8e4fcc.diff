commit 8b14a8ad343051ec460f1e5941f89a59ee8e4fcc (from 924bab1a031101634ba350cd8daf1c5a2e08430a)
Merge: 924bab1 959d82e
Author: Bernhard Kubicek <kubicek@gmx.at>
Date:   Sun Nov 20 16:39:39 2011 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index f5df6f6..04353b5 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -430,21 +430,21 @@ void disable_heater()
   #if TEMP_0_PIN > -1
   target_raw[0]=0;
    #if HEATER_0_PIN > -1  
-     WRITE(HEATER_0_PIN,LOW);
+     digitalWrite(HEATER_0_PIN,LOW);
    #endif
   #endif
      
   #if TEMP_1_PIN > -1
     target_raw[1]=0;
     #if HEATER_1_PIN > -1 
-      WRITE(HEATER_1_PIN,LOW);
+      digitalWrite(HEATER_1_PIN,LOW);
     #endif
   #endif
       
   #if TEMP_2_PIN > -1
     target_raw[2]=0;
     #if HEATER_2_PIN > -1  
-      WRITE(HEATER_2_PIN,LOW);
+      digitalWrite(HEATER_2_PIN,LOW);
     #endif
   #endif 
 }

commit 8b14a8ad343051ec460f1e5941f89a59ee8e4fcc (from 959d82e81e3a8185992a4c8edeff171fed9f01ca)
Merge: 924bab1 959d82e
Author: Bernhard Kubicek <kubicek@gmx.at>
Date:   Sun Nov 20 16:39:39 2011 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/cardreader.pde b/Marlin/cardreader.pde
index c0dbc58..eec10f1 100644
--- a/Marlin/cardreader.pde
+++ b/Marlin/cardreader.pde
@@ -252,10 +252,11 @@ void CardReader::openFile(char* name,bool read)
       sdpos = 0;
       
       SERIAL_PROTOCOLLNPGM("File selected");
+      LCD_MESSAGE(fname);
     }
     else
     {
-     SERIAL_PROTOCOLPGM("open failed, File: ");
+      SERIAL_PROTOCOLPGM("open failed, File: ");
       SERIAL_PROTOCOL(fname);
       SERIAL_PROTOCOLLNPGM(".");
     }
@@ -273,6 +274,7 @@ void CardReader::openFile(char* name,bool read)
       saving = true;
       SERIAL_PROTOCOLPGM("Writing to file: ");
       SERIAL_PROTOCOLLN(name);
+      LCD_MESSAGE(fname);
     }
   }
   
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index a59945d..214226e 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -762,3 +762,7 @@ void plan_set_position(const float &x, const float &y, const float &z, const flo
   previous_speed[3] = 0.0;
 }
 
+uint8_t movesplanned()
+{
+ return (block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
+}
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 52a6fba..511f532 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -80,6 +80,7 @@ void plan_discard_current_block();
 block_t *plan_get_current_block();
 
 void check_axes_activity();
+uint8_t movesplanned();
 
 extern unsigned long minsegmenttime;
 extern float max_feedrate[4]; // set the max speeds
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 6222c70..85a8df7 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -64,6 +64,7 @@
     void showStatus();
     void showMainMenu();
     void showPrepare();
+    void showTune();
     void showControl();
     void showControlMotion();
     void showControlTemp();
@@ -75,6 +76,8 @@
     
     bool linechanging;
     
+    bool tune;
+    
   private:
     inline void updateActiveLines(const uint8_t &maxlines,volatile int &encoderpos)
     {
@@ -89,8 +92,7 @@
         {  
           lineoffset--; 
           if(lineoffset<0) lineoffset=0; 
-          curencoderpos=lcdslow-1; 
-          force_lcd_update=true; 
+          curencoderpos=lcdslow-1;
         } 
         if(curencoderpos>(LCD_HEIGHT-1+1)*lcdslow) 
         { 
@@ -100,9 +102,9 @@
             lineoffset=maxlines+1-LCD_HEIGHT; 
           if(curencoderpos>maxlines*lcdslow) 
             curencoderpos=maxlines*lcdslow; 
-          force_lcd_update=true; 
         } 
-        lastencoderpos=encoderpos=curencoderpos; 
+        lastencoderpos=encoderpos=curencoderpos;
+        int lastactiveline=activeline;
         activeline=curencoderpos/lcdslow;
         if(activeline<0) activeline=0;
         if(activeline>LCD_HEIGHT-1) activeline=LCD_HEIGHT-1;
@@ -111,6 +113,8 @@
           activeline=maxlines;
           curencoderpos=maxlines*lcdslow;
         }
+        if(lastlineoffset!=lineoffset)
+          force_lcd_update=true;
         lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');    
       } 
     }
@@ -126,7 +130,6 @@
   };
 
   //conversion routines, could need some overworking
-  char *fillto(int8_t n,char *c);
   char *ftostr51(const float &x);
   char *ftostr31(const float &x);
   char *ftostr3(const float &x);
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index 57f63c1..e2a75df 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -65,6 +65,7 @@ inline int intround(const float &x){return int(0.5+x);}
 void lcd_status(const char* message)
 {
   strncpy(messagetext,message,LCD_WIDTH);
+  messagetext[strlen(message)]=0;
 }
 
 void lcd_statuspgm(const char* message)
@@ -79,6 +80,7 @@ void lcd_statuspgm(const char* message)
     cnt++;
     ch=pgm_read_byte(++message);
   }
+  *target=0;
 }
 
 inline void clear()
@@ -280,6 +282,7 @@ MainMenu::MainMenu()
   #endif
   lcd_init();
   linechanging=false;
+  tune=false;
 }
 
 void MainMenu::showStatus()
@@ -373,7 +376,11 @@ void MainMenu::showStatus()
   if(messagetext[0]!='\0')
   {
     lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(fillto(LCD_WIDTH,messagetext));
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
+    
     messagetext[0]='\0';
   }
   
@@ -419,7 +426,10 @@ void MainMenu::showStatus()
   if(messagetext[0]!='\0')
   {
     lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(fillto(LCD_WIDTH,messagetext));
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
     messagetext[0]='\0';
   }
 
@@ -471,6 +481,166 @@ void MainMenu::showPrepare()
  updateActiveLines(ItemP_disstep,encoderpos);
 }
 
+enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,ItemT_fan};
+
+void MainMenu::showTune()
+{ 
+  uint8_t line=0;
+  clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+   //Serial.println((int)(line-lineoffset));
+  switch(i)
+  {
+  case ItemT_exit:
+      MENUITEM(  lcdprintPGM(" Tune")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+  case ItemT_speed:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);lcdprintPGM(" Speed:");
+        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
+      }
+      
+      if((activeline==line) )
+      {
+        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=feedmultiply;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>400) encoderpos=400;
+          feedmultiply = encoderpos;
+          feedmultiplychanged=true;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }
+    }break;
+    case ItemT_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
+        }
+        
+        if((activeline==line) )
+        {
+          if(CLICKED)
+          {
+            linechanging=!linechanging;
+            if(linechanging)
+            {
+               encoderpos=intround(degTargetHotend0());
+            }
+            else
+            {
+              setTargetHotend0(encoderpos);
+              encoderpos=activeline*lcdslow;
+              beepshort();
+            }
+            BLOCK;
+          }
+          if(linechanging)
+          {
+            if(encoderpos<0) encoderpos=0;
+            if(encoderpos>260) encoderpos=260;
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+          }
+        }
+      }break;
+      
+      case ItemT_fan:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
+        }
+        
+        if((activeline==line) )
+        {
+          if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+          {
+            linechanging=!linechanging;
+            if(linechanging)
+            {
+               encoderpos=fanpwm;
+            }
+            else
+            {
+              encoderpos=activeline*lcdslow;
+              beepshort();
+            }
+            BLOCK;
+          }
+          if(linechanging)
+          {
+            if(encoderpos<0) encoderpos=0;
+            if(encoderpos>255) encoderpos=255;
+            fanpwm=encoderpos;
+              analogWrite(FAN_PIN,  fanpwm);
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+          }
+        }
+      }break;
+      case ItemT_flow://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Flow:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
+        }
+        
+        if((activeline==line) )
+        {
+          if(CLICKED)
+          {
+            linechanging=!linechanging;
+            if(linechanging)
+            {
+               encoderpos=(int)axis_steps_per_unit[3];
+            }
+            else
+            {
+              float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
+              position[E_AXIS]=lround(position[E_AXIS]*factor);
+              //current_position[3]*=factor;
+              axis_steps_per_unit[E_AXIS]= encoderpos;
+              encoderpos=activeline*lcdslow;
+                
+            }
+            BLOCK;
+            beepshort();
+          }
+          if(linechanging)
+          {
+            if(encoderpos<5) encoderpos=5;
+            if(encoderpos>9999) encoderpos=9999;
+            lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+          }
+        }
+      }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemT_fan,encoderpos);
+}
 
 //does not work
 // #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
@@ -510,7 +680,7 @@ void MainMenu::showControlTemp()
         if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degHotend0())));
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
         }
         
         if((activeline==line) )
@@ -520,7 +690,7 @@ void MainMenu::showControlTemp()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=intround(degHotend0());
+               encoderpos=intround(degTargetHotend0());
             }
             else
             {
@@ -558,10 +728,7 @@ void MainMenu::showControlTemp()
             }
             else
             {
-              fanpwm = constrain(encoderpos,0,255);
-              encoderpos=fanpwm;
-              analogWrite(FAN_PIN,  fanpwm);
-
+              encoderpos=activeline*lcdslow;
               beepshort();
             }
             BLOCK;
@@ -1246,7 +1413,22 @@ void MainMenu::showMainMenu()
   #ifndef ULTIPANEL
     force_lcd_update=false;
   #endif
-   
+  if(tune)
+  {
+    if(!(movesplanned() ||card.sdprinting))
+    {
+      force_lcd_update=true;
+      tune=false;
+    }
+  }
+  else 
+  {
+    if(movesplanned() ||card.sdprinting)
+    {
+      force_lcd_update=true;
+      tune=true;
+    }
+  } 
   clearIfNecessary();
   for(int8_t line=0;line<LCD_HEIGHT;line++)
   {
@@ -1256,7 +1438,7 @@ void MainMenu::showMainMenu()
         MENUITEM(  lcdprintPGM(" Watch")  ,  BLOCK;status=Main_Status;beepshort(); ) ;
        break;
       case ItemM_prepare:
-        MENUITEM(  lcdprintPGM(" Prepare \x7E")  ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
+        MENUITEM(  if(!tune) lcdprintPGM(" Prepare \x7E");else  lcdprintPGM(" Tune \x7E"); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
       break;
        
       case ItemM_control:
@@ -1363,7 +1545,14 @@ void MainMenu::update()
       }break;
       case Main_Prepare: 
       {
-        showPrepare(); 
+        if(tune)
+        {
+          showTune();
+        }
+        else
+        {
+          showPrepare(); 
+        }
       }break;
       case Main_Control:
       {
@@ -1478,26 +1667,6 @@ char *ftostr51(const float &x)
   return conv;
 }
 
-char *fillto(int8_t n,char *c)
-{
-  static char ret[25];
-  bool endfound=false;
-  for(int8_t i=0;i<n;i++)
-  {
-    ret[i]=c[i];
-    if(c[i]==0)
-    {
-      endfound=true;
-    }
-    if(endfound)
-    {
-      ret[i]=' ';
-    }
-  }
-  ret[n]=0;
-  return ret;
-}
-
 
 #endif //ULTRA_LCD
 

