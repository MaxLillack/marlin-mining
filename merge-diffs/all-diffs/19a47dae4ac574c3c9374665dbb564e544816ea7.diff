commit 19a47dae4ac574c3c9374665dbb564e544816ea7 (from 910f4e77a2ef18e19de399380a2ce0968e3165f0)
Merge: 910f4e7 02ee9e3
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sun Mar 11 04:34:59 2012 -0700

    Merge pull request #99 from Justblair/master
    
    Better pin configuration for rotary encoder in RAMPS boards

diff --git a/Marlin/pins.h b/Marlin/pins.h
index bf0ce3e..cad3ade 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -285,7 +285,7 @@
 #define FAN_PIN            4 // IO pin. Buffer needed
 #endif
 #define PS_ON_PIN          12
-#define KILL_PIN           31
+#define KILL_PIN           -1
 
 #define HEATER_0_PIN       10   // EXTRUDER 1
 #if MOTHERBOARD == 33
@@ -314,9 +314,9 @@
     #define LCD_PINS_D7 29
     
     //buttons are directly attached using AUX-2
-    #define BTN_EN1 44
-    #define BTN_EN2 42
-    #define BTN_ENC 64  //the click
+    #define BTN_EN1 37
+    #define BTN_EN2 35
+    #define BTN_ENC 31  //the click
     
     #define BLEN_C 2
     #define BLEN_B 1

commit 19a47dae4ac574c3c9374665dbb564e544816ea7 (from 02ee9e3d30adb1621a7651917ccef88d4fad32cc)
Merge: 910f4e7 02ee9e3
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sun Mar 11 04:34:59 2012 -0700

    Merge pull request #99 from Justblair/master
    
    Better pin configuration for rotary encoder in RAMPS boards

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 74c03eb..2320dce 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -82,13 +82,13 @@
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
   #define K1 0.95 //smoothing factor withing the PID
-  #define PID_dT 0.128 //sampling period of the PID
+  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the
 
 // If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
     #define  DEFAULT_Kp  22.2
-    #define  DEFAULT_Ki (1.25*PID_dT)  
-    #define  DEFAULT_Kd (99/PID_dT)  
+    #define  DEFAULT_Ki (1.08*PID_dT)  
+    #define  DEFAULT_Kd (114/PID_dT)  
 
 // Makergear
 //    #define  DEFAULT_Kp 7.0
@@ -171,6 +171,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // 
 #define DEFAULT_XYJERK                20.0    // (mm/sec)
 #define DEFAULT_ZJERK                 0.4     // (mm/sec)
+#define DEFAULT_EJERK                 5.0    // (mm/sec)
 
 //===========================================================================
 //=============================Additional Features===========================
@@ -191,9 +192,9 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //#define ULTRA_LCD  //general lcd support, also 16x2
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 
-//#define ULTIPANEL
+#define ULTIPANEL
 #ifdef ULTIPANEL
-  #define NEWPANEL  //enable this if you have a click-encoder panel
+//  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
   #define ULTRA_LCD
   #define LCD_WIDTH 20
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 38e9409..0e42235 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -61,6 +61,12 @@
 #define TEMP_SENSOR_AD595_OFFSET 0.0
 #define TEMP_SENSOR_AD595_GAIN   1.0
 
+//This is for controlling a fan to cool down the stepper drivers
+//it will turn on when any driver is enabled
+//and turn off after the set amount of seconds from last driver being disabled again
+//#define CONTROLLERFAN_PIN 23 //Pin used for the fan to cool controller, comment out to disable this function
+#define CONTROLLERFAN_SEC 60 //How many seconds, after all motors were disabled, the fan should run
+
 //===========================================================================
 //=============================Mechanical Settings===========================
 //===========================================================================
diff --git a/Marlin/EEPROMwrite.h b/Marlin/EEPROMwrite.h
index bb25ae8..d639e56 100644
--- a/Marlin/EEPROMwrite.h
+++ b/Marlin/EEPROMwrite.h
@@ -38,7 +38,7 @@ template <class T> int EEPROM_readAnything(int &ee, T& value)
 // the default values are used whenever there is a change to the data, to prevent
 // wrong data being written to the variables.
 // ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#define EEPROM_VERSION "V04"  
+#define EEPROM_VERSION "V05"  
 
 inline void EEPROM_StoreSettings() 
 {
@@ -56,6 +56,7 @@ inline void EEPROM_StoreSettings()
   EEPROM_writeAnything(i,minsegmenttime);
   EEPROM_writeAnything(i,max_xy_jerk);
   EEPROM_writeAnything(i,max_z_jerk);
+  EEPROM_writeAnything(i,max_e_jerk);
   #ifdef PIDTEMP
     EEPROM_writeAnything(i,Kp);
     EEPROM_writeAnything(i,Ki);
@@ -116,6 +117,7 @@ inline void EEPROM_printSettings()
       SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
       SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); 
       SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
+      SERIAL_ECHOPAIR(" E" ,max_e_jerk);
       SERIAL_ECHOLN(""); 
     #ifdef PIDTEMP
       SERIAL_ECHO_START;
@@ -150,6 +152,7 @@ inline void EEPROM_RetrieveSettings(bool def=false)
       EEPROM_readAnything(i,minsegmenttime);
       EEPROM_readAnything(i,max_xy_jerk);
       EEPROM_readAnything(i,max_z_jerk);
+      EEPROM_readAnything(i,max_e_jerk);
       #ifndef PIDTEMP
         float Kp,Ki,Kd;
       #endif
@@ -179,6 +182,7 @@ inline void EEPROM_RetrieveSettings(bool def=false)
       mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
       max_xy_jerk=DEFAULT_XYJERK;
       max_z_jerk=DEFAULT_ZJERK;
+      max_e_jerk=DEFAULT_EJERK;
       SERIAL_ECHO_START;
       SERIAL_ECHOLN("Using Default settings:");
     }
diff --git a/Marlin/Makefile b/Marlin/Makefile
index 9e41c28..955ccd5 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -23,7 +23,9 @@
 #  3. Set the line containing "MCU" to match your board's processor. 
 #     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
 #     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
-#     change F_CPU to 8000000.
+#     change F_CPU to 8000000. If you are using Gen7 electronics, you
+#     probably need to use 20000000. Either way, you must regenerate
+#     the speed lookup table with create_speed_lookuptable.py.
 #
 #  4. Type "make" and press enter to compile/verify your program.
 #
@@ -42,6 +44,8 @@ MCU = atmega1280
 #Arduino install directory
 INSTALL_DIR = ../../arduino-0022/
 
+# Be sure to regenerate speed_lookuptable.h with create_speed_lookuptable.py
+# if you are setting this to something other than 16MHz
 F_CPU = 16000000
 
 UPLOAD_RATE = 115200
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index de02c88..b90f20e 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -97,7 +97,7 @@
 // M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 // M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 // M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
+// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
 // M206 - set additional homeing offset
 // M220 S<factor in percent>- set speed factor override percentage
 // M221 S<factor in percent>- set extrude factor override percentage
@@ -109,6 +109,7 @@
 // M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
 // M503 - print the current settings (from memory not from eeprom)
+// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
 
 //Stepper Movement Variables
 
@@ -289,6 +290,7 @@ void setup()
     axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
   }
 
+
   tp_init();    // Initialize temperature loop 
   plan_init();  // Initialize planner;
   st_init();    // Initialize stepper;
@@ -575,6 +577,7 @@ void process_commands()
       saved_feedrate = feedrate;
       saved_feedmultiply = feedmultiply;
       feedmultiply = 100;
+      previous_millis_cmd = millis();
       
       enable_endstops(true);
       
@@ -942,6 +945,7 @@ void process_commands()
             codenum = millis(); 
           }
           manage_heater();
+          LCD_STATUS;
         }
         LCD_MESSAGEPGM(MSG_BED_DONE);
         previous_millis_cmd = millis();
@@ -1116,6 +1120,7 @@ void process_commands()
       if(code_seen('B')) minsegmenttime = code_value() ;
       if(code_seen('X')) max_xy_jerk = code_value() ;
       if(code_seen('Z')) max_z_jerk = code_value() ;
+      if(code_seen('E')) max_e_jerk = code_value() ;
     }
     break;
     case 206: // M206 additional homeing offset
@@ -1196,6 +1201,13 @@ void process_commands()
       allow_cold_extrudes(true);
     }
     break;
+    case 303: // M303 PID autotune
+    {
+      float temp = 150.0;
+      if (code_seen('S')) temp=code_value();
+      PID_autotune(temp);
+    }
+    break;
     case 400: // finish all moves
     {
       st_synchronize();
@@ -1304,12 +1316,11 @@ void prepare_move()
     if (destination[Y_AXIS] > Y_MAX_LENGTH) destination[Y_AXIS] = Y_MAX_LENGTH;
     if (destination[Z_AXIS] > Z_MAX_LENGTH) destination[Z_AXIS] = Z_MAX_LENGTH;
   }
-  
+  previous_millis_cmd = millis();  
   plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
   for(int8_t i=0; i < NUM_AXIS; i++) {
     current_position[i] = destination[i];
   }
-  previous_millis_cmd = millis();
 }
 
 void prepare_arc_move(char isclockwise) {
@@ -1327,6 +1338,40 @@ void prepare_arc_move(char isclockwise) {
   previous_millis_cmd = millis();
 }
 
+#ifdef CONTROLLERFAN_PIN
+unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
+unsigned long lastMotorCheck = 0;
+
+void controllerFan()
+{
+  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
+  {
+    lastMotorCheck = millis();
+    
+    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
+    #if EXTRUDERS > 2
+       || !READ(E2_ENABLE_PIN)
+    #endif
+    #if EXTRUDER > 1
+       || !READ(E2_ENABLE_PIN)
+    #endif
+       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
+    {
+      lastMotor = millis(); //... set time to NOW so the fan will turn on
+    }
+    
+    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
+    {
+      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
+    }
+    else
+    {
+      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
+    }
+  }
+}
+#endif
+
 void manage_inactivity(byte debug) 
 { 
   if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
@@ -1335,14 +1380,19 @@ void manage_inactivity(byte debug)
   if(stepper_inactive_time)  {
     if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
     {
-      disable_x();
-      disable_y();
-      disable_z();
-      disable_e0();
-      disable_e1();
-      disable_e2();
+      if(blocks_queued() == false) {
+        disable_x();
+        disable_y();
+        disable_z();
+        disable_e0();
+        disable_e1();
+        disable_e2();
+      }
     }
   }
+  #ifdef CONTROLLERFAN_PIN
+    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
+  #endif
   #ifdef EXTRUDER_RUNOUT_PREVENT
     if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
     if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
diff --git a/Marlin/Marlin.suo b/Marlin/Marlin.suo
deleted file mode 100644
index 4aca6fe..0000000
Binary files a/Marlin/Marlin.suo and /dev/null differ
diff --git a/Marlin/create_speed_lookuptable.py b/Marlin/create_speed_lookuptable.py
new file mode 100755
index 0000000..13ed92d
--- /dev/null
+++ b/Marlin/create_speed_lookuptable.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python
+
+""" Generate the stepper delay lookup table for Marlin firmware. """
+
+import argparse
+
+__author__ = "Ben Gamari <bgamari@gmail.com>"
+__copyright__ = "Copyright 2012, Ben Gamari"
+__license__ = "GPL"
+
+parser = argparse.ArgumentParser(description=__doc__)
+parser.add_argument('-f', '--cpu-freq', type=int, default=16, help='CPU clockrate in MHz (default=16)')
+parser.add_argument('-d', '--divider', type=int, default=8, help='Timer/counter pre-scale divider (default=8)')
+args = parser.parse_args()
+
+cpu_freq = args.cpu_freq * 1000000
+timer_freq = cpu_freq / args.divider
+
+print "#ifndef SPEED_LOOKUPTABLE_H"
+print "#define SPEED_LOOKUPTABLE_H"
+print
+print '#include "Marlin.h"'
+print
+
+print "const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {"
+a = [ timer_freq / ((i*256)+(args.cpu_freq*2)) for i in range(256) ]
+b = [ a[i] - a[i+1] for i in range(255) ]
+b.append(b[-1])
+for i in range(32):
+    print "  ",
+    for j in range(8):
+        print "{%d, %d}," % (a[8*i+j], b[8*i+j]),
+    print 
+print "};"
+print
+
+print "const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {"
+a = [ timer_freq / ((i*8)+(args.cpu_freq*2)) for i in range(256) ]
+b = [ a[i] - a[i+1] for i in range(255) ]
+b.append(b[-1])
+for i in range(32):
+    print "  ",
+    for j in range(8):
+        print "{%d, %d}," % (a[8*i+j], b[8*i+j]),
+    print 
+print "};"
+print
+
+print "#endif"
+
diff --git a/Marlin/pins.h b/Marlin/pins.h
index abf5a7e..cad3ade 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -734,7 +734,7 @@
     #define encrot2 3
     #define encrot3 1
 
-    
+    #define SDCARDDETECT -1
     //bits in the shift register that carry the buttons for:
     // left up center down right red
     #define BL_LE 7
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 5972daf..c06c073 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -74,6 +74,7 @@ float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT A
 float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
 float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
 float max_z_jerk;
+float max_e_jerk;
 float mintravelfeedrate;
 unsigned long axis_steps_per_sqr_second[NUM_AXIS];
 
@@ -436,13 +437,17 @@ void check_axes_activity() {
     }
   }
   else {
-    if (FanSpeed != 0) analogWrite(FAN_PIN,FanSpeed); // If buffer is empty use current fan speed
+    #if FAN_PIN > -1
+      if (FanSpeed != 0) analogWrite(FAN_PIN,FanSpeed); // If buffer is empty use current fan speed
+    #endif
   }
   if((DISABLE_X) && (x_active == 0)) disable_x();
   if((DISABLE_Y) && (y_active == 0)) disable_y();
   if((DISABLE_Z) && (z_active == 0)) disable_z();
   if((DISABLE_E) && (e_active == 0)) { disable_e0();disable_e1();disable_e2(); }
-  if((FanSpeed == 0) && (fan_speed ==0)) analogWrite(FAN_PIN, 0);
+  #if FAN_PIN > -1
+    if((FanSpeed == 0) && (fan_speed ==0)) analogWrite(FAN_PIN, 0);
+  #endif
   if (FanSpeed != 0 && tail_fan_speed !=0) { 
     analogWrite(FAN_PIN,tail_fan_speed);
   }
@@ -531,6 +536,13 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   if(block->steps_e != 0) { enable_e0();enable_e1();enable_e2(); }
 
 
+  if (block->steps_e == 0) {
+        if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
+  }
+  else {
+    	if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
+  } 
+  
   // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
   int moves_queued=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
   #ifdef SLOWDOWN
@@ -555,12 +567,6 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   block->nominal_speed = block->millimeters * inverse_second; // (mm/sec) Always > 0
   block->nominal_rate = ceil(block->step_event_count * inverse_second); // (step/sec) Always > 0
 
-  if (block->steps_e == 0) {
-        if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
-  }
-  else {
-    	if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
-  } 
 
 /*
   //  segment time im micro seconds
@@ -705,7 +711,9 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   if(abs(current_speed[Z_AXIS]) > max_z_jerk/2) 
     vmax_junction = max_z_jerk/2;
   vmax_junction = min(vmax_junction, block->nominal_speed);
-
+  if(abs(current_speed[E_AXIS]) > max_e_jerk/2) 
+    vmax_junction = min(vmax_junction, max_e_jerk/2);
+    
   if ((moves_queued > 1) && (previous_nominal_speed > 0.0)) {
     float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));
     if((previous_speed[X_AXIS] != 0.0) || (previous_speed[Y_AXIS] != 0.0)) {
@@ -717,6 +725,9 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
     if(abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
       vmax_junction *= (max_z_jerk/abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
     } 
+    if(abs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
+      vmax_junction *= (max_e_jerk/abs(current_speed[E_AXIS] - previous_speed[E_AXIS]));
+    } 
   }
   block->max_entry_speed = vmax_junction;
     
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 8fa4d4e..873441b 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -88,6 +88,7 @@ extern float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DE
 extern float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
 extern float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
 extern float max_z_jerk;
+extern float max_e_jerk;
 extern float mintravelfeedrate;
 extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];
 
diff --git a/Marlin/speed_lookuptable.h b/Marlin/speed_lookuptable.h
index 77f7661..670e744 100644
--- a/Marlin/speed_lookuptable.h
+++ b/Marlin/speed_lookuptable.h
@@ -3,6 +3,8 @@
 
 #include "Marlin.h"
 
+#if F_CPU == 16000000
+
 const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {\
 { 62500, 55556}, { 6944, 3268}, { 3676, 1176}, { 2500, 607}, { 1893, 369}, { 1524, 249}, { 1275, 179}, { 1096, 135}, 
 { 961, 105}, { 856, 85}, { 771, 69}, { 702, 58}, { 644, 49}, { 595, 42}, { 553, 37}, { 516, 32}, 
@@ -73,4 +75,78 @@ const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {\
 { 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}
 };
 
+#else
+
+const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {
+   {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},
+   {1197, 131}, {1066, 105}, {961, 86}, {875, 72}, {803, 61}, {742, 53}, {689, 45}, {644, 40},
+   {604, 35}, {569, 32}, {537, 28}, {509, 25}, {484, 23}, {461, 21}, {440, 19}, {421, 17},
+   {404, 16}, {388, 15}, {373, 14}, {359, 13}, {346, 12}, {334, 11}, {323, 10}, {313, 10},
+   {303, 9}, {294, 9}, {285, 8}, {277, 7}, {270, 8}, {262, 7}, {255, 6}, {249, 6},
+   {243, 6}, {237, 6}, {231, 5}, {226, 5}, {221, 5}, {216, 5}, {211, 4}, {207, 5},
+   {202, 4}, {198, 4}, {194, 4}, {190, 3}, {187, 4}, {183, 3}, {180, 3}, {177, 4},
+   {173, 3}, {170, 3}, {167, 2}, {165, 3}, {162, 3}, {159, 2}, {157, 3}, {154, 2},
+   {152, 3}, {149, 2}, {147, 2}, {145, 2}, {143, 2}, {141, 2}, {139, 2}, {137, 2},
+   {135, 2}, {133, 2}, {131, 2}, {129, 1}, {128, 2}, {126, 2}, {124, 1}, {123, 2},
+   {121, 1}, {120, 2}, {118, 1}, {117, 1}, {116, 2}, {114, 1}, {113, 1}, {112, 2},
+   {110, 1}, {109, 1}, {108, 1}, {107, 2}, {105, 1}, {104, 1}, {103, 1}, {102, 1},
+   {101, 1}, {100, 1}, {99, 1}, {98, 1}, {97, 1}, {96, 1}, {95, 1}, {94, 1},
+   {93, 1}, {92, 1}, {91, 0}, {91, 1}, {90, 1}, {89, 1}, {88, 1}, {87, 0},
+   {87, 1}, {86, 1}, {85, 1}, {84, 0}, {84, 1}, {83, 1}, {82, 1}, {81, 0},
+   {81, 1}, {80, 1}, {79, 0}, {79, 1}, {78, 0}, {78, 1}, {77, 1}, {76, 0},
+   {76, 1}, {75, 0}, {75, 1}, {74, 1}, {73, 0}, {73, 1}, {72, 0}, {72, 1},
+   {71, 0}, {71, 1}, {70, 0}, {70, 1}, {69, 0}, {69, 1}, {68, 0}, {68, 1},
+   {67, 0}, {67, 1}, {66, 0}, {66, 1}, {65, 0}, {65, 0}, {65, 1}, {64, 0},
+   {64, 1}, {63, 0}, {63, 1}, {62, 0}, {62, 0}, {62, 1}, {61, 0}, {61, 1},
+   {60, 0}, {60, 0}, {60, 1}, {59, 0}, {59, 0}, {59, 1}, {58, 0}, {58, 0},
+   {58, 1}, {57, 0}, {57, 0}, {57, 1}, {56, 0}, {56, 0}, {56, 1}, {55, 0},
+   {55, 0}, {55, 1}, {54, 0}, {54, 0}, {54, 1}, {53, 0}, {53, 0}, {53, 0},
+   {53, 1}, {52, 0}, {52, 0}, {52, 1}, {51, 0}, {51, 0}, {51, 0}, {51, 1},
+   {50, 0}, {50, 0}, {50, 0}, {50, 1}, {49, 0}, {49, 0}, {49, 0}, {49, 1},
+   {48, 0}, {48, 0}, {48, 0}, {48, 1}, {47, 0}, {47, 0}, {47, 0}, {47, 1},
+   {46, 0}, {46, 0}, {46, 0}, {46, 0}, {46, 1}, {45, 0}, {45, 0}, {45, 0},
+   {45, 1}, {44, 0}, {44, 0}, {44, 0}, {44, 0}, {44, 1}, {43, 0}, {43, 0},
+   {43, 0}, {43, 0}, {43, 1}, {42, 0}, {42, 0}, {42, 0}, {42, 0}, {42, 0},
+   {42, 1}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 1}, {40, 0},
+   {40, 0}, {40, 0}, {40, 0}, {40, 1}, {39, 0}, {39, 0}, {39, 0}, {39, 0},
+   {39, 0}, {39, 0}, {39, 1}, {38, 0}, {38, 0}, {38, 0}, {38, 0}, {38, 0},
+};
+
+const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {
+   {62500, 10417}, {52083, 7441}, {44642, 5580}, {39062, 4340}, {34722, 3472}, {31250, 2841}, {28409, 2368}, {26041, 2003},
+   {24038, 1717}, {22321, 1488}, {20833, 1302}, {19531, 1149}, {18382, 1021}, {17361, 914}, {16447, 822}, {15625, 745},
+   {14880, 676}, {14204, 618}, {13586, 566}, {13020, 520}, {12500, 481}, {12019, 445}, {11574, 414}, {11160, 385},
+   {10775, 359}, {10416, 336}, {10080, 315}, {9765, 296}, {9469, 278}, {9191, 263}, {8928, 248}, {8680, 235},
+   {8445, 222}, {8223, 211}, {8012, 200}, {7812, 191}, {7621, 181}, {7440, 173}, {7267, 165}, {7102, 158},
+   {6944, 151}, {6793, 145}, {6648, 138}, {6510, 133}, {6377, 127}, {6250, 123}, {6127, 118}, {6009, 113},
+   {5896, 109}, {5787, 106}, {5681, 101}, {5580, 98}, {5482, 95}, {5387, 91}, {5296, 88}, {5208, 86},
+   {5122, 82}, {5040, 80}, {4960, 78}, {4882, 75}, {4807, 73}, {4734, 70}, {4664, 69}, {4595, 67},
+   {4528, 64}, {4464, 63}, {4401, 61}, {4340, 60}, {4280, 58}, {4222, 56}, {4166, 55}, {4111, 53},
+   {4058, 52}, {4006, 51}, {3955, 49}, {3906, 48}, {3858, 48}, {3810, 45}, {3765, 45}, {3720, 44},
+   {3676, 43}, {3633, 42}, {3591, 40}, {3551, 40}, {3511, 39}, {3472, 38}, {3434, 38}, {3396, 36},
+   {3360, 36}, {3324, 35}, {3289, 34}, {3255, 34}, {3221, 33}, {3188, 32}, {3156, 31}, {3125, 31},
+   {3094, 31}, {3063, 30}, {3033, 29}, {3004, 28}, {2976, 28}, {2948, 28}, {2920, 27}, {2893, 27},
+   {2866, 26}, {2840, 25}, {2815, 25}, {2790, 25}, {2765, 24}, {2741, 24}, {2717, 24}, {2693, 23},
+   {2670, 22}, {2648, 22}, {2626, 22}, {2604, 22}, {2582, 21}, {2561, 21}, {2540, 20}, {2520, 20},
+   {2500, 20}, {2480, 20}, {2460, 19}, {2441, 19}, {2422, 19}, {2403, 18}, {2385, 18}, {2367, 18},
+   {2349, 17}, {2332, 18}, {2314, 17}, {2297, 16}, {2281, 17}, {2264, 16}, {2248, 16}, {2232, 16},
+   {2216, 16}, {2200, 15}, {2185, 15}, {2170, 15}, {2155, 15}, {2140, 15}, {2125, 14}, {2111, 14},
+   {2097, 14}, {2083, 14}, {2069, 14}, {2055, 13}, {2042, 13}, {2029, 13}, {2016, 13}, {2003, 13},
+   {1990, 13}, {1977, 12}, {1965, 12}, {1953, 13}, {1940, 11}, {1929, 12}, {1917, 12}, {1905, 12},
+   {1893, 11}, {1882, 11}, {1871, 11}, {1860, 11}, {1849, 11}, {1838, 11}, {1827, 11}, {1816, 10},
+   {1806, 11}, {1795, 10}, {1785, 10}, {1775, 10}, {1765, 10}, {1755, 10}, {1745, 9}, {1736, 10},
+   {1726, 9}, {1717, 10}, {1707, 9}, {1698, 9}, {1689, 9}, {1680, 9}, {1671, 9}, {1662, 9},
+   {1653, 9}, {1644, 8}, {1636, 9}, {1627, 8}, {1619, 9}, {1610, 8}, {1602, 8}, {1594, 8},
+   {1586, 8}, {1578, 8}, {1570, 8}, {1562, 8}, {1554, 7}, {1547, 8}, {1539, 8}, {1531, 7},
+   {1524, 8}, {1516, 7}, {1509, 7}, {1502, 7}, {1495, 7}, {1488, 7}, {1481, 7}, {1474, 7},
+   {1467, 7}, {1460, 7}, {1453, 7}, {1446, 6}, {1440, 7}, {1433, 7}, {1426, 6}, {1420, 6},
+   {1414, 7}, {1407, 6}, {1401, 6}, {1395, 7}, {1388, 6}, {1382, 6}, {1376, 6}, {1370, 6},
+   {1364, 6}, {1358, 6}, {1352, 6}, {1346, 5}, {1341, 6}, {1335, 6}, {1329, 5}, {1324, 6},
+   {1318, 5}, {1313, 6}, {1307, 5}, {1302, 6}, {1296, 5}, {1291, 5}, {1286, 6}, {1280, 5},
+   {1275, 5}, {1270, 5}, {1265, 5}, {1260, 5}, {1255, 5}, {1250, 5}, {1245, 5}, {1240, 5},
+   {1235, 5}, {1230, 5}, {1225, 5}, {1220, 5}, {1215, 4}, {1211, 5}, {1206, 5}, {1201, 5},
+};
+
+#endif
+
 #endif
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 55c0990..e9b42f45 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -236,8 +236,8 @@ FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
     step_loops = 1;
   } 
   
-  if(step_rate < 32) step_rate = 32;
-  step_rate -= 32; // Correct for minimal speed
+  if(step_rate < (F_CPU/500000)) step_rate = (F_CPU/500000);
+  step_rate -= (F_CPU/500000); // Correct for minimal speed
   if(step_rate >= (8*256)){ // higher step rate 
     unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate>>8)][0];
     unsigned char tmp_step_rate = (step_rate & 0x00ff);
@@ -714,23 +714,33 @@ void st_init()
   //Initialize Step Pins
   #if (X_STEP_PIN > -1) 
     SET_OUTPUT(X_STEP_PIN);
+    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
   #endif  
   #if (Y_STEP_PIN > -1) 
     SET_OUTPUT(Y_STEP_PIN);
+    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
   #endif  
   #if (Z_STEP_PIN > -1) 
     SET_OUTPUT(Z_STEP_PIN);
+    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
   #endif  
   #if (E0_STEP_PIN > -1) 
     SET_OUTPUT(E0_STEP_PIN);
+    if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);
   #endif  
   #if defined(E1_STEP_PIN) && (E1_STEP_PIN > -1) 
     SET_OUTPUT(E1_STEP_PIN);
+    if(!E_ENABLE_ON) WRITE(E1_ENABLE_PIN,HIGH);
   #endif  
   #if defined(E2_STEP_PIN) && (E2_STEP_PIN > -1) 
     SET_OUTPUT(E2_STEP_PIN);
+    if(!E_ENABLE_ON) WRITE(E2_ENABLE_PIN,HIGH);
   #endif  
 
+  #ifdef CONTROLLERFAN_PIN
+    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
+  #endif
+  
   // waveform generation = 0100 = CTC
   TCCR1B &= ~(1<<WGM13);
   TCCR1B |=  (1<<WGM12);
@@ -740,7 +750,13 @@ void st_init()
   // output mode = 00 (disconnected)
   TCCR1A &= ~(3<<COM1A0); 
   TCCR1A &= ~(3<<COM1B0); 
-  TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (2<<CS10); // 2MHz timer
+  
+  // Set the timer pre-scaler
+  // Generally we use a divider of 8, resulting in a 2MHz timer
+  // frequency on a 16MHz MCU. If you are going to change this, be
+  // sure to regenerate speed_lookuptable.h with
+  // create_speed_lookuptable.py
+  TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (2<<CS10);
 
   OCR1A = 0x4000;
   TCNT1 = 0;
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 77f9491..6578f4e 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -62,7 +62,7 @@ int current_raw_bed = 0;
 //===========================================================================
 //=============================private variables============================
 //===========================================================================
-static bool temp_meas_ready = false;
+static volatile bool temp_meas_ready = false;
 
 static unsigned long  previous_millis_bed_heater;
 //static unsigned long previous_millis_heater;
@@ -132,7 +132,94 @@ static unsigned long  previous_millis_bed_heater;
 //===========================================================================
 //=============================   functions      ============================
 //===========================================================================
+
+void PID_autotune(float temp)
+{
+  float input;
+  int cycles=0;
+  bool heating = true;
+  soft_pwm[0] = 255>>1;
+
+  unsigned long temp_millis = millis();
+  unsigned long t1=temp_millis;
+  unsigned long t2=temp_millis;
+  long t_high;
+  long t_low;
+
+  long bias=127;
+  long d = 127;
+  float Ku, Tu;
+  float Kp, Ki, Kd;
+  float max, min;
   
+  SERIAL_ECHOLN("PID Autotune start");
+
+  for(;;) {
+
+    if(temp_meas_ready == true) { // temp sample ready
+      CRITICAL_SECTION_START;
+      temp_meas_ready = false;
+      CRITICAL_SECTION_END;
+      input = analog2temp(current_raw[0], 0);
+      
+      max=max(max,input);
+      min=min(min,input);
+      if(heating == true && input > temp) {
+        if(millis() - t2 > 5000) { 
+          heating=false;
+          soft_pwm[0] = (bias - d) >> 1;
+          t1=millis();
+          t_high=t1 - t2;
+          max=temp;
+        }
+      }
+      if(heating == false && input < temp) {
+        if(millis() - t1 > 5000) {
+          heating=true;
+          t2=millis();
+          t_low=t2 - t1;
+          if(cycles > 0) {
+            bias += (d*(t_high - t_low))/(t_low + t_high);
+            bias = constrain(bias, 20 ,235);
+            if(bias > 127) d = 254 - bias;
+            else d = bias;
+
+            SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);
+            SERIAL_PROTOCOLPGM(" d: "); SERIAL_PROTOCOL(d);
+            SERIAL_PROTOCOLPGM(" min: "); SERIAL_PROTOCOL(min);
+            SERIAL_PROTOCOLPGM(" max: "); SERIAL_PROTOCOLLN(max);
+            if(cycles > 2) {
+              Ku = (4.0*d)/(3.14159*(max-min)/2.0);
+              Tu = ((float)(t_low + t_high)/1000.0);
+              Kp = 0.6*Ku;
+              Ki = 2*Kp/Tu;
+              Kd = Kp*Tu/8;
+              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
+              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
+              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
+            }
+          }
+          soft_pwm[0] = (bias + d) >> 1;
+          cycles++;
+          min=temp;
+        }
+      } 
+    }
+    if(input > (temp + 20)) {
+      SERIAL_PROTOCOLLNPGM("PID Autotune failed !, Temperature to high");
+      return;
+    }
+    if(millis() - temp_millis > 2000) {
+      temp_millis = millis();
+      SERIAL_PROTOCOLPGM("ok T:");
+      SERIAL_PROTOCOL(degHotend(0));   
+      SERIAL_PROTOCOLPGM(" @:");
+      SERIAL_PROTOCOLLN(getHeaterPower(0));       
+    }
+    LCD_STATUS;
+  }
+}
+
 void updatePID()
 {
 #ifdef PIDTEMP
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 80e68f7..e122a31 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -1,162 +1,165 @@
-/*
-  temperature.h - temperature controller
-  Part of Marlin
-
-  Copyright (c) 2011 Erik van der Zalm
-
-  Grbl is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  Grbl is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef temperature_h
-#define temperature_h 
-
-#include "Marlin.h"
-#include "planner.h"
-#ifdef PID_ADD_EXTRUSION_RATE
-  #include "stepper.h"
-#endif
-
-// public functions
-void tp_init();  //initialise the heating
-void manage_heater(); //it is critical that this is called periodically.
-
-//low leven conversion routines
-// do not use this routines and variables outsie of temperature.cpp
-int temp2analog(int celsius, uint8_t e);
-int temp2analogBed(int celsius);
-float analog2temp(int raw, uint8_t e);
-float analog2tempBed(int raw);
-extern int target_raw[EXTRUDERS];  
-extern int heatingtarget_raw[EXTRUDERS];  
-extern int current_raw[EXTRUDERS];
-extern int target_raw_bed;
-extern int current_raw_bed;
-#ifdef BED_LIMIT_SWITCHING
-  extern int target_bed_low_temp ;  
-  extern int target_bed_high_temp ;
-#endif
-extern float Kp,Ki,Kd,Kc;
-
-#ifdef PIDTEMP
-  extern float pid_setpoint[EXTRUDERS];
-#endif
-  
-// #ifdef WATCHPERIOD
-  extern int watch_raw[EXTRUDERS] ;
-//   extern unsigned long watchmillis;
-// #endif
-
-
-//high level conversion routines, for use outside of temperature.cpp
-//inline so that there is no performance decrease.
-//deg=degreeCelsius
-
-FORCE_INLINE float degHotend(uint8_t extruder) {  
-  return analog2temp(current_raw[extruder], extruder);
-};
-
-FORCE_INLINE float degBed() {
-  return analog2tempBed(current_raw_bed);
-};
-
-FORCE_INLINE float degTargetHotend(uint8_t extruder) {  
-  return analog2temp(target_raw[extruder], extruder);
-};
-
-FORCE_INLINE float degTargetBed() {   
-  return analog2tempBed(target_raw_bed);
-};
-
-FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  
-  target_raw[extruder] = temp2analog(celsius, extruder);
-#ifdef PIDTEMP
-  pid_setpoint[extruder] = celsius;
-#endif //PIDTEMP
-};
-
-FORCE_INLINE void setTargetBed(const float &celsius) {  
-  
-  target_raw_bed = temp2analogBed(celsius);
-  #ifdef BED_LIMIT_SWITCHING
-    if(celsius>BED_HYSTERESIS)
-    {
-    target_bed_low_temp= temp2analogBed(celsius-BED_HYSTERESIS);
-    target_bed_high_temp= temp2analogBed(celsius+BED_HYSTERESIS);
-    }
-    else
-    { 
-      target_bed_low_temp=0;
-      target_bed_high_temp=0;
-    }
-  #endif
-};
-
-FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  
-  return target_raw[extruder] > current_raw[extruder];
-};
-
-FORCE_INLINE bool isHeatingBed() {
-  return target_raw_bed > current_raw_bed;
-};
-
-FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  
-  return target_raw[extruder] < current_raw[extruder];
-};
-
-FORCE_INLINE bool isCoolingBed() {
-  return target_raw_bed < current_raw_bed;
-};
-
-#define degHotend0() degHotend(0)
-#define degTargetHotend0() degTargetHotend(0)
-#define setTargetHotend0(_celsius) setTargetHotend((_celsius), 0)
-#define isHeatingHotend0() isHeatingHotend(0)
-#define isCoolingHotend0() isCoolingHotend(0)
-#if EXTRUDERS > 1
-#define degHotend1() degHotend(1)
-#define degTargetHotend1() degTargetHotend(1)
-#define setTargetHotend1(_celsius) setTargetHotend((_celsius), 1)
-#define isHeatingHotend1() isHeatingHotend(1)
-#define isCoolingHotend1() isCoolingHotend(1)
-#endif
-#if EXTRUDERS > 2
-#define degHotend2() degHotend(2)
-#define degTargetHotend2() degTargetHotend(2)
-#define setTargetHotend2(_celsius) setTargetHotend((_celsius), 2)
-#define isHeatingHotend2() isHeatingHotend(2)
-#define isCoolingHotend2() isCoolingHotend(2)
-#endif
-#if EXTRUDERS > 3
-#error Invalid number of extruders
-#endif
-
-
-
-int getHeaterPower(int heater);
-void disable_heater();
-void setWatch();
-void updatePID();
-
-FORCE_INLINE void autotempShutdown(){
- #ifdef AUTOTEMP
- if(autotemp_enabled)
- {
-  autotemp_enabled=false;
-  if(degTargetHotend(ACTIVE_EXTRUDER)>autotemp_min)
-    setTargetHotend(0,ACTIVE_EXTRUDER);
- }
- #endif
-}
-#endif
+/*
+  temperature.h - temperature controller
+  Part of Marlin
+
+  Copyright (c) 2011 Erik van der Zalm
+
+  Grbl is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  Grbl is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef temperature_h
+#define temperature_h 
+
+#include "Marlin.h"
+#include "planner.h"
+#ifdef PID_ADD_EXTRUSION_RATE
+  #include "stepper.h"
+#endif
+
+// public functions
+void tp_init();  //initialise the heating
+void manage_heater(); //it is critical that this is called periodically.
+
+//low leven conversion routines
+// do not use this routines and variables outsie of temperature.cpp
+int temp2analog(int celsius, uint8_t e);
+int temp2analogBed(int celsius);
+float analog2temp(int raw, uint8_t e);
+float analog2tempBed(int raw);
+extern int target_raw[EXTRUDERS];  
+extern int heatingtarget_raw[EXTRUDERS];  
+extern int current_raw[EXTRUDERS];
+extern int target_raw_bed;
+extern int current_raw_bed;
+#ifdef BED_LIMIT_SWITCHING
+  extern int target_bed_low_temp ;  
+  extern int target_bed_high_temp ;
+#endif
+extern float Kp,Ki,Kd,Kc;
+
+#ifdef PIDTEMP
+  extern float pid_setpoint[EXTRUDERS];
+#endif
+  
+// #ifdef WATCHPERIOD
+  extern int watch_raw[EXTRUDERS] ;
+//   extern unsigned long watchmillis;
+// #endif
+
+
+//high level conversion routines, for use outside of temperature.cpp
+//inline so that there is no performance decrease.
+//deg=degreeCelsius
+
+FORCE_INLINE float degHotend(uint8_t extruder) {  
+  return analog2temp(current_raw[extruder], extruder);
+};
+
+FORCE_INLINE float degBed() {
+  return analog2tempBed(current_raw_bed);
+};
+
+FORCE_INLINE float degTargetHotend(uint8_t extruder) {  
+  return analog2temp(target_raw[extruder], extruder);
+};
+
+FORCE_INLINE float degTargetBed() {   
+  return analog2tempBed(target_raw_bed);
+};
+
+FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  
+  target_raw[extruder] = temp2analog(celsius, extruder);
+#ifdef PIDTEMP
+  pid_setpoint[extruder] = celsius;
+#endif //PIDTEMP
+};
+
+FORCE_INLINE void setTargetBed(const float &celsius) {  
+  
+  target_raw_bed = temp2analogBed(celsius);
+  #ifdef BED_LIMIT_SWITCHING
+    if(celsius>BED_HYSTERESIS)
+    {
+    target_bed_low_temp= temp2analogBed(celsius-BED_HYSTERESIS);
+    target_bed_high_temp= temp2analogBed(celsius+BED_HYSTERESIS);
+    }
+    else
+    { 
+      target_bed_low_temp=0;
+      target_bed_high_temp=0;
+    }
+  #endif
+};
+
+FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  
+  return target_raw[extruder] > current_raw[extruder];
+};
+
+FORCE_INLINE bool isHeatingBed() {
+  return target_raw_bed > current_raw_bed;
+};
+
+FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  
+  return target_raw[extruder] < current_raw[extruder];
+};
+
+FORCE_INLINE bool isCoolingBed() {
+  return target_raw_bed < current_raw_bed;
+};
+
+#define degHotend0() degHotend(0)
+#define degTargetHotend0() degTargetHotend(0)
+#define setTargetHotend0(_celsius) setTargetHotend((_celsius), 0)
+#define isHeatingHotend0() isHeatingHotend(0)
+#define isCoolingHotend0() isCoolingHotend(0)
+#if EXTRUDERS > 1
+#define degHotend1() degHotend(1)
+#define degTargetHotend1() degTargetHotend(1)
+#define setTargetHotend1(_celsius) setTargetHotend((_celsius), 1)
+#define isHeatingHotend1() isHeatingHotend(1)
+#define isCoolingHotend1() isCoolingHotend(1)
+#endif
+#if EXTRUDERS > 2
+#define degHotend2() degHotend(2)
+#define degTargetHotend2() degTargetHotend(2)
+#define setTargetHotend2(_celsius) setTargetHotend((_celsius), 2)
+#define isHeatingHotend2() isHeatingHotend(2)
+#define isCoolingHotend2() isCoolingHotend(2)
+#endif
+#if EXTRUDERS > 3
+#error Invalid number of extruders
+#endif
+
+
+
+int getHeaterPower(int heater);
+void disable_heater();
+void setWatch();
+void updatePID();
+
+FORCE_INLINE void autotempShutdown(){
+ #ifdef AUTOTEMP
+ if(autotemp_enabled)
+ {
+  autotemp_enabled=false;
+  if(degTargetHotend(active_extruder)>autotemp_min)
+    setTargetHotend(0,active_extruder);
+ }
+ #endif
+}
+
+void PID_autotune(float temp);
+
+#endif
 
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index 47dc2d5..4629e2e 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -315,19 +315,18 @@ void MainMenu::showStatus()
   static int olddegHotEnd0=-1;
   static int oldtargetHotEnd0=-1;
   //force_lcd_update=true;
-  if(force_lcd_update||feedmultiplychanged)  //initial display of content
+  if(force_lcd_update)  //initial display of content
   {
-    feedmultiplychanged=false;
     encoderpos=feedmultiply;
     clear();
-    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
+    lcd.setCursor(0,0);lcdprintPGM("\002---/---\001 ");
     #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-      lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
+      lcd.setCursor(10,0);lcdprintPGM("B---/---\001 ");
     #endif
   }
     
   int tHotEnd0=intround(degHotend0());
-  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update) //>1 because otherwise the lcd is refreshed to often.
+  if((tHotEnd0!=olddegHotEnd0)||force_lcd_update)
   {
     lcd.setCursor(1,0);
     lcd.print(ftostr3(tHotEnd0));
@@ -379,8 +378,15 @@ void MainMenu::showStatus()
     lcdprintPGM("Z:");lcd.print(ftostr52(current_position[2]));
     oldzpos=currentz;
   }
+  
   static int oldfeedmultiply=0;
   int curfeedmultiply=feedmultiply;
+  
+  if(feedmultiplychanged == true) {
+    feedmultiplychanged = false;
+    encoderpos = curfeedmultiply;
+  }
+  
   if(encoderpos!=curfeedmultiply||force_lcd_update)
   {
    curfeedmultiply=encoderpos;
@@ -391,12 +397,14 @@ void MainMenu::showStatus()
    feedmultiply=curfeedmultiply;
    encoderpos=curfeedmultiply;
   }
+  
   if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
   {
    oldfeedmultiply=curfeedmultiply;
    lcd.setCursor(0,2);
    lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
   }
+  
   if(messagetext[0]!='\0')
   {
     lcd.setCursor(0,LCD_HEIGHT-1);
@@ -404,7 +412,6 @@ void MainMenu::showStatus()
     uint8_t n=strlen(messagetext);
     for(int8_t i=0;i<LCD_WIDTH-n;i++)
       lcd.print(" ");
-    
     messagetext[0]='\0';
   }
   
@@ -498,10 +505,18 @@ void MainMenu::showPrepare()
       MENUITEM(  lcdprintPGM(MSG_SET_ORIGIN)  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
       break;
     case ItemP_preheat_pla:
-      MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA)  ,  BLOCK;setTargetHotend0(PLA_PREHEAT_HOTEND_TEMP);setTargetBed(PLA_PREHEAT_HPB_TEMP);analogWrite(FAN_PIN, PLA_PREHEAT_FAN_SPEED); beepshort(); ) ;
+      MENUITEM(  lcdprintPGM(MSG_PREHEAT_PLA)  ,  BLOCK;setTargetHotend0(PLA_PREHEAT_HOTEND_TEMP);setTargetBed(PLA_PREHEAT_HPB_TEMP);
+      #if FAN_PIN > -1
+        analogWrite(FAN_PIN, PLA_PREHEAT_FAN_SPEED);
+      #endif
+      beepshort(); );
       break;
     case ItemP_preheat_abs:
-      MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS)  ,  BLOCK;setTargetHotend0(ABS_PREHEAT_HOTEND_TEMP);setTargetBed(ABS_PREHEAT_HPB_TEMP); analogWrite(FAN_PIN, ABS_PREHEAT_FAN_SPEED); beepshort(); ) ;
+      MENUITEM(  lcdprintPGM(MSG_PREHEAT_ABS)  ,  BLOCK;setTargetHotend0(ABS_PREHEAT_HOTEND_TEMP);setTargetBed(ABS_PREHEAT_HPB_TEMP); 
+      #if FAN_PIN > -1
+        analogWrite(FAN_PIN, ABS_PREHEAT_FAN_SPEED);
+      #endif
+      beepshort(); );
       break;
     case ItemP_cooldown:
       MENUITEM(  lcdprintPGM(MSG_COOLDOWN)  ,  BLOCK;setTargetHotend0(0);setTargetBed(0);beepshort(); ) ;

