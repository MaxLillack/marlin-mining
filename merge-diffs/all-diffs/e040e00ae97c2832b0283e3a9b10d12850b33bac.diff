commit e040e00ae97c2832b0283e3a9b10d12850b33bac (from 52b6b8e36b3d8926d4364d5ccb9a2c19bc1f9b24)
Merge: 52b6b8e f26d542
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 19:42:38 2016 -0700

    Merge pull request #4514 from thinkyhead/rc_cleanup_circularqueue
    
    Patch up CircularQueue

diff --git a/Marlin/circularqueue.h b/Marlin/circularqueue.h
index 99efd24..9aafb99 100644
--- a/Marlin/circularqueue.h
+++ b/Marlin/circularqueue.h
@@ -26,120 +26,119 @@
 #include <Arduino.h>
 
 /**
- * @brief Circular Queue class
+ * @brief   Circular Queue class
  * @details Implementation of the classic ring buffer data structure
  */
-template<typename T, int N>
+template<typename T, uint8_t N>
 class CircularQueue {
   private:
 
     /**
-     * @brief Buffer structure
+     * @brief   Buffer structure
      * @details This structure consolidates all the overhead required to handle
-     * a circular queue such as the pointers and the buffer vector.
+     *          a circular queue such as the pointers and the buffer vector.
      */
     struct buffer_t {
       uint8_t head;
       uint8_t tail;
+      uint8_t count;
       uint8_t size;
-      uint8_t length;
       T queue[N];
     } buffer;
 
   public:
     /**
-     * @brief Class constructor
+     * @brief   Class constructor
      * @details This class requires two template parameters, T defines the type
-     * of the items this queue will handle and N defines the maximum number of
-     * items that can be stored on the queue.
+     *          of item this queue will handle and N defines the maximum number of
+     *          items that can be stored on the queue.
      */
     CircularQueue<T, N>() {
-      this->buffer.length = N;
-      this->buffer.size = this->buffer.head = this->buffer.tail = 0;
+      this->buffer.size = N;
+      this->buffer.count = this->buffer.head = this->buffer.tail = 0;
     }
 
     /**
-     * @brief Removes and returns a item from the queue
-     * @details Removes the oldest item on the queue which is pointed by the
-     * buffer_t head variable, this item is then returned to the caller.
-     * @return type T item
+     * @brief   Removes and returns a item from the queue
+     * @details Removes the oldest item on the queue, pointed to by the
+     *          buffer_t head field. The item is returned to the caller.
+     * @return  type T item
      */
     T dequeue() {
       if (this->isEmpty()) return T();
 
-      T const item = this->buffer.queue[this->buffer.head++];
-      --this->buffer.size;
+      uint8_t index = this->buffer.head;
 
-      if (this->buffer.head == this->buffer.length)
+      --this->buffer.count;
+      if (++this->buffer.head == this->buffer.size)
         this->buffer.head = 0;
 
-      return item;
+      return this->buffer.queue[index];
     }
 
     /**
-     * @brief Adds an item to the queue
-     * @details Adds a item to the queue on the location pointed by the buffer_t
-     * tail vairable, will return false if there is no queue space available.
-     *
-     * @param item Item to be added to the queue
-     * @return true if the operation was successfull
+     * @brief   Adds an item to the queue
+     * @details Adds an item to the queue on the location pointed by the buffer_t
+     *          tail variable. Returns false if no queue space is available.
+     * @param   item Item to be added to the queue
+     * @return  true if the operation was successful
      */
     bool enqueue(T const &item) {
       if (this->isFull()) return false;
 
-      this->buffer.queue[this->buffer.tail++] = item;
-      ++this->buffer.size;
+      this->buffer.queue[this->buffer.tail] = item;
 
-      if (this->buffer.tail == this->buffer.length)
+      ++this->buffer.count;
+      if (++this->buffer.tail == this->buffer.size)
         this->buffer.tail = 0;
 
       return true;
     }
 
     /**
-     * @brief Checks if the queue has no items
+     * @brief   Checks if the queue has no items
      * @details Returns true if there are no items on the queue, false otherwise.
-     * @return true if queue is empty
+     * @return  true if queue is empty
      */
     bool isEmpty() {
-      return this->buffer.size == 0;
+      return this->buffer.count == 0;
     }
 
     /**
-     * @brief Checks if the queue is full
+     * @brief   Checks if the queue is full
      * @details Returns true if the queue is full, false otherwise.
-     * @return true if queue is full
+     * @return  true if queue is full
      */
     bool isFull() {
-      return this->buffer.size == this->buffer.length;
+      return this->buffer.count == this->buffer.size;
     }
 
     /**
-     * @brief Gets the queue size
+     * @brief   Gets the queue size
      * @details Returns the maximum number of items a queue can have.
-     * @return the queue lenght
+     * @return  the queue size
      */
-    uint8_t length() {
-      return this->buffer.length;
+    uint8_t size() {
+      return this->buffer.size;
     }
 
     /**
-     * @brief Gets the next item from the queue without removing it
-     * @details Returns the next item on the queue but the item is not removed
-     * from the queue nor the pointers updated.
-     * @return the queue size
+     * @brief   Gets the next item from the queue without removing it
+     * @details Returns the next item in the queue without removing it
+     *          or updating the pointers.
+     * @return  first item in the queue
      */
-    uint8_t peek() {
+    T peek() {
       return this->buffer.queue[this->buffer.head];
     }
 
     /**
      * @brief Gets the number of items on the queue
      * @details Returns the current number of items stored on the queue.
-     * @return type T item
+     * @return number of items in the queue
      */
-    uint8_t size() {
-      return this->buffer.size;
+    uint8_t count() {
+      return this->buffer.count;
     }
 };
 

commit e040e00ae97c2832b0283e3a9b10d12850b33bac (from f26d5425bf03f5ea704371ca94a10b465f3e4030)
Merge: 52b6b8e f26d542
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 19:42:38 2016 -0700

    Merge pull request #4514 from thinkyhead/rc_cleanup_circularqueue
    
    Patch up CircularQueue

diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 1f0f309..6eb5eff 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -190,34 +190,54 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   #endif
 
   /**
-   * START_SCREEN generates the init code for a screen function
+   * START_SCREEN_OR_MENU generates init code for a screen or menu
    *
    *   encoderLine is the position based on the encoder
    *   encoderTopLine is the top menu line to display
    *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
    *   _menuLineNr is the menu item to draw and process
    *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+   *   _countedItems is the total number of items in the menu (after one call)
    */
-  #define _START_SCREEN(CODE, SKIP) \
+  #define START_SCREEN_OR_MENU(LIMIT) \
     ENCODER_DIRECTION_MENUS(); \
     encoderRateMultiplierEnabled = false; \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
+    static int8_t _countedItems = 0; \
     int8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
-    NOMORE(encoderTopLine, encoderLine); \
+    if (_countedItems > 0 && encoderLine >= _countedItems - LIMIT) { \
+      encoderLine = _countedItems - LIMIT; \
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    }
+
+  #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
-    bool _skipStatic = SKIP; \
-    CODE; \
     for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT; _lcdLineNr++, _menuLineNr++) { \
-      _thisItemNr = 0;
-
-  #define START_SCREEN() _START_SCREEN(NOOP, false)
+      _thisItemNr = 0
 
   /**
-   * START_MENU generates the init code for a menu function
+   * START_SCREEN  Opening code for a screen having only static items.
+   *               Do simplified scrolling of the entire screen.
    *
-   *   wasClicked indicates the controller was clicked
+   * START_MENU    Opening code for a screen with menu items.
+   *               Scroll as-needed to keep the selected line in view.
+   *               'wasClicked' indicates the controller was clicked.
    */
-  #define START_MENU() _START_SCREEN(bool wasClicked = LCD_CLICKED, true)
+  #define START_SCREEN() \
+    START_SCREEN_OR_MENU(LCD_HEIGHT); \
+    encoderTopLine = encoderLine; \
+    bool _skipStatic = false; \
+    SCREEN_OR_MENU_LOOP()
+
+  #define START_MENU() \
+    START_SCREEN_OR_MENU(1); \
+    NOMORE(encoderTopLine, encoderLine); \
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
+      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
+    } \
+    bool wasClicked = LCD_CLICKED; \
+    bool _skipStatic = true; \
+    SCREEN_OR_MENU_LOOP()
 
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
@@ -252,7 +272,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
         return; \
       } \
     } \
-    _thisItemNr++
+    ++_thisItemNr
 
   #define MENU_ITEM(TYPE, LABEL, ARGS...) do { \
       _skipStatic = false; \
@@ -270,42 +290,15 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## ARGS); \
     } \
-    _thisItemNr++
-
-  /**
-   *
-   * END_SCREEN  Closing code for a screen having only static items.
-   *             Do simplified scrolling of the entire screen.
-   *
-   * END_MENU    Closing code for a screen with menu items.
-   *             Scroll as-needed to keep the selected line in view.
-   *
-   * At this point _thisItemNr equals the total number of items.
-   *
-   */
+    ++_thisItemNr
 
-  // Simple-scroll by using encoderLine as encoderTopLine
   #define END_SCREEN() \
     } \
-    NOMORE(encoderLine, _thisItemNr - LCD_HEIGHT); \
-    NOLESS(encoderLine, 0); \
-    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    if (encoderTopLine != encoderLine) { \
-      encoderTopLine = encoderLine; \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    }
+    _countedItems = _thisItemNr
 
-  // Scroll through menu items, scrolling as-needed to stay in view
   #define END_MENU() \
     } \
-    if (encoderLine >= _thisItemNr) { \
-      encoderLine = _thisItemNr - 1; \
-      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    } \
-    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
-      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    } \
+    _countedItems = _thisItemNr; \
     UNUSED(_skipStatic)
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)

