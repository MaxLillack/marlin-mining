commit 704ae1b73734018568c0baa7257f6e4e02b0da8e (from 7ed70305df56b2778d005024b60013ab904959cf)
Merge: 7ed7030 229f70f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 21:14:30 2016 -0700

    Merge pull request #4516 from thinkyhead/rc_short_prints_quiet
    
    Only report finished prints longer than 1 min

diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 2cc1b2a..65b4093 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -616,7 +616,8 @@ void CardReader::printingHasFinished() {
     if (SD_FINISHED_STEPPERRELEASE)
       enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
     print_job_timer.stop();
-    enqueue_and_echo_commands_P(PSTR("M31"));
+    if (print_job_timer.duration() > 60)
+      enqueue_and_echo_commands_P(PSTR("M31"));
   }
 }
 

commit 704ae1b73734018568c0baa7257f6e4e02b0da8e (from 229f70f1940eb45bcc066ee359636860853b4bf9)
Merge: 7ed7030 229f70f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 21:14:30 2016 -0700

    Merge pull request #4516 from thinkyhead/rc_short_prints_quiet
    
    Only report finished prints longer than 1 min

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 3aa0aff..9f289f2 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -215,7 +215,6 @@ void manage_inactivity(bool ignore_stepper_queue = false);
 /**
  * The axis order in all axis related arrays is X, Y, Z, E
  */
-#define NUM_AXIS 4
 #define _AXIS(AXIS) AXIS ##_AXIS
 
 void enable_all_steppers();
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index 304b3be..9ef9002 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -29,10 +29,12 @@
   Modified 14 February 2016 by Andreas Hardtung (added tx buffer)
 */
 
-#include "Marlin.h"
 #include "MarlinSerial.h"
+
 #include "stepper.h"
 
+#include "Marlin.h"
+
 #ifndef USBCON
 // this next line disables the entire HardwareSerial.cpp,
 // this is so I can support Attiny series and any other chip without a UART
diff --git a/Marlin/MarlinSerial.h b/Marlin/MarlinSerial.h
index a5e2ee7..e761752 100644
--- a/Marlin/MarlinSerial.h
+++ b/Marlin/MarlinSerial.h
@@ -31,13 +31,8 @@
 
 #ifndef MarlinSerial_h
 #define MarlinSerial_h
-#include "Marlin.h"
-
-#ifndef CRITICAL_SECTION_START
-  #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();
-  #define CRITICAL_SECTION_END    SREG = _sreg;
-#endif
 
+#include "MarlinConfig.h"
 
 #ifndef SERIAL_PORT
   #define SERIAL_PORT 0
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ccffdf7..84493cf 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -61,6 +61,7 @@
 #include "math.h"
 #include "nozzle.h"
 #include "duration_t.h"
+#include "types.h"
 
 #if ENABLED(USE_WATCHDOG)
   #include "watchdog.h"
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index 4548acf..199d64e 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -23,6 +23,7 @@
 #ifndef __BUZZER_H__
 #define __BUZZER_H__
 
+#include "types.h"
 #include "fastio.h"
 #include "circularqueue.h"
 #include "temperature.h"
@@ -127,7 +128,9 @@ class Buzzer {
 
         if (this->state.tone.frequency > 0) {
           #if ENABLED(SPEAKER)
+            CRITICAL_SECTION_START;
             ::tone(BEEPER_PIN, this->state.tone.frequency, this->state.tone.duration);
+            CRITICAL_SECTION_END;
           #else
             this->on();
           #endif
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index f564390..65b4093 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -20,13 +20,15 @@
  *
  */
 
-#include "Marlin.h"
 #include "cardreader.h"
+
 #include "ultralcd.h"
 #include "stepper.h"
 #include "temperature.h"
 #include "language.h"
 
+#include "Marlin.h"
+
 #if ENABLED(SDSUPPORT)
 
 CardReader::CardReader() {
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 31b8238..8c22e58 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -23,11 +23,15 @@
 #ifndef CARDREADER_H
 #define CARDREADER_H
 
+#include "MarlinConfig.h"
+
 #if ENABLED(SDSUPPORT)
 
 #define MAX_DIR_DEPTH 10          // Maximum folder depth
 
 #include "SdFile.h"
+
+#include "types.h"
 #include "enum.h"
 
 class CardReader {
diff --git a/Marlin/circularqueue.h b/Marlin/circularqueue.h
index 99efd24..9aafb99 100644
--- a/Marlin/circularqueue.h
+++ b/Marlin/circularqueue.h
@@ -26,120 +26,119 @@
 #include <Arduino.h>
 
 /**
- * @brief Circular Queue class
+ * @brief   Circular Queue class
  * @details Implementation of the classic ring buffer data structure
  */
-template<typename T, int N>
+template<typename T, uint8_t N>
 class CircularQueue {
   private:
 
     /**
-     * @brief Buffer structure
+     * @brief   Buffer structure
      * @details This structure consolidates all the overhead required to handle
-     * a circular queue such as the pointers and the buffer vector.
+     *          a circular queue such as the pointers and the buffer vector.
      */
     struct buffer_t {
       uint8_t head;
       uint8_t tail;
+      uint8_t count;
       uint8_t size;
-      uint8_t length;
       T queue[N];
     } buffer;
 
   public:
     /**
-     * @brief Class constructor
+     * @brief   Class constructor
      * @details This class requires two template parameters, T defines the type
-     * of the items this queue will handle and N defines the maximum number of
-     * items that can be stored on the queue.
+     *          of item this queue will handle and N defines the maximum number of
+     *          items that can be stored on the queue.
      */
     CircularQueue<T, N>() {
-      this->buffer.length = N;
-      this->buffer.size = this->buffer.head = this->buffer.tail = 0;
+      this->buffer.size = N;
+      this->buffer.count = this->buffer.head = this->buffer.tail = 0;
     }
 
     /**
-     * @brief Removes and returns a item from the queue
-     * @details Removes the oldest item on the queue which is pointed by the
-     * buffer_t head variable, this item is then returned to the caller.
-     * @return type T item
+     * @brief   Removes and returns a item from the queue
+     * @details Removes the oldest item on the queue, pointed to by the
+     *          buffer_t head field. The item is returned to the caller.
+     * @return  type T item
      */
     T dequeue() {
       if (this->isEmpty()) return T();
 
-      T const item = this->buffer.queue[this->buffer.head++];
-      --this->buffer.size;
+      uint8_t index = this->buffer.head;
 
-      if (this->buffer.head == this->buffer.length)
+      --this->buffer.count;
+      if (++this->buffer.head == this->buffer.size)
         this->buffer.head = 0;
 
-      return item;
+      return this->buffer.queue[index];
     }
 
     /**
-     * @brief Adds an item to the queue
-     * @details Adds a item to the queue on the location pointed by the buffer_t
-     * tail vairable, will return false if there is no queue space available.
-     *
-     * @param item Item to be added to the queue
-     * @return true if the operation was successfull
+     * @brief   Adds an item to the queue
+     * @details Adds an item to the queue on the location pointed by the buffer_t
+     *          tail variable. Returns false if no queue space is available.
+     * @param   item Item to be added to the queue
+     * @return  true if the operation was successful
      */
     bool enqueue(T const &item) {
       if (this->isFull()) return false;
 
-      this->buffer.queue[this->buffer.tail++] = item;
-      ++this->buffer.size;
+      this->buffer.queue[this->buffer.tail] = item;
 
-      if (this->buffer.tail == this->buffer.length)
+      ++this->buffer.count;
+      if (++this->buffer.tail == this->buffer.size)
         this->buffer.tail = 0;
 
       return true;
     }
 
     /**
-     * @brief Checks if the queue has no items
+     * @brief   Checks if the queue has no items
      * @details Returns true if there are no items on the queue, false otherwise.
-     * @return true if queue is empty
+     * @return  true if queue is empty
      */
     bool isEmpty() {
-      return this->buffer.size == 0;
+      return this->buffer.count == 0;
     }
 
     /**
-     * @brief Checks if the queue is full
+     * @brief   Checks if the queue is full
      * @details Returns true if the queue is full, false otherwise.
-     * @return true if queue is full
+     * @return  true if queue is full
      */
     bool isFull() {
-      return this->buffer.size == this->buffer.length;
+      return this->buffer.count == this->buffer.size;
     }
 
     /**
-     * @brief Gets the queue size
+     * @brief   Gets the queue size
      * @details Returns the maximum number of items a queue can have.
-     * @return the queue lenght
+     * @return  the queue size
      */
-    uint8_t length() {
-      return this->buffer.length;
+    uint8_t size() {
+      return this->buffer.size;
     }
 
     /**
-     * @brief Gets the next item from the queue without removing it
-     * @details Returns the next item on the queue but the item is not removed
-     * from the queue nor the pointers updated.
-     * @return the queue size
+     * @brief   Gets the next item from the queue without removing it
+     * @details Returns the next item in the queue without removing it
+     *          or updating the pointers.
+     * @return  first item in the queue
      */
-    uint8_t peek() {
+    T peek() {
       return this->buffer.queue[this->buffer.head];
     }
 
     /**
      * @brief Gets the number of items on the queue
      * @details Returns the current number of items stored on the queue.
-     * @return type T item
+     * @return number of items in the queue
      */
-    uint8_t size() {
-      return this->buffer.size;
+    uint8_t count() {
+      return this->buffer.count;
     }
 };
 
diff --git a/Marlin/macros.h b/Marlin/macros.h
index c228ac3..5eec73e 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -23,6 +23,8 @@
 #ifndef MACROS_H
 #define MACROS_H
 
+#define NUM_AXIS 4
+
 #define FORCE_INLINE __attribute__((always_inline)) inline
 
 // Bracket code that shouldn't be interrupted
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index f738d56..4e4d4a1 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -58,13 +58,14 @@
  *
  */
 
-#include "Marlin.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 #include "ultralcd.h"
 #include "language.h"
 
+#include "Marlin.h"
+
 #if ENABLED(MESH_BED_LEVELING)
   #include "mesh_bed_leveling.h"
 #endif
diff --git a/Marlin/planner.h b/Marlin/planner.h
index eac1ae5..7405536 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -32,7 +32,8 @@
 #ifndef PLANNER_H
 #define PLANNER_H
 
-#include "Marlin.h"
+#include "types.h"
+#include "MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   #include "vector_3.h"
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 3ecf93a..1dd1531 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -47,6 +47,7 @@
 #include "speed_lookuptable.h"
 #include "stepper_indirection.h"
 #include "language.h"
+#include "types.h"
 
 class Stepper;
 extern Stepper stepper;
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 9a1de04..ffb47a5 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -27,10 +27,11 @@
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
-#include "Marlin.h"
 #include "planner.h"
 #include "thermistortables.h"
 
+#include "MarlinConfig.h"
+
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 1f0f309..6eb5eff 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -190,34 +190,54 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   #endif
 
   /**
-   * START_SCREEN generates the init code for a screen function
+   * START_SCREEN_OR_MENU generates init code for a screen or menu
    *
    *   encoderLine is the position based on the encoder
    *   encoderTopLine is the top menu line to display
    *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
    *   _menuLineNr is the menu item to draw and process
    *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+   *   _countedItems is the total number of items in the menu (after one call)
    */
-  #define _START_SCREEN(CODE, SKIP) \
+  #define START_SCREEN_OR_MENU(LIMIT) \
     ENCODER_DIRECTION_MENUS(); \
     encoderRateMultiplierEnabled = false; \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
+    static int8_t _countedItems = 0; \
     int8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
-    NOMORE(encoderTopLine, encoderLine); \
+    if (_countedItems > 0 && encoderLine >= _countedItems - LIMIT) { \
+      encoderLine = _countedItems - LIMIT; \
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    }
+
+  #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
-    bool _skipStatic = SKIP; \
-    CODE; \
     for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT; _lcdLineNr++, _menuLineNr++) { \
-      _thisItemNr = 0;
-
-  #define START_SCREEN() _START_SCREEN(NOOP, false)
+      _thisItemNr = 0
 
   /**
-   * START_MENU generates the init code for a menu function
+   * START_SCREEN  Opening code for a screen having only static items.
+   *               Do simplified scrolling of the entire screen.
    *
-   *   wasClicked indicates the controller was clicked
+   * START_MENU    Opening code for a screen with menu items.
+   *               Scroll as-needed to keep the selected line in view.
+   *               'wasClicked' indicates the controller was clicked.
    */
-  #define START_MENU() _START_SCREEN(bool wasClicked = LCD_CLICKED, true)
+  #define START_SCREEN() \
+    START_SCREEN_OR_MENU(LCD_HEIGHT); \
+    encoderTopLine = encoderLine; \
+    bool _skipStatic = false; \
+    SCREEN_OR_MENU_LOOP()
+
+  #define START_MENU() \
+    START_SCREEN_OR_MENU(1); \
+    NOMORE(encoderTopLine, encoderLine); \
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
+      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
+    } \
+    bool wasClicked = LCD_CLICKED; \
+    bool _skipStatic = true; \
+    SCREEN_OR_MENU_LOOP()
 
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
@@ -252,7 +272,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
         return; \
       } \
     } \
-    _thisItemNr++
+    ++_thisItemNr
 
   #define MENU_ITEM(TYPE, LABEL, ARGS...) do { \
       _skipStatic = false; \
@@ -270,42 +290,15 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## ARGS); \
     } \
-    _thisItemNr++
-
-  /**
-   *
-   * END_SCREEN  Closing code for a screen having only static items.
-   *             Do simplified scrolling of the entire screen.
-   *
-   * END_MENU    Closing code for a screen with menu items.
-   *             Scroll as-needed to keep the selected line in view.
-   *
-   * At this point _thisItemNr equals the total number of items.
-   *
-   */
+    ++_thisItemNr
 
-  // Simple-scroll by using encoderLine as encoderTopLine
   #define END_SCREEN() \
     } \
-    NOMORE(encoderLine, _thisItemNr - LCD_HEIGHT); \
-    NOLESS(encoderLine, 0); \
-    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    if (encoderTopLine != encoderLine) { \
-      encoderTopLine = encoderLine; \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    }
+    _countedItems = _thisItemNr
 
-  // Scroll through menu items, scrolling as-needed to stay in view
   #define END_MENU() \
     } \
-    if (encoderLine >= _thisItemNr) { \
-      encoderLine = _thisItemNr - 1; \
-      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    } \
-    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
-      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    } \
+    _countedItems = _thisItemNr; \
     UNUSED(_skipStatic)
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)

