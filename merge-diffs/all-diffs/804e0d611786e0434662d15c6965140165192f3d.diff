commit 804e0d611786e0434662d15c6965140165192f3d (from bb499421e901504e88c40af6cecfd582e2a15e16)
Merge: bb49942 602c8ee
Author: ErikZalm <erik@vdzalm.eu>
Date:   Wed May 16 12:21:48 2012 -0700

    Merge pull request #164 from guanix/Marlin_v1
    
    Melzi support

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index f158767..6c5b974 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -26,6 +26,7 @@
 // Gen6 = 5
 // Gen6 deluxe = 51
 // Sanguinololu 1.2 and above = 62
+// Melzi = 63
 // Ultimaker = 7
 // Teensylu = 8
 // Gen3+ =9
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 0d6b602..95a0369 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -554,7 +554,10 @@
 * Sanguinololu pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 62
+#if MOTHERBOARD == 63
+#define MELZI
+#endif
+#if MOTHERBOARD == 62 || MOTHERBOARD == 63
 #undef MOTHERBOARD
 #define MOTHERBOARD 6
 #define SANGUINOLOLU_V_1_2 
@@ -589,6 +592,11 @@
 
 #define FAN_PIN            -1 
 
+#ifdef MELZI
+#define LED_PIN            28
+#define FAN_PIN            4
+#endif
+
 #define PS_ON_PIN          -1
 #define KILL_PIN           -1
 
@@ -621,6 +629,10 @@
 #define SDPOWER            -1
 #define SDSS               31
 
+#ifdef MELZI
+#define SDSS               24
+#endif
+
 #endif
 
 

commit 804e0d611786e0434662d15c6965140165192f3d (from 602c8ee02bcd6993cb60e8758aa5928253b577dd)
Merge: bb49942 602c8ee
Author: ErikZalm <erik@vdzalm.eu>
Date:   Wed May 16 12:21:48 2012 -0700

    Merge pull request #164 from guanix/Marlin_v1
    
    Melzi support

diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index cfb503d..2763310 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -555,7 +555,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
   if ( block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0 ) {
-    block->millimeters = abs(delta_mm[E_AXIS]);
+    block->millimeters = fabs(delta_mm[E_AXIS]);
   } else {
     block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));
   }
@@ -591,8 +591,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   float speed_factor = 1.0; //factor <=1 do decrease speed
   for(int i=0; i < 4; i++) {
     current_speed[i] = delta_mm[i] * inverse_second;
-    if(abs(current_speed[i]) > max_feedrate[i])
-      speed_factor = min(speed_factor, max_feedrate[i] / abs(current_speed[i]));
+    if(fabs(current_speed[i]) > max_feedrate[i])
+      speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));
   }
 
 // Max segement time in us.
@@ -696,25 +696,25 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 #endif
   // Start with a safe speed
   float vmax_junction = max_xy_jerk/2;  
-  if(abs(current_speed[Z_AXIS]) > max_z_jerk/2) 
+  if(fabs(current_speed[Z_AXIS]) > max_z_jerk/2) 
     vmax_junction = max_z_jerk/2;
   vmax_junction = min(vmax_junction, block->nominal_speed);
-  if(abs(current_speed[E_AXIS]) > max_e_jerk/2) 
+  if(fabs(current_speed[E_AXIS]) > max_e_jerk/2) 
     vmax_junction = min(vmax_junction, max_e_jerk/2);
     
   if ((moves_queued > 1) && (previous_nominal_speed > 0.0001)) {
     float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));
-    if((abs(previous_speed[X_AXIS]) > 0.0001) || (abs(previous_speed[Y_AXIS]) > 0.0001)) {
+    if((fabs(previous_speed[X_AXIS]) > 0.0001) || (fabs(previous_speed[Y_AXIS]) > 0.0001)) {
       vmax_junction = block->nominal_speed;
     }
     if (jerk > max_xy_jerk) {
       vmax_junction *= (max_xy_jerk/jerk);
     } 
-    if(abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
-      vmax_junction *= (max_z_jerk/abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
+    if(fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
+      vmax_junction *= (max_z_jerk/fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
     } 
-    if(abs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
-      vmax_junction *= (max_e_jerk/abs(current_speed[E_AXIS] - previous_speed[E_AXIS]));
+    if(fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
+      vmax_junction *= (max_e_jerk/fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]));
     } 
   }
   block->max_entry_speed = vmax_junction;

