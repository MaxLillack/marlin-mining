commit 79374f0b938402fa64cdb747478f052ff72277d9 (from 1520de00935c2ee3e535c0e286fa73d6786677dd)
Merge: 1520de0 5090c56
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Wed Jun 5 17:44:48 2013 +0200

    Merge branch 'reisnyderb' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index d23fd6a..0c8dd55 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -90,10 +90,14 @@
 // 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan) (1k pullup)
 
 #define TEMP_SENSOR_0 -1
-#define TEMP_SENSOR_1 0
+#define TEMP_SENSOR_1 -1
 #define TEMP_SENSOR_2 0
 #define TEMP_SENSOR_BED 0
 
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT 
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
 // Actual temperature must be close to target for this long before M109 returns success
 #define TEMP_RESIDENCY_TIME 10  // (seconds)
 #define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index afdd684..fea219f 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -318,6 +318,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 //===========================================================================
 //=============================  Define Defines  ============================
 //===========================================================================
+#if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
+  #error "You cannot use  TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+#endif
 
 #if TEMP_SENSOR_0 > 0
   #define THERMISTORHEATER_0 TEMP_SENSOR_0
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 2e30142..39a838d 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1055,7 +1055,7 @@ void process_commands()
     case 105 : // M105
       if(setTargetedHotend(105)){
         break;
-      }
+        }
       #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
         SERIAL_PROTOCOLPGM("ok T:");
         SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);
@@ -2281,4 +2281,4 @@ bool setTargetedHotend(int code){
     }
   }
   return false;
-}
+}
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 431b2e2..b632f62 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -313,189 +313,200 @@
 
 #if MOTHERBOARD == 33 || MOTHERBOARD == 34
 
-#define LARGE_FLASH        true
+  #define LARGE_FLASH        true
+
+  #define X_STEP_PIN         54
+  #define X_DIR_PIN          55
+  #define X_ENABLE_PIN       38
+  #define X_MIN_PIN           3
+  #define X_MAX_PIN           2
+
+  #define Y_STEP_PIN         60
+  #define Y_DIR_PIN          61
+  #define Y_ENABLE_PIN       56
+  #define Y_MIN_PIN          14
+  #define Y_MAX_PIN          15
+
+  #define Z_STEP_PIN         46
+  #define Z_DIR_PIN          48
+  #define Z_ENABLE_PIN       62
+  #define Z_MIN_PIN          18
+  #define Z_MAX_PIN          19
+
+  #define Z2_STEP_PIN        36
+  #define Z2_DIR_PIN         34
+  #define Z2_ENABLE_PIN      30
+
+  #define E0_STEP_PIN        26
+  #define E0_DIR_PIN         28
+  #define E0_ENABLE_PIN      24
+
+  #define E1_STEP_PIN        36
+  #define E1_DIR_PIN         34
+  #define E1_ENABLE_PIN      30
+
+  #define SDPOWER            -1
+  #define SDSS               53
+  #define LED_PIN            13
+
+  #if MOTHERBOARD == 33
+    #define FAN_PIN            9 // (Sprinter config)
+  #else
+    #define FAN_PIN            4 // IO pin. Buffer needed
+  #endif
 
-#define X_STEP_PIN         54
-#define X_DIR_PIN          55
-#define X_ENABLE_PIN       38
-#define X_MIN_PIN           3
-#define X_MAX_PIN           2
+  #define PS_ON_PIN          12
 
-#define Y_STEP_PIN         60
-#define Y_DIR_PIN          61
-#define Y_ENABLE_PIN       56
-#define Y_MIN_PIN          14
-#define Y_MAX_PIN          15
+  #if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
+    #define KILL_PIN           41
+  #else
+    #define KILL_PIN           -1
+  #endif
 
-#define Z_STEP_PIN         46
-#define Z_DIR_PIN          48
-#define Z_ENABLE_PIN       62
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          19
+  #define HEATER_0_PIN       10   // EXTRUDER 1
 
-#define Z2_STEP_PIN        36
-#define Z2_DIR_PIN         34
-#define Z2_ENABLE_PIN      30
+  #if MOTHERBOARD == 33
+    #define HEATER_1_PIN       -1
+  #else
+    #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
+  #endif
 
-#define E0_STEP_PIN        26
-#define E0_DIR_PIN         28
-#define E0_ENABLE_PIN      24
+  #define HEATER_2_PIN       -1
+  #define TEMP_0_PIN         13   // ANALOG NUMBERING
+  #define TEMP_1_PIN         15   // ANALOG NUMBERING
+  #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+  #define HEATER_BED_PIN     8    // BED
+  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
-#define E1_STEP_PIN        36
-#define E1_DIR_PIN         34
-#define E1_ENABLE_PIN      30
 
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
 
-#if MOTHERBOARD == 33
-#define FAN_PIN            9 // (Sprinter config)
-#else
-#define FAN_PIN            4 // IO pin. Buffer needed
-#endif
-#define PS_ON_PIN          12
+  #ifdef NUM_SERVOS
+    #define SERVO0_PIN         11
 
-#if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
-#define KILL_PIN           41
-#else
-#define KILL_PIN           -1
-#endif
+    #if NUM_SERVOS > 1
+      #define SERVO1_PIN         6
+    #endif
 
-#define HEATER_0_PIN       10   // EXTRUDER 1
-#if MOTHERBOARD == 33
-#define HEATER_1_PIN       -1
-#else
-#define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
-#endif
-#define HEATER_2_PIN       -1
-#define TEMP_0_PIN         13   // ANALOG NUMBERING
-#define TEMP_1_PIN         15   // ANALOG NUMBERING
-#define TEMP_2_PIN         -1   // ANALOG NUMBERING
-#define HEATER_BED_PIN     8    // BED
-#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+    #if NUM_SERVOS > 2
+      #define SERVO2_PIN         5
+    #endif
 
-#ifdef NUM_SERVOS
-  #define SERVO0_PIN         11
-  #if NUM_SERVOS > 1
-  #define SERVO1_PIN         6
-  #endif
-  #if NUM_SERVOS > 2
-  #define SERVO2_PIN         5
-  #endif
-  #if NUM_SERVOS > 2
-  #define SERVO3_PIN         4
+    #if NUM_SERVOS > 2
+      #define SERVO3_PIN         4
+    #endif
   #endif
-#endif
 
-#ifdef ULTRA_LCD
+  #ifdef ULTRA_LCD
 
-  #ifdef NEWPANEL
-    #define LCD_PINS_RS 16 
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25
-    #define LCD_PINS_D6 27
-    #define LCD_PINS_D7 29
-
-    #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
-      #define BEEPER 37
+    #ifdef NEWPANEL
+      #define LCD_PINS_RS 16 
+      #define LCD_PINS_ENABLE 17
+      #define LCD_PINS_D4 23
+      #define LCD_PINS_D5 25
+      #define LCD_PINS_D6 27
+      #define LCD_PINS_D7 29
 
-      #define BTN_EN1 31
-      #define BTN_EN2 33
-      #define BTN_ENC 35
+      #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+        #define BEEPER 37
 
-      #define SDCARDDETECT 49
-    #else
-      //arduino pin which triggers an piezzo beeper
-      #define BEEPER 33  // Beeper on AUX-4
-
-      //buttons are directly attached using AUX-2
-      #ifdef REPRAPWORLD_KEYPAD
-        #define BTN_EN1 64 // encoder
-        #define BTN_EN2 59 // encoder
-        #define BTN_ENC 63 // enter button
-        #define SHIFT_OUT 40 // shift register
-        #define SHIFT_CLK 44 // shift register
-        #define SHIFT_LD 42 // shift register
-      #else
-        #define BTN_EN1 37
-        #define BTN_EN2 35
-        #define BTN_ENC 31  //the click
-      #endif
+        #define BTN_EN1 31
+        #define BTN_EN2 33
+        #define BTN_ENC 35
 
-      #ifdef G3D_PANEL
         #define SDCARDDETECT 49
       #else
-        #define SDCARDDETECT -1  // Ramps does not use this port
+        //arduino pin which triggers an piezzo beeper
+        #define BEEPER 33  // Beeper on AUX-4
+
+        //buttons are directly attached using AUX-2
+        #ifdef REPRAPWORLD_KEYPAD
+          #define BTN_EN1 64 // encoder
+          #define BTN_EN2 59 // encoder
+          #define BTN_ENC 63 // enter button
+          #define SHIFT_OUT 40 // shift register
+          #define SHIFT_CLK 44 // shift register
+          #define SHIFT_LD 42 // shift register
+        #else
+          #define BTN_EN1 37
+          #define BTN_EN2 35
+          #define BTN_ENC 31  //the click
+        #endif
+
+        #ifdef G3D_PANEL
+          #define SDCARDDETECT 49
+        #else
+          #define SDCARDDETECT -1  // Ramps does not use this port
+        #endif
+    
       #endif
-    #endif
 
-  #else //old style panel with shift register
-    //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 33   // No Beeper added 
-
-    //buttons are attached to a shift register
-  // Not wired this yet
-    //#define SHIFT_CLK 38
-    //#define SHIFT_LD 42
-    //#define SHIFT_OUT 40
-    //#define SHIFT_EN 17
-
-    #define LCD_PINS_RS 16
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25
-    #define LCD_PINS_D6 27
-    #define LCD_PINS_D7 29
-  #endif 
-#endif //ULTRA_LCD
+    #else //old style panel with shift register
+      //arduino pin witch triggers an piezzo beeper
+      #define BEEPER 33   // No Beeper added 
+
+      //buttons are attached to a shift register
+      // Not wired this yet
+      //#define SHIFT_CLK 38
+      //#define SHIFT_LD 42
+      //#define SHIFT_OUT 40
+      //#define SHIFT_EN 17
+
+      #define LCD_PINS_RS 16
+      #define LCD_PINS_ENABLE 17
+      #define LCD_PINS_D4 23
+      #define LCD_PINS_D5 25
+      #define LCD_PINS_D6 27
+      #define LCD_PINS_D7 29
+    #endif 
+  #endif //ULTRA_LCD
 
 #else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
 
-#define X_STEP_PIN         26
-#define X_DIR_PIN          28
-#define X_ENABLE_PIN       24
-#define X_MIN_PIN           3
-#define X_MAX_PIN          -1    //2
-
-#define Y_STEP_PIN         38
-#define Y_DIR_PIN          40
-#define Y_ENABLE_PIN       36
-#define Y_MIN_PIN          16
-#define Y_MAX_PIN          -1    //17
-
-#define Z_STEP_PIN         44
-#define Z_DIR_PIN          46
-#define Z_ENABLE_PIN       42
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          -1    //19
+  #define X_STEP_PIN         26
+  #define X_DIR_PIN          28
+  #define X_ENABLE_PIN       24
+  #define X_MIN_PIN           3
+  #define X_MAX_PIN          -1    //2
+
+  #define Y_STEP_PIN         38
+  #define Y_DIR_PIN          40
+  #define Y_ENABLE_PIN       36
+  #define Y_MIN_PIN          16
+  #define Y_MAX_PIN          -1    //17
+
+  #define Z_STEP_PIN         44
+  #define Z_DIR_PIN          46
+  #define Z_ENABLE_PIN       42
+  #define Z_MIN_PIN          18
+  #define Z_MAX_PIN          -1    //19
+
+  #define E0_STEP_PIN         32
+  #define E0_DIR_PIN          34
+  #define E0_ENABLE_PIN       30
+
+  #define SDPOWER            48
+  #define SDSS               53
+  #define LED_PIN            13
+  #define PS_ON_PIN          -1
+  #define KILL_PIN           -1
+
+  #ifdef RAMPS_V_1_0 // RAMPS_V_1_0
+    #define HEATER_0_PIN     12    // RAMPS 1.0
+    #define HEATER_BED_PIN   -1    // RAMPS 1.0
+    #define FAN_PIN          11    // RAMPS 1.0
+  #else // RAMPS_V_1_1 or RAMPS_V_1_2
+    #define HEATER_0_PIN     10    // RAMPS 1.1
+    #define HEATER_BED_PIN    8    // RAMPS 1.1
+    #define FAN_PIN           9    // RAMPS 1.1
+  #endif
 
-#define E0_STEP_PIN         32
-#define E0_DIR_PIN          34
-#define E0_ENABLE_PIN       30
+  #define HEATER_1_PIN        -1
+  #define HEATER_2_PIN        -1
+  #define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+  #define TEMP_1_PIN          -1
+  #define TEMP_2_PIN          -1
+  #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
 
-#define SDPOWER            48
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
-  #define HEATER_0_PIN     12    // RAMPS 1.0
-  #define HEATER_BED_PIN   -1    // RAMPS 1.0
-  #define FAN_PIN          11    // RAMPS 1.0
-#else // RAMPS_V_1_1 or RAMPS_V_1_2
-  #define HEATER_0_PIN     10    // RAMPS 1.1
-  #define HEATER_BED_PIN    8    // RAMPS 1.1
-  #define FAN_PIN           9    // RAMPS 1.1
-#endif
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          -1
-#define TEMP_2_PIN          -1
-#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
 #endif// MOTHERBOARD == 33 || MOTHERBOARD == 34
 
 // SPI for Max6675 Thermocouple
@@ -1835,4 +1846,4 @@
                         HEATER_BED_PIN, FAN_PIN,                  \
                         _E0_PINS _E1_PINS _E2_PINS             \
                         analogInputToDigitalPin(TEMP_0_PIN), analogInputToDigitalPin(TEMP_1_PIN), analogInputToDigitalPin(TEMP_2_PIN), analogInputToDigitalPin(TEMP_BED_PIN) }
-#endif
+#endif
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 7b23780..b7c39f8 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -40,10 +40,13 @@
 int target_temperature[EXTRUDERS] = { 0 };
 int target_temperature_bed = 0;
 int current_temperature_raw[EXTRUDERS] = { 0 };
-float current_temperature[EXTRUDERS] = { 0 };
+float current_temperature[EXTRUDERS] = { 0.0 };
 int current_temperature_bed_raw = 0;
-float current_temperature_bed = 0;
-
+float current_temperature_bed = 0.0;
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  int redundant_temperature_raw = 0;
+  float redundant_temperature = 0.0;
+#endif
 #ifdef PIDTEMP
   float Kp=DEFAULT_Kp;
   float Ki=(DEFAULT_Ki*PID_dT);
@@ -104,15 +107,15 @@ static volatile bool temp_meas_ready = false;
     (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
   static unsigned long extruder_autofan_last_check;
 #endif  
-  
+
 #if EXTRUDERS > 3
-# error Unsupported number of extruders
+  # error Unsupported number of extruders
 #elif EXTRUDERS > 2
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
 #elif EXTRUDERS > 1
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
 #else
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
 #endif
 
 // Init min and max temp with extreme values to prevent false errors during startup
@@ -124,8 +127,14 @@ static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
 #ifdef BED_MAXTEMP
 static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
 #endif
-static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
-static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };
+  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+#else
+  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
+  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+#endif
 
 static float analog2temp(int raw, uint8_t e);
 static float analog2tempBed(int raw);
@@ -157,28 +166,28 @@ void PID_autotune(float temp, int extruder, int ncycles)
   float Kp, Ki, Kd;
   float max = 0, min = 10000;
 
-	if ((extruder > EXTRUDERS)
+  if ((extruder > EXTRUDERS)
   #if (TEMP_BED_PIN <= -1)
-		||(extruder < 0)
-	#endif
-	){
-  	SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
-  	return;
-	}
+       ||(extruder < 0)
+  #endif
+       ){
+          SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
+          return;
+        }
 	
   SERIAL_ECHOLN("PID Autotune start");
   
   disable_heater(); // switch off all heaters.
 
-	if (extruder<0)
-	{
-	 	soft_pwm_bed = (MAX_BED_POWER)/2;
-		bias = d = (MAX_BED_POWER)/2;
-  }
-	else
-	{
-	  soft_pwm[extruder] = (PID_MAX)/2;
-		bias = d = (PID_MAX)/2;
+  if (extruder<0)
+  {
+     soft_pwm_bed = (MAX_BED_POWER)/2;
+     bias = d = (MAX_BED_POWER)/2;
+   }
+   else
+   {
+     soft_pwm[extruder] = (PID_MAX)/2;
+     bias = d = (PID_MAX)/2;
   }
 
 
@@ -196,10 +205,10 @@ void PID_autotune(float temp, int extruder, int ncycles)
       if(heating == true && input > temp) {
         if(millis() - t2 > 5000) { 
           heating=false;
-					if (extruder<0)
-						soft_pwm_bed = (bias - d) >> 1;
-					else
-						soft_pwm[extruder] = (bias - d) >> 1;
+          if (extruder<0)
+            soft_pwm_bed = (bias - d) >> 1;
+          else
+            soft_pwm[extruder] = (bias - d) >> 1;
           t1=millis();
           t_high=t1 - t2;
           max=temp;
@@ -250,10 +259,10 @@ void PID_autotune(float temp, int extruder, int ncycles)
               */
             }
           }
-					if (extruder<0)
-						soft_pwm_bed = (bias + d) >> 1;
-					else
-						soft_pwm[extruder] = (bias + d) >> 1;
+          if (extruder<0)
+            soft_pwm_bed = (bias + d) >> 1;
+          else
+            soft_pwm[extruder] = (bias + d) >> 1;
           cycles++;
           min=temp;
         }
@@ -264,14 +273,14 @@ void PID_autotune(float temp, int extruder, int ncycles)
       return;
     }
     if(millis() - temp_millis > 2000) {
-			int p;
-			if (extruder<0){
-	      p=soft_pwm_bed;       
-	      SERIAL_PROTOCOLPGM("ok B:");
-			}else{
-	      p=soft_pwm[extruder];       
-	      SERIAL_PROTOCOLPGM("ok T:");
-			}
+      int p;
+      if (extruder<0){
+        p=soft_pwm_bed;       
+        SERIAL_PROTOCOLPGM("ok B:");
+      }else{
+        p=soft_pwm[extruder];       
+        SERIAL_PROTOCOLPGM("ok T:");
+      }
 			
       SERIAL_PROTOCOL(input);   
       SERIAL_PROTOCOLPGM(" @:");
@@ -471,7 +480,19 @@ void manage_heater()
         }
     }
     #endif
-
+    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      if(fabs(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF) {
+        disable_heater();
+        if(IsStopped() == false) {
+          SERIAL_ERROR_START;
+          SERIAL_ERRORLNPGM("Extruder switched off. Temperature difference between temp sensors is too high !");
+          LCD_ALERTMESSAGEPGM("Err: REDUNDANT TEMP ERROR");
+        }
+        #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+          Stop();
+        #endif
+      }
+    #endif
   } // End extruder for loop
 
   #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
@@ -565,7 +586,11 @@ void manage_heater()
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 static float analog2temp(int raw, uint8_t e) {
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  if(e > EXTRUDERS)
+#else
   if(e >= EXTRUDERS)
+#endif
   {
       SERIAL_ERROR_START;
       SERIAL_ERROR((int)e);
@@ -644,7 +669,9 @@ static void updateTemperaturesFromRawValues()
         current_temperature[e] = analog2temp(current_temperature_raw[e], e);
     }
     current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
-
+    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      redundant_temperature = analog2temp(redundant_temperature_raw, 1);
+    #endif
     //Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
 
@@ -1145,6 +1172,9 @@ ISR(TIMER0_COMPB_vect)
 #if EXTRUDERS > 1
       current_temperature_raw[1] = raw_temp_1_value;
 #endif
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      redundant_temperature_raw = raw_temp_1_value;
+#endif
 #if EXTRUDERS > 2
       current_temperature_raw[2] = raw_temp_2_value;
 #endif
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 7cc62aa..75ffcd0 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -37,6 +37,9 @@ extern int target_temperature[EXTRUDERS];
 extern float current_temperature[EXTRUDERS];
 extern int target_temperature_bed;
 extern float current_temperature_bed;
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  extern float redundant_temperature;
+#endif
 
 #ifdef PIDTEMP
   extern float Kp,Ki,Kd,Kc;

commit 79374f0b938402fa64cdb747478f052ff72277d9 (from 5090c56651bf18ea45a7453f5fccfe6a09d13062)
Merge: 1520de0 5090c56
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Wed Jun 5 17:44:48 2013 +0200

    Merge branch 'reisnyderb' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 319a079..0c8dd55 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -43,6 +43,8 @@
 // 82 = Brainwave (AT90USB646)
 // 9  = Gen3+
 // 70 = Megatronics
+// 701= Megatronics v2.0
+// 702= Minitronics v1.0
 // 90 = Alpha OMCA board
 // 91 = Final OMCA board
 // 301 = Rambo
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 3a38d2e..39a838d 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -128,7 +128,7 @@
 // M280 - set servo position absolute. P: servo index, S: angle or microseconds
 // M300 - Play beepsound S<frequency Hz> P<duration ms>
 // M301 - Set PID parameters P I and D
-// M302 - Allow cold extrudes
+// M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
 // M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
 // M304 - Set bed PID parameters P I and D
 // M400 - Finish all moves
@@ -1625,12 +1625,15 @@ void process_commands()
       #endif
      }
     break;
-
-    case 302: // allow cold extrudes
+    #ifdef PREVENT_DANGEROUS_EXTRUDE
+    case 302: // allow cold extrudes, or set the minimum extrude temperature
     {
-      allow_cold_extrudes(true);
+	  float temp = .0;
+	  if (code_seen('S')) temp=code_value();
+      set_extrude_min_temp(temp);
     }
     break;
+	#endif
     case 303: // M303 PID autotune
     {
       float temp = 150.0;
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 6558556..17a56ad 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -33,11 +33,11 @@
 #define LCD_CLICKED (buttons&EN_C)
 #endif
 
-// CHANGE_DE begin ***
-#include <U8glib.h>	// DE_U8glib
+#include <U8glib.h>
 #include "DOGMbitmaps.h"
 #include "dogm_font_data_marlin.h"
 #include "ultralcd.h"
+#include "ultralcd_st7920_u8glib_rrd.h"
 
 
 /* Russian language not supported yet, needs custom font
@@ -74,11 +74,10 @@
 
 #define FONT_STATUSMENU	u8g_font_6x9
 
-
 // LCD selection
 #ifdef U8GLIB_ST7920
-// SPI Com: SCK = en = (D4), MOSI = rw = (RS), CS = di = (ENABLE)
-U8GLIB_ST7920_128X64_1X u8g(LCD_PINS_D4, LCD_PINS_ENABLE, LCD_PINS_RS);
+//U8GLIB_ST7920_128X64_RRD u8g(0,0,0);
+U8GLIB_ST7920_128X64_RRD u8g(0);
 #else
 U8GLIB_DOGM128 u8g(DOGLCD_CS, DOGLCD_A0);	// HW-SPI Com: CS, A0
 #endif
@@ -101,11 +100,11 @@ static void lcd_implementation_init()
 	u8g.setRot90();	// Rotate screen by 90°
 #endif
 
-#ifdef LCD_SCREEN_ROT_180;
+#ifdef LCD_SCREEN_ROT_180
 	u8g.setRot180();	// Rotate screen by 180°
 #endif
 
-#ifdef LCD_SCREEN_ROT_270;
+#ifdef LCD_SCREEN_ROT_270
 	u8g.setRot270();	// Rotate screen by 270°
 #endif
 
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index ed77b50..0746bf1 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -2575,8 +2575,702 @@ pins
 #define PF7_DDR			DDRF
 #endif
 
+
+#if defined (__AVR_ATmega1281__) || defined (__AVR_ATmega2561__)
+// UART
+#define	RXD					DIO0
+#define	TXD					DIO1
+
+// SPI
+#define	SCK					DIO10
+#define	MISO				DIO12
+#define	MOSI				DIO11
+#define	SS					DIO16
+
+// TWI (I2C)
+#define	SCL					DIO17
+#define	SDA					DIO18
+
+// timers and PWM
+#define	OC0A				DIO9
+#define	OC0B				DIO4
+#define	OC1A				DIO7
+#define	OC1B				DIO8
+#define	OC2A				DIO6
+#define	OC3A				DIO5
+#define	OC3B				DIO2
+#define	OC3C				DIO3
+
+
+// change for your board
+#define	DEBUG_LED		DIO46
+
+/*
+pins
+*/
+#define	DIO0_PIN		PINE0
+#define	DIO0_RPORT	PINE
+#define	DIO0_WPORT	PORTE
+#define	DIO0_DDR		DDRE
+#define DIO0_PWM		NULL
+
+#define	DIO1_PIN		PINE1
+#define	DIO1_RPORT	PINE
+#define	DIO1_WPORT	PORTE
+#define	DIO1_DDR		DDRE
+#define DIO1_PWM		NULL
+
+#define	DIO2_PIN		PINE4
+#define	DIO2_RPORT	PINE
+#define	DIO2_WPORT	PORTE
+#define	DIO2_DDR		DDRE
+#define DIO2_PWM		&OCR3BL
+
+#define	DIO3_PIN		PINE5
+#define	DIO3_RPORT	PINE
+#define	DIO3_WPORT	PORTE
+#define	DIO3_DDR		DDRE
+#define DIO3_PWM		&OCR3CL
+
+#define	DIO4_PIN		PING5
+#define	DIO4_RPORT	PING
+#define	DIO4_WPORT	PORTG
+#define	DIO4_DDR		DDRG
+#define DIO4_PWM		&OCR0B
+
+#define	DIO5_PIN		PINE3
+#define	DIO5_RPORT	PINE
+#define	DIO5_WPORT	PORTE
+#define	DIO5_DDR		DDRE
+#define DIO5_PWM		&OCR3AL
+
+#define	DIO6_PIN		PINB4
+#define	DIO6_RPORT	PINB
+#define	DIO6_WPORT	PORTB
+#define	DIO6_DDR		DDRB
+#define DIO6_PWM		&OCR2AL
+
+#define	DIO7_PIN		PINB5
+#define	DIO7_RPORT	PINB
+#define	DIO7_WPORT	PORTB
+#define	DIO7_DDR		DDRB
+#define DIO7_PWM		&OCR1AL
+
+#define	DIO8_PIN		PINB6
+#define	DIO8_RPORT	PINB
+#define	DIO8_WPORT	PORTB
+#define	DIO8_DDR		DDRB
+#define DIO8_PWM		&OCR1BL
+
+#define	DIO9_PIN		PINB7
+#define	DIO9_RPORT	PINB
+#define	DIO9_WPORT	PORTB
+#define	DIO9_DDR		DDRB
+#define DIO9_PWM		&OCR0AL
+
+#define	DIO10_PIN		PINB1
+#define	DIO10_RPORT	PINB
+#define	DIO10_WPORT	PORTB
+#define	DIO10_DDR		DDRB
+#define DIO10_PWM		NULL
+
+#define	DIO11_PIN		PINB2
+#define	DIO11_RPORT	PINB
+#define	DIO11_WPORT	PORTB
+#define	DIO11_DDR		DDRB
+#define DIO11_PWM		NULL
+
+#define	DIO12_PIN		PINB3
+#define	DIO12_RPORT	PINB
+#define	DIO12_WPORT	PORTB
+#define	DIO12_DDR		DDRB
+#define DIO12_PWM		NULL
+
+#define	DIO13_PIN		PINE2
+#define	DIO13_RPORT	PINE
+#define	DIO13_WPORT	PORTE
+#define	DIO13_DDR		DDRE
+#define DIO13_PWM		NULL
+
+#define	DIO14_PIN		PINE6
+#define	DIO14_RPORT	PINE
+#define	DIO14_WPORT	PORTE
+#define	DIO14_DDR		DDRE
+#define DIO14_PWM		NULL
+
+#define	DIO15_PIN		PINE7
+#define	DIO15_RPORT	PINE
+#define	DIO15_WPORT	PORTE
+#define	DIO15_DDR		DDRE
+#define DIO15_PWM		NULL
+
+#define	DIO16_PIN		PINB0
+#define	DIO16_RPORT	PINB
+#define	DIO16_WPORT	PORTB
+#define	DIO16_DDR		DDRB
+#define DIO16_PWM		NULL
+
+#define	DIO17_PIN		PIND0
+#define	DIO17_RPORT	PIND
+#define	DIO17_WPORT	PORTD
+#define	DIO17_DDR		DDRD
+#define DIO17_PWM		NULL
+
+#define	DIO18_PIN		PIND1
+#define	DIO18_RPORT	PIND
+#define	DIO18_WPORT	PORTD
+#define	DIO18_DDR		DDRD
+#define DIO18_PWM		NULL
+
+#define	DIO19_PIN		PIND2
+#define	DIO19_RPORT	PIND
+#define	DIO19_WPORT	PORTD
+#define	DIO19_DDR		DDRD
+#define DIO19_PWM		NULL
+
+#define	DIO20_PIN		PIND3
+#define	DIO20_RPORT	PIND
+#define	DIO20_WPORT	PORTD
+#define	DIO20_DDR		DDRD
+#define DIO20_PWM		NULL
+
+#define	DIO21_PIN		PIND4
+#define	DIO21_RPORT	PIND
+#define	DIO21_WPORT	PORTD
+#define	DIO21_DDR		DDRD
+#define DIO21_PWM		NULL
+
+#define	DIO22_PIN		PIND5
+#define	DIO22_RPORT	PIND
+#define	DIO22_WPORT	PORTD
+#define	DIO22_DDR		DDRD
+#define DIO22_PWM		NULL
+
+#define	DIO23_PIN		PIND6
+#define	DIO23_RPORT	PIND
+#define	DIO23_WPORT	PORTD
+#define	DIO23_DDR		DDRD
+#define DIO23_PWM		NULL
+
+#define	DIO24_PIN		PIND7
+#define	DIO24_RPORT	PIND
+#define	DIO24_WPORT	PORTD
+#define	DIO24_DDR		DDRD
+#define DIO24_PWM		NULL
+
+#define	DIO25_PIN		PING0
+#define	DIO25_RPORT	PING
+#define	DIO25_WPORT	PORTG
+#define	DIO25_DDR		DDRG
+#define DIO25_PWM		NULL
+
+#define	DIO26_PIN		PING1
+#define	DIO26_RPORT	PING
+#define	DIO26_WPORT	PORTG
+#define	DIO26_DDR		DDRG
+#define DIO26_PWM		NULL
+
+#define	DIO27_PIN		PING2
+#define	DIO27_RPORT	PING
+#define	DIO27_WPORT	PORTG
+#define	DIO27_DDR		DDRG
+#define DIO27_PWM		NULL
+
+#define	DIO28_PIN		PING3
+#define	DIO28_RPORT	PING
+#define	DIO28_WPORT	PORTG
+#define	DIO28_DDR		DDRG
+#define DIO28_PWM		NULL
+
+#define	DIO29_PIN		PING4
+#define	DIO29_RPORT	PING
+#define	DIO29_WPORT	PORTG
+#define	DIO29_DDR		DDRG
+#define DIO29_PWM		NULL
+
+#define	DIO30_PIN		PINC0
+#define	DIO30_RPORT	PINC
+#define	DIO30_WPORT	PORTC
+#define	DIO30_DDR		DDRC
+#define DIO30_PWM		NULL
+
+#define	DIO31_PIN		PINC1
+#define	DIO31_RPORT	PINC
+#define	DIO31_WPORT	PORTC
+#define	DIO31_DDR		DDRC
+#define DIO31_PWM		NULL
+
+#define	DIO32_PIN		PINC2
+#define	DIO32_RPORT	PINC
+#define	DIO32_WPORT	PORTC
+#define	DIO32_DDR		DDRC
+#define DIO32_PWM		NULL
+
+#define	DIO33_PIN		PINC3
+#define	DIO33_RPORT	PINC
+#define	DIO33_WPORT	PORTC
+#define	DIO33_DDR		DDRC
+#define DIO33_PWM		NULL
+
+#define	DIO34_PIN		PINC4
+#define	DIO34_RPORT	PINC
+#define	DIO34_WPORT	PORTC
+#define	DIO34_DDR		DDRC
+#define DIO34_PWM		NULL
+
+#define	DIO35_PIN		PINC5
+#define	DIO35_RPORT	PINC
+#define	DIO35_WPORT	PORTC
+#define	DIO35_DDR		DDRC
+#define DIO35_PWM		NULL
+
+#define	DIO36_PIN		PINC6
+#define	DIO36_RPORT	PINC
+#define	DIO36_WPORT	PORTC
+#define	DIO36_DDR		DDRC
+#define DIO36_PWM		NULL
+
+#define	DIO37_PIN		PINC7
+#define	DIO37_RPORT	PINC
+#define	DIO37_WPORT	PORTC
+#define	DIO37_DDR		DDRC
+#define DIO37_PWM		NULL
+
+#define	DIO38_PIN		PINA0
+#define	DIO38_RPORT	PINA
+#define	DIO38_WPORT	PORTA
+#define	DIO38_DDR		DDRA
+#define DIO38_PWM		NULL
+
+#define	DIO39_PIN		PINA1
+#define	DIO39_RPORT	PINA
+#define	DIO39_WPORT	PORTA
+#define	DIO39_DDR		DDRA
+#define DIO39_PWM		NULL
+
+#define	DIO40_PIN		PINA2
+#define	DIO40_RPORT	PINA
+#define	DIO40_WPORT	PORTA
+#define	DIO40_DDR		DDRA
+#define DIO40_PWM		NULL
+
+#define	DIO41_PIN		PINA3
+#define	DIO41_RPORT	PINA
+#define	DIO41_WPORT	PORTA
+#define	DIO41_DDR		DDRA
+#define DIO41_PWM		NULL
+
+#define	DIO42_PIN		PINA4
+#define	DIO42_RPORT	PINA
+#define	DIO42_WPORT	PORTA
+#define	DIO42_DDR		DDRA
+#define DIO42_PWM		NULL
+
+#define	DIO43_PIN		PINA5
+#define	DIO43_RPORT	PINA
+#define	DIO43_WPORT	PORTA
+#define	DIO43_DDR		DDRA
+#define DIO43_PWM		NULL
+
+#define	DIO44_PIN		PINA6
+#define	DIO44_RPORT	PINA
+#define	DIO44_WPORT	PORTA
+#define	DIO44_DDR		DDRA
+#define DIO44_PWM		NULL
+
+#define	DIO45_PIN		PINA7
+#define	DIO45_RPORT	PINA
+#define	DIO45_WPORT	PORTA
+#define	DIO45_DDR		DDRA
+#define DIO45_PWM		NULL
+
+#define	DIO46_PIN		PINF0
+#define	DIO46_RPORT	PINF
+#define	DIO46_WPORT	PORTF
+#define	DIO46_DDR		DDRF
+#define DIO46_PWM		NULL
+
+#define	DIO47_PIN		PINF1
+#define	DIO47_RPORT	PINF
+#define	DIO47_WPORT	PORTF
+#define	DIO47_DDR		DDRF
+#define DIO47_PWM		NULL
+
+#define	DIO48_PIN		PINF2
+#define	DIO48_RPORT	PINF
+#define	DIO48_WPORT	PORTF
+#define	DIO48_DDR		DDRF
+#define DIO48_PWM		NULL
+
+#define	DIO49_PIN		PINF3
+#define	DIO49_RPORT	PINF
+#define	DIO49_WPORT	PORTF
+#define	DIO49_DDR		DDRF
+#define DIO49_PWM		NULL
+
+#define	DIO50_PIN		PINF4
+#define	DIO50_RPORT	PINF
+#define	DIO50_WPORT	PORTF
+#define	DIO50_DDR		DDRF
+#define DIO50_PWM		NULL
+
+#define	DIO51_PIN		PINF5
+#define	DIO51_RPORT	PINF
+#define	DIO51_WPORT	PORTF
+#define	DIO51_DDR		DDRF
+#define DIO51_PWM		NULL
+
+#define	DIO52_PIN		PINF6
+#define	DIO52_RPORT	PINF
+#define	DIO52_WPORT	PORTF
+#define	DIO52_DDR		DDRF
+#define DIO52_PWM		NULL
+
+#define	DIO53_PIN		PINF7
+#define	DIO53_RPORT	PINF
+#define	DIO53_WPORT	PORTF
+#define	DIO53_DDR		DDRF
+#define DIO53_PWM		NULL
+
+
+
+
+#undef PA0
+#define PA0_PIN			PINA0
+#define PA0_RPORT		PINA
+#define PA0_WPORT		PORTA
+#define PA0_DDR			DDRA
+#define PA0_PWM			NULL
+#undef PA1
+#define PA1_PIN			PINA1
+#define PA1_RPORT		PINA
+#define PA1_WPORT		PORTA
+#define PA1_DDR			DDRA
+#define PA1_PWM			NULL
+#undef PA2
+#define PA2_PIN			PINA2
+#define PA2_RPORT		PINA
+#define PA2_WPORT		PORTA
+#define PA2_DDR			DDRA
+#define PA2_PWM			NULL
+#undef PA3
+#define PA3_PIN			PINA3
+#define PA3_RPORT		PINA
+#define PA3_WPORT		PORTA
+#define PA3_DDR			DDRA
+#define PA3_PWM			NULL
+#undef PA4
+#define PA4_PIN			PINA4
+#define PA4_RPORT		PINA
+#define PA4_WPORT		PORTA
+#define PA4_DDR			DDRA
+#define PA4_PWM			NULL
+#undef PA5
+#define PA5_PIN			PINA5
+#define PA5_RPORT		PINA
+#define PA5_WPORT		PORTA
+#define PA5_DDR			DDRA
+#define PA5_PWM			NULL
+#undef PA6
+#define PA6_PIN			PINA6
+#define PA6_RPORT		PINA
+#define PA6_WPORT		PORTA
+#define PA6_DDR			DDRA
+#define PA6_PWM			NULL
+#undef PA7
+#define PA7_PIN			PINA7
+#define PA7_RPORT		PINA
+#define PA7_WPORT		PORTA
+#define PA7_DDR			DDRA
+#define PA7_PWM			NULL
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_DDR			DDRB
+#define PB0_PWM			NULL
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_DDR			DDRB
+#define PB1_PWM			NULL
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_DDR			DDRB
+#define PB2_PWM			NULL
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_DDR			DDRB
+#define PB3_PWM			NULL
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_DDR			DDRB
+#define PB4_PWM			&OCR2A
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_DDR			DDRB
+#define PB5_PWM			NULL
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_DDR			DDRB
+#define PB6_PWM			NULL
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_DDR			DDRB
+#define PB7_PWM			&OCR0A
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_DDR			DDRC
+#define PC0_PWM			NULL
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_DDR			DDRC
+#define PC1_PWM			NULL
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_DDR			DDRC
+#define PC2_PWM			NULL
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_DDR			DDRC
+#define PC3_PWM			NULL
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_DDR			DDRC
+#define PC4_PWM			NULL
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_DDR			DDRC
+#define PC5_PWM			NULL
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_DDR			DDRC
+#define PC6_PWM			NULL
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_DDR			DDRC
+#define PC7_PWM			NULL
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_DDR			DDRD
+#define PD0_PWM			NULL
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_DDR			DDRD
+#define PD1_PWM			NULL
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_DDR			DDRD
+#define PD2_PWM			NULL
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_DDR			DDRD
+#define PD3_PWM			NULL
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_DDR			DDRD
+#define PD4_PWM			NULL
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_DDR			DDRD
+#define PD5_PWM			NULL
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_DDR			DDRD
+#define PD6_PWM			NULL
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_DDR			DDRD
+#define PD7_PWM			NULL
+
+#undef PE0
+#define PE0_PIN			PINE0
+#define PE0_RPORT		PINE
+#define PE0_WPORT		PORTE
+#define PE0_DDR			DDRE
+#define PE0_PWM			NULL
+#undef PE1
+#define PE1_PIN			PINE1
+#define PE1_RPORT		PINE
+#define PE1_WPORT		PORTE
+#define PE1_DDR			DDRE
+#define PE1_PWM			NULL
+#undef PE2
+#define PE2_PIN			PINE2
+#define PE2_RPORT		PINE
+#define PE2_WPORT		PORTE
+#define PE2_DDR			DDRE
+#define PE2_PWM			NULL
+#undef PE3
+#define PE3_PIN			PINE3
+#define PE3_RPORT		PINE
+#define PE3_WPORT		PORTE
+#define PE3_DDR			DDRE
+#define PE3_PWM			&OCR3AL
+#undef PE4
+#define PE4_PIN			PINE4
+#define PE4_RPORT		PINE
+#define PE4_WPORT		PORTE
+#define PE4_DDR			DDRE
+#define PE4_PWM			&OCR3BL
+#undef PE5
+#define PE5_PIN			PINE5
+#define PE5_RPORT		PINE
+#define PE5_WPORT		PORTE
+#define PE5_DDR			DDRE
+#define PE5_PWM			&OCR3CL
+#undef PE6
+#define PE6_PIN			PINE6
+#define PE6_RPORT		PINE
+#define PE6_WPORT		PORTE
+#define PE6_DDR			DDRE
+#define PE6_PWM			NULL
+#undef PE7
+#define PE7_PIN			PINE7
+#define PE7_RPORT		PINE
+#define PE7_WPORT		PORTE
+#define PE7_DDR			DDRE
+#define PE7_PWM			NULL
+
+#undef PF0
+#define PF0_PIN			PINF0
+#define PF0_RPORT		PINF
+#define PF0_WPORT		PORTF
+#define PF0_DDR			DDRF
+#define PF0_PWM			NULL
+#undef PF1
+#define PF1_PIN			PINF1
+#define PF1_RPORT		PINF
+#define PF1_WPORT		PORTF
+#define PF1_DDR			DDRF
+#define PF1_PWM			NULL
+#undef PF2
+#define PF2_PIN			PINF2
+#define PF2_RPORT		PINF
+#define PF2_WPORT		PORTF
+#define PF2_DDR			DDRF
+#define PF2_PWM			NULL
+#undef PF3
+#define PF3_PIN			PINF3
+#define PF3_RPORT		PINF
+#define PF3_WPORT		PORTF
+#define PF3_DDR			DDRF
+#define PF3_PWM			NULL
+#undef PF4
+#define PF4_PIN			PINF4
+#define PF4_RPORT		PINF
+#define PF4_WPORT		PORTF
+#define PF4_DDR			DDRF
+#define PF4_PWM			NULL
+#undef PF5
+#define PF5_PIN			PINF5
+#define PF5_RPORT		PINF
+#define PF5_WPORT		PORTF
+#define PF5_DDR			DDRF
+#define PF5_PWM			NULL
+#undef PF6
+#define PF6_PIN			PINF6
+#define PF6_RPORT		PINF
+#define PF6_WPORT		PORTF
+#define PF6_DDR			DDRF
+#define PF6_PWM			NULL
+#undef PF7
+#define PF7_PIN			PINF7
+#define PF7_RPORT		PINF
+#define PF7_WPORT		PORTF
+#define PF7_DDR			DDRF
+#define PF7_PWM			NULL
+
+#undef PG0
+#define PG0_PIN			PING0
+#define PG0_RPORT		PING
+#define PG0_WPORT		PORTG
+#define PG0_DDR			DDRG
+#define PG0_PWM			NULL
+#undef PG1
+#define PG1_PIN			PING1
+#define PG1_RPORT		PING
+#define PG1_WPORT		PORTG
+#define PG1_DDR			DDRG
+#define PG1_PWM			NULL
+#undef PG2
+#define PG2_PIN			PING2
+#define PG2_RPORT		PING
+#define PG2_WPORT		PORTG
+#define PG2_DDR			DDRG
+#define PG2_PWM			NULL
+#undef PG3
+#define PG3_PIN			PING3
+#define PG3_RPORT		PING
+#define PG3_WPORT		PORTG
+#define PG3_DDR			DDRG
+#define PG3_PWM			NULL
+#undef PG4
+#define PG4_PIN			PING4
+#define PG4_RPORT		PING
+#define PG4_WPORT		PORTG
+#define PG4_DDR			DDRG
+#define PG4_PWM			NULL
+#undef PG5
+#define PG5_PIN			PING5
+#define PG5_RPORT		PING
+#define PG5_WPORT		PORTG
+#define PG5_DDR			DDRG
+#define PG5_PWM			&OCR0B
+
+
+#endif
+
 #ifndef	DIO0_PIN
 #error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
 #endif
 
-#endif /* _FASTIO_ARDUINO_H */
+#endif /* _FASTIO_ARDUINO_H */
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 03dbc96..b632f62 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -1486,7 +1486,6 @@
 #if MOTHERBOARD == 70
 #define KNOWN_BOARD 1
 
-//////////////////FIX THIS//////////////
 
  #ifndef __AVR_ATmega2560__
  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
@@ -1566,12 +1565,230 @@
     #define BTN_EN2 64
     #define BTN_ENC 43  //the click
     
-    #define SDCARDDETECT -1   // Ramps does not use this port
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+    
+    #define SDCARDDETECT -1		// Ramps does not use this port
+    
+      //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
 #endif
 #endif //ULTRA_LCD
 
 #endif
 
+/****************************************************************************************
+* MegaTronics v2.0
+*
+****************************************************************************************/
+#if MOTHERBOARD == 701
+ #define KNOWN_BOARD 1
+ 
+ 
+ #ifndef __AVR_ATmega2560__
+ #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+ 
+ #define LARGE_FLASH        true
+ 
+ #define X_STEP_PIN 26
+ #define X_DIR_PIN 27
+ #define X_ENABLE_PIN 25
+ #define X_MIN_PIN 37
+ #define X_MAX_PIN 40 //2 //Max endstops default to disabled "-1", set to commented value to enable.
+ 
+ #define Y_STEP_PIN 4 // A6
+ #define Y_DIR_PIN 54 // A0
+ #define Y_ENABLE_PIN 5
+ #define Y_MIN_PIN 41
+ #define Y_MAX_PIN 38 //15
+ 
+ #define Z_STEP_PIN 56 // A2
+ #define Z_DIR_PIN 60 // A6
+ #define Z_ENABLE_PIN 55 // A1
+ #define Z_MIN_PIN 18
+ #define Z_MAX_PIN 19
+ 
+ #define E0_STEP_PIN 35
+ #define E0_DIR_PIN 36
+ #define E0_ENABLE_PIN 34
+ 
+ #define E1_STEP_PIN 29
+ #define E1_DIR_PIN 39
+ #define E1_ENABLE_PIN 28
+ 
+ #define E2_STEP_PIN 23
+ #define E2_DIR_PIN 24
+ #define E2_ENABLE_PIN 22
+ 
+ #define SDPOWER -1
+ #define SDSS 53
+ #define LED_PIN 13
+ 
+ #define FAN_PIN 7
+ #define FAN2_PIN 6
+ #define PS_ON_PIN 12
+ #define KILL_PIN -1
+ 
+ #define HEATER_0_PIN 9 // EXTRUDER 1
+ #define HEATER_1_PIN 8 // EXTRUDER 2
+ #define HEATER_2_PIN -1
+ 
+ #if TEMP_SENSOR_0 == -1
+   #define TEMP_0_PIN 4 // ANALOG NUMBERING
+ #else
+   #define TEMP_0_PIN 13 // ANALOG NUMBERING
+ #endif
+ 
+ 
+ #if TEMP_SENSOR_1 == -1
+   #define TEMP_1_PIN 8 // ANALOG NUMBERING
+ #else
+   #define TEMP_1_PIN 15 // ANALOG NUMBERING
+ #endif
+ 
+ #define TEMP_2_PIN -1 // ANALOG NUMBERING
+ 
+ #define HEATER_BED_PIN 10 // BED
+ 
+ #if TEMP_SENSOR_BED == -1
+   #define TEMP_BED_PIN 8 // ANALOG NUMBERING
+ #else 
+   #define TEMP_BED_PIN 14 // ANALOG NUMBERING
+ #endif
+ 
+ #define BEEPER 64	
+ 
+ 
+ #define LCD_PINS_RS 14
+ #define LCD_PINS_ENABLE 15
+ #define LCD_PINS_D4 30
+ #define LCD_PINS_D5 31
+ #define LCD_PINS_D6 32
+ #define LCD_PINS_D7 33
+ 
+ 
+ //buttons are directly attached using keypad
+ #define BTN_EN1 61
+ #define BTN_EN2 59
+ #define BTN_ENC 43 //the click
+ 
+ #define BLEN_C 2
+ #define BLEN_B 1
+ #define BLEN_A 0
+ 
+ #define SDCARDDETECT -1	// Megatronics does not use this port
+ 
+   //encoder rotation values
+ #define encrot0 0
+ #define encrot1 2
+ #define encrot2 3
+ #define encrot3 1
+
+#endif
+
+
+/****************************************************************************************
+* Minitronics v1.0
+*
+****************************************************************************************/
+#if MOTHERBOARD == 702
+ #define KNOWN_BOARD 1
+ 
+ 
+ #ifndef __AVR_ATmega1281__
+ #error Oops! Make sure you have 'Minitronics ' selected from the 'Tools -> Boards' menu.
+ #endif
+ 
+ #define LARGE_FLASH        true
+ 
+ #define X_STEP_PIN 48
+ #define X_DIR_PIN 47
+ #define X_ENABLE_PIN 49
+ #define X_MIN_PIN 5
+ #define X_MAX_PIN -1 //2 //Max endstops default to disabled "-1", set to commented value to enable.
+ 
+ #define Y_STEP_PIN 39 // A6
+ #define Y_DIR_PIN 40 // A0
+ #define Y_ENABLE_PIN 38
+ #define Y_MIN_PIN 2
+ #define Y_MAX_PIN -1 //15
+ 
+ #define Z_STEP_PIN 42 // A2
+ #define Z_DIR_PIN 43 // A6
+ #define Z_ENABLE_PIN 41 // A1
+ #define Z_MIN_PIN 6
+ #define Z_MAX_PIN -1
+ 
+ #define E0_STEP_PIN 45
+ #define E0_DIR_PIN 44
+ #define E0_ENABLE_PIN 27
+ 
+ #define E1_STEP_PIN 36
+ #define E1_DIR_PIN 35
+ #define E1_ENABLE_PIN 37
+ 
+ #define E2_STEP_PIN -1
+ #define E2_DIR_PIN -1
+ #define E2_ENABLE_PIN -1
+ 
+ #define SDPOWER -1
+ #define SDSS 16
+ #define LED_PIN 46
+ 
+ #define FAN_PIN 9
+ #define FAN2_PIN -1
+ #define PS_ON_PIN -1
+ #define KILL_PIN -1
+ 
+ #define HEATER_0_PIN 7 // EXTRUDER 1
+ #define HEATER_1_PIN 8 // EXTRUDER 2
+ #define HEATER_2_PIN -1
+ 
+
+ #define TEMP_0_PIN 7 // ANALOG NUMBERING
+ #define TEMP_1_PIN 6 // ANALOG NUMBERING
+ #define TEMP_2_PIN -1 // ANALOG NUMBERING
+ 
+ #define HEATER_BED_PIN 3 // BED
+ #define TEMP_BED_PIN 6 // ANALOG NUMBERING
+ 
+ #define BEEPER -1	
+ 
+ 
+ #define LCD_PINS_RS -1
+ #define LCD_PINS_ENABLE -1
+ #define LCD_PINS_D4 -1
+ #define LCD_PINS_D5 -1
+ #define LCD_PINS_D6 -1
+ #define LCD_PINS_D7 -1
+ 
+ 
+ //buttons are directly attached using keypad
+ #define BTN_EN1 -1
+ #define BTN_EN2 -1
+ #define BTN_ENC -1 //the click
+ 
+ #define BLEN_C 2
+ #define BLEN_B 1
+ #define BLEN_A 0
+ 
+ #define SDCARDDETECT -1	// Megatronics does not use this port
+ 
+   //encoder rotation values
+ #define encrot0 0
+ #define encrot1 2
+ #define encrot2 3
+ #define encrot3 1
+
+#endif
+
+
+
 #ifndef KNOWN_BOARD
 #error Unknown MOTHERBOARD value in configuration.h
 #endif
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 64935c8..fcebab9 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -98,7 +98,7 @@ volatile unsigned char block_buffer_tail;           // Index of the block to pro
 //=============================private variables ============================
 //===========================================================================
 #ifdef PREVENT_DANGEROUS_EXTRUDE
-bool allow_cold_extrude=false;
+float extrude_min_temp=EXTRUDE_MINTEMP;
 #endif
 #ifdef XY_FREQUENCY_LIMIT
 #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
@@ -537,7 +537,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   #ifdef PREVENT_DANGEROUS_EXTRUDE
   if(target[E_AXIS]!=position[E_AXIS])
   {
-    if(degHotend(active_extruder)<EXTRUDE_MINTEMP && !allow_cold_extrude)
+    if(degHotend(active_extruder)<extrude_min_temp)
     {
       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
       SERIAL_ECHO_START;
@@ -918,12 +918,12 @@ uint8_t movesplanned()
   return (block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
 }
 
-void allow_cold_extrudes(bool allow)
-{
 #ifdef PREVENT_DANGEROUS_EXTRUDE
-  allow_cold_extrude=allow;
-#endif
+void set_extrude_min_temp(float temp)
+{
+  extrude_min_temp=temp;
 }
+#endif
 
 // Calculate the steps/s^2 acceleration rates, based on the mm/s^s
 void reset_acceleration_rates()
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 703646e..597eeb1 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -139,7 +139,9 @@ FORCE_INLINE bool blocks_queued()
     return true;
 }
 
-void allow_cold_extrudes(bool allow);
+#ifdef PREVENT_DANGEROUS_EXTRUDE
+void set_extrude_min_temp(float temp);
+#endif
 
 void reset_acceleration_rates();
 #endif
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index d4e9967..2cf33d9 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -503,7 +503,7 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -525,7 +525,7 @@ static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -547,7 +547,7 @@ static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, cons
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -617,7 +617,7 @@ static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char*
         filename = longFilename;
         longFilename[LCD_WIDTH-1] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -637,7 +637,7 @@ static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, co
         filename = longFilename;
         longFilename[LCD_WIDTH-1] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -658,7 +658,7 @@ static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const
         filename = longFilename;
         longFilename[LCD_WIDTH-2] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -679,7 +679,7 @@ static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pst
         filename = longFilename;
         longFilename[LCD_WIDTH-2] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
diff --git a/Marlin/ultralcd_st7920_u8glib_rrd.h b/Marlin/ultralcd_st7920_u8glib_rrd.h
new file mode 100644
index 0000000..e198a85
--- /dev/null
+++ b/Marlin/ultralcd_st7920_u8glib_rrd.h
@@ -0,0 +1,131 @@
+#ifndef ULCDST7920_H
+#define ULCDST7920_H
+
+#include "Marlin.h"
+
+#ifdef U8GLIB_ST7920
+
+//set optimization so ARDUINO optimizes this file
+#pragma GCC optimize (3)
+
+#define ST7920_CLK_PIN  LCD_PINS_D4
+#define ST7920_DAT_PIN  LCD_PINS_ENABLE
+#define ST7920_CS_PIN   LCD_PINS_RS
+
+//#define PAGE_HEIGHT 8   //128 byte frambuffer
+//#define PAGE_HEIGHT 16  //256 byte frambuffer
+#define PAGE_HEIGHT 32  //512 byte framebuffer
+
+#define WIDTH 128
+#define HEIGHT 64
+
+#include <U8glib.h>
+
+static void ST7920_SWSPI_SND_8BIT(uint8_t val)
+{
+  uint8_t i;
+  for( i=0; i<8; i++ )
+  {
+    WRITE(ST7920_CLK_PIN,0);
+    WRITE(ST7920_DAT_PIN,val&0x80); 
+    val<<=1;
+    WRITE(ST7920_CLK_PIN,1);
+  }
+}
+
+#define ST7920_CS()              {WRITE(ST7920_CS_PIN,1);u8g_10MicroDelay();}
+#define ST7920_NCS()             {WRITE(ST7920_CS_PIN,0);}
+#define ST7920_SET_CMD()         {ST7920_SWSPI_SND_8BIT(0xf8);u8g_10MicroDelay();}
+#define ST7920_SET_DAT()         {ST7920_SWSPI_SND_8BIT(0xfa);u8g_10MicroDelay();}
+#define ST7920_WRITE_BYTE(a)     {ST7920_SWSPI_SND_8BIT((a)&0xf0);ST7920_SWSPI_SND_8BIT((a)<<4);u8g_10MicroDelay();}
+#define ST7920_WRITE_BYTES(p,l)  {uint8_t i;for(i=0;i<l;i++){ST7920_SWSPI_SND_8BIT(*p&0xf0);ST7920_SWSPI_SND_8BIT(*p<<4);p++;}u8g_10MicroDelay();}
+
+uint8_t u8g_dev_rrd_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
+{
+  uint8_t i,y;
+  switch(msg)
+  {
+    case U8G_DEV_MSG_INIT:
+      {
+        SET_OUTPUT(ST7920_CS_PIN);
+        WRITE(ST7920_CS_PIN,0);
+        SET_OUTPUT(ST7920_DAT_PIN);
+        WRITE(ST7920_DAT_PIN,0);
+        SET_OUTPUT(ST7920_CLK_PIN);
+        WRITE(ST7920_CLK_PIN,1);
+
+        ST7920_CS();
+        u8g_Delay(90);                 //initial delay for boot up
+        ST7920_SET_CMD();
+        ST7920_WRITE_BYTE(0x08);       //display off, cursor+blink off
+        ST7920_WRITE_BYTE(0x01);       //clear CGRAM ram
+        u8g_Delay(10);                 //delay for cgram clear
+        ST7920_WRITE_BYTE(0x3E);       //extended mode + gdram active
+        for(y=0;y<HEIGHT/2;y++)        //clear GDRAM
+        {
+          ST7920_WRITE_BYTE(0x80|y);   //set y
+          ST7920_WRITE_BYTE(0x80);     //set x = 0
+          ST7920_SET_DAT();
+          for(i=0;i<2*WIDTH/8;i++)     //2x width clears both segments
+            ST7920_WRITE_BYTE(0);
+          ST7920_SET_CMD();
+        }
+        ST7920_WRITE_BYTE(0x0C); //display on, cursor+blink off
+        ST7920_NCS();
+      }
+      break;
+
+    case U8G_DEV_MSG_STOP:
+      break;
+    case U8G_DEV_MSG_PAGE_NEXT:
+      {
+        uint8_t *ptr;
+        u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
+        y = pb->p.page_y0;
+        ptr = (uint8_t*)pb->buf;
+
+        ST7920_CS();
+        for( i = 0; i < PAGE_HEIGHT; i ++ )
+        {
+          ST7920_SET_CMD();
+          if ( y < 32 )
+          {
+            ST7920_WRITE_BYTE(0x80 | y);       //y
+            ST7920_WRITE_BYTE(0x80);           //x=0
+          }
+          else
+          {
+            ST7920_WRITE_BYTE(0x80 | (y-32));  //y
+            ST7920_WRITE_BYTE(0x80 | 8);       //x=64
+          }
+
+          ST7920_SET_DAT();
+          ST7920_WRITE_BYTES(ptr,WIDTH/8); //ptr is incremented inside of macro
+          y++;
+        }
+        ST7920_NCS();
+      }
+      break;
+  }
+#if PAGE_HEIGHT == 8
+  return u8g_dev_pb8h1_base_fn(u8g, dev, msg, arg);
+#elif PAGE_HEIGHT == 16
+  return u8g_dev_pb16h1_base_fn(u8g, dev, msg, arg);
+#else
+  return u8g_dev_pb32h1_base_fn(u8g, dev, msg, arg);
+#endif
+}
+
+uint8_t   u8g_dev_st7920_128x64_rrd_buf[WIDTH*(PAGE_HEIGHT/8)] U8G_NOCOMMON;
+u8g_pb_t  u8g_dev_st7920_128x64_rrd_pb = {{PAGE_HEIGHT,HEIGHT,0,0,0},WIDTH,u8g_dev_st7920_128x64_rrd_buf};
+u8g_dev_t u8g_dev_st7920_128x64_rrd_sw_spi = {u8g_dev_rrd_st7920_128x64_fn,&u8g_dev_st7920_128x64_rrd_pb,&u8g_com_null_fn};
+
+class U8GLIB_ST7920_128X64_RRD : public U8GLIB
+{
+  public:
+    U8GLIB_ST7920_128X64_RRD(uint8_t dummy) : U8GLIB(&u8g_dev_st7920_128x64_rrd_sw_spi) {}
+};
+
+
+#endif //U8GLIB_ST7920
+#endif //ULCDST7920_H
diff --git a/README.md b/README.md
index ada4e83..d73ff24 100644
--- a/README.md
+++ b/README.md
@@ -2,14 +2,7 @@
 Marlin 3D Printer Firmware
 ==========================
 
-Notes: 
------
-
-The configuration is now split in two files:
-  Configuration.h for the normal settings
-  Configuration_adv.h for the advanced settings
-
-Gen7T is not supported.
+[![Flattr this git repo](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=ErikZalm&url=https://github.com/ErikZalm/Marlin&title=Marlin&language=&tags=github&category=software)
 
 Quick Information
 ===================
@@ -133,57 +126,98 @@ necessary for backwards compatibility.
 An interrupt is used to manage ADC conversions, and enforce checking for critical temperatures.
 This leads to less blocking in the heater management routine.
 
+Implemented G Codes:
+====================
+
+*  G0  -> G1
+*  G1  - Coordinated Movement X Y Z E
+*  G2  - CW ARC
+*  G3  - CCW ARC
+*  G4  - Dwell S<seconds> or P<milliseconds>
+*  G10 - retract filament according to settings of M207
+*  G11 - retract recover filament according to settings of M208
+*  G28 - Home all Axis
+*  G90 - Use Absolute Coordinates
+*  G91 - Use Relative Coordinates
+*  G92 - Set current position to cordinates given
+
+RepRap M Codes
+*  M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+*  M1   - Same as M0
+*  M104 - Set extruder target temp
+*  M105 - Read current temp
+*  M106 - Fan on
+*  M107 - Fan off
+*  M109 - Wait for extruder current temp to reach target temp.
+*  M114 - Display current position
+
+Custom M Codes
+*  M17  - Enable/Power all stepper motors
+*  M18  - Disable all stepper motors; same as M84
+*  M20  - List SD card
+*  M21  - Init SD card
+*  M22  - Release SD card
+*  M23  - Select SD file (M23 filename.g)
+*  M24  - Start/resume SD print
+*  M25  - Pause SD print
+*  M26  - Set SD position in bytes (M26 S12345)
+*  M27  - Report SD print status
+*  M28  - Start SD write (M28 filename.g)
+*  M29  - Stop SD write
+*  M30  - Delete file from SD (M30 filename.g)
+*  M31  - Output time since last M109 or SD card start to serial
+*  M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
+*  M80  - Turn on Power Supply
+*  M81  - Turn off Power Supply
+*  M82  - Set E codes absolute (default)
+*  M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+*  M84  - Disable steppers until next move, or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+*  M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+*  M92  - Set axis_steps_per_unit - same syntax as G92
+*  M114 - Output current position to serial port
+*  M115 - Capabilities string
+*  M117 - display message
+*  M119 - Output Endstop status to serial port
+*  M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
+*  M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
+*  M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M140 - Set bed target temp
+*  M190 - Wait for bed current temp to reach target temp.
+*  M200 - Set filament diameter
+*  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+*  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+*  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+*  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+*  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+*  M206 - set additional homeing offset
+*  M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+*  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+*  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
+*  M220 S<factor in percent>- set speed factor override percentage
+*  M221 S<factor in percent>- set extrude factor override percentage
+*  M240 - Trigger a camera to take a photograph
+*  M280 - set servo position absolute. P: servo index, S: angle or microseconds
+*  M300 - Play beepsound S<frequency Hz> P<duration ms>
+*  M301 - Set PID parameters P I and D
+*  M302 - Allow cold extrudes
+*  M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+*  M304 - Set bed PID parameters P I and D
+*  M400 - Finish all moves
+*  M500 - stores paramters in EEPROM
+*  M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+*  M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+*  M503 - print the current settings (from memory not from eeprom)
+*  M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+*  M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+*  M907 - Set digital trimpot motor current using axis codes.
+*  M908 - Control digital trimpot directly.
+*  M350 - Set microstepping mode.
+*  M351 - Toggle MS1 MS2 pins directly.
+*  M928 - Start SD logging (M928 filename.g) - ended by M29
+*  M999 - Restart after being stopped by error
 
-Non-standard M-Codes, different to an old version of sprinter:
-==============================================================
-Movement:
-
-*   G2  - CW ARC
-*   G3  - CCW ARC
-
-General:
-
-*   M17  - Enable/Power all stepper motors. Compatibility to ReplicatorG.
-*   M18  - Disable all stepper motors; same as M84.Compatibility to ReplicatorG.
-*   M30  - Print time since last M109 or SD card start to serial
-*   M42  - Change pin status via gcode
-*   M80  - Turn on Power Supply
-*   M81  - Turn off Power Supply
-*   M114 - Output current position to serial port 
-*   M119 - Output Endstop status to serial port
-
-Movement variables:
-
-*   M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-*   M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-*   M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-*   M206 - set home offsets.  This sets the X,Y,Z coordinates of the endstops (and is added to the {X,Y,Z}_HOME_POS configuration options (and is also added to the coordinates, if any, provided to G82, as with earlier firmware)
-*   M220 - set build speed mulitplying S:factor in percent ; aka "realtime tuneing in the gcode". So you can slow down if you have islands in one height-range, and speed up otherwise.
-*   M221 - set the extrude multiplying S:factor in percent
-*   M400 - Finish all buffered moves.
-
-Temperature variables:
-*   M301 - Set PID parameters P I and D
-*   M302 - Allow cold extrudes
-*   M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-
-Advance:
-
-*   M200 - Set filament diameter for advance
-*   M205 - advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
-
-EEPROM:
-
-*   M500 - stores paramters in EEPROM. This parameters are stored:  axis_steps_per_unit,  max_feedrate, max_acceleration  ,acceleration,retract_acceleration,
-  minimumfeedrate,mintravelfeedrate,minsegmenttime,  jerk velocities, PID
-*   M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
-*   M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-*   M503 - print the current settings (from memory not from eeprom)
-
-MISC:
-
-*   M240 - Trigger a camera to take a photograph
-*   M999 - Restart after being stopped by error
 
 Configuring and compilation:
 ============================
@@ -194,12 +228,7 @@ Install the arduino software IDE/toolset v23 (Some configurations also work with
 For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
   copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
 
-Install Ultimaker's RepG 25 build
-    http://software.ultimaker.com
-For SD handling and as better substitute (apart from stl manipulation) download
-the very nice Kliment's printrun/pronterface  https://github.com/kliment/Printrun
-
-Copy the Ultimaker Marlin firmware
+Copy the Marlin firmware
    https://github.com/ErikZalm/Marlin/tree/Marlin_v1
    (Use the download button)
 
@@ -213,15 +242,8 @@ Click the Verify/Compile button
 Click the Upload button
 If all goes well the firmware is uploading
 
-Start Ultimaker's Custom RepG 25
-Make sure Show Experimental Profiles is enabled in Preferences
-Select Sprinter as the Driver
-
-Press the Connect button.
-
-KNOWN ISSUES: RepG will display:  Unknown: marlin x.y.z
-
 That's ok.  Enjoy Silky Smooth Printing.
 
 
 
+

