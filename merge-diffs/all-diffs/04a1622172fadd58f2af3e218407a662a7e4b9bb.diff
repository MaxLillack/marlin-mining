commit 04a1622172fadd58f2af3e218407a662a7e4b9bb (from 81c2ca3e100e8de74f74e03bddd02a909a82e88b)
Merge: 81c2ca3 b878bc5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 21 18:43:26 2015 -0700

    Merge pull request #2127 from Wackerbarth/Kossel_Pro
    
    Kossel Pro

diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
index 6c0571c..cbe7c7b 100644
--- a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
@@ -1,4 +1,5 @@
 # See: https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5---3rd-party-Hardware-specification
+# See: http://code.google.com/p/arduino/wiki/Platforms
 
 ##############################################################
 
@@ -70,3 +71,89 @@ sanguino.menu.cpu.atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
 sanguino.menu.cpu.atmega1284m=ATmega1284p 20MHz
 sanguino.menu.cpu.atmega1284m.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
 sanguino.menu.cpu.atmega1284m.build.f_cpu=20000000L
+
+########################################
+## Brainwave
+########################################
+Brainwave.name=Brainwave
+
+Brainwave.bootloader.tool=avrdude
+Brainwave.bootloader.low_fuses=0xFF
+Brainwave.bootloader.high_fuses=0x99
+Brainwave.bootloader.extended_fuses=0xF0
+Brainwave.bootloader.unlock_bits=0x3F
+Brainwave.bootloader.lock_bits=0x02F
+Brainwave.bootloader.path=brainwave
+Brainwave.bootloader.file=Brainwave-646-LUFA.hex
+
+Brainwave.upload.tool=avrdude
+Brainwave.upload.protocol=avr109
+Brainwave.upload.maximum_size=61440
+Brainwave.upload.speed=115200
+Brainwave.upload.disable_flushing=true
+
+Brainwave.build.mcu=at90usb646
+Brainwave.build.f_cpu=16000000L
+Brainwave.build.core=brainwave
+Brainwave.build.dependency=true
+Brainwave.build.variant=brainwave
+Brainwave.build.vid=0x16D0
+Brainwave.build.pid=0x076B
+
+########################################
+## BrainwavePro
+########################################
+BrainwavePro.name=Brainwave Pro
+
+BrainwavePro.bootloader.tool=avrdude
+BrainwavePro.bootloader.low_fuses=0xFF
+BrainwavePro.bootloader.high_fuses=0x9B
+BrainwavePro.bootloader.extended_fuses=0xF0
+BrainwavePro.bootloader.unlock_bits=0x3F
+BrainwavePro.bootloader.lock_bits=0x02F
+BrainwavePro.bootloader.path=brainwave
+BrainwavePro.bootloader.file=BrainwavePro-1286-LUFA.hex
+
+BrainwavePro.upload.tool=avrdude
+BrainwavePro.upload.protocol=avr109
+BrainwavePro.upload.maximum_size=126976
+BrainwavePro.upload.speed=115200
+BrainwavePro.upload.disable_flushing=true
+
+BrainwavePro.build.mcu=at90usb1286
+BrainwavePro.build.f_cpu=16000000L
+BrainwavePro.build.core=brainwave
+BrainwavePro.build.dependency=true
+BrainwavePro.build.variant=brainwavepro
+BrainwavePro.build.vid=0x16D0
+BrainwavePro.build.pid=0x076B
+BrainwavePro.build.extra_flags=-DAT90USBxx_TEENSYPP_ASSIGNMENTS -DUSB_VID={build.vid} -DUSB_PID={build.pid}
+
+########################################
+## KosselPro -- BrainwavePro with HID boot
+########################################
+KosselPro.name=Kossel Pro (HID Bootloader)
+
+KosselPro.bootloader.tool=avrdude
+KosselPro.bootloader.low_fuses=0xFF
+KosselPro.bootloader.high_fuses=0x9B
+KosselPro.bootloader.extended_fuses=0xF0
+KosselPro.bootloader.unlock_bits=0x3F
+KosselPro.bootloader.lock_bits=0x02F
+KosselPro.bootloader.path=brainwave
+KosselPro.bootloader.file=BootloaderHID.hex
+
+KosselPro.upload.tool=hidloader
+KosselPro.upload.protocol=halfkay
+KosselPro.upload.maximum_size=126976
+KosselPro.upload.speed=115200
+KosselPro.upload.disable_flushing=true
+
+KosselPro.build.mcu=at90usb1286
+KosselPro.build.f_cpu=16000000L
+KosselPro.build.core=brainwave
+KosselPro.build.dependency=true
+KosselPro.build.variant=brainwavepro
+KosselPro.build.vid=0x16D0
+KosselPro.build.pid=0x076B
+KosselPro.build.extra_flags=-DAT90USBxx_TEENSYPP_ASSIGNMENTS -DUSB_VID={build.vid} -DUSB_PID={build.pid}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BootloaderHID.hex b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BootloaderHID.hex
new file mode 100644
index 0000000..31134c8
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BootloaderHID.hex
@@ -0,0 +1,139 @@
+:020000021000EC
+:10F000004BC0000077C0000075C0000073C0000056
+:10F0100071C000006FC000006DC000006BC0000038
+:10F0200069C0000067C0000028C2000063C0000083
+:10F0300061C000005FC000005DC000005BC0000058
+:10F0400059C0000057C0000055C0000053C0000068
+:10F0500051C000004FC000004DC000004BC0000078
+:10F0600049C0000047C0000045C0000043C0000088
+:10F0700041C000003FC000003DC000003BC0000098
+:10F0800039C0000037C0000035C0000033C00000A8
+:10F0900031C000002FC0000011241FBECFEFD0E20E
+:10F0A000DEBFCDBF04B603FE0EC080915401909127
+:10F0B000550182349C4D39F410925501109254013F
+:10F0C000E0E0F0E0099511E0A0E0B1E0E8E2F8EF5F
+:10F0D00001E00BBF02C007900D92AA34B107D9F727
+:10F0E00021E0AAE4B1E001C01D92A435B207E1F726
+:10F0F00002D098C385CF84B7877F84BF88E10FB6DD
+:10F10000F89480936000109260000FBE81E085BF8C
+:10F1100082E085BF97D1789480910001882311F017
+:10F1200066D3FACF8091E00081608093E00082E4B2
+:10F130009CED90935501809354012CE088E190E080
+:10F140000FB6F894A895809360000FBE20936000DE
+:10F15000FFCF42E361EC81E002C1CF92DF92EF92F8
+:10F16000FF921F93CF93DF9380914C018F77813271
+:10F1700009F075C080914D01893009F070C080910F
+:10F18000E800877F8093E8008091E80082FFFCCF51
+:10F190009091F1008091F100492F582F60E070E0CC
+:10F1A000B62FA52F942F88274F3F5F4F19F4109249
+:10F1B00000013EC023E0FC01A0935B0020935700B8
+:10F1C000E89507B600FCFDCF20E030E011E040916B
+:10F1D000F2005091F300452B09F437C05091F10033
+:10F1E0004091F100C52FD42FA901440F551F6C0188
+:10F1F0007D01C40ED51EE11CF11C0E01F601E0924A
+:10F200005B0010935700E89511242F5F3F4F203883
+:10F210003105E9F625E0FC01A0935B00209357003F
+:10F22000E89507B600FCFDCF81E180935700E89593
+:10F230008091E8008B778093E800DF91CF911F9158
+:10F24000FF90EF90DF90CF909EC04091E8004B7709
+:10F250004093E8004091E80042FFFCCFBFCFDF9130
+:10F26000CF911F91FF90EF90DF90CF900895913054
+:10F2700049F0923061F0913279F489E090E023E135
+:10F2800031E00EC082E190E023E231E009C082E289
+:10F2900090E021E031E004C085E190E025E331E039
+:10F2A000FA01318320830895209152013091530156
+:10F2B0002617370748F06115710539F42091E800E9
+:10F2C0002E772093E80001C0B901FC0120E0611510
+:10F2D000710591F18EB38823E1F18530E1F18091E0
+:10F2E000E80083FD3AC08091E80082FF06C080916B
+:10F2F000E80082FF24C080E008958091E80080FF4C
+:10F30000E6CF8091F2009091F3006115710551F004
+:10F310008830910538F421912093F10061507109F2
+:10F320000196F3CF21E0089709F020E08091E800F2
+:10F330008E778093E800CBCF2111CCCFD8CF8EB37E
+:10F34000882339F0853039F08091E80083FFCFCFF2
+:10F3500004C082E0089583E0089581E008958F70ED
+:10F360008093E900EBEEF0E0808181608083EDEE38
+:10F37000F0E010826093EC0040838091EE00881FE3
+:10F380008827881F089580914C0187FD05C08091D2
+:10F39000E80080FF0DC010C08091E80082FD04C02D
+:10F3A0008EB38111F9CF08958091E8008B7707C063
+:10F3B0008EB38111ECCF08958091E8008E77809311
+:10F3C000E80008950F931F93CF93DF9349D050D057
+:10F3D000C8EDD0E088818F778883888180688883B2
+:10F3E00088818F7D8883E7EDF0E08081806880836D
+:10F3F00019BC1EBA10924A0100EE10E0F80180819B
+:10F400008B7F808388818160888342E060E080E038
+:10F41000A6DFE1EEF0E080818E7F8083E2EEF0E017
+:10F42000808181608083808188608083F801808111
+:10F430008E7F8083888180618883DF91CF911F9147
+:10F440000F910895E8EDF0E080818F7E8083E7EDF5
+:10F45000F0E080818160808381E080934B01B2CFB6
+:10F46000E8EDF0E080818C7F80831092E2000895C7
+:10F470001092DA001092E10008951F920F920FB6D9
+:10F480000F9211240BB60F922F933F934F935F93DC
+:10F490006F937F938F939F93AF93BF93EF93FF935C
+:10F4A0008091DA0080FF1BC08091D80080FF17C0D8
+:10F4B0008091DA008E7F8093DA008091D90080FFFE
+:10F4C0000BC084E189BD86E189BD09B400FEFDCF92
+:10F4D00081E08EBB8BD103C019BC1EBA87D180914D
+:10F4E000E10080FF17C08091E20080FF13C080918F
+:10F4F000E2008E7F8093E2008091E2008061809341
+:10F50000E2008091D80080628093D80019BC85E029
+:10F510008EBB6CD18091E10084FF2EC08091E2000F
+:10F5200084FF2AC084E189BD86E189BD09B400FE5B
+:10F53000FDCF8091D8008F7D8093D8008091E1002D
+:10F540008F7E8093E1008091E2008F7E8093E200C5
+:10F550008091E20081608093E20080914A018823DB
+:10F5600011F084E007C08091E30087FF02C083E0D0
+:10F5700001C081E08EBB3AD18091E10083FF21C0C0
+:10F580008091E20083FF1DC08091E100877F80931E
+:10F59000E10082E08EBB10924A018091E1008E7FF3
+:10F5A0008093E1008091E2008E7F8093E200809161
+:10F5B000E20080618093E20042E060E080E0CFDE24
+:10F5C00015D1FF91EF91BF91AF919F918F917F9155
+:10F5D0006F915F914F913F912F910F900BBE0F90C4
+:10F5E0000FBE0F901F9018951F93CF93DF9300D0FD
+:10F5F000CDB7DEB7ECE4F1E08091F100819381E0DA
+:10F60000E435F807C9F7A9DD8091E80083FFDAC087
+:10F6100090914C0180914D01853009F465C030F422
+:10F62000813059F168F0833041F1CCC0883009F461
+:10F630009CC0893009F4ABC0863009F0C3C075C0E6
+:10F64000903881F0923809F0BDC0809150018F70E0
+:10F650008093E9009091EB0095FB992790F9109227
+:10F66000E90001C090E08091E800877F8093E80086
+:10F670009093F1001092F10083C0292F2D7F09F0A3
+:10F68000A1C0923009F09EC090914E01911126C008
+:10F69000209150012F7009F495C02093E9009091BA
+:10F6A000EB0090FF1BC0833021F48091EB0080625F
+:10F6B00013C08091EB0080618093EB0081E090E0CB
+:10F6C000022E01C0880F0A94EAF78093EA00109294
+:10F6D000EA008091EB0088608093EB001092E900D3
+:10F6E0008091E800877F4FC091116CC010914E014E
+:10F6F0001F778091E3008078812B8093E3008091D5
+:10F70000E800877F8093E8003EDE8091E80080FF7C
+:10F71000FCCF8091E30080688093E300112311F017
+:10F7200083E001C082E08EBB4DC09058923008F05B
+:10F7300049C0AE014F5F5F4F6091500180914E0113
+:10F7400090914F0194DD009709F43CC02091E800AE
+:10F75000277F2093E800BC0189819A81A5DD8091F3
+:10F76000E8008B778093E8002DC0903859F58091A0
+:10F77000E800877F8093E80080914A018093F10040
+:10F780008091E8008E778093E800FDDD1BC0911129
+:10F7900019C090914E019230A8F48091E800877FC3
+:10F7A0008093E80090934A01EEDD80914A01811137
+:10F7B00004C08091E30087FF02C084E001C081E0C3
+:10F7C0008EBBC7DC8091E80083FF0AC08091E8000F
+:10F7D000877F8093E8008091EB0080628093EB004C
+:10F7E0000F900F90DF91CF911F9108950895CF93BF
+:10F7F0008EB38823A9F08091E9008F709091EC007E
+:10F8000090FF02C090E801C090E0C92FC82B109271
+:10F81000E9008091E80083FDE7DECF70C093E90046
+:08F82000CF910895F894FFCF89
+:10F8280001090222000101008032090400000103DD
+:10F8380000000009211101000122150007058103BC
+:10F848004000051201100100000008EB03672001C9
+:10F85800000000000106DCFF09FBA10109021500F8
+:0AF8680025FF75089602019102C009
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/Brainwave-646-LUFA.hex b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/Brainwave-646-LUFA.hex
new file mode 100644
index 0000000..6adb770
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/Brainwave-646-LUFA.hex
@@ -0,0 +1,239 @@
+:020000021000EC
+:10F000004BC0000064C0000062C0000060C000008F
+:10F010005EC000005CC000005AC0000058C0000084
+:10F0200056C0000054C000006FC4000050C0000073
+:10F030004EC000004CC000004AC0000048C00000A4
+:10F0400046C0000044C0000042C0000040C00000B4
+:10F050003EC000003CC000003AC0000038C00000C4
+:10F0600036C0000034C0000032C0000030C00000D4
+:10F070002EC000002CC000002AC0000028C00000E4
+:10F0800026C0000024C0000022C0000020C00000F4
+:10F090001EC000001CC0000011241FBECFEFD0E135
+:10F0A000DEBFCDBF11E0A0E0B1E0E2E2FEEF02C0C2
+:10F0B00005900D92AC38B107D9F711E0ACE8B1E09A
+:10F0C00001C01D92AD39B107E1F7FCD2A8C698CFB7
+:10F0D00084E08093E9000DC08091E8008B778093F5
+:10F0E000E80003C08EB3882359F08091E80082FFC6
+:10F0F000F9CF8091E80085FFEFCF8091F10008956E
+:10F1000080E0089593E09093E9009091E80095FDE8
+:10F110000DC09091E8009E779093E80003C09EB3E5
+:10F12000992331F09091E80090FFF9CF8093F1009E
+:10F13000089584B7877F84BF88E10FB6F8948093E1
+:10F140006000109260000FBE90E080E80FB6F89467
+:10F1500080936100909361000FBE81E085BF82E0E3
+:10F1600085BFBCC382E061EC42E03ED383E061E84E
+:10F1700042E13AD384E060E842E136C380919601EF
+:10F180008032B1F0813239F580919501813A19F5DB
+:10F190008091E800877F8093E80088E091E067E055
+:10F1A00070E07BD58091E8008B778093E80008952C
+:10F1B00080919501813279F48091E800877F809376
+:10F1C000E80088E091E067E070E0C2D58091E80057
+:10F1D0008E778093E80008952F923F924F925F922E
+:10F1E0006F927F929F92AF92BF92CF92DF92EF92F7
+:10F1F000FF920F931F93DF93CF930F92CDB7DEB79C
+:10F2000084E08093E9008091E80082FF48C2109278
+:10F210008C015EDF182F8C3409F4EEC1803509F4BF
+:10F22000EBC1843529F0853429F410920F01E4C133
+:10F230004FDFE2C1843711F484E448C0813611F411
+:10F2400089E503C28134F1F443DF382F330F20E026
+:10F2500079010027F7FC0095102FE0928F01F092C2
+:10F260009001009391011093920132DF90E0880F9A
+:10F27000991FAA2797FDA095BA2F8E299F29A02B09
+:10F28000B12BB2C1803711F483E5DFC1833559F466
+:10F2900000E011E0F80181918F0134DFF1E00730E7
+:10F2A0001F07C1F7D3C1863521F481E32BDF80E34B
+:10F2B000CCC1833731F482E825DF86E923DF8EE194
+:10F2C000C4C1823631F489E51DDF81E01BDF80E0B7
+:10F2D000BCC18536F9F480E090E0DC0133E025E044
+:10F2E000FC0130935700E89507B600FCFDCF209352
+:10F2F0005700E89507B600FCFDCF8F5F9E4FAF4FDC
+:10F30000BF4F8F3E40EF940741E0A40740E0B407B1
+:10F3100039F772C18C3651F4DBDE809599E0E1E07B
+:10F32000F0E0082E90935700E89566C1823719F4F3
+:10F33000E1E0F0E00EC0863419F4E0E0F0E009C04E
+:10F340008E3419F4E3E0F0E004C0813539F4E2E0F2
+:10F35000F0E089E080935700849177C1833471F4A1
+:10F3600000918F0110919001B3DE90E021E0F8014F
+:10F370000C0120935700E89511243EC1833679F49F
+:10F3800000918F01109190010160A2DE90E021E0D8
+:10F39000F8010C0120935700E89511241AC18D360D
+:10F3A00061F4E0918F01F091900185E08093570026
+:10F3B000E89507B600FCFDCF1FC1823419F08736EF
+:10F3C00009F0E9C085DEE82E83DE082F81DEB82E45
+:10F3D0008554823008F038C13E2D20E0202E3324A1
+:10F3E000222A332A173609F054C081E1809357004E
+:10F3F000E89510E001E048C0FB2DF63409F5E12F57
+:10F40000F0E080918F0190919001E82BF92B84918D
+:10F4100079DE112399F080918F0190919001A09154
+:10F420009101B09192010296A11DB11D80938F01AF
+:10F4300090939001A0939101B0939201102721C065
+:10F4400080918F0190919001A0919101B0919201D2
+:10F45000B695A79597958795CCD454DE80918F016A
+:10F4600090919001A0919101B09192010296A11DFD
+:10F47000B11D80938F0190939001A0939101B0935F
+:10F4800092010894210831082114310409F0B4CF05
+:10F49000DDC040908F01509090016090910170907C
+:10F4A00092012B2D263409F061C083E0F201809394
+:10F4B0005700E89507B600FCFDCF58C0FB2DF63489
+:10F4C00061F5222331F1E0908F01F090900100DE90
+:10F4D000D82ECC248A2D90E08C299D29F7010C018F
+:10F4E00090925700E895112480918F01909190019E
+:10F4F000A0919101B09192010296A11DB11D80933E
+:10F500008F0190939001A0939101B093920120E01C
+:10F5100029C0DEDDA82E21E025C0E0908F01F0900B
+:10F520009001009191011091920116950795F79421
+:10F53000E7942983CDDD682FC70163D480918F01C3
+:10F5400090919001A0919101B09192010296A11D1C
+:10F55000B11D80938F0190939001A0939101B0937E
+:10F560009201298108942108310804C0AA2420E0CE
+:10F57000992493942114310409F0A0CFFB2DF63483
+:10F5800009F03AC085E0F20180935700E89507B68C
+:10F5900000FCFDCF31C0823551F4E0918F01F09134
+:10F5A000900105911491812FADDD802F4EC08434E0
+:10F5B00029F5E0908F01F090900100919101109158
+:10F5C000920116950795F794E79482DD682FC7019D
+:10F5D00018D480918F0190919001A0919101B091E8
+:10F5E00092010296A11DB11D80938F01909390010D
+:10F5F000A0939101B09392018DE027C0843611F55C
+:10F6000080918F0190919001A0919101B091920110
+:10F61000B695A79597958795ECD374DD80918F016A
+:10F6200090919001A0919101B09192010296A11D3B
+:10F63000B11D80938F0190939001A0939101B0939D
+:10F64000920104C08B3111F08FE35CDD83E0809385
+:10F65000E9009091E8008091E8008E778093E800BF
+:10F6600095FF04C010C08EB38823C9F08091E800D4
+:10F6700080FFF9CF8091E8008E778093E80003C087
+:10F680008EB3882361F08091E80080FFF9CF84E099
+:10F690008093E9008091E8008B778093E8000F90D9
+:10F6A000CF91DF911F910F91FF90EF90DF90CF905E
+:10F6B000BF90AF909F907F906F905F904F903F90E2
+:10F6C0002F900895EF92FF920F931F93DF93CF93A4
+:10F6D0000F92CDB7DEB784B714BE909160009861E9
+:10F6E000909360001092600010928C0190E0FC01F9
+:10F6F000E270F07081FD0BC0859194912FEF8F3FE8
+:10F70000920729F0E0918D01F0918E01099511DDAC
+:10F710006F9A779A789481E010E000E0E0E0F0E002
+:10F72000E590F49025C0898357DD51D30F5F89811F
+:10F73000002311F4180F779A011709F477981F3FE7
+:10F7400059F0112351F4813041F080918C018F5F89
+:10F7500080938C0181E001C08FEF90918C019530F6
+:10F7600038F09FEFE9169FEFF90611F010920F01A4
+:10F7700090910F019923B9F68091E0008160809308
+:10F78000E0002CE088E190E00FB6F894A895809313
+:10F7900060000FBE20936000FFCF923049F093309D
+:10F7A00061F09130C1F020E030E080E090E017C0DF
+:10F7B0002EE330E082E291E012C0882331F4209100
+:10F7C000600130E080E691E00AC02091640130E001
+:10F7D00084E691E004C022E130E080E191E0FA01AA
+:10F7E00091838083C90108958093E900EBEEF0E0F6
+:10F7F000808181608083EDEEF0E010826093EC0008
+:10F8000040838091EE00881F8827881F089580918B
+:10F81000950187FF11C003C08EB38823B1F080919A
+:10F82000E80082FFF9CF8091E8008B778093E800B1
+:10F8300008958EB3882349F08091E80080FFF9CFC6
+:10F840008091E8008E778093E800089550D057D0DB
+:10F850008091D800982F9F779093D80080688093EC
+:10F86000D80088E189BD89B5826089BD09B400FEF0
+:10F87000FDCF8091D8008F7D8093D8008091D700F4
+:10F8800080688093D7001EBA109293018091E000A7
+:10F890008B7F8093E0008091D80081608093D800B6
+:10F8A00080E060E042E0A0DF8091E1008E7F809305
+:10F8B000E1008091E20081608093E2008091E200AB
+:10F8C00088608093E2008091E0008E7F8093E0006A
+:10F8D0008091D80080618093D8000895E7EDF0E032
+:10F8E00080818160808381E080939401AFCFE8EDD7
+:10F8F000F0E080818C7F80831092E2000895109266
+:10F90000DA001092E10008951F920F920FB60F9245
+:10F9100011242F933F934F935F936F937F938F9314
+:10F920009F93AF93BF93EF93FF938091DA0080FF93
+:10F9300013C08091D80080FF0FC08091DA008E7FC5
+:10F940008093DA008091D90080FF04C081E08EBBF3
+:10F95000A3D102C01EBAA0D18091E10080FF1CC0DB
+:10F960008091E20080FF18C08091E1008E7F80933B
+:10F97000E1008091E2008E7F8093E2008091E200BE
+:10F9800080618093E2008091D80080628093D800EB
+:10F9900019BC85E08EBB80D18091E10084FF2DC031
+:10F9A0008091E20084FF29C088E189BD89B5826029
+:10F9B00089BD09B400FEFDCF8091D8008F7D809372
+:10F9C000D8008091E1008F7E8093E1008091E20079
+:10F9D0008F7E8093E2008091E20081608093E2005C
+:10F9E00080919301882321F48091E30087FF02C076
+:10F9F00084E001C081E08EBB4FD18091E10083FFA4
+:10FA000021C08091E20083FF1DC08091E100877FCB
+:10FA10008093E10082E08EBB109293018091E1001F
+:10FA20008E7F8093E1008091E2008E7F8093E200E0
+:10FA30008091E20080618093E20080E060E042E03B
+:10FA4000D3DE2AD18091E10082FF0AC08091E200DA
+:10FA500082FF06C08091E1008B7F8093E1001CD182
+:10FA6000FF91EF91BF91AF919F918F917F916F9196
+:10FA70005F914F913F912F910F900FBE0F901F906C
+:10FA800018950F931F93DF93CF9300D0CDB7DEB7B8
+:10FA9000E5E9F1E08091F100819381E0ED39F8072B
+:10FAA000C9F78091950190919601953009F46BC04A
+:10FAB000963040F4913061F1913070F0933009F05C
+:10FAC000D5C026C0983009F4A3C0993009F4B2C05B
+:10FAD000963009F0CBC07CC0803809F4C8C08238A9
+:10FAE00009F0C4C08091990187708093E9009091DA
+:10FAF000EB001092E9008091E800877F8093E80096
+:10FB000081E095FF80E08093F1001092F1008BC0BE
+:10FB1000882319F0823009F0A9C08F71823009F072
+:10FB2000A6C080919701882341F520919901277003
+:10FB300009F49DC02093E9008091EB0080FF1DC077
+:10FB400080919601833021F48091EB00806213C094
+:10FB50008091EB0080618093EB0081E090E002C037
+:10FB6000880F991F2A95E2F78093EA001092EA0025
+:10FB70008091EB0088608093EB001092E900809107
+:10FB8000E800877F53C0882309F070C01091970167
+:10FB90001F770FB7F8948091E800877F8093E80083
+:10FBA00036DE8091E80080FFFCCF112311F083E066
+:10FBB00001C082E08EBB8091E3008078812B80932E
+:10FBC000E3008091E30080688093E3000FBF4FC0A3
+:10FBD0008058823008F04AC0809197019091980136
+:10FBE00060919901AE014F5F5F4FD7DDBC01009777
+:10FBF00009F43DC08091E800877F8093E800898107
+:10FC00009A814BD08091E8008B778093E8002FC0D9
+:10FC1000803861F58091E800877F8093E8008091CB
+:10FC200093018093F1008091E8008E778093E80043
+:10FC3000EEDD1DC08823D1F4909197019230B8F485
+:10FC40008091E800877F8093E80090939301DFDD47
+:10FC500080919301882321F48091E30087FF02C003
+:10FC600084E001C081E08EBB7DDA01C087DA80913B
+:10FC7000E80083FF0AC08091EB0080628093EB0074
+:10FC80008091E800877F8093E8000F900F90CF91DC
+:10FC9000DF911F910F9108950895282F392FF901B1
+:10FCA00080919B0190919C018617970718F4BC01E5
+:10FCB00020E035C061157105D9F78091E8008E7795
+:10FCC0008093E800F5CF8EB38823F1F18530C1F140
+:10FCD0008091E80083FD36C08091E80082FD2AC053
+:10FCE0008091E80080FF1BC08091F2009091F300AA
+:10FCF00006C021912093F10061507040019661157A
+:10FD0000710519F088309105A0F321E08830910544
+:10FD100009F020E08091E8008E778093E80061157B
+:10FD2000710589F6222379F605C08EB3882361F028
+:10FD3000853061F08091E80082FFF7CF80E0089580
+:10FD400083E0089581E0089582E0089583E00895B6
+:10FD50006115710529F51FC02EB32223A1F12530AD
+:10FD600071F12091E80023FD2CC02091E80022FFD2
+:10FD7000F3CFE82FF92F07C08091F1008193CF01D5
+:10FD80006150704041F0CF012091F2003091F300BA
+:10FD90002115310589F72091E8002B772093E800A1
+:10FDA00061157105C9F605C08EB3882361F08530F1
+:10FDB00061F08091E80080FFF7CF80E0089583E054
+:10FDC000089581E0089582E0089583E008951F93E7
+:10FDD0008EB3882361F01091E90017701092E9004A
+:10FDE0008091E80083FF01C04CDE1093E9001F9171
+:10FDF0000895F999FECF92BD81BDF89A992780B5F3
+:10FE00000895262FF999FECF1FBA92BD81BD20BD5E
+:10FE10000FB6F894FA9AF99A0FBE01960895F894DD
+:02FE2000FFCF12
+:10FE22004C554641434443000000000000000801D5
+:10FE320012011001020000089A23010001000001D2
+:10FE4200000109023E0002010080320904000001A3
+:10FE52000202010005240010010424020405240604
+:10FE620000010705820308000209040100020A00DA
+:10FE720000000705040210000007058302100000BD
+:10FE820004030904260341005600520020004300E7
+:10FE920044004300200042006F006F0074006C00B9
+:0CFEA2006F006100640065007200000049
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BrainwavePro-1286-LUFA.hex b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BrainwavePro-1286-LUFA.hex
new file mode 100644
index 0000000..99f0f36
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/bootloaders/brainwave/BrainwavePro-1286-LUFA.hex
@@ -0,0 +1,247 @@
+:020000021000EC
+:10F000004BC0000066C0000064C0000062C0000089
+:10F0100060C000005EC000005CC000005AC000007C
+:10F0200058C0000056C00000ACC4000052C0000030
+:10F0300050C000004EC000004CC000004AC000009C
+:10F0400048C0000046C0000044C0000042C00000AC
+:10F0500040C000003EC000003CC000003AC00000BC
+:10F0600038C0000036C0000034C0000032C00000CC
+:10F0700030C000002EC000002CC000002AC00000DC
+:10F0800028C0000026C0000024C0000022C00000EC
+:10F0900020C000001EC0000011241FBECFEFD0E230
+:10F0A000DEBFCDBF11E0A0E0B1E0E4EAFEEF01E099
+:10F0B0000BBF02C007900D92AC38B107D9F711E031
+:10F0C000ACE8B1E001C01D92AD39B107E1F72FD333
+:10F0D000E7C696CF84E08093E9000DC08091E800F8
+:10F0E0008B778093E80003C08EB3882359F080911A
+:10F0F000E80082FFF9CF8091E80085FFEFCF809193
+:10F10000F100089580E0089593E09093E9009091D4
+:10F11000E80095FD0DC09091E8009E779093E8007F
+:10F1200003C09EB3992331F09091E80090FFF9CF8E
+:10F130008093F100089584B7877F84BF88E10FB67C
+:10F14000F89480936000109260000FBE90E080E819
+:10F150000FB6F89480936100909361000FBE81E038
+:10F1600085BF82E085BFF7C382E061EC42E079D3DE
+:10F1700083E061E842E175D384E060E842E171C375
+:10F18000809196018032B1F0813239F580919501FC
+:10F19000813A19F58091E800877F8093E80088E044
+:10F1A00091E067E070E0BAD58091E8008B778093BA
+:10F1B000E800089580919501813279F48091E8000A
+:10F1C000877F8093E80088E091E067E070E001D6F7
+:10F1D0008091E8008E778093E80008952F923F9207
+:10F1E0005F926F927F928F929F92AF92BF92CF92D7
+:10F1F000DF92EF92FF920F931F93DF93CF930F92C3
+:10F20000CDB7DEB784E08093E9008091E80082FF0B
+:10F210007BC210928C015EDF182F8C3409F421C25E
+:10F22000803509F41EC2843529F0853429F4109202
+:10F230000F0117C24FDF15C2843711F484E448C0B0
+:10F24000813611F489E536C28134F1F443DF382F79
+:10F25000330F20E079010027F7FC0095102FE09292
+:10F260008F01F0929001009391011093920132DF8F
+:10F2700090E0880F991FAA2797FDA095BA2F8E2995
+:10F280009F29A02BB12BE5C1803711F483E512C271
+:10F29000833559F400E011E0D8018D918D0134DF00
+:10F2A000B1E007301B07C1F706C2863521F481E3C0
+:10F2B0002BDF80E3FFC1833731F482E825DF87E964
+:10F2C00023DF8EE1F7C1823631F489E51DDF81E06D
+:10F2D0001BDF80E0EFC1853621F580E090E0DC01A6
+:10F2E00033E025E0FC01A0935B0030935700E895E4
+:10F2F00007B600FCFDCFFC01A0935B0020935700F4
+:10F30000E89507B600FCFDCF8F5F9E4FAF4FBF4F14
+:10F310008F3EE0EF9E07E1E0AE07E0E0BE0711F7A9
+:10F32000A0C18C3651F4D6DE809599E0E1E0F0E0A2
+:10F33000082E90935700E89594C1823719F4E1E0C4
+:10F34000F0E00EC0863419F4E0E0F0E009C08E343D
+:10F3500019F4E3E0F0E004C0813539F4E2E0F0E0D4
+:10F3600089E0809357008491A5C18334A1F4E09093
+:10F370008F01F09090010091910110919201AADE0D
+:10F3800090E021E00C01F70100935B00209357000F
+:10F39000E895112466C18336E1F4E0908F01F09086
+:10F3A0009001009191011091920181E090E0A0E024
+:10F3B000B0E0E82AF92A0A2B1B2B8CDE90E021E032
+:10F3C0000C01F70100935B0020935700E89511248E
+:10F3D00035C18D3699F480918F0190919001A09163
+:10F3E0009101B091920125E0FC01A0935B00209374
+:10F3F0005700E89507B600FCFDCF33C1823419F001
+:10F40000873609F0F7C066DEE82E64DE082F62DE7C
+:10F41000982E8554823008F04CC13E2D20E0202EDD
+:10F420003324222A332A173609F058C081E1809309
+:10F430005700E89510E001E04CC020918F01309119
+:10F4400090014091910150919201992D963419F5B6
+:10F45000812F90E0A0E0B0E0822B932BA42BB52B62
+:10F46000ABBFFC01879150DE112399F080918F0191
+:10F4700090919001A0919101B09192010296A11DED
+:10F48000B11D80938F0190939001A0939101B0934F
+:10F49000920110271BC0DA01C901B695A79597956F
+:10F4A0008795E8D431DE80918F0190919001A091F1
+:10F4B0009101B09192010296A11DB11D80938F011F
+:10F4C00090939001A0939101B09392010894210828
+:10F4D00031082114310409F0B0CFEDC0A0908F01A4
+:10F4E000B0909001C0909101D0909201A92DA634C6
+:10F4F00009F069C083E0F501C0925B00809357007A
+:10F50000E89507B600FCFDCF5EC0B92DB63491F585
+:10F51000222361F1E0908F01F09090010091910120
+:10F5200010919201D7DD782E6624282D30E026290F
+:10F5300037290901F70100935B0050925700E895C5
+:10F54000112480918F0190919001A0919101B0912F
+:10F5500092010296A11DB11D80938F01909390019D
+:10F56000A0939101B093920120E029C0B3DD882ED1
+:10F5700021E025C0E0908F01F09090010091910171
+:10F580001091920116950795F794E7942983A2DDCF
+:10F59000682FC70177D480918F0190919001A0913D
+:10F5A0009101B09192010296A11DB11D80938F012E
+:10F5B00090939001A0939101B093920129810894B6
+:10F5C0002108310804C0882420E0552453942114D4
+:10F5D000310409F09ACFE92DE63409F042C085E004
+:10F5E000F501C0925B0080935700E89507B600FCD8
+:10F5F000FDCF37C0823581F480918F0190919001C9
+:10F60000A0919101B0919201ABBFFC0107911691BD
+:10F61000812F7ADD802F4EC0843429F5E0908F0150
+:10F62000F09090010091910110919201169507952B
+:10F63000F794E7944FDD682FC70124D480918F01A0
+:10F6400090919001A0919101B09192010296A11D1B
+:10F65000B11D80938F0190939001A0939101B0937D
+:10F6600092018DE027C0843611F580918F01909131
+:10F670009001A0919101B0919201B695A7959795AF
+:10F680008795F8D341DD80918F0190919001A091F1
+:10F690009101B09192010296A11DB11D80938F013D
+:10F6A00090939001A0939101B093920104C08B318B
+:10F6B00011F08FE329DD83E08093E9009091E80069
+:10F6C0008091E8008E778093E80095FF04C010C019
+:10F6D0008EB38823C9F08091E80080FFF9CF809134
+:10F6E000E8008E778093E80003C08EB3882361F032
+:10F6F0008091E80080FFF9CF84E08093E900809159
+:10F70000E8008B778093E8000F90CF91DF911F91F5
+:10F710000F91FF90EF90DF90CF90BF90AF909F90B0
+:10F720008F907F906F905F903F902F900895EF9211
+:10F73000FF920F931F93DF93CF930F92CDB7DEB756
+:10F7400084B714BE9091600098619093600010920D
+:10F75000600010928C0190E0FC01E270F07081FD7D
+:10F760000BC0859194912FEF8F3F920729F0E09184
+:10F770008D01F0918E010995209A289A6F9A779AB7
+:10F780006D9A759A3B9A439AD6DC6F9A779A7894D9
+:10F7900081E010E000E0E0E0F0E0E590F49025C0CA
+:10F7A00089831CDD55D30F5F8981002311F4180F65
+:10F7B000779A011709F477981F3F59F0112351F4F4
+:10F7C000813041F080918C018F5F80938C0181E0CA
+:10F7D00001C08FEF90918C01923338F09FEFE916C2
+:10F7E0009FEFF90611F010920F0190910F019923EC
+:10F7F000B9F68091E00081608093E0002CE088E120
+:10F8000090E00FB6F894A895809360000FBE209307
+:10F810006000FFCF923049F0933061F09130C1F039
+:10F8200020E030E080E090E017C02EE330E082E29C
+:10F8300091E012C0882331F42091600130E080E62D
+:10F8400091E00AC02091640130E084E691E004C0B8
+:10F8500022E130E080E191E0FA0191838083C901E7
+:10F8600008958093E900EBEEF0E080818160808371
+:10F87000EDEEF0E010826093EC0040838091EE00AA
+:10F88000881F8827881F08958091950187FF11C0E0
+:10F8900003C08EB38823B1F08091E80082FFF9CFD6
+:10F8A0008091E8008B778093E80008958EB38823D9
+:10F8B00049F08091E80080FFF9CF8091E8008E77D1
+:10F8C0008093E800089550D057D08091D800982FA9
+:10F8D0009F779093D80080688093D80084E189BD99
+:10F8E00089B5826089BD09B400FEFDCF8091D80042
+:10F8F0008F7D8093D8008091D70080688093D70057
+:10F900001EBA109293018091E0008B7F8093E000FB
+:10F910008091D80081608093D80080E060E042E070
+:10F92000A0DF8091E1008E7F8093E1008091E20072
+:10F9300081608093E2008091E20088608093E20021
+:10F940008091E0008E7F8093E0008091D8008061FC
+:10F950008093D8000895E7EDF0E080818160808396
+:10F9600081E080939401AFCFE8EDF0E080818C7F5F
+:10F9700080831092E20008951092DA001092E10064
+:10F9800008951F920F920FB60F920BB60F9211248B
+:10F990002F933F934F935F936F937F938F939F9397
+:10F9A000AF93BF93EF93FF938091DA0080FF13C072
+:10F9B0008091D80080FF0FC08091DA008E7F809305
+:10F9C000DA008091D90080FF04C081E08EBBA5D110
+:10F9D00002C01EBAA2D18091E10080FF1CC08091BC
+:10F9E000E20080FF18C08091E1008E7F8093E100EB
+:10F9F0008091E2008E7F8093E2008091E20080613E
+:10FA00008093E2008091D80080628093D80019BC76
+:10FA100085E08EBB82D18091E10084FF2DC0809172
+:10FA2000E20084FF29C084E189BD89B5826089BD77
+:10FA300009B400FEFDCF8091D8008F7D8093D8005F
+:10FA40008091E1008F7E8093E1008091E2008F7EC3
+:10FA50008093E2008091E20081608093E2008091D7
+:10FA60009301882321F48091E30087FF02C084E0A2
+:10FA700001C081E08EBB51D18091E10083FF21C0A4
+:10FA80008091E20083FF1DC08091E100877F809319
+:10FA9000E10082E08EBB109293018091E1008E7FA5
+:10FAA0008093E1008091E2008E7F8093E20080915C
+:10FAB000E20080618093E20080E060E042E0D1DE1D
+:10FAC0002CD18091E10082FF0AC08091E20082FF88
+:10FAD00006C08091E1008B7F8093E1001ED1FF91F1
+:10FAE000EF91BF91AF919F918F917F916F915F91B6
+:10FAF0004F913F912F910F900BBE0F900FBE0F9023
+:10FB00001F9018950F931F93DF93CF9300D0CDB71D
+:10FB1000DEB7E5E9F1E08091F100819381E0ED3914
+:10FB2000F807C9F78091950190919601953009F4F5
+:10FB30006BC0963040F4913061F1913070F09330A9
+:10FB400009F0D5C026C0983009F4A3C0993009F453
+:10FB5000B2C0963009F0CBC07CC0803809F4C8C070
+:10FB6000823809F0C4C08091990187708093E900C0
+:10FB70009091EB001092E9008091E800877F8093DC
+:10FB8000E80081E095FF80E08093F1001092F100A1
+:10FB90008BC0882319F0823009F0A9C08F718230A0
+:10FBA00009F0A6C080919701882341F52091990121
+:10FBB000277009F49DC02093E9008091EB0080FF3D
+:10FBC0001DC080919601833021F48091EB0080620A
+:10FBD00013C08091EB0080618093EB0081E090E0A6
+:10FBE00002C0880F991F2A95E2F78093EA001092CD
+:10FBF000EA008091EB0088608093EB001092E900AE
+:10FC00008091E800877F53C0882309F070C010916D
+:10FC100097011F770FB7F8948091E800877F809352
+:10FC2000E80032DE8091E80080FFFCCF112311F064
+:10FC300083E001C082E08EBB8091E3008078812B5D
+:10FC40008093E3008091E30080688093E3000FBF1E
+:10FC50004FC08058823008F04AC08091970190913F
+:10FC6000980160919901AE014F5F5F4FD3DDBC01F8
+:10FC7000009709F43DC08091E800877F8093E800F9
+:10FC800089819A814BD08091E8008B778093E8003E
+:10FC90002FC0803861F58091E800877F8093E8006D
+:10FCA000809193018093F1008091E8008E7780939A
+:10FCB000E800EADD1DC08823D1F4909197019230CD
+:10FCC000B8F48091E800877F8093E80090939301D7
+:10FCD000DBDD80919301882321F48091E30087FF8D
+:10FCE00002C084E001C081E08EBB3EDA01C048DA88
+:10FCF0008091E80083FF0AC08091EB0080628093CE
+:10FD0000EB008091E800877F8093E8000F900F90D0
+:10FD1000CF91DF911F910F9108950895282F392FCA
+:10FD2000F90180919B0190919C018617970718F427
+:10FD3000BC0120E035C061157105D9F78091E8005C
+:10FD40008E778093E800F5CF8EB38823F1F185306C
+:10FD5000C1F18091E80083FD36C08091E80082FD0A
+:10FD60002AC08091E80080FF1BC08091F200909132
+:10FD7000F30006C021912093F1006150704001967C
+:10FD80006115710519F088309105A0F321E08830E4
+:10FD9000910509F020E08091E8008E778093E800DB
+:10FDA0006115710589F6222379F605C08EB3882383
+:10FDB00061F0853061F08091E80082FFF7CF80E04C
+:10FDC000089583E0089581E0089582E0089583E036
+:10FDD00008956115710529F51FC02EB32223A1F1E5
+:10FDE000253071F12091E80023FD2CC02091E8001E
+:10FDF00022FFF3CFE82FF92F07C08091F100819304
+:10FE0000CF016150704041F0CF012091F20030915C
+:10FE1000F3002115310589F72091E8002B77209315
+:10FE2000E80061157105C9F605C08EB3882361F03D
+:10FE3000853061F08091E80080FFF7CF80E0089581
+:10FE400083E0089581E0089582E0089583E00895B5
+:10FE50001F938EB3882361F01091E9001770109200
+:10FE6000E9008091E80083FF01C04CDE1093E900B7
+:10FE70001F910895F999FECF92BD81BDF89A9927F7
+:10FE800080B50895262FF999FECF1FBA92BD81BD86
+:10FE900020BD0FB6F894FA9AF99A0FBE019608950C
+:04FEA000F894FFCF04
+:10FEA4004C55464143444300000000000000080153
+:10FEB40012011001020000089A2301000100000150
+:10FEC400000109023E000201008032090400000121
+:10FED4000202010005240010010424020405240682
+:10FEE40000010705820308000209040100020A0058
+:10FEF400000007050402100000070583021000003B
+:10FF04000403090426034100560052002000430064
+:10FF140044004300200042006F006F0074006C0036
+:0CFF24006F0061006400650072000000C6
+:040000031000F000F9
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Arduino.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Arduino.h
new file mode 100644
index 0000000..830c995
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Arduino.h
@@ -0,0 +1,215 @@
+#ifndef Arduino_h
+#define Arduino_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/pgmspace.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+#define INPUT_PULLUP 0x2
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
+#define DEFAULT 0
+#define EXTERNAL 1
+#define INTERNAL 2
+#else  
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1284P__) 
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+#endif
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+
+#define analogInPinToBit(P) (P)
+
+// On the ATmega1280, the addresses of some of the port registers are
+// greater than 255, so we can't store them in uint8_t's.
+extern const uint16_t PROGMEM port_to_mode_PGM[];
+extern const uint16_t PROGMEM port_to_input_PGM[];
+extern const uint16_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+// extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#ifdef ARDUINO_MAIN
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+#define PE 5
+#define PF 6
+#define PG 7
+#define PH 8
+#define PJ 10
+#define PK 11
+#define PL 12
+#endif
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+#define TIMER3A 8
+#define TIMER3B 9
+#define TIMER3C 10
+#define TIMER4A 11
+#define TIMER4B 12
+#define TIMER4C 13
+#define TIMER4D 14	
+#define TIMER5A 15
+#define TIMER5B 16
+#define TIMER5C 17
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#endif
+
+#include "pins_arduino.h"
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/CDC.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/CDC.cpp
new file mode 100644
index 0000000..5a49621
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/CDC.cpp
@@ -0,0 +1,236 @@
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include <avr/wdt.h>
+
+#if defined(USBCON)
+#ifdef CDC_ENABLED
+
+#if (RAMEND < 1000)
+#define SERIAL_BUFFER_SIZE 16
+#else
+// Use a 128 byte buffer like Arduinos of old for maximum
+// compatibility. -Hubbe 20120929
+#define SERIAL_BUFFER_SIZE 128
+#endif
+
+struct ring_buffer
+{
+	unsigned char buffer[SERIAL_BUFFER_SIZE];
+	volatile int head;
+	volatile int tail;
+};
+
+ring_buffer cdc_rx_buffer = { { 0 }, 0, 0};
+
+typedef struct
+{
+	u32	dwDTERate;
+	u8	bCharFormat;
+	u8 	bParityType;
+	u8 	bDataBits;
+	u8	lineState;
+} LineInfo;
+
+static volatile LineInfo _usbLineInfo = { 57600, 0x00, 0x00, 0x00, 0x00 };
+
+#define WEAK __attribute__ ((weak))
+
+extern const CDCDescriptor _cdcInterface PROGMEM;
+const CDCDescriptor _cdcInterface =
+{
+	D_IAD(0,2,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,1),
+
+	//	CDC communication interface
+	D_INTERFACE(CDC_ACM_INTERFACE,1,CDC_COMMUNICATION_INTERFACE_CLASS,CDC_ABSTRACT_CONTROL_MODEL,0),
+	D_CDCCS(CDC_HEADER,0x10,0x01),								// Header (1.10 bcd)
+	D_CDCCS(CDC_CALL_MANAGEMENT,1,1),							// Device handles call management (not)
+	D_CDCCS4(CDC_ABSTRACT_CONTROL_MANAGEMENT,6),				// SET_LINE_CODING, GET_LINE_CODING, SET_CONTROL_LINE_STATE supported
+	D_CDCCS(CDC_UNION,CDC_ACM_INTERFACE,CDC_DATA_INTERFACE),	// Communication interface is master, data interface is slave 0
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_ACM),USB_ENDPOINT_TYPE_INTERRUPT,0x10,0x40),
+
+	//	CDC data interface
+	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
+	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
+	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
+};
+
+int WEAK CDC_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 2;	// uses 2
+	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
+}
+
+bool WEAK CDC_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_GET_LINE_CODING == r)
+		{
+			USB_SendControl(0,(void*)&_usbLineInfo,7);
+			return true;
+		}
+	}
+
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (CDC_SET_LINE_CODING == r)
+		{
+			USB_RecvControl((void*)&_usbLineInfo,7);
+			return true;
+		}
+
+		if (CDC_SET_CONTROL_LINE_STATE == r)
+		{
+			_usbLineInfo.lineState = setup.wValueL;
+
+			// auto-reset into the bootloader is triggered when the port, already 
+			// open at 1200 bps, is closed.  this is the signal to start the watchdog
+			// with a relatively long period so it can finish housekeeping tasks
+			// like servicing endpoints before the sketch ends
+			if (1200 == _usbLineInfo.dwDTERate) {
+				// We check DTR state to determine if host port is open (bit 0 of lineState).
+				if ((_usbLineInfo.lineState & 0x01) == 0) {
+					*(uint16_t *)0x0800 = 0x7777;
+					wdt_enable(WDTO_120MS);
+				} else {
+					// Most OSs do some intermediate steps when configuring ports and DTR can
+					// twiggle more than once before stabilizing.
+					// To avoid spurious resets we set the watchdog to 250ms and eventually
+					// cancel if DTR goes back high.
+	
+					wdt_disable();
+					wdt_reset();
+					*(uint16_t *)0x0800 = 0x0;
+				}
+			}
+			return true;
+		}
+	}
+	return false;
+}
+
+
+int _serialPeek = -1;
+void Serial_::begin(uint16_t baud_count)
+{
+}
+
+void Serial_::end(void)
+{
+}
+
+void Serial_::accept(void) 
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	int c = USB_Recv(CDC_RX); 
+	int i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
+	
+	// if we should be storing the received character into the location
+	// just before the tail (meaning that the head would advance to the
+	// current location of the tail), we're about to overflow the buffer
+	// and so we don't write the character or advance the head.
+	if (i != buffer->tail) {
+		buffer->buffer[buffer->head] = c;
+		buffer->head = i;
+	}
+}
+
+int Serial_::available(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int Serial_::peek(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		return buffer->buffer[buffer->tail];
+	}
+}
+
+int Serial_::read(void)
+{
+	ring_buffer *buffer = &cdc_rx_buffer;
+	// if the head isn't ahead of the tail, we don't have any characters
+	if (buffer->head == buffer->tail) {
+		return -1;
+	} else {
+		unsigned char c = buffer->buffer[buffer->tail];
+		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+		return c;
+	}	
+}
+
+void Serial_::flush(void)
+{
+	USB_Flush(CDC_TX);
+}
+
+size_t Serial_::write(uint8_t c)
+{
+	/* only try to send bytes if the high-level CDC connection itself 
+	 is open (not just the pipe) - the OS should set lineState when the port
+	 is opened and clear lineState when the port is closed.
+	 bytes sent before the user opens the connection or after
+	 the connection is closed are lost - just like with a UART. */
+	
+	// TODO - ZE - check behavior on different OSes and test what happens if an
+	// open connection isn't broken cleanly (cable is yanked out, host dies
+	// or locks up, or host virtual serial port hangs)
+
+  /* Actually, let's ignore the line state for now since repetierHost
+     doens't work if we don't ignore it. -Hubbe 20120929 */
+  /* if (_usbLineInfo.lineState > 0)	*/ {
+		int r = USB_Send(CDC_TX,&c,1);
+		if (r > 0) {
+			return r;
+		} else {
+			setWriteError();
+			return 0;
+		}
+	}
+	setWriteError();
+	return 0;
+}
+
+// This operator is a convenient way for a sketch to check whether the
+// port has actually been configured and opened by the host (as opposed
+// to just being connected to the host).  It can be used, for example, in 
+// setup() before printing to ensure that an application on the host is
+// actually ready to receive and display the data.
+// We add a short delay before returning to fix a bug observed by Federico
+// where the port is configured (lineState != 0) but not quite opened.
+Serial_::operator bool() {
+	bool result = false;
+	if (_usbLineInfo.lineState > 0) 
+		result = true;
+	delay(10);
+	return result;
+}
+
+Serial_ Serial;
+
+#endif
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Client.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Client.h
new file mode 100644
index 0000000..ea13483
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Client.h
@@ -0,0 +1,26 @@
+#ifndef client_h
+#define client_h
+#include "Print.h"
+#include "Stream.h"
+#include "IPAddress.h"
+
+class Client : public Stream {
+
+public:
+  virtual int connect(IPAddress ip, uint16_t port) =0;
+  virtual int connect(const char *host, uint16_t port) =0;
+  virtual size_t write(uint8_t) =0;
+  virtual size_t write(const uint8_t *buf, size_t size) =0;
+  virtual int available() = 0;
+  virtual int read() = 0;
+  virtual int read(uint8_t *buf, size_t size) = 0;
+  virtual int peek() = 0;
+  virtual void flush() = 0;
+  virtual void stop() = 0;
+  virtual uint8_t connected() = 0;
+  virtual operator bool() = 0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HID.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HID.cpp
new file mode 100644
index 0000000..ac63608
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HID.cpp
@@ -0,0 +1,520 @@
+
+
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+#ifdef HID_ENABLED
+
+//#define RAWHID_ENABLED
+
+//	Singletons for mouse and keyboard
+
+Mouse_ Mouse;
+Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+
+//	HID report descriptor
+
+#define LSB(_x) ((_x) & 0xFF)
+#define MSB(_x) ((_x) >> 8)
+
+#define RAWHID_USAGE_PAGE	0xFFC0
+#define RAWHID_USAGE		0x0C00
+#define RAWHID_TX_SIZE 64
+#define RAWHID_RX_SIZE 64
+
+extern const u8 _hidReportDescriptor[] PROGMEM;
+const u8 _hidReportDescriptor[] = {
+	
+	//	Mouse
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 54
+    0x09, 0x02,                    // USAGE (Mouse)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x09, 0x01,                    //   USAGE (Pointer)
+    0xa1, 0x00,                    //   COLLECTION (Physical)
+    0x85, 0x01,                    //     REPORT_ID (1)
+    0x05, 0x09,                    //     USAGE_PAGE (Button)
+    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
+    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
+    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x75, 0x01,                    //     REPORT_SIZE (1)
+    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //     REPORT_COUNT (1)
+    0x75, 0x05,                    //     REPORT_SIZE (5)
+    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
+    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
+    0x09, 0x30,                    //     USAGE (X)
+    0x09, 0x31,                    //     USAGE (Y)
+    0x09, 0x38,                    //     USAGE (Wheel)
+    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
+    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
+    0x75, 0x08,                    //     REPORT_SIZE (8)
+    0x95, 0x03,                    //     REPORT_COUNT (3)
+    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
+    0xc0,                          //   END_COLLECTION
+    0xc0,                          // END_COLLECTION
+
+	//	Keyboard
+    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)	// 47
+    0x09, 0x06,                    // USAGE (Keyboard)
+    0xa1, 0x01,                    // COLLECTION (Application)
+    0x85, 0x02,                    //   REPORT_ID (2)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+   
+	0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)
+    0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
+    0x75, 0x01,                    //   REPORT_SIZE (1)
+    
+	0x95, 0x08,                    //   REPORT_COUNT (8)
+    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
+    0x95, 0x01,                    //   REPORT_COUNT (1)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
+    
+	0x95, 0x06,                    //   REPORT_COUNT (6)
+    0x75, 0x08,                    //   REPORT_SIZE (8)
+    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
+    0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
+    0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
+    
+	0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
+    0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
+    0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
+    0xc0,                          // END_COLLECTION
+
+#if RAWHID_ENABLED
+	//	RAW HID
+	0x06, LSB(RAWHID_USAGE_PAGE), MSB(RAWHID_USAGE_PAGE),	// 30
+	0x0A, LSB(RAWHID_USAGE), MSB(RAWHID_USAGE),
+
+	0xA1, 0x01,				// Collection 0x01
+    0x85, 0x03,             // REPORT_ID (3)
+	0x75, 0x08,				// report size = 8 bits
+	0x15, 0x00,				// logical minimum = 0
+	0x26, 0xFF, 0x00,		// logical maximum = 255
+
+	0x95, 64,				// report count TX
+	0x09, 0x01,				// usage
+	0x81, 0x02,				// Input (array)
+
+	0x95, 64,				// report count RX
+	0x09, 0x02,				// usage
+	0x91, 0x02,				// Output (array)
+	0xC0					// end collection
+#endif
+};
+
+extern const HIDDescriptor _hidInterface PROGMEM;
+const HIDDescriptor _hidInterface =
+{
+	D_INTERFACE(HID_INTERFACE,1,3,0,0),
+	D_HIDREPORT(sizeof(_hidReportDescriptor)),
+	D_ENDPOINT(USB_ENDPOINT_IN (HID_ENDPOINT_INT),USB_ENDPOINT_TYPE_INTERRUPT,0x40,0x01)
+};
+
+//================================================================================
+//================================================================================
+//	Driver
+
+u8 _hid_protocol = 1;
+u8 _hid_idle = 1;
+
+#define WEAK __attribute__ ((weak))
+
+int WEAK HID_GetInterface(u8* interfaceNum)
+{
+	interfaceNum[0] += 1;	// uses 1
+	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
+}
+
+int WEAK HID_GetDescriptor(int i)
+{
+	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
+}
+
+void WEAK HID_SendReport(u8 id, const void* data, int len)
+{
+	USB_Send(HID_TX, &id, 1);
+	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
+}
+
+bool WEAK HID_Setup(Setup& setup)
+{
+	u8 r = setup.bRequest;
+	u8 requestType = setup.bmRequestType;
+	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
+	{
+		if (HID_GET_REPORT == r)
+		{
+			//HID_GetReport();
+			return true;
+		}
+		if (HID_GET_PROTOCOL == r)
+		{
+			//Send8(_hid_protocol);	// TODO
+			return true;
+		}
+	}
+	
+	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
+	{
+		if (HID_SET_PROTOCOL == r)
+		{
+			_hid_protocol = setup.wValueL;
+			return true;
+		}
+
+		if (HID_SET_IDLE == r)
+		{
+			_hid_idle = setup.wValueL;
+			return true;
+		}
+	}
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+Mouse_::Mouse_(void) : _buttons(0)
+{
+}
+
+void Mouse_::begin(void) 
+{
+}
+
+void Mouse_::end(void) 
+{
+}
+
+void Mouse_::click(uint8_t b)
+{
+	_buttons = b;
+	move(0,0,0);
+	_buttons = 0;
+	move(0,0,0);
+}
+
+void Mouse_::move(signed char x, signed char y, signed char wheel)
+{
+	u8 m[4];
+	m[0] = _buttons;
+	m[1] = x;
+	m[2] = y;
+	m[3] = wheel;
+	HID_SendReport(1,m,4);
+}
+
+void Mouse_::buttons(uint8_t b)
+{
+	if (b != _buttons)
+	{
+		_buttons = b;
+		move(0,0,0);
+	}
+}
+
+void Mouse_::press(uint8_t b) 
+{
+	buttons(_buttons | b);
+}
+
+void Mouse_::release(uint8_t b)
+{
+	buttons(_buttons & ~b);
+}
+
+bool Mouse_::isPressed(uint8_t b)
+{
+	if ((b & _buttons) > 0) 
+		return true;
+	return false;
+}
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+Keyboard_::Keyboard_(void) 
+{
+}
+
+void Keyboard_::begin(void) 
+{
+}
+
+void Keyboard_::end(void) 
+{
+}
+
+void Keyboard_::sendReport(KeyReport* keys)
+{
+	HID_SendReport(2,keys,sizeof(KeyReport));
+}
+
+extern
+const uint8_t _asciimap[128] PROGMEM;
+
+#define SHIFT 0x80
+const uint8_t _asciimap[128] =
+{
+	0x00,             // NUL
+	0x00,             // SOH
+	0x00,             // STX
+	0x00,             // ETX
+	0x00,             // EOT
+	0x00,             // ENQ
+	0x00,             // ACK  
+	0x00,             // BEL
+	0x2a,			// BS	Backspace
+	0x2b,			// TAB	Tab
+	0x28,			// LF	Enter
+	0x00,             // VT 
+	0x00,             // FF 
+	0x00,             // CR 
+	0x00,             // SO 
+	0x00,             // SI 
+	0x00,             // DEL
+	0x00,             // DC1
+	0x00,             // DC2
+	0x00,             // DC3
+	0x00,             // DC4
+	0x00,             // NAK
+	0x00,             // SYN
+	0x00,             // ETB
+	0x00,             // CAN
+	0x00,             // EM 
+	0x00,             // SUB
+	0x00,             // ESC
+	0x00,             // FS 
+	0x00,             // GS 
+	0x00,             // RS 
+	0x00,             // US 
+
+	0x2c,		   //  ' '
+	0x1e|SHIFT,	   // !
+	0x34|SHIFT,	   // "
+	0x20|SHIFT,    // #
+	0x21|SHIFT,    // $
+	0x22|SHIFT,    // %
+	0x24|SHIFT,    // &
+	0x34,          // '
+	0x26|SHIFT,    // (
+	0x27|SHIFT,    // )
+	0x25|SHIFT,    // *
+	0x2e|SHIFT,    // +
+	0x36,          // ,
+	0x2d,          // -
+	0x37,          // .
+	0x38,          // /
+	0x27,          // 0
+	0x1e,          // 1
+	0x1f,          // 2
+	0x20,          // 3
+	0x21,          // 4
+	0x22,          // 5
+	0x23,          // 6
+	0x24,          // 7
+	0x25,          // 8
+	0x26,          // 9
+	0x33|SHIFT,      // :
+	0x33,          // ;
+	0x36|SHIFT,      // <
+	0x2e,          // =
+	0x37|SHIFT,      // >
+	0x38|SHIFT,      // ?
+	0x1f|SHIFT,      // @
+	0x04|SHIFT,      // A
+	0x05|SHIFT,      // B
+	0x06|SHIFT,      // C
+	0x07|SHIFT,      // D
+	0x08|SHIFT,      // E
+	0x09|SHIFT,      // F
+	0x0a|SHIFT,      // G
+	0x0b|SHIFT,      // H
+	0x0c|SHIFT,      // I
+	0x0d|SHIFT,      // J
+	0x0e|SHIFT,      // K
+	0x0f|SHIFT,      // L
+	0x10|SHIFT,      // M
+	0x11|SHIFT,      // N
+	0x12|SHIFT,      // O
+	0x13|SHIFT,      // P
+	0x14|SHIFT,      // Q
+	0x15|SHIFT,      // R
+	0x16|SHIFT,      // S
+	0x17|SHIFT,      // T
+	0x18|SHIFT,      // U
+	0x19|SHIFT,      // V
+	0x1a|SHIFT,      // W
+	0x1b|SHIFT,      // X
+	0x1c|SHIFT,      // Y
+	0x1d|SHIFT,      // Z
+	0x2f,          // [
+	0x31,          // bslash
+	0x30,          // ]
+	0x23|SHIFT,    // ^
+	0x2d|SHIFT,    // _
+	0x35,          // `
+	0x04,          // a
+	0x05,          // b
+	0x06,          // c
+	0x07,          // d
+	0x08,          // e
+	0x09,          // f
+	0x0a,          // g
+	0x0b,          // h
+	0x0c,          // i
+	0x0d,          // j
+	0x0e,          // k
+	0x0f,          // l
+	0x10,          // m
+	0x11,          // n
+	0x12,          // o
+	0x13,          // p
+	0x14,          // q
+	0x15,          // r
+	0x16,          // s
+	0x17,          // t
+	0x18,          // u
+	0x19,          // v
+	0x1a,          // w
+	0x1b,          // x
+	0x1c,          // y
+	0x1d,          // z
+	0x2f|SHIFT,    // 
+	0x31|SHIFT,    // |
+	0x30|SHIFT,    // }
+	0x35|SHIFT,    // ~
+	0				// DEL
+};
+
+uint8_t USBPutChar(uint8_t c);
+
+// press() adds the specified key (printing, non-printing, or modifier)
+// to the persistent key report and sends the report.  Because of the way 
+// USB HID works, the host acts like the key remains pressed until we 
+// call release(), releaseAll(), or otherwise clear the report and resend.
+size_t Keyboard_::press(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers |= (1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			setWriteError();
+			return 0;
+		}
+		if (k & 0x80) {						// it's a capital letter or other character reached with shift
+			_keyReport.modifiers |= 0x02;	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Add k to the key report only if it's not already present
+	// and if there is an empty slot.
+	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
+		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
+		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
+		
+		for (i=0; i<6; i++) {
+			if (_keyReport.keys[i] == 0x00) {
+				_keyReport.keys[i] = k;
+				break;
+			}
+		}
+		if (i == 6) {
+			setWriteError();
+			return 0;
+		}	
+	}
+	sendReport(&_keyReport);
+	return 1;
+}
+
+// release() takes the specified key out of the persistent key report and
+// sends the report.  This tells the OS the key is no longer pressed and that
+// it shouldn't be repeated any more.
+size_t Keyboard_::release(uint8_t k) 
+{
+	uint8_t i;
+	if (k >= 136) {			// it's a non-printing key (not a modifier)
+		k = k - 136;
+	} else if (k >= 128) {	// it's a modifier key
+		_keyReport.modifiers &= ~(1<<(k-128));
+		k = 0;
+	} else {				// it's a printing key
+		k = pgm_read_byte(_asciimap + k);
+		if (!k) {
+			return 0;
+		}
+		if (k & 0x80) {							// it's a capital letter or other character reached with shift
+			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
+			k &= 0x7F;
+		}
+	}
+	
+	// Test the key report to see if k is present.  Clear it if it exists.
+	// Check all positions in case the key is present more than once (which it shouldn't be)
+	for (i=0; i<6; i++) {
+		if (0 != k && _keyReport.keys[i] == k) {
+			_keyReport.keys[i] = 0x00;
+		}
+	}
+
+	sendReport(&_keyReport);
+	return 1;
+}
+
+void Keyboard_::releaseAll(void)
+{
+	_keyReport.keys[0] = 0;
+	_keyReport.keys[1] = 0;	
+	_keyReport.keys[2] = 0;
+	_keyReport.keys[3] = 0;	
+	_keyReport.keys[4] = 0;
+	_keyReport.keys[5] = 0;	
+	_keyReport.modifiers = 0;
+	sendReport(&_keyReport);
+}
+
+size_t Keyboard_::write(uint8_t c)
+{	
+	uint8_t p = press(c);		// Keydown
+	uint8_t r = release(c);		// Keyup
+	return (p);					// just return the result of press() since release() almost always returns 1
+}
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.cpp
new file mode 100644
index 0000000..f40ddee
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.cpp
@@ -0,0 +1,428 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "Arduino.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which head is the index of the location
+// to which to write the next incoming character and tail is the index of the
+// location from which to read.
+#if (RAMEND < 1000)
+  #define SERIAL_BUFFER_SIZE 16
+#else
+  #define SERIAL_BUFFER_SIZE 64
+#endif
+
+struct ring_buffer
+{
+  unsigned char buffer[SERIAL_BUFFER_SIZE];
+  volatile unsigned int head;
+  volatile unsigned int tail;
+};
+
+#if defined(USBCON)
+  ring_buffer rx_buffer = { { 0 }, 0, 0};
+  ring_buffer tx_buffer = { { 0 }, 0, 0};
+#endif
+#if defined(UBRRH) || defined(UBRR0H)
+  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR1H)
+  ring_buffer rx_buffer1  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer1  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR2H)
+  ring_buffer rx_buffer2  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer2  =  { { 0 }, 0, 0 };
+#endif
+#if defined(UBRR3H)
+  ring_buffer rx_buffer3  =  { { 0 }, 0, 0 };
+  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *buffer)
+{
+  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != buffer->tail) {
+    buffer->buffer[buffer->head] = c;
+    buffer->head = i;
+  }
+}
+
+#if !defined(USART0_RX_vect) && defined(USART1_RX_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(USART_RX_vect) && !defined(SIG_USART0_RECV) && \
+    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
+	!defined(SIG_UART_RECV)
+  #error "Don't know what the Data Received vector is called for the first UART"
+#else
+  void serialEvent() __attribute__((weak));
+  void serialEvent() {}
+  #define serialEvent_implemented
+#if defined(USART_RX_vect)
+  SIGNAL(USART_RX_vect)
+#elif defined(SIG_USART0_RECV)
+  SIGNAL(SIG_USART0_RECV)
+#elif defined(SIG_UART0_RECV)
+  SIGNAL(SIG_UART0_RECV)
+#elif defined(USART0_RX_vect)
+  SIGNAL(USART0_RX_vect)
+#elif defined(SIG_UART_RECV)
+  SIGNAL(SIG_UART_RECV)
+#endif
+  {
+  #if defined(UDR0)
+    unsigned char c  =  UDR0;
+  #elif defined(UDR)
+    unsigned char c  =  UDR;
+  #else
+    #error UDR not defined
+  #endif
+    store_char(c, &rx_buffer);
+  }
+#endif
+#endif
+
+#if defined(USART1_RX_vect)
+  void serialEvent1() __attribute__((weak));
+  void serialEvent1() {}
+  #define serialEvent1_implemented
+  SIGNAL(USART1_RX_vect)
+  {
+    unsigned char c = UDR1;
+    store_char(c, &rx_buffer1);
+  }
+#elif defined(SIG_USART1_RECV)
+  #error SIG_USART1_RECV
+#endif
+
+#if defined(USART2_RX_vect) && defined(UDR2)
+  void serialEvent2() __attribute__((weak));
+  void serialEvent2() {}
+  #define serialEvent2_implemented
+  SIGNAL(USART2_RX_vect)
+  {
+    unsigned char c = UDR2;
+    store_char(c, &rx_buffer2);
+  }
+#elif defined(SIG_USART2_RECV)
+  #error SIG_USART2_RECV
+#endif
+
+#if defined(USART3_RX_vect) && defined(UDR3)
+  void serialEvent3() __attribute__((weak));
+  void serialEvent3() {}
+  #define serialEvent3_implemented
+  SIGNAL(USART3_RX_vect)
+  {
+    unsigned char c = UDR3;
+    store_char(c, &rx_buffer3);
+  }
+#elif defined(SIG_USART3_RECV)
+  #error SIG_USART3_RECV
+#endif
+
+void serialEventRun(void)
+{
+#ifdef serialEvent_implemented
+  if (Serial.available()) serialEvent();
+#endif
+#ifdef serialEvent1_implemented
+  if (Serial1.available()) serialEvent1();
+#endif
+#ifdef serialEvent2_implemented
+  if (Serial2.available()) serialEvent2();
+#endif
+#ifdef serialEvent3_implemented
+  if (Serial3.available()) serialEvent3();
+#endif
+}
+
+
+#if !defined(USART0_UDRE_vect) && defined(USART1_UDRE_vect)
+// do nothing - on the 32u4 the first USART is USART1
+#else
+#if !defined(UART0_UDRE_vect) && !defined(UART_UDRE_vect) && !defined(USART0_UDRE_vect) && !defined(USART_UDRE_vect)
+  #error "Don't know what the Data Register Empty vector is called for the first UART"
+#else
+#if defined(UART0_UDRE_vect)
+ISR(UART0_UDRE_vect)
+#elif defined(UART_UDRE_vect)
+ISR(UART_UDRE_vect)
+#elif defined(USART0_UDRE_vect)
+ISR(USART0_UDRE_vect)
+#elif defined(USART_UDRE_vect)
+ISR(USART_UDRE_vect)
+#endif
+{
+  if (tx_buffer.head == tx_buffer.tail) {
+	// Buffer empty, so disable interrupts
+#if defined(UCSR0B)
+    cbi(UCSR0B, UDRIE0);
+#else
+    cbi(UCSRB, UDRIE);
+#endif
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
+    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+  #if defined(UDR0)
+    UDR0 = c;
+  #elif defined(UDR)
+    UDR = c;
+  #else
+    #error UDR not defined
+  #endif
+  }
+}
+#endif
+#endif
+
+#ifdef USART1_UDRE_vect
+ISR(USART1_UDRE_vect)
+{
+  if (tx_buffer1.head == tx_buffer1.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR1B, UDRIE1);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer1.buffer[tx_buffer1.tail];
+    tx_buffer1.tail = (tx_buffer1.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR1 = c;
+  }
+}
+#endif
+
+#ifdef USART2_UDRE_vect
+ISR(USART2_UDRE_vect)
+{
+  if (tx_buffer2.head == tx_buffer2.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR2B, UDRIE2);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer2.buffer[tx_buffer2.tail];
+    tx_buffer2.tail = (tx_buffer2.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR2 = c;
+  }
+}
+#endif
+
+#ifdef USART3_UDRE_vect
+ISR(USART3_UDRE_vect)
+{
+  if (tx_buffer3.head == tx_buffer3.tail) {
+	// Buffer empty, so disable interrupts
+    cbi(UCSR3B, UDRIE3);
+  }
+  else {
+    // There is more data in the output buffer. Send the next byte
+    unsigned char c = tx_buffer3.buffer[tx_buffer3.tail];
+    tx_buffer3.tail = (tx_buffer3.tail + 1) % SERIAL_BUFFER_SIZE;
+	
+    UDR3 = c;
+  }
+}
+#endif
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _tx_buffer = tx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udrie = udrie;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(unsigned long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+
+try_again:
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+  
+  if ((baud_setting > 4095) && use_u2x)
+  {
+    use_u2x = false;
+    goto try_again;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+  cbi(*_ucsrb, _udrie);
+}
+
+void HardwareSerial::end()
+{
+  // wait for transmission of outgoing data
+  while (_tx_buffer->head != _tx_buffer->tail)
+    ;
+
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+  cbi(*_ucsrb, _udrie);
+  
+  // clear any received data
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  while (_tx_buffer->head != _tx_buffer->tail)
+    ;
+}
+
+size_t HardwareSerial::write(uint8_t c)
+{
+  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
+	
+  // If the output buffer is full, there's nothing for it other than to 
+  // wait for the interrupt handler to empty it a bit
+  // ???: return 0 here instead?
+  while (i == _tx_buffer->tail)
+    ;
+	
+  _tx_buffer->buffer[_tx_buffer->head] = c;
+  _tx_buffer->head = i;
+	
+  sbi(*_ucsrb, _udrie);
+  
+  return 1;
+}
+
+HardwareSerial::operator bool() {
+	return true;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(UBRRH) && defined(UBRRL)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
+#elif defined(UBRR0H) && defined(UBRR0L)
+  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
+#elif defined(USBCON)
+  // do nothing - Serial object and buffers are initialized in CDC code
+#else
+  #error no serial port defined  (port 0)
+#endif
+
+#if defined(UBRR1H)
+  HardwareSerial Serial1(&rx_buffer1, &tx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1);
+#endif
+#if defined(UBRR2H)
+  HardwareSerial Serial2(&rx_buffer2, &tx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRIE2, U2X2);
+#endif
+#if defined(UBRR3H)
+  HardwareSerial Serial3(&rx_buffer3, &tx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRIE3, U2X3);
+#endif
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.h
new file mode 100644
index 0000000..bf4924c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/HardwareSerial.h
@@ -0,0 +1,81 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    ring_buffer *_tx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udrie;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x);
+    void begin(unsigned long);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    virtual size_t write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+    operator bool();
+};
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "USBAPI.h"
+//  extern HardwareSerial Serial_;  
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+extern void serialEventRun(void) __attribute__((weak));
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.cpp
new file mode 100644
index 0000000..fe3deb7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.cpp
@@ -0,0 +1,56 @@
+
+#include <Arduino.h>
+#include <IPAddress.h>
+
+IPAddress::IPAddress()
+{
+    memset(_address, 0, sizeof(_address));
+}
+
+IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
+{
+    _address[0] = first_octet;
+    _address[1] = second_octet;
+    _address[2] = third_octet;
+    _address[3] = fourth_octet;
+}
+
+IPAddress::IPAddress(uint32_t address)
+{
+    memcpy(_address, &address, sizeof(_address));
+}
+
+IPAddress::IPAddress(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+}
+
+IPAddress& IPAddress::operator=(const uint8_t *address)
+{
+    memcpy(_address, address, sizeof(_address));
+    return *this;
+}
+
+IPAddress& IPAddress::operator=(uint32_t address)
+{
+    memcpy(_address, (const uint8_t *)&address, sizeof(_address));
+    return *this;
+}
+
+bool IPAddress::operator==(const uint8_t* addr)
+{
+    return memcmp(addr, _address, sizeof(_address)) == 0;
+}
+
+size_t IPAddress::printTo(Print& p) const
+{
+    size_t n = 0;
+    for (int i =0; i < 3; i++)
+    {
+        n += p.print(_address[i], DEC);
+        n += p.print('.');
+    }
+    n += p.print(_address[3], DEC);
+    return n;
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.h
new file mode 100644
index 0000000..2585aec
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/IPAddress.h
@@ -0,0 +1,76 @@
+/*
+ *
+ * MIT License:
+ * Copyright (c) 2011 Adrian McEwen
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * adrianm@mcqn.com 1/1/2011
+ */
+
+#ifndef IPAddress_h
+#define IPAddress_h
+
+#include <Printable.h>
+
+// A class to make it easier to handle and pass around IP addresses
+
+class IPAddress : public Printable {
+private:
+    uint8_t _address[4];  // IPv4 address
+    // Access the raw byte array containing the address.  Because this returns a pointer
+    // to the internal structure rather than a copy of the address this function should only
+    // be used when you know that the usage of the returned uint8_t* will be transient and not
+    // stored.
+    uint8_t* raw_address() { return _address; };
+
+public:
+    // Constructors
+    IPAddress();
+    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
+    IPAddress(uint32_t address);
+    IPAddress(const uint8_t *address);
+
+    // Overloaded cast operator to allow IPAddress objects to be used where a pointer
+    // to a four-byte uint8_t array is expected
+    operator uint32_t() { return *((uint32_t*)_address); };
+    bool operator==(const IPAddress& addr) { return (*((uint32_t*)_address)) == (*((uint32_t*)addr._address)); };
+    bool operator==(const uint8_t* addr);
+
+    // Overloaded index operator to allow getting and setting individual octets of the address
+    uint8_t operator[](int index) const { return _address[index]; };
+    uint8_t& operator[](int index) { return _address[index]; };
+
+    // Overloaded copy operators to allow initialisation of IPAddress objects from other types
+    IPAddress& operator=(const uint8_t *address);
+    IPAddress& operator=(uint32_t address);
+
+    virtual size_t printTo(Print& p) const;
+
+    friend class EthernetClass;
+    friend class UDP;
+    friend class Client;
+    friend class Server;
+    friend class DhcpClass;
+    friend class DNSClient;
+};
+
+const IPAddress INADDR_NONE(0,0,0,0);
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Platform.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Platform.h
new file mode 100644
index 0000000..8b8f742
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Platform.h
@@ -0,0 +1,23 @@
+
+#ifndef __PLATFORM_H__
+#define __PLATFORM_H__
+
+#include <inttypes.h>
+#include <avr/pgmspace.h>
+#include <avr/eeprom.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned long u32;
+
+#include "Arduino.h"
+
+#if defined(USBCON)
+	#include "USBDesc.h"
+	#include "USBCore.h"
+	#include "USBAPI.h"
+#endif /* if defined(USBCON) */
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.cpp
new file mode 100644
index 0000000..e541a6c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.cpp
@@ -0,0 +1,263 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "Arduino.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+size_t Print::write(const uint8_t *buffer, size_t size)
+{
+  size_t n = 0;
+  while (size--) {
+    n += write(*buffer++);
+  }
+  return n;
+}
+
+size_t Print::print(const __FlashStringHelper *ifsh)
+{
+  const char PROGMEM *p = (const char PROGMEM *)ifsh;
+  size_t n = 0;
+  while (1) {
+    unsigned char c = pgm_read_byte(p++);
+    if (c == 0) break;
+    n += write(c);
+  }
+  return n;
+}
+
+size_t Print::print(const String &s)
+{
+  size_t n = 0;
+  for (uint16_t i = 0; i < s.length(); i++) {
+    n += write(s[i]);
+  }
+  return n;
+}
+
+size_t Print::print(const char str[])
+{
+  return write(str);
+}
+
+size_t Print::print(char c)
+{
+  return write(c);
+}
+
+size_t Print::print(unsigned char b, int base)
+{
+  return print((unsigned long) b, base);
+}
+
+size_t Print::print(int n, int base)
+{
+  return print((long) n, base);
+}
+
+size_t Print::print(unsigned int n, int base)
+{
+  return print((unsigned long) n, base);
+}
+
+size_t Print::print(long n, int base)
+{
+  if (base == 0) {
+    return write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      int t = print('-');
+      n = -n;
+      return printNumber(n, 10) + t;
+    }
+    return printNumber(n, 10);
+  } else {
+    return printNumber(n, base);
+  }
+}
+
+size_t Print::print(unsigned long n, int base)
+{
+  if (base == 0) return write(n);
+  else return printNumber(n, base);
+}
+
+size_t Print::print(double n, int digits)
+{
+  return printFloat(n, digits);
+}
+
+size_t Print::println(const __FlashStringHelper *ifsh)
+{
+  size_t n = print(ifsh);
+  n += println();
+  return n;
+}
+
+size_t Print::print(const Printable& x)
+{
+  return x.printTo(*this);
+}
+
+size_t Print::println(void)
+{
+  size_t n = print('\r');
+  n += print('\n');
+  return n;
+}
+
+size_t Print::println(const String &s)
+{
+  size_t n = print(s);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const char c[])
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(char c)
+{
+  size_t n = print(c);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned char b, int base)
+{
+  size_t n = print(b, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned int num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(unsigned long num, int base)
+{
+  size_t n = print(num, base);
+  n += println();
+  return n;
+}
+
+size_t Print::println(double num, int digits)
+{
+  size_t n = print(num, digits);
+  n += println();
+  return n;
+}
+
+size_t Print::println(const Printable& x)
+{
+  size_t n = print(x);
+  n += println();
+  return n;
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+size_t Print::printNumber(unsigned long n, uint8_t base) {
+  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
+  char *str = &buf[sizeof(buf) - 1];
+
+  *str = '\0';
+
+  // prevent crash if called with base == 1
+  if (base < 2) base = 10;
+
+  do {
+    unsigned long m = n;
+    n /= base;
+    char c = m - base * n;
+    *--str = c < 10 ? c + '0' : c + 'A' - 10;
+  } while(n);
+
+  return write(str);
+}
+
+size_t Print::printFloat(double number, uint8_t digits) 
+{ 
+  size_t n = 0;
+  
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     n += print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  n += print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0) {
+    n += print("."); 
+  }
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    n += print(toPrint);
+    remainder -= toPrint; 
+  } 
+  
+  return n;
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.h
new file mode 100644
index 0000000..1af6b72
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Print.h
@@ -0,0 +1,78 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+#include "Printable.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+
+class Print
+{
+  private:
+    int write_error;
+    size_t printNumber(unsigned long, uint8_t);
+    size_t printFloat(double, uint8_t);
+  protected:
+    void setWriteError(int err = 1) { write_error = err; }
+  public:
+    Print() : write_error(0) {}
+  
+    int getWriteError() { return write_error; }
+    void clearWriteError() { setWriteError(0); }
+  
+    virtual size_t write(uint8_t) = 0;
+    size_t write(const char *str) { return write((const uint8_t *)str, strlen(str)); }
+    virtual size_t write(const uint8_t *buffer, size_t size);
+    
+    size_t print(const __FlashStringHelper *);
+    size_t print(const String &);
+    size_t print(const char[]);
+    size_t print(char);
+    size_t print(unsigned char, int = DEC);
+    size_t print(int, int = DEC);
+    size_t print(unsigned int, int = DEC);
+    size_t print(long, int = DEC);
+    size_t print(unsigned long, int = DEC);
+    size_t print(double, int = 2);
+    size_t print(const Printable&);
+
+    size_t println(const __FlashStringHelper *);
+    size_t println(const String &s);
+    size_t println(const char[]);
+    size_t println(char);
+    size_t println(unsigned char, int = DEC);
+    size_t println(int, int = DEC);
+    size_t println(unsigned int, int = DEC);
+    size_t println(long, int = DEC);
+    size_t println(unsigned long, int = DEC);
+    size_t println(double, int = 2);
+    size_t println(const Printable&);
+    size_t println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Printable.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Printable.h
new file mode 100644
index 0000000..d03c9af
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Printable.h
@@ -0,0 +1,40 @@
+/*
+  Printable.h - Interface class that allows printing of complex types
+  Copyright (c) 2011 Adrian McEwen.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Printable_h
+#define Printable_h
+
+#include <new.h>
+
+class Print;
+
+/** The Printable class provides a way for new classes to allow themselves to be printed.
+    By deriving from Printable and implementing the printTo method, it will then be possible
+    for users to print out instances of this class by passing them into the usual
+    Print::print and Print::println methods.
+*/
+
+class Printable
+{
+  public:
+    virtual size_t printTo(Print& p) const = 0;
+};
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Server.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Server.h
new file mode 100644
index 0000000..9674c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Server.h
@@ -0,0 +1,9 @@
+#ifndef server_h
+#define server_h
+
+class Server : public Print {
+public:
+  virtual void begin() =0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.cpp
new file mode 100644
index 0000000..aafb7fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.cpp
@@ -0,0 +1,270 @@
+/*
+ Stream.cpp - adds parsing methods to Stream class
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Created July 2011
+ parsing functions based on TextFinder library by Michael Margolis
+ */
+
+#include "Arduino.h"
+#include "Stream.h"
+
+#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
+#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field
+
+// private method to read stream with timeout
+int Stream::timedRead()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = read();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// private method to peek stream with timeout
+int Stream::timedPeek()
+{
+  int c;
+  _startMillis = millis();
+  do {
+    c = peek();
+    if (c >= 0) return c;
+  } while(millis() - _startMillis < _timeout);
+  return -1;     // -1 indicates timeout
+}
+
+// returns peek of the next digit in the stream or -1 if timeout
+// discards non-numeric characters
+int Stream::peekNextDigit()
+{
+  int c;
+  while (1) {
+    c = timedPeek();
+    if (c < 0) return c;  // timeout
+    if (c == '-') return c;
+    if (c >= '0' && c <= '9') return c;
+    read();  // discard non-numeric
+  }
+}
+
+// Public Methods
+//////////////////////////////////////////////////////////////
+
+void Stream::setTimeout(unsigned long timeout)  // sets the maximum number of milliseconds to wait
+{
+  _timeout = timeout;
+}
+
+ // find returns true if the target string is found
+bool  Stream::find(char *target)
+{
+  return findUntil(target, NULL);
+}
+
+// reads data from the stream until the target string of given length is found
+// returns true if target string is found, false if timed out
+bool Stream::find(char *target, size_t length)
+{
+  return findUntil(target, length, NULL, 0);
+}
+
+// as find but search ends if the terminator string is found
+bool  Stream::findUntil(char *target, char *terminator)
+{
+  return findUntil(target, strlen(target), terminator, strlen(terminator));
+}
+
+// reads data from the stream until the target string of the given length is found
+// search terminated if the terminator string is found
+// returns true if target string is found, false if terminated or timed out
+bool Stream::findUntil(char *target, size_t targetLen, char *terminator, size_t termLen)
+{
+  size_t index = 0;  // maximum target string length is 64k bytes!
+  size_t termIndex = 0;
+  int c;
+  
+  if( *target == 0)
+    return true;   // return true if target is a null string
+  while( (c = timedRead()) > 0){
+    
+    if(c != target[index])
+      index = 0; // reset index if any char does not match
+    
+    if( c == target[index]){
+      //////Serial.print("found "); Serial.write(c); Serial.print("index now"); Serial.println(index+1);
+      if(++index >= targetLen){ // return true if all chars in the target match
+        return true;
+      }
+    }
+    
+    if(termLen > 0 && c == terminator[termIndex]){
+      if(++termIndex >= termLen)
+        return false;       // return false if terminate string found before target string
+    }
+    else
+      termIndex = 0;
+  }
+  return false;
+}
+
+
+// returns the first valid (long) integer value from the current position.
+// initial characters that are not digits (or the minus sign) are skipped
+// function is terminated by the first character that is not a digit.
+long Stream::parseInt()
+{
+  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
+}
+
+// as above but a given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+long Stream::parseInt(char skipChar)
+{
+  boolean isNegative = false;
+  long value = 0;
+  int c;
+
+  c = peekNextDigit();
+  // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore this charactor
+    else if(c == '-')
+      isNegative = true;
+    else if(c >= '0' && c <= '9')        // is c a digit?
+      value = value * 10 + c - '0';
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9') || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  return value;
+}
+
+
+// as parseInt but returns a floating point value
+float Stream::parseFloat()
+{
+  return parseFloat(NO_SKIP_CHAR);
+}
+
+// as above but the given skipChar is ignored
+// this allows format characters (typically commas) in values to be ignored
+float Stream::parseFloat(char skipChar){
+  boolean isNegative = false;
+  boolean isFraction = false;
+  long value = 0;
+  char c;
+  float fraction = 1.0;
+
+  c = peekNextDigit();
+    // ignore non numeric leading characters
+  if(c < 0)
+    return 0; // zero returned if timeout
+
+  do{
+    if(c == skipChar)
+      ; // ignore
+    else if(c == '-')
+      isNegative = true;
+    else if (c == '.')
+      isFraction = true;
+    else if(c >= '0' && c <= '9')  {      // is c a digit?
+      value = value * 10 + c - '0';
+      if(isFraction)
+         fraction *= 0.1;
+    }
+    read();  // consume the character we got with peek
+    c = timedPeek();
+  }
+  while( (c >= '0' && c <= '9')  || c == '.' || c == skipChar );
+
+  if(isNegative)
+    value = -value;
+  if(isFraction)
+    return value * fraction;
+  else
+    return value;
+}
+
+// read characters from stream into buffer
+// terminates if length characters have been read, or timeout (see setTimeout)
+// returns the number of characters placed in the buffer
+// the buffer is NOT null terminated.
+//
+size_t Stream::readBytes(char *buffer, size_t length)
+{
+  size_t count = 0;
+  while (count < length) {
+    int c = timedRead();
+    if (c < 0) break;
+    *buffer++ = (char)c;
+    count++;
+  }
+  return count;
+}
+
+
+// as readBytes with terminator character
+// terminates if length characters have been read, timeout, or if the terminator character  detected
+// returns the number of characters placed in the buffer (0 means no valid data found)
+
+size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
+{
+  if (length < 1) return 0;
+  size_t index = 0;
+  while (index < length) {
+    int c = timedRead();
+    if (c < 0 || c == terminator) break;
+    *buffer++ = (char)c;
+    index++;
+  }
+  return index; // return number of characters, not including null terminator
+}
+
+String Stream::readString()
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
+String Stream::readStringUntil(char terminator)
+{
+  String ret;
+  int c = timedRead();
+  while (c >= 0 && c != terminator)
+  {
+    ret += (char)c;
+    c = timedRead();
+  }
+  return ret;
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.h
new file mode 100644
index 0000000..58bbf75
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Stream.h
@@ -0,0 +1,96 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  parsing functions based on TextFinder library by Michael Margolis
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// compatability macros for testing
+/*
+#define   getInt()            parseInt()
+#define   getInt(skipChar)    parseInt(skipchar)
+#define   getFloat()          parseFloat()
+#define   getFloat(skipChar)  parseFloat(skipChar)
+#define   getString( pre_string, post_string, buffer, length)
+readBytesBetween( pre_string, terminator, buffer, length)
+*/
+
+class Stream : public Print
+{
+  private:
+    unsigned long _timeout;      // number of milliseconds to wait for the next char before aborting timed read
+    unsigned long _startMillis;  // used for timeout measurement
+    int timedRead();    // private method to read stream with timeout
+    int timedPeek();    // private method to peek stream with timeout
+    int peekNextDigit(); // returns the next numeric digit in the stream or -1 if timeout
+
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+
+    Stream() {_timeout=1000;}
+
+// parsing methods
+
+  void setTimeout(unsigned long timeout);  // sets maximum milliseconds to wait for stream data, default is 1 second
+
+  bool find(char *target);   // reads data from the stream until the target string is found
+  // returns true if target string is found, false if timed out (see setTimeout)
+
+  bool find(char *target, size_t length);   // reads data from the stream until the target string of given length is found
+  // returns true if target string is found, false if timed out
+
+  bool findUntil(char *target, char *terminator);   // as find but search ends if the terminator string is found
+
+  bool findUntil(char *target, size_t targetLen, char *terminate, size_t termLen);   // as above but search ends if the terminate string is found
+
+
+  long parseInt(); // returns the first valid (long) integer value from the current position.
+  // initial characters that are not digits (or the minus sign) are skipped
+  // integer is terminated by the first character that is not a digit.
+
+  float parseFloat();               // float version of parseInt
+
+  size_t readBytes( char *buffer, size_t length); // read chars from stream into buffer
+  // terminates if length characters have been read or timeout (see setTimeout)
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  size_t readBytesUntil( char terminator, char *buffer, size_t length); // as readBytes with terminator character
+  // terminates if length characters have been read, timeout, or if the terminator character  detected
+  // returns the number of characters placed in the buffer (0 means no valid data found)
+
+  // Arduino String functions to be added here
+  String readString();
+  String readStringUntil(char terminator);
+
+  protected:
+  long parseInt(char skipChar); // as above but the given skipChar is ignored
+  // as above but the given skipChar is ignored
+  // this allows format characters (typically commas) in values to be ignored
+
+  float parseFloat(char skipChar);  // as above but the given skipChar is ignored
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Tone.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Tone.cpp
new file mode 100644
index 0000000..20eed3f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Tone.cpp
@@ -0,0 +1,601 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "Arduino.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+// MLS: This does not make sense, the 3 options are the same
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBAPI.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBAPI.h
new file mode 100644
index 0000000..d5abdb6
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBAPI.h
@@ -0,0 +1,195 @@
+
+
+#ifndef __USBAPI__
+#define __USBAPI__
+
+#if defined(USBCON)
+
+//================================================================================
+//================================================================================
+//	USB
+
+class USBDevice_
+{
+public:
+	USBDevice_();
+	bool configured();
+
+	void attach();
+	void detach();	// Serial port goes down too...
+	void poll();
+};
+extern USBDevice_ USBDevice;
+
+//================================================================================
+//================================================================================
+//	Serial over CDC (Serial1 is the physical port)
+
+class Serial_ : public Stream
+{
+private:
+	ring_buffer *_cdc_rx_buffer;
+public:
+	void begin(uint16_t baud_count);
+	void end(void);
+
+	virtual int available(void);
+	virtual void accept(void);
+	virtual int peek(void);
+	virtual int read(void);
+	virtual void flush(void);
+	virtual size_t write(uint8_t);
+	operator bool();
+};
+extern Serial_ Serial;
+
+//================================================================================
+//================================================================================
+//	Mouse
+
+#define MOUSE_LEFT 1
+#define MOUSE_RIGHT 2
+#define MOUSE_MIDDLE 4
+#define MOUSE_ALL (MOUSE_LEFT | MOUSE_RIGHT | MOUSE_MIDDLE)
+
+class Mouse_
+{
+private:
+	uint8_t _buttons;
+	void buttons(uint8_t b);
+public:
+	Mouse_(void);
+	void begin(void);
+	void end(void);
+	void click(uint8_t b = MOUSE_LEFT);
+	void move(signed char x, signed char y, signed char wheel = 0);	
+	void press(uint8_t b = MOUSE_LEFT);		// press LEFT by default
+	void release(uint8_t b = MOUSE_LEFT);	// release LEFT by default
+	bool isPressed(uint8_t b = MOUSE_LEFT);	// check LEFT by default
+};
+extern Mouse_ Mouse;
+
+//================================================================================
+//================================================================================
+//	Keyboard
+
+#define KEY_LEFT_CTRL		0x80
+#define KEY_LEFT_SHIFT		0x81
+#define KEY_LEFT_ALT		0x82
+#define KEY_LEFT_GUI		0x83
+#define KEY_RIGHT_CTRL		0x84
+#define KEY_RIGHT_SHIFT		0x85
+#define KEY_RIGHT_ALT		0x86
+#define KEY_RIGHT_GUI		0x87
+
+#define KEY_UP_ARROW		0xDA
+#define KEY_DOWN_ARROW		0xD9
+#define KEY_LEFT_ARROW		0xD8
+#define KEY_RIGHT_ARROW		0xD7
+#define KEY_BACKSPACE		0xB2
+#define KEY_TAB				0xB3
+#define KEY_RETURN			0xB0
+#define KEY_ESC				0xB1
+#define KEY_INSERT			0xD1
+#define KEY_DELETE			0xD4
+#define KEY_PAGE_UP			0xD3
+#define KEY_PAGE_DOWN		0xD6
+#define KEY_HOME			0xD2
+#define KEY_END				0xD5
+#define KEY_CAPS_LOCK		0xC1
+#define KEY_F1				0xC2
+#define KEY_F2				0xC3
+#define KEY_F3				0xC4
+#define KEY_F4				0xC5
+#define KEY_F5				0xC6
+#define KEY_F6				0xC7
+#define KEY_F7				0xC8
+#define KEY_F8				0xC9
+#define KEY_F9				0xCA
+#define KEY_F10				0xCB
+#define KEY_F11				0xCC
+#define KEY_F12				0xCD
+
+//	Low level key report: up to 6 keys and shift, ctrl etc at once
+typedef struct
+{
+	uint8_t modifiers;
+	uint8_t reserved;
+	uint8_t keys[6];
+} KeyReport;
+
+class Keyboard_ : public Print
+{
+private:
+	KeyReport _keyReport;
+	void sendReport(KeyReport* keys);
+public:
+	Keyboard_(void);
+	void begin(void);
+	void end(void);
+	virtual size_t write(uint8_t k);
+	virtual size_t press(uint8_t k);
+	virtual size_t release(uint8_t k);
+	virtual void releaseAll(void);
+};
+extern Keyboard_ Keyboard;
+
+//================================================================================
+//================================================================================
+//	Low level API
+
+typedef struct
+{
+	uint8_t bmRequestType;
+	uint8_t bRequest;
+	uint8_t wValueL;
+	uint8_t wValueH;
+	uint16_t wIndex;
+	uint16_t wLength;
+} Setup;
+
+//================================================================================
+//================================================================================
+//	HID 'Driver'
+
+int		HID_GetInterface(uint8_t* interfaceNum);
+int		HID_GetDescriptor(int i);
+bool	HID_Setup(Setup& setup);
+void	HID_SendReport(uint8_t id, const void* data, int len);
+
+//================================================================================
+//================================================================================
+//	MSC 'Driver'
+
+int		MSC_GetInterface(uint8_t* interfaceNum);
+int		MSC_GetDescriptor(int i);
+bool	MSC_Setup(Setup& setup);
+bool	MSC_Data(uint8_t rx,uint8_t tx);
+
+//================================================================================
+//================================================================================
+//	CSC 'Driver'
+
+int		CDC_GetInterface(uint8_t* interfaceNum);
+int		CDC_GetDescriptor(int i);
+bool	CDC_Setup(Setup& setup);
+
+//================================================================================
+//================================================================================
+
+#define TRANSFER_PGM		0x80
+#define TRANSFER_RELEASE	0x40
+#define TRANSFER_ZERO		0x20
+
+int USB_SendControl(uint8_t flags, const void* d, int len);
+int USB_RecvControl(void* d, int len);
+
+uint8_t	USB_Available(uint8_t ep);
+int USB_Send(uint8_t ep, const void* data, int len);	// blocking
+int USB_Recv(uint8_t ep, void* data, int len);		// non-blocking
+int USB_Recv(uint8_t ep);							// non-blocking
+void USB_Flush(uint8_t ep);
+
+#endif
+
+#endif /* if defined(USBCON) */
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.cpp
new file mode 100644
index 0000000..545c88a
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.cpp
@@ -0,0 +1,670 @@
+
+
+/* Copyright (c) 2010, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#include "Platform.h"
+#include "USBAPI.h"
+#include "USBDesc.h"
+
+#if defined(USBCON)
+
+#define EP_TYPE_CONTROL				0x00
+#define EP_TYPE_BULK_IN				0x81
+#define EP_TYPE_BULK_OUT			0x80
+#define EP_TYPE_INTERRUPT_IN		0xC1
+#define EP_TYPE_INTERRUPT_OUT		0xC0
+#define EP_TYPE_ISOCHRONOUS_IN		0x41
+#define EP_TYPE_ISOCHRONOUS_OUT		0x40
+
+/** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse type */
+#define TX_RX_LED_PULSE_MS 100
+volatile u8 TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
+volatile u8 RxLEDPulse; /**< Milliseconds remaining for data Rx LED pulse */
+
+//==================================================================
+//==================================================================
+
+extern const u16 STRING_LANGUAGE[] PROGMEM;
+extern const u16 STRING_IPRODUCT[] PROGMEM;
+extern const u16 STRING_IMANUFACTURER[] PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptor PROGMEM;
+extern const DeviceDescriptor USB_DeviceDescriptorA PROGMEM;
+
+const u16 STRING_LANGUAGE[2] = {
+	(3<<8) | (2+2),
+	0x0409	// English
+};
+
+const u16 STRING_IPRODUCT[17] = {
+	(3<<8) | (2+2*16),
+	'B','r','a','i','n','w','a','v','e',' ',' ',' ',' ',' ',' ',' '
+};
+
+const u16 STRING_IMANUFACTURER[12] = {
+	(3<<8) | (2+2*11),
+	'M','e','t','r','i','x',' ',' ',' ',' ',' '
+};
+
+#ifdef CDC_ENABLED
+#define DEVICE_CLASS 0x02
+#else
+#define DEVICE_CLASS 0x00
+#endif
+
+//	DEVICE DESCRIPTOR
+const DeviceDescriptor USB_DeviceDescriptor =
+	D_DEVICE(0x00,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+const DeviceDescriptor USB_DeviceDescriptorA =
+	D_DEVICE(DEVICE_CLASS,0x00,0x00,64,USB_VID,USB_PID,0x100,IMANUFACTURER,IPRODUCT,0,1);
+
+//==================================================================
+//==================================================================
+
+volatile u8 _usbConfiguration = 0;
+
+static inline void WaitIN(void)
+{
+	while (!(UEINTX & (1<<TXINI)));
+}
+
+static inline void ClearIN(void)
+{
+	UEINTX = ~(1<<TXINI);
+}
+
+static inline void WaitOUT(void)
+{
+	while (!(UEINTX & (1<<RXOUTI)))
+		;
+}
+
+static inline u8 WaitForINOrOUT()
+{
+	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
+		;
+	return (UEINTX & (1<<RXOUTI)) == 0;
+}
+
+static inline void ClearOUT(void)
+{
+	UEINTX = ~(1<<RXOUTI);
+}
+
+void Recv(volatile u8* data, u8 count)
+{
+	while (count--)
+		*data++ = UEDATX;
+	
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;	
+}
+
+static inline u8 Recv8()
+{
+	RXLED1;					// light the RX LED
+	RxLEDPulse = TX_RX_LED_PULSE_MS;
+
+	return UEDATX;	
+}
+
+static inline void Send8(u8 d)
+{
+	UEDATX = d;
+}
+
+static inline void SetEP(u8 ep)
+{
+	UENUM = ep;
+}
+
+static inline u8 FifoByteCount()
+{
+	return UEBCLX;
+}
+
+static inline u8 ReceivedSetupInt()
+{
+	return UEINTX & (1<<RXSTPI);
+}
+
+static inline void ClearSetupInt()
+{
+	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
+}
+
+static inline void Stall()
+{
+	UECONX = (1<<STALLRQ) | (1<<EPEN);
+}
+
+static inline u8 ReadWriteAllowed()
+{
+	return UEINTX & (1<<RWAL);
+}
+
+static inline u8 Stalled()
+{
+	return UEINTX & (1<<STALLEDI);
+}
+
+static inline u8 FifoFree()
+{
+	return UEINTX & (1<<FIFOCON);
+}
+
+static inline void ReleaseRX()
+{
+	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
+}
+
+static inline void ReleaseTX()
+{
+	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
+}
+
+static inline u8 FrameNumber()
+{
+	return UDFNUML;
+}
+
+//==================================================================
+//==================================================================
+
+u8 USBGetConfiguration(void)
+{
+	return _usbConfiguration;
+}
+
+#define USB_RECV_TIMEOUT
+class LockEP
+{
+	u8 _sreg;
+public:
+	LockEP(u8 ep) : _sreg(SREG)
+	{
+		cli();
+		SetEP(ep & 7);
+	}
+	~LockEP()
+	{
+		SREG = _sreg;
+	}
+};
+
+//	Number of bytes, assumes a rx endpoint
+u8 USB_Available(u8 ep)
+{
+	LockEP lock(ep);
+	return FifoByteCount();
+}
+
+//	Non Blocking receive
+//	Return number of bytes read
+int USB_Recv(u8 ep, void* d, int len)
+{
+	if (!_usbConfiguration || len < 0)
+		return -1;
+	
+	LockEP lock(ep);
+	u8 n = FifoByteCount();
+	len = min(n,len);
+	n = len;
+	u8* dst = (u8*)d;
+	while (n--)
+		*dst++ = Recv8();
+	if (len && !FifoByteCount())	// release empty buffer
+		ReleaseRX();
+	
+	return len;
+}
+
+//	Recv 1 byte if ready
+int USB_Recv(u8 ep)
+{
+	u8 c;
+	if (USB_Recv(ep,&c,1) != 1)
+		return -1;
+	return c;
+}
+
+//	Space in send EP
+u8 USB_SendSpace(u8 ep)
+{
+	LockEP lock(ep);
+	if (!ReadWriteAllowed())
+		return 0;
+	return 64 - FifoByteCount();
+}
+
+//	Blocking Send of data to an endpoint
+int USB_Send(u8 ep, const void* d, int len)
+{
+	if (!_usbConfiguration)
+		return -1;
+
+	int r = len;
+	const u8* data = (const u8*)d;
+	u8 zero = ep & TRANSFER_ZERO;
+	u8 timeout = 250;		// 250ms timeout on send? TODO
+	while (len)
+	{
+		u8 n = USB_SendSpace(ep);
+		if (n == 0)
+		{
+			if (!(--timeout))
+				return -1;
+			delay(1);
+			continue;
+		}
+
+		if (n > len)
+			n = len;
+		len -= n;
+		{
+			LockEP lock(ep);
+			if (ep & TRANSFER_ZERO)
+			{
+				while (n--)
+					Send8(0);
+			}
+			else if (ep & TRANSFER_PGM)
+			{
+				while (n--)
+					Send8(pgm_read_byte(data++));
+			}
+			else
+			{
+				while (n--)
+					Send8(*data++);
+			}
+			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
+				ReleaseTX();
+		}
+	}
+	TXLED1;					// light the TX LED
+	TxLEDPulse = TX_RX_LED_PULSE_MS;
+	return r;
+}
+
+extern const u8 _initEndpoints[] PROGMEM;
+const u8 _initEndpoints[] = 
+{
+	0,
+	
+#ifdef CDC_ENABLED
+	EP_TYPE_INTERRUPT_IN,		// CDC_ENDPOINT_ACM
+	EP_TYPE_BULK_OUT,			// CDC_ENDPOINT_OUT
+	EP_TYPE_BULK_IN,			// CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+	EP_TYPE_INTERRUPT_IN		// HID_ENDPOINT_INT
+#endif
+};
+
+#define EP_SINGLE_64 0x32	// EP0
+#define EP_DOUBLE_64 0x36	// Other endpoints
+
+static
+void InitEP(u8 index, u8 type, u8 size)
+{
+	UENUM = index;
+	UECONX = 1;
+	UECFG0X = type;
+	UECFG1X = size;
+}
+
+static
+void InitEndpoints()
+{
+	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
+	{
+		UENUM = i;
+		UECONX = 1;
+		UECFG0X = pgm_read_byte(_initEndpoints+i);
+		UECFG1X = EP_DOUBLE_64;
+	}
+	UERST = 0x7E;	// And reset them
+	UERST = 0;
+}
+
+//	Handle CLASS_INTERFACE requests
+static
+bool ClassInterfaceRequest(Setup& setup)
+{
+	u8 i = setup.wIndex;
+
+#ifdef CDC_ENABLED
+	if (CDC_ACM_INTERFACE == i)
+		return CDC_Setup(setup);
+#endif
+
+#ifdef HID_ENABLED
+	if (HID_INTERFACE == i)
+		return HID_Setup(setup);
+#endif
+	return false;
+}
+
+int _cmark;
+int _cend;
+void InitControl(int end)
+{
+	SetEP(0);
+	_cmark = 0;
+	_cend = end;
+}
+
+static
+bool SendControl(u8 d)
+{
+	if (_cmark < _cend)
+	{
+		if (!WaitForINOrOUT())
+			return false;
+		Send8(d);
+		if (!((_cmark + 1) & 0x3F))
+			ClearIN();	// Fifo is full, release this packet
+	}
+	_cmark++;
+	return true;
+};
+
+//	Clipped by _cmark/_cend
+int USB_SendControl(u8 flags, const void* d, int len)
+{
+	int sent = len;
+	const u8* data = (const u8*)d;
+	bool pgm = flags & TRANSFER_PGM;
+	while (len--)
+	{
+		u8 c = pgm ? pgm_read_byte(data++) : *data++;
+		if (!SendControl(c))
+			return -1;
+	}
+	return sent;
+}
+
+//	Does not timeout or cross fifo boundaries
+//	Will only work for transfers <= 64 bytes
+//	TODO
+int USB_RecvControl(void* d, int len)
+{
+	WaitOUT();
+	Recv((u8*)d,len);
+	ClearOUT();
+	return len;
+}
+
+int SendInterfaces()
+{
+	int total = 0;
+	u8 interfaces = 0;
+
+#ifdef CDC_ENABLED
+	total = CDC_GetInterface(&interfaces);
+#endif
+
+#ifdef HID_ENABLED
+	total += HID_GetInterface(&interfaces);
+#endif
+
+	return interfaces;
+}
+
+//	Construct a dynamic configuration descriptor
+//	This really needs dynamic endpoint allocation etc
+//	TODO
+static
+bool SendConfiguration(int maxlen)
+{
+	//	Count and measure interfaces
+	InitControl(0);	
+	int interfaces = SendInterfaces();
+	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
+
+	//	Now send them
+	InitControl(maxlen);
+	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
+	SendInterfaces();
+	return true;
+}
+
+u8 _cdcComposite = 0;
+
+static
+bool SendDescriptor(Setup& setup)
+{
+	u8 t = setup.wValueH;
+	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
+		return SendConfiguration(setup.wLength);
+
+	InitControl(setup.wLength);
+#ifdef HID_ENABLED
+	if (HID_REPORT_DESCRIPTOR_TYPE == t)
+		return HID_GetDescriptor(t);
+#endif
+
+	u8 desc_length = 0;
+	const u8* desc_addr = 0;
+	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wLength == 8)
+			_cdcComposite = 1;
+		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
+	}
+	else if (USB_STRING_DESCRIPTOR_TYPE == t)
+	{
+		if (setup.wValueL == 0)
+			desc_addr = (const u8*)&STRING_LANGUAGE;
+		else if (setup.wValueL == IPRODUCT) 
+			desc_addr = (const u8*)&STRING_IPRODUCT;
+		else if (setup.wValueL == IMANUFACTURER)
+			desc_addr = (const u8*)&STRING_IMANUFACTURER;
+		else
+			return false;
+	}
+
+	if (desc_addr == 0)
+		return false;
+	if (desc_length == 0)
+		desc_length = pgm_read_byte(desc_addr);
+
+	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
+	return true;
+}
+
+//	Endpoint 0 interrupt
+ISR(USB_COM_vect)
+{
+    SetEP(0);
+	if (!ReceivedSetupInt())
+		return;
+
+	Setup setup;
+	Recv((u8*)&setup,8);
+	ClearSetupInt();
+
+	u8 requestType = setup.bmRequestType;
+	if (requestType & REQUEST_DEVICETOHOST)
+		WaitIN();
+	else
+		ClearIN();
+
+    bool ok = true;
+	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
+	{
+		//	Standard Requests
+		u8 r = setup.bRequest;
+		if (GET_STATUS == r)
+		{
+			Send8(0);		// TODO
+			Send8(0);
+		}
+		else if (CLEAR_FEATURE == r)
+		{
+		}
+		else if (SET_FEATURE == r)
+		{
+		}
+		else if (SET_ADDRESS == r)
+		{
+			WaitIN();
+			UDADDR = setup.wValueL | (1<<ADDEN);
+		}
+		else if (GET_DESCRIPTOR == r)
+		{
+			ok = SendDescriptor(setup);
+		}
+		else if (SET_DESCRIPTOR == r)
+		{
+			ok = false;
+		}
+		else if (GET_CONFIGURATION == r)
+		{
+			Send8(1);
+		}
+		else if (SET_CONFIGURATION == r)
+		{
+			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
+			{
+				InitEndpoints();
+				_usbConfiguration = setup.wValueL;
+			} else
+				ok = false;
+		}
+		else if (GET_INTERFACE == r)
+		{
+		}
+		else if (SET_INTERFACE == r)
+		{
+		}
+	}
+	else
+	{
+		InitControl(setup.wLength);		//	Max length of transfer
+		ok = ClassInterfaceRequest(setup);
+	}
+
+	if (ok)
+		ClearIN();
+	else
+	{
+		Stall();
+	}
+}
+
+void USB_Flush(u8 ep)
+{
+	SetEP(ep);
+	if (FifoByteCount())
+		ReleaseTX();
+}
+
+//	General interrupt
+ISR(USB_GEN_vect)
+{
+	u8 udint = UDINT;
+	UDINT = 0;
+
+	//	End of Reset
+	if (udint & (1<<EORSTI))
+	{
+		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
+		_usbConfiguration = 0;			// not configured yet
+		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
+	}
+
+	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
+	if (udint & (1<<SOFI))
+	{
+#ifdef CDC_ENABLED
+		USB_Flush(CDC_TX);				// Send a tx frame if found
+		while (USB_Available(CDC_RX))	// Handle received bytes (if any)
+			Serial.accept();
+#endif
+		
+		// check whether the one-shot period has elapsed.  if so, turn off the LED
+		if (TxLEDPulse && !(--TxLEDPulse))
+			TXLED0;
+		if (RxLEDPulse && !(--RxLEDPulse))
+			RXLED0;
+	}
+}
+
+//	VBUS or counting frames
+//	Any frame counting?
+u8 USBConnected()
+{
+	u8 f = UDFNUML;
+	delay(3);
+	return f != UDFNUML;
+}
+
+//=======================================================================
+//=======================================================================
+
+USBDevice_ USBDevice;
+
+USBDevice_::USBDevice_()
+{
+}
+
+void USBDevice_::attach()
+{
+	_usbConfiguration = 0;
+	UHWCON = 0x01;						// power internal reg
+	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
+#if defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__)
+	PLLCSR = 0x1A;						// Need 16 MHz xtal
+#elif defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__)
+	PLLCSR = 0x16;						// Need 16 MHz xtal
+#else
+	PLLCSR = 0x12;						// Need 16 MHz xtal
+#endif
+	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
+		;
+
+	// Some tests on specific versions of macosx (10.7.3), reported some
+	// strange behaviuors when the board is reset using the serial
+	// port touch at 1200 bps. This delay fixes this behaviour.
+	delay(1);
+
+	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
+	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
+	UDCON = 0;							// enable attach resistor
+	
+	TX_RX_LED_INIT;
+}
+
+void USBDevice_::detach()
+{
+}
+
+//	Check for interrupts
+//	TODO: VBUS detection
+bool USBDevice_::configured()
+{
+	return _usbConfiguration;
+}
+
+void USBDevice_::poll()
+{
+}
+
+#endif /* if defined(USBCON) */
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.h
new file mode 100644
index 0000000..5392815
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBCore.h
@@ -0,0 +1,307 @@
+
+// Copyright (c) 2010, Peter Barrett 
+/*
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+**  
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#ifndef __USBCORE_H__
+#define __USBCORE_H__
+
+#define USB_VID 0x16D0
+#define USB_PID 0x076B
+
+
+//	Standard requests
+#define GET_STATUS			0
+#define CLEAR_FEATURE		1
+#define SET_FEATURE			3
+#define SET_ADDRESS			5
+#define GET_DESCRIPTOR		6
+#define SET_DESCRIPTOR		7
+#define GET_CONFIGURATION	8
+#define SET_CONFIGURATION	9
+#define GET_INTERFACE		10
+#define SET_INTERFACE		11
+
+
+// bmRequestType
+#define REQUEST_HOSTTODEVICE	0x00
+#define REQUEST_DEVICETOHOST	0x80
+#define REQUEST_DIRECTION		0x80
+
+#define REQUEST_STANDARD		0x00
+#define REQUEST_CLASS			0x20
+#define REQUEST_VENDOR			0x40
+#define REQUEST_TYPE			0x60
+
+#define REQUEST_DEVICE			0x00
+#define REQUEST_INTERFACE		0x01
+#define REQUEST_ENDPOINT		0x02
+#define REQUEST_OTHER			0x03
+#define REQUEST_RECIPIENT		0x03
+
+#define REQUEST_DEVICETOHOST_CLASS_INTERFACE  (REQUEST_DEVICETOHOST + REQUEST_CLASS + REQUEST_INTERFACE)
+#define REQUEST_HOSTTODEVICE_CLASS_INTERFACE  (REQUEST_HOSTTODEVICE + REQUEST_CLASS + REQUEST_INTERFACE)
+
+//	Class requests
+
+#define CDC_SET_LINE_CODING			0x20
+#define CDC_GET_LINE_CODING			0x21
+#define CDC_SET_CONTROL_LINE_STATE	0x22
+
+#define MSC_RESET					0xFF
+#define MSC_GET_MAX_LUN				0xFE
+
+#define HID_GET_REPORT				0x01
+#define HID_GET_IDLE				0x02
+#define HID_GET_PROTOCOL			0x03
+#define HID_SET_REPORT				0x09
+#define HID_SET_IDLE				0x0A
+#define HID_SET_PROTOCOL			0x0B
+
+//	Descriptors
+
+#define USB_DEVICE_DESC_SIZE 18
+#define USB_CONFIGUARTION_DESC_SIZE 9
+#define USB_INTERFACE_DESC_SIZE 9
+#define USB_ENDPOINT_DESC_SIZE 7
+
+#define USB_DEVICE_DESCRIPTOR_TYPE             1
+#define USB_CONFIGURATION_DESCRIPTOR_TYPE      2
+#define USB_STRING_DESCRIPTOR_TYPE             3
+#define USB_INTERFACE_DESCRIPTOR_TYPE          4
+#define USB_ENDPOINT_DESCRIPTOR_TYPE           5
+
+#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
+#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
+#define USB_DEVICE_CLASS_STORAGE               0x08
+#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
+
+#define USB_CONFIG_POWERED_MASK                0x40
+#define USB_CONFIG_BUS_POWERED                 0x80
+#define USB_CONFIG_SELF_POWERED                0xC0
+#define USB_CONFIG_REMOTE_WAKEUP               0x20
+
+// bMaxPower in Configuration Descriptor
+#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
+
+// bEndpointAddress in Endpoint Descriptor
+#define USB_ENDPOINT_DIRECTION_MASK            0x80
+#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
+#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
+
+#define USB_ENDPOINT_TYPE_MASK                 0x03
+#define USB_ENDPOINT_TYPE_CONTROL              0x00
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
+#define USB_ENDPOINT_TYPE_BULK                 0x02
+#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
+
+#define TOBYTES(x) ((x) & 0xFF),(((x) >> 8) & 0xFF)
+
+#define CDC_V1_10                               0x0110
+#define CDC_COMMUNICATION_INTERFACE_CLASS       0x02
+
+#define CDC_CALL_MANAGEMENT                     0x01
+#define CDC_ABSTRACT_CONTROL_MODEL              0x02
+#define CDC_HEADER                              0x00
+#define CDC_ABSTRACT_CONTROL_MANAGEMENT         0x02
+#define CDC_UNION                               0x06
+#define CDC_CS_INTERFACE                        0x24
+#define CDC_CS_ENDPOINT                         0x25
+#define CDC_DATA_INTERFACE_CLASS                0x0A
+
+#define MSC_SUBCLASS_SCSI						0x06 
+#define MSC_PROTOCOL_BULK_ONLY					0x50 
+
+#define HID_HID_DESCRIPTOR_TYPE					0x21
+#define HID_REPORT_DESCRIPTOR_TYPE				0x22
+#define HID_PHYSICAL_DESCRIPTOR_TYPE			0x23
+
+
+//	Device
+typedef struct {
+	u8 len;				// 18
+	u8 dtype;			// 1 USB_DEVICE_DESCRIPTOR_TYPE
+	u16 usbVersion;		// 0x200
+	u8	deviceClass;
+	u8	deviceSubClass;
+	u8	deviceProtocol;
+	u8	packetSize0;	// Packet 0
+	u16	idVendor;
+	u16	idProduct;
+	u16	deviceVersion;	// 0x100
+	u8	iManufacturer;
+	u8	iProduct;
+	u8	iSerialNumber;
+	u8	bNumConfigurations;
+} DeviceDescriptor;
+
+//	Config
+typedef struct {
+	u8	len;			// 9
+	u8	dtype;			// 2
+	u16 clen;			// total length
+	u8	numInterfaces;
+	u8	config;
+	u8	iconfig;
+	u8	attributes;
+	u8	maxPower;
+} ConfigDescriptor;
+
+//	String
+
+//	Interface
+typedef struct
+{
+	u8 len;		// 9
+	u8 dtype;	// 4
+	u8 number;
+	u8 alternate;
+	u8 numEndpoints;
+	u8 interfaceClass;
+	u8 interfaceSubClass;
+	u8 protocol;
+	u8 iInterface;
+} InterfaceDescriptor;
+
+//	Endpoint
+typedef struct
+{
+	u8 len;		// 7
+	u8 dtype;	// 5
+	u8 addr;
+	u8 attr;
+	u16 packetSize;
+	u8 interval;
+} EndpointDescriptor;
+
+// Interface Association Descriptor
+// Used to bind 2 interfaces together in CDC compostite device
+typedef struct
+{
+	u8 len;				// 8
+	u8 dtype;			// 11
+	u8 firstInterface;
+	u8 interfaceCount;
+	u8 functionClass;
+	u8 funtionSubClass;
+	u8 functionProtocol;
+	u8 iInterface;
+} IADDescriptor;
+
+//	CDC CS interface descriptor
+typedef struct
+{
+	u8 len;		// 5
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+	u8 d1;
+} CDCCSInterfaceDescriptor;
+
+typedef struct
+{
+	u8 len;		// 4
+	u8 dtype;	// 0x24
+	u8 subtype;
+	u8 d0;
+} CDCCSInterfaceDescriptor4;
+
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+    u8 	bDataInterface;
+} CMFunctionalDescriptor;
+	
+typedef struct 
+{
+    u8	len;
+    u8 	dtype;		// 0x24
+    u8 	subtype;	// 1
+    u8 	bmCapabilities;
+} ACMFunctionalDescriptor;
+
+typedef struct 
+{
+	//	IAD
+	IADDescriptor				iad;	// Only needed on compound device
+
+	//	Control
+	InterfaceDescriptor			cif;	// 
+	CDCCSInterfaceDescriptor	header;
+	CMFunctionalDescriptor		callManagement;			// Call Management
+	ACMFunctionalDescriptor		controlManagement;		// ACM
+	CDCCSInterfaceDescriptor	functionalDescriptor;	// CDC_UNION
+	EndpointDescriptor			cifin;
+
+	//	Data
+	InterfaceDescriptor			dif;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} CDCDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			msc;
+	EndpointDescriptor			in;
+	EndpointDescriptor			out;
+} MSCDescriptor;
+
+typedef struct
+{
+	u8 len;			// 9
+	u8 dtype;		// 0x21
+	u8 addr;
+	u8	versionL;	// 0x101
+	u8	versionH;	// 0x101
+	u8	country;
+	u8	desctype;	// 0x22 report
+	u8	descLenL;
+	u8	descLenH;
+} HIDDescDescriptor;
+
+typedef struct 
+{
+	InterfaceDescriptor			hid;
+	HIDDescDescriptor			desc;
+	EndpointDescriptor			in;
+} HIDDescriptor;
+
+
+#define D_DEVICE(_class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs) \
+	{ 18, 1, 0x200, _class,_subClass,_proto,_packetSize0,_vid,_pid,_version,_im,_ip,_is,_configs }
+
+#define D_CONFIG(_totalLength,_interfaces) \
+	{ 9, 2, _totalLength,_interfaces, 1, 0, USB_CONFIG_BUS_POWERED, USB_CONFIG_POWER_MA(500) }
+
+#define D_INTERFACE(_n,_numEndpoints,_class,_subClass,_protocol) \
+	{ 9, 4, _n, 0, _numEndpoints, _class,_subClass, _protocol, 0 }
+
+#define D_ENDPOINT(_addr,_attr,_packetSize, _interval) \
+	{ 7, 5, _addr,_attr,_packetSize, _interval }
+
+#define D_IAD(_firstInterface, _count, _class, _subClass, _protocol) \
+	{ 8, 11, _firstInterface, _count, _class, _subClass, _protocol, 0 }
+
+#define D_HIDREPORT(_descriptorLength) \
+	{ 9, 0x21, 0x1, 0x1, 0, 1, 0x22, _descriptorLength, 0 }
+
+#define D_CDCCS(_subtype,_d0,_d1)	{ 5, 0x24, _subtype, _d0, _d1 }
+#define D_CDCCS4(_subtype,_d0)		{ 4, 0x24, _subtype, _d0 }
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBDesc.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBDesc.h
new file mode 100644
index 0000000..0948264
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/USBDesc.h
@@ -0,0 +1,62 @@
+/* Copyright (c) 2011, Peter Barrett  
+**  
+** Permission to use, copy, modify, and/or distribute this software for  
+** any purpose with or without fee is hereby granted, provided that the  
+** above copyright notice and this permission notice appear in all copies.  
+** 
+** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL  
+** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  
+** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR  
+** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES  
+** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,  
+** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  
+** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  
+** SOFTWARE.  
+*/
+
+#define CDC_ENABLED
+
+// Disable HID, Brainwaves don't need to be mice. -Hubbe 20120929
+// #define HID_ENABLED
+
+#ifdef CDC_ENABLED
+#define CDC_INTERFACE_COUNT	2
+#define CDC_ENPOINT_COUNT	3
+#else
+#define CDC_INTERFACE_COUNT	0
+#define CDC_ENPOINT_COUNT	0
+#endif
+
+#ifdef HID_ENABLED
+#define HID_INTERFACE_COUNT	1
+#define HID_ENPOINT_COUNT	1
+#else
+#define HID_INTERFACE_COUNT	0
+#define HID_ENPOINT_COUNT	0
+#endif
+
+#define CDC_ACM_INTERFACE	0	// CDC ACM
+#define CDC_DATA_INTERFACE	1	// CDC Data
+#define CDC_FIRST_ENDPOINT	1
+#define CDC_ENDPOINT_ACM	(CDC_FIRST_ENDPOINT)							// CDC First
+#define CDC_ENDPOINT_OUT	(CDC_FIRST_ENDPOINT+1)
+#define CDC_ENDPOINT_IN		(CDC_FIRST_ENDPOINT+2)
+
+#define HID_INTERFACE		(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT)		// HID Interface
+#define HID_FIRST_ENDPOINT	(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT)
+#define HID_ENDPOINT_INT	(HID_FIRST_ENDPOINT)
+
+#define INTERFACE_COUNT		(MSC_INTERFACE + MSC_INTERFACE_COUNT)
+
+#ifdef CDC_ENABLED
+#define CDC_RX CDC_ENDPOINT_OUT
+#define CDC_TX CDC_ENDPOINT_IN
+#endif
+
+#ifdef HID_ENABLED
+#define HID_TX HID_ENDPOINT_INT
+#endif
+
+#define IMANUFACTURER	1
+#define IPRODUCT		2
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Udp.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Udp.h
new file mode 100644
index 0000000..dc5644b
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/Udp.h
@@ -0,0 +1,88 @@
+/*
+ *  Udp.cpp: Library to send/receive UDP packets.
+ *
+ * NOTE: UDP is fast, but has some important limitations (thanks to Warren Gray for mentioning these)
+ * 1) UDP does not guarantee the order in which assembled UDP packets are received. This
+ * might not happen often in practice, but in larger network topologies, a UDP
+ * packet can be received out of sequence. 
+ * 2) UDP does not guard against lost packets - so packets *can* disappear without the sender being
+ * aware of it. Again, this may not be a concern in practice on small local networks.
+ * For more information, see http://www.cafeaulait.org/course/week12/35.html
+ *
+ * MIT License:
+ * Copyright (c) 2008 Bjoern Hartmann
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ * bjoern@cs.stanford.edu 12/30/2008
+ */
+
+#ifndef udp_h
+#define udp_h
+
+#include <Stream.h>
+#include <IPAddress.h>
+
+class UDP : public Stream {
+
+public:
+  virtual uint8_t begin(uint16_t) =0;	// initialize, start listening on specified port. Returns 1 if successful, 0 if there are no sockets available to use
+  virtual void stop() =0;  // Finish with the UDP socket
+
+  // Sending UDP packets
+  
+  // Start building up a packet to send to the remote host specific in ip and port
+  // Returns 1 if successful, 0 if there was a problem with the supplied IP address or port
+  virtual int beginPacket(IPAddress ip, uint16_t port) =0;
+  // Start building up a packet to send to the remote host specific in host and port
+  // Returns 1 if successful, 0 if there was a problem resolving the hostname or port
+  virtual int beginPacket(const char *host, uint16_t port) =0;
+  // Finish off this packet and send it
+  // Returns 1 if the packet was sent successfully, 0 if there was an error
+  virtual int endPacket() =0;
+  // Write a single byte into the packet
+  virtual size_t write(uint8_t) =0;
+  // Write size bytes from buffer into the packet
+  virtual size_t write(const uint8_t *buffer, size_t size) =0;
+
+  // Start processing the next available incoming packet
+  // Returns the size of the packet in bytes, or 0 if no packets are available
+  virtual int parsePacket() =0;
+  // Number of bytes remaining in the current packet
+  virtual int available() =0;
+  // Read a single byte from the current packet
+  virtual int read() =0;
+  // Read up to len bytes from the current packet and place them into buffer
+  // Returns the number of bytes read, or 0 if none are available
+  virtual int read(unsigned char* buffer, size_t len) =0;
+  // Read up to len characters from the current packet and place them into buffer
+  // Returns the number of characters read, or 0 if none are available
+  virtual int read(char* buffer, size_t len) =0;
+  // Return the next byte from the current packet without moving on to the next byte
+  virtual int peek() =0;
+  virtual void flush() =0;	// Finish reading the current packet
+
+  // Return the IP address of the host who sent the current incoming packet
+  virtual IPAddress remoteIP() =0;
+  // Return the port of the host who sent the current incoming packet
+  virtual uint16_t remotePort() =0;
+protected:
+  uint8_t* rawIPAddress(IPAddress& addr) { return addr.raw_address(); };
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WCharacter.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WInterrupts.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WInterrupts.c
new file mode 100644
index 0000000..8f3ec84
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WInterrupts.c
@@ -0,0 +1,298 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "wiring_private.h"
+
+static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+	// I hate doing this, but the register assignment differs between the 1280/2560
+	// and the 32U4.  Since avrlib defines registers PCMSK1 and PCMSK2 that aren't 
+	// even present on the 32U4 this is the only way to distinguish between them.
+	case 0:
+		EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (mode << ISC00);
+		EIMSK |= (1<<INT0);
+		break;
+	case 1:
+		EICRA = (EICRA & ~((1<<ISC10) | (1<<ISC11))) | (mode << ISC10);
+		EIMSK |= (1<<INT1);
+		break;	
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else		
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+    
+    case 2:
+    #if defined(EICRA) && defined(ISC20) && defined(ISC21) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(ISC21) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GICR |= (1 << INT2);
+    #elif defined(MCUCR) && defined(ISC20) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      GIMSK |= (1 << INT2);
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(__AVR_ATmega32U4__)
+	case 0:
+		EIMSK &= ~(1<<INT0);
+		break;
+	case 1:
+		EIMSK &= ~(1<<INT1);
+		break;		
+#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(__AVR_ATmega32U4__)
+SIGNAL(INT0_vect) {
+	if(intFunc[EXTERNAL_INT_0])
+		intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+	if(intFunc[EXTERNAL_INT_1])
+		intFunc[EXTERNAL_INT_1]();
+}
+
+#elif defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#if defined(EICRA) && defined(ISC20)
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+#endif
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WMath.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.cpp
new file mode 100644
index 0000000..c6839fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.cpp
@@ -0,0 +1,645 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "WString.h"
+
+
+/*********************************************/
+/*  Constructors                             */
+/*********************************************/
+
+String::String(const char *cstr)
+{
+	init();
+	if (cstr) copy(cstr, strlen(cstr));
+}
+
+String::String(const String &value)
+{
+	init();
+	*this = value;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String::String(String &&rval)
+{
+	init();
+	move(rval);
+}
+String::String(StringSumHelper &&rval)
+{
+	init();
+	move(rval);
+}
+#endif
+
+String::String(char c)
+{
+	init();
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	*this = buf;
+}
+
+String::String(unsigned char value, unsigned char base)
+{
+	init();
+	char buf[9];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(int value, unsigned char base)
+{
+	init();
+	char buf[18];
+	itoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned int value, unsigned char base)
+{
+	init();
+	char buf[17];
+	utoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(long value, unsigned char base)
+{
+	init();
+	char buf[34];
+	ltoa(value, buf, base);
+	*this = buf;
+}
+
+String::String(unsigned long value, unsigned char base)
+{
+	init();
+	char buf[33];
+	ultoa(value, buf, base);
+	*this = buf;
+}
+
+String::~String()
+{
+	free(buffer);
+}
+
+/*********************************************/
+/*  Memory Management                        */
+/*********************************************/
+
+inline void String::init(void)
+{
+	buffer = NULL;
+	capacity = 0;
+	len = 0;
+	flags = 0;
+}
+
+void String::invalidate(void)
+{
+	if (buffer) free(buffer);
+	buffer = NULL;
+	capacity = len = 0;
+}
+
+unsigned char String::reserve(unsigned int size)
+{
+	if (buffer && capacity >= size) return 1;
+	if (changeBuffer(size)) {
+		if (len == 0) buffer[0] = 0;
+		return 1;
+	}
+	return 0;
+}
+
+unsigned char String::changeBuffer(unsigned int maxStrLen)
+{
+	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
+	if (newbuffer) {
+		buffer = newbuffer;
+		capacity = maxStrLen;
+		return 1;
+	}
+	return 0;
+}
+
+/*********************************************/
+/*  Copy and Move                            */
+/*********************************************/
+
+String & String::copy(const char *cstr, unsigned int length)
+{
+	if (!reserve(length)) {
+		invalidate();
+		return *this;
+	}
+	len = length;
+	strcpy(buffer, cstr);
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+void String::move(String &rhs)
+{
+	if (buffer) {
+		if (capacity >= rhs.len) {
+			strcpy(buffer, rhs.buffer);
+			len = rhs.len;
+			rhs.len = 0;
+			return;
+		} else {
+			free(buffer);
+		}
+	}
+	buffer = rhs.buffer;
+	capacity = rhs.capacity;
+	len = rhs.len;
+	rhs.buffer = NULL;
+	rhs.capacity = 0;
+	rhs.len = 0;
+}
+#endif
+
+String & String::operator = (const String &rhs)
+{
+	if (this == &rhs) return *this;
+	
+	if (rhs.buffer) copy(rhs.buffer, rhs.len);
+	else invalidate();
+	
+	return *this;
+}
+
+#ifdef __GXX_EXPERIMENTAL_CXX0X__
+String & String::operator = (String &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+
+String & String::operator = (StringSumHelper &&rval)
+{
+	if (this != &rval) move(rval);
+	return *this;
+}
+#endif
+
+String & String::operator = (const char *cstr)
+{
+	if (cstr) copy(cstr, strlen(cstr));
+	else invalidate();
+	
+	return *this;
+}
+
+/*********************************************/
+/*  concat                                   */
+/*********************************************/
+
+unsigned char String::concat(const String &s)
+{
+	return concat(s.buffer, s.len);
+}
+
+unsigned char String::concat(const char *cstr, unsigned int length)
+{
+	unsigned int newlen = len + length;
+	if (!cstr) return 0;
+	if (length == 0) return 1;
+	if (!reserve(newlen)) return 0;
+	strcpy(buffer + len, cstr);
+	len = newlen;
+	return 1;
+}
+
+unsigned char String::concat(const char *cstr)
+{
+	if (!cstr) return 0;
+	return concat(cstr, strlen(cstr));
+}
+
+unsigned char String::concat(char c)
+{
+	char buf[2];
+	buf[0] = c;
+	buf[1] = 0;
+	return concat(buf, 1);
+}
+
+unsigned char String::concat(unsigned char num)
+{
+	char buf[4];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(int num)
+{
+	char buf[7];
+	itoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned int num)
+{
+	char buf[6];
+	utoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(long num)
+{
+	char buf[12];
+	ltoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+unsigned char String::concat(unsigned long num)
+{
+	char buf[11];
+	ultoa(num, buf, 10);
+	return concat(buf, strlen(buf));
+}
+
+/*********************************************/
+/*  Concatenate                              */
+/*********************************************/
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, char c)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(c)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
+{
+	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
+	if (!a.concat(num)) a.invalidate();
+	return a;
+}
+
+/*********************************************/
+/*  Comparison                               */
+/*********************************************/
+
+int String::compareTo(const String &s) const
+{
+	if (!buffer || !s.buffer) {
+		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
+		if (buffer && len > 0) return *(unsigned char *)buffer;
+		return 0;
+	}
+	return strcmp(buffer, s.buffer);
+}
+
+unsigned char String::equals(const String &s2) const
+{
+	return (len == s2.len && compareTo(s2) == 0);
+}
+
+unsigned char String::equals(const char *cstr) const
+{
+	if (len == 0) return (cstr == NULL || *cstr == 0);
+	if (cstr == NULL) return buffer[0] == 0;
+	return strcmp(buffer, cstr) == 0;
+}
+
+unsigned char String::operator<(const String &rhs) const
+{
+	return compareTo(rhs) < 0;
+}
+
+unsigned char String::operator>(const String &rhs) const
+{
+	return compareTo(rhs) > 0;
+}
+
+unsigned char String::operator<=(const String &rhs) const
+{
+	return compareTo(rhs) <= 0;
+}
+
+unsigned char String::operator>=(const String &rhs) const
+{
+	return compareTo(rhs) >= 0;
+}
+
+unsigned char String::equalsIgnoreCase( const String &s2 ) const
+{
+	if (this == &s2) return 1;
+	if (len != s2.len) return 0;
+	if (len == 0) return 1;
+	const char *p1 = buffer;
+	const char *p2 = s2.buffer;
+	while (*p1) {
+		if (tolower(*p1++) != tolower(*p2++)) return 0;
+	} 
+	return 1;
+}
+
+unsigned char String::startsWith( const String &s2 ) const
+{
+	if (len < s2.len) return 0;
+	return startsWith(s2, 0);
+}
+
+unsigned char String::startsWith( const String &s2, unsigned int offset ) const
+{
+	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
+	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
+}
+
+unsigned char String::endsWith( const String &s2 ) const
+{
+	if ( len < s2.len || !buffer || !s2.buffer) return 0;
+	return strcmp(&buffer[len - s2.len], s2.buffer) == 0;
+}
+
+/*********************************************/
+/*  Character Access                         */
+/*********************************************/
+
+char String::charAt(unsigned int loc) const
+{
+	return operator[](loc);
+}
+
+void String::setCharAt(unsigned int loc, char c) 
+{
+	if (loc < len) buffer[loc] = c;
+}
+
+char & String::operator[](unsigned int index)
+{
+	static char dummy_writable_char;
+	if (index >= len || !buffer) {
+		dummy_writable_char = 0;
+		return dummy_writable_char;
+	}
+	return buffer[index];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+	if (index >= len || !buffer) return 0;
+	return buffer[index];
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
+{
+	if (!bufsize || !buf) return;
+	if (index >= len) {
+		buf[0] = 0;
+		return;
+	}
+	unsigned int n = bufsize - 1;
+	if (n > len - index) n = len - index;
+	strncpy((char *)buf, buffer + index, n);
+	buf[n] = 0;
+}
+
+/*********************************************/
+/*  Search                                   */
+/*********************************************/
+
+int String::indexOf(char c) const
+{
+	return indexOf(c, 0);
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+	if (fromIndex >= len) return -1;
+	const char* temp = strchr(buffer + fromIndex, ch);
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::indexOf(const String &s2) const
+{
+	return indexOf(s2, 0);
+}
+
+int String::indexOf(const String &s2, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	const char *found = strstr(buffer + fromIndex, s2.buffer);
+	if (found == NULL) return -1;
+	return found - buffer;
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+	return lastIndexOf(theChar, len - 1);
+}
+
+int String::lastIndexOf(char ch, unsigned int fromIndex) const
+{
+	if (fromIndex >= len) return -1;
+	char tempchar = buffer[fromIndex + 1];
+	buffer[fromIndex + 1] = '\0';
+	char* temp = strrchr( buffer, ch );
+	buffer[fromIndex + 1] = tempchar;
+	if (temp == NULL) return -1;
+	return temp - buffer;
+}
+
+int String::lastIndexOf(const String &s2) const
+{
+	return lastIndexOf(s2, len - s2.len);
+}
+
+int String::lastIndexOf(const String &s2, unsigned int fromIndex) const
+{
+  	if (s2.len == 0 || len == 0 || s2.len > len) return -1;
+	if (fromIndex >= len) fromIndex = len - 1;
+	int found = -1;
+	for (char *p = buffer; p <= buffer + fromIndex; p++) {
+		p = strstr(p, s2.buffer);
+		if (!p) break;
+		if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;
+	}
+	return found;
+}
+
+String String::substring( unsigned int left ) const
+{
+	return substring(left, len);
+}
+
+String String::substring(unsigned int left, unsigned int right) const
+{
+	if (left > right) {
+		unsigned int temp = right;
+		right = left;
+		left = temp;
+	}
+	String out;
+	if (left > len) return out;
+	if (right > len) right = len;
+	char temp = buffer[right];  // save the replaced character
+	buffer[right] = '\0';	
+	out = buffer + left;  // pointer arithmetic
+	buffer[right] = temp;  //restore character
+	return out;
+}
+
+/*********************************************/
+/*  Modification                             */
+/*********************************************/
+
+void String::replace(char find, char replace)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		if (*p == find) *p = replace;
+	}
+}
+
+void String::replace(const String& find, const String& replace)
+{
+	if (len == 0 || find.len == 0) return;
+	int diff = replace.len - find.len;
+	char *readFrom = buffer;
+	char *foundAt;
+	if (diff == 0) {
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			memcpy(foundAt, replace.buffer, replace.len);
+			readFrom = foundAt + replace.len;
+		}
+	} else if (diff < 0) {
+		char *writeTo = buffer;
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			unsigned int n = foundAt - readFrom;
+			memcpy(writeTo, readFrom, n);
+			writeTo += n;
+			memcpy(writeTo, replace.buffer, replace.len);
+			writeTo += replace.len;
+			readFrom = foundAt + find.len;
+			len += diff;
+		}
+		strcpy(writeTo, readFrom);
+	} else {
+		unsigned int size = len; // compute size needed for result
+		while ((foundAt = strstr(readFrom, find.buffer)) != NULL) {
+			readFrom = foundAt + find.len;
+			size += diff;
+		}
+		if (size == len) return;
+		if (size > capacity && !changeBuffer(size)) return; // XXX: tell user!
+		int index = len - 1;
+		while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) {
+			readFrom = buffer + index + find.len;
+			memmove(readFrom + diff, readFrom, len - (readFrom - buffer));
+			len += diff;
+			buffer[len] = 0;
+			memcpy(buffer + index, replace.buffer, replace.len);
+			index--;
+		}
+	}
+}
+
+void String::toLowerCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = tolower(*p);
+	}
+}
+
+void String::toUpperCase(void)
+{
+	if (!buffer) return;
+	for (char *p = buffer; *p; p++) {
+		*p = toupper(*p);
+	}
+}
+
+void String::trim(void)
+{
+	if (!buffer || len == 0) return;
+	char *begin = buffer;
+	while (isspace(*begin)) begin++;
+	char *end = buffer + len - 1;
+	while (isspace(*end) && end >= begin) end--;
+	len = end + 1 - begin;
+	if (begin > buffer) memcpy(buffer, begin, len);
+	buffer[len] = 0;
+}
+
+/*********************************************/
+/*  Parsing / Conversion                     */
+/*********************************************/
+
+long String::toInt(void) const
+{
+	if (buffer) return atol(buffer);
+	return 0;
+}
+
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.h
new file mode 100644
index 0000000..d76d2a3
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/WString.h
@@ -0,0 +1,205 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  ...mostly rewritten by Paul Stoffregen...
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+  Copyright 2011, Paul Stoffregen, paul@pjrc.com
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_class_h
+#define String_class_h
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <avr/pgmspace.h>
+
+// When compiling programs with this class, the following gcc parameters
+// dramatically increase performance and memory (RAM) efficiency, typically
+// with little or no increase in code size.
+//     -felide-constructors
+//     -std=c++0x
+
+class __FlashStringHelper;
+#define F(string_literal) (reinterpret_cast<__FlashStringHelper *>(PSTR(string_literal)))
+
+// An inherited class for holding the result of a concatenation.  These
+// result objects are assumed to be writable by subsequent concatenations.
+class StringSumHelper;
+
+// The string class
+class String
+{
+	// use a function pointer to allow for "if (s)" without the
+	// complications of an operator bool(). for more information, see:
+	// http://www.artima.com/cppsource/safebool.html
+	typedef void (String::*StringIfHelperType)() const;
+	void StringIfHelper() const {}
+
+public:
+	// constructors
+	// creates a copy of the initial value.
+	// if the initial value is null or invalid, or if memory allocation
+	// fails, the string will be marked as invalid (i.e. "if (s)" will
+	// be false).
+	String(const char *cstr = "");
+	String(const String &str);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String(String &&rval);
+	String(StringSumHelper &&rval);
+	#endif
+	explicit String(char c);
+	explicit String(unsigned char, unsigned char base=10);
+	explicit String(int, unsigned char base=10);
+	explicit String(unsigned int, unsigned char base=10);
+	explicit String(long, unsigned char base=10);
+	explicit String(unsigned long, unsigned char base=10);
+	~String(void);
+
+	// memory management
+	// return true on success, false on failure (in which case, the string
+	// is left unchanged).  reserve(0), if successful, will validate an
+	// invalid string (i.e., "if (s)" will be true afterwards)
+	unsigned char reserve(unsigned int size);
+	inline unsigned int length(void) const {return len;}
+
+	// creates a copy of the assigned value.  if the value is null or
+	// invalid, or if the memory allocation fails, the string will be 
+	// marked as invalid ("if (s)" will be false).
+	String & operator = (const String &rhs);
+	String & operator = (const char *cstr);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	String & operator = (String &&rval);
+	String & operator = (StringSumHelper &&rval);
+	#endif
+
+	// concatenate (works w/ built-in types)
+	
+	// returns true on success, false on failure (in which case, the string
+	// is left unchanged).  if the argument is null or invalid, the 
+	// concatenation is considered unsucessful.  
+	unsigned char concat(const String &str);
+	unsigned char concat(const char *cstr);
+	unsigned char concat(char c);
+	unsigned char concat(unsigned char c);
+	unsigned char concat(int num);
+	unsigned char concat(unsigned int num);
+	unsigned char concat(long num);
+	unsigned char concat(unsigned long num);
+	
+	// if there's not enough memory for the concatenated value, the string
+	// will be left unchanged (but this isn't signalled in any way)
+	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
+	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
+	String & operator += (char c)			{concat(c); return (*this);}
+	String & operator += (unsigned char num)		{concat(num); return (*this);}
+	String & operator += (int num)			{concat(num); return (*this);}
+	String & operator += (unsigned int num)		{concat(num); return (*this);}
+	String & operator += (long num)			{concat(num); return (*this);}
+	String & operator += (unsigned long num)	{concat(num); return (*this);}
+
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, char c);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, long num);
+	friend StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num);
+
+	// comparison (only works w/ Strings and "strings")
+	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
+	int compareTo(const String &s) const;
+	unsigned char equals(const String &s) const;
+	unsigned char equals(const char *cstr) const;
+	unsigned char operator == (const String &rhs) const {return equals(rhs);}
+	unsigned char operator == (const char *cstr) const {return equals(cstr);}
+	unsigned char operator != (const String &rhs) const {return !equals(rhs);}
+	unsigned char operator != (const char *cstr) const {return !equals(cstr);}
+	unsigned char operator <  (const String &rhs) const;
+	unsigned char operator >  (const String &rhs) const;
+	unsigned char operator <= (const String &rhs) const;
+	unsigned char operator >= (const String &rhs) const;
+	unsigned char equalsIgnoreCase(const String &s) const;
+	unsigned char startsWith( const String &prefix) const;
+	unsigned char startsWith(const String &prefix, unsigned int offset) const;
+	unsigned char endsWith(const String &suffix) const;
+
+	// character acccess
+	char charAt(unsigned int index) const;
+	void setCharAt(unsigned int index, char c);
+	char operator [] (unsigned int index) const;
+	char& operator [] (unsigned int index);
+	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
+	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
+		{getBytes((unsigned char *)buf, bufsize, index);}
+
+	// search
+	int indexOf( char ch ) const;
+	int indexOf( char ch, unsigned int fromIndex ) const;
+	int indexOf( const String &str ) const;
+	int indexOf( const String &str, unsigned int fromIndex ) const;
+	int lastIndexOf( char ch ) const;
+	int lastIndexOf( char ch, unsigned int fromIndex ) const;
+	int lastIndexOf( const String &str ) const;
+	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
+	String substring( unsigned int beginIndex ) const;
+	String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+
+	// modification
+	void replace(char find, char replace);
+	void replace(const String& find, const String& replace);
+	void toLowerCase(void);
+	void toUpperCase(void);
+	void trim(void);
+
+	// parsing/conversion
+	long toInt(void) const;
+
+protected:
+	char *buffer;	        // the actual char array
+	unsigned int capacity;  // the array length minus one (for the '\0')
+	unsigned int len;       // the String length (not counting the '\0')
+	unsigned char flags;    // unused, for future features
+protected:
+	void init(void);
+	void invalidate(void);
+	unsigned char changeBuffer(unsigned int maxStrLen);
+	unsigned char concat(const char *cstr, unsigned int length);
+
+	// copy and move
+	String & copy(const char *cstr, unsigned int length);
+	#ifdef __GXX_EXPERIMENTAL_CXX0X__
+	void move(String &rhs);
+	#endif
+};
+
+class StringSumHelper : public String
+{
+public:
+	StringSumHelper(const String &s) : String(s) {}
+	StringSumHelper(const char *p) : String(p) {}
+	StringSumHelper(char c) : String(c) {}
+	StringSumHelper(unsigned char num) : String(num) {}
+	StringSumHelper(int num) : String(num) {}
+	StringSumHelper(unsigned int num) : String(num) {}
+	StringSumHelper(long num) : String(num) {}
+	StringSumHelper(unsigned long num) : String(num) {}
+};
+
+#endif  // __cplusplus
+#endif  // String_class_h
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/binary.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/main.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/main.cpp
new file mode 100644
index 0000000..3d4e079
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/main.cpp
@@ -0,0 +1,20 @@
+#include <Arduino.h>
+
+int main(void)
+{
+	init();
+
+#if defined(USBCON)
+	USBDevice.attach();
+#endif
+	
+	setup();
+    
+	for (;;) {
+		loop();
+		if (serialEventRun) serialEventRun();
+	}
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.cpp
new file mode 100644
index 0000000..0f6d422
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.cpp
@@ -0,0 +1,18 @@
+#include <new.h>
+
+void * operator new(size_t size)
+{
+  return malloc(size);
+}
+
+void operator delete(void * ptr)
+{
+  free(ptr);
+} 
+
+int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
+void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
+void __cxa_guard_abort (__guard *) {}; 
+
+void __cxa_pure_virtual(void) {};
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.h
new file mode 100644
index 0000000..cd940ce
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/new.h
@@ -0,0 +1,22 @@
+/* Header to define new/delete operators as they aren't provided by avr-gcc by default
+   Taken from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=59453 
+ */
+
+#ifndef NEW_H
+#define NEW_H
+
+#include <stdlib.h>
+
+void * operator new(size_t size);
+void operator delete(void * ptr); 
+
+__extension__ typedef int __guard __attribute__((mode (__DI__)));
+
+extern "C" int __cxa_guard_acquire(__guard *);
+extern "C" void __cxa_guard_release (__guard *);
+extern "C" void __cxa_guard_abort (__guard *); 
+
+extern "C" void __cxa_pure_virtual(void);
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring.c
new file mode 100644
index 0000000..ac8bb6f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring.c
@@ -0,0 +1,324 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
+SIGNAL(TIM0_OVF_vect)
+#else
+SIGNAL(TIMER0_OVF_vect)
+#endif
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+#if F_CPU >= 20000000L
+	// for the 20 MHz clock on rare Arduino boards
+
+	// for a one-microsecond delay, simply wait 2 cycle and return. The overhead
+	// of the function call yields a delay of exactly a one microsecond.
+	__asm__ __volatile__ (
+		"nop" "\n\t"
+		"nop"); //just waiting 2 cycle
+	if (--us == 0)
+		return;
+
+	// the following loop takes a 1/5 of a microsecond (4 cycles)
+	// per iteration, so execute it five times for each microsecond of
+	// delay requested.
+	us = (us<<2) + us; // x5 us
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+
+#elif F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1B, CS10);
+#endif
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+#if F_CPU >= 8000000L
+	sbi(TCCR1, CS10);
+#endif
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
+	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
+	sbi(TCCR4B, CS41);
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
+	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
+	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
+#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+#endif /* end timer4 block for ATMEGA1280/2560 and similar */	
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_analog.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_analog.c
new file mode 100644
index 0000000..0e9881f
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_analog.c
@@ -0,0 +1,282 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega32U4__)
+	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
+#elif defined(__AVR_ATmega1284__)
+	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+	
+#if defined(__AVR_ATmega32U4__)
+	pin = analogPinToChannel(pin);
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#elif defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A)
+			case TIMER4A:
+				//connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				#if defined(COM4A0)		// only used on 32U4
+				cbi(TCCR4A, COM4A0);
+				#endif
+				OCR4A = val;	// set pwm duty
+				break;
+			#endif
+			
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+				
+			#if defined(TCCR4C) && defined(COM4D1)
+			case TIMER4D:				
+				// connect pwm to pin on timer 4, channel D
+				sbi(TCCR4C, COM4D1);
+				#if defined(COM4D0)		// only used on 32U4
+				cbi(TCCR4C, COM4D0);
+				#endif
+				OCR4D = val;	// set pwm duty
+				break;
+			#endif
+
+							
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_digital.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_digital.c
new file mode 100644
index 0000000..be323b1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_digital.c
@@ -0,0 +1,178 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#define ARDUINO_MAIN
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg, *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+	out = portOutputRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else if (mode == INPUT_PULLUP) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		*out |= bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif					
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif			
+		#if defined(TCCR4C) && defined(COM4D1)
+		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
+		#endif			
+			
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	uint8_t oldSREG = SREG;
+	cli();
+
+	if (val == LOW) {
+		*out &= ~bit;
+	} else {
+		*out |= bit;
+	}
+
+	SREG = oldSREG;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_private.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_private.h
new file mode 100644
index 0000000..f0ceb0c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_private.h
@@ -0,0 +1,69 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "Arduino.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#elif defined(__AVR_ATmega1284P__) 
+#define EXTERNAL_NUM_INTERRUPTS 3
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_pulse.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_shift.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/cores/brainwave/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/firmwares/Brainwave.inf b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/firmwares/Brainwave.inf
new file mode 100644
index 0000000..e488294
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/firmwares/Brainwave.inf
@@ -0,0 +1,106 @@
+;************************************************************
+; Windows USB CDC ACM Setup File
+; Copyright (c) 2000 Microsoft Corporation
+
+
+[Version]
+Signature="$Windows NT$"
+Class=Ports
+ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}
+Provider=%MFGNAME%
+LayoutFile=layout.inf
+CatalogFile=%MFGFILENAME%.cat
+DriverVer=11/15/2007,5.1.2600.0
+
+[Manufacturer]
+%MFGNAME%=DeviceList, NTamd64
+
+[DestinationDirs]
+DefaultDestDir=12
+
+
+;------------------------------------------------------------------------------
+;  Windows 2000/XP/Vista-32bit Sections
+;------------------------------------------------------------------------------
+
+[DriverInstall.nt]
+include=mdmcpq.inf
+CopyFiles=DriverCopyFiles.nt
+AddReg=DriverInstall.nt.AddReg
+
+[DriverCopyFiles.nt]
+usbser.sys,,,0x20
+
+[DriverInstall.nt.AddReg]
+HKR,,DevLoader,,*ntkern
+HKR,,NTMPDriver,,%DRIVERFILENAME%.sys
+HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"
+
+[DriverInstall.nt.Services]
+AddService=usbser, 0x00000002, DriverService.nt
+
+[DriverService.nt]
+DisplayName=%SERVICE%
+ServiceType=1
+StartType=3
+ErrorControl=1
+ServiceBinary=%12%\%DRIVERFILENAME%.sys
+
+;------------------------------------------------------------------------------
+;  Vista-64bit Sections
+;------------------------------------------------------------------------------
+
+[DriverInstall.NTamd64]
+include=mdmcpq.inf
+CopyFiles=DriverCopyFiles.NTamd64
+AddReg=DriverInstall.NTamd64.AddReg
+
+[DriverCopyFiles.NTamd64]
+%DRIVERFILENAME%.sys,,,0x20
+
+[DriverInstall.NTamd64.AddReg]
+HKR,,DevLoader,,*ntkern
+HKR,,NTMPDriver,,%DRIVERFILENAME%.sys
+HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"
+
+[DriverInstall.NTamd64.Services]
+AddService=usbser, 0x00000002, DriverService.NTamd64
+
+[DriverService.NTamd64]
+DisplayName=%SERVICE%
+ServiceType=1
+StartType=3
+ErrorControl=1
+ServiceBinary=%12%\%DRIVERFILENAME%.sys
+
+
+;------------------------------------------------------------------------------
+;  Vendor and Product ID Definitions
+;------------------------------------------------------------------------------
+; When developing your USB device, the VID and PID used in the PC side
+; application program and the firmware on the microcontroller must match.
+; Modify the below line to use your VID and PID.  Use the format as shown below.
+; Note: One INF file can be used for multiple devices with different VID and PIDs.
+; For each supported device, append ",USB\VID_xxxx&PID_yyyy" to the end of the line.
+;------------------------------------------------------------------------------
+[SourceDisksFiles]
+[SourceDisksNames]
+[DeviceList]
+%DESCRIPTION%=DriverInstall, USB\VID_16D0&PID_076B
+
+[DeviceList.NTamd64]
+%DESCRIPTION%=DriverInstall, USB\VID_16D0&PID_204A
+
+
+;------------------------------------------------------------------------------
+;  String Definitions
+;------------------------------------------------------------------------------
+;Modify these strings to customize your device
+;------------------------------------------------------------------------------
+[Strings]
+MFGFILENAME="CDC_vista"
+DRIVERFILENAME ="usbser"
+MFGNAME="Metrix Create Space"
+INSTDISK="Brainwave Driver Installer"
+DESCRIPTION="Communications Port"
+SERVICE="USB RS-232 Emulation Driver"
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.cpp
new file mode 100644
index 0000000..61efca4
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.cpp
@@ -0,0 +1,310 @@
+#include "LiquidCrystal.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "Arduino.h"
+
+// When the display powers up, it is configured as follows:
+//
+// 1. Display clear
+// 2. Function set: 
+//    DL = 1; 8-bit interface data 
+//    N = 0; 1-line display 
+//    F = 0; 5x8 dot character font 
+// 3. Display on/off control: 
+//    D = 0; Display off 
+//    C = 0; Cursor off 
+//    B = 0; Blinking off 
+// 4. Entry mode set: 
+//    I/D = 1; Increment by 1 
+//    S = 0; No shift 
+//
+// Note, however, that resetting the Arduino doesn't reset the LCD, so we
+// can't assume that it's in that state when a sketch starts (and the
+// LiquidCrystal constructor is called).
+
+LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
+}
+
+LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+LiquidCrystal::LiquidCrystal(uint8_t rs,  uint8_t enable,
+			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
+{
+  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
+}
+
+void LiquidCrystal::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
+{
+  _rs_pin = rs;
+  _rw_pin = rw;
+  _enable_pin = enable;
+  
+  _data_pins[0] = d0;
+  _data_pins[1] = d1;
+  _data_pins[2] = d2;
+  _data_pins[3] = d3; 
+  _data_pins[4] = d4;
+  _data_pins[5] = d5;
+  _data_pins[6] = d6;
+  _data_pins[7] = d7; 
+
+  pinMode(_rs_pin, OUTPUT);
+  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
+  if (_rw_pin != 255) { 
+    pinMode(_rw_pin, OUTPUT);
+  }
+  pinMode(_enable_pin, OUTPUT);
+  
+  if (fourbitmode)
+    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  else 
+    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
+  
+  begin(16, 1);  
+}
+
+void LiquidCrystal::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
+  if (lines > 1) {
+    _displayfunction |= LCD_2LINE;
+  }
+  _numlines = lines;
+  _currline = 0;
+
+  // for some 1 line displays you can select a 10 pixel high font
+  if ((dotsize != 0) && (lines == 1)) {
+    _displayfunction |= LCD_5x10DOTS;
+  }
+
+  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
+  // according to datasheet, we need at least 40ms after power rises above 2.7V
+  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
+  delayMicroseconds(50000); 
+  // Now we pull both RS and R/W low to begin commands
+  digitalWrite(_rs_pin, LOW);
+  digitalWrite(_enable_pin, LOW);
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  //put the LCD into 4 bit or 8 bit mode
+  if (! (_displayfunction & LCD_8BITMODE)) {
+    // this is according to the hitachi HD44780 datasheet
+    // figure 24, pg 46
+
+    // we start in 8bit mode, try to set 4 bit mode
+    write4bits(0x03);
+    delayMicroseconds(4500); // wait min 4.1ms
+
+    // second try
+    write4bits(0x03);
+    delayMicroseconds(4500); // wait min 4.1ms
+    
+    // third go!
+    write4bits(0x03); 
+    delayMicroseconds(150);
+
+    // finally, set to 4-bit interface
+    write4bits(0x02); 
+  } else {
+    // this is according to the hitachi HD44780 datasheet
+    // page 45 figure 23
+
+    // Send function set command sequence
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(4500);  // wait more than 4.1ms
+
+    // second try
+    command(LCD_FUNCTIONSET | _displayfunction);
+    delayMicroseconds(150);
+
+    // third go
+    command(LCD_FUNCTIONSET | _displayfunction);
+  }
+
+  // finally, set # lines, font size, etc.
+  command(LCD_FUNCTIONSET | _displayfunction);  
+
+  // turn the display on with no cursor or blinking default
+  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
+  display();
+
+  // clear it off
+  clear();
+
+  // Initialize to default text direction (for romance languages)
+  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
+  // set the entry mode
+  command(LCD_ENTRYMODESET | _displaymode);
+
+}
+
+/********** high level commands, for the user! */
+void LiquidCrystal::clear()
+{
+  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystal::home()
+{
+  command(LCD_RETURNHOME);  // set cursor position to zero
+  delayMicroseconds(2000);  // this command takes a long time!
+}
+
+void LiquidCrystal::setCursor(uint8_t col, uint8_t row)
+{
+  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
+  if ( row >= _numlines ) {
+    row = _numlines-1;    // we count rows starting w/0
+  }
+  
+  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
+}
+
+// Turn the display on/off (quickly)
+void LiquidCrystal::noDisplay() {
+  _displaycontrol &= ~LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystal::display() {
+  _displaycontrol |= LCD_DISPLAYON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turns the underline cursor on/off
+void LiquidCrystal::noCursor() {
+  _displaycontrol &= ~LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystal::cursor() {
+  _displaycontrol |= LCD_CURSORON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// Turn on and off the blinking cursor
+void LiquidCrystal::noBlink() {
+  _displaycontrol &= ~LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+void LiquidCrystal::blink() {
+  _displaycontrol |= LCD_BLINKON;
+  command(LCD_DISPLAYCONTROL | _displaycontrol);
+}
+
+// These commands scroll the display without changing the RAM
+void LiquidCrystal::scrollDisplayLeft(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
+}
+void LiquidCrystal::scrollDisplayRight(void) {
+  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
+}
+
+// This is for text that flows Left to Right
+void LiquidCrystal::leftToRight(void) {
+  _displaymode |= LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This is for text that flows Right to Left
+void LiquidCrystal::rightToLeft(void) {
+  _displaymode &= ~LCD_ENTRYLEFT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'right justify' text from the cursor
+void LiquidCrystal::autoscroll(void) {
+  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// This will 'left justify' text from the cursor
+void LiquidCrystal::noAutoscroll(void) {
+  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
+  command(LCD_ENTRYMODESET | _displaymode);
+}
+
+// Allows us to fill the first 8 CGRAM locations
+// with custom characters
+void LiquidCrystal::createChar(uint8_t location, uint8_t charmap[]) {
+  location &= 0x7; // we only have 8 locations 0-7
+  command(LCD_SETCGRAMADDR | (location << 3));
+  for (int i=0; i<8; i++) {
+    write(charmap[i]);
+  }
+}
+
+/*********** mid level commands, for sending data/cmds */
+
+inline void LiquidCrystal::command(uint8_t value) {
+  send(value, LOW);
+}
+
+inline size_t LiquidCrystal::write(uint8_t value) {
+  send(value, HIGH);
+  return 1; // assume sucess
+}
+
+/************ low level data pushing commands **********/
+
+// write either command or data, with automatic 4/8-bit selection
+void LiquidCrystal::send(uint8_t value, uint8_t mode) {
+  digitalWrite(_rs_pin, mode);
+
+  // if there is a RW pin indicated, set it low to Write
+  if (_rw_pin != 255) { 
+    digitalWrite(_rw_pin, LOW);
+  }
+  
+  if (_displayfunction & LCD_8BITMODE) {
+    write8bits(value); 
+  } else {
+    write4bits(value>>4);
+    write4bits(value);
+  }
+}
+
+void LiquidCrystal::pulseEnable(void) {
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(1);    
+  digitalWrite(_enable_pin, HIGH);
+  delayMicroseconds(1);    // enable pulse must be >450ns
+  digitalWrite(_enable_pin, LOW);
+  delayMicroseconds(100);   // commands need > 37us to settle
+}
+
+void LiquidCrystal::write4bits(uint8_t value) {
+  for (int i = 0; i < 4; i++) {
+    pinMode(_data_pins[i], OUTPUT);
+    digitalWrite(_data_pins[i], (value >> i) & 0x01);
+  }
+
+  pulseEnable();
+}
+
+void LiquidCrystal::write8bits(uint8_t value) {
+  for (int i = 0; i < 8; i++) {
+    pinMode(_data_pins[i], OUTPUT);
+    digitalWrite(_data_pins[i], (value >> i) & 0x01);
+  }
+  
+  pulseEnable();
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.h
new file mode 100644
index 0000000..24ec5af
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/LiquidCrystal.h
@@ -0,0 +1,106 @@
+#ifndef LiquidCrystal_h
+#define LiquidCrystal_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+// commands
+#define LCD_CLEARDISPLAY 0x01
+#define LCD_RETURNHOME 0x02
+#define LCD_ENTRYMODESET 0x04
+#define LCD_DISPLAYCONTROL 0x08
+#define LCD_CURSORSHIFT 0x10
+#define LCD_FUNCTIONSET 0x20
+#define LCD_SETCGRAMADDR 0x40
+#define LCD_SETDDRAMADDR 0x80
+
+// flags for display entry mode
+#define LCD_ENTRYRIGHT 0x00
+#define LCD_ENTRYLEFT 0x02
+#define LCD_ENTRYSHIFTINCREMENT 0x01
+#define LCD_ENTRYSHIFTDECREMENT 0x00
+
+// flags for display on/off control
+#define LCD_DISPLAYON 0x04
+#define LCD_DISPLAYOFF 0x00
+#define LCD_CURSORON 0x02
+#define LCD_CURSOROFF 0x00
+#define LCD_BLINKON 0x01
+#define LCD_BLINKOFF 0x00
+
+// flags for display/cursor shift
+#define LCD_DISPLAYMOVE 0x08
+#define LCD_CURSORMOVE 0x00
+#define LCD_MOVERIGHT 0x04
+#define LCD_MOVELEFT 0x00
+
+// flags for function set
+#define LCD_8BITMODE 0x10
+#define LCD_4BITMODE 0x00
+#define LCD_2LINE 0x08
+#define LCD_1LINE 0x00
+#define LCD_5x10DOTS 0x04
+#define LCD_5x8DOTS 0x00
+
+class LiquidCrystal : public Print {
+public:
+  LiquidCrystal(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+  LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+  LiquidCrystal(uint8_t rs, uint8_t enable,
+		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
+
+  void init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
+	    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
+	    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
+    
+  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);
+
+  void clear();
+  void home();
+
+  void noDisplay();
+  void display();
+  void noBlink();
+  void blink();
+  void noCursor();
+  void cursor();
+  void scrollDisplayLeft();
+  void scrollDisplayRight();
+  void leftToRight();
+  void rightToLeft();
+  void autoscroll();
+  void noAutoscroll();
+
+  void createChar(uint8_t, uint8_t[]);
+  void setCursor(uint8_t, uint8_t); 
+  virtual size_t write(uint8_t);
+  void command(uint8_t);
+  
+  using Print::write;
+private:
+  void send(uint8_t, uint8_t);
+  void write4bits(uint8_t);
+  void write8bits(uint8_t);
+  void pulseEnable();
+
+  uint8_t _rs_pin; // LOW: command.  HIGH: character.
+  uint8_t _rw_pin; // LOW: write to LCD.  HIGH: read from LCD.
+  uint8_t _enable_pin; // activated by a HIGH pulse.
+  uint8_t _data_pins[8];
+
+  uint8_t _displayfunction;
+  uint8_t _displaycontrol;
+  uint8_t _displaymode;
+
+  uint8_t _initialized;
+
+  uint8_t _numlines,_currline;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/keywords.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/keywords.txt
new file mode 100644
index 0000000..132845c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/LiquidCrystal/keywords.txt
@@ -0,0 +1,37 @@
+#######################################
+# Syntax Coloring Map For LiquidCrystal
+#######################################
+
+#######################################
+# Datatypes (KEYWORD1)
+#######################################
+
+LiquidCrystal	KEYWORD1
+
+#######################################
+# Methods and Functions (KEYWORD2)
+#######################################
+
+begin	KEYWORD2
+clear	KEYWORD2
+home	KEYWORD2
+print	KEYWORD2
+setCursor	KEYWORD2
+cursor	KEYWORD2
+noCursor	KEYWORD2
+blink	KEYWORD2
+noBlink	KEYWORD2
+display	KEYWORD2
+noDisplay	KEYWORD2
+autoscroll	KEYWORD2
+noAutoscroll	KEYWORD2
+leftToRight	KEYWORD2
+rightToLeft	KEYWORD2
+scrollDisplayLeft	KEYWORD2
+scrollDisplayRight	KEYWORD2
+createChar	KEYWORD2
+
+#######################################
+# Constants (LITERAL1)
+#######################################
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.cpp
new file mode 100644
index 0000000..5e48073
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2010 by Cristian Maglie <c.maglie@bug.st>
+ * SPI Master library for arduino.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of either the GNU General Public License version 2
+ * or the GNU Lesser General Public License version 2.1, both as
+ * published by the Free Software Foundation.
+ */
+
+#include "pins_arduino.h"
+#include "SPI.h"
+
+SPIClass SPI;
+
+void SPIClass::begin() {
+
+  // Set SS to high so a connected chip will be "deselected" by default
+  digitalWrite(SS, HIGH);
+
+  // When the SS pin is set as OUTPUT, it can be used as
+  // a general purpose output port (it doesn't influence
+  // SPI operations).
+  pinMode(SS, OUTPUT);
+
+  // Warning: if the SS pin ever becomes a LOW INPUT then SPI
+  // automatically switches to Slave, so the data direction of
+  // the SS pin MUST be kept as OUTPUT.
+  SPCR |= _BV(MSTR);
+  SPCR |= _BV(SPE);
+
+  // Set direction register for SCK and MOSI pin.
+  // MISO pin automatically overrides to INPUT.
+  // By doing this AFTER enabling SPI, we avoid accidentally
+  // clocking in a single bit since the lines go directly
+  // from "input" to SPI control.  
+  // http://code.google.com/p/arduino/issues/detail?id=888
+  pinMode(SCK, OUTPUT);
+  pinMode(MOSI, OUTPUT);
+}
+
+
+void SPIClass::end() {
+  SPCR &= ~_BV(SPE);
+}
+
+void SPIClass::setBitOrder(uint8_t bitOrder)
+{
+  if(bitOrder == LSBFIRST) {
+    SPCR |= _BV(DORD);
+  } else {
+    SPCR &= ~(_BV(DORD));
+  }
+}
+
+void SPIClass::setDataMode(uint8_t mode)
+{
+  SPCR = (SPCR & ~SPI_MODE_MASK) | mode;
+}
+
+void SPIClass::setClockDivider(uint8_t rate)
+{
+  SPCR = (SPCR & ~SPI_CLOCK_MASK) | (rate & SPI_CLOCK_MASK);
+  SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((rate >> 2) & SPI_2XCLOCK_MASK);
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.h
new file mode 100644
index 0000000..f647d5c
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/SPI.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2010 by Cristian Maglie <c.maglie@bug.st>
+ * SPI Master library for arduino.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of either the GNU General Public License version 2
+ * or the GNU Lesser General Public License version 2.1, both as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _SPI_H_INCLUDED
+#define _SPI_H_INCLUDED
+
+#include <stdio.h>
+#include <Arduino.h>
+#include <avr/pgmspace.h>
+
+#define SPI_CLOCK_DIV4 0x00
+#define SPI_CLOCK_DIV16 0x01
+#define SPI_CLOCK_DIV64 0x02
+#define SPI_CLOCK_DIV128 0x03
+#define SPI_CLOCK_DIV2 0x04
+#define SPI_CLOCK_DIV8 0x05
+#define SPI_CLOCK_DIV32 0x06
+//#define SPI_CLOCK_DIV64 0x07
+
+#define SPI_MODE0 0x00
+#define SPI_MODE1 0x04
+#define SPI_MODE2 0x08
+#define SPI_MODE3 0x0C
+
+#define SPI_MODE_MASK 0x0C  // CPOL = bit 3, CPHA = bit 2 on SPCR
+#define SPI_CLOCK_MASK 0x03  // SPR1 = bit 1, SPR0 = bit 0 on SPCR
+#define SPI_2XCLOCK_MASK 0x01  // SPI2X = bit 0 on SPSR
+
+class SPIClass {
+public:
+  inline static byte transfer(byte _data);
+
+  // SPI Configuration methods
+
+  inline static void attachInterrupt();
+  inline static void detachInterrupt(); // Default
+
+  static void begin(); // Default
+  static void end();
+
+  static void setBitOrder(uint8_t);
+  static void setDataMode(uint8_t);
+  static void setClockDivider(uint8_t);
+};
+
+extern SPIClass SPI;
+
+byte SPIClass::transfer(byte _data) {
+  SPDR = _data;
+  while (!(SPSR & _BV(SPIF)))
+    ;
+  return SPDR;
+}
+
+void SPIClass::attachInterrupt() {
+  SPCR |= _BV(SPIE);
+}
+
+void SPIClass::detachInterrupt() {
+  SPCR &= ~_BV(SPIE);
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/keywords.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/keywords.txt
new file mode 100644
index 0000000..fa76165
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/SPI/keywords.txt
@@ -0,0 +1,36 @@
+#######################################
+# Syntax Coloring Map SPI
+#######################################
+
+#######################################
+# Datatypes (KEYWORD1)
+#######################################
+
+SPI	KEYWORD1
+
+#######################################
+# Methods and Functions (KEYWORD2)
+#######################################
+begin	KEYWORD2
+end	KEYWORD2
+transfer	KEYWORD2
+setBitOrder	KEYWORD2
+setDataMode	KEYWORD2
+setClockDivider	KEYWORD2
+
+
+#######################################
+# Constants (LITERAL1)
+#######################################
+SPI_CLOCK_DIV4	LITERAL1
+SPI_CLOCK_DIV16	LITERAL1
+SPI_CLOCK_DIV64	LITERAL1
+SPI_CLOCK_DIV128	LITERAL1
+SPI_CLOCK_DIV2	LITERAL1
+SPI_CLOCK_DIV8	LITERAL1
+SPI_CLOCK_DIV32	LITERAL1
+SPI_CLOCK_DIV64	LITERAL1
+SPI_MODE0	LITERAL1
+SPI_MODE1	LITERAL1
+SPI_MODE2	LITERAL1
+SPI_MODE3	LITERAL1
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.cpp b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.cpp
new file mode 100644
index 0000000..553add7
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.cpp
@@ -0,0 +1,303 @@
+/*
+  TwoWire.cpp - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+extern "C" {
+  #include <stdlib.h>
+  #include <string.h>
+  #include <inttypes.h>
+  #include "twi.h"
+}
+
+#include "Wire.h"
+
+// Initialize Class Variables //////////////////////////////////////////////////
+
+uint8_t TwoWire::rxBuffer[BUFFER_LENGTH];
+uint8_t TwoWire::rxBufferIndex = 0;
+uint8_t TwoWire::rxBufferLength = 0;
+
+uint8_t TwoWire::txAddress = 0;
+uint8_t TwoWire::txBuffer[BUFFER_LENGTH];
+uint8_t TwoWire::txBufferIndex = 0;
+uint8_t TwoWire::txBufferLength = 0;
+
+uint8_t TwoWire::transmitting = 0;
+void (*TwoWire::user_onRequest)(void);
+void (*TwoWire::user_onReceive)(int);
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+TwoWire::TwoWire()
+{
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void TwoWire::begin(void)
+{
+  rxBufferIndex = 0;
+  rxBufferLength = 0;
+
+  txBufferIndex = 0;
+  txBufferLength = 0;
+
+  twi_init();
+}
+
+void TwoWire::begin(uint8_t address)
+{
+  twi_setAddress(address);
+  twi_attachSlaveTxEvent(onRequestService);
+  twi_attachSlaveRxEvent(onReceiveService);
+  begin();
+}
+
+void TwoWire::begin(int address)
+{
+  begin((uint8_t)address);
+}
+
+void TwoWire::setClock(uint32_t frequency)
+{
+  TWBR = ((F_CPU / frequency) - 16) / 2;
+}
+
+uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)
+{
+  // clamp to buffer length
+  if(quantity > BUFFER_LENGTH){
+    quantity = BUFFER_LENGTH;
+  }
+  // perform blocking read into buffer
+  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
+  // set rx buffer iterator vars
+  rxBufferIndex = 0;
+  rxBufferLength = read;
+
+  return read;
+}
+
+uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
+}
+
+uint8_t TwoWire::requestFrom(int address, int quantity)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
+}
+
+uint8_t TwoWire::requestFrom(int address, int quantity, int sendStop)
+{
+  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
+}
+
+void TwoWire::beginTransmission(uint8_t address)
+{
+  // indicate that we are transmitting
+  transmitting = 1;
+  // set address of targeted slave
+  txAddress = address;
+  // reset tx buffer iterator vars
+  txBufferIndex = 0;
+  txBufferLength = 0;
+}
+
+void TwoWire::beginTransmission(int address)
+{
+  beginTransmission((uint8_t)address);
+}
+
+//
+//	Originally, 'endTransmission' was an f(void) function.
+//	It has been modified to take one parameter indicating
+//	whether or not a STOP should be performed on the bus.
+//	Calling endTransmission(false) allows a sketch to 
+//	perform a repeated start. 
+//
+//	WARNING: Nothing in the library keeps track of whether
+//	the bus tenure has been properly ended with a STOP. It
+//	is very possible to leave the bus in a hung state if
+//	no call to endTransmission(true) is made. Some I2C
+//	devices will behave oddly if they do not see a STOP.
+//
+uint8_t TwoWire::endTransmission(uint8_t sendStop)
+{
+  // transmit buffer (blocking)
+  int8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
+  // reset tx buffer iterator vars
+  txBufferIndex = 0;
+  txBufferLength = 0;
+  // indicate that we are done transmitting
+  transmitting = 0;
+  return ret;
+}
+
+//	This provides backwards compatibility with the original
+//	definition, and expected behaviour, of endTransmission
+//
+uint8_t TwoWire::endTransmission(void)
+{
+  return endTransmission(true);
+}
+
+// must be called in:
+// slave tx event callback
+// or after beginTransmission(address)
+size_t TwoWire::write(uint8_t data)
+{
+  if(transmitting){
+  // in master transmitter mode
+    // don't bother if buffer is full
+    if(txBufferLength >= BUFFER_LENGTH){
+      setWriteError();
+      return 0;
+    }
+    // put byte in tx buffer
+    txBuffer[txBufferIndex] = data;
+    ++txBufferIndex;
+    // update amount in buffer   
+    txBufferLength = txBufferIndex;
+  }else{
+  // in slave send mode
+    // reply to master
+    twi_transmit(&data, 1);
+  }
+  return 1;
+}
+
+// must be called in:
+// slave tx event callback
+// or after beginTransmission(address)
+size_t TwoWire::write(const uint8_t *data, size_t quantity)
+{
+  if(transmitting){
+  // in master transmitter mode
+    for(size_t i = 0; i < quantity; ++i){
+      write(data[i]);
+    }
+  }else{
+  // in slave send mode
+    // reply to master
+    twi_transmit(data, quantity);
+  }
+  return quantity;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+int TwoWire::available(void)
+{
+  return rxBufferLength - rxBufferIndex;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+int TwoWire::read(void)
+{
+  int value = -1;
+  
+  // get each successive byte on each call
+  if(rxBufferIndex < rxBufferLength){
+    value = rxBuffer[rxBufferIndex];
+    ++rxBufferIndex;
+  }
+
+  return value;
+}
+
+// must be called in:
+// slave rx event callback
+// or after requestFrom(address, numBytes)
+int TwoWire::peek(void)
+{
+  int value = -1;
+  
+  if(rxBufferIndex < rxBufferLength){
+    value = rxBuffer[rxBufferIndex];
+  }
+
+  return value;
+}
+
+void TwoWire::flush(void)
+{
+  // XXX: to be implemented.
+}
+
+// behind the scenes function that is called when data is received
+void TwoWire::onReceiveService(uint8_t* inBytes, int numBytes)
+{
+  // don't bother if user hasn't registered a callback
+  if(!user_onReceive){
+    return;
+  }
+  // don't bother if rx buffer is in use by a master requestFrom() op
+  // i know this drops data, but it allows for slight stupidity
+  // meaning, they may not have read all the master requestFrom() data yet
+  if(rxBufferIndex < rxBufferLength){
+    return;
+  }
+  // copy twi rx buffer into local read buffer
+  // this enables new reads to happen in parallel
+  for(uint8_t i = 0; i < numBytes; ++i){
+    rxBuffer[i] = inBytes[i];    
+  }
+  // set rx iterator vars
+  rxBufferIndex = 0;
+  rxBufferLength = numBytes;
+  // alert user program
+  user_onReceive(numBytes);
+}
+
+// behind the scenes function that is called when data is requested
+void TwoWire::onRequestService(void)
+{
+  // don't bother if user hasn't registered a callback
+  if(!user_onRequest){
+    return;
+  }
+  // reset tx buffer iterator vars
+  // !!! this will kill any pending pre-master sendTo() activity
+  txBufferIndex = 0;
+  txBufferLength = 0;
+  // alert user program
+  user_onRequest();
+}
+
+// sets function called on slave write
+void TwoWire::onReceive( void (*function)(int) )
+{
+  user_onReceive = function;
+}
+
+// sets function called on slave read
+void TwoWire::onRequest( void (*function)(void) )
+{
+  user_onRequest = function;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+TwoWire Wire = TwoWire();
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.h
new file mode 100644
index 0000000..732bdc3
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/Wire.h
@@ -0,0 +1,80 @@
+/*
+  TwoWire.h - TWI/I2C library for Arduino & Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+#ifndef TwoWire_h
+#define TwoWire_h
+
+#include <inttypes.h>
+#include "Stream.h"
+
+#define BUFFER_LENGTH 32
+
+class TwoWire : public Stream
+{
+  private:
+    static uint8_t rxBuffer[];
+    static uint8_t rxBufferIndex;
+    static uint8_t rxBufferLength;
+
+    static uint8_t txAddress;
+    static uint8_t txBuffer[];
+    static uint8_t txBufferIndex;
+    static uint8_t txBufferLength;
+
+    static uint8_t transmitting;
+    static void (*user_onRequest)(void);
+    static void (*user_onReceive)(int);
+    static void onRequestService(void);
+    static void onReceiveService(uint8_t*, int);
+  public:
+    TwoWire();
+    void begin();
+    void begin(uint8_t);
+    void begin(int);
+    void setClock(uint32_t);
+    void beginTransmission(uint8_t);
+    void beginTransmission(int);
+    uint8_t endTransmission(void);
+    uint8_t endTransmission(uint8_t);
+    uint8_t requestFrom(uint8_t, uint8_t);
+    uint8_t requestFrom(uint8_t, uint8_t, uint8_t);
+    uint8_t requestFrom(int, int);
+    uint8_t requestFrom(int, int, int);
+    virtual size_t write(uint8_t);
+    virtual size_t write(const uint8_t *, size_t);
+    virtual int available(void);
+    virtual int read(void);
+    virtual int peek(void);
+    virtual void flush(void);
+    void onReceive( void (*)(int) );
+    void onRequest( void (*)(void) );
+
+    inline size_t write(unsigned long n) { return write((uint8_t)n); }
+    inline size_t write(long n) { return write((uint8_t)n); }
+    inline size_t write(unsigned int n) { return write((uint8_t)n); }
+    inline size_t write(int n) { return write((uint8_t)n); }
+    using Print::write;
+};
+
+extern TwoWire Wire;
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/SFRRanger_reader/SFRRanger_reader.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/SFRRanger_reader/SFRRanger_reader.ino
new file mode 100644
index 0000000..d97a9e3
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/SFRRanger_reader/SFRRanger_reader.ino
@@ -0,0 +1,87 @@
+// I2C SRF10 or SRF08 Devantech Ultrasonic Ranger Finder
+// by Nicholas Zambetti <http://www.zambetti.com>
+// and James Tichenor <http://www.jamestichenor.net>
+
+// Demonstrates use of the Wire library reading data from the
+// Devantech Utrasonic Rangers SFR08 and SFR10
+
+// Created 29 April 2006
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin();                // join i2c bus (address optional for master)
+  Serial.begin(9600);          // start serial communication at 9600bps
+}
+
+int reading = 0;
+
+void loop()
+{
+  // step 1: instruct sensor to read echoes
+  Wire.beginTransmission(112); // transmit to device #112 (0x70)
+  // the address specified in the datasheet is 224 (0xE0)
+  // but i2c adressing uses the high 7 bits so it's 112
+  Wire.write(byte(0x00));      // sets register pointer to the command register (0x00)
+  Wire.write(byte(0x50));      // command sensor to measure in "inches" (0x50)
+  // use 0x51 for centimeters
+  // use 0x52 for ping microseconds
+  Wire.endTransmission();      // stop transmitting
+
+  // step 2: wait for readings to happen
+  delay(70);                   // datasheet suggests at least 65 milliseconds
+
+  // step 3: instruct sensor to return a particular echo reading
+  Wire.beginTransmission(112); // transmit to device #112
+  Wire.write(byte(0x02));      // sets register pointer to echo #1 register (0x02)
+  Wire.endTransmission();      // stop transmitting
+
+  // step 4: request reading from sensor
+  Wire.requestFrom(112, 2);    // request 2 bytes from slave device #112
+
+  // step 5: receive reading from sensor
+  if (2 <= Wire.available())   // if two bytes were received
+  {
+    reading = Wire.read();  // receive high byte (overwrites previous reading)
+    reading = reading << 8;    // shift high byte to be high 8 bits
+    reading |= Wire.read(); // receive low byte as lower 8 bits
+    Serial.println(reading);   // print the reading
+  }
+
+  delay(250);                  // wait a bit since people have to read the output :)
+}
+
+
+/*
+
+// The following code changes the address of a Devantech Ultrasonic Range Finder (SRF10 or SRF08)
+// usage: changeAddress(0x70, 0xE6);
+
+void changeAddress(byte oldAddress, byte newAddress)
+{
+  Wire.beginTransmission(oldAddress);
+  Wire.write(byte(0x00));
+  Wire.write(byte(0xA0));
+  Wire.endTransmission();
+
+  Wire.beginTransmission(oldAddress);
+  Wire.write(byte(0x00));
+  Wire.write(byte(0xAA));
+  Wire.endTransmission();
+
+  Wire.beginTransmission(oldAddress);
+  Wire.write(byte(0x00));
+  Wire.write(byte(0xA5));
+  Wire.endTransmission();
+
+  Wire.beginTransmission(oldAddress);
+  Wire.write(byte(0x00));
+  Wire.write(newAddress);
+  Wire.endTransmission();
+}
+
+*/
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/digital_potentiometer/digital_potentiometer.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/digital_potentiometer/digital_potentiometer.ino
new file mode 100644
index 0000000..4d1580a
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/digital_potentiometer/digital_potentiometer.ino
@@ -0,0 +1,39 @@
+// I2C Digital Potentiometer
+// by Nicholas Zambetti <http://www.zambetti.com>
+// and Shawn Bonkowski <http://people.interaction-ivrea.it/s.bonkowski/>
+
+// Demonstrates use of the Wire library
+// Controls AD5171 digital potentiometer via I2C/TWI
+
+// Created 31 March 2006
+
+// This example code is in the public domain.
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin(); // join i2c bus (address optional for master)
+}
+
+byte val = 0;
+
+void loop()
+{
+  Wire.beginTransmission(44); // transmit to device #44 (0x2c)
+  // device address is specified in datasheet
+  Wire.write(byte(0x00));            // sends instruction byte
+  Wire.write(val);             // sends potentiometer value byte
+  Wire.endTransmission();     // stop transmitting
+
+  val++;        // increment value
+  if (val == 64) // if reached 64th position (max)
+  {
+    val = 0;    // start over from lowest value
+  }
+  delay(500);
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_reader/master_reader.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_reader/master_reader.ino
new file mode 100644
index 0000000..74f0155
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_reader/master_reader.ino
@@ -0,0 +1,32 @@
+// Wire Master Reader
+// by Nicholas Zambetti <http://www.zambetti.com>
+
+// Demonstrates use of the Wire library
+// Reads data from an I2C/TWI slave device
+// Refer to the "Wire Slave Sender" example for use with this
+
+// Created 29 March 2006
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin();        // join i2c bus (address optional for master)
+  Serial.begin(9600);  // start serial for output
+}
+
+void loop()
+{
+  Wire.requestFrom(2, 6);    // request 6 bytes from slave device #2
+
+  while (Wire.available())   // slave may send less than requested
+  {
+    char c = Wire.read(); // receive a byte as character
+    Serial.print(c);         // print the character
+  }
+
+  delay(500);
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_writer/master_writer.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_writer/master_writer.ino
new file mode 100644
index 0000000..482e922
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/master_writer/master_writer.ino
@@ -0,0 +1,31 @@
+// Wire Master Writer
+// by Nicholas Zambetti <http://www.zambetti.com>
+
+// Demonstrates use of the Wire library
+// Writes data to an I2C/TWI slave device
+// Refer to the "Wire Slave Receiver" example for use with this
+
+// Created 29 March 2006
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin(); // join i2c bus (address optional for master)
+}
+
+byte x = 0;
+
+void loop()
+{
+  Wire.beginTransmission(4); // transmit to device #4
+  Wire.write("x is ");        // sends five bytes
+  Wire.write(x);              // sends one byte
+  Wire.endTransmission();    // stop transmitting
+
+  x++;
+  delay(500);
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_receiver/slave_receiver.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_receiver/slave_receiver.ino
new file mode 100644
index 0000000..15eff9a
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_receiver/slave_receiver.ino
@@ -0,0 +1,38 @@
+// Wire Slave Receiver
+// by Nicholas Zambetti <http://www.zambetti.com>
+
+// Demonstrates use of the Wire library
+// Receives data as an I2C/TWI slave device
+// Refer to the "Wire Master Writer" example for use with this
+
+// Created 29 March 2006
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin(4);                // join i2c bus with address #4
+  Wire.onReceive(receiveEvent); // register event
+  Serial.begin(9600);           // start serial for output
+}
+
+void loop()
+{
+  delay(100);
+}
+
+// function that executes whenever data is received from master
+// this function is registered as an event, see setup()
+void receiveEvent(int howMany)
+{
+  while (1 < Wire.available()) // loop through all but the last
+  {
+    char c = Wire.read(); // receive byte as a character
+    Serial.print(c);         // print the character
+  }
+  int x = Wire.read();    // receive byte as an integer
+  Serial.println(x);         // print the integer
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_sender/slave_sender.ino b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_sender/slave_sender.ino
new file mode 100644
index 0000000..4437ab1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/examples/slave_sender/slave_sender.ino
@@ -0,0 +1,32 @@
+// Wire Slave Sender
+// by Nicholas Zambetti <http://www.zambetti.com>
+
+// Demonstrates use of the Wire library
+// Sends data as an I2C/TWI slave device
+// Refer to the "Wire Master Reader" example for use with this
+
+// Created 29 March 2006
+
+// This example code is in the public domain.
+
+
+#include <Wire.h>
+
+void setup()
+{
+  Wire.begin(2);                // join i2c bus with address #2
+  Wire.onRequest(requestEvent); // register event
+}
+
+void loop()
+{
+  delay(100);
+}
+
+// function that executes whenever data is requested by master
+// this function is registered as an event, see setup()
+void requestEvent()
+{
+  Wire.write("hello "); // respond with message of 6 bytes
+  // as expected by master
+}
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/keywords.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/keywords.txt
new file mode 100644
index 0000000..ff31475
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/keywords.txt
@@ -0,0 +1,32 @@
+#######################################
+# Syntax Coloring Map For Wire
+#######################################
+
+#######################################
+# Datatypes (KEYWORD1)
+#######################################
+
+#######################################
+# Methods and Functions (KEYWORD2)
+#######################################
+
+begin	KEYWORD2
+setClock	KEYWORD2
+beginTransmission	KEYWORD2
+endTransmission	KEYWORD2
+requestFrom	KEYWORD2
+send	KEYWORD2
+receive	KEYWORD2
+onReceive	KEYWORD2
+onRequest	KEYWORD2
+
+#######################################
+# Instances (KEYWORD2)
+#######################################
+
+Wire	KEYWORD2
+
+#######################################
+# Constants (LITERAL1)
+#######################################
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/library.properties b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/library.properties
new file mode 100644
index 0000000..3246a75
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/library.properties
@@ -0,0 +1,8 @@
+name=Wire
+version=1.0
+author=Arduino
+maintainer=Arduino <info@arduino.cc>
+sentence=Allows the communication between devices or sensors connected via Two Wire Interface Bus. For all Arduino boards, BUT Arduino DUE. 
+paragraph=
+url=http://arduino.cc/en/Reference/Wire
+architectures=avr
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.c b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.c
new file mode 100644
index 0000000..201d7d1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.c
@@ -0,0 +1,527 @@
+/*
+  twi.c - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 2012 by Todd Krein (todd@krein.org) to implement repeated starts
+*/
+
+#include <math.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <compat/twi.h>
+#include "Arduino.h" // for digitalWrite
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#include "pins_arduino.h"
+#include "twi.h"
+
+static volatile uint8_t twi_state;
+static volatile uint8_t twi_slarw;
+static volatile uint8_t twi_sendStop;			// should the transaction end with a stop
+static volatile uint8_t twi_inRepStart;			// in the middle of a repeated start
+
+static void (*twi_onSlaveTransmit)(void);
+static void (*twi_onSlaveReceive)(uint8_t*, int);
+
+static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_masterBufferIndex;
+static volatile uint8_t twi_masterBufferLength;
+
+static uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_txBufferIndex;
+static volatile uint8_t twi_txBufferLength;
+
+static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];
+static volatile uint8_t twi_rxBufferIndex;
+
+static volatile uint8_t twi_error;
+
+/* 
+ * Function twi_init
+ * Desc     readys twi pins and sets twi bitrate
+ * Input    none
+ * Output   none
+ */
+void twi_init(void)
+{
+  // initialize state
+  twi_state = TWI_READY;
+  twi_sendStop = true;		// default value
+  twi_inRepStart = false;
+  
+  // activate internal pullups for twi.
+  digitalWrite(SDA, 1);
+  digitalWrite(SCL, 1);
+
+  // initialize twi prescaler and bit rate
+  cbi(TWSR, TWPS0);
+  cbi(TWSR, TWPS1);
+  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
+
+  /* twi bit rate formula from atmega128 manual pg 204
+  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
+  note: TWBR should be 10 or higher for master mode
+  It is 72 for a 16mhz Wiring board with 100kHz TWI */
+
+  // enable twi module, acks, and twi interrupt
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
+}
+
+/* 
+ * Function twi_slaveInit
+ * Desc     sets slave address and enables interrupt
+ * Input    none
+ * Output   none
+ */
+void twi_setAddress(uint8_t address)
+{
+  // set twi slave address (skip over TWGCE bit)
+  TWAR = address << 1;
+}
+
+/* 
+ * Function twi_readFrom
+ * Desc     attempts to become twi bus master and read a
+ *          series of bytes from a device on the bus
+ * Input    address: 7bit i2c device address
+ *          data: pointer to byte array
+ *          length: number of bytes to read into array
+ *          sendStop: Boolean indicating whether to send a stop at the end
+ * Output   number of bytes read
+ */
+uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 0;
+  }
+
+  // wait until twi is ready, become master receiver
+  while(TWI_READY != twi_state){
+    continue;
+  }
+  twi_state = TWI_MRX;
+  twi_sendStop = sendStop;
+  // reset error state (0xFF.. no error occured)
+  twi_error = 0xFF;
+
+  // initialize buffer iteration vars
+  twi_masterBufferIndex = 0;
+  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
+  // On receive, the previously configured ACK/NACK setting is transmitted in
+  // response to the received byte before the interrupt is signalled. 
+  // Therefor we must actually set NACK when the _next_ to last byte is
+  // received, causing that NACK to be sent in response to receiving the last
+  // expected byte of data.
+
+  // build sla+w, slave device address + w bit
+  twi_slarw = TW_READ;
+  twi_slarw |= address << 1;
+
+  if (true == twi_inRepStart) {
+    // if we're in the repeated start state, then we've already sent the start,
+    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
+    // We need to remove ourselves from the repeated start state before we enable interrupts,
+    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
+    // up. Also, don't enable the START interrupt. There may be one pending from the 
+    // repeated start that we sent outselves, and that would really confuse things.
+    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
+    TWDR = twi_slarw;
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
+  }
+  else
+    // send start condition
+    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
+
+  // wait for read operation to complete
+  while(TWI_MRX == twi_state){
+    continue;
+  }
+
+  if (twi_masterBufferIndex < length)
+    length = twi_masterBufferIndex;
+
+  // copy twi buffer to data
+  for(i = 0; i < length; ++i){
+    data[i] = twi_masterBuffer[i];
+  }
+	
+  return length;
+}
+
+/* 
+ * Function twi_writeTo
+ * Desc     attempts to become twi bus master and write a
+ *          series of bytes to a device on the bus
+ * Input    address: 7bit i2c device address
+ *          data: pointer to byte array
+ *          length: number of bytes in array
+ *          wait: boolean indicating to wait for write or not
+ *          sendStop: boolean indicating whether or not to send a stop at the end
+ * Output   0 .. success
+ *          1 .. length to long for buffer
+ *          2 .. address send, NACK received
+ *          3 .. data send, NACK received
+ *          4 .. other twi error (lost bus arbitration, bus error, ..)
+ */
+uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 1;
+  }
+
+  // wait until twi is ready, become master transmitter
+  while(TWI_READY != twi_state){
+    continue;
+  }
+  twi_state = TWI_MTX;
+  twi_sendStop = sendStop;
+  // reset error state (0xFF.. no error occured)
+  twi_error = 0xFF;
+
+  // initialize buffer iteration vars
+  twi_masterBufferIndex = 0;
+  twi_masterBufferLength = length;
+  
+  // copy data to twi buffer
+  for(i = 0; i < length; ++i){
+    twi_masterBuffer[i] = data[i];
+  }
+  
+  // build sla+w, slave device address + w bit
+  twi_slarw = TW_WRITE;
+  twi_slarw |= address << 1;
+  
+  // if we're in a repeated start, then we've already sent the START
+  // in the ISR. Don't do it again.
+  //
+  if (true == twi_inRepStart) {
+    // if we're in the repeated start state, then we've already sent the start,
+    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
+    // We need to remove ourselves from the repeated start state before we enable interrupts,
+    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
+    // up. Also, don't enable the START interrupt. There may be one pending from the 
+    // repeated start that we sent outselves, and that would really confuse things.
+    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
+    TWDR = twi_slarw;				
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
+  }
+  else
+    // send start condition
+    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs
+
+  // wait for write operation to complete
+  while(wait && (TWI_MTX == twi_state)){
+    continue;
+  }
+  
+  if (twi_error == 0xFF)
+    return 0;	// success
+  else if (twi_error == TW_MT_SLA_NACK)
+    return 2;	// error: address send, nack received
+  else if (twi_error == TW_MT_DATA_NACK)
+    return 3;	// error: data send, nack received
+  else
+    return 4;	// other twi error
+}
+
+/* 
+ * Function twi_transmit
+ * Desc     fills slave tx buffer with data
+ *          must be called in slave tx event callback
+ * Input    data: pointer to byte array
+ *          length: number of bytes in array
+ * Output   1 length too long for buffer
+ *          2 not slave transmitter
+ *          0 ok
+ */
+uint8_t twi_transmit(const uint8_t* data, uint8_t length)
+{
+  uint8_t i;
+
+  // ensure data will fit into buffer
+  if(TWI_BUFFER_LENGTH < length){
+    return 1;
+  }
+  
+  // ensure we are currently a slave transmitter
+  if(TWI_STX != twi_state){
+    return 2;
+  }
+  
+  // set length and copy data into tx buffer
+  twi_txBufferLength = length;
+  for(i = 0; i < length; ++i){
+    twi_txBuffer[i] = data[i];
+  }
+  
+  return 0;
+}
+
+/* 
+ * Function twi_attachSlaveRxEvent
+ * Desc     sets function called before a slave read operation
+ * Input    function: callback function to use
+ * Output   none
+ */
+void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
+{
+  twi_onSlaveReceive = function;
+}
+
+/* 
+ * Function twi_attachSlaveTxEvent
+ * Desc     sets function called before a slave write operation
+ * Input    function: callback function to use
+ * Output   none
+ */
+void twi_attachSlaveTxEvent( void (*function)(void) )
+{
+  twi_onSlaveTransmit = function;
+}
+
+/* 
+ * Function twi_reply
+ * Desc     sends byte or readys receive line
+ * Input    ack: byte indicating to ack or to nack
+ * Output   none
+ */
+void twi_reply(uint8_t ack)
+{
+  // transmit master read ready signal, with or without ack
+  if(ack){
+    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
+  }else{
+	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
+  }
+}
+
+/* 
+ * Function twi_stop
+ * Desc     relinquishes bus master status
+ * Input    none
+ * Output   none
+ */
+void twi_stop(void)
+{
+  // send stop condition
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
+
+  // wait for stop condition to be exectued on bus
+  // TWINT is not set after a stop condition!
+  while(TWCR & _BV(TWSTO)){
+    continue;
+  }
+
+  // update twi state
+  twi_state = TWI_READY;
+}
+
+/* 
+ * Function twi_releaseBus
+ * Desc     releases bus control
+ * Input    none
+ * Output   none
+ */
+void twi_releaseBus(void)
+{
+  // release bus
+  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
+
+  // update twi state
+  twi_state = TWI_READY;
+}
+
+ISR(TWI_vect)
+{
+  switch(TW_STATUS){
+    // All Master
+    case TW_START:     // sent start condition
+    case TW_REP_START: // sent repeated start condition
+      // copy device address and r/w bit to output register and ack
+      TWDR = twi_slarw;
+      twi_reply(1);
+      break;
+
+    // Master Transmitter
+    case TW_MT_SLA_ACK:  // slave receiver acked address
+    case TW_MT_DATA_ACK: // slave receiver acked data
+      // if there is data to send, send it, otherwise stop 
+      if(twi_masterBufferIndex < twi_masterBufferLength){
+        // copy data to output register and ack
+        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
+        twi_reply(1);
+      }else{
+	if (twi_sendStop)
+          twi_stop();
+	else {
+	  twi_inRepStart = true;	// we're gonna send the START
+	  // don't enable the interrupt. We'll generate the start, but we 
+	  // avoid handling the interrupt until we're in the next transaction,
+	  // at the point where we would normally issue the start.
+	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
+	  twi_state = TWI_READY;
+	}
+      }
+      break;
+    case TW_MT_SLA_NACK:  // address sent, nack received
+      twi_error = TW_MT_SLA_NACK;
+      twi_stop();
+      break;
+    case TW_MT_DATA_NACK: // data sent, nack received
+      twi_error = TW_MT_DATA_NACK;
+      twi_stop();
+      break;
+    case TW_MT_ARB_LOST: // lost bus arbitration
+      twi_error = TW_MT_ARB_LOST;
+      twi_releaseBus();
+      break;
+
+    // Master Receiver
+    case TW_MR_DATA_ACK: // data received, ack sent
+      // put byte into buffer
+      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
+    case TW_MR_SLA_ACK:  // address sent, ack received
+      // ack if more bytes are expected, otherwise nack
+      if(twi_masterBufferIndex < twi_masterBufferLength){
+        twi_reply(1);
+      }else{
+        twi_reply(0);
+      }
+      break;
+    case TW_MR_DATA_NACK: // data received, nack sent
+      // put final byte into buffer
+      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
+	if (twi_sendStop)
+          twi_stop();
+	else {
+	  twi_inRepStart = true;	// we're gonna send the START
+	  // don't enable the interrupt. We'll generate the start, but we 
+	  // avoid handling the interrupt until we're in the next transaction,
+	  // at the point where we would normally issue the start.
+	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
+	  twi_state = TWI_READY;
+	}    
+	break;
+    case TW_MR_SLA_NACK: // address sent, nack received
+      twi_stop();
+      break;
+    // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case
+
+    // Slave Receiver
+    case TW_SR_SLA_ACK:   // addressed, returned ack
+    case TW_SR_GCALL_ACK: // addressed generally, returned ack
+    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
+    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
+      // enter slave receiver mode
+      twi_state = TWI_SRX;
+      // indicate that rx buffer can be overwritten and ack
+      twi_rxBufferIndex = 0;
+      twi_reply(1);
+      break;
+    case TW_SR_DATA_ACK:       // data received, returned ack
+    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
+      // if there is still room in the rx buffer
+      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
+        // put byte in buffer and ack
+        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
+        twi_reply(1);
+      }else{
+        // otherwise nack
+        twi_reply(0);
+      }
+      break;
+    case TW_SR_STOP: // stop or repeated start condition received
+      // put a null char after data if there's room
+      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
+        twi_rxBuffer[twi_rxBufferIndex] = '\0';
+      }
+      // sends ack and stops interface for clock stretching
+      twi_stop();
+      // callback to user defined callback
+      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
+      // since we submit rx buffer to "wire" library, we can reset it
+      twi_rxBufferIndex = 0;
+      // ack future responses and leave slave receiver state
+      twi_releaseBus();
+      break;
+    case TW_SR_DATA_NACK:       // data received, returned nack
+    case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack
+      // nack back at master
+      twi_reply(0);
+      break;
+    
+    // Slave Transmitter
+    case TW_ST_SLA_ACK:          // addressed, returned ack
+    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
+      // enter slave transmitter mode
+      twi_state = TWI_STX;
+      // ready the tx buffer index for iteration
+      twi_txBufferIndex = 0;
+      // set tx buffer length to be zero, to verify if user changes it
+      twi_txBufferLength = 0;
+      // request for txBuffer to be filled and length to be set
+      // note: user must call twi_transmit(bytes, length) to do this
+      twi_onSlaveTransmit();
+      // if they didn't change buffer & length, initialize it
+      if(0 == twi_txBufferLength){
+        twi_txBufferLength = 1;
+        twi_txBuffer[0] = 0x00;
+      }
+      // transmit first byte from buffer, fall
+    case TW_ST_DATA_ACK: // byte sent, ack returned
+      // copy data to output register
+      TWDR = twi_txBuffer[twi_txBufferIndex++];
+      // if there is more to send, ack, otherwise nack
+      if(twi_txBufferIndex < twi_txBufferLength){
+        twi_reply(1);
+      }else{
+        twi_reply(0);
+      }
+      break;
+    case TW_ST_DATA_NACK: // received nack, we are done 
+    case TW_ST_LAST_DATA: // received ack, but we are done already!
+      // ack future responses
+      twi_reply(1);
+      // leave slave receiver state
+      twi_state = TWI_READY;
+      break;
+
+    // All
+    case TW_NO_INFO:   // no state information
+      break;
+    case TW_BUS_ERROR: // bus error, illegal stop/start
+      twi_error = TW_BUS_ERROR;
+      twi_stop();
+      break;
+  }
+}
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.h
new file mode 100644
index 0000000..6526593
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/libraries/Wire/utility/twi.h
@@ -0,0 +1,53 @@
+/*
+  twi.h - TWI/I2C library for Wiring & Arduino
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef twi_h
+#define twi_h
+
+  #include <inttypes.h>
+
+  //#define ATMEGA8
+
+  #ifndef TWI_FREQ
+  #define TWI_FREQ 100000L
+  #endif
+
+  #ifndef TWI_BUFFER_LENGTH
+  #define TWI_BUFFER_LENGTH 32
+  #endif
+
+  #define TWI_READY 0
+  #define TWI_MRX   1
+  #define TWI_MTX   2
+  #define TWI_SRX   3
+  #define TWI_STX   4
+  
+  void twi_init(void);
+  void twi_setAddress(uint8_t);
+  uint8_t twi_readFrom(uint8_t, uint8_t*, uint8_t, uint8_t);
+  uint8_t twi_writeTo(uint8_t, uint8_t*, uint8_t, uint8_t, uint8_t);
+  uint8_t twi_transmit(const uint8_t*, uint8_t);
+  void twi_attachSlaveRxEvent( void (*)(uint8_t*, int) );
+  void twi_attachSlaveTxEvent( void (*)(void) );
+  void twi_reply(uint8_t);
+  void twi_stop(void);
+  void twi_releaseBus(void);
+
+#endif
+
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.local.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.local.txt
index ff2ad5d..2beeaba 100644
--- a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.local.txt
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.local.txt
@@ -1 +1,2 @@
 compiler.cpp.extra_flags=-DHAS_AUTOMATIC_VERSIONING
+recipe.hooks.prebuild.pattern=/usr/local/bin/generate_version_header_for_marlin {build.source.path} {build.path}/_Version.h
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.txt
index 639448c..fd1a4fb 100644
--- a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.txt
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/platform.txt
@@ -1,5 +1,5 @@
 
-# Marlin AVR Core and platform.
+# Arduino AVR Core and platform.
 # ------------------------------
 
 # For more info:
@@ -7,3 +7,113 @@
 
 name=Marlin AVR Boards
 version=1.5.6
+
+# AVR compile variables
+# ---------------------
+
+# Default "compiler.path" is correct, change only if you want to overidde the initial value
+compiler.path={runtime.ide.path}/hardware/tools/avr/bin/
+compiler.c.cmd=avr-gcc
+compiler.c.flags=-c -g -Os -w -ffunction-sections -fdata-sections -MMD
+# -w flag added to avoid printing a wrong warning http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59396
+# This is fixed in gcc 4.8.3 and will be removed as soon as we update the toolchain
+compiler.c.elf.flags=-w -Os -Wl,--gc-sections
+compiler.c.elf.cmd=avr-gcc
+compiler.S.flags=-c -g -x assembler-with-cpp
+compiler.cpp.cmd=avr-g++
+compiler.cpp.flags=-c -g -Os -w -fno-exceptions -ffunction-sections -fdata-sections -fno-threadsafe-statics -MMD
+compiler.ar.cmd=avr-ar
+compiler.ar.flags=rcs
+compiler.objcopy.cmd=avr-objcopy
+compiler.objcopy.eep.flags=-O ihex -j .eeprom --set-section-flags=.eeprom=alloc,load --no-change-warnings --change-section-lma .eeprom=0
+compiler.elf2hex.flags=-O ihex -R .eeprom
+compiler.elf2hex.cmd=avr-objcopy
+compiler.ldflags=
+compiler.size.cmd=avr-size
+
+# This can be overriden in boards.txt
+build.extra_flags=
+
+# These can be overridden in platform.local.txt
+compiler.c.extra_flags=
+compiler.c.elf.extra_flags=
+compiler.S.extra_flags=
+compiler.cpp.extra_flags=
+compiler.ar.extra_flags=
+compiler.objcopy.eep.extra_flags=
+compiler.elf2hex.extra_flags=
+
+# AVR compile patterns
+# --------------------
+
+## Compile c files
+recipe.c.o.pattern="{compiler.path}{compiler.c.cmd}" {compiler.c.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} "{source_file}" -o "{object_file}"
+
+## Compile c++ files
+recipe.cpp.o.pattern="{compiler.path}{compiler.cpp.cmd}" {compiler.cpp.flags} {compiler.cpp.extra_flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {build.extra_flags} {includes} "{source_file}" -o "{object_file}"
+
+## Compile S files
+recipe.S.o.pattern="{compiler.path}{compiler.c.cmd}" {compiler.S.flags} -mmcu={build.mcu} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.S.extra_flags} {build.extra_flags} {includes} "{source_file}" -o "{object_file}"
+
+## Create archives
+recipe.ar.pattern="{compiler.path}{compiler.ar.cmd}" {compiler.ar.flags} {compiler.ar.extra_flags} "{build.path}/{archive_file}" "{object_file}"
+
+## Combine gc-sections, archives, and objects
+recipe.c.combine.pattern="{compiler.path}{compiler.c.elf.cmd}" {compiler.c.elf.flags} -mmcu={build.mcu} {compiler.c.elf.extra_flags} -o "{build.path}/{build.project_name}.elf" {object_files} "{build.path}/{archive_file}" "-L{build.path}" -lm
+
+## Create eeprom
+recipe.objcopy.eep.pattern="{compiler.path}{compiler.objcopy.cmd}" {compiler.objcopy.eep.flags} {compiler.objcopy.eep.extra_flags} "{build.path}/{build.project_name}.elf" "{build.path}/{build.project_name}.eep"
+
+## Create hex
+recipe.objcopy.hex.pattern="{compiler.path}{compiler.elf2hex.cmd}" {compiler.elf2hex.flags} {compiler.elf2hex.extra_flags} "{build.path}/{build.project_name}.elf" "{build.path}/{build.project_name}.hex"
+
+## Compute size
+recipe.size.pattern="{compiler.path}{compiler.size.cmd}" -A "{build.path}/{build.project_name}.elf"
+recipe.size.regex=^(?:\.text|\.data|\.bootloader)\s+([0-9]+).*
+recipe.size.regex.data=^(?:\.data|\.bss|\.noinit)\s+([0-9]+).*
+recipe.size.regex.eeprom=^(?:\.eeprom)\s+([0-9]+).*
+
+
+# AVR Uploader/Programmers tools
+# ------------------------------
+
+tools.avrdude.cmd.path={runtime.ide.path}/hardware/tools/avr/bin/avrdude
+tools.avrdude.config.path={runtime.ide.path}/hardware/tools/avr/etc/avrdude.conf
+
+tools.avrdude.upload.params.verbose=-v
+tools.avrdude.upload.params.quiet=-q -q
+tools.avrdude.upload.pattern="{cmd.path}" "-C{config.path}" {upload.verbose} -p{build.mcu} -c{upload.protocol} -P{serial.port} -b{upload.speed} -D "-Uflash:w:{build.path}/{build.project_name}.hex:i"
+
+tools.avrdude.program.params.verbose=-v
+tools.avrdude.program.params.quiet=-q -q
+tools.avrdude.program.pattern="{cmd.path}" "-C{config.path}" {program.verbose} -p{build.mcu} -c{protocol} {program.extra_params} "-Uflash:w:{build.path}/{build.project_name}.hex:i"
+
+tools.avrdude.erase.params.verbose=-v
+tools.avrdude.erase.params.quiet=-q -q
+tools.avrdude.erase.pattern="{cmd.path}" "-C{config.path}" {erase.verbose} -p{build.mcu} -c{protocol} {program.extra_params} -e -Ulock:w:{bootloader.unlock_bits}:m -Uefuse:w:{bootloader.extended_fuses}:m -Uhfuse:w:{bootloader.high_fuses}:m -Ulfuse:w:{bootloader.low_fuses}:m
+
+tools.avrdude.bootloader.params.verbose=-v
+tools.avrdude.bootloader.params.quiet=-q -q
+tools.avrdude.bootloader.pattern="{cmd.path}" "-C{config.path}" {bootloader.verbose} -p{build.mcu} -c{protocol} {program.extra_params} "-Uflash:w:{runtime.platform.path}/bootloaders/{bootloader.path}/{bootloader.file}:i" -Ulock:w:{bootloader.lock_bits}:m
+
+tools.hidloader.cmd.path=/usr/local/bin/HIDUploader
+
+tools.hidloader.upload.params.verbose=-v
+tools.hidloader.upload.params.quiet=
+tools.hidloader.upload.pattern="{cmd.path}" --upload -mmcu={build.mcu} {upload.verbose} -w "{build.path}/{build.project_name}.hex"
+tools.nativehid.program.params.verbose=-v
+tools.nativehid.program.params.quiet=-q -q
+
+tools.hidloader.program.params.verbose=-v
+tools.hidloader.program.params.quiet=-q -q
+tools.hidloader.program.pattern="{cmd.path}" -mmcu={build.mcu} {upload.verbose} -w "{build.path}/{build.project_name}.hex"
+
+tools.hidloader.erase.params.verbose=-v
+tools.hidloader.erase.params.quiet=-q -q
+tools.hidloader.erase.pattern="{cmd.path}" --erase "-C{config.path}" {erase.verbose} -p{build.mcu} -c{protocol} {program.extra_params} -e -Ulock:w:{bootloader.unlock_bits}:m -Uefuse:w:{bootloader.extended_fuses}:m -Uhfuse:w:{bootloader.high_fuses}:m -Ulfuse:w:{bootloader.low_fuses}:m
+
+# USB Default Flags
+# Default blank usb manufacturer will be filled it at compile time
+# - from numeric vendor ID, set to Unknown otherwise
+build.usb_manufacturer=
+build.usb_flags=-DUSB_VID={build.vid} -DUSB_PID={build.pid} '-DUSB_MANUFACTURER={build.usb_manufacturer}' '-DUSB_PRODUCT={build.usb_product}'
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwave/pins_arduino.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwave/pins_arduino.h
new file mode 100644
index 0000000..83a04fc
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwave/pins_arduino.h
@@ -0,0 +1,281 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+  Modified 2012 by Fredrik Hubinette
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NUM_DIGITAL_PINS            48
+#define NUM_ANALOG_INPUTS           8
+
+#define TX_RX_LED_INIT		DDRE |= (1<<7)
+#define TXLED0			0
+#define TXLED1			0
+#define RXLED0			PORTE |= (1<<7)
+#define RXLED1			PORTE &= ~(1<<7)
+
+static const uint8_t SDA = 0;
+static const uint8_t SCL = 1;
+
+// Map SPI port to 'new' pins D14..D17
+static const uint8_t SS   = 20;
+static const uint8_t MOSI = 22;
+static const uint8_t MISO = 23;
+static const uint8_t SCK  = 21;
+
+// Mapping of analog pins as digital I/O
+// A6-A11 share with digital pins
+static const uint8_t A0 = 38;   // F0
+static const uint8_t A1 = 39;   // F1
+static const uint8_t A2 = 40;   // F2
+static const uint8_t A3 = 41;   // F3
+static const uint8_t A4 = 42;   // F4
+static const uint8_t A5 = 43;   // F5
+static const uint8_t A6 = 44;	// F6
+static const uint8_t A7 = 45;	// F7
+
+#define analogInputToDigitalPin(p)  ((p < 16) ? (p) + 54 : -1)
+
+// Pins below still needs to be configured - Hubbe.
+
+#define digitalPinToPCICR(p)    ((((p) >= 8 && (p) <= 11) || ((p) >= 14 && (p) <= 17) || ((p) >= A8 && (p) <= A10)) ? (&PCICR) : ((uint8_t *)0))
+#define digitalPinToPCICRbit(p) 0
+#define digitalPinToPCMSK(p)    ((((p) >= 8 && (p) <= 11) || ((p) >= 14 && (p) <= 17) || ((p) >= A8 && (p) <= A10)) ? (&PCMSK0) : ((uint8_t *)0))
+#define digitalPinToPCMSKbit(p) ( ((p) >= 8 && (p) <= 11) ? (p) - 4 : ((p) == 14 ? 3 : ((p) == 15 ? 1 : ((p) == 16 ? 2 : ((p) == 17 ? 0 : (p - A8 + 4))))))
+
+
+#define digitalPinHasPWM(p)         ((p) == 12 || (p) == 13 || (p) == 14 || (p) == 20 || (p) == 21 || (p) == 22)
+
+//	__AVR_ATmega32U4__ has an unusual mapping of pins to channels
+extern const uint8_t PROGMEM analog_pin_to_channel_PGM[];
+#define analogPinToChannel(P)  ( pgm_read_byte( analog_pin_to_channel_PGM + (P) ) )
+
+#ifdef ARDUINO_MAIN
+
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+// Note PA == 1, PB == 2, etc. (GAH!)
+const uint16_t PROGMEM port_to_mode_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &DDRA,
+  (uint16_t) &DDRB,
+  (uint16_t) &DDRC,
+  (uint16_t) &DDRD,
+  (uint16_t) &DDRE,
+};
+
+const uint16_t PROGMEM port_to_output_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &PORTA,
+  (uint16_t) &PORTB,
+  (uint16_t) &PORTC,
+  (uint16_t) &PORTD,
+  (uint16_t) &PORTE,
+};
+
+const uint16_t PROGMEM port_to_input_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &PINA,
+  (uint16_t) &PINB,
+  (uint16_t) &PINC,
+  (uint16_t) &PIND,
+  (uint16_t) &PINE,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] = {
+  PA, // 0
+  PA,
+  PA,
+  PA,
+  PA,
+  PA,
+  PA,
+  PA,
+  PB, // 8
+  PB,
+  PB,
+  PB,
+  PB,
+  PB,
+  PB,
+  PB,
+  PC, // 16
+  PC,
+  PC,
+  PC,
+  PC,
+  PC,
+  PC,
+  PC,
+  PD, // 24
+  PD,
+  PD,
+  PD,
+  PD,
+  PD,
+  PD,
+  PD,
+  PE, // 32
+  PE,
+  PE,
+  PE,
+  PE,
+  PE,
+  PE,
+  PE, // 39 - PE7
+  PF, // 40 - A0 - PF0
+  PF,
+  PF,
+  PF,
+  PF,
+  PF,
+  PF,
+  PF, // 47 - A7 - PF7
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {
+  _BV(0), // PA0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+  _BV(0), // PB0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+  _BV(0), // PC0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+  _BV(0), // PD0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+  _BV(0), // PE0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+  _BV(0), // PF0
+  _BV(1),
+  _BV(2),
+  _BV(3),
+  _BV(4),
+  _BV(5),
+  _BV(6),
+  _BV(7),
+};
+
+
+// TODO(unrepentantgeek) complete this map of PWM capable pins
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] = {
+  NOT_ON_TIMER, //  0 - PA0
+  NOT_ON_TIMER, //  1 - PA1
+  NOT_ON_TIMER, //  2 - PA2
+  NOT_ON_TIMER, //  3 - PA3
+  NOT_ON_TIMER, //  4 - PA4
+  NOT_ON_TIMER, //  5 - PA5
+  NOT_ON_TIMER, //  6 - PA6
+  NOT_ON_TIMER, //  7 - PA7
+  NOT_ON_TIMER, //  8 - PB0
+  NOT_ON_TIMER, //  9 - PB1
+  NOT_ON_TIMER, // 10 - PB2
+  NOT_ON_TIMER, // 11 - PB3
+  TIMER2A,      // 12 - PB4
+  TIMER1A,      // 13 - PB5
+  TIMER1B,      // 14 - PB6
+  NOT_ON_TIMER, // 15 - PB7
+  NOT_ON_TIMER, // 16 - PC0
+  NOT_ON_TIMER, // 17 - PC1
+  NOT_ON_TIMER, // 18 - PC2
+  NOT_ON_TIMER, // 19 - PC3
+  TIMER3C,      // 20 - PC4
+  TIMER3B,      // 21 - PC5
+  TIMER3A,      // 22 - PC6
+  NOT_ON_TIMER, // 23 - PC7
+  NOT_ON_TIMER, // 24 - PD0
+  NOT_ON_TIMER, // 25 - PD1
+  NOT_ON_TIMER, // 26 - PD2
+  NOT_ON_TIMER, // 27 - PD3
+  NOT_ON_TIMER, // 28 - PD4
+  NOT_ON_TIMER, // 29 - PD5
+  NOT_ON_TIMER, // 30 - PD6
+  NOT_ON_TIMER, // 31 - PD7
+  NOT_ON_TIMER, // 32 - PE0
+  NOT_ON_TIMER, // 33 - PE1
+  NOT_ON_TIMER, // 34 - PE2
+  NOT_ON_TIMER, // 35 - PE3
+  NOT_ON_TIMER, // 36 - PE4
+  NOT_ON_TIMER, // 37 - PE5
+  NOT_ON_TIMER, // 38 - PE6
+  NOT_ON_TIMER, // 39 - PE7
+  NOT_ON_TIMER, // 40 - A0 - PF0
+  NOT_ON_TIMER, // 41 - A1 - PF1
+  NOT_ON_TIMER, // 42 - A2 - PF2
+  NOT_ON_TIMER, // 43 - A3 - PF3
+  NOT_ON_TIMER, // 44 - A4 - PF4
+  NOT_ON_TIMER, // 45 - A5 - PF5
+  NOT_ON_TIMER, // 46 - A6 - PF6
+  NOT_ON_TIMER, // 47 - A7 - PF7
+};
+
+const uint8_t PROGMEM analog_pin_to_channel_PGM[12] = {
+	7,	// A0				PF7					ADC7
+	6,	// A1				PF6					ADC6
+	5,	// A2				PF5					ADC5
+	4,	// A3				PF4					ADC4
+	1,	// A4				PF1					ADC1
+	0,	// A5				PF0					ADC0
+	8,	// A6		D4		PD4					ADC8
+	10,	// A7		D6		PD7					ADC10
+	11,	// A8		D8		PB4					ADC11
+	12,	// A9		D9		PB5					ADC12
+	13,	// A10		D10		PB6					ADC13
+	9	// A11		D12		PD6					ADC9
+};
+
+#endif /* ARDUINO_MAIN */
+#endif /* Pins_Arduino_h */
diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwavepro/pins_arduino.h b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwavepro/pins_arduino.h
new file mode 100644
index 0000000..8fef383
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/variants/brainwavepro/pins_arduino.h
@@ -0,0 +1,278 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+  Modified 2012 by Fredrik Hubinette
+  Modified 2014-2015 by Matthew Wilson
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NUM_DIGITAL_PINS            48
+#define NUM_ANALOG_INPUTS           8
+
+// PE7 is our status LED
+#define TX_RX_LED_INIT		DDRE |= (1<<7)
+#define TXLED0			0
+#define TXLED1			0
+#define RXLED0			PORTE |= (1<<7)
+#define RXLED1			PORTE &= ~(1<<7)
+
+static const uint8_t SDA = 1;
+static const uint8_t SCL = 0;
+
+// Map SPI port to 'new' pins D14..D17
+static const uint8_t SS   = 20;
+static const uint8_t MOSI = 22;
+static const uint8_t MISO = 23;
+static const uint8_t SCK  = 21;
+
+// Mapping of analog pins as digital I/O
+// A6-A11 share with digital pins
+static const uint8_t A0 = 38;   // F0
+static const uint8_t A1 = 39;   // F1
+static const uint8_t A2 = 40;   // F2
+static const uint8_t A3 = 41;   // F3
+static const uint8_t A4 = 42;   // F4
+static const uint8_t A5 = 43;   // F5
+static const uint8_t A6 = 44;	// F6
+static const uint8_t A7 = 45;	// F7
+
+#define analogInputToDigitalPin(p)  ((p < 8) ? (p) + 38 : -1)
+
+// Pins below still needs to be configured - Hubbe.
+
+#define digitalPinToPCICR(p)    ((((p) >= 0 && (p) <= 3) || ((p) >= 18 && (p) <= 19) || ((p) >= 36 && (p) <= 37)) ? (&PCICR) : ((uint8_t *)0))
+#define digitalPinToPCICRbit(p) 0
+#define digitalPinToPCMSK(p)    ((((p) >= 0 && (p) <= 3) || ((p) >= 18 && (p) <= 19) || ((p) >= 36 && (p) <= 37)) ? (&PCMSK0) : ((uint8_t *)0))
+#define digitalPinToPCMSKbit(p) ( ((p) >= 0 && (p) <= 3) ? (p) : ((p) == 18 ? 6 : ((p) == 19 ? 7 : ((p) == 36 ? 4 : ((p) == 37 ? 5 : (-1))))))
+
+#define digitalPinHasPWM(p)     ((p) == 0 || (p) == 1 || (p) == 14 || (p) == 15 || (p) == 16 || (p) == 24 || (p) == 25 || (p) == 26 || (p) == 27)
+
+//	__AVR_ATmega32U4__ has an unusual mapping of pins to channels
+extern const uint8_t PROGMEM analog_pin_to_channel_PGM[];
+#define analogPinToChannel(P)  ( pgm_read_byte( analog_pin_to_channel_PGM + (P) ) )
+
+#ifdef ARDUINO_MAIN
+
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+// Note PA == 1, PB == 2, etc. (GAH!)
+const uint16_t PROGMEM port_to_mode_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &DDRA,
+  (uint16_t) &DDRB,
+  (uint16_t) &DDRC,
+  (uint16_t) &DDRD,
+  (uint16_t) &DDRE,
+};
+
+const uint16_t PROGMEM port_to_output_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &PORTA,
+  (uint16_t) &PORTB,
+  (uint16_t) &PORTC,
+  (uint16_t) &PORTD,
+  (uint16_t) &PORTE,
+};
+
+const uint16_t PROGMEM port_to_input_PGM[] = {
+  NOT_A_PORT,
+  (uint16_t) &PINA,
+  (uint16_t) &PINB,
+  (uint16_t) &PINC,
+  (uint16_t) &PIND,
+  (uint16_t) &PINE,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] = {
+  PD, // 0  - PD0 - INT0 - PWM
+  PD, // 1  - PD1 - INT1 - PWM
+  PD, // 2  - PD2 - INT2 - RX
+  PD, // 3  - PD3 - INT3 - TX
+  PD, // 4  - PD4
+  PD, // 5  - PD5
+  PD, // 6  - PD6
+  PD, // 7  - PD7
+  PE, // 8  - PE0
+  PE, // 9  - PE1
+  PC, // 10 - PC0
+  PC, // 11 - PC1
+  PC, // 12 - PC2
+  PC, // 13 - PC3
+  PC, // 14 - PC4 - PWM
+  PC, // 15 - PC5 - PWM
+  PC, // 16 - PC6 - PWM
+  PC, // 17 - PC7
+  PE, // 18 - PE6 - INT6
+  PE, // 19 - PE7 - INT7
+  PB, // 20 - PB0
+  PB, // 21 - PB1
+  PB, // 22 - PB2
+  PB, // 23 - PB3
+  PB, // 24 - PB4 - PWM
+  PB, // 25 - PB5 - PWM
+  PB, // 26 - PB6 - PWM
+  PB, // 27 - PB7 - PWM
+  PA, // 28 - PA0
+  PA, // 29 - PA1
+  PA, // 30 - PA2
+  PA, // 31 - PA3
+  PA, // 32 - PA4
+  PA, // 33 - PA5
+  PA, // 34 - PA6
+  PA, // 35 - PA7
+  PE, // 36 - PE4 - INT4
+  PE, // 37 - PE5 - INT5
+  PF, // 38 - PF0 - A0
+  PF, // 39 - PF1 - A1
+  PF, // 40 - PF2 - A2
+  PF, // 41 - PF3 - A3
+  PF, // 42 - PF4 - A4
+  PF, // 43 - PF5 - A5
+  PF, // 44 - PF6 - A6
+  PF, // 45 - PF7 - A7
+  PE, // 46 - PE2 (not defined in teensy)
+  PE, // 47 - PE3 (not defined in teensy)
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {
+  _BV(0), // 0  - PD0 - INT0 - PWM
+  _BV(1), // 1  - PD1 - INT1 - PWM
+  _BV(2), // 2  - PD2 - INT2 - RX
+  _BV(3), // 3  - PD3 - INT3 - TX
+  _BV(4), // 4  - PD4
+  _BV(5), // 5  - PD5
+  _BV(6), // 6  - PD6
+  _BV(7), // 7  - PD7
+  _BV(0), // 8  - PE0
+  _BV(1), // 9  - PE1
+  _BV(0), // 10 - PC0
+  _BV(1), // 11 - PC1
+  _BV(2), // 12 - PC2
+  _BV(3), // 13 - PC3
+  _BV(4), // 14 - PC4 - PWM
+  _BV(5), // 15 - PC5 - PWM
+  _BV(6), // 16 - PC6 - PWM
+  _BV(7), // 17 - PC7
+  _BV(6), // 18 - PE6 - INT6
+  _BV(7), // 19 - PE7 - INT7
+  _BV(0), // 20 - PB0
+  _BV(1), // 21 - PB1
+  _BV(2), // 22 - PB2
+  _BV(3), // 23 - PB3
+  _BV(4), // 24 - PB4 - PWM
+  _BV(5), // 25 - PB5 - PWM
+  _BV(6), // 26 - PB6 - PWM
+  _BV(7), // 27 - PB7 - PWM
+  _BV(0), // 28 - PA0
+  _BV(1), // 29 - PA1
+  _BV(2), // 30 - PA2
+  _BV(3), // 31 - PA3
+  _BV(4), // 32 - PA4
+  _BV(5), // 33 - PA5
+  _BV(6), // 34 - PA6
+  _BV(7), // 35 - PA7
+  _BV(4), // 36 - PE4 - INT4
+  _BV(5), // 37 - PE5 - INT5
+  _BV(0), // 38 - PF0 - A0
+  _BV(1), // 39 - PF1 - A1
+  _BV(2), // 40 - PF2 - A2
+  _BV(3), // 41 - PF3 - A3
+  _BV(4), // 42 - PF4 - A4
+  _BV(5), // 43 - PF5 - A5
+  _BV(6), // 44 - PF6 - A6
+  _BV(7), // 45 - PF7 - A7
+  _BV(2), // 46 - PE2 (not defined in teensy)
+  _BV(3), // 47 - PE3 (not defined in teensy)
+};
+
+
+// TODO(unrepentantgeek) complete this map of PWM capable pins
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] = {
+  TIMER0A,      // 0  - PD0 - INT0 - PWM
+  TIMER2B,      // 1  - PD1 - INT1 - PWM
+  NOT_ON_TIMER, // 2  - PD2 - INT2 - RX
+  NOT_ON_TIMER, // 3  - PD3 - INT3 - TX
+  NOT_ON_TIMER, // 4  - PD4
+  NOT_ON_TIMER, // 5  - PD5
+  NOT_ON_TIMER, // 6  - PD6
+  NOT_ON_TIMER, // 7  - PD7
+  NOT_ON_TIMER, // 8  - PE0
+  NOT_ON_TIMER, // 9  - PE1
+  NOT_ON_TIMER, // 10 - PC0
+  NOT_ON_TIMER, // 11 - PC1
+  NOT_ON_TIMER, // 12 - PC2
+  NOT_ON_TIMER, // 13 - PC3
+  TIMER3C,      // 14 - PC4 - PWM
+  TIMER3B,      // 15 - PC5 - PWM
+  TIMER3A,      // 16 - PC6 - PWM
+  NOT_ON_TIMER, // 17 - PC7
+  NOT_ON_TIMER, // 18 - PE6 - INT6
+  NOT_ON_TIMER, // 19 - PE7 - INT7
+  NOT_ON_TIMER, // 20 - PB0
+  NOT_ON_TIMER, // 21 - PB1
+  NOT_ON_TIMER, // 22 - PB2
+  NOT_ON_TIMER, // 23 - PB3
+  TIMER2A,      // 24 - PB4 - PWM
+  TIMER1A,      // 25 - PB5 - PWM
+  TIMER1B,      // 26 - PB6 - PWM
+  NOT_ON_TIMER, // 27 - PB7 - PWM  // This should be on TIMER1C
+  NOT_ON_TIMER, // 28 - PA0
+  NOT_ON_TIMER, // 29 - PA1
+  NOT_ON_TIMER, // 30 - PA2
+  NOT_ON_TIMER, // 31 - PA3
+  NOT_ON_TIMER, // 32 - PA4
+  NOT_ON_TIMER, // 33 - PA5
+  NOT_ON_TIMER, // 34 - PA6
+  NOT_ON_TIMER, // 35 - PA7
+  NOT_ON_TIMER, // 36 - PE4 - INT4
+  NOT_ON_TIMER, // 37 - PE5 - INT5
+  NOT_ON_TIMER, // 38 - PF0 - A0
+  NOT_ON_TIMER, // 39 - PF1 - A1
+  NOT_ON_TIMER, // 40 - PF2 - A2
+  NOT_ON_TIMER, // 41 - PF3 - A3
+  NOT_ON_TIMER, // 42 - PF4 - A4
+  NOT_ON_TIMER, // 43 - PF5 - A5
+  NOT_ON_TIMER, // 44 - PF6 - A6
+  NOT_ON_TIMER, // 45 - PF7 - A7
+  NOT_ON_TIMER, // 46 - PE2 (not defined in teensy)
+  NOT_ON_TIMER, // 47 - PE3 (not defined in teensy)
+};
+
+const uint8_t PROGMEM analog_pin_to_channel_PGM[8] = {
+	0,	// A0		PF0	ADC0
+	1,	// A1		PF1	ADC1
+	2,	// A2		PF2	ADC2
+	3,	// A3		PF3	ADC3
+	4,	// A4		PF4	ADC4
+	5,	// A5		PF5	ADC5
+	6,	// A6	  	PD6	ADC6
+	7,	// A7		PD7	ADC7
+};
+
+#endif /* ARDUINO_MAIN */
+#endif /* Pins_Arduino_h */
diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index 358131e..59a599b 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -205,6 +205,8 @@
 
   #define CONDITIONALS_H
 
+  #include "pins.h"
+
   #ifndef AT90USB
     #define HardwareSerial_h // trick to disable the standard HWserial
   #endif
@@ -215,8 +217,6 @@
     #include "WProgram.h"
   #endif
 
-  #include "pins.h"
-
   /**
    * ENDSTOPPULLUPS
    */
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index be0f960..fe63dba 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -20,6 +20,7 @@
 
 #include "fastio.h"
 #include "Configuration.h"
+#include "pins.h"
 
 #ifndef SANITYCHECK_H
   #error Your Configuration.h and Configuration_adv.h files are outdated!
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 6bb2c2e..de8bd5a 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -213,6 +213,10 @@
  * M365 - SCARA calibration: Scaling factor, X, Y, Z axis
  * ************* SCARA End ***************
  *
+ * ************ Custom codes - This can change to suit future G-code regulations
+ * M851 - Set probe's Z offset (mm above extruder -- The value will always be negative)
+
+
  * M928 - Start SD logging (M928 filename.g) - ended by M29
  * M999 - Restart after being stopped by error
  *
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 9aaff4a..ee67417 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -152,18 +152,18 @@
      * Check if Probe_Offset * Grid Points is greater than Probing Range
      */
     #ifdef AUTO_BED_LEVELING_GRID
-
-      // Make sure probing points are reachable
-      #if LEFT_PROBE_BED_POSITION < MIN_PROBE_X
-        #error "The given LEFT_PROBE_BED_POSITION can't be reached by the probe."
-      #elif RIGHT_PROBE_BED_POSITION > MAX_PROBE_X
-        #error "The given RIGHT_PROBE_BED_POSITION can't be reached by the probe."
-      #elif FRONT_PROBE_BED_POSITION < MIN_PROBE_Y
-        #error "The given FRONT_PROBE_BED_POSITION can't be reached by the probe."
-      #elif BACK_PROBE_BED_POSITION > MAX_PROBE_Y
-        #error "The given BACK_PROBE_BED_POSITION can't be reached by the probe."
+      #ifndef DELTA_PROBABLE_RADIUS
+        // Make sure probing points are reachable
+        #if LEFT_PROBE_BED_POSITION < MIN_PROBE_X
+          #error "The given LEFT_PROBE_BED_POSITION can't be reached by the probe."
+        #elif RIGHT_PROBE_BED_POSITION > MAX_PROBE_X
+          #error "The given RIGHT_PROBE_BED_POSITION can't be reached by the probe."
+        #elif FRONT_PROBE_BED_POSITION < MIN_PROBE_Y
+          #error "The given FRONT_PROBE_BED_POSITION can't be reached by the probe."
+        #elif BACK_PROBE_BED_POSITION > MAX_PROBE_Y
+          #error "The given BACK_PROBE_BED_POSITION can't be reached by the probe."
+        #endif
       #endif
-
       #define PROBE_SIZE_X (X_PROBE_OFFSET_FROM_EXTRUDER * (AUTO_BED_LEVELING_GRID_POINTS-1))
       #define PROBE_SIZE_Y (Y_PROBE_OFFSET_FROM_EXTRUDER * (AUTO_BED_LEVELING_GRID_POINTS-1))
       #define PROBE_AREA_WIDTH (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION)
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
new file mode 100644
index 0000000..3472a46
--- /dev/null
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -0,0 +1,1083 @@
+// Example configuration file for OpenBeam Kossel Pro
+// tested on 2015-05-19 by @Wackerbarth
+// using Arduino 1.6.5 (Mac)
+
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+#include "boards.h"
+
+//===========================================================================
+//============================= Getting Started =============================
+//===========================================================================
+/*
+Here are some standard links for getting your machine calibrated:
+ * http://reprap.org/wiki/Calibration
+ * http://youtu.be/wAL9d7FgInk
+ * http://calculator.josefprusa.cz
+ * http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide
+ * http://www.thingiverse.com/thing:5573
+ * https://sites.google.com/site/repraplogphase/calibration-of-your-reprap
+ * http://www.thingiverse.com/thing:298812
+*/
+
+// This configuration file contains the basic settings.
+// Advanced settings can be found in Configuration_adv.h
+// BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
+
+//===========================================================================
+//============================= DELTA Printer ===============================
+//===========================================================================
+// For a Delta printer replace the configuration files with the files in the
+// example_configurations/delta directory.
+//
+
+//===========================================================================
+//============================= SCARA Printer ===============================
+//===========================================================================
+// For a Scara printer replace the configuration files with the files in the
+// example_configurations/SCARA directory.
+//
+#ifdef HAS_AUTOMATIC_VERSIONING
+  #include "_Version.h"
+#else
+  #include "Default_Version.h"
+#endif
+
+// @section info
+
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
+#define STRING_SPLASH_LINE1 BUILD_VERSION // will be shown during bootup in line 1
+//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+
+// @section machine
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+// :[0,1,2,3,4,5,6,7]
+#define SERIAL_PORT 0
+
+// This determines the communication speed of the printer
+// :[2400,9600,19200,38400,57600,115200,250000]
+#define BAUDRATE 250000
+
+// This enables the serial port associated to the Bluetooth interface
+//#define BTENABLED              // Enable BT interface on AT90USB devices
+
+// The following define selects which electronics board you have.
+// Please choose the name from boards.h that matches your setup
+#ifndef MOTHERBOARD
+  #define MOTHERBOARD BOARD_BRAINWAVE_PRO
+#endif
+
+// Optional custom name for your RepStrap or other custom machine
+// Displayed in the LCD "Ready" message
+#define CUSTOM_MACHINE_NAME "Kossel Pro"
+
+// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
+// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
+// #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
+
+// This defines the number of extruders
+// :[1,2,3,4]
+#define EXTRUDERS 1
+
+// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
+// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
+// For the other hotends it is their distance from the extruder 0 hotend.
+//#define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
+//#define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
+
+//// The following define selects which power supply you have. Please choose the one that matches your setup
+// 1 = ATX
+// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+// :{1:'ATX',2:'X-Box 360'}
+
+#define POWER_SUPPLY 1
+
+// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
+// #define PS_DEFAULT_OFF
+
+// @section temperature
+
+//===========================================================================
+//============================= Thermal Settings ============================
+//===========================================================================
+//
+//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table
+//
+//// Temperature sensor settings:
+// -2 is thermocouple with MAX6675 (only for sensor 0)
+// -1 is thermocouple with AD595
+// 0 is not used
+// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
+// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
+// 3 is Mendel-parts thermistor (4.7k pullup)
+// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
+// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
+// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
+// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
+// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)
+// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
+// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
+// 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 11 is 100k beta 3950 1% thermistor (4.7k pullup)
+// 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)
+// 13 is 100k Hisens 3950  1% up to 300°C for hotend "Simple ONE " & "Hotend "All In ONE"
+// 20 is the PT100 circuit found in the Ultimainboard V2.x
+// 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950
+//
+//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
+//                          (but gives greater accuracy and more stable PID)
+// 51 is 100k thermistor - EPCOS (1k pullup)
+// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
+// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+//
+// 1047 is Pt1000 with 4k7 pullup
+// 1010 is Pt1000 with 1k pullup (non standard)
+// 147 is Pt100 with 4k7 pullup
+// 110 is Pt100 with 1k pullup (non standard)
+// 998 and 999 are Dummy Tables. They will ALWAYS read 25°C or the temperature defined below.
+//     Use it for Testing or Development purposes. NEVER for production machine.
+//     #define DUMMY_THERMISTOR_998_VALUE 25
+//     #define DUMMY_THERMISTOR_999_VALUE 100
+// :{ '0': "Not used", '4': "10k !! do not use for a hotend. Bad resolution at high temp. !!", '1': "100k / 4.7k - EPCOS", '51': "100k / 1k - EPCOS", '6': "100k / 4.7k EPCOS - Not as accurate as Table 1", '5': "100K / 4.7k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)", '7': "100k / 4.7k Honeywell 135-104LAG-J01", '71': "100k / 4.7k Honeywell 135-104LAF-J01", '8': "100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT", '9': "100k / 4.7k GE Sensing AL03006-58.2K-97-G1", '10': "100k / 4.7k RS 198-961", '11': "100k / 4.7k beta 3950 1%", '12': "100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT (calibrated for Makibox hot bed)", '13': "100k Hisens 3950  1% up to 300°C for hotend 'Simple ONE ' & hotend 'All In ONE'", '60': "100k Maker's Tool Works Kapton Bed Thermistor beta=3950", '55': "100k / 1k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)", '2': "200k / 4.7k - ATC Semitec 204GT-2", '52': "200k / 1k - ATC Semitec 204GT-2", '-2': "Thermocouple + MAX6675 (only for sensor 0)", '-1': "Thermocouple + AD595", '3': "Mendel-parts / 4.7k", '1047': "Pt1000 / 4.7k", '1010': "Pt1000 / 1k (non standard)", '20': "PT100 (Ultimainboard V2.x)", '147': "Pt100 / 4.7k", '110': "Pt100 / 1k (non-standard)", '998': "Dummy 1", '999': "Dummy 2" }
+#define TEMP_SENSOR_0 5
+#define TEMP_SENSOR_1 0
+#define TEMP_SENSOR_2 0
+#define TEMP_SENSOR_3 0
+#define TEMP_SENSOR_BED 5
+
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
+// Actual temperature must be close to target for this long before M109 returns success
+#define TEMP_RESIDENCY_TIME 10  // (seconds)
+#define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
+
+// The minimal temperature defines the temperature below which the heater will not be enabled It is used
+// to check that the wiring to the thermistor is not broken.
+// Otherwise this would lead to the heater being powered on all the time.
+#define HEATER_0_MINTEMP 5
+#define HEATER_1_MINTEMP 5
+#define HEATER_2_MINTEMP 5
+#define HEATER_3_MINTEMP 5
+#define BED_MINTEMP 5
+
+// When temperature exceeds max temp, your heater will be switched off.
+// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
+// You should use MINTEMP for thermistor short/failure protection.
+#define HEATER_0_MAXTEMP 275
+#define HEATER_1_MAXTEMP 275
+#define HEATER_2_MAXTEMP 275
+#define HEATER_3_MAXTEMP 275
+#define BED_MAXTEMP 150
+
+// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
+// average current. The value should be an integer and the heat bed will be turned on for 1 interval of
+// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
+//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
+
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R
+//#define BED_WATTS (12.0*12.0/1.1)      // P=I^2/R
+
+//===========================================================================
+//============================= PID Settings ================================
+//===========================================================================
+// PID Tuning Guide here: http://reprap.org/wiki/PID_Tuning
+
+// Comment the following line to disable PID and enable bang-bang.
+#define PIDTEMP
+#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX  125 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#ifdef PIDTEMP
+  //#define PID_DEBUG // Sends debug data to the serial port.
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
+  //#define SLOW_PWM_HEATERS // PWM with very low frequency (roughly 0.125Hz=8s) and minimum state time of approximately 1s useful for heaters driven by a relay
+  //#define PID_PARAMS_PER_EXTRUDER // Uses separate PID parameters for each extruder (useful for mismatched extruders)
+                                    // Set/get with gcode: M301 E[extruder number, 0-2]
+  #define PID_FUNCTIONAL_RANGE 50   // If the temperature difference between the target temperature and the actual temperature
+                                    // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
+  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
+  #define K1 0.95 //smoothing factor within the PID
+
+// If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
+
+// Ultimaker
+//    #define  DEFAULT_Kp 22.2
+//    #define  DEFAULT_Ki 1.08
+//    #define  DEFAULT_Kd 114
+
+// Kossel Pro
+      #define  DEFAULT_Kp 19.30
+      #define  DEFAULT_Ki 3.51
+      #define  DEFAULT_Kd 26.56
+
+// MakerGear
+//    #define  DEFAULT_Kp 7.0
+//    #define  DEFAULT_Ki 0.1
+//    #define  DEFAULT_Kd 12
+
+// Mendel Parts V9 on 12V
+//    #define  DEFAULT_Kp 63.0
+//    #define  DEFAULT_Ki 2.25
+//    #define  DEFAULT_Kd 440
+#endif // PIDTEMP
+
+//===========================================================================
+//============================= PID > Bed Temperature Control ===============
+//===========================================================================
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
+// If your PID_dT is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+#define PIDTEMPBED
+//
+//#define BED_LIMIT_SWITCHING
+
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
+
+//#define PID_BED_DEBUG // Sends debug data to the serial port.
+
+#ifdef PIDTEMPBED
+//Kossel Pro heated bed plate with borosilicate glass
+//from pidautotune (M303 E-1 S60 C8)
+    #define  DEFAULT_bedKp 370.25
+    #define  DEFAULT_bedKi 62.77
+    #define  DEFAULT_bedKd 545.98
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
+//    #define  DEFAULT_bedKp 10.00
+//    #define  DEFAULT_bedKi .023
+//    #define  DEFAULT_bedKd 305.4
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from pidautotune
+//    #define  DEFAULT_bedKp 97.1
+//    #define  DEFAULT_bedKi 1.41
+//    #define  DEFAULT_bedKd 1675.16
+
+// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+// @section extruder
+
+//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
+//can be software-disabled for whatever purposes by
+#define PREVENT_DANGEROUS_EXTRUDE
+//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
+#define PREVENT_LENGTHY_EXTRUDE
+
+#define EXTRUDE_MINTEMP 170
+#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
+
+//===========================================================================
+//======================== Thermal Runaway Protection =======================
+//===========================================================================
+
+/**
+ * Thermal Runaway Protection protects your printer from damage and fire if a
+ * thermistor falls out or temperature sensors fail in any way.
+ *
+ * The issue: If a thermistor falls out or a temperature sensor fails,
+ * Marlin can no longer sense the actual temperature. Since a disconnected
+ * thermistor reads as a low temperature, the firmware will keep the heater on.
+ *
+ * The solution: Once the temperature reaches the target, start observing.
+ * If the temperature stays too far below the target (hysteresis) for too long,
+ * the firmware will halt as a safety precaution.
+ *
+ * Note that because the countdown starts only AFTER the temperature reaches
+ * the target, this will not catch a thermistor that is already disconnected
+ * when the print starts!
+ *
+ * To enable for all extruder heaters, uncomment the two defines below:
+ */
+
+#define THERMAL_RUNAWAY_PROTECTION_HOTENDS // Enable thermal protection for all extruders
+#define THERMAL_RUNAWAY_PROTECTION_BED     // Enable thermal protection for the heated bed
+// Parameters for all extruder heaters
+#define THERMAL_RUNAWAY_PROTECTION_PERIOD 40 // in seconds
+#define THERMAL_RUNAWAY_PROTECTION_HYSTERESIS 4 // in degree Celsius
+
+// To enable for the bed heater, uncomment the two defines below:
+
+// Parameters for the bed heater
+#define THERMAL_RUNAWAY_PROTECTION_BED_PERIOD 20 // in seconds
+#define THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS 2 // in degree Celsius
+
+//===========================================================================
+//============================= Mechanical Settings =========================
+//===========================================================================
+
+// @section machine
+
+// Uncomment this option to enable CoreXY kinematics
+// #define COREXY
+
+//===========================================================================
+//============================== Delta Settings =============================
+//===========================================================================
+// Enable DELTA kinematics and most of the default configuration for Deltas
+#define DELTA
+
+#ifdef DELTA
+// Make delta curves from many straight lines (linear interpolation).
+// This is a trade-off between visible corners (not enough segments)
+// and processor overload (too many expensive sqrt calls).
+#define DELTA_SEGMENTS_PER_SECOND 160
+
+// NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
+
+// Center-to-center distance of the holes in the diagonal push rods.
+#define DELTA_DIAGONAL_ROD 301.0 // mm
+
+// Horizontal offset from middle of printer to smooth rod center.
+#define DELTA_SMOOTH_ROD_OFFSET 212.357 // mm
+
+// Horizontal offset of the universal joints on the end effector.
+#define DELTA_EFFECTOR_OFFSET 30.0 // mm
+
+// Horizontal offset of the universal joints on the carriages.
+#define DELTA_CARRIAGE_OFFSET 30.0 // mm
+
+// Horizontal distance bridged by diagonal push rods when effector is centered.
+#define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
+
+// Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
+#define DELTA_PRINTABLE_RADIUS 127
+
+#endif
+
+// Enable this option for Toshiba steppers
+// #define CONFIG_STEPPERS_TOSHIBA
+
+// @section homing
+
+// coarse Endstop Settings
+#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+
+#ifndef ENDSTOPPULLUPS
+  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
+  // #define ENDSTOPPULLUP_XMAX
+  // #define ENDSTOPPULLUP_YMAX
+  // #define ENDSTOPPULLUP_ZMAX
+  // #define ENDSTOPPULLUP_XMIN
+  // #define ENDSTOPPULLUP_YMIN
+  // #define ENDSTOPPULLUP_ZMIN
+#endif
+
+#ifdef ENDSTOPPULLUPS
+  #define ENDSTOPPULLUP_XMAX
+  #define ENDSTOPPULLUP_YMAX
+  #define ENDSTOPPULLUP_ZMAX
+  #define ENDSTOPPULLUP_XMIN
+  #define ENDSTOPPULLUP_YMIN
+  #define ENDSTOPPULLUP_ZMIN
+#endif
+
+// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
+const bool X_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
+//#define DISABLE_MAX_ENDSTOPS
+//#define DISABLE_MIN_ENDSTOPS // Deltas only use min endstops for probing
+
+// Disable max endstops for compatibility with endstop checking routine
+#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
+  #define DISABLE_MAX_ENDSTOPS
+#endif
+
+// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
+// :{0:'Low',1:'High'}
+#define X_ENABLE_ON 0
+#define Y_ENABLE_ON 0
+#define Z_ENABLE_ON 0
+#define E_ENABLE_ON 0 // For all extruders
+
+// Disables axis when it's not being used.
+// WARNING: When motors turn off there is a chance of losing position accuracy!
+#define DISABLE_X false
+#define DISABLE_Y false
+#define DISABLE_Z false
+
+// @section extruder
+
+#define DISABLE_E false // For all extruders
+#define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled
+
+// @section machine
+
+// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
+#define INVERT_X_DIR true
+#define INVERT_Y_DIR true
+#define INVERT_Z_DIR true
+
+// @section extruder
+
+// For direct drive extruder v9 set to true, for geared extruder set to false.
+#define INVERT_E0_DIR true
+#define INVERT_E1_DIR false
+#define INVERT_E2_DIR false
+#define INVERT_E3_DIR false
+
+// @section homing
+
+// ENDSTOP SETTINGS:
+// Sets direction of endstops when homing; 1=MAX, -1=MIN
+// :[-1,1]
+#define X_HOME_DIR 1  // deltas always home to max
+#define Y_HOME_DIR 1
+#define Z_HOME_DIR 1
+
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
+
+// @section machine
+
+// Travel limits after homing (units are in mm)
+#define X_MIN_POS -DELTA_PRINTABLE_RADIUS
+#define Y_MIN_POS -DELTA_PRINTABLE_RADIUS
+#define Z_MIN_POS 0
+#define X_MAX_POS DELTA_PRINTABLE_RADIUS
+#define Y_MAX_POS DELTA_PRINTABLE_RADIUS
+#define Z_MAX_POS MANUAL_Z_HOME_POS
+
+//===========================================================================
+//========================= Filament Runout Sensor ==========================
+//===========================================================================
+//#define FILAMENT_RUNOUT_SENSOR // Uncomment for defining a filament runout sensor such as a mechanical or opto endstop to check the existence of filament
+                                 // In RAMPS uses servo pin 2. Can be changed in pins file. For other boards pin definition should be made.
+                                 // It is assumed that when logic high = filament available
+                                 //                    when logic  low = filament ran out
+#ifdef FILAMENT_RUNOUT_SENSOR
+  const bool FIL_RUNOUT_INVERTING = true;  // Should be uncommented and true or false should assigned
+  #define ENDSTOPPULLUP_FIL_RUNOUT // Uncomment to use internal pullup for filament runout pins if the sensor is defined.
+  #define FILAMENT_RUNOUT_SCRIPT "M600"
+#endif
+
+//===========================================================================
+//=========================== Manual Bed Leveling ===========================
+//===========================================================================
+#define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)
+#define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)
+#define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
+
+//===========================================================================
+//============================ Bed Auto Leveling ============================
+//===========================================================================
+
+// @section bedlevel
+
+#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+// /// #define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
+
+#ifdef ENABLE_AUTO_BED_LEVELING
+
+  // There are 2 different ways to specify probing locations
+  //
+  // - "grid" mode
+  //   Probe several points in a rectangular grid.
+  //   You specify the rectangle and the density of sample points.
+  //   This mode is preferred because there are more measurements.
+  //
+  // - "3-point" mode
+  //   Probe 3 arbitrary points on the bed (that aren't colinear)
+  //   You specify the XY coordinates of all 3 points.
+
+  // Enable this to sample the bed in a grid (least squares solution)
+  // Note: this feature generates 10KB extra code size
+  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode
+
+  // with AUTO_BED_LEVELING_GRID, the bed is sampled in a
+  // AUTO_BED_LEVELING_GRID_POINTSxAUTO_BED_LEVELING_GRID_POINTS grid
+  // and least squares solution is calculated
+  // Note: this feature occupies 10'206 byte
+  #ifdef AUTO_BED_LEVELING_GRID
+
+    // set the rectangle in which to probe
+    #define DELTA_PROBABLE_RADIUS (DELTA_PRINTABLE_RADIUS-25)
+    #define LEFT_PROBE_BED_POSITION -DELTA_PROBABLE_RADIUS
+    #define RIGHT_PROBE_BED_POSITION DELTA_PROBABLE_RADIUS
+    #define FRONT_PROBE_BED_POSITION -DELTA_PROBABLE_RADIUS
+    #define BACK_PROBE_BED_POSITION DELTA_PROBABLE_RADIUS
+
+    #define MIN_PROBE_EDGE 10 // The probe square sides can be no smaller than this
+    // probe at the points of a lattice grid
+    #define AUTO_BED_LEVELING_GRID_POINTS 7
+    #define AUTO_BED_LEVELING_GRID_X ((RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS - 1))
+    #define AUTO_BED_LEVELING_GRID_Y ((BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS - 1))
+
+    // Non-linear bed leveling will be used.
+    // Compensate by interpolating between the nearest four Z probe values for each point.
+    // Useful for deltas where the print surface may appear like a bowl or dome shape.
+    // Works best with ACCURATE_BED_LEVELING_POINTS 5 or higher.
+    #define NONLINEAR_BED_LEVELING
+
+  #else  // not AUTO_BED_LEVELING_GRID
+
+      // Arbitrary points to probe. A simple cross-product
+      // is used to estimate the plane of the bed.
+      #define ABL_PROBE_PT_1_X 15
+      #define ABL_PROBE_PT_1_Y 180
+      #define ABL_PROBE_PT_2_X 15
+      #define ABL_PROBE_PT_2_Y 20
+      #define ABL_PROBE_PT_3_X 170
+      #define ABL_PROBE_PT_3_Y 20
+
+  #endif // AUTO_BED_LEVELING_GRID
+
+  // Offsets to the probe relative to the extruder tip (Hotend - Probe)
+  // X and Y offsets must be integers
+  #define X_PROBE_OFFSET_FROM_EXTRUDER -23 // KosselPro actual: -22.919
+  #define Y_PROBE_OFFSET_FROM_EXTRUDER -6  // KosselPro actual: -6.304
+  // Kossel Pro note: The correct value is likely -17.45 but I'd rather err on the side of
+  // not giving someone a head crash. Use something like G29 Z-0.2 to adjust as needed.
+  #define Z_PROBE_OFFSET_FROM_EXTRUDER -17.25  // Increase this if the first layer is too thin (remember: it's a negative number so increase means closer to zero).
+
+  #define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z before homing (G28) for Probe Clearance.
+                                        // Be sure you have this distance over your Z_MAX_POS in case
+
+  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min
+
+  #define Z_RAISE_BEFORE_PROBING 100  //How much the extruder will be raised before traveling to the first probing point.
+  #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
+  #define Z_RAISE_AFTER_PROBING 15    //How much the extruder will be raised after the last probing point.
+
+//   #define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" //These commands will be executed in the end of G29 routine.
+                                                                            //Useful to retract a deployable probe.
+
+  //#define Z_PROBE_SLED // turn on if you have a z-probe mounted on a sled like those designed by Charles Bell
+  //#define SLED_DOCKING_OFFSET 5 // the extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
+
+  //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk
+  //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
+  // You MUST HAVE the SERVO_ENDSTOPS defined to use here a value higher than zero otherwise your code will not compile.
+
+  // Allen key retractable z-probe as seen on many Kossel delta printers - http://reprap.org/wiki/Kossel#Automatic_bed_leveling_probe
+  // Deploys by touching z-axis belt. Retracts by pushing the probe down. Uses Z_MIN_PIN.
+  #define Z_PROBE_ALLEN_KEY
+
+  #ifdef Z_PROBE_ALLEN_KEY
+    // 2 or 3 sets of coordinates for deploying and retracting the spring loaded touch probe on G29,
+    // if servo actuated touch probe is not defined. Uncomment as appropriate for your printer/probe.
+
+    // Allen key retractable z-probe as seen on many Kossel delta printers - http://reprap.org/wiki/Kossel#Automatic_bed_leveling_probe
+    // Deploys by touching z-axis belt. Retracts by pushing the probe down. Uses Z_MIN_PIN.
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_X 30
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y DELTA_PRINTABLE_RADIUS
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z 100
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE HOMING_FEEDRATE_X
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_X 0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y DELTA_PRINTABLE_RADIUS
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z 100
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE (HOMING_FEEDRATE_X/10)
+
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_X -64.0 // Move the probe into position
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_Y 56.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_Z 23.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE HOMING_FEEDRATE_X
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_X -64.0 // Push it down
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_Y 56.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_Z 3.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE (HOMING_FEEDRATE_X/10)
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_X -64.0 // Move it up to clear
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_Y 56.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_Z 50.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE HOMING_FEEDRATE_X
+
+    // Kossel Mini
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_X 35.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y 72.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z 100.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE (HOMING_FEEDRATE_X/10)
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_X 0.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y 0.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z 100.0
+    //#define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE (HOMING_FEEDRATE_X/10)
+
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_X -46.0 // Move the probe into position
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_Y 59.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_Z 28.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE HOMING_FEEDRATE_X
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_X -46.0 // Move the nozzle down further to push the probe into retracted position.
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_Y 59.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_Z 8.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE (HOMING_FEEDRATE_Z/10)
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_X -46.0 // Raise things back up slightly so we don't bump into anything
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_Y 59.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_Z 38.0
+    //#define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE HOMING_FEEDRATE_Z
+
+    // Kossel Pro
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X -105.00 // Move left but not quite so far that we'll bump the belt
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y 0.00
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z 100.0
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE HOMING_FEEDRATE_X
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X -110.00 // Move outward to position deploy pin to the left of the arm
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y -125.00
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z 100.0
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE HOMING_FEEDRATE_X
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X 45.00 // Move right to trigger deploy pin
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y -125.00
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z 100.0
+    #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE (HOMING_FEEDRATE_X/2)
+
+    #define Z_PROBE_ALLEN_KEY_STOW_1_X 36.00 // Line up with bed retaining clip
+    #define Z_PROBE_ALLEN_KEY_STOW_1_Y -122.00
+    #define Z_PROBE_ALLEN_KEY_STOW_1_Z 75.0
+    #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE HOMING_FEEDRATE_X
+    #define Z_PROBE_ALLEN_KEY_STOW_2_X 36.00 // move down to retract probe
+    #define Z_PROBE_ALLEN_KEY_STOW_2_Y -122.00
+    #define Z_PROBE_ALLEN_KEY_STOW_2_Z 25.0
+    #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE (HOMING_FEEDRATE_Z/2)
+    #define Z_PROBE_ALLEN_KEY_STOW_3_X 0.0  // return to 0,0,100
+    #define Z_PROBE_ALLEN_KEY_STOW_3_Y 0.0
+    #define Z_PROBE_ALLEN_KEY_STOW_3_Z 100.0
+    #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE HOMING_FEEDRATE_Z
+  #endif
+
+//  #define PROBE_SERVO_DEACTIVATION_DELAY 300
+
+
+//If you have enabled the Bed Auto Leveling and are using the same Z Probe for Z Homing,
+//it is highly recommended you let this Z_SAFE_HOMING enabled!!!
+
+  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
+                          // When defined, it will:
+                          // - Allow Z homing only after X and Y homing AND stepper drivers still enabled
+                          // - If stepper drivers timeout, it will need X and Y homing again before Z homing
+                          // - Position the probe in a defined XY point before Z Homing when homing all axis (G28)
+                          // - Block Z homing only when the probe is outside bed area.
+
+  #ifdef Z_SAFE_HOMING
+
+    #define Z_SAFE_HOMING_X_POINT (X_MAX_LENGTH/2)    // X point for Z homing when homing all axis (G28)
+    #define Z_SAFE_HOMING_Y_POINT (Y_MAX_LENGTH/2)    // Y point for Z homing when homing all axis (G28)
+
+
+  // Support for a dedicated Z PROBE endstop separate from the Z MIN endstop.
+  // If you would like to use both a Z PROBE and a Z MIN endstop together or just a Z PROBE with a custom pin, uncomment #define Z_PROBE_ENDSTOP and read the instructions below.
+  // If you want to still use the Z min endstop for homing, disable Z_SAFE_HOMING above. Eg; to park the head outside the bed area when homing with G28.
+  // WARNING: The Z MIN endstop will need to set properly as it would without a Z PROBE to prevent head crashes and premature stopping during a print.
+  // To use a separate Z PROBE endstop, you must have a Z_PROBE_PIN defined in the pins.h file for your control board.
+  // If you are using a servo based Z PROBE, you will need to enable NUM_SERVOS, SERVO_ENDSTOPS and SERVO_ENDSTOPS_ANGLES in the R/C Servo below.
+  // RAMPS 1.3/1.4 boards may be able to use the 5V, Ground and the D32 pin in the Aux 4 section of the RAMPS board. Use 5V for powered sensors, otherwise connect to ground and D32
+  // for normally closed configuration and 5V and D32 for normally open configurations. Normally closed configuration is advised and assumed.
+  // The D32 pin in Aux 4 on RAMPS maps to the Arduino D32 pin. Z_PROBE_PIN is setting the pin to use on the Arduino. Since the D32 pin on the RAMPS maps to D32 on Arduino, this works.
+  // D32 is currently selected in the RAMPS 1.3/1.4 pin file. All other boards will need changes to the respective pins_XXXXX.h file.
+  // WARNING: Setting the wrong pin may have unexpected and potentially disastrous outcomes. Use with caution and do your homework.
+
+  //#define Z_PROBE_ENDSTOP
+  #endif // Z_SAFE_HOMING
+
+#endif // ENABLE_AUTO_BED_LEVELING
+
+
+// @section homing
+
+// The position of the homing switches
+#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
+
+// Manual homing switch locations:
+// For deltabots this means top and center of the Cartesian print volume.
+#ifdef MANUAL_HOME_POSITIONS
+  #define MANUAL_X_HOME_POS 0
+  #define MANUAL_Y_HOME_POS 0
+  #define MANUAL_Z_HOME_POS 277 // For delta: Distance between nozzle and print surface after homing.
+#endif
+
+// @section movement
+
+/**
+ * MOVEMENT SETTINGS
+ */
+
+  ////// #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
+// set the homing speeds (mm/min)
+// delta homing speeds must be the same on xyz
+#define HOMING_FEEDRATE_X (200*60)
+#define HOMING_FEEDRATE_Y (200*60)
+#define HOMING_FEEDRATE_Z (200*60)
+#define HOMING_FEEDRATE_E 0
+#define HOMING_FEEDRATE {HOMING_FEEDRATE_X,HOMING_FEEDRATE_Y,HOMING_FEEDRATE_Z,HOMING_FEEDRATE_E}
+
+#define XYZ_FULL_STEPS_PER_ROTATION 200
+#define XYZ_MICROSTEPS 32
+#define XYZ_BELT_PITCH 2
+#define XYZ_PULLEY_TEETH 20
+#define XYZ_STEPS (XYZ_FULL_STEPS_PER_ROTATION * XYZ_MICROSTEPS / double(XYZ_BELT_PITCH) / double(XYZ_PULLEY_TEETH))
+
+// default settings
+// delta speeds must be the same on xyz
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {XYZ_STEPS, XYZ_STEPS, XYZ_STEPS, 184.8}
+#define DEFAULT_MAX_FEEDRATE          {200, 200, 200, 200}    // (mm/sec)
+#define DEFAULT_MAX_ACCELERATION      {9000,9000,9000,9000}    // X, Y, Z, E maximum start speed for accelerated moves.
+
+#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E acceleration in mm/s^2 for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration in mm/s^2 for retracts
+#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves
+
+// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
+// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
+// For the other hotends it is their distance from the extruder 0 hotend.
+// #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
+// #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
+
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
+#define DEFAULT_XYJERK                20.0    // (mm/sec)
+#define DEFAULT_ZJERK                 20.0    // (mm/sec) Must be same as XY for delta
+#define DEFAULT_EJERK                 5.0     // (mm/sec)
+
+
+//=============================================================================
+//============================= Additional Features ===========================
+//=============================================================================
+
+// @section more
+
+// Custom M code points
+#define CUSTOM_M_CODES
+#ifdef CUSTOM_M_CODES
+  #ifdef ENABLE_AUTO_BED_LEVELING
+    #define CUSTOM_M_CODE_SET_Z_PROBE_OFFSET 851
+    #define Z_PROBE_OFFSET_RANGE_MIN -15
+    #define Z_PROBE_OFFSET_RANGE_MAX -5
+  #endif
+#endif
+
+// @section extras
+
+// EEPROM
+// The microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores parameters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+//define this to enable EEPROM support
+#ifdef EEPROM_SETTINGS
+  // To disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
+  #define EEPROM_CHITCHAT // Please keep turned on if you can.
+#endif
+
+// @section temperature
+
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+//==============================LCD and SD support=============================
+// @section lcd
+
+// Define your display language below. Replace (en) with your language code and uncomment.
+// en, pl, fr, de, es, ru, it, pt, pt-br, fi, an, nl, ca, eu, kana, kana_utf8, cn, test
+// See also language.h
+#define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(en)
+
+// Choose ONE of these 3 charsets. This has to match your hardware. Ignored for full graphic display.
+// To find out what type you have - compile with (test) - upload - click to get the menu. You'll see two typical lines from the upper half of the charset.
+// See also documentation/LCDLanguageFont.md
+  #define DISPLAY_CHARSET_HD44780_JAPAN        // this is the most common hardware
+  //#define DISPLAY_CHARSET_HD44780_WESTERN
+  //#define DISPLAY_CHARSET_HD44780_CYRILLIC
+
+//#define ULTRA_LCD  //general LCD support, also 16x2
+//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
+#define SDSUPPORT // Enable SD Card Support in Hardware Console
+//#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
+//#define SD_CHECK_AND_RETRY // Use CRC checks and retries on the SD communication
+//#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder
+//#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
+//#define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.
+//#define ULTIPANEL  //the UltiPanel as on Thingiverse
+//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100 // the duration the buzzer plays the UI feedback sound. ie Screen Click
+//#define LCD_FEEDBACK_FREQUENCY_HZ 1000         // this is the tone frequency the buzzer plays when on UI feedback. ie Screen Click
+                                                 // 0 to disable buzzer feedback. Test with M300 S<frequency Hz> P<duration ms>
+
+// The MaKr3d Makr-Panel with graphic controller and SD support
+// http://reprap.org/wiki/MaKr3d_MaKrPanel
+//#define MAKRPANEL
+
+// The Panucatt Devices Viki 2.0 and mini Viki with Graphic LCD
+// http://panucatt.com
+// ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
+//#define VIKI2
+//#define miniVIKI
+
+// This is a new controller currently under development.  https://github.com/eboston/Adafruit-ST7565-Full-Graphic-Controller/
+//
+// ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
+//#define ELB_FULL_GRAPHIC_CONTROLLER
+
+// The RepRapDiscount Smart Controller (white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
+// The GADGETS3D G3D LCD/SD Controller (blue PCB)
+// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
+//#define G3D_PANEL
+
+// The RepRapDiscount FULL GRAPHIC Smart Controller (quadratic white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
+//
+// ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
+//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+
+// The RepRapWorld REPRAPWORLD_KEYPAD v1.1
+// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
+//#define REPRAPWORLD_KEYPAD
+//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click
+
+// The Elefu RA Board Control Panel
+// http://www.elefu.com/index.php?route=product/product&product_id=53
+// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARDUINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C
+//#define RA_CONTROL_PANEL
+
+//automatic expansion
+#if defined (MAKRPANEL)
+ #define DOGLCD
+ #define SDSUPPORT
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define DEFAULT_LCD_CONTRAST 17
+#endif
+
+#if defined (REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)
+ #define DOGLCD
+ #define U8GLIB_ST7920
+ #define REPRAP_DISCOUNT_SMART_CONTROLLER
+#endif
+
+#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+#endif
+
+#if defined(REPRAPWORLD_KEYPAD)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+#if defined(RA_CONTROL_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define LCD_I2C_TYPE_PCA8574
+ #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+#endif
+
+/**
+ * I2C Panels
+ */
+
+//#define LCD_I2C_SAINSMART_YWROBOT
+#ifdef LCD_I2C_SAINSMART_YWROBOT
+  // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )
+  // Make sure it is placed in the Arduino libraries directory.
+  #define LCD_I2C_TYPE_PCF8575
+  #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+
+// PANELOLU2 LCD with status LEDs, separate encoder and click inputs
+//#define LCD_I2C_PANELOLU2
+#ifdef LCD_I2C_PANELOLU2
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)
+  // Note: The PANELOLU2 encoder click input can either be directly connected to a pin
+  //       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
+  #define NEWPANEL
+  #define ULTIPANEL
+
+  #ifndef ENCODER_PULSES_PER_STEP
+	#define ENCODER_PULSES_PER_STEP 4
+  #endif
+
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+	#define ENCODER_STEPS_PER_MENU_ITEM 1
+  #endif
+
+
+  #ifdef LCD_USE_I2C_BUZZER
+	#define LCD_FEEDBACK_FREQUENCY_HZ 1000
+	#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
+  #endif
+
+#endif
+
+// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
+//#define LCD_I2C_VIKI
+#ifdef LCD_I2C_VIKI
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // Note: The pause/stop/resume LCD button pin should be connected to the Arduino
+  //       BTN_ENC pin (or set BTN_ENC to -1 if not used)
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+
+// Shift register panels
+// ---------------------
+// 2 wire Non-latching LCD SR from:
+// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+//#define SR_LCD
+#ifdef SR_LCD
+   #define SR_LCD_2W_NL    // Non latching 2 wire shift register
+   //#define NEWPANEL
+#endif
+
+
+// @section extras
+#ifdef ULTIPANEL
+//  #define NEWPANEL  //enable this if you have a click-encoder panel
+  #define SDSUPPORT
+  #define ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the DOG graphic display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 4
+  #endif
+#else //no panel but just LCD
+  #ifdef ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 16
+    #define LCD_HEIGHT 2
+  #endif
+  #endif
+#endif
+
+// default LCD contrast for dogm-like LCD displays
+#ifdef DOGLCD
+# ifndef DEFAULT_LCD_CONTRAST
+#  define DEFAULT_LCD_CONTRAST 32
+# endif
+#endif
+
+// Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
+//#define FAST_PWM_FAN
+
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not as annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
+// Temperature status LEDs that display the hotend and bet temperature.
+// If all hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
+// Otherwise the RED led is on. There is 1C hysteresis.
+//#define TEMP_STAT_LEDS
+
+// M240  Triggers a camera by emulating a Canon RC-1 Remote
+// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
+// #define PHOTOGRAPH_PIN     23
+
+// SkeinForge sends the wrong arc g-codes when using Arc Point as fillet procedure
+//#define SF_ARC_FIX
+
+// Support for the BariCUDA Paste Extruder.
+//#define BARICUDA
+
+//define BlinkM/CyzRgb Support
+//#define BLINKM
+
+/*********************************************************************\
+* R/C SERVO support
+* Sponsored by TrinityLabs, Reworked by codexmas
+**********************************************************************/
+
+// Number of servos
+//
+// If you select a configuration below, this will receive a default value and does not need to be set manually
+// set it manually if you have more servos than extruders and wish to manually control some
+// leaving it undefined or defining as 0 will disable the servo subsystem
+// If unsure, leave commented / disabled
+//
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
+
+// Servo Endstops
+//
+// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.
+// Use M206 command to correct for switch height offset to actual nozzle height. Store that setting with M500.
+//
+//#define SERVO_ENDSTOPS {-1, -1, 0} // Servo index for X, Y, Z. Disable with -1
+//#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 70,0} // X,Y,Z Axis Extend and Retract angles
+
+/**********************************************************************\
+ * Support for a filament diameter sensor
+ * Also allows adjustment of diameter at print time (vs  at slicing)
+ * Single extruder only at this point (extruder 0)
+ *
+ * Motherboards
+ * 34 - RAMPS1.4 - uses Analog input 5 on the AUX2 connector
+ * 81 - Printrboard - Uses Analog input 2 on the Exp1 connector (version B,C,D,E)
+ * 301 - Rambo  - uses Analog input 3
+ * Note may require analog pins to be defined for different motherboards
+ **********************************************************************/
+// Uncomment below to enable
+//#define FILAMENT_SENSOR
+
+#define FILAMENT_SENSOR_EXTRUDER_NUM	0  //The number of the extruder that has the filament sensor (0,1,2)
+#define MEASUREMENT_DELAY_CM			14  //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
+
+#define DEFAULT_NOMINAL_FILAMENT_DIA  3.0  //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation
+#define MEASURED_UPPER_LIMIT          3.30  //upper limit factor used for sensor reading validation in mm
+#define MEASURED_LOWER_LIMIT          1.90  //lower limit factor for sensor reading validation in mm
+#define MAX_MEASUREMENT_DELAY			20  //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)
+
+//defines used in the code
+#define DEFAULT_MEASURED_FILAMENT_DIA  DEFAULT_NOMINAL_FILAMENT_DIA  //set measured to nominal initially
+
+//When using an LCD, uncomment the line below to display the Filament sensor data on the last line instead of status.  Status will appear for 5 sec.
+//#define FILAMENT_LCD_DISPLAY
+
+
+
+
+
+
+#include "Configuration_adv.h"
+#include "thermistortables.h"
+
+#endif //CONFIGURATION_H
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
new file mode 100644
index 0000000..f40332d
--- /dev/null
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -0,0 +1,660 @@
+// Example configuration file for OpenBeam Kossel Pro
+// tested on 2015-05-19 by @Wackerbarth
+// using Arduino 1.6.5 (Mac)
+
+#ifndef CONFIGURATION_ADV_H
+#define CONFIGURATION_ADV_H
+
+#include "Conditionals.h"
+
+// @section temperature
+
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
+
+#ifdef BED_LIMIT_SWITCHING
+  #define BED_HYSTERESIS 2 //only disable heating if T>target+BED_HYSTERESIS and enable heating if T>target-BED_HYSTERESIS
+#endif
+#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control
+
+/**
+ * Heating Sanity Check
+ *
+ * Whenever an M104 or M109 increases the target temperature this will wait for WATCH_TEMP_PERIOD milliseconds,
+ * and if the temperature hasn't increased by WATCH_TEMP_INCREASE degrees, the machine is halted, requiring a
+ * hard reset. This test restarts with any M104/M109, but only if the current temperature is below the target
+ * by at least 2 * WATCH_TEMP_INCREASE degrees celsius.
+ */
+#ifdef THERMAL_RUNAWAY_PROTECTION_HOTENDS
+  #define THERMAL_RUNAWAY_PROTECTION_PERIOD 40        // Seconds
+  #define THERMAL_RUNAWAY_PROTECTION_HYSTERESIS 4     // Degrees Celsius
+
+  /**
+   * Whenever an M104 or M109 increases the target temperature the firmware will wait for the
+   * WATCH_TEMP_PERIOD to expire, and if the temperature hasn't increased by WATCH_TEMP_INCREASE
+   * degrees, the machine is halted, requiring a hard reset. This test restarts with any M104/M109,
+   * but only if the current temperature is far enough below the target for a reliable test.
+   */
+  #define WATCH_TEMP_PERIOD 16                // Seconds
+  #define WATCH_TEMP_INCREASE 4               // Degrees Celsius
+#endif
+
+#ifdef THERMAL_RUNAWAY_PROTECTION_BED
+  #define THERMAL_RUNAWAY_PROTECTION_BED_PERIOD 20    // Seconds
+  #define THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS 2 // Degrees Celsius
+#endif
+
+#ifdef PIDTEMP
+  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.
+  // if Kc is chosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE
+  #ifdef PID_ADD_EXTRUSION_RATE
+    #define  DEFAULT_Kc (1) //heating power=Kc*(e_speed)
+  #endif
+#endif
+
+
+//automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.
+//The maximum buffered steps/sec of the extruder motor are called "se".
+//You enter the autotemp mode by a M109 S<mintemp> B<maxtemp> F<factor>
+// the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp
+// you exit the value by any M109 without F*
+// Also, if the temperature is set to a value <mintemp, it is not changed by autotemp.
+// on an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
+#define AUTOTEMP
+#ifdef AUTOTEMP
+  #define AUTOTEMP_OLDWEIGHT 0.98
+#endif
+
+//Show Temperature ADC value
+//The M105 command return, besides traditional information, the ADC value read from temperature sensors.
+//#define SHOW_TEMP_ADC_VALUES
+
+// @section extruder
+
+//  extruder run-out prevention.
+//if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
+//#define EXTRUDER_RUNOUT_PREVENT
+#define EXTRUDER_RUNOUT_MINTEMP 190
+#define EXTRUDER_RUNOUT_SECONDS 30.
+#define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
+#define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed
+#define EXTRUDER_RUNOUT_EXTRUDE 100
+
+// @section temperature
+
+//These defines help to calibrate the AD595 sensor in case you get wrong temperature measurements.
+//The measured temperature is defined as "actualTemp = (measuredTemp * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET"
+#define TEMP_SENSOR_AD595_OFFSET 0.0
+#define TEMP_SENSOR_AD595_GAIN   1.0
+
+//This is for controlling a fan to cool down the stepper drivers
+//it will turn on when any driver is enabled
+//and turn off after the set amount of seconds from last driver being disabled again
+#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)
+#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run
+#define CONTROLLERFAN_SPEED 255  // == full speed
+
+// When first starting the main fan, run it at full speed for the
+// given number of milliseconds.  This gets the fan spinning reliably
+// before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)
+//#define FAN_KICKSTART_TIME 100
+
+// @section extruder
+
+// Extruder cooling fans
+// Configure fan pin outputs to automatically turn on/off when the associated
+// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
+// Multiple extruders can be assigned to the same pin in which case
+// the fan will turn on when any selected extruder is above the threshold.
+#define EXTRUDER_0_AUTO_FAN_PIN -1
+#define EXTRUDER_1_AUTO_FAN_PIN -1
+#define EXTRUDER_2_AUTO_FAN_PIN -1
+#define EXTRUDER_3_AUTO_FAN_PIN -1
+#define EXTRUDER_AUTO_FAN_TEMPERATURE 50
+#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
+
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+// @section homing
+
+#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
+
+// @section extras
+
+//// AUTOSET LOCATIONS OF LIMIT SWITCHES
+//// Added by ZetaPhoenix 09-15-2012
+#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations
+  #define X_HOME_POS MANUAL_X_HOME_POS
+  #define Y_HOME_POS MANUAL_Y_HOME_POS
+  #define Z_HOME_POS MANUAL_Z_HOME_POS
+#else //Set min/max homing switch positions based upon homing direction and min/max travel limits
+  //X axis
+  #if X_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * -0.5
+    #else
+      #define X_HOME_POS X_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * 0.5
+    #else
+      #define X_HOME_POS X_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //X_HOME_DIR == -1
+
+  //Y axis
+  #if Y_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * -0.5
+    #else
+      #define Y_HOME_POS Y_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * 0.5
+    #else
+      #define Y_HOME_POS Y_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //Y_HOME_DIR == -1
+
+  // Z axis
+  #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
+    #define Z_HOME_POS Z_MIN_POS
+  #else
+    #define Z_HOME_POS Z_MAX_POS
+  #endif //Z_HOME_DIR == -1
+#endif //End auto min/max positions
+//END AUTOSET LOCATIONS OF LIMIT SWITCHES -ZP
+
+
+//#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
+
+// A single Z stepper driver is usually used to drive 2 stepper motors.
+// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
+// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
+// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
+// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+//#define Z_DUAL_STEPPER_DRIVERS
+
+#ifdef Z_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+// Same again but for Y Axis.
+//#define Y_DUAL_STEPPER_DRIVERS
+
+// Define if the two Y drives need to rotate in opposite directions
+#define INVERT_Y2_VS_Y_DIR true
+
+#ifdef Y_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+#if defined (Z_DUAL_STEPPER_DRIVERS) && defined (Y_DUAL_STEPPER_DRIVERS)
+  #error "You cannot have dual drivers for both Y and Z"
+#endif
+
+// Enable this for dual x-carriage printers.
+// A dual x-carriage design has the advantage that the inactive extruder can be parked which
+// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
+// allowing faster printing speeds.
+//#define DUAL_X_CARRIAGE
+#ifdef DUAL_X_CARRIAGE
+  // Configuration for second X-carriage
+  // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
+  // the second x-carriage always homes to the maximum endstop.
+  #define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
+  #define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed
+  #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
+  #define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position
+      // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software
+      // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
+      // without modifying the firmware (through the "M218 T1 X???" command).
+      // Remember: you should set the second extruder x-offset to 0 in your slicer.
+
+  // Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)
+  #define X2_ENABLE_PIN 29
+  #define X2_STEP_PIN 25
+  #define X2_DIR_PIN 23
+
+  // There are a few selectable movement modes for dual x-carriages using M605 S<mode>
+  //    Mode 0: Full control. The slicer has full control over both x-carriages and can achieve optimal travel results
+  //                           as long as it supports dual x-carriages. (M605 S0)
+  //    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
+  //                           that additional slicer support is not required. (M605 S1)
+  //    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all
+  //                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
+  //                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
+
+  // This is the default power-up mode which can be later using M605.
+  #define DEFAULT_DUAL_X_CARRIAGE_MODE 0
+
+  // Default settings in "Auto-park Mode"
+  #define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
+  #define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
+
+  // Default x offset in duplication mode (typically set to half print bed width)
+  #define DEFAULT_DUPLICATION_X_OFFSET 100
+
+#endif //DUAL_X_CARRIAGE
+
+// @section homing
+
+//homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
+#define X_HOME_BUMP_MM 5
+#define Y_HOME_BUMP_MM 5
+#define Z_HOME_BUMP_MM 5 // deltas need the same for all three axis
+#define HOMING_BUMP_DIVISOR {10, 10, 20}  // Re-Bump Speed Divisor (Divides the Homing Feedrate)
+//#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
+
+// When G28 is called, this option will make Y home before X
+// #define HOME_Y_BEFORE_X
+
+// @section machine
+
+#define AXIS_RELATIVE_MODES {false, false, false, false}
+
+// @section machine
+
+#ifdef CONFIG_STEPPERS_TOSHIBA
+#define MAX_STEP_FREQUENCY 10000 // Max step frequency for Toshiba Stepper Controllers
+#else
+#define MAX_STEP_FREQUENCY 40000 // Max step frequency for Ultimaker (5000 pps / half step)
+#endif
+//By default pololu step drivers require an active high signal. However, some high power drivers require an active low signal as step.
+#define INVERT_X_STEP_PIN false
+#define INVERT_Y_STEP_PIN false
+#define INVERT_Z_STEP_PIN false
+#define INVERT_E_STEP_PIN false
+
+// Default stepper release if idle. Set to 0 to deactivate.
+#define DEFAULT_STEPPER_DEACTIVE_TIME 60
+
+#define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate
+#define DEFAULT_MINTRAVELFEEDRATE     0.0
+
+// @section lcd
+
+#ifdef ULTIPANEL
+  #define MANUAL_FEEDRATE {50*60, 50*60, 4*60, 60} // Feedrates for manual moves along X, Y, Z, E from panel
+  #define ULTIPANEL_FEEDMULTIPLY  // Comment to disable setting feedrate multiplier via encoder
+#endif
+
+// @section extras
+
+// minimum time in microseconds that a movement needs to take if the buffer is emptied.
+#define DEFAULT_MINSEGMENTTIME        20000
+
+// If defined the movements slow down when the look ahead buffer is only half full
+// (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
+//#define SLOWDOWN
+
+// Frequency limit
+// See nophead's blog for more info
+// Not working O
+//#define XY_FREQUENCY_LIMIT  15
+
+// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end
+// of the buffer and all stops. This should not be much greater than zero and should only be changed
+// if unwanted behavior is observed on a user's machine when running at very slow speeds.
+#define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)
+
+// MS1 MS2 Stepper Driver Microstepping mode table
+#define MICROSTEP1 LOW,LOW
+#define MICROSTEP2 HIGH,LOW
+#define MICROSTEP4 LOW,HIGH
+#define MICROSTEP8 HIGH,HIGH
+#define MICROSTEP16 HIGH,HIGH
+
+// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.
+#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]
+
+// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
+#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
+
+// uncomment to enable an I2C based DIGIPOT like on the Azteeg X3 Pro
+//#define DIGIPOT_I2C
+// Number of channels available for I2C digipot, For Azteeg X3 Pro we have 8
+#define DIGIPOT_I2C_NUM_CHANNELS 8
+// actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
+#define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}
+
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
+
+//#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
+#define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
+
+// @section lcd
+
+#ifdef SDSUPPORT
+
+  // If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
+  // You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT
+  // in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
+  // be commented out otherwise
+  #define SDCARDDETECTINVERTED
+
+  #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
+  #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
+
+  #define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the file system block order.
+  // if a file is deleted, it frees a block. hence, the order is not purely chronological. To still have auto0.g accessible, there is again the option to do that.
+  // using:
+  //#define MENU_ADDAUTOSTART
+
+  // Show a progress bar on HD44780 LCDs for SD printing
+  //#define LCD_PROGRESS_BAR
+
+  #ifdef LCD_PROGRESS_BAR
+    // Amount of time (ms) to show the bar
+    #define PROGRESS_BAR_BAR_TIME 2000
+    // Amount of time (ms) to show the status message
+    #define PROGRESS_BAR_MSG_TIME 3000
+    // Amount of time (ms) to retain the status message (0=forever)
+    #define PROGRESS_MSG_EXPIRE   0
+    // Enable this to show messages for MSG_TIME then hide them
+    //#define PROGRESS_MSG_ONCE
+  #endif
+
+#endif // SDSUPPORT
+
+// for dogm lcd displays you can choose some additional fonts:
+#ifdef DOGLCD
+  // save 3120 bytes of PROGMEM by commenting out #define USE_BIG_EDIT_FONT
+  // we don't have a big font for Cyrillic, Kana
+  //#define USE_BIG_EDIT_FONT
+ 
+  // If you have spare 2300Byte of progmem and want to use a 
+  // smaller font on the Info-screen uncomment the next line.
+  //#define USE_SMALL_INFOFONT
+#endif // DOGLCD
+
+// @section more
+
+// The hardware watchdog should reset the microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
+//#define USE_WATCHDOG
+
+#ifdef USE_WATCHDOG
+// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.
+// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.
+//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
+//#define WATCHDOG_RESET_MANUAL
+#endif
+
+// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
+//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+
+// @section lcd
+
+// Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process
+// it can e.g. be used to change z-positions in the print startup phase in real-time
+// does not respect endstops!
+//#define BABYSTEPPING
+#ifdef BABYSTEPPING
+  #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
+  #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
+  #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
+
+// @section extruder
+  #ifdef COREXY
+    #error BABYSTEPPING not implemented for COREXY yet.
+  #endif
+
+  #ifdef DELTA
+    #ifdef BABYSTEP_XY
+      #error BABYSTEPPING only implemented for Z axis on deltabots.
+    #endif
+  #endif
+#endif
+
+// extruder advance constant (s2/mm3)
+//
+// advance (steps) = STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K * cubic mm per second ^ 2
+//
+// Hooke's law says:    force = k * distance
+// Bernoulli's principle says:  v ^ 2 / 2 + g . h + pressure / density = constant
+// so: v ^ 2 is proportional to number of steps we advance the extruder
+//#define ADVANCE
+
+#ifdef ADVANCE
+  #define EXTRUDER_ADVANCE_K .0
+
+  #define D_FILAMENT 2.85
+  #define STEPS_MM_E 836
+  #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUSION_AREA)
+
+// @section extras
+#endif // ADVANCE
+
+// Arc interpretation settings:
+#define MM_PER_ARC_SEGMENT 1
+#define N_ARC_CORRECTION 25
+
+const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
+
+#ifdef ULTIPANEL
+ #undef SDCARDDETECTINVERTED
+#endif
+
+// Power Signal Control Definitions
+// By default use ATX definition
+#ifndef POWER_SUPPLY
+  #define POWER_SUPPLY 1
+#endif
+// 1 = ATX
+#if (POWER_SUPPLY == 1)
+  #define PS_ON_AWAKE  LOW
+  #define PS_ON_ASLEEP HIGH
+#endif
+// 2 = X-Box 360 203W
+#if (POWER_SUPPLY == 2)
+  #define PS_ON_AWAKE  HIGH
+  #define PS_ON_ASLEEP LOW
+#endif
+
+// Control heater 0 and heater 1 in parallel.
+//#define HEATERS_PARALLEL
+
+//===========================================================================
+//================================= Buffers =================================
+//===========================================================================
+
+// @section hidden
+
+// The number of linear motions that can be in the plan at any give time.
+// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
+#if defined SDSUPPORT
+  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+#else
+  #define BLOCK_BUFFER_SIZE 64 // maximize block buffer
+#endif
+
+// @section more
+
+//The ASCII buffer for receiving from the serial:
+#define MAX_CMD_SIZE 96
+#define BUFSIZE 4
+
+// Bad Serial-connections can miss a received command by sending an 'ok'
+// Therefore some clients abort after 30 seconds in a timeout.
+// Some other clients start sending commands while receiving a 'wait'.
+// This "wait" is only sent when the buffer is empty. 1 second is a good value here.
+//#define NO_TIMEOUTS 1000 // Milliseconds
+
+// Some clients will have this feature soon. This could make the NO_TIMEOUTS unnecessary.
+//#define ADVANCED_OK
+
+// @section fwretract
+
+// Firmware based and LCD controlled retract
+// M207 and M208 can be used to define parameters for the retraction.
+// The retraction can be called by the slicer using G10 and G11
+// until then, intended retractions can be detected by moves that only extrude and the direction.
+// the moves are than replaced by the firmware controlled ones.
+
+// #define FWRETRACT  //ONLY PARTIALLY TESTED
+#ifdef FWRETRACT
+  #define MIN_RETRACT 0.1                //minimum extruded mm to accept a automatic gcode retraction attempt
+  #define RETRACT_LENGTH 3               //default retract length (positive mm)
+  #define RETRACT_LENGTH_SWAP 13         //default swap retract length (positive mm), for extruder change
+  #define RETRACT_FEEDRATE 45            //default feedrate for retracting (mm/s)
+  #define RETRACT_ZLIFT 0                //default retract Z-lift
+  #define RETRACT_RECOVER_LENGTH 0       //default additional recover length (mm, added to retract length when recovering)
+  #define RETRACT_RECOVER_LENGTH_SWAP 0  //default additional swap recover length (mm, added to retract length when recovering from extruder change)
+  #define RETRACT_RECOVER_FEEDRATE 8     //default feedrate for recovering from retraction (mm/s)
+#endif
+
+// Add support for experimental filament exchange support M600; requires display
+#ifdef ULTIPANEL
+  #define FILAMENTCHANGEENABLE
+  #ifdef FILAMENTCHANGEENABLE
+    #define FILAMENTCHANGE_XPOS 3
+    #define FILAMENTCHANGE_YPOS 3
+    #define FILAMENTCHANGE_ZADD 10
+    #define FILAMENTCHANGE_FIRSTRETRACT -2
+    #define FILAMENTCHANGE_FINALRETRACT -100
+  #endif
+#endif
+
+/******************************************************************************\
+ * enable this section if you have TMC26X motor drivers. 
+ * you need to import the TMC26XStepper library into the arduino IDE for this
+ ******************************************************************************/
+
+// @section tmc
+
+//#define HAVE_TMCDRIVER
+#ifdef HAVE_TMCDRIVER
+
+//  #define X_IS_TMC
+  #define X_MAX_CURRENT 1000  //in mA
+  #define X_SENSE_RESISTOR 91 //in mOhms
+  #define X_MICROSTEPS 16     //number of microsteps
+  
+//  #define X2_IS_TMC
+  #define X2_MAX_CURRENT 1000  //in mA
+  #define X2_SENSE_RESISTOR 91 //in mOhms
+  #define X2_MICROSTEPS 16     //number of microsteps
+  
+//  #define Y_IS_TMC
+  #define Y_MAX_CURRENT 1000  //in mA
+  #define Y_SENSE_RESISTOR 91 //in mOhms
+  #define Y_MICROSTEPS 16     //number of microsteps
+  
+//  #define Y2_IS_TMC
+  #define Y2_MAX_CURRENT 1000  //in mA
+  #define Y2_SENSE_RESISTOR 91 //in mOhms
+  #define Y2_MICROSTEPS 16     //number of microsteps 
+  
+//  #define Z_IS_TMC
+  #define Z_MAX_CURRENT 1000  //in mA
+  #define Z_SENSE_RESISTOR 91 //in mOhms
+  #define Z_MICROSTEPS 16     //number of microsteps
+  
+//  #define Z2_IS_TMC
+  #define Z2_MAX_CURRENT 1000  //in mA
+  #define Z2_SENSE_RESISTOR 91 //in mOhms
+  #define Z2_MICROSTEPS 16     //number of microsteps
+  
+//  #define E0_IS_TMC
+  #define E0_MAX_CURRENT 1000  //in mA
+  #define E0_SENSE_RESISTOR 91 //in mOhms
+  #define E0_MICROSTEPS 16     //number of microsteps
+  
+//  #define E1_IS_TMC
+  #define E1_MAX_CURRENT 1000  //in mA
+  #define E1_SENSE_RESISTOR 91 //in mOhms
+  #define E1_MICROSTEPS 16     //number of microsteps 
+  
+//  #define E2_IS_TMC
+  #define E2_MAX_CURRENT 1000  //in mA
+  #define E2_SENSE_RESISTOR 91 //in mOhms
+  #define E2_MICROSTEPS 16     //number of microsteps 
+  
+//  #define E3_IS_TMC
+  #define E3_MAX_CURRENT 1000  //in mA
+  #define E3_SENSE_RESISTOR 91 //in mOhms
+  #define E3_MICROSTEPS 16     //number of microsteps   
+
+#endif
+
+#ifdef FILAMENTCHANGEENABLE
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
+  #endif
+#endif
+
+//===========================================================================
+//=============================  Define Defines  ============================
+//===========================================================================
+#if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
+  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+#endif
+
+#if EXTRUDERS > 1 && defined HEATERS_PARALLEL
+  #error "You cannot use HEATERS_PARALLEL if EXTRUDERS > 1"
+#endif
+
+#if TEMP_SENSOR_0 > 0
+  #define THERMISTORHEATER_0 TEMP_SENSOR_0
+  #define HEATER_0_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_1 > 0
+  #define THERMISTORHEATER_1 TEMP_SENSOR_1
+  #define HEATER_1_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_2 > 0
+  #define THERMISTORHEATER_2 TEMP_SENSOR_2
+  #define HEATER_2_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_BED > 0
+  #define THERMISTORBED TEMP_SENSOR_BED
+  #define BED_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_0 == -1
+  #define HEATER_0_USES_AD595
+#endif
+#if TEMP_SENSOR_1 == -1
+  #define HEATER_1_USES_AD595
+#endif
+#if TEMP_SENSOR_2 == -1
+  #define HEATER_2_USES_AD595
+#endif
+#if TEMP_SENSOR_BED == -1
+  #define BED_USES_AD595
+#endif
+#if TEMP_SENSOR_0 == -2
+  #define HEATER_0_USES_MAX6675
+#endif
+#if TEMP_SENSOR_0 == 0
+  #undef HEATER_0_MINTEMP
+  #undef HEATER_0_MAXTEMP
+#endif
+#if TEMP_SENSOR_1 == 0
+  #undef HEATER_1_MINTEMP
+  #undef HEATER_1_MAXTEMP
+#endif
+#if TEMP_SENSOR_2 == 0
+  #undef HEATER_2_MINTEMP
+  #undef HEATER_2_MAXTEMP
+#endif
+#if TEMP_SENSOR_BED == 0
+  #undef BED_MINTEMP
+  #undef BED_MAXTEMP
+#endif
+
+#include "Conditionals.h"
+#include "SanityCheck.h"
+
+#endif //CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/delta/kossel_pro/readme.md b/Marlin/example_configurations/delta/kossel_pro/readme.md
new file mode 100644
index 0000000..37b5ccf
--- /dev/null
+++ b/Marlin/example_configurations/delta/kossel_pro/readme.md
@@ -0,0 +1,5 @@
+# Example Configuration for OpenBeam Kossel Pro [BRAINWAVE_PRO](http://www.openbeamusa.com/3d-printers/kossel/)
+* Configuration files for the **Openbeam Kossel Pro** as delivered in their KickStarter distribution
+
+I [@Wackerbarth](https://github.com/Wackerbarth) tested this version on my Kossel Pro and Arduino 1.6.5 for Mac.
+This configuration is a transition to merge Terence Tam's configuration with up-to-date Marlin source and a current Arduino IDE

commit 04a1622172fadd58f2af3e218407a662a7e4b9bb (from b878bc562056fe485d1c27d9ddbf6c334bc9c305)
Merge: 81c2ca3 b878bc5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 21 18:43:26 2015 -0700

    Merge pull request #2127 from Wackerbarth/Kossel_Pro
    
    Kossel Pro

diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 8818b1b..8a05298 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -313,6 +313,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 23a6f1a..fe63dba 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -34,6 +34,7 @@
 
 #define BIT(b) (1<<(b))
 #define TEST(n,b) (((n)&BIT(b))!=0)
+#define SET_BIT(n,b,value) (n) ^= ((-value)^(n)) & (BIT(b))
 #define RADIANS(d) ((d)*M_PI/180.0)
 #define DEGREES(r) ((d)*180.0/M_PI)
 #define NOLESS(v,n) do{ if (v < n) v = n; }while(0)
@@ -199,7 +200,7 @@ void manage_inactivity(bool ignore_stepper_queue=false);
  */
 enum AxisEnum {X_AXIS=0, Y_AXIS=1, A_AXIS=0, B_AXIS=1, Z_AXIS=2, E_AXIS=3, X_HEAD=4, Y_HEAD=5};
 
-enum EndstopEnum {X_MIN=0, Y_MIN=1, Z_MIN=2, Z_PROBE=3, X_MAX=4, Y_MAX=5, Z_MAX=6};
+enum EndstopEnum {X_MIN=0, Y_MIN=1, Z_MIN=2, Z_PROBE=3, X_MAX=4, Y_MAX=5, Z_MAX=6, Z2_MIN=7, Z2_MAX=8};
 
 void enable_all_steppers();
 void disable_all_steppers();
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 876d8e2..de8bd5a 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -120,6 +120,7 @@
  *        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
  *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
+ * M33  - Get the longname version of a path
  * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
  * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]
  * M80  - Turn on Power Supply
@@ -141,7 +142,7 @@
  * M112 - Emergency stop
  * M114 - Output current position to serial port
  * M115 - Capabilities string
- * M117 - display message
+ * M117 - Display a message on the controller screen
  * M119 - Output Endstop status to serial port
  * M120 - Enable endstop detection
  * M121 - Disable endstop detection
@@ -240,6 +241,7 @@ bool axis_known_position[3] = { false };
 
 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
 
+static char *current_command, *current_command_args;
 static int cmd_queue_index_r = 0;
 static int cmd_queue_index_w = 0;
 static int commands_in_queue = 0;
@@ -269,7 +271,7 @@ static bool relative_mode = false;  //Determines Absolute or Relative Coordinate
 static char serial_char;
 static int serial_count = 0;
 static boolean comment_mode = false;
-static char *strchr_pointer; ///< A pointer to find chars in the command string (X, Y, Z, E, etc.)
+static char *seen_pointer; ///< A pointer to find chars in the command string (X, Y, Z, E, etc.)
 const char* queued_commands_P= NULL; /* pointer to the current line in the active sequence of commands, or NULL when none */
 const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
 // Inactivity shutdown
@@ -789,21 +791,20 @@ void get_command() {
         fromsd[cmd_queue_index_w] = false;
       #endif
 
-      if (strchr(command, 'N') != NULL) {
-        strchr_pointer = strchr(command, 'N');
-        gcode_N = (strtol(strchr_pointer + 1, NULL, 10));
+      char *npos = strchr(command, 'N');
+      char *apos = strchr(command, '*');
+      if (npos) {
+        gcode_N = strtol(npos + 1, NULL, 10);
         if (gcode_N != gcode_LastN + 1 && strstr_P(command, PSTR("M110")) == NULL) {
           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
           return;
         }
 
-        if (strchr(command, '*') != NULL) {
-          byte checksum = 0;
-          byte count = 0;
+        if (apos) {
+          byte checksum = 0, count = 0;
           while (command[count] != '*') checksum ^= command[count++];
-          strchr_pointer = strchr(command, '*');
 
-          if (strtol(strchr_pointer + 1, NULL, 10) != checksum) {
+          if (strtol(apos + 1, NULL, 10) != checksum) {
             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
             return;
           }
@@ -817,28 +818,26 @@ void get_command() {
         gcode_LastN = gcode_N;
         // if no errors, continue parsing
       }
-      else {  // if we don't receive 'N' but still see '*'
-        if ((strchr(command, '*') != NULL)) {
-          gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
-          return;
-        }
+      else if (apos) { // No '*' without 'N'
+        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
+        return;
       }
 
-      if (strchr(command, 'G') != NULL) {
-        strchr_pointer = strchr(command, 'G');
-        switch (strtol(strchr_pointer + 1, NULL, 10)) {
-          case 0:
-          case 1:
-          case 2:
-          case 3:
-            if (IsStopped()) {
+      // Movement commands alert when stopped
+      if (IsStopped()) {
+        char *gpos = strchr(command, 'G');
+        if (gpos) {
+          int codenum = strtol(gpos + 1, NULL, 10);
+          switch (codenum) {
+            case 0:
+            case 1:
+            case 2:
+            case 3:
               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
               LCD_MESSAGEPGM(MSG_STOPPED);
-            }
-            break;
-          default:
-            break;
-        }
+              break;
+          }
+        }        
       }
 
       // If command was e-stop process now
@@ -920,32 +919,32 @@ void get_command() {
 
 bool code_has_value() {
   int i = 1;
-  char c = strchr_pointer[i];
-  if (c == '-' || c == '+') c = strchr_pointer[++i];
-  if (c == '.') c = strchr_pointer[++i];
+  char c = seen_pointer[i];
+  if (c == '-' || c == '+') c = seen_pointer[++i];
+  if (c == '.') c = seen_pointer[++i];
   return (c >= '0' && c <= '9');
 }
 
 float code_value() {
   float ret;
-  char *e = strchr(strchr_pointer, 'E');
+  char *e = strchr(seen_pointer, 'E');
   if (e) {
     *e = 0;
-    ret = strtod(strchr_pointer+1, NULL);
+    ret = strtod(seen_pointer+1, NULL);
     *e = 'E';
   }
   else
-    ret = strtod(strchr_pointer+1, NULL);
+    ret = strtod(seen_pointer+1, NULL);
   return ret;
 }
 
-long code_value_long() { return strtol(strchr_pointer + 1, NULL, 10); }
+long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }
 
-int16_t code_value_short() { return (int16_t)strtol(strchr_pointer + 1, NULL, 10); }
+int16_t code_value_short() { return (int16_t)strtol(seen_pointer + 1, NULL, 10); }
 
 bool code_seen(char code) {
-  strchr_pointer = strchr(command_queue[cmd_queue_index_r], code);
-  return (strchr_pointer != NULL);  //Return True if a character was found
+  seen_pointer = strchr(current_command_args, code); // +3 since "G0 " is the shortest prefix
+  return (seen_pointer != NULL);  //Return True if a character was found
 }
 
 #define DEFINE_PGM_READ_ANY(type, reader)       \
@@ -1796,6 +1795,13 @@ void gcode_get_destination() {
   }
 }
 
+void unknown_command_error() {
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
+  SERIAL_ECHO(current_command);
+  SERIAL_ECHOPGM("\"\n");
+}
+
 /**
  * G0, G1: Coordinated movement of X Y Z E axes
  */
@@ -2847,7 +2853,7 @@ inline void gcode_G92() {
    * M1: // M1 - Conditional stop - Wait for user button press on LCD
    */
   inline void gcode_M0_M1() {
-    char *src = strchr_pointer + 2;
+    char *args = current_command_args;
 
     millis_t codenum = 0;
     bool hasP = false, hasS = false;
@@ -2859,11 +2865,9 @@ inline void gcode_G92() {
       codenum = code_value() * 1000; // seconds to wait
       hasS = codenum > 0;
     }
-    char* starpos = strchr(src, '*');
-    if (starpos != NULL) *(starpos) = '\0';
-    while (*src == ' ') ++src;
-    if (!hasP && !hasS && *src != '\0')
-      lcd_setstatus(src, true);
+
+    if (!hasP && !hasS && *args != '\0')
+      lcd_setstatus(args, true);
     else {
       LCD_MESSAGEPGM(MSG_USERWAIT);
       #if defined(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
@@ -2936,10 +2940,7 @@ inline void gcode_M17() {
    * M23: Select a file
    */
   inline void gcode_M23() {
-    char* codepos = strchr_pointer + 4;
-    char* starpos = strchr(codepos, '*');
-    if (starpos) *starpos = '\0';
-    card.openFile(codepos, true);
+    card.openFile(current_command_args, true);
   }
 
   /**
@@ -2976,14 +2977,7 @@ inline void gcode_M17() {
    * M28: Start SD Write
    */
   inline void gcode_M28() {
-    char* codepos = strchr_pointer + 4;
-    char* starpos = strchr(codepos, '*');
-    if (starpos) {
-      char* npos = strchr(command_queue[cmd_queue_index_r], 'N');
-      strchr_pointer = strchr(npos, ' ') + 1;
-      *(starpos) = '\0';
-    }
-    card.openFile(codepos, false);
+    card.openFile(current_command_args, false);
   }
 
   /**
@@ -3000,13 +2994,7 @@ inline void gcode_M17() {
   inline void gcode_M30() {
     if (card.cardOK) {
       card.closefile();
-      char* starpos = strchr(strchr_pointer + 4, '*');
-      if (starpos) {
-        char* npos = strchr(command_queue[cmd_queue_index_r], 'N');
-        strchr_pointer = strchr(npos, ' ') + 1;
-        *(starpos) = '\0';
-      }
-      card.removeFile(strchr_pointer + 4);
+      card.removeFile(current_command_args);
     }
   }
 
@@ -3036,23 +3024,18 @@ inline void gcode_M31() {
     if (card.sdprinting)
       st_synchronize();
 
-    char* codepos = strchr_pointer + 4;
-
-    char* namestartpos = strchr(codepos, '!');   //find ! to indicate filename string start.
-    if (! namestartpos)
-      namestartpos = codepos; //default name position, 4 letters after the M
+    char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.
+    if (!namestartpos)
+      namestartpos = current_command_args; // Default name position, 4 letters after the M
     else
       namestartpos++; //to skip the '!'
 
-    char* starpos = strchr(codepos, '*');
-    if (starpos) *(starpos) = '\0';
-
-    bool call_procedure = code_seen('P') && (strchr_pointer < namestartpos);
+    bool call_procedure = code_seen('P') && (seen_pointer < namestartpos);
 
     if (card.cardOK) {
       card.openFile(namestartpos, true, !call_procedure);
 
-      if (code_seen('S') && strchr_pointer < namestartpos) // "S" (must occur _before_ the filename!)
+      if (code_seen('S') && seen_pointer < namestartpos) // "S" (must occur _before_ the filename!)
         card.setIndex(code_value_short());
 
       card.startFileprint();
@@ -3061,17 +3044,34 @@ inline void gcode_M31() {
     }
   }
 
+  #ifdef LONG_FILENAME_HOST_SUPPORT
+
+    /**
+     * M33: Get the long full path of a file or folder
+     *
+     * Parameters:
+     *   <dospath> Case-insensitive DOS-style path to a file or folder
+     *
+     * Example:
+     *   M33 miscel~1/armchair/armcha~1.gco
+     *
+     * Output:
+     *   /Miscellaneous/Armchair/Armchair.gcode
+     */
+    inline void gcode_M33() {
+      char *args = strchr_pointer + 4;
+      while (*args == ' ') ++args;
+      clear_asterisk(args);
+      card.printLongPath(args);
+    }
+
+  #endif
+
   /**
    * M928: Start SD Write
    */
   inline void gcode_M928() {
-    char* starpos = strchr(strchr_pointer + 5, '*');
-    if (starpos) {
-      char* npos = strchr(command_queue[cmd_queue_index_r], 'N');
-      strchr_pointer = strchr(npos, ' ') + 1;
-      *(starpos) = '\0';
-    }
-    card.openLogFile(strchr_pointer + 5);
+    card.openLogFile(current_command_args);
   }
 
 #endif // SDSUPPORT
@@ -3371,10 +3371,6 @@ inline void gcode_M104() {
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
         setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);
     #endif
-
-    #ifdef THERMAL_PROTECTION_HOTENDS
-      start_watching_heater(target_extruder);
-    #endif
   }
 }
 
@@ -3486,10 +3482,6 @@ inline void gcode_M109() {
     if (code_seen('B')) autotemp_max = code_value();
   #endif
 
-  #ifdef THERMAL_PROTECTION_HOTENDS
-    start_watching_heater(target_extruder);
-  #endif
-
   millis_t temp_ms = millis();
 
   /* See if we are heating up or cooling down */
@@ -3868,16 +3860,12 @@ inline void gcode_M115() {
   SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
 }
 
-#ifdef ULTIPANEL
-
-  /**
-   * M117: Set LCD Status Message
-   */
-  inline void gcode_M117() {
-    lcd_setstatus(strchr_pointer + 5);
-  }
-
-#endif
+/**
+ * M117: Set LCD Status Message
+ */
+inline void gcode_M117() {
+  lcd_setstatus(current_command_args);
+}
 
 /**
  * M119: Output endstop states to serial output
@@ -3921,12 +3909,12 @@ inline void gcode_M119() {
 /**
  * M120: Enable endstops
  */
-inline void gcode_M120() { enable_endstops(false); }
+inline void gcode_M120() { enable_endstops(true); }
 
 /**
  * M121: Disable endstops
  */
-inline void gcode_M121() { enable_endstops(true); }
+inline void gcode_M121() { enable_endstops(false); }
 
 #ifdef BLINKM
 
@@ -4165,10 +4153,7 @@ inline void gcode_M206() {
           autoretract_enabled = true;
           break;
         default:
-          SERIAL_ECHO_START;
-          SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-          SERIAL_ECHO(command_queue[cmd_queue_index_r]);
-          SERIAL_ECHOLNPGM("\"");
+          unknown_command_error();
           return;
       }
       for (int i=0; i<EXTRUDERS; i++) retracted[i] = false;
@@ -4476,6 +4461,9 @@ inline void gcode_M303() {
   int c = code_seen('C') ? code_value_short() : 5;
   float temp = code_seen('S') ? code_value() : (e < 0 ? 70.0 : 150.0);
   PID_autotune(temp, e, c);
+  // Suppress a line mismatch error
+  gcode_LastN += 1;
+  FlushSerialRequestResend();
 }
 
 #ifdef SCARA
@@ -5088,8 +5076,7 @@ inline void gcode_M999() {
  *
  *   F[mm/min] Set the movement feedrate
  */
-inline void gcode_T() {
-  uint16_t tmp_extruder = code_value_short();
+inline void gcode_T(uint8_t tmp_extruder) {
   if (tmp_extruder >= EXTRUDERS) {
     SERIAL_ECHO_START;
     SERIAL_CHAR('T');
@@ -5192,21 +5179,52 @@ inline void gcode_T() {
 }
 
 /**
- * Process Commands and dispatch them to handlers
+ * Process a single command and dispatch it to its handler
  * This is called from the main loop()
  */
 void process_next_command() {
+  current_command = command_queue[cmd_queue_index_r];
 
   if ((marlin_debug_flags & DEBUG_ECHO)) {
     SERIAL_ECHO_START;
-    SERIAL_ECHOLN(command_queue[cmd_queue_index_r]);
+    SERIAL_ECHOLN(current_command);
   }
 
-  if (code_seen('G')) {
+  // Sanitize the current command:
+  //  - Skip leading spaces
+  //  - Bypass N...
+  //  - Overwrite * with nul to mark the end
+  while (*current_command == ' ') ++current_command;
+  if (*current_command == 'N' && current_command[1] >= '0' && current_command[1] <= '9') {
+    while (*current_command != ' ') ++current_command;
+    while (*current_command == ' ') ++current_command;
+  }
+  char *starpos = strchr(current_command, '*');  // * should always be the last parameter
+  if (starpos) *starpos = '\0';
+
+  // Get the command code, which must be G, M, or T
+  char command_code = *current_command;
+
+  // The code must have a numeric value
+  bool code_is_good = (current_command[1] >= '0' && current_command[1] <= '9');
 
-    int codenum = code_value_short();
+  int codenum; // define ahead of goto
 
-    switch (codenum) {
+  // Bail early if there's no code
+  if (!code_is_good) goto ExitUnknownCommand;
+
+  // Args pointer optimizes code_seen, especially those taking XYZEF
+  // This wastes a little cpu on commands that expect no arguments.
+  current_command_args = current_command;
+  while (*current_command_args != ' ') ++current_command_args;
+  while (*current_command_args == ' ') ++current_command_args;
+
+  // Interpret the code int
+  codenum = code_value_short();
+
+  // Handle a known G, M, or T
+  switch(command_code) {
+    case 'G': switch (codenum) {
 
     // G0, G1
     case 0:
@@ -5275,11 +5293,12 @@ void process_next_command() {
     case 92: // G92
       gcode_G92();
       break;
+
+    default: code_is_good = false;
     }
-  }
+    break;
 
-  else if (code_seen('M')) {
-    switch(code_value_short()) {
+    case 'M': switch (codenum) {
       #ifdef ULTIPANEL
         case 0: // M0 - Unconditional stop - Wait for user button press on LCD
         case 1: // M1 - Conditional stop - Wait for user button press on LCD
@@ -5317,6 +5336,12 @@ void process_next_command() {
           gcode_M30(); break;
         case 32: //M32 - Select file and start SD print
           gcode_M32(); break;
+
+        #ifdef LONG_FILENAME_HOST_SUPPORT
+          case 33: //M33 - Get the long full path to a file or folder
+            gcode_M33(); break;
+        #endif // LONG_FILENAME_HOST_SUPPORT
+
         case 928: //M928 - Start SD write
           gcode_M928(); break;
 
@@ -5354,8 +5379,7 @@ void process_next_command() {
 
       case 105: // M105: Read current temperature
         gcode_M105();
-        return;
-        break;
+        return; // "ok" already printed
 
       case 109: // M109: Wait for temperature
         gcode_M109();
@@ -5429,13 +5453,9 @@ void process_next_command() {
       case 115: // M115: Report capabilities
         gcode_M115();
         break;
-
-      #ifdef ULTIPANEL
-        case 117: // M117: Set LCD message text
-          gcode_M117();
-          break;
-      #endif
-
+      case 117: // M117: Set LCD message text, if possible
+        gcode_M117();
+        break;
       case 114: // M114: Report current position
         gcode_M114();
         break;
@@ -5705,19 +5725,20 @@ void process_next_command() {
       case 999: // M999: Restart after being Stopped
         gcode_M999();
         break;
+
+      default: code_is_good = false;
     }
-  }
+    break;
 
-  else if (code_seen('T')) {
-    gcode_T();
+    case 'T':
+      gcode_T(codenum);
+    break;
   }
 
-  else {
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
-    SERIAL_ECHO(command_queue[cmd_queue_index_r]);
-    SERIAL_ECHOLNPGM("\"");
-  }
+ExitUnknownCommand:
+
+  // Still unknown command? Throw an error
+  if (!code_is_good) unknown_command_error();
 
   ok_to_send();
 }
diff --git a/Marlin/boards.h b/Marlin/boards.h
index 5ccf0f8..4e0241f 100644
--- a/Marlin/boards.h
+++ b/Marlin/boards.h
@@ -51,8 +51,6 @@
 #define BOARD_5DPRINT           88   // 5DPrint D8 Driver Board
 #define BOARD_LEAPFROG          999  // Leapfrog
 #define BOARD_MKS_BASE          40   // MKS BASE 1.0
-#define BOARD_WITBOX            41   // bq WITBOX
-#define BOARD_HEPHESTOS         42   // bq Prusa i3 Hephestos
 #define BOARD_BAM_DICE          401  // 2PrintBeta BAM&DICE with STK drivers
 #define BOARD_BAM_DICE_DUE      402  // 2PrintBeta BAM&DICE Due with STK drivers
 
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 95b9f35..8693424 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -129,6 +129,69 @@ void CardReader::ls()  {
   lsDive("", root);
 }
 
+#ifdef LONG_FILENAME_HOST_SUPPORT
+
+  /**
+   * Get a long pretty path based on a DOS 8.3 path
+   */
+  void CardReader::printLongPath(char *path) {
+    lsAction = LS_GetFilename;
+
+    int i, pathLen = strlen(path);
+
+    // SERIAL_ECHOPGM("Full Path: "); SERIAL_ECHOLN(path);
+
+    // Zero out slashes to make segments
+    for (i = 0; i < pathLen; i++) if (path[i] == '/') path[i] = '\0';
+
+    SdFile diveDir = root; // start from the root for segment 1
+    for (i = 0; i < pathLen;) {
+
+      if (path[i] == '\0') i++; // move past a single nul
+
+      char *segment = &path[i]; // The segment after most slashes
+
+      // If a segment is empty (extra-slash) then exit
+      if (!*segment) break;
+
+      // Go to the next segment
+      while (path[++i]) { }
+
+      // SERIAL_ECHOPGM("Looking for segment: "); SERIAL_ECHOLN(segment);
+
+      // Find the item, setting the long filename
+      diveDir.rewind();
+      lsDive("", diveDir, segment);
+
+      // Print /LongNamePart to serial output
+      SERIAL_PROTOCOLCHAR('/');
+      SERIAL_PROTOCOL(longFilename[0] ? longFilename : "???");
+
+      // If the filename was printed then that's it
+      if (!filenameIsDir) break;
+
+      // SERIAL_ECHOPGM("Opening dir: "); SERIAL_ECHOLN(segment);
+
+      // Open the sub-item as the new dive parent
+      SdFile dir;
+      if (!dir.open(diveDir, segment, O_READ)) {
+        SERIAL_EOL;
+        SERIAL_ECHO_START;
+        SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
+        SERIAL_ECHO(segment);
+        break;
+      }
+
+      diveDir.close();
+      diveDir = dir;
+
+    } // while i<pathLen
+
+    SERIAL_EOL;
+  }
+
+#endif // LONG_FILENAME_HOST_SUPPORT
+
 void CardReader::initsd() {
   cardOK = false;
   if (root.isOpen()) root.close();
@@ -429,7 +492,7 @@ void CardReader::checkautostart(bool force) {
     if (!cardOK) return; // fail
   }
 
-  char autoname[30];
+  char autoname[10];
   sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);
   for (int8_t i = 0; i < (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);
 
@@ -441,7 +504,7 @@ void CardReader::checkautostart(bool force) {
   while (root.readDir(p, NULL) > 0) {
     for (int8_t i = 0; i < (int8_t)strlen((char*)p.name); i++) p.name[i] = tolower(p.name[i]);
     if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {
-      char cmd[30];
+      char cmd[4 + (FILENAME_LENGTH + 1) * MAX_DIR_DEPTH + 2];
       sprintf_P(cmd, PSTR("M23 %s"), autoname);
       enqueuecommand(cmd);
       enqueuecommands_P(PSTR("M24"));
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 03d4303..4b0b6e4 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -28,6 +28,10 @@ public:
   void getStatus();
   void printingHasFinished();
 
+  #ifdef LONG_FILENAME_HOST_SUPPORT
+    void printLongPath(char *path);
+  #endif
+
   void getfilename(uint16_t nr, const char* const match=NULL);
   uint16_t getnrfilenames();
 
diff --git a/Marlin/configurator/config/Configuration.h b/Marlin/configurator/config/Configuration.h
index 0d8a5d4..ccd9786 100644
--- a/Marlin/configurator/config/Configuration.h
+++ b/Marlin/configurator/config/Configuration.h
@@ -401,7 +401,7 @@ const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic
   const bool FIL_RUNOUT_INVERTING = true;  // Should be uncommented and true or false should assigned
   #define ENDSTOPPULLUP_FIL_RUNOUT // Uncomment to use internal pullup for filament runout pins if the sensor is defined.
   #define FILAMENT_RUNOUT_SCRIPT "M600"
-#endif
+#endif 
 
 //===========================================================================
 //=========================== Manual Bed Leveling ===========================
@@ -411,7 +411,7 @@ const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic
 // #define MESH_BED_LEVELING    // Enable mesh bed leveling
 
 #ifdef MANUAL_BED_LEVELING
-  #define MBL_Z_STEP 0.025
+  #define MBL_Z_STEP 0.025  // Step size while manually probing Z axis
 #endif  // MANUAL_BED_LEVELING
 
 #ifdef MESH_BED_LEVELING
@@ -605,7 +605,7 @@ const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic
 
 #ifdef EEPROM_SETTINGS
   // To disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
-  #define EEPROM_CHITCHAT // please keep turned on if you can.
+  #define EEPROM_CHITCHAT // Please keep turned on if you can.
 #endif
 
 // @section temperature
@@ -646,7 +646,6 @@ const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic
 //#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100 // the duration the buzzer plays the UI feedback sound. ie Screen Click
 //#define LCD_FEEDBACK_FREQUENCY_HZ 1000         // this is the tone frequency the buzzer plays when on UI feedback. ie Screen Click
                                                  // 0 to disable buzzer feedback. Test with M300 S<frequency Hz> P<duration ms>
-
 // PanelOne from T3P3 (via RAMPS 1.4 AUX2/AUX3)
 // http://reprap.org/wiki/PanelOne
 //#define PANEL_ONE
@@ -779,13 +778,13 @@ const bool Z_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic
 // Uncomment below to enable
 //#define FILAMENT_SENSOR
 
-#define FILAMENT_SENSOR_EXTRUDER_NUM	0  //The number of the extruder that has the filament sensor (0,1,2)
-#define MEASUREMENT_DELAY_CM			14  //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
+#define FILAMENT_SENSOR_EXTRUDER_NUM 0   //The number of the extruder that has the filament sensor (0,1,2)
+#define MEASUREMENT_DELAY_CM        14   //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
 
-#define DEFAULT_NOMINAL_FILAMENT_DIA  3.0  //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation
-#define MEASURED_UPPER_LIMIT          3.30  //upper limit factor used for sensor reading validation in mm
-#define MEASURED_LOWER_LIMIT          1.90  //lower limit factor for sensor reading validation in mm
-#define MAX_MEASUREMENT_DELAY			20  //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)
+#define DEFAULT_NOMINAL_FILAMENT_DIA 3.0 //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation
+#define MEASURED_UPPER_LIMIT         3.3 //upper limit factor used for sensor reading validation in mm
+#define MEASURED_LOWER_LIMIT         1.9 //lower limit factor for sensor reading validation in mm
+#define MAX_MEASUREMENT_DELAY       20   //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)
 
 //defines used in the code
 #define DEFAULT_MEASURED_FILAMENT_DIA  DEFAULT_NOMINAL_FILAMENT_DIA  //set measured to nominal initially
diff --git a/Marlin/configurator/config/Configuration_adv.h b/Marlin/configurator/config/Configuration_adv.h
index 91d8c9d..8a05298 100644
--- a/Marlin/configurator/config/Configuration_adv.h
+++ b/Marlin/configurator/config/Configuration_adv.h
@@ -36,6 +36,15 @@
   #define THERMAL_PROTECTION_BED_HYSTERESIS 2 // Degrees Celsius
 #endif
 
+#ifdef PIDTEMP
+  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.
+  // if Kc is chosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE
+  #ifdef PID_ADD_EXTRUSION_RATE
+    #define  DEFAULT_Kc (1) //heating power=Kc*(e_speed)
+  #endif
+#endif
+
 /**
  * Automatic Temperature:
  * The hotend target temperature is calculated by all the buffered lines of gcode.
@@ -46,23 +55,6 @@
  * Also, if the temperature is set to a value below mintemp, it will not be changed by autotemp.
  * On an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
  */
-#ifdef PIDTEMP
-  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.
-  // if Kc is chosen well, the additional required power due to increased melting should be compensated.
-  #define PID_ADD_EXTRUSION_RATE
-  #ifdef PID_ADD_EXTRUSION_RATE
-    #define  DEFAULT_Kc (1) //heating power=Kc*(e_speed)
-  #endif
-#endif
-
-
-//automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.
-//The maximum buffered steps/sec of the extruder motor are called "se".
-//You enter the autotemp mode by a M109 S<mintemp> B<maxtemp> F<factor>
-// the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp
-// you exit the value by any M109 without F*
-// Also, if the temperature is set to a value <mintemp, it is not changed by autotemp.
-// on an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
 #define AUTOTEMP
 #ifdef AUTOTEMP
   #define AUTOTEMP_OLDWEIGHT 0.98
@@ -321,6 +313,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/configurator/config/boards.h b/Marlin/configurator/config/boards.h
index 0e9c8c2..4e0241f 100644
--- a/Marlin/configurator/config/boards.h
+++ b/Marlin/configurator/config/boards.h
@@ -14,6 +14,7 @@
 #define BOARD_RAMPS_13_EEB      34   // RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
 #define BOARD_RAMPS_13_EFF      35   // RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)
 #define BOARD_RAMPS_13_EEF      36   // RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Fan)
+#define BOARD_RAMPS_13_SF       38   // RAMPS 1.3 / 1.4 (Power outputs: Spindle, Controller Fan)
 #define BOARD_FELIX2            37   // Felix 2.0+ Electronics Board (RAMPS like)
 #define BOARD_GEN6              5    // Gen6
 #define BOARD_GEN6_DELUXE       51   // Gen6 deluxe
@@ -49,8 +50,7 @@
 #define BOARD_ELEFU_3           21   // Elefu Ra Board (v3)
 #define BOARD_5DPRINT           88   // 5DPrint D8 Driver Board
 #define BOARD_LEAPFROG          999  // Leapfrog
-#define BOARD_WITBOX            41   // bq WITBOX
-#define BOARD_HEPHESTOS         42   // bq Prusa i3 Hephestos
+#define BOARD_MKS_BASE          40   // MKS BASE 1.0
 #define BOARD_BAM_DICE          401  // 2PrintBeta BAM&DICE with STK drivers
 #define BOARD_BAM_DICE_DUE      402  // 2PrintBeta BAM&DICE Due with STK drivers
 
diff --git a/Marlin/configurator/config/language.h b/Marlin/configurator/config/language.h
index 40d8dbe..856bd58 100644
--- a/Marlin/configurator/config/language.h
+++ b/Marlin/configurator/config/language.h
@@ -32,8 +32,8 @@
 // kana_utf Japanese
 // cn       Chinese
 
+// fallback if no language is set, don't change
 #ifndef LANGUAGE_INCLUDE
-  // pick your language from the list above
   #define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(en)
 #endif
 
@@ -53,26 +53,14 @@
   #define FIRMWARE_URL "http://3dprint.elettronicain.it/"
 #elif MB(K8200)
   #define MACHINE_NAME "K8200"
+  #define FIRMWARE_URL "https://github.com/CONSULitAS/Marlin-K8200"
 #elif MB(5DPRINT)
   #define MACHINE_NAME "Makibox"
 #elif MB(SAV_MKI)
   #define MACHINE_NAME "SAV MkI"
   #define FIRMWARE_URL "https://github.com/fmalpartida/Marlin/tree/SAV-MkI-config"
-#elif MB(WITBOX)
-  #define MACHINE_NAME "WITBOX"
-  #define FIRMWARE_URL "http://www.bq.com/gb/downloads-witbox.html"
-#elif MB(HEPHESTOS)
-  #define MACHINE_NAME "HEPHESTOS"
-  #define FIRMWARE_URL "http://www.bq.com/gb/downloads-prusa-i3-hephestos.html"
-#elif MB(BRAINWAVE_PRO)
-  #define MACHINE_NAME "Kossel Pro"
-  #ifndef FIRMWARE_URL
-    #define FIRMWARE_URL "https://github.com/OpenBeamUSA/Marlin/"
-  #endif
-#else
-  #ifndef MACHINE_NAME
-    #define MACHINE_NAME "3D Printer"
-  #endif
+#elif !defined(MACHINE_NAME)
+  #define MACHINE_NAME "3D Printer"
 #endif
 
 #ifdef CUSTOM_MENDEL_NAME
@@ -122,6 +110,7 @@
 #define MSG_FREE_MEMORY                     " Free Memory: "
 #define MSG_PLANNER_BUFFER_BYTES            "  PlannerBufferBytes: "
 #define MSG_OK                              "ok"
+#define MSG_WAIT                            "wait"
 #define MSG_FILE_SAVED                      "Done saving file."
 #define MSG_ERR_LINE_NO                     "Line Number is not Last Line Number+1, Last Line: "
 #define MSG_ERR_CHECKSUM_MISMATCH           "checksum mismatch, Last Line: "
@@ -221,15 +210,16 @@
 #define MSG_PID_DEBUG_PTERM                 " pTerm "
 #define MSG_PID_DEBUG_ITERM                 " iTerm "
 #define MSG_PID_DEBUG_DTERM                 " dTerm "
-#define MSG_HEATING_FAILED                  "Heating failed"
-#define MSG_EXTRUDER_SWITCHED_OFF           "Extruder switched off. Temperature difference between temp sensors is too high !"
-
 #define MSG_INVALID_EXTRUDER_NUM            " - Invalid extruder number !"
-#define MSG_THERMAL_RUNAWAY_STOP            "Thermal Runaway, system stopped! Heater_ID: "
-#define MSG_SWITCHED_OFF_MAX                " switched off. MAXTEMP triggered !!"
-#define MSG_MINTEMP_EXTRUDER_OFF            ": Extruder switched off. MINTEMP triggered !"
-#define MSG_MAXTEMP_EXTRUDER_OFF            ": Extruder" MSG_SWITCHED_OFF_MAX
-#define MSG_MAXTEMP_BED_OFF                 "Heated bed" MSG_SWITCHED_OFF_MAX
+
+#define MSG_HEATER_BED                      "bed"
+#define MSG_STOPPED_HEATER                  ", system stopped! Heater_ID: "
+#define MSG_REDUNDANCY                      "Heater switched off. Temperature difference between temp sensors is too high !"
+#define MSG_T_HEATING_FAILED                "Heating failed"
+#define MSG_T_THERMAL_RUNAWAY               "Thermal Runaway"
+#define MSG_T_MAXTEMP                       "MAXTEMP triggered"
+#define MSG_T_MINTEMP                       "MINTEMP triggered"
+
 
 // LCD Menu Messages
 
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index 24b0b93..a2f8f4b 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/Hephestos/Configuration.h b/Marlin/example_configurations/Hephestos/Configuration.h
index 4e8503a..5350335 100644
--- a/Marlin/example_configurations/Hephestos/Configuration.h
+++ b/Marlin/example_configurations/Hephestos/Configuration.h
@@ -57,11 +57,14 @@ Here are some standard links for getting your machine calibrated:
 
 // The following define selects which electronics board you have.
 // Please choose the name from boards.h that matches your setup
-#define MOTHERBOARD BOARD_HEPHESTOS
+#define MOTHERBOARD BOARD_RAMPS_13_EFB
 
 // Optional custom name for your RepStrap or other custom machine
 // Displayed in the LCD "Ready" message
-// #define CUSTOM_MACHINE_NAME "3D Printer"
+#define CUSTOM_MACHINE_NAME "HEPHESTOS"
+
+// Added for BQ
+#define FIRMWARE_URL "http://www.bq.com/gb/downloads-prusa-i3-hephestos.html"
  
 // Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
 // You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 485afd1..d6ae0f3 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index 24b0b93..a2f8f4b 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index b2e05ef..863148e 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/WITBOX/Configuration.h b/Marlin/example_configurations/WITBOX/Configuration.h
index f9543b0..142d163 100644
--- a/Marlin/example_configurations/WITBOX/Configuration.h
+++ b/Marlin/example_configurations/WITBOX/Configuration.h
@@ -57,11 +57,14 @@ Here are some standard links for getting your machine calibrated:
 
 // The following define selects which electronics board you have.
 // Please choose the name from boards.h that matches your setup
-#define MOTHERBOARD BOARD_WITBOX
+#define MOTHERBOARD BOARD_RAMPS_13_EFB
 
 // Optional custom name for your RepStrap or other custom machine
 // Displayed in the LCD "Ready" message
-// #define CUSTOM_MACHINE_NAME "3D Printer"
+#define CUSTOM_MACHINE_NAME "WITBOX"
+
+// Added for BQ
+#define FIRMWARE_URL "http://www.bq.com/gb/downloads-witbox.html"
 
 // Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
 // You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 2d187ae..ca3c783 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
index 9a9104e..2b2acc8 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
@@ -322,6 +322,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index 9a86fc8..3848f97 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -322,6 +322,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index 8cd7786..5f262c2 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index d502852..8b50750 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index 85b75e1..962a853 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -321,6 +321,9 @@
     //#define PROGRESS_MSG_ONCE
   #endif
 
+  // This allows hosts to request long names for files and folders with M33
+  //#define LONG_FILENAME_HOST_SUPPORT
+
 #endif // SDSUPPORT
 
 // for dogm lcd displays you can choose some additional fonts:
diff --git a/Marlin/language.h b/Marlin/language.h
index 6e078d1..856bd58 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -59,21 +59,8 @@
 #elif MB(SAV_MKI)
   #define MACHINE_NAME "SAV MkI"
   #define FIRMWARE_URL "https://github.com/fmalpartida/Marlin/tree/SAV-MkI-config"
-#elif MB(WITBOX)
-  #define MACHINE_NAME "WITBOX"
-  #define FIRMWARE_URL "http://www.bq.com/gb/downloads-witbox.html"
-#elif MB(HEPHESTOS)
-  #define MACHINE_NAME "HEPHESTOS"
-  #define FIRMWARE_URL "http://www.bq.com/gb/downloads-prusa-i3-hephestos.html"
-#elif MB(BRAINWAVE_PRO)
-  #define MACHINE_NAME "Kossel Pro"
-  #ifndef FIRMWARE_URL
-    #define FIRMWARE_URL "https://github.com/OpenBeamUSA/Marlin/"
-  #endif
-#else
-  #ifndef MACHINE_NAME
-    #define MACHINE_NAME "3D Printer"
-  #endif
+#elif !defined(MACHINE_NAME)
+  #define MACHINE_NAME "3D Printer"
 #endif
 
 #ifdef CUSTOM_MENDEL_NAME
diff --git a/Marlin/pins.h b/Marlin/pins.h
index abffe2c..d53f225 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -104,10 +104,6 @@
   #include "pins_5DPRINT.h"
 #elif MB(LEAPFROG)
   #include "pins_LEAPFROG.h"
-#elif MB(WITBOX)
-  #include "pins_WITBOX.h"
-#elif MB(HEPHESTOS)
-  #include "pins_HEPHESTOS.h"
 #elif MB(BAM_DICE)
   #include "pins_RAMPS_13.h"
 #elif MB(BAM_DICE_DUE)
diff --git a/Marlin/pins_HEPHESTOS.h b/Marlin/pins_HEPHESTOS.h
deleted file mode 100644
index ec8d3fa..0000000
--- a/Marlin/pins_HEPHESTOS.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/**
- * bq Prusa i3 Hephestos – Arduino Mega with RAMPS v1.3/1.4 pin assignments
- */
-
-#include "pins_RAMPS_13.h"
-
-#undef FAN_PIN
-#define FAN_PIN             9 // (Sprinter config)
-
-#undef HEATER_1_PIN
-#define HEATER_1_PIN       -1
diff --git a/Marlin/pins_WITBOX.h b/Marlin/pins_WITBOX.h
deleted file mode 100644
index 037b38d..0000000
--- a/Marlin/pins_WITBOX.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/**
- * bq WITBOX Arduino Mega with RAMPS v1.3/1.4 pin assignments
- */
-
-#include "pins_RAMPS_13.h"
-
-#undef FAN_PIN
-#define FAN_PIN             9 // (Sprinter config)
-
-#undef HEATER_1_PIN
-#define HEATER_1_PIN       -1
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index e614f5a..438120c 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -76,6 +76,13 @@ volatile long endstops_trigsteps[3] = { 0 };
 volatile long endstops_stepsTotal, endstops_stepsDone;
 static volatile char endstop_hit_bits = 0; // use X_MIN, Y_MIN, Z_MIN and Z_PROBE as BIT value
 
+#ifndef Z_DUAL_ENDSTOPS
+  static byte
+#else
+  static uint16_t
+#endif
+  old_endstop_bits = 0; // use X_MIN, X_MAX... Z_MAX, Z_PROBE, Z2_MIN, Z2_MAX
+
 #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
   bool abort_on_endstop_hit = false;
 #endif
@@ -84,31 +91,6 @@ static volatile char endstop_hit_bits = 0; // use X_MIN, Y_MIN, Z_MIN and Z_PROB
   int motor_current_setting[3] = DEFAULT_PWM_MOTOR_CURRENT;
 #endif
 
-#if HAS_X_MIN
-  static bool old_x_min_endstop = false;
-#endif
-#if HAS_X_MAX
-  static bool old_x_max_endstop = false;
-#endif
-#if HAS_Y_MIN
-  static bool old_y_min_endstop = false;
-#endif
-#if HAS_Y_MAX
-  static bool old_y_max_endstop = false;
-#endif
-
-static bool old_z_min_endstop = false;
-static bool old_z_max_endstop = false;
-
-#ifdef Z_DUAL_ENDSTOPS
-  static bool old_z2_min_endstop = false;
-  static bool old_z2_max_endstop = false;
-#endif
-
-#ifdef Z_PROBE_ENDSTOP // No need to check for valid pin, SanityCheck.h already does this.
-  static bool old_z_probe_endstop = false;
-#endif
-
 static bool check_endstops = true;
 
 volatile long count_position[NUM_AXIS] = { 0 };
@@ -155,11 +137,11 @@ volatile signed char count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
     #define Z_APPLY_STEP(v,Q) \
     if (performing_homing) { \
       if (Z_HOME_DIR > 0) {\
-        if (!(old_z_max_endstop && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
-        if (!(old_z2_max_endstop && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
+        if (!(TEST(old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
+        if (!(TEST(old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
       } else {\
-        if (!(old_z_min_endstop && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
-        if (!(old_z2_min_endstop && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
+        if (!(TEST(old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
+        if (!(TEST(old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
       } \
     } else { \
       Z_STEP_WRITE(v); \
@@ -266,7 +248,7 @@ void endstops_hit_on_purpose() {
 }
 
 void checkHitEndstops() {
-  if (endstop_hit_bits) { // #ifdef || endstop_z_probe_hit to save space if needed.
+  if (endstop_hit_bits) {
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
     if (endstop_hit_bits & BIT(X_MIN)) {
@@ -296,11 +278,7 @@ void checkHitEndstops() {
         card.sdprinting = false;
         card.closefile();
         quickStop();
-        setTargetHotend0(0);
-        setTargetHotend1(0);
-        setTargetHotend2(0);
-        setTargetHotend3(0);
-        setTargetBed(0);
+        disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
@@ -447,7 +425,7 @@ FORCE_INLINE void trapezoid_generator_reset() {
 // It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.
 ISR(TIMER1_COMPA_vect) {
 
-  if(cleaning_buffer_counter)
+  if (cleaning_buffer_counter)
   {
     current_block = NULL;
     plan_discard_current_block();
@@ -492,22 +470,33 @@ ISR(TIMER1_COMPA_vect) {
     // Check endstops
     if (check_endstops) {
       
-      #define _ENDSTOP(axis, minmax) axis ##_## minmax ##_endstop
+      #ifdef Z_DUAL_ENDSTOPS
+        uint16_t
+      #else
+        byte
+      #endif
+      current_endstop_bits;
+
       #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
       #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
-      #define _OLD_ENDSTOP(axis, minmax) old_## axis ##_## minmax ##_endstop
       #define _AXIS(AXIS) AXIS ##_AXIS
-      #define _HIT_BIT(AXIS) AXIS ##_MIN
-      #define _ENDSTOP_HIT(AXIS) endstop_hit_bits |= BIT(_HIT_BIT(AXIS))
-
-      #define UPDATE_ENDSTOP(axis,AXIS,minmax,MINMAX) \
-        bool _ENDSTOP(axis, minmax) = (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)); \
-        if (_ENDSTOP(axis, minmax) && _OLD_ENDSTOP(axis, minmax) && (current_block->steps[_AXIS(AXIS)] > 0)) { \
+      #define _ENDSTOP_HIT(AXIS) endstop_hit_bits |= BIT(_ENDSTOP(AXIS, MIN))
+      #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+
+      // SET_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
+      #define SET_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+      // COPY_BIT: copy the value of COPY_BIT to BIT in bits
+      #define COPY_BIT(bits, COPY_BIT, BIT) SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
+      // TEST_ENDSTOP: test the old and the current status of an endstop
+      #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP) && TEST(old_endstop_bits, ENDSTOP))
+
+      #define UPDATE_ENDSTOP(AXIS,MINMAX) \
+        SET_ENDSTOP_BIT(AXIS, MINMAX); \
+        if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))  && (current_block->steps[_AXIS(AXIS)] > 0)) { \
           endstops_trigsteps[_AXIS(AXIS)] = count_position[_AXIS(AXIS)]; \
           _ENDSTOP_HIT(AXIS); \
           step_events_completed = current_block->step_event_count; \
-        } \
-        _OLD_ENDSTOP(axis, minmax) = _ENDSTOP(axis, minmax);
+        }
       
       #ifdef COREXY
         // Head direction in -X axis for CoreXY bots.
@@ -524,7 +513,7 @@ ISR(TIMER1_COMPA_vect) {
             #endif
               {
                 #if HAS_X_MIN
-                  UPDATE_ENDSTOP(x, X, min, MIN);
+                  UPDATE_ENDSTOP(X, MIN);
                 #endif
               }
           }
@@ -535,7 +524,7 @@ ISR(TIMER1_COMPA_vect) {
             #endif
               {
                 #if HAS_X_MAX
-                  UPDATE_ENDSTOP(x, X, max, MAX);
+                  UPDATE_ENDSTOP(X, MAX);
                 #endif
               }
           }
@@ -550,12 +539,12 @@ ISR(TIMER1_COMPA_vect) {
       #endif
           { // -direction
             #if HAS_Y_MIN
-              UPDATE_ENDSTOP(y, Y, min, MIN);
+              UPDATE_ENDSTOP(Y, MIN);
             #endif
           }
           else { // +direction
             #if HAS_Y_MAX
-              UPDATE_ENDSTOP(y, Y, max, MAX);
+              UPDATE_ENDSTOP(Y, MAX);
             #endif
           }
       #ifdef COREXY
@@ -565,45 +554,36 @@ ISR(TIMER1_COMPA_vect) {
         #if HAS_Z_MIN
 
           #ifdef Z_DUAL_ENDSTOPS
+            SET_ENDSTOP_BIT(Z, MIN);
+              #if HAS_Z2_MIN
+                SET_ENDSTOP_BIT(Z2, MIN);
+              #else
+                COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN)
+              #endif
+
+            byte z_test = TEST_ENDSTOP(Z_MIN) << 0 + TEST_ENDSTOP(Z2_MIN) << 1; // bit 0 for Z, bit 1 for Z2
 
-            bool z_min_endstop = READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING,
-                z2_min_endstop =
-                  #if HAS_Z2_MIN
-                    READ(Z2_MIN_PIN) != Z2_MIN_ENDSTOP_INVERTING
-                  #else
-                    z_min_endstop
-                  #endif
-                ;
-
-            bool z_min_both = z_min_endstop && old_z_min_endstop,
-                z2_min_both = z2_min_endstop && old_z2_min_endstop;
-            if ((z_min_both || z2_min_both) && current_block->steps[Z_AXIS] > 0) {
+            if (z_test && current_block->steps[Z_AXIS] > 0) { // z_test = Z_MIN || Z2_MIN
               endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
               endstop_hit_bits |= BIT(Z_MIN);
-              if (!performing_homing || (performing_homing && z_min_both && z2_min_both)) //if not performing home or if both endstops were trigged during homing...
-                step_events_completed = current_block->step_event_count;
+              if (!performing_homing || (performing_homing && !((~z_test) & 0x3)))  //if not performing home or if both endstops were trigged during homing...
+                step_events_completed = current_block->step_event_count;            //!((~z_test) & 0x3) = Z_MIN && Z2_MIN
             }
-            old_z_min_endstop = z_min_endstop;
-            old_z2_min_endstop = z2_min_endstop;
-
           #else // !Z_DUAL_ENDSTOPS
 
-            UPDATE_ENDSTOP(z, Z, min, MIN);
-
+            UPDATE_ENDSTOP(Z, MIN);
           #endif // !Z_DUAL_ENDSTOPS
-
         #endif // Z_MIN_PIN
 
         #ifdef Z_PROBE_ENDSTOP
-          UPDATE_ENDSTOP(z, Z, probe, PROBE);
-          z_probe_endstop=(READ(Z_PROBE_PIN) != Z_PROBE_ENDSTOP_INVERTING);
-          if(z_probe_endstop && old_z_probe_endstop)
+          UPDATE_ENDSTOP(Z, PROBE);
+          SET_ENDSTOP_BIT(Z, PROBE);
+
+          if (TEST_ENDSTOP(Z_PROBE))
           {
             endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
             endstop_hit_bits |= BIT(Z_PROBE);
-  //        if (z_probe_endstop && old_z_probe_endstop) SERIAL_ECHOLN("z_probe_endstop = true");
           }
-          old_z_probe_endstop = z_probe_endstop;
         #endif
       }
       else { // z +direction
@@ -611,55 +591,43 @@ ISR(TIMER1_COMPA_vect) {
 
           #ifdef Z_DUAL_ENDSTOPS
 
-            bool z_max_endstop = READ(Z_MAX_PIN) != Z_MAX_ENDSTOP_INVERTING,
-                z2_max_endstop =
-                  #if HAS_Z2_MAX
-                    READ(Z2_MAX_PIN) != Z2_MAX_ENDSTOP_INVERTING
-                  #else
-                    z_max_endstop
-                  #endif
-                ;
-
-            bool z_max_both = z_max_endstop && old_z_max_endstop,
-                z2_max_both = z2_max_endstop && old_z2_max_endstop;
-            if ((z_max_both || z2_max_both) && current_block->steps[Z_AXIS] > 0) {
-              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
-              endstop_hit_bits |= BIT(Z_MIN);
+            SET_ENDSTOP_BIT(Z, MAX);
+              #if HAS_Z2_MAX
+                SET_ENDSTOP_BIT(Z2, MAX);
+              #else
+                COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX)
+              #endif
 
-             // if (z_max_both) SERIAL_ECHOLN("z_max_endstop = true");
-             // if (z2_max_both) SERIAL_ECHOLN("z2_max_endstop = true");
+            byte z_test = TEST_ENDSTOP(Z_MAX) << 0 + TEST_ENDSTOP(Z2_MAX) << 1; // bit 0 for Z, bit 1 for Z2
 
-              if (!performing_homing || (performing_homing && z_max_both && z2_max_both)) //if not performing home or if both endstops were trigged during homing...
-                step_events_completed = current_block->step_event_count;
+            if (z_test && current_block->steps[Z_AXIS] > 0) {  // t_test = Z_MAX || Z2_MAX
+              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
+              endstop_hit_bits |= BIT(Z_MIN);
+              if (!performing_homing || (performing_homing && !((~z_test) & 0x3)))  //if not performing home or if both endstops were trigged during homing...
+                step_events_completed = current_block->step_event_count;            //!((~z_test) & 0x3) = Z_MAX && Z2_MAX
             }
-            old_z_max_endstop = z_max_endstop;
-            old_z2_max_endstop = z2_max_endstop;
 
           #else // !Z_DUAL_ENDSTOPS
 
-            UPDATE_ENDSTOP(z, Z, max, MAX);
+            UPDATE_ENDSTOP(Z, MAX);
 
           #endif // !Z_DUAL_ENDSTOPS
-
         #endif // Z_MAX_PIN
         
         #ifdef Z_PROBE_ENDSTOP
-          UPDATE_ENDSTOP(z, Z, probe, PROBE);
-          z_probe_endstop=(READ(Z_PROBE_PIN) != Z_PROBE_ENDSTOP_INVERTING);
-          if(z_probe_endstop && old_z_probe_endstop)
+          UPDATE_ENDSTOP(Z, PROBE);
+          SET_ENDSTOP_BIT(Z, PROBE);
+          if (TEST_ENDSTOP(Z_PROBE))
           {
             endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
             endstop_hit_bits |= BIT(Z_PROBE);
-//          if (z_probe_endstop && old_z_probe_endstop) SERIAL_ECHOLN("z_probe_endstop = true");
           }
-          old_z_probe_endstop = z_probe_endstop;
         #endif
       }
-
+      old_endstop_bits = current_endstop_bits;
     }
 
 
-
     // Take multiple steps per interrupt (For high speed moves)
     for (int8_t i = 0; i < step_loops; i++) {
       #ifndef AT90USB
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 9fdcb78..4d8973c 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1004,10 +1004,9 @@ void tp_init() {
    * This is called when the temperature is set. (M104, M109)
    */
   void start_watching_heater(int e) {
-    millis_t ms = millis() + WATCH_TEMP_PERIOD * 1000;
     if (degHotend(e) < degTargetHotend(e) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_target_temp[e] = degHotend(e) + WATCH_TEMP_INCREASE;
-      watch_heater_next_ms[e] = ms;
+      watch_heater_next_ms[e] = millis() + WATCH_TEMP_PERIOD * 1000;
     }
     else
       watch_heater_next_ms[e] = 0;
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 62a4f6c..6ab35d5 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -96,7 +96,16 @@ FORCE_INLINE float degBed() { return current_temperature_bed; }
 FORCE_INLINE float degTargetHotend(uint8_t extruder) { return target_temperature[extruder]; }
 FORCE_INLINE float degTargetBed() { return target_temperature_bed; }
 
-FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) { target_temperature[extruder] = celsius; }
+#ifdef THERMAL_PROTECTION_HOTENDS
+  void start_watching_heater(int e=0);
+#endif
+
+FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {
+  target_temperature[extruder] = celsius;
+  #ifdef THERMAL_PROTECTION_HOTENDS
+    start_watching_heater(extruder);
+  #endif
+}
 FORCE_INLINE void setTargetBed(const float &celsius) { target_temperature_bed = celsius; }
 
 FORCE_INLINE bool isHeatingHotend(uint8_t extruder) { return target_temperature[extruder] > current_temperature[extruder]; }
@@ -137,10 +146,6 @@ void PID_autotune(float temp, int extruder, int ncycles);
 void setExtruderAutoFanState(int pin, bool state);
 void checkExtruderAutoFans();
 
-#ifdef THERMAL_PROTECTION_HOTENDS
-  void start_watching_heater(int e=0);
-#endif
-
 FORCE_INLINE void autotempShutdown() {
   #ifdef AUTOTEMP
     if (autotemp_enabled) {
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 8584a96..0668b96 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -515,12 +515,11 @@ static void lcd_tune_menu() {
 
 void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {
   if (temph > 0) setTargetHotend(temph, endnum);
-  setTargetBed(tempb);
+  #if TEMP_SENSOR_BED != 0
+    setTargetBed(tempb);
+  #endif
   fanSpeed = fan;
   lcd_return_to_status();
-  #ifdef WATCH_TEMP_PERIOD
-    if (endnum >= 0) start_watching_heater(endnum);
-  #endif
 }
 void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
 void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
@@ -602,11 +601,7 @@ void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTem
 #endif // more than one temperature sensor present
 
 void lcd_cooldown() {
-  setTargetHotend0(0);
-  setTargetHotend1(0);
-  setTargetHotend2(0);
-  setTargetHotend3(0);
-  setTargetBed(0);
+  disable_all_heaters();
   fanSpeed = 0;
   lcd_return_to_status();
 }
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 27e2be0..ca41a6b 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -396,7 +396,7 @@ char lcd_printPGM(const char* str) {
 }
 
 char lcd_print(char* str) {
-  char c, n = 0;;
+  char c, n = 0;
   unsigned char i = 0;
   while ((c = str[i++])) n += charset_mapper(c);
   return n;

