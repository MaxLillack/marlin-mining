commit bd7a96ed42ca035618d6c8f28b27468ae5ae205c (from 704ae1b73734018568c0baa7257f6e4e02b0da8e)
Merge: 704ae1b f1be87a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 21:35:59 2016 -0700

    Merge pull request #4517 from thinkyhead/rc_min_probe_pin
    
    Define Z_MIN_PROBE_PIN always, allowing override

diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 92e21f0..6f1b73b 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -270,10 +270,16 @@
   #endif
 
   /**
-   * Z_MIN_PIN and Z_MIN_PROBE_PIN can't co-exist when Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN
+   * Require a Z min pin
    */
-  #if HAS_Z_MIN && HAS_Z_MIN_PROBE_PIN && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    #error "A probe cannot have more than one pin! Use Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN or Z_MIN_PROBE_PIN."
+  #if HAS_Z_MIN
+     // Z_MIN_PIN and Z_MIN_PROBE_PIN can't co-exist when Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN
+    #if HAS_Z_MIN_PROBE_PIN && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+      #error "A probe cannot have more than one pin! Use Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN or Z_MIN_PROBE_PIN."
+    #endif
+  #elif !HAS_Z_MIN_PROBE_PIN || (DISABLED(Z_MIN_PROBE_ENDSTOP) || ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP))
+    // A pin was set for the Z probe, but not enabled.
+    #error "A probe requires a Z_MIN or Z_PROBE pin. Z_MIN_PIN or Z_MIN_PROBE_PIN must point to a valid hardware pin."
   #endif
 
   /**
@@ -385,15 +391,6 @@
   #endif
 
   /**
-   * Require a Z min pin
-   */
-  #if !PIN_EXISTS(Z_MIN)
-    #if !PIN_EXISTS(Z_MIN_PROBE) || (DISABLED(Z_MIN_PROBE_ENDSTOP) || ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP)) // It's possible for someone to set a pin for the Z probe, but not enable it.
-      #error "AUTO_BED_LEVELING_FEATURE requires a Z_MIN or Z_PROBE endstop. Z_MIN_PIN or Z_MIN_PROBE_PIN must point to a valid hardware pin."
-    #endif
-  #endif
-
-  /**
    * Check if Probe_Offset * Grid Points is greater than Probing Range
    */
   #if ENABLED(AUTO_BED_LEVELING_GRID)
diff --git a/Marlin/pins_AZTEEG_X3_PRO.h b/Marlin/pins_AZTEEG_X3_PRO.h
index b531ec3..f4114c5 100644
--- a/Marlin/pins_AZTEEG_X3_PRO.h
+++ b/Marlin/pins_AZTEEG_X3_PRO.h
@@ -60,14 +60,10 @@
   #define Z_MAX_PIN        18
 #endif
 
-
-#if ENABLED(Z_MIN_PROBE_ENDSTOP)
-  //#undef Z_MIN_PIN
-  //#define Z_MIN_PIN        15
-  // Define a pin to use as the signal pin on Arduino for the Z probe endstop.
+#ifndef Z_MIN_PROBE_PIN
   #define Z_MIN_PROBE_PIN  19
 #endif
-//
+
 #define E2_STEP_PIN        23
 #define E2_DIR_PIN         25
 #define E2_ENABLE_PIN      40
diff --git a/Marlin/pins_BRAINWAVE_PRO.h b/Marlin/pins_BRAINWAVE_PRO.h
index 3b33eeb..cba0d46 100644
--- a/Marlin/pins_BRAINWAVE_PRO.h
+++ b/Marlin/pins_BRAINWAVE_PRO.h
@@ -41,21 +41,24 @@
 
 #define LARGE_FLASH        true
 
+#define X_STOP_PIN         47
+#define Y_STOP_PIN         18
+#define Z_MAX_PIN          36
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN  17
+#endif
+
 #define X_STEP_PIN         33
 #define X_DIR_PIN          32
 #define X_ENABLE_PIN       11
-#define X_STOP_PIN         47
 
 #define Y_STEP_PIN         31
 #define Y_DIR_PIN          30
 #define Y_ENABLE_PIN        8
-#define Y_STOP_PIN         18
 
 #define Z_STEP_PIN         29
 #define Z_DIR_PIN          28
 #define Z_ENABLE_PIN       37
-#define Z_MAX_PIN          36
-#define Z_MIN_PROBE_PIN    17  // Bed Z probe
 
 #define E0_STEP_PIN        35
 #define E0_DIR_PIN         34
diff --git a/Marlin/pins_RAMBO.h b/Marlin/pins_RAMBO.h
index d1bd48b..278774c 100644
--- a/Marlin/pins_RAMBO.h
+++ b/Marlin/pins_RAMBO.h
@@ -42,26 +42,30 @@
   #define SLED_PIN         -1
 #endif
 
-#define X_STEP_PIN 37
-#define X_DIR_PIN 48
 #define X_MIN_PIN 12
 #define X_MAX_PIN 24
+#define Y_MIN_PIN 11
+#define Y_MAX_PIN 23
+#define Z_MIN_PIN 10
+#define Z_MAX_PIN 30
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN 10
+#endif
+
+#define X_STEP_PIN 37
+#define X_DIR_PIN 48
 #define X_ENABLE_PIN 29
 #define X_MS1_PIN 40
 #define X_MS2_PIN 41
 
 #define Y_STEP_PIN 36
 #define Y_DIR_PIN 49
-#define Y_MIN_PIN 11
-#define Y_MAX_PIN 23
 #define Y_ENABLE_PIN 28
 #define Y_MS1_PIN 69
 #define Y_MS2_PIN 39
 
 #define Z_STEP_PIN 35
 #define Z_DIR_PIN 47
-#define Z_MIN_PIN 10
-#define Z_MAX_PIN 30
 #define Z_ENABLE_PIN 27
 #define Z_MS1_PIN 68
 #define Z_MS2_PIN 67
diff --git a/Marlin/pins_RAMPS.h b/Marlin/pins_RAMPS.h
index 3280dd3..5f2e0d1 100644
--- a/Marlin/pins_RAMPS.h
+++ b/Marlin/pins_RAMPS.h
@@ -63,25 +63,29 @@
 #define SERVO2_PIN          5
 #define SERVO3_PIN          4
 
-#define X_STEP_PIN         54
-#define X_DIR_PIN          55
-#define X_ENABLE_PIN       38
 #define X_MIN_PIN           3
 #ifndef X_MAX_PIN
   #define X_MAX_PIN         2
 #endif
+#define Y_MIN_PIN          14
+#define Y_MAX_PIN          15
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          19
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN  32
+#endif
+
+#define X_STEP_PIN         54
+#define X_DIR_PIN          55
+#define X_ENABLE_PIN       38
 
 #define Y_STEP_PIN         60
 #define Y_DIR_PIN          61
 #define Y_ENABLE_PIN       56
-#define Y_MIN_PIN          14
-#define Y_MAX_PIN          15
 
 #define Z_STEP_PIN         46
 #define Z_DIR_PIN          48
 #define Z_ENABLE_PIN       62
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          19
 
 #define E0_STEP_PIN        26
 #define E0_DIR_PIN         28
@@ -97,11 +101,6 @@
 // Use the RAMPS 1.4 Analog input 5 on the AUX2 connector
 #define FILWIDTH_PIN        5 // ANALOG NUMBERING
 
-#if ENABLED(Z_MIN_PROBE_ENDSTOP)
-  // Define a pin to use as the signal pin on Arduino for the Z_PROBE endstop.
-  #define Z_MIN_PROBE_PIN  32
-#endif
-
 // define digital pin 4 for the filament runout sensor. Use the RAMPS 1.4 digital input 4 on the servos connector
 #define FIL_RUNOUT_PIN      4
 
diff --git a/Marlin/pins_RIGIDBOARD.h b/Marlin/pins_RIGIDBOARD.h
index 6b76452..a60e492 100644
--- a/Marlin/pins_RIGIDBOARD.h
+++ b/Marlin/pins_RIGIDBOARD.h
@@ -24,22 +24,15 @@
  * RIGIDBOARD Arduino Mega with RAMPS v1.4 pin assignments
  */
 
-#include "pins_RAMPS.h"
-
-#undef BOARD_NAME
 #define BOARD_NAME "RigidBoard"
 
-#if ENABLED(Z_MIN_PROBE_ENDSTOP)
-  #undef Z_MAX_PIN
-  #define Z_MAX_PIN -1
-  #undef Z_MIN_PROBE_PIN
+#define RAMPS_D10_PIN       9    // EXTRUDER 1
+#define MOSFET_D_PIN       12    // EXTRUDER 2 or FAN
+#ifndef Z_MIN_PROBE_PIN
   #define Z_MIN_PROBE_PIN  19    // Z-MAX pin J14 End Stops
 #endif
 
-#undef HEATER_0_PIN
-#undef HEATER_1_PIN
-#define HEATER_0_PIN        9    // EXTRUDER 1
-#define HEATER_1_PIN       12    // EXTRUDER 2 (FAN On Sprinter)
+#include "pins_RAMPS.h"
 
 #undef TEMP_0_PIN
 #undef TEMP_1_PIN
diff --git a/Marlin/pins_RUMBA.h b/Marlin/pins_RUMBA.h
index 642deb2..ec5e023 100644
--- a/Marlin/pins_RUMBA.h
+++ b/Marlin/pins_RUMBA.h
@@ -53,8 +53,7 @@
 #define Z_MIN_PIN          33
 #define Z_MAX_PIN          32
 
-#if ENABLED(Z_MIN_PROBE_ENDSTOP)
-  // Define a pin to use as the signal pin on Arduino for the Z probe endstop.
+#ifndef Z_MIN_PROBE_PIN
   #define Z_MIN_PROBE_PIN  33
 #endif
 

commit bd7a96ed42ca035618d6c8f28b27468ae5ae205c (from f1be87a85cc9c793e2fb555da9f855e3ccec6b23)
Merge: 704ae1b f1be87a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 2 21:35:59 2016 -0700

    Merge pull request #4517 from thinkyhead/rc_min_probe_pin
    
    Define Z_MIN_PROBE_PIN always, allowing override

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 3aa0aff..9f289f2 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -215,7 +215,6 @@ void manage_inactivity(bool ignore_stepper_queue = false);
 /**
  * The axis order in all axis related arrays is X, Y, Z, E
  */
-#define NUM_AXIS 4
 #define _AXIS(AXIS) AXIS ##_AXIS
 
 void enable_all_steppers();
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index 304b3be..9ef9002 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -29,10 +29,12 @@
   Modified 14 February 2016 by Andreas Hardtung (added tx buffer)
 */
 
-#include "Marlin.h"
 #include "MarlinSerial.h"
+
 #include "stepper.h"
 
+#include "Marlin.h"
+
 #ifndef USBCON
 // this next line disables the entire HardwareSerial.cpp,
 // this is so I can support Attiny series and any other chip without a UART
diff --git a/Marlin/MarlinSerial.h b/Marlin/MarlinSerial.h
index a5e2ee7..e761752 100644
--- a/Marlin/MarlinSerial.h
+++ b/Marlin/MarlinSerial.h
@@ -31,13 +31,8 @@
 
 #ifndef MarlinSerial_h
 #define MarlinSerial_h
-#include "Marlin.h"
-
-#ifndef CRITICAL_SECTION_START
-  #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();
-  #define CRITICAL_SECTION_END    SREG = _sreg;
-#endif
 
+#include "MarlinConfig.h"
 
 #ifndef SERIAL_PORT
   #define SERIAL_PORT 0
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ccffdf7..84493cf 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -61,6 +61,7 @@
 #include "math.h"
 #include "nozzle.h"
 #include "duration_t.h"
+#include "types.h"
 
 #if ENABLED(USE_WATCHDOG)
   #include "watchdog.h"
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index 4548acf..199d64e 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -23,6 +23,7 @@
 #ifndef __BUZZER_H__
 #define __BUZZER_H__
 
+#include "types.h"
 #include "fastio.h"
 #include "circularqueue.h"
 #include "temperature.h"
@@ -127,7 +128,9 @@ class Buzzer {
 
         if (this->state.tone.frequency > 0) {
           #if ENABLED(SPEAKER)
+            CRITICAL_SECTION_START;
             ::tone(BEEPER_PIN, this->state.tone.frequency, this->state.tone.duration);
+            CRITICAL_SECTION_END;
           #else
             this->on();
           #endif
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index dd6ff9f..65b4093 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -20,13 +20,15 @@
  *
  */
 
-#include "Marlin.h"
 #include "cardreader.h"
+
 #include "ultralcd.h"
 #include "stepper.h"
 #include "temperature.h"
 #include "language.h"
 
+#include "Marlin.h"
+
 #if ENABLED(SDSUPPORT)
 
 CardReader::CardReader() {
@@ -614,7 +616,8 @@ void CardReader::printingHasFinished() {
     if (SD_FINISHED_STEPPERRELEASE)
       enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
     print_job_timer.stop();
-    enqueue_and_echo_commands_P(PSTR("M31"));
+    if (print_job_timer.duration() > 60)
+      enqueue_and_echo_commands_P(PSTR("M31"));
   }
 }
 
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 31b8238..8c22e58 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -23,11 +23,15 @@
 #ifndef CARDREADER_H
 #define CARDREADER_H
 
+#include "MarlinConfig.h"
+
 #if ENABLED(SDSUPPORT)
 
 #define MAX_DIR_DEPTH 10          // Maximum folder depth
 
 #include "SdFile.h"
+
+#include "types.h"
 #include "enum.h"
 
 class CardReader {
diff --git a/Marlin/circularqueue.h b/Marlin/circularqueue.h
index 99efd24..9aafb99 100644
--- a/Marlin/circularqueue.h
+++ b/Marlin/circularqueue.h
@@ -26,120 +26,119 @@
 #include <Arduino.h>
 
 /**
- * @brief Circular Queue class
+ * @brief   Circular Queue class
  * @details Implementation of the classic ring buffer data structure
  */
-template<typename T, int N>
+template<typename T, uint8_t N>
 class CircularQueue {
   private:
 
     /**
-     * @brief Buffer structure
+     * @brief   Buffer structure
      * @details This structure consolidates all the overhead required to handle
-     * a circular queue such as the pointers and the buffer vector.
+     *          a circular queue such as the pointers and the buffer vector.
      */
     struct buffer_t {
       uint8_t head;
       uint8_t tail;
+      uint8_t count;
       uint8_t size;
-      uint8_t length;
       T queue[N];
     } buffer;
 
   public:
     /**
-     * @brief Class constructor
+     * @brief   Class constructor
      * @details This class requires two template parameters, T defines the type
-     * of the items this queue will handle and N defines the maximum number of
-     * items that can be stored on the queue.
+     *          of item this queue will handle and N defines the maximum number of
+     *          items that can be stored on the queue.
      */
     CircularQueue<T, N>() {
-      this->buffer.length = N;
-      this->buffer.size = this->buffer.head = this->buffer.tail = 0;
+      this->buffer.size = N;
+      this->buffer.count = this->buffer.head = this->buffer.tail = 0;
     }
 
     /**
-     * @brief Removes and returns a item from the queue
-     * @details Removes the oldest item on the queue which is pointed by the
-     * buffer_t head variable, this item is then returned to the caller.
-     * @return type T item
+     * @brief   Removes and returns a item from the queue
+     * @details Removes the oldest item on the queue, pointed to by the
+     *          buffer_t head field. The item is returned to the caller.
+     * @return  type T item
      */
     T dequeue() {
       if (this->isEmpty()) return T();
 
-      T const item = this->buffer.queue[this->buffer.head++];
-      --this->buffer.size;
+      uint8_t index = this->buffer.head;
 
-      if (this->buffer.head == this->buffer.length)
+      --this->buffer.count;
+      if (++this->buffer.head == this->buffer.size)
         this->buffer.head = 0;
 
-      return item;
+      return this->buffer.queue[index];
     }
 
     /**
-     * @brief Adds an item to the queue
-     * @details Adds a item to the queue on the location pointed by the buffer_t
-     * tail vairable, will return false if there is no queue space available.
-     *
-     * @param item Item to be added to the queue
-     * @return true if the operation was successfull
+     * @brief   Adds an item to the queue
+     * @details Adds an item to the queue on the location pointed by the buffer_t
+     *          tail variable. Returns false if no queue space is available.
+     * @param   item Item to be added to the queue
+     * @return  true if the operation was successful
      */
     bool enqueue(T const &item) {
       if (this->isFull()) return false;
 
-      this->buffer.queue[this->buffer.tail++] = item;
-      ++this->buffer.size;
+      this->buffer.queue[this->buffer.tail] = item;
 
-      if (this->buffer.tail == this->buffer.length)
+      ++this->buffer.count;
+      if (++this->buffer.tail == this->buffer.size)
         this->buffer.tail = 0;
 
       return true;
     }
 
     /**
-     * @brief Checks if the queue has no items
+     * @brief   Checks if the queue has no items
      * @details Returns true if there are no items on the queue, false otherwise.
-     * @return true if queue is empty
+     * @return  true if queue is empty
      */
     bool isEmpty() {
-      return this->buffer.size == 0;
+      return this->buffer.count == 0;
     }
 
     /**
-     * @brief Checks if the queue is full
+     * @brief   Checks if the queue is full
      * @details Returns true if the queue is full, false otherwise.
-     * @return true if queue is full
+     * @return  true if queue is full
      */
     bool isFull() {
-      return this->buffer.size == this->buffer.length;
+      return this->buffer.count == this->buffer.size;
     }
 
     /**
-     * @brief Gets the queue size
+     * @brief   Gets the queue size
      * @details Returns the maximum number of items a queue can have.
-     * @return the queue lenght
+     * @return  the queue size
      */
-    uint8_t length() {
-      return this->buffer.length;
+    uint8_t size() {
+      return this->buffer.size;
     }
 
     /**
-     * @brief Gets the next item from the queue without removing it
-     * @details Returns the next item on the queue but the item is not removed
-     * from the queue nor the pointers updated.
-     * @return the queue size
+     * @brief   Gets the next item from the queue without removing it
+     * @details Returns the next item in the queue without removing it
+     *          or updating the pointers.
+     * @return  first item in the queue
      */
-    uint8_t peek() {
+    T peek() {
       return this->buffer.queue[this->buffer.head];
     }
 
     /**
      * @brief Gets the number of items on the queue
      * @details Returns the current number of items stored on the queue.
-     * @return type T item
+     * @return number of items in the queue
      */
-    uint8_t size() {
-      return this->buffer.size;
+    uint8_t count() {
+      return this->buffer.count;
     }
 };
 
diff --git a/Marlin/macros.h b/Marlin/macros.h
index c228ac3..5eec73e 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -23,6 +23,8 @@
 #ifndef MACROS_H
 #define MACROS_H
 
+#define NUM_AXIS 4
+
 #define FORCE_INLINE __attribute__((always_inline)) inline
 
 // Bracket code that shouldn't be interrupted
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index f738d56..4e4d4a1 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -58,13 +58,14 @@
  *
  */
 
-#include "Marlin.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 #include "ultralcd.h"
 #include "language.h"
 
+#include "Marlin.h"
+
 #if ENABLED(MESH_BED_LEVELING)
   #include "mesh_bed_leveling.h"
 #endif
diff --git a/Marlin/planner.h b/Marlin/planner.h
index eac1ae5..7405536 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -32,7 +32,8 @@
 #ifndef PLANNER_H
 #define PLANNER_H
 
-#include "Marlin.h"
+#include "types.h"
+#include "MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   #include "vector_3.h"
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 3ecf93a..1dd1531 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -47,6 +47,7 @@
 #include "speed_lookuptable.h"
 #include "stepper_indirection.h"
 #include "language.h"
+#include "types.h"
 
 class Stepper;
 extern Stepper stepper;
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 9a1de04..ffb47a5 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -27,10 +27,11 @@
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
-#include "Marlin.h"
 #include "planner.h"
 #include "thermistortables.h"
 
+#include "MarlinConfig.h"
+
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 1f0f309..6eb5eff 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -190,34 +190,54 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   #endif
 
   /**
-   * START_SCREEN generates the init code for a screen function
+   * START_SCREEN_OR_MENU generates init code for a screen or menu
    *
    *   encoderLine is the position based on the encoder
    *   encoderTopLine is the top menu line to display
    *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
    *   _menuLineNr is the menu item to draw and process
    *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+   *   _countedItems is the total number of items in the menu (after one call)
    */
-  #define _START_SCREEN(CODE, SKIP) \
+  #define START_SCREEN_OR_MENU(LIMIT) \
     ENCODER_DIRECTION_MENUS(); \
     encoderRateMultiplierEnabled = false; \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
+    static int8_t _countedItems = 0; \
     int8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
-    NOMORE(encoderTopLine, encoderLine); \
+    if (_countedItems > 0 && encoderLine >= _countedItems - LIMIT) { \
+      encoderLine = _countedItems - LIMIT; \
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    }
+
+  #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
-    bool _skipStatic = SKIP; \
-    CODE; \
     for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT; _lcdLineNr++, _menuLineNr++) { \
-      _thisItemNr = 0;
-
-  #define START_SCREEN() _START_SCREEN(NOOP, false)
+      _thisItemNr = 0
 
   /**
-   * START_MENU generates the init code for a menu function
+   * START_SCREEN  Opening code for a screen having only static items.
+   *               Do simplified scrolling of the entire screen.
    *
-   *   wasClicked indicates the controller was clicked
+   * START_MENU    Opening code for a screen with menu items.
+   *               Scroll as-needed to keep the selected line in view.
+   *               'wasClicked' indicates the controller was clicked.
    */
-  #define START_MENU() _START_SCREEN(bool wasClicked = LCD_CLICKED, true)
+  #define START_SCREEN() \
+    START_SCREEN_OR_MENU(LCD_HEIGHT); \
+    encoderTopLine = encoderLine; \
+    bool _skipStatic = false; \
+    SCREEN_OR_MENU_LOOP()
+
+  #define START_MENU() \
+    START_SCREEN_OR_MENU(1); \
+    NOMORE(encoderTopLine, encoderLine); \
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
+      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
+    } \
+    bool wasClicked = LCD_CLICKED; \
+    bool _skipStatic = true; \
+    SCREEN_OR_MENU_LOOP()
 
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
@@ -252,7 +272,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
         return; \
       } \
     } \
-    _thisItemNr++
+    ++_thisItemNr
 
   #define MENU_ITEM(TYPE, LABEL, ARGS...) do { \
       _skipStatic = false; \
@@ -270,42 +290,15 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## ARGS); \
     } \
-    _thisItemNr++
-
-  /**
-   *
-   * END_SCREEN  Closing code for a screen having only static items.
-   *             Do simplified scrolling of the entire screen.
-   *
-   * END_MENU    Closing code for a screen with menu items.
-   *             Scroll as-needed to keep the selected line in view.
-   *
-   * At this point _thisItemNr equals the total number of items.
-   *
-   */
+    ++_thisItemNr
 
-  // Simple-scroll by using encoderLine as encoderTopLine
   #define END_SCREEN() \
     } \
-    NOMORE(encoderLine, _thisItemNr - LCD_HEIGHT); \
-    NOLESS(encoderLine, 0); \
-    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    if (encoderTopLine != encoderLine) { \
-      encoderTopLine = encoderLine; \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    }
+    _countedItems = _thisItemNr
 
-  // Scroll through menu items, scrolling as-needed to stay in view
   #define END_MENU() \
     } \
-    if (encoderLine >= _thisItemNr) { \
-      encoderLine = _thisItemNr - 1; \
-      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    } \
-    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
-      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    } \
+    _countedItems = _thisItemNr; \
     UNUSED(_skipStatic)
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)

