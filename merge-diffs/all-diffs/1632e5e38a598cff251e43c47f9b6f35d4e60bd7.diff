commit 1632e5e38a598cff251e43c47f9b6f35d4e60bd7
Merge: 3cd7dbc 1d62309
Author: Neil Darlow <neil@darlow.co.uk>
Date:   Thu Sep 4 12:21:35 2014 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 46d6b96..eb2141a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -12,6 +12,13 @@
 // example_configurations/delta directory.
 //
 
+//===========================================================================
+//============================= SCARA Printer ===============================
+//===========================================================================
+// For a Delta printer replace the configuration files with the files in the
+// example_configurations/SCARA directory.
+//
+
 // User-specified version info of this build to display in [Pronterface, etc] terminal window during
 // startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
 // build by the user have been successfully uploaded into firmware.
@@ -72,6 +79,7 @@
 // 301= Rambo
 // 21 = Elefu Ra Board (v3)
 // 88 = 5DPrint D8 Driver Board
+// 999 = Leapfrog
 
 #ifndef MOTHERBOARD
 #define MOTHERBOARD 7
@@ -132,7 +140,6 @@
 // 1010 is Pt1000 with 1k pullup (non standard)
 // 147 is Pt100 with 4k7 pullup
 // 110 is Pt100 with 1k pullup (non standard)
-// 70 is 500C thermistor for Pico hot end
 
 #define TEMP_SENSOR_0 -1
 #define TEMP_SENSOR_1 -1
@@ -376,6 +383,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //============================= Bed Auto Leveling ===========================
 
 //#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 
@@ -436,6 +444,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
 
+  //#define Z_PROBE_SLED // turn on if you have a z-probe mounted on a sled like those designed by Charles Bell
+  //#define SLED_DOCKING_OFFSET 5 // the extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
   //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk
   //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
index 074ef6a..7bbfede 100644
--- a/Marlin/ConfigurationStore.cpp
+++ b/Marlin/ConfigurationStore.cpp
@@ -37,10 +37,15 @@ void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size)
 // the default values are used whenever there is a change to the data, to prevent
 // wrong data being written to the variables.
 // ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#ifdef DELTA
-#define EEPROM_VERSION "V11"
-#else
+
 #define EEPROM_VERSION "V10"
+#ifdef DELTA
+	#undef EEPROM_VERSION
+	#define EEPROM_VERSION "V11"
+#endif
+#ifdef SCARA
+	#undef EEPROM_VERSION
+	#define EEPROM_VERSION "V12"
 #endif
 
 #ifdef EEPROM_SETTINGS
@@ -49,7 +54,7 @@ void Config_StoreSettings()
   char ver[4]= "000";
   int i=EEPROM_OFFSET;
   EEPROM_WRITE_VAR(i,ver); // invalidate data first 
-  EEPROM_WRITE_VAR(i,axis_steps_per_unit);  
+  EEPROM_WRITE_VAR(i,axis_steps_per_unit);
   EEPROM_WRITE_VAR(i,max_feedrate);  
   EEPROM_WRITE_VAR(i,max_acceleration_units_per_sq_second);
   EEPROM_WRITE_VAR(i,acceleration);
@@ -93,6 +98,9 @@ void Config_StoreSettings()
     int lcd_contrast = 32;
   #endif
   EEPROM_WRITE_VAR(i,lcd_contrast);
+  #ifdef SCARA
+  EEPROM_WRITE_VAR(i,axis_scaling);        // Add scaling for SCARA
+  #endif
   char ver2[4]=EEPROM_VERSION;
   i=EEPROM_OFFSET;
   EEPROM_WRITE_VAR(i,ver2); // validate data
@@ -115,6 +123,16 @@ void Config_PrintSettings()
     SERIAL_ECHOLN("");
       
     SERIAL_ECHO_START;
+#ifdef SCARA
+SERIAL_ECHOLNPGM("Scaling factors:");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("  M365 X",axis_scaling[0]);
+    SERIAL_ECHOPAIR(" Y",axis_scaling[1]);
+    SERIAL_ECHOPAIR(" Z",axis_scaling[2]);
+    SERIAL_ECHOLN("");
+      
+    SERIAL_ECHO_START;
+#endif
     SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
     SERIAL_ECHO_START;
     SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
@@ -196,7 +214,7 @@ void Config_RetrieveSettings()
     if (strncmp(ver,stored_ver,3) == 0)
     {
         // version number match
-        EEPROM_READ_VAR(i,axis_steps_per_unit);  
+        EEPROM_READ_VAR(i,axis_steps_per_unit);
         EEPROM_READ_VAR(i,max_feedrate);  
         EEPROM_READ_VAR(i,max_acceleration_units_per_sq_second);
         
@@ -240,6 +258,9 @@ void Config_RetrieveSettings()
         int lcd_contrast;
         #endif
         EEPROM_READ_VAR(i,lcd_contrast);
+		#ifdef SCARA
+		EEPROM_READ_VAR(i,axis_scaling);
+		#endif
 
 		// Call updatePID (similar to when we have processed M301)
 		updatePID();
@@ -266,6 +287,9 @@ void Config_ResetDefault()
         axis_steps_per_unit[i]=tmp1[i];  
         max_feedrate[i]=tmp2[i];  
         max_acceleration_units_per_sq_second[i]=tmp3[i];
+		#ifdef SCARA
+		axis_scaling[i]=1;
+		#endif
     }
     
     // steps per sq second need to be updated to agree with the units per sq second
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 062b6d4..9e6ba26 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -178,6 +178,10 @@ void get_coordinates();
 void calculate_delta(float cartesian[3]);
 extern float delta[3];
 #endif
+#ifdef SCARA
+void calculate_delta(float cartesian[3]);
+void calculate_SCARA_forward_Transform(float f_scara[3]);
+#endif
 void prepare_move();
 void kill();
 void Stop();
@@ -215,6 +219,9 @@ extern float delta_diagonal_rod;
 extern float delta_segments_per_second;
 void recalc_delta_settings(float radius, float diagonal_rod);
 #endif
+#ifdef SCARA
+extern float axis_scaling[3];  // Build size scaling
+#endif
 extern float min_pos[3];
 extern float max_pos[3];
 extern bool axis_known_position[3];
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 2f8cf78..9116af8 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -78,6 +78,8 @@
 // G28 - Home all Axis
 // G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
 // G30 - Single Z Probe, probes bed at current XY location.
+// G31 - Dock sled (Z_PROBE_SLED only)
+// G32 - Undock sled (Z_PROBE_SLED only)
 // G90 - Use Absolute Coordinates
 // G91 - Use Relative Coordinates
 // G92 - Set current position to coordinates given
@@ -170,6 +172,16 @@
 // M908 - Control digital trimpot directly.
 // M350 - Set microstepping mode.
 // M351 - Toggle MS1 MS2 pins directly.
+
+// ************ SCARA Specific - This can change to suit future G-code regulations
+// M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
+// M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
+// M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
+// M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
+// M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
+// M365 - SCARA calibration: Scaling factor, X, Y, Z axis
+//************* SCARA End ***************
+
 // M928 - Start SD logging (M928 filename.g) - ended by M29
 // M999 - Restart after being stopped by error
 
@@ -212,6 +224,7 @@ float add_homeing[3]={0,0,0};
 #ifdef DELTA
 float endstop_adj[3]={0,0,0};
 #endif
+
 float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
 float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
 bool axis_known_position[3] = {false, false, false};
@@ -292,7 +305,11 @@ int EtoPPressure=0;
   float delta_diagonal_rod= DELTA_DIAGONAL_ROD;
   float delta_diagonal_rod_2= sq(delta_diagonal_rod);
   float delta_segments_per_second= DELTA_SEGMENTS_PER_SECOND;
-#endif					
+#endif
+
+#ifdef SCARA                              // Build size scaling
+float axis_scaling[3]={1,1,1};  // Build size scaling, default to 1
+#endif				
 
 bool cancel_heatup = false ;
 
@@ -301,6 +318,7 @@ bool cancel_heatup = false ;
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+static float delta[3] = {0.0, 0.0, 0.0};
 static float offset[3] = {0.0, 0.0, 0.0};
 static bool home_all_axis = true;
 static float feedrate = 1500.0, next_feedrate, saved_feedrate;
@@ -548,6 +566,10 @@ void setup()
   #ifdef DIGIPOT_I2C
     digipot_i2c_init();
   #endif
+#ifdef Z_PROBE_SLED
+  pinMode(SERVO0_PIN, OUTPUT);
+  digitalWrite(SERVO0_PIN, LOW); // turn it off
+#endif // Z_PROBE_SLED
 }
 
 
@@ -870,9 +892,59 @@ static void axis_is_at_home(int axis) {
     }
   }
 #endif
+#ifdef SCARA
+   float homeposition[3];
+   char i;
+   
+   if (axis < 2)
+   {
+   
+     for (i=0; i<3; i++)
+     {
+        homeposition[i] = base_home_pos(i); 
+     }  
+	// SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
+   //  SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
+   // Works out real Homeposition angles using inverse kinematics, 
+   // and calculates homing offset using forward kinematics
+     calculate_delta(homeposition);
+     
+    // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
+    // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
+     
+     for (i=0; i<2; i++)
+     {
+        delta[i] -= add_homeing[i];
+     } 
+     
+    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homeing[X_AXIS]);
+	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homeing[Y_AXIS]);
+    // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
+    // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
+      
+     calculate_SCARA_forward_Transform(delta);
+     
+    // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
+    // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
+     
+    current_position[axis] = delta[axis];
+    
+    // SCARA home positions are based on configuration since the actual limits are determined by the 
+    // inverse kinematic transform.
+    min_pos[axis] =          base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
+    max_pos[axis] =          base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));
+   } 
+   else
+   {
+      current_position[axis] = base_home_pos(axis) + add_homeing[axis];
+      min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
+      max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+   }
+#else
   current_position[axis] = base_home_pos(axis) + add_homeing[axis];
   min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
   max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+#endif
 }
 
 #ifdef ENABLE_AUTO_BED_LEVELING
@@ -894,7 +966,7 @@ static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
     current_position[Y_AXIS] = corrected_position.y;
     current_position[Z_AXIS] = corrected_position.z;
 
-    // but the bed at 0 so we don't go below it.
+    // put the bed at 0 so we don't go below it.
     current_position[Z_AXIS] = zprobe_zoffset; // in the lsq we reach here after raising the extruder due to the loop structure
 
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
@@ -1035,10 +1107,14 @@ static float probe_pt(float x, float y, float z_before) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_before);
   do_blocking_move_to(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
 
+#ifndef Z_PROBE_SLED
   engage_z_probe();   // Engage Z Servo endstop if available
+#endif // Z_PROBE_SLED
   run_z_probe();
   float measured_z = current_position[Z_AXIS];
+#ifndef Z_PROBE_SLED
   retract_z_probe();
+#endif // Z_PROBE_SLED
 
   SERIAL_PROTOCOLPGM(MSG_BED);
   SERIAL_PROTOCOLPGM(" x: ");
@@ -1071,6 +1147,7 @@ static void homeaxis(int axis) {
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 
 
+#ifndef Z_PROBE_SLED
     // Engage Servo endstop if enabled
     #ifdef SERVO_ENDSTOPS
       #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
@@ -1083,7 +1160,7 @@ static void homeaxis(int axis) {
         servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2]);
       }
     #endif
-
+#endif // Z_PROBE_SLED
     destination[axis] = 1.5 * max_length(axis) * axis_home_dir;
     feedrate = homing_feedrate[axis];
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
@@ -1125,12 +1202,13 @@ static void homeaxis(int axis) {
       }
     #endif
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
-    if (axis==Z_AXIS) retract_z_probe();
+//    if (axis==Z_AXIS) retract_z_probe();
 #endif
 
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+
 void refresh_cmd_timeout(void)
 {
   previous_millis_cmd = millis();
@@ -1154,7 +1232,12 @@ void refresh_cmd_timeout(void)
       retracted[active_extruder]=true;
       prepare_move();
       current_position[Z_AXIS]-=retract_zlift;
+#ifdef DELTA
+      calculate_delta(current_position); // change cartesian kinematic to  delta kinematic;
+      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+#else
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#endif
       prepare_move();
       feedrate = oldFeedrate;
     } else if(!retracting && retracted[active_extruder]) {
@@ -1163,7 +1246,12 @@ void refresh_cmd_timeout(void)
       destination[Z_AXIS]=current_position[Z_AXIS];
       destination[E_AXIS]=current_position[E_AXIS];
       current_position[Z_AXIS]+=retract_zlift;
+#ifdef DELTA
+      calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
+      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+#else
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#endif
       //prepare_move();
       if (swapretract) {
         current_position[E_AXIS]-=(retract_length_swap+retract_recover_length_swap)/volumetric_multiplier[active_extruder]; 
@@ -1180,6 +1268,42 @@ void refresh_cmd_timeout(void)
   } //retract
 #endif //FWRETRACT
 
+#ifdef ENABLE_AUTO_BED_LEVELING
+//
+// Method to dock/undock a sled designed by Charles Bell.
+//
+// dock[in]     If true, move to MAX_X and engage the electromagnet
+// offset[in]   The additional distance to move to adjust docking location
+//
+static void dock_sled(bool dock, int offset=0) {
+ int z_loc;
+ 
+ if (!((axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS]))) {
+   LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
+   SERIAL_ECHO_START;
+   SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
+   return;
+ }
+
+ if (dock) {
+   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
+                       current_position[Y_AXIS],
+                       current_position[Z_AXIS]);
+   // turn off magnet
+   digitalWrite(SERVO0_PIN, LOW);
+ } else {
+   if (current_position[Z_AXIS] < (Z_RAISE_BEFORE_PROBING + 5))
+     z_loc = Z_RAISE_BEFORE_PROBING;
+   else
+     z_loc = current_position[Z_AXIS];
+   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
+                       Y_PROBE_OFFSET_FROM_EXTRUDER, z_loc);
+   // turn on magnet
+   digitalWrite(SERVO0_PIN, HIGH);
+ }
+}
+#endif
+
 void process_commands()
 {
   unsigned long codenum; //throw away variable
@@ -1212,6 +1336,7 @@ void process_commands()
         return;
       }
       break;
+#ifndef SCARA //disable arc support
     case 2: // G2  - CW ARC
       if(Stopped == false) {
         get_arc_coordinates();
@@ -1226,6 +1351,7 @@ void process_commands()
         return;
       }
       break;
+#endif
     case 4: // G4 dwell
       LCD_MESSAGEPGM(MSG_DWELL);
       codenum = 0;
@@ -1304,12 +1430,12 @@ void process_commands()
           HOMEAXIS(Z);
 
           calculate_delta(current_position);
-          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
-
+          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);		  
+		  
 #else // NOT DELTA
 
       home_all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])));
-
+	  
       #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
@@ -1353,7 +1479,9 @@ void process_commands()
 
         current_position[X_AXIS] = destination[X_AXIS];
         current_position[Y_AXIS] = destination[Y_AXIS];
+		#ifndef SCARA
         current_position[Z_AXIS] = destination[Z_AXIS];
+		#endif
       }
       #endif
 
@@ -1383,13 +1511,21 @@ void process_commands()
       if(code_seen(axis_codes[X_AXIS]))
       {
         if(code_value_long() != 0) {
-          current_position[X_AXIS]=code_value()+add_homeing[0];
+		#ifdef SCARA
+		   current_position[X_AXIS]=code_value();
+		#else
+		   current_position[X_AXIS]=code_value()+add_homeing[0];
+		#endif
         }
       }
 
       if(code_seen(axis_codes[Y_AXIS])) {
         if(code_value_long() != 0) {
-          current_position[Y_AXIS]=code_value()+add_homeing[1];
+         #ifdef SCARA
+		   current_position[Y_AXIS]=code_value();
+		#else
+		   current_position[Y_AXIS]=code_value()+add_homeing[1];
+		#endif
         }
       }
 
@@ -1464,6 +1600,11 @@ void process_commands()
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 #endif // else DELTA
 
+#ifdef SCARA
+	  calculate_delta(current_position);
+      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+#endif SCARA
+
       #ifdef ENDSTOPS_ONLY_FOR_HOMING
         enable_endstops(false);
       #endif
@@ -1490,6 +1631,9 @@ void process_commands()
                 break; // abort G29, since we don't know where we are
             }
 
+#ifdef Z_PROBE_SLED
+            dock_sled(false);
+#endif // Z_PROBE_SLED
             st_synchronize();
             // make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly
             //vector_3 corrected_position = plan_get_position_mm();
@@ -1615,13 +1759,15 @@ void process_commands()
             apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);         //Apply the correction sending the probe offset
             current_position[Z_AXIS] = z_tmp - real_z + current_position[Z_AXIS];   //The difference is added to current position and sent to planner.
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#ifdef Z_PROBE_SLED
+            dock_sled(true, -SLED_DOCKING_OFFSET); // correct for over travel.
+#endif // Z_PROBE_SLED
         }
         break;
-
+#ifndef Z_PROBE_SLED
     case 30: // G30 Single Z Probe
         {
             engage_z_probe(); // Engage Z Servo endstop if available
-
             st_synchronize();
             // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
             setup_for_endstop_move();
@@ -1639,10 +1785,17 @@ void process_commands()
             SERIAL_PROTOCOLPGM("\n");
 
             clean_up_after_endstop_move();
-
             retract_z_probe(); // Retract Z Servo endstop if available
         }
         break;
+#else
+    case 31: // dock the sled
+        dock_sled(true);
+        break;
+    case 32: // undock the sled
+        dock_sled(false);
+        break;
+#endif // Z_PROBE_SLED
 #endif // ENABLE_AUTO_BED_LEVELING
     case 90: // G90
       relative_mode = false;
@@ -1660,8 +1813,17 @@ void process_commands()
              plan_set_e_position(current_position[E_AXIS]);
            }
            else {
-             current_position[i] = code_value()+add_homeing[i];
-             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#ifdef SCARA
+		if (i == X_AXIS || i == Y_AXIS) {
+                	current_position[i] = code_value();  
+		}
+		else {
+                current_position[i] = code_value()+add_homeing[i];  
+            	}  
+#else
+		current_position[i] = code_value()+add_homeing[i];
+#endif
+            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            }
         }
       }
@@ -1864,6 +2026,280 @@ void process_commands()
         }
       }
      break;
+
+// M48 Z-Probe repeatability measurement function.
+//
+// Usage:   M48 <n #_samples> <X X_position_for_samples> <Y Y_position_for_samples> <V Verbose_Level> <Engage_probe_for_each_reading> <L legs_of_movement_prior_to_doing_probe>
+//	
+// This function assumes the bed has been homed.  Specificaly, that a G28 command
+// as been issued prior to invoking the M48 Z-Probe repeatability measurement function.
+// Any information generated by a prior G29 Bed leveling command will be lost and need to be
+// regenerated.
+//
+// The number of samples will default to 10 if not specified.  You can use upper or lower case
+// letters for any of the options EXCEPT n.  n must be in lower case because Marlin uses a capital
+// N for its communication protocol and will get horribly confused if you send it a capital N.
+//
+
+#ifdef ENABLE_AUTO_BED_LEVELING
+#ifdef Z_PROBE_REPEATABILITY_TEST 
+
+    case 48: // M48 Z-Probe repeatability
+        {
+            #if Z_MIN_PIN == -1
+            #error "You must have a Z_MIN endstop in order to enable calculation of Z-Probe repeatability."
+            #endif
+
+	double sum=0.0; 
+	double mean=0.0; 
+	double sigma=0.0;
+	double sample_set[50];
+	int verbose_level=1, n=0, j, n_samples = 10, n_legs=0, engage_probe_for_each_reading=0 ;
+	double X_current, Y_current, Z_current;
+	double X_probe_location, Y_probe_location, Z_start_location, ext_position;
+	
+	if (code_seen('V') || code_seen('v')) {
+        	verbose_level = code_value();
+		if (verbose_level<0 || verbose_level>4 ) {
+			SERIAL_PROTOCOLPGM("?Verbose Level not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (verbose_level > 0)   {
+		SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test.   Version 2.00\n");
+		SERIAL_PROTOCOLPGM("Full support at: http://3dprintboard.com/forum.php\n");
+	}
+
+	if (code_seen('n')) {
+        	n_samples = code_value();
+		if (n_samples<4 || n_samples>50 ) {
+			SERIAL_PROTOCOLPGM("?Specified sample size not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	X_current = X_probe_location = st_get_position_mm(X_AXIS);
+	Y_current = Y_probe_location = st_get_position_mm(Y_AXIS);
+	Z_current = st_get_position_mm(Z_AXIS);
+	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
+	ext_position	 = st_get_position_mm(E_AXIS);
+
+	if (code_seen('E') || code_seen('e') ) 
+		engage_probe_for_each_reading++;
+
+	if (code_seen('X') || code_seen('x') ) {
+        	X_probe_location = code_value() -  X_PROBE_OFFSET_FROM_EXTRUDER;
+		if (X_probe_location<X_MIN_POS || X_probe_location>X_MAX_POS ) {
+			SERIAL_PROTOCOLPGM("?Specified X position out of range.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (code_seen('Y') || code_seen('y') ) {
+        	Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;
+		if (Y_probe_location<Y_MIN_POS || Y_probe_location>Y_MAX_POS ) {
+			SERIAL_PROTOCOLPGM("?Specified Y position out of range.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (code_seen('L') || code_seen('l') ) {
+        	n_legs = code_value();
+		if ( n_legs==1 ) 
+			n_legs = 2;
+		if ( n_legs<0 || n_legs>15 ) {
+			SERIAL_PROTOCOLPGM("?Specified number of legs in movement not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+//
+// Do all the preliminary setup work.   First raise the probe.
+//
+
+        st_synchronize();
+        plan_bed_level_matrix.set_to_identity();
+	plan_buffer_line( X_current, Y_current, Z_start_location,
+			ext_position,
+    			homing_feedrate[Z_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+
+//
+// Now get everything to the specified probe point So we can safely do a probe to
+// get us close to the bed.  If the Z-Axis is far from the bed, we don't want to 
+// use that as a starting point for each probe.
+//
+	if (verbose_level > 2) 
+		SERIAL_PROTOCOL("Positioning probe for the test.\n");
+
+	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
+			ext_position,
+    			homing_feedrate[X_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+
+	current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);
+	current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+	current_position[E_AXIS] = ext_position = st_get_position_mm(E_AXIS);
+
+// 
+// OK, do the inital probe to get us close to the bed.
+// Then retrace the right amount and use that in subsequent probes
+//
+
+        engage_z_probe();	
+
+	setup_for_endstop_move();
+	run_z_probe();
+
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
+
+	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
+			ext_position,
+    			homing_feedrate[X_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+
+	if (engage_probe_for_each_reading)
+        	retract_z_probe();
+
+        for( n=0; n<n_samples; n++) {
+
+		do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Make sure we are at the probe location
+
+		if ( n_legs)  {
+		double radius=0.0, theta=0.0, x_sweep, y_sweep;
+		int rotational_direction, l;
+
+			rotational_direction = (unsigned long) millis() & 0x0001;			// clockwise or counter clockwise
+			radius = (unsigned long) millis() % (long) (X_MAX_LENGTH/4); 			// limit how far out to go 
+			theta = (float) ((unsigned long) millis() % (long) 360) / (360./(2*3.1415926));	// turn into radians
+
+//SERIAL_ECHOPAIR("starting radius: ",radius);
+//SERIAL_ECHOPAIR("   theta: ",theta);
+//SERIAL_ECHOPAIR("   direction: ",rotational_direction);
+//SERIAL_PROTOCOLLNPGM("");
+
+			for( l=0; l<n_legs-1; l++) {
+				if (rotational_direction==1)
+					theta += (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians
+				else
+					theta -= (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians
+
+				radius += (float) ( ((long) ((unsigned long) millis() % (long) 10)) - 5);
+				if ( radius<0.0 )
+					radius = -radius;
+
+				X_current = X_probe_location + cos(theta) * radius;
+				Y_current = Y_probe_location + sin(theta) * radius;
+
+				if ( X_current<X_MIN_POS)		// Make sure our X & Y are sane
+					 X_current = X_MIN_POS;
+				if ( X_current>X_MAX_POS)
+					 X_current = X_MAX_POS;
+
+				if ( Y_current<Y_MIN_POS)		// Make sure our X & Y are sane
+					 Y_current = Y_MIN_POS;
+				if ( Y_current>Y_MAX_POS)
+					 Y_current = Y_MAX_POS;
+
+				if (verbose_level>3 ) {
+					SERIAL_ECHOPAIR("x: ", X_current);
+					SERIAL_ECHOPAIR("y: ", Y_current);
+					SERIAL_PROTOCOLLNPGM("");
+				}
+
+				do_blocking_move_to( X_current, Y_current, Z_current );
+			}
+			do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Go back to the probe location
+		}
+
+		if (engage_probe_for_each_reading)  {
+        		engage_z_probe();	
+          		delay(1000);
+		}
+
+		setup_for_endstop_move();
+                run_z_probe();
+
+		sample_set[n] = current_position[Z_AXIS];
+
+//
+// Get the current mean for the data points we have so far
+//
+		sum=0.0; 
+		for( j=0; j<=n; j++) {
+			sum = sum + sample_set[j];
+		}
+		mean = sum / (double (n+1));
+//
+// Now, use that mean to calculate the standard deviation for the
+// data points we have so far
+//
+
+		sum=0.0; 
+		for( j=0; j<=n; j++) {
+			sum = sum + (sample_set[j]-mean) * (sample_set[j]-mean);
+		}
+		sigma = sqrt( sum / (double (n+1)) );
+
+		if (verbose_level > 1) {
+			SERIAL_PROTOCOL(n+1);
+			SERIAL_PROTOCOL(" of ");
+			SERIAL_PROTOCOL(n_samples);
+			SERIAL_PROTOCOLPGM("   z: ");
+			SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
+		}
+
+		if (verbose_level > 2) {
+			SERIAL_PROTOCOL(" mean: ");
+			SERIAL_PROTOCOL_F(mean,6);
+
+			SERIAL_PROTOCOL("   sigma: ");
+			SERIAL_PROTOCOL_F(sigma,6);
+		}
+
+		if (verbose_level > 0) 
+			SERIAL_PROTOCOLPGM("\n");
+
+		plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location, 
+				  current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);
+        	st_synchronize();
+
+		if (engage_probe_for_each_reading)  {
+        		retract_z_probe();	
+          		delay(1000);
+		}
+	}
+
+        retract_z_probe();
+	delay(1000);
+
+        clean_up_after_endstop_move();
+
+//      enable_endstops(true);
+
+	if (verbose_level > 0) {
+		SERIAL_PROTOCOLPGM("Mean: ");
+		SERIAL_PROTOCOL_F(mean, 6);
+		SERIAL_PROTOCOLPGM("\n");
+	}
+
+SERIAL_PROTOCOLPGM("Standard Deviation: ");
+SERIAL_PROTOCOL_F(sigma, 6);
+SERIAL_PROTOCOLPGM("\n\n");
+
+Sigma_Exit:
+        break;
+	}
+#endif		// Z_PROBE_REPEATABILITY_TEST 
+#endif		// ENABLE_AUTO_BED_LEVELING
+
     case 104: // M104
       if(setTargetedHotend(104)){
         break;
@@ -1984,7 +2420,7 @@ void process_commands()
 
       /* See if we are heating up or cooling down */
       target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
-      
+
       cancel_heatup = false;
 
       #ifdef TEMP_RESIDENCY_TIME
@@ -2256,6 +2692,26 @@ void process_commands()
       SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
 
       SERIAL_PROTOCOLLN("");
+#ifdef SCARA
+	  SERIAL_PROTOCOLPGM("SCARA Theta:");
+      SERIAL_PROTOCOL(delta[X_AXIS]);
+      SERIAL_PROTOCOLPGM("   Psi+Theta:");
+      SERIAL_PROTOCOL(delta[Y_AXIS]);
+      SERIAL_PROTOCOLLN("");
+      
+      SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");
+      SERIAL_PROTOCOL(delta[X_AXIS]+add_homeing[0]);
+      SERIAL_PROTOCOLPGM("   Psi+Theta (90):");
+      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homeing[1]);
+      SERIAL_PROTOCOLLN("");
+      
+      SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
+      SERIAL_PROTOCOL(delta[X_AXIS]/90*axis_steps_per_unit[X_AXIS]);
+      SERIAL_PROTOCOLPGM("   Psi+Theta:");
+      SERIAL_PROTOCOL((delta[Y_AXIS]-delta[X_AXIS])/90*axis_steps_per_unit[Y_AXIS]);
+      SERIAL_PROTOCOLLN("");
+      SERIAL_PROTOCOLLN("");
+#endif
       break;
     case 120: // M120
       enable_endstops(false) ;
@@ -2377,6 +2833,16 @@ void process_commands()
       {
         if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
       }
+	  #ifdef SCARA
+	   if(code_seen('T'))       // Theta
+      {
+        add_homeing[0] = code_value() ;
+      }
+      if(code_seen('P'))       // Psi
+      {
+        add_homeing[1] = code_value() ;
+      }
+	  #endif
       break;
     #ifdef DELTA
 	case 665: // M665 set delta configurations L<diagonal_rod> R<delta_radius> S<segments_per_sec>
@@ -2755,12 +3221,111 @@ void process_commands()
       PID_autotune(temp, e, c);
     }
     break;
+	#ifdef SCARA
+	case 360:  // M360 SCARA Theta pos1
+      SERIAL_ECHOLN(" Cal: Theta 0 ");
+      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
+      //SERIAL_ECHOLN(" Soft endstops disabled ");
+      if(Stopped == false) {
+        //get_coordinates(); // For X Y Z E F
+        delta[0] = 0;
+        delta[1] = 120;
+        calculate_SCARA_forward_Transform(delta);
+        destination[0] = delta[0]/axis_scaling[X_AXIS];
+        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+    break;
+
+    case 361:  // SCARA Theta pos2
+      SERIAL_ECHOLN(" Cal: Theta 90 ");
+      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
+      //SERIAL_ECHOLN(" Soft endstops disabled ");
+      if(Stopped == false) {
+        //get_coordinates(); // For X Y Z E F
+        delta[0] = 90;
+        delta[1] = 130;
+        calculate_SCARA_forward_Transform(delta);
+        destination[0] = delta[0]/axis_scaling[X_AXIS];
+        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+    break;
+    case 362:  // SCARA Psi pos1
+      SERIAL_ECHOLN(" Cal: Psi 0 ");
+      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
+      //SERIAL_ECHOLN(" Soft endstops disabled ");
+      if(Stopped == false) {
+        //get_coordinates(); // For X Y Z E F
+        delta[0] = 60;
+        delta[1] = 180;
+        calculate_SCARA_forward_Transform(delta);
+        destination[0] = delta[0]/axis_scaling[X_AXIS];
+        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+    break;
+    case 363:  // SCARA Psi pos2
+      SERIAL_ECHOLN(" Cal: Psi 90 ");
+      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
+      //SERIAL_ECHOLN(" Soft endstops disabled ");
+      if(Stopped == false) {
+        //get_coordinates(); // For X Y Z E F
+        delta[0] = 50;
+        delta[1] = 90;
+        calculate_SCARA_forward_Transform(delta);
+        destination[0] = delta[0]/axis_scaling[X_AXIS];
+        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+    break;
+    case 364:  // SCARA Psi pos3 (90 deg to Theta)
+      SERIAL_ECHOLN(" Cal: Theta-Psi 90 ");
+     // SoftEndsEnabled = false;              // Ignore soft endstops during calibration
+      //SERIAL_ECHOLN(" Soft endstops disabled ");
+      if(Stopped == false) {
+        //get_coordinates(); // For X Y Z E F
+        delta[0] = 45;
+        delta[1] = 135;
+        calculate_SCARA_forward_Transform(delta);
+        destination[0] = delta[0]/axis_scaling[X_AXIS];
+        destination[1] = delta[1]/axis_scaling[Y_AXIS]; 
+        
+        prepare_move();
+        //ClearToSend();
+        return;
+      }
+    break;
+    case 365: // M364  Set SCARA scaling for X Y Z
+      for(int8_t i=0; i < 3; i++) 
+      {
+        if(code_seen(axis_codes[i])) 
+        {
+          
+            axis_scaling[i] = code_value();
+          
+        }
+      }
+      break;
+	#endif
     case 400: // M400 finish all moves
     {
       st_synchronize();
     }
     break;
-#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS)
+#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS) && not defined(Z_PROBE_SLED)
     case 401:
     {
         engage_z_probe();    // Engage Z Servo endstop if available
@@ -3317,8 +3882,46 @@ void calculate_delta(float cartesian[3])
 void prepare_move()
 {
   clamp_to_software_endstops(destination);
-
   previous_millis_cmd = millis();
+  
+  #ifdef SCARA //for now same as delta-code
+
+float difference[NUM_AXIS];
+for (int8_t i=0; i < NUM_AXIS; i++) {
+	difference[i] = destination[i] - current_position[i];
+}
+
+float cartesian_mm = sqrt(	sq(difference[X_AXIS]) +
+							sq(difference[Y_AXIS]) +
+							sq(difference[Z_AXIS]));
+if (cartesian_mm < 0.000001) { cartesian_mm = abs(difference[E_AXIS]); }
+if (cartesian_mm < 0.000001) { return; }
+float seconds = 6000 * cartesian_mm / feedrate / feedmultiply;
+int steps = max(1, int(scara_segments_per_second * seconds));
+ //SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
+ //SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
+ //SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);
+for (int s = 1; s <= steps; s++) {
+	float fraction = float(s) / float(steps);
+	for(int8_t i=0; i < NUM_AXIS; i++) {
+		destination[i] = current_position[i] + difference[i] * fraction;
+	}
+
+	
+	calculate_delta(destination);
+         //SERIAL_ECHOPGM("destination[0]="); SERIAL_ECHOLN(destination[0]);
+         //SERIAL_ECHOPGM("destination[1]="); SERIAL_ECHOLN(destination[1]);
+         //SERIAL_ECHOPGM("destination[2]="); SERIAL_ECHOLN(destination[2]);
+         //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);
+         //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
+         //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);
+         
+	plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
+	destination[E_AXIS], feedrate*feedmultiply/60/100.0,
+	active_extruder);
+}
+#endif // SCARA
+  
 #ifdef DELTA
   float difference[NUM_AXIS];
   for (int8_t i=0; i < NUM_AXIS; i++) {
@@ -3344,7 +3947,8 @@ void prepare_move()
                      destination[E_AXIS], feedrate*feedmultiply/60/100.0,
                      active_extruder);
   }
-#else
+  
+#endif // DELTA
 
 #ifdef DUAL_X_CARRIAGE
   if (active_extruder_parked)
@@ -3387,6 +3991,7 @@ void prepare_move()
   }
 #endif //DUAL_X_CARRIAGE
 
+#if ! (defined DELTA || defined SCARA)
   // Do not use feedmultiply for E or Z only moves
   if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
       plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
@@ -3394,7 +3999,8 @@ void prepare_move()
   else {
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
   }
-#endif //else DELTA
+#endif // !(DELTA || SCARA)
+
   for(int8_t i=0; i < NUM_AXIS; i++) {
     current_position[i] = destination[i];
   }
@@ -3462,6 +4068,84 @@ void controllerFan()
 }
 #endif
 
+#ifdef SCARA
+void calculate_SCARA_forward_Transform(float f_scara[3])
+{
+  // Perform forward kinematics, and place results in delta[3]
+  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
+  
+  float x_sin, x_cos, y_sin, y_cos;
+  
+    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
+    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);
+  
+    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
+    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
+    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
+    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
+   
+  //  SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
+  //  SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
+  //  SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
+  //  SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);
+  
+    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
+    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi
+	
+    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
+    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
+}  
+
+void calculate_delta(float cartesian[3]){
+  //reverse kinematics.
+  // Perform reversed kinematics, and place results in delta[3]
+  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
+  
+  float SCARA_pos[2];
+  static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi; 
+  
+  SCARA_pos[X_AXIS] = cartesian[X_AXIS] * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y
+  SCARA_pos[Y_AXIS] = cartesian[Y_AXIS] * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.
+  
+  #if (Linkage_1 == Linkage_2)
+    SCARA_C2 = ( ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) ) / (2 * (float)L1_2) ) - 1;
+  #else
+    SCARA_C2 =   ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) - (float)L1_2 - (float)L2_2 ) / 45000; 
+  #endif
+  
+  SCARA_S2 = sqrt( 1 - sq(SCARA_C2) );
+  
+  SCARA_K1 = Linkage_1 + Linkage_2 * SCARA_C2;
+  SCARA_K2 = Linkage_2 * SCARA_S2;
+  
+  SCARA_theta = ( atan2(SCARA_pos[X_AXIS],SCARA_pos[Y_AXIS])-atan2(SCARA_K1, SCARA_K2) ) * -1;
+  SCARA_psi   =   atan2(SCARA_S2,SCARA_C2);
+  
+  delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle
+  delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)
+  delta[Z_AXIS] = cartesian[Z_AXIS];
+  
+  /*
+  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
+  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
+  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
+  
+  SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);
+  SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);
+  
+  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
+  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
+  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
+  
+  SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);
+  SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);
+  SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);
+  SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);
+  SERIAL_ECHOLN(" ");*/
+}
+
+#endif
+
 #ifdef TEMP_STAT_LEDS
 static bool blue_led = false;
 static bool red_led = false;
@@ -3518,10 +4202,9 @@ void manage_inactivity()
   }
   
   #ifdef CHDK //Check if pin should be set to LOW after M240 set it to HIGH
-    if (chdkActive)
+    if (chdkActive && (millis() - chdkHigh > CHDK_DELAY))
     {
       chdkActive = false;
-      if (millis()-chdkHigh < CHDK_DELAY) return;
       WRITE(CHDK, LOW);
     }
   #endif
diff --git a/Marlin/example_configurations/SCARA/Configuration.h b/Marlin/example_configurations/SCARA/Configuration.h
new file mode 100644
index 0000000..6b74b0c
--- /dev/null
+++ b/Marlin/example_configurations/SCARA/Configuration.h
@@ -0,0 +1,802 @@
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+// This configuration file contains the basic settings.
+// Advanced settings can be found in Configuration_adv.h
+// BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
+
+//===========================================================================
+//========================= SCARA Settings ==================================
+//===========================================================================
+// SCARA-mode for Marlin has been developed by QHARLEY in ZA in 2012/2013. Implemented
+// and slightly reworked by JCERNY in 06/2014 with the goal to bring it into Master-Branch
+// QHARLEYS Autobedlevelling has not been ported, because Marlin has now Bed-levelling
+// You might need Z-Min endstop on SCARA-Printer to use this feature. Actually untested!
+// Uncomment to use Morgan scara mode
+#define SCARA  
+#define scara_segments_per_second 200 //careful, two much will decrease performance...
+// Length of inner support arm
+#define Linkage_1 150 //mm      Preprocessor cannot handle decimal point...
+// Length of outer support arm     Measure arm lengths precisely and enter 
+#define Linkage_2 150 //mm    
+
+// SCARA tower offset (position of Tower relative to bed zero position) 
+// This needs to be reasonably accurate as it defines the printbed position in the SCARA space.
+#define SCARA_offset_x 100 //mm   
+#define SCARA_offset_y -56 //mm
+#define SCARA_RAD2DEG 57.2957795  // to convert RAD to degrees
+
+#define THETA_HOMING_OFFSET 0	//calculatated from Calibration Guide and command M360 / M114 see picture in http://reprap.harleystudio.co.za/?page_id=1073
+#define PSI_HOMING_OFFSET 0  // calculatated from Calibration Guide and command M364 / M114 see picture in http://reprap.harleystudio.co.za/?page_id=1073
+
+//some helper variables to make kinematics faster
+#define L1_2 sq(Linkage_1) // do not change
+#define L2_2 sq(Linkage_2) // do not change
+
+//===========================================================================
+//========================= SCARA Settings end ==================================
+//===========================================================================
+
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
+#define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+#define SERIAL_PORT 0
+
+// This determines the communication speed of the printer
+// This determines the communication speed of the printer
+#define BAUDRATE 250000
+
+// This enables the serial port associated to the Bluetooth interface
+//#define BTENABLED              // Enable BT interface on AT90USB devices
+
+
+//// The following define selects which electronics board you have. Please choose the one that matches your setup
+// 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"
+// 11 = Gen7 v1.1, v1.2 = 11
+// 12 = Gen7 v1.3
+// 13 = Gen7 v1.4
+// 131 = OpenHardware.co.za custom Gen7 electronics
+// 2  = Cheaptronic v1.0
+// 20 = Sethi 3D_1
+// 3  = MEGA/RAMPS up to 1.2 = 3
+// 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
+// 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
+// 35 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)
+// 4  = Duemilanove w/ ATMega328P pin assignment
+// 5  = Gen6
+// 51 = Gen6 deluxe
+// 6  = Sanguinololu < 1.2
+// 62 = Sanguinololu 1.2 and above
+// 63 = Melzi
+// 64 = STB V1.1
+// 65 = Azteeg X1
+// 66 = Melzi with ATmega1284 (MaKr3d version)
+// 67 = Azteeg X3
+// 68 = Azteeg X3 Pro
+// 7  = Ultimaker
+// 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 72 = Ultimainboard 2.x (Uses TEMP_SENSOR 20)
+// 77 = 3Drag Controller
+// 8  = Teensylu
+// 80 = Rumba
+// 81 = Printrboard (AT90USB1286)
+// 82 = Brainwave (AT90USB646)
+// 83 = SAV Mk-I (AT90USB1286)
+// 84 = Teensy++2.0 (AT90USB1286) // CLI compile: DEFINES=AT90USBxx_TEENSYPP_ASSIGNMENTS HARDWARE_MOTHERBOARD=84  make
+// 9  = Gen3+
+// 70 = Megatronics
+// 701= Megatronics v2.0
+// 702= Minitronics v1.0
+// 90 = Alpha OMCA board
+// 91 = Final OMCA board
+// 301= Rambo
+// 21 = Elefu Ra Board (v3)
+// 88 = 5DPrint D8 Driver Board
+
+#ifndef MOTHERBOARD
+#define MOTHERBOARD 33
+#endif
+
+// Define this to set a custom name for your generic Mendel,
+// #define CUSTOM_MENDEL_NAME "This Mendel"
+
+// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
+// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
+// #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
+
+// This defines the number of extruders
+#define EXTRUDERS 1
+
+//// The following define selects which power supply you have. Please choose the one that matches your setup
+// 1 = ATX
+// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+
+#define POWER_SUPPLY 1
+
+// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
+// #define PS_DEFAULT_OFF
+
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
+//
+//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table
+//
+//// Temperature sensor settings:
+// -2 is thermocouple with MAX6675 (only for sensor 0)
+// -1 is thermocouple with AD595
+// 0 is not used
+// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
+// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
+// 3 is Mendel-parts thermistor (4.7k pullup)
+// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
+// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
+// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
+// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
+// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)
+// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
+// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
+// 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 11 is 100k beta 3950 1% thermistor (4.7k pullup)
+// 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)
+// 20 is the PT100 circuit found in the Ultimainboard V2.x
+// 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950
+//
+//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
+//                          (but gives greater accuracy and more stable PID)
+// 51 is 100k thermistor - EPCOS (1k pullup)
+// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
+// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+//
+// 1047 is Pt1000 with 4k7 pullup
+// 1010 is Pt1000 with 1k pullup (non standard)
+// 147 is Pt100 with 4k7 pullup
+// 110 is Pt100 with 1k pullup (non standard)
+
+#define TEMP_SENSOR_0 1
+#define TEMP_SENSOR_1 0
+#define TEMP_SENSOR_2 0
+#define TEMP_SENSOR_BED 1
+
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
+// Actual temperature must be close to target for this long before M109 returns success
+#define TEMP_RESIDENCY_TIME 3  // (seconds)
+#define TEMP_HYSTERESIS 2       // (degC) range of +/- temperatures considered "close" to the target one
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
+
+// The minimal temperature defines the temperature below which the heater will not be enabled It is used
+// to check that the wiring to the thermistor is not broken.
+// Otherwise this would lead to the heater being powered on all the time.
+#define HEATER_0_MINTEMP 5
+#define HEATER_1_MINTEMP 5
+#define HEATER_2_MINTEMP 5
+#define BED_MINTEMP 5
+
+// When temperature exceeds max temp, your heater will be switched off.
+// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
+// You should use MINTEMP for thermistor short/failure protection.
+#define HEATER_0_MAXTEMP 275
+#define HEATER_1_MAXTEMP 275
+#define HEATER_2_MAXTEMP 275
+#define BED_MAXTEMP 150
+
+// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
+// average current. The value should be an integer and the heat bed will be turned on for 1 interval of
+// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
+//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
+
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+#define EXTRUDER_WATTS (2*2/5.9) //  P=I^2/R
+#define BED_WATTS (5.45*5.45/2.2)      // P=I^2/R
+
+// PID settings:
+// Comment the following line to disable PID and enable bang-bang.
+#define PIDTEMP
+#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#ifdef PIDTEMP
+  //#define PID_DEBUG // Sends debug data to the serial port.
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
+  #define PID_FUNCTIONAL_RANGE 20 // If the temperature difference between the target temperature and the actual temperature
+                                  // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
+  #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
+  #define K1 0.95 //smoothing factor within the PID
+  #define PID_dT ((OVERSAMPLENR * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
+
+// If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
+// Ultimaker
+  //  #define  DEFAULT_Kp 22.2
+  //  #define  DEFAULT_Ki 1.08
+   // #define  DEFAULT_Kd 114
+  
+ // Jhead MK5: From Autotune  
+  //  #define  DEFAULT_Kp 20.92
+   // #define  DEFAULT_Ki 1.51
+  //  #define  DEFAULT_Kd 72.34
+    
+ //Merlin Hotend: From Autotune  
+    #define  DEFAULT_Kp 24.5
+    #define  DEFAULT_Ki 1.72
+    #define  DEFAULT_Kd 87.73
+
+// MakerGear
+//    #define  DEFAULT_Kp 7.0
+//    #define  DEFAULT_Ki 0.1
+//    #define  DEFAULT_Kd 12
+
+// Mendel Parts V9 on 12V
+  //  #define  DEFAULT_Kp 63.0
+   // #define  DEFAULT_Ki 2.25
+   // #define  DEFAULT_Kd 440
+#endif // PIDTEMP
+
+// Bed Temperature Control
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
+// If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+#define PIDTEMPBED
+//
+#define BED_LIMIT_SWITCHING
+
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
+
+#ifdef PIDTEMPBED
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
+  //  #define  DEFAULT_bedKp 10.00
+  //  #define  DEFAULT_bedKi .023
+  //  #define  DEFAULT_bedKd 305.4
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from pidautotune
+//    #define  DEFAULT_bedKp 97.1
+//    #define  DEFAULT_bedKi 1.41
+//    #define  DEFAULT_bedKd 1675.16
+
+//12v Heatbed Mk3 12V in parallel
+//from pidautotune
+    #define  DEFAULT_bedKp 630.14
+    #define  DEFAULT_bedKi 121.71
+    #define  DEFAULT_bedKd 815.64
+    
+// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+
+
+//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
+//can be software-disabled for whatever purposes by
+//#define PREVENT_DANGEROUS_EXTRUDE
+//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
+#define PREVENT_LENGTHY_EXTRUDE
+
+#define EXTRUDE_MINTEMP 150
+#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
+
+/*================== Thermal Runaway Protection ==============================
+This is a feature to protect your printer from burn up in flames if it has
+a thermistor coming off place (this happened to a friend of mine recently and
+motivated me writing this feature).
+
+The issue: If a thermistor come off, it will read a lower temperature than actual.
+The system will turn the heater on forever, burning up the filament and anything
+else around.
+
+After the temperature reaches the target for the first time, this feature will 
+start measuring for how long the current temperature stays below the target 
+minus _HYSTERESIS (set_temperature - THERMAL_RUNAWAY_PROTECTION_HYSTERESIS).
+
+If it stays longer than _PERIOD, it means the thermistor temperature
+cannot catch up with the target, so something *may be* wrong. Then, to be on the
+safe side, the system will he halt.
+
+Bear in mind the count down will just start AFTER the first time the 
+thermistor temperature is over the target, so you will have no problem if
+your extruder heater takes 2 minutes to hit the target on heating.
+
+*/
+// If you want to enable this feature for all your extruder heaters,
+// uncomment the 2 defines below:
+
+// Parameters for all extruder heaters
+//#define THERMAL_RUNAWAY_PROTECTION_PERIOD 40 //in seconds
+//#define THERMAL_RUNAWAY_PROTECTION_HYSTERESIS 4 // in degree Celsius
+
+// If you want to enable this feature for your bed heater,
+// uncomment the 2 defines below:
+
+// Parameters for the bed heater
+//#define THERMAL_RUNAWAY_PROTECTION_BED_PERIOD 20 //in seconds
+//#define THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS 2 // in degree Celsius
+//===========================================================================
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+// Uncomment the following line to enable CoreXY kinematics
+// #define COREXY
+
+// coarse Endstop Settings
+//#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+
+#ifndef ENDSTOPPULLUPS
+  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
+  // #define ENDSTOPPULLUP_XMAX
+  // #define ENDSTOPPULLUP_YMAX
+   #define ENDSTOPPULLUP_ZMAX  // open pin, inverted
+   #define ENDSTOPPULLUP_XMIN  // open pin, inverted
+   #define ENDSTOPPULLUP_YMIN  // open pin, inverted
+  // #define ENDSTOPPULLUP_ZMIN
+#endif
+
+#ifdef ENDSTOPPULLUPS
+  #define ENDSTOPPULLUP_XMAX
+  #define ENDSTOPPULLUP_YMAX
+  #define ENDSTOPPULLUP_ZMAX
+  #define ENDSTOPPULLUP_XMIN
+  #define ENDSTOPPULLUP_YMIN
+  #define ENDSTOPPULLUP_ZMIN
+#endif
+
+// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
+const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+//#define DISABLE_MAX_ENDSTOPS
+//#define DISABLE_MIN_ENDSTOPS
+
+// Disable max endstops for compatibility with endstop checking routine
+#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
+  #define DISABLE_MAX_ENDSTOPS
+#endif
+
+// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
+#define X_ENABLE_ON 0
+#define Y_ENABLE_ON 0
+#define Z_ENABLE_ON 0
+#define E_ENABLE_ON 0 // For all extruders
+
+// Disables axis when it's not being used.
+#define DISABLE_X false
+#define DISABLE_Y false
+#define DISABLE_Z false
+#define DISABLE_E false // For all extruders
+#define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled
+
+#define INVERT_X_DIR false    // for Mendel set to false, for Orca set to true
+#define INVERT_Y_DIR false    // for Mendel set to true, for Orca set to false
+#define INVERT_Z_DIR true     // for Mendel set to false, for Orca set to true
+#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+
+// ENDSTOP SETTINGS:
+// Sets direction of endstop	s when homing; 1=MAX, -1=MIN
+#define X_HOME_DIR 1
+#define Y_HOME_DIR 1
+#define Z_HOME_DIR -1
+
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
+
+// Travel limits after homing
+#define X_MAX_POS 200
+#define X_MIN_POS 0
+#define Y_MAX_POS 200
+#define Y_MIN_POS 0
+#define Z_MAX_POS 225
+#define Z_MIN_POS MANUAL_Z_HOME_POS
+
+#define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)
+#define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)
+#define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
+//============================= Bed Auto Leveling ===========================
+
+//#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+
+#ifdef ENABLE_AUTO_BED_LEVELING
+
+// There are 2 different ways to pick the X and Y locations to probe:
+
+//  - "grid" mode
+//    Probe every point in a rectangular grid
+//    You must specify the rectangle, and the density of sample points
+//    This mode is preferred because there are more measurements.
+//    It used to be called ACCURATE_BED_LEVELING but "grid" is more descriptive
+
+//  - "3-point" mode
+//    Probe 3 arbitrary points on the bed (that aren't colinear)
+//    You must specify the X & Y coordinates of all 3 points
+
+  #define AUTO_BED_LEVELING_GRID
+  // with AUTO_BED_LEVELING_GRID, the bed is sampled in a
+  // AUTO_BED_LEVELING_GRID_POINTSxAUTO_BED_LEVELING_GRID_POINTS grid
+  // and least squares solution is calculated
+  // Note: this feature occupies 10'206 byte
+  #ifdef AUTO_BED_LEVELING_GRID
+
+    // set the rectangle in which to probe
+    #define LEFT_PROBE_BED_POSITION 15
+    #define RIGHT_PROBE_BED_POSITION 170
+    #define BACK_PROBE_BED_POSITION 180
+    #define FRONT_PROBE_BED_POSITION 20
+
+     // set the number of grid points per dimension
+     // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
+    #define AUTO_BED_LEVELING_GRID_POINTS 2
+
+
+  #else  // not AUTO_BED_LEVELING_GRID
+    // with no grid, just probe 3 arbitrary points.  A simple cross-product
+    // is used to esimate the plane of the print bed
+
+      #define ABL_PROBE_PT_1_X 15
+      #define ABL_PROBE_PT_1_Y 180
+      #define ABL_PROBE_PT_2_X 15
+      #define ABL_PROBE_PT_2_Y 20
+      #define ABL_PROBE_PT_3_X 170
+      #define ABL_PROBE_PT_3_Y 20
+
+  #endif // AUTO_BED_LEVELING_GRID
+
+
+  // these are the offsets to the probe relative to the extruder tip (Hotend - Probe)
+  #define X_PROBE_OFFSET_FROM_EXTRUDER -25
+  #define Y_PROBE_OFFSET_FROM_EXTRUDER -29
+  #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35
+
+  //#define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z before homing (G28) for Probe Clearance.
+                                        // Be sure you have this distance over your Z_MAX_POS in case
+
+  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min
+
+  #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
+  #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
+
+
+  //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk
+  //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
+  // You MUST HAVE the SERVO_ENDSTOPS defined to use here a value higher than zero otherwise your code will not compile.
+
+//  #define PROBE_SERVO_DEACTIVATION_DELAY 300
+
+
+//If you have enabled the Bed Auto Leveling and are using the same Z Probe for Z Homing,
+//it is highly recommended you let this Z_SAFE_HOMING enabled!!!
+
+ // #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
+                          // When defined, it will:
+                          // - Allow Z homing only after X and Y homing AND stepper drivers still enabled
+                          // - If stepper drivers timeout, it will need X and Y homing again before Z homing
+                          // - Position the probe in a defined XY point before Z Homing when homing all axis (G28)
+                          // - Block Z homing only when the probe is outside bed area.
+
+  #ifdef Z_SAFE_HOMING
+
+    #define Z_SAFE_HOMING_X_POINT (X_MAX_LENGTH/2)    // X point for Z homing when homing all axis (G28)
+    #define Z_SAFE_HOMING_Y_POINT (Y_MAX_LENGTH/2)    // Y point for Z homing when homing all axis (G28)
+
+  #endif
+
+#endif // ENABLE_AUTO_BED_LEVELING
+
+
+// The position of the homing switches
+#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
+
+//Manual homing switch locations:
+// For deltabots this means top and center of the Cartesian print volume.
+// For SCARA: Offset between HomingPosition and Bed X=0 / Y=0
+#define MANUAL_X_HOME_POS -22.
+#define MANUAL_Y_HOME_POS -52.
+#define MANUAL_Z_HOME_POS 0.1  // Distance between nozzle and print surface after homing.
+
+
+//// MOVEMENT SETTINGS
+#define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
+#define HOMING_FEEDRATE {40*60, 40*60, 10*60, 0}  // set the homing speeds (mm/min)
+
+// default settings
+
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {103.69,106.65,200/1.25,1000}  // default steps per unit for SCARA
+#define DEFAULT_MAX_FEEDRATE          {300, 300, 30, 25}    // (mm/sec)
+#define DEFAULT_MAX_ACCELERATION      {300,300,20,1000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
+
+#define DEFAULT_ACCELERATION          400    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  2000  // X, Y, Z and E max acceleration in mm/s^2 for retracts
+
+// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
+// The offset has to be X=0, Y=0 for extruder 0 hotend (default extruder).
+// For the other hotends it is their distance from the extruder 0 hotend.
+// #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
+// #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
+
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
+#define DEFAULT_XYJERK                5    // (mm/sec)
+#define DEFAULT_ZJERK                 0.4    // (mm/sec)
+#define DEFAULT_EJERK                 3    // (mm/sec)
+
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
+
+// Custom M code points
+//#define CUSTOM_M_CODES
+#ifdef CUSTOM_M_CODES
+  #define CUSTOM_M_CODE_SET_Z_PROBE_OFFSET 851
+  #define Z_PROBE_OFFSET_RANGE_MIN -15
+  #define Z_PROBE_OFFSET_RANGE_MAX -5
+#endif
+
+
+// EEPROM
+// The microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores parameters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+//define this to enable EEPROM support
+//#define EEPROM_SETTINGS
+//to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
+// please keep turned on if you can.
+#define EEPROM_CHITCHAT
+
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+//LCD and SD support
+//#define ULTRA_LCD  //general LCD support, also 16x2
+//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
+//#define SDSUPPORT // Enable SD Card Support in Hardware Console
+//#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
+//#define SD_CHECK_AND_RETRY // Use CRC checks and retries on the SD communication
+//#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder
+//#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
+//#define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.
+//#define ULTIPANEL  //the UltiPanel as on Thingiverse
+//#define LCD_FEEDBACK_FREQUENCY_HZ 1000	// this is the tone frequency the buzzer plays when on UI feedback. ie Screen Click
+//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100 // the duration the buzzer plays the UI feedback sound. ie Screen Click
+
+// The MaKr3d Makr-Panel with graphic controller and SD support
+// http://reprap.org/wiki/MaKr3d_MaKrPanel
+//#define MAKRPANEL
+
+// The RepRapDiscount Smart Controller (white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
+// The GADGETS3D G3D LCD/SD Controller (blue PCB)
+// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
+//#define G3D_PANEL
+
+// The RepRapDiscount FULL GRAPHIC Smart Controller (quadratic white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
+//
+// ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
+//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+
+// The RepRapWorld REPRAPWORLD_KEYPAD v1.1
+// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
+//#define REPRAPWORLD_KEYPAD
+//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click
+
+// The Elefu RA Board Control Panel
+// http://www.elefu.com/index.php?route=product/product&product_id=53
+// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARUDINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C
+//#define RA_CONTROL_PANEL
+
+//automatic expansion
+#if defined (MAKRPANEL)
+ #define DOGLCD
+ #define SDSUPPORT
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define DEFAULT_LCD_CONTRAST 17
+#endif
+
+#if defined (REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)
+ #define DOGLCD
+ #define U8GLIB_ST7920
+ #define REPRAP_DISCOUNT_SMART_CONTROLLER
+#endif
+
+#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+#endif
+
+#if defined(REPRAPWORLD_KEYPAD)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+#if defined(RA_CONTROL_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define LCD_I2C_TYPE_PCA8574
+ #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+#endif
+
+//I2C PANELS
+
+//#define LCD_I2C_SAINSMART_YWROBOT
+#ifdef LCD_I2C_SAINSMART_YWROBOT
+  // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )
+  // Make sure it is placed in the Arduino libraries directory.
+  #define LCD_I2C_TYPE_PCF8575
+  #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+
+// PANELOLU2 LCD with status LEDs, separate encoder and click inputs
+//#define LCD_I2C_PANELOLU2
+#ifdef LCD_I2C_PANELOLU2
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)
+  // Note: The PANELOLU2 encoder click input can either be directly connected to a pin
+  //       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
+  #define NEWPANEL
+  #define ULTIPANEL
+
+  #ifndef ENCODER_PULSES_PER_STEP
+	#define ENCODER_PULSES_PER_STEP 4
+  #endif
+
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+	#define ENCODER_STEPS_PER_MENU_ITEM 1
+  #endif
+
+
+  #ifdef LCD_USE_I2C_BUZZER
+	#define LCD_FEEDBACK_FREQUENCY_HZ 1000
+	#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
+  #endif
+
+#endif
+
+// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
+//#define LCD_I2C_VIKI
+#ifdef LCD_I2C_VIKI
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // Note: The pause/stop/resume LCD button pin should be connected to the Arduino
+  //       BTN_ENC pin (or set BTN_ENC to -1 if not used)
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+
+// Shift register panels
+// ---------------------
+// 2 wire Non-latching LCD SR from:
+// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+//#define SR_LCD
+#ifdef SR_LCD
+   #define SR_LCD_2W_NL    // Non latching 2 wire shift register
+   //#define NEWPANEL
+#endif
+
+
+#ifdef ULTIPANEL
+//  #define NEWPANEL  //enable this if you have a click-encoder panel
+  #define SDSUPPORT
+  #define ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the DOG graphic display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 4
+  #endif
+#else //no panel but just LCD
+  #ifdef ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 16
+    #define LCD_HEIGHT 2
+  #endif
+  #endif
+#endif
+
+// default LCD contrast for dogm-like LCD displays
+#ifdef DOGLCD
+# ifndef DEFAULT_LCD_CONTRAST
+#  define DEFAULT_LCD_CONTRAST 32
+# endif
+#endif
+
+// Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
+//#define FAST_PWM_FAN
+
+// Temperature status LEDs that display the hotend and bet temperature.
+// If all hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
+// Otherwise the RED led is on. There is 1C hysteresis.
+//#define TEMP_STAT_LEDS
+
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not ass annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
+// M240  Triggers a camera by emulating a Canon RC-1 Remote
+// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
+// #define PHOTOGRAPH_PIN     23
+
+// SF send wrong arc g-codes when using Arc Point as fillet procedure
+//#define SF_ARC_FIX
+
+// Support for the BariCUDA Paste Extruder.
+//#define BARICUDA
+
+//define BlinkM/CyzRgb Support
+//#define BLINKM
+
+/*********************************************************************\
+* R/C SERVO support
+* Sponsored by TrinityLabs, Reworked by codexmas
+**********************************************************************/
+
+// Number of servos
+//
+// If you select a configuration below, this will receive a default value and does not need to be set manually
+// set it manually if you have more servos than extruders and wish to manually control some
+// leaving it undefined or defining as 0 will disable the servo subsystem
+// If unsure, leave commented / disabled
+//
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
+
+// Servo Endstops
+//
+// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.
+// Use M206 command to correct for switch height offset to actual nozzle height. Store that setting with M500.
+//
+//#define SERVO_ENDSTOPS {-1, -1, 0} // Servo index for X, Y, Z. Disable with -1
+//#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 70,0} // X,Y,Z Axis Extend and Retract angles
+
+#include "Configuration_adv.h"
+#include "thermistortables.h"
+
+#endif //__CONFIGURATION_H
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
new file mode 100644
index 0000000..7a01bcc
--- /dev/null
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -0,0 +1,507 @@
+#ifndef CONFIGURATION_ADV_H
+#define CONFIGURATION_ADV_H
+
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
+
+#ifdef BED_LIMIT_SWITCHING
+  #define BED_HYSTERESIS 2 //only disable heating if T>target+BED_HYSTERESIS and enable heating if T>target-BED_HYSTERESIS
+#endif
+#define BED_CHECK_INTERVAL 3000 //ms between checks in bang-bang control
+
+//// Heating sanity check:
+// This waits for the watch period in milliseconds whenever an M104 or M109 increases the target temperature
+// If the temperature has not increased at the end of that period, the target temperature is set to zero.
+// It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
+//  differ by at least 2x WATCH_TEMP_INCREASE
+//#define WATCH_TEMP_PERIOD 40000 //40 seconds
+//#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds
+
+#ifdef PIDTEMP
+  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.
+  // if Kc is chosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE
+  #ifdef PID_ADD_EXTRUSION_RATE
+    #define  DEFAULT_Kc (1) //heating power=Kc*(e_speed)
+  #endif
+#endif
+
+
+//automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.
+//The maximum buffered steps/sec of the extruder motor are called "se".
+//You enter the autotemp mode by a M109 S<mintemp> B<maxtemp> F<factor>
+// the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp
+// you exit the value by any M109 without F*
+// Also, if the temperature is set to a value <mintemp, it is not changed by autotemp.
+// on an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
+#define AUTOTEMP
+#ifdef AUTOTEMP
+  #define AUTOTEMP_OLDWEIGHT 0.98
+#endif
+
+//Show Temperature ADC value
+//The M105 command return, besides traditional information, the ADC value read from temperature sensors.
+//#define SHOW_TEMP_ADC_VALUES
+
+//  extruder run-out prevention.
+//if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
+//#define EXTRUDER_RUNOUT_PREVENT
+#define EXTRUDER_RUNOUT_MINTEMP 180
+#define EXTRUDER_RUNOUT_SECONDS 30.
+#define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
+#define EXTRUDER_RUNOUT_SPEED 180.  //extrusion speed
+#define EXTRUDER_RUNOUT_EXTRUDE 100
+
+//These defines help to calibrate the AD595 sensor in case you get wrong temperature measurements.
+//The measured temperature is defined as "actualTemp = (measuredTemp * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET"
+#define TEMP_SENSOR_AD595_OFFSET 0.0
+#define TEMP_SENSOR_AD595_GAIN   1.0
+
+//This is for controlling a fan to cool down the stepper drivers
+//it will turn on when any driver is enabled
+//and turn off after the set amount of seconds from last driver being disabled again
+#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)
+#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run
+#define CONTROLLERFAN_SPEED 255  // == full speed
+
+// When first starting the main fan, run it at full speed for the
+// given number of milliseconds.  This gets the fan spinning reliably
+// before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)
+//#define FAN_KICKSTART_TIME 100
+
+// Extruder cooling fans
+// Configure fan pin outputs to automatically turn on/off when the associated
+// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
+// Multiple extruders can be assigned to the same pin in which case
+// the fan will turn on when any selected extruder is above the threshold.
+#define EXTRUDER_0_AUTO_FAN_PIN   -1
+#define EXTRUDER_1_AUTO_FAN_PIN   -1
+#define EXTRUDER_2_AUTO_FAN_PIN   -1
+#define EXTRUDER_AUTO_FAN_TEMPERATURE 50
+#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
+
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
+
+
+//// AUTOSET LOCATIONS OF LIMIT SWITCHES
+//// Added by ZetaPhoenix 09-15-2012
+#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations
+  #define X_HOME_POS MANUAL_X_HOME_POS
+  #define Y_HOME_POS MANUAL_Y_HOME_POS
+  #define Z_HOME_POS MANUAL_Z_HOME_POS
+#else //Set min/max homing switch positions based upon homing direction and min/max travel limits
+  //X axis
+  #if X_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * -0.5
+    #else
+      #define X_HOME_POS X_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * 0.5
+    #else
+      #define X_HOME_POS X_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //X_HOME_DIR == -1
+
+  //Y axis
+  #if Y_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * -0.5
+    #else
+      #define Y_HOME_POS Y_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * 0.5
+    #else
+      #define Y_HOME_POS Y_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //Y_HOME_DIR == -1
+
+  // Z axis
+  #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
+    #define Z_HOME_POS Z_MIN_POS
+  #else
+    #define Z_HOME_POS Z_MAX_POS
+  #endif //Z_HOME_DIR == -1
+#endif //End auto min/max positions
+//END AUTOSET LOCATIONS OF LIMIT SWITCHES -ZP
+
+
+//#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
+
+// A single Z stepper driver is usually used to drive 2 stepper motors.
+// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
+// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
+// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
+// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+//#define Z_DUAL_STEPPER_DRIVERS
+
+#ifdef Z_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+// Same again but for Y Axis.
+//#define Y_DUAL_STEPPER_DRIVERS
+
+// Define if the two Y drives need to rotate in opposite directions
+#define INVERT_Y2_VS_Y_DIR true
+
+#ifdef Y_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+#if defined (Z_DUAL_STEPPER_DRIVERS) && defined (Y_DUAL_STEPPER_DRIVERS)
+  #error "You cannot have dual drivers for both Y and Z"
+#endif
+
+// Enable this for dual x-carriage printers.
+// A dual x-carriage design has the advantage that the inactive extruder can be parked which
+// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
+// allowing faster printing speeds.
+//#define DUAL_X_CARRIAGE
+#ifdef DUAL_X_CARRIAGE
+// Configuration for second X-carriage
+// Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
+// the second x-carriage always homes to the maximum endstop.
+#define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
+#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed
+#define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software
+    // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
+    // without modifying the firmware (through the "M218 T1 X???" command).
+    // Remember: you should set the second extruder x-offset to 0 in your slicer.
+
+// Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)
+#define X2_ENABLE_PIN 29
+#define X2_STEP_PIN 25
+#define X2_DIR_PIN 23
+
+// There are a few selectable movement modes for dual x-carriages using M605 S<mode>
+//    Mode 0: Full control. The slicer has full control over both x-carriages and can achieve optimal travel results
+//                           as long as it supports dual x-carriages. (M605 S0)
+//    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
+//                           that additional slicer support is not required. (M605 S1)
+//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all
+//                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
+//                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
+
+// This is the default power-up mode which can be later using M605.
+#define DEFAULT_DUAL_X_CARRIAGE_MODE 0
+
+// As the x-carriages are independent we can now account for any relative Z offset
+#define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0
+
+// Default settings in "Auto-park Mode"
+#define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
+#define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
+
+// Default x offset in duplication mode (typically set to half print bed width)
+#define DEFAULT_DUPLICATION_X_OFFSET 100
+
+#endif //DUAL_X_CARRIAGE
+
+//homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
+#define X_HOME_RETRACT_MM 3
+#define Y_HOME_RETRACT_MM 3
+#define Z_HOME_RETRACT_MM 3
+//#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
+#ifdef SCARA
+	#define QUICK_HOME //SCARA needs Quickhome
+#endif
+
+#define AXIS_RELATIVE_MODES {false, false, false, false}
+
+#define MAX_STEP_FREQUENCY 40000 // Max step frequency for Ultimaker (5000 pps / half step)
+
+//By default pololu step drivers require an active high signal. However, some high power drivers require an active low signal as step.
+#define INVERT_X_STEP_PIN false
+#define INVERT_Y_STEP_PIN false
+#define INVERT_Z_STEP_PIN false
+#define INVERT_E_STEP_PIN false
+
+//default stepper release if idle
+#define DEFAULT_STEPPER_DEACTIVE_TIME 240
+
+#define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate
+#define DEFAULT_MINTRAVELFEEDRATE     0.0
+
+// Feedrates for manual moves along X, Y, Z, E from panel
+#ifdef ULTIPANEL
+#define MANUAL_FEEDRATE {50*60, 50*60, 10*60, 60}  // set the speeds for manual moves (mm/min)
+#endif
+
+//Comment to disable setting feedrate multiplier via encoder
+#ifdef ULTIPANEL
+    #define ULTIPANEL_FEEDMULTIPLY
+#endif
+
+// minimum time in microseconds that a movement needs to take if the buffer is emptied.
+#define DEFAULT_MINSEGMENTTIME        20000
+
+// If defined the movements slow down when the look ahead buffer is only half full
+//#define SLOWDOWN
+#ifdef SCARA
+ #undef SLOWDOWN
+#endif
+// Frequency limit
+// See nophead's blog for more info
+// Not working O
+//#define XY_FREQUENCY_LIMIT  15
+
+// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end
+// of the buffer and all stops. This should not be much greater than zero and should only be changed
+// if unwanted behavior is observed on a user's machine when running at very slow speeds.
+#define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)
+
+// MS1 MS2 Stepper Driver Microstepping mode table
+#define MICROSTEP1 LOW,LOW
+#define MICROSTEP2 HIGH,LOW
+#define MICROSTEP4 LOW,HIGH
+#define MICROSTEP8 HIGH,HIGH
+#define MICROSTEP16 HIGH,HIGH
+
+// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.
+#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]
+
+// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
+#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
+
+// uncomment to enable an I2C based DIGIPOT like on the Azteeg X3 Pro
+//#define DIGIPOT_I2C
+// Number of channels available for I2C digipot, For Azteeg X3 Pro we have 8
+#define DIGIPOT_I2C_NUM_CHANNELS 8
+// actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
+#define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}
+
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
+
+//#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
+#define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
+
+#define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
+#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
+
+#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the file system block order.
+// if a file is deleted, it frees a block. hence, the order is not purely chronological. To still have auto0.g accessible, there is again the option to do that.
+// using:
+//#define MENU_ADDAUTOSTART
+
+// The hardware watchdog should reset the microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
+//#define USE_WATCHDOG
+
+#ifdef USE_WATCHDOG
+// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.
+// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.
+//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
+//#define WATCHDOG_RESET_MANUAL
+#endif
+
+// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
+//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+
+// Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process
+// it can e.g. be used to change z-positions in the print startup phase in real-time
+// does not respect endstops!
+//#define BABYSTEPPING
+#ifdef BABYSTEPPING
+  #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
+  #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
+  #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
+
+  #ifdef COREXY
+    #error BABYSTEPPING not implemented for COREXY yet.
+  #endif
+
+  #ifdef DELTA
+    #ifdef BABYSTEP_XY
+      #error BABYSTEPPING only implemented for Z axis on deltabots.
+    #endif
+  #endif
+  
+  #ifdef SCARA
+    #error BABYSTEPPING not implemented for SCARA yet.
+  #endif
+  
+#endif
+
+// extruder advance constant (s2/mm3)
+//
+// advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2
+//
+// Hooke's law says:		force = k * distance
+// Bernoulli's principle says:	v ^ 2 / 2 + g . h + pressure / density = constant
+// so: v ^ 2 is proportional to number of steps we advance the extruder
+#define ADVANCE
+
+#ifdef ADVANCE
+  #define EXTRUDER_ADVANCE_K .0
+
+  #define D_FILAMENT 1.75
+  #define STEPS_MM_E 1000
+  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+
+#endif // ADVANCE
+
+// Arc interpretation settings:
+#define MM_PER_ARC_SEGMENT 1
+#define N_ARC_CORRECTION 25
+
+const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
+
+// If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
+// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT
+// in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
+// be commented out otherwise
+#define SDCARDDETECTINVERTED
+
+#ifdef ULTIPANEL
+ #undef SDCARDDETECTINVERTED
+#endif
+
+// Power Signal Control Definitions
+// By default use ATX definition
+#ifndef POWER_SUPPLY
+  #define POWER_SUPPLY 1
+#endif
+// 1 = ATX
+#if (POWER_SUPPLY == 1)
+  #define PS_ON_AWAKE  LOW
+  #define PS_ON_ASLEEP HIGH
+#endif
+// 2 = X-Box 360 203W
+#if (POWER_SUPPLY == 2)
+  #define PS_ON_AWAKE  HIGH
+  #define PS_ON_ASLEEP LOW
+#endif
+
+// Control heater 0 and heater 1 in parallel.
+//#define HEATERS_PARALLEL
+
+//===========================================================================
+//=============================Buffers           ============================
+//===========================================================================
+
+// The number of linear motions that can be in the plan at any give time.
+// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
+#if defined SDSUPPORT
+  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+#else
+  #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
+#endif
+
+
+//The ASCII buffer for receiving from the serial:
+#define MAX_CMD_SIZE 96
+#define BUFSIZE 4
+
+
+// Firmware based and LCD controlled retract
+// M207 and M208 can be used to define parameters for the retraction.
+// The retraction can be called by the slicer using G10 and G11
+// until then, intended retractions can be detected by moves that only extrude and the direction.
+// the moves are than replaced by the firmware controlled ones.
+
+// #define FWRETRACT  //ONLY PARTIALLY TESTED
+#ifdef FWRETRACT
+  #define MIN_RETRACT 0.1                //minimum extruded mm to accept a automatic gcode retraction attempt
+  #define RETRACT_LENGTH 3               //default retract length (positive mm)
+  #define RETRACT_FEEDRATE 35            //default feedrate for retracting (mm/s)
+  #define RETRACT_ZLIFT 0                //default retract Z-lift
+  #define RETRACT_RECOVER_LENGTH 0       //default additional recover length (mm, added to retract length when recovering)
+  #define RETRACT_RECOVER_FEEDRATE 8     //default feedrate for recovering from retraction (mm/s)
+#endif
+
+//adds support for experimental filament exchange support M600; requires display
+#ifdef ULTIPANEL
+  #define FILAMENTCHANGEENABLE
+  #ifdef FILAMENTCHANGEENABLE
+    #define FILAMENTCHANGE_XPOS 3
+    #define FILAMENTCHANGE_YPOS 3
+    #define FILAMENTCHANGE_ZADD 10
+    #define FILAMENTCHANGE_FIRSTRETRACT -2
+    #define FILAMENTCHANGE_FINALRETRACT -100
+  #endif
+#endif
+
+#ifdef FILAMENTCHANGEENABLE
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
+  #endif
+#endif
+
+//===========================================================================
+//=============================  Define Defines  ============================
+//===========================================================================
+#if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
+  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+#endif
+
+#if EXTRUDERS > 1 && defined HEATERS_PARALLEL
+  #error "You cannot use HEATERS_PARALLEL if EXTRUDERS > 1"
+#endif
+
+#if TEMP_SENSOR_0 > 0
+  #define THERMISTORHEATER_0 TEMP_SENSOR_0
+  #define HEATER_0_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_1 > 0
+  #define THERMISTORHEATER_1 TEMP_SENSOR_1
+  #define HEATER_1_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_2 > 0
+  #define THERMISTORHEATER_2 TEMP_SENSOR_2
+  #define HEATER_2_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_BED > 0
+  #define THERMISTORBED TEMP_SENSOR_BED
+  #define BED_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_0 == -1
+  #define HEATER_0_USES_AD595
+#endif
+#if TEMP_SENSOR_1 == -1
+  #define HEATER_1_USES_AD595
+#endif
+#if TEMP_SENSOR_2 == -1
+  #define HEATER_2_USES_AD595
+#endif
+#if TEMP_SENSOR_BED == -1
+  #define BED_USES_AD595
+#endif
+#if TEMP_SENSOR_0 == -2
+  #define HEATER_0_USES_MAX6675
+#endif
+#if TEMP_SENSOR_0 == 0
+  #undef HEATER_0_MINTEMP
+  #undef HEATER_0_MAXTEMP
+#endif
+#if TEMP_SENSOR_1 == 0
+  #undef HEATER_1_MINTEMP
+  #undef HEATER_1_MAXTEMP
+#endif
+#if TEMP_SENSOR_2 == 0
+  #undef HEATER_2_MINTEMP
+  #undef HEATER_2_MAXTEMP
+#endif
+#if TEMP_SENSOR_BED == 0
+  #undef BED_MINTEMP
+  #undef BED_MAXTEMP
+#endif
+
+
+#endif //__CONFIGURATION_ADV_H
diff --git a/Marlin/language.h b/Marlin/language.h
index 8522018..54ca5bc 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -67,6 +67,81 @@
 #define MSG_MARLIN "Marlin"
 
 
+// Serial Console Messages (do not translate those!)
+
+#define MSG_Enqueing "enqueing \""
+#define MSG_POWERUP "PowerUp"
+#define MSG_EXTERNAL_RESET " External Reset"
+#define MSG_BROWNOUT_RESET " Brown out Reset"
+#define MSG_WATCHDOG_RESET " Watchdog Reset"
+#define MSG_SOFTWARE_RESET " Software Reset"
+#define MSG_AUTHOR " | Author: "
+#define MSG_CONFIGURATION_VER " Last Updated: "
+#define MSG_FREE_MEMORY " Free Memory: "
+#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+#define MSG_OK "ok"
+#define MSG_FILE_SAVED "Done saving file."
+#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
+#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
+#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
+#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
+#define MSG_FILE_PRINTED "Done printing file"
+#define MSG_BEGIN_FILE_LIST "Begin file list"
+#define MSG_END_FILE_LIST "End file list"
+#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
+#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+#define MSG_M200_INVALID_EXTRUDER "M200 Invalid extruder "
+#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
+#define MSG_M221_INVALID_EXTRUDER "M221 Invalid extruder "
+#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
+#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
+#define MSG_HEATING "Heating..."
+#define MSG_HEATING_COMPLETE "Heating done."
+#define MSG_BED_HEATING "Bed Heating."
+#define MSG_BED_DONE "Bed done."
+#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
+#define MSG_COUNT_X " Count X: "
+#define MSG_ERR_KILLED "Printer halted. kill() called!"
+#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
+#define MSG_RESEND "Resend: "
+#define MSG_UNKNOWN_COMMAND "Unknown command: \""
+#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
+#define MSG_INVALID_EXTRUDER "Invalid extruder"
+#define MSG_X_MIN "x_min: "
+#define MSG_X_MAX "x_max: "
+#define MSG_Y_MIN "y_min: "
+#define MSG_Y_MAX "y_max: "
+#define MSG_Z_MIN "z_min: "
+#define MSG_Z_MAX "z_max: "
+#define MSG_M119_REPORT "Reporting endstop status"
+#define MSG_ENDSTOP_HIT "TRIGGERED"
+#define MSG_ENDSTOP_OPEN "open"
+#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
+#define MSG_SD_INIT_FAIL "SD init fail"
+#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
+#define MSG_SD_OPENROOT_FAIL "openRoot failed"
+#define MSG_SD_CARD_OK "SD card ok"
+#define MSG_SD_WORKDIR_FAIL "workDir open failed"
+#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
+#define MSG_SD_FILE_OPENED "File opened: "
+#define MSG_SD_SIZE " Size: "
+#define MSG_SD_FILE_SELECTED "File selected"
+#define MSG_SD_WRITE_TO_FILE "Writing to file: "
+#define MSG_SD_PRINTING_BYTE "SD printing byte "
+#define MSG_SD_NOT_PRINTING "Not SD printing"
+#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
+#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
+
+#define MSG_STEPPER_TOO_HIGH "Steprate too high: "
+#define MSG_ENDSTOPS_HIT "endstops hit: "
+#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
+#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+#define MSG_BABYSTEPPING_X "Babystepping X"
+#define MSG_BABYSTEPPING_Y "Babystepping Y"
+#define MSG_BABYSTEPPING_Z "Babystepping Z"
+#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
 
 #if LANGUAGE_CHOICE == 1
 
@@ -189,82 +264,6 @@
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Count X: "
-	#define MSG_ERR_KILLED "Printer halted. kill() called!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
-	#define MSG_RESEND "Resend: "
-	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened: "
-	#define MSG_SD_SIZE " Size: "
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate too high: "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 
@@ -392,82 +391,6 @@
 	#define MSG_ENDSTOP_ABORT "Blad wyl. kranc."
 	#define MSG_CONTRAST "Kontrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "Kolejkowanie \""
-	#define MSG_POWERUP "Zasilanie wlaczone"
-	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
-	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
-	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
-	#define MSG_SOFTWARE_RESET " Reset (programowy)"
-	#define MSG_AUTHOR " | Autor: "
-	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
-	#define MSG_FREE_MEMORY " Wolna pamiec: "
-	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
-	#define MSG_OK "OK"
-	#define MSG_FILE_SAVED "Plik zapisany."
-	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
-	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
-	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
-	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
-	#define MSG_END_FILE_LIST "Koniec listy plikow"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Niepoprawny ekstruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Niepoprawny ekstruder "
-	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
-	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
-	#define MSG_HEATING "Nagrzewanie ekstrudera..."
-	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
-	#define MSG_BED_HEATING "Nagrzewanie loza..."
-	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Licznik X: "
-	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
-	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
-	#define MSG_RESEND "Wyslij ponownie: "
-	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
-	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
-	#define MSG_ENDSTOP_HIT "Wyzwolony"
-	#define MSG_ENDSTOP_OPEN "Otwarty"
-	#define MSG_HOTEND_OFFSET "Offsety dysz:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
-	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
-	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
-	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
-	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
-	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
-	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
-	#define MSG_SD_FILE_OPENED "Otwarto plik:"
-	#define MSG_SD_SIZE " Rozmiar:"
-	#define MSG_SD_FILE_SELECTED "Wybrano plik"
-	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
-	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
-	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Wystapil blad podczas zapisu do pliku"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
-
-	#define MSG_STEPPER_TOO_HIGH "Za duza czestotliwosc krokow: "
-	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
-	#define MSG_BABYSTEPPING_X "Babystepping w osi X"
-	#define MSG_BABYSTEPPING_Y "Babystepping w osi Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping w osi Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 
@@ -595,82 +518,6 @@
 	#define MSG_ENDSTOP_ABORT "Butee abandon"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "Mise en tampon \""
-	#define MSG_POWERUP "Allumage"
-	#define MSG_EXTERNAL_RESET " RAZ Externe"
-	#define MSG_BROWNOUT_RESET " RAZ defaut alim."
-	#define MSG_WATCHDOG_RESET " RAZ Watchdog"
-	#define MSG_SOFTWARE_RESET " RAZ logicielle"
-	#define MSG_AUTHOR " | Auteur: "
-	#define MSG_CONFIGURATION_VER " Derniere MaJ: "
-	#define MSG_FREE_MEMORY " Memoire libre: "
-	#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Fichier enregistre."
-	#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
-	#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
-	#define MSG_FILE_PRINTED "Impression terminee"
-	#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
-	#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
-	#define MSG_M200_INVALID_EXTRUDER "M200 Extruder invalide"
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
-	#define MSG_M221_INVALID_EXTRUDER "M221 Extruder invalide"
-	#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
-	#define MSG_HEATING "En chauffe..."
-	#define MSG_HEATING_COMPLETE "Chauffe terminee."
-	#define MSG_BED_HEATING "Chauffe du lit."
-	#define MSG_BED_DONE "Chauffe du lit terminee."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Compteur X: "
-	#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
-	#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
-	#define MSG_RESEND "Renvoie: "
-	#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
-	#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
-	#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Affichage du status des fin de course"
-	#define MSG_ENDSTOP_HIT "DECLENCHE"
-	#define MSG_ENDSTOP_OPEN "OUVERT"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
-	#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
-	#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
-	#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
-	#define MSG_SD_CARD_OK "Carte SD Ok"
-	#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
-	#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
-	#define MSG_SD_FILE_OPENED "Fichier ouvert: "
-	#define MSG_SD_SIZE " Taille: "
-	#define MSG_SD_FILE_SELECTED "Fichier selectionne"
-	#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
-	#define MSG_SD_PRINTING_BYTE "Octet impression SD "
-	#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate trop eleve: "
-	#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 
@@ -799,82 +646,6 @@
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Count X:"
-	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"
-	#define MSG_RESEND "Resend:"
-	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate too high : "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 
@@ -1008,81 +779,6 @@
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "En cola \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Externo"
-	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
-	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
-	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_AUTHOR " | Autor: "
-	#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
-	#define MSG_FREE_MEMORY " Memoria libre: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Guardado."
-	#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"
-	#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"
-	#define MSG_FILE_PRINTED "Impresion terminada"
-	#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"
-	#define MSG_END_FILE_LIST "Fin de la lista de archivos"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor Invalido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Extrusor Invalido "
-	#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
-	#define MSG_HEATING "Calentando..."
-	#define MSG_HEATING_COMPLETE "Calentamiento Hecho."
-	#define MSG_BED_HEATING "Calentando la base."
-	#define MSG_BED_DONE "Base Caliente."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Cuenta X:"
-	#define MSG_ERR_KILLED "¡¡Impresora Parada con kill()!!"
-	#define MSG_ERR_STOPPED "¡Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela despues de continuar)"
-	#define MSG_RESEND "Reenviar:"
-	#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
-	#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Comprobando fines de carrera."
-	#define MSG_ENDSTOP_HIT "PULSADO"
-	#define MSG_ENDSTOP_OPEN "abierto"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-	#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
-	#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
-	#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
-	#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"
-	#define MSG_SD_CARD_OK "Tarjeta SD OK"
-	#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"
-	#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "
-	#define MSG_SD_FILE_OPENED "Archivo abierto:"
-	#define MSG_SD_SIZE " Tamaño:"
-	#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"
-	#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "
-	#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
-	#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
-	#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate demasiado alto : "
-	#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 #if LANGUAGE_CHOICE == 6
@@ -1208,80 +904,6 @@
 	#define MSG_ENDSTOP_ABORT 					"Endstop abort"
 	#define MSG_CONTRAST 						"Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing						"Запланировано \""
-	#define MSG_POWERUP							"Включение питания"
-	#define MSG_EXTERNAL_RESET					" Внешний сброс"
-	#define MSG_BROWNOUT_RESET					" Brown out сброс"
-	#define MSG_WATCHDOG_RESET					" Watchdog сброс"
-	#define MSG_SOFTWARE_RESET					" программный сброс"
-	#define MSG_AUTHOR							" | Автор: "
-	#define MSG_CONFIGURATION_VER				" Последнее обновление: "
-	#define MSG_FREE_MEMORY						" Памяти свободно: "
-	#define MSG_PLANNER_BUFFER_BYTES			"  Буффер очереди команд Bytes: "
-	#define MSG_OK								"ok"
-	#define MSG_FILE_SAVED						"Файл записан."
-	#define MSG_ERR_LINE_NO						"Номен строки это не последняя строка+1, последняя строка:"
-	#define MSG_ERR_CHECKSUM_MISMATCH			"контрольная сумма не совпадает, последняя строка:"
-	#define MSG_ERR_NO_CHECKSUM					"нет контрольной суммы для строки, последняя строка:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"нет строки для контрольной суммы, последняя строка:"
-	#define MSG_FILE_PRINTED					"Печать файла завершена"
-	#define MSG_BEGIN_FILE_LIST					"Список файлов"
-	#define MSG_END_FILE_LIST					"Конец списка файлов"
-	#define MSG_M104_INVALID_EXTRUDER			"M104 ошибка экструдера "
-	#define MSG_M105_INVALID_EXTRUDER			"M105 ошибка экструдера "
-	#define MSG_M200_INVALID_EXTRUDER			"M200 ошибка экструдера "
-	#define MSG_M218_INVALID_EXTRUDER			"M218 ошибка экструдера "
-	#define MSG_M221_INVALID_EXTRUDER			"M221 ошибка экструдера "
-	#define MSG_ERR_NO_THERMISTORS				"Нет термистра - нет температуры"
-	#define MSG_M109_INVALID_EXTRUDER			"M109 ошибка экструдера "
-	#define MSG_HEATING							"Нагрев...  "
-	#define MSG_HEATING_COMPLETE				"Наргето.    "
-	#define MSG_BED_HEATING						"Нагрев стола...     "
-	#define MSG_BED_DONE						"Стол нагрет.        "
-	#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X							" Count X:"
-	#define MSG_ERR_KILLED						"Принтер остановлен. вызов kill() !!"
-	#define MSG_ERR_STOPPED						"Ошибка принтера, останов. Устраните неисправность и используйте M999 для перезагрузки!. (Температура недоступна. Проверьте датчики)"
-	#define MSG_RESEND							"Переотправка:"
-	#define MSG_UNKNOWN_COMMAND					"Неизвестная команда:\""
-	#define MSG_ACTIVE_EXTRUDER					"Активный экструдер: "
-	#define MSG_INVALID_EXTRUDER				"Ошибка экструдера"
-	#define MSG_X_MIN							"x_min:"
-	#define MSG_X_MAX							"x_max:"
-	#define MSG_Y_MIN							"y_min:"
-	#define MSG_Y_MAX							"y_max:"
-	#define MSG_Z_MIN							"z_min:"
-	#define MSG_Z_MAX							"z_max:"
-	#define MSG_M119_REPORT						"Статус концевиков"
-	#define MSG_ENDSTOP_HIT						"Срабатывание концевика"
-	#define MSG_ENDSTOP_OPEN					"Концевик освобожден"
-	#define MSG_HOTEND_OFFSET					"Hotend offsets:"
-	#define MSG_SD_CANT_OPEN_SUBDIR				"Не открыть папку"
-	#define MSG_SD_INIT_FAIL					"Ошибка инициализации SD"
-	#define MSG_SD_VOL_INIT_FAIL				"Ошибка инициализации раздела"
-	#define MSG_SD_OPENROOT_FAIL				"Не прочесть содержимое корня"
-	#define MSG_SD_CARD_OK						"SD карта в порядке"
-	#define MSG_SD_WORKDIR_FAIL					"не открыть рабочую папку"
-	#define MSG_SD_OPEN_FILE_FAIL				"Ошибка чтения, файл: "
-	#define MSG_SD_FILE_OPENED					"Файл открыт:"
-	#define MSG_SD_SIZE							" Размер:"
-	#define MSG_SD_FILE_SELECTED				"Файл выбран"
-	#define MSG_SD_WRITE_TO_FILE				"Запись в файл: "
-	#define MSG_SD_PRINTING_BYTE				"SD печать byte "
-	#define MSG_SD_NOT_PRINTING					"нет SD печати"
-	#define MSG_SD_ERR_WRITE_TO_FILE			"ошибка записи в файл"
-	#define MSG_SD_CANT_ENTER_SUBDIR			"Не зайти в папку:"
-	#define MSG_STEPPER_TOO_HIGH				"Частота шагов очень высока : "
-	#define MSG_ENDSTOPS_HIT					"концевик сработал: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
-	#define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 
@@ -1407,82 +1029,6 @@
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing             "accodamento \""
-	#define MSG_POWERUP              "Accensione"
-	#define MSG_EXTERNAL_RESET       " Reset Esterno"
-	#define MSG_BROWNOUT_RESET       " Brown out Reset"
-	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET       " Software Reset"
-	#define MSG_AUTHOR               " | Autore: "
-	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
-	#define MSG_FREE_MEMORY          " Memoria Libera: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK                   "ok"
-	#define MSG_FILE_SAVED           "File Salvato."
-	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "
-	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "
-	#define MSG_FILE_PRINTED         "File stampato"
-	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
-	#define MSG_END_FILE_LIST        "Fine Lista File"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Estrusore non valido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Estrusore non valido "
-	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
-	#define MSG_HEATING              "Riscaldamento..."
-	#define MSG_HEATING_COMPLETE     "Stampante Calda."
-	#define MSG_BED_HEATING          "Riscaldamento Piatto."
-	#define MSG_BED_DONE             "Piatto Pronto."
-	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X              " Calcola X: "
-	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
-	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
-	#define MSG_RESEND               "Reinviato:"
-	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""
-	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
-	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
-	#define MSG_X_MIN                "x_min: "
-	#define MSG_X_MAX                "x_max: "
-	#define MSG_Y_MIN                "y_min: "
-	#define MSG_Y_MAX                "y_max: "
-	#define MSG_Z_MIN                "z_min: "
-	#define MSG_Z_MAX                "z_max: "
-	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
-	#define MSG_ENDSTOP_HIT          "INNESCATO"
-	#define MSG_ENDSTOP_OPEN         "aperto"
-	#define MSG_HOTEND_OFFSET        "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
-	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
-	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
-	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
-	#define MSG_SD_CARD_OK           "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
-	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
-	#define MSG_SD_FILE_OPENED       "File aperto: "
-	#define MSG_SD_SIZE              " Dimensione: "
-	#define MSG_SD_FILE_SELECTED     "File selezionato"
-	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
-	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
-	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
-
-	#define MSG_STEPPER_TOO_HIGH     "Steprate troppo alto: "
-	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
-
 #endif
 
 
@@ -1614,82 +1160,6 @@
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Externo"
-	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
-	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
-	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
-	#define MSG_FREE_MEMORY " memoria Livre: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Guardado."
-	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
-	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
-	#define MSG_FILE_PRINTED "Impressao terminada"
-	#define MSG_BEGIN_FILE_LIST "Começo da lista de arquivos"
-	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor inválido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor inválido "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor inválido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor inválido "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Extrusor inválido "
-	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor inválido "
-	#define MSG_HEATING "Aquecendo..."
-	#define MSG_HEATING_COMPLETE "Aquecido."
-	#define MSG_BED_HEATING "Aquecendo a Base."
-	#define MSG_BED_DONE "Base quente."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Conta X:"
-	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
-	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomeçar!. (Temperatura reiniciada. Ajuste antes de recomeçar)"
-	#define MSG_RESEND "Reenviar:"
-	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
-	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Relatando estado do ponto final"
-	#define MSG_ENDSTOP_HIT "PULSADO"
-	#define MSG_ENDSTOP_OPEN "Aberto"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
-	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
-	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
-	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
-	#define MSG_SD_CARD_OK "cartao SD ok"
-	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
-	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
-	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
-	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
-	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
-	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate muito alto : "
-	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
-
 #endif
 
 
@@ -1815,84 +1285,6 @@
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "jonoon \""
-	#define MSG_POWERUP "Kaynnistys"
-	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"
-	#define MSG_BROWNOUT_RESET " Alajannite Reset"
-	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
-	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
-	#define MSG_FREE_MEMORY " Vapaata muistia: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Tiedosto tallennettu."
-	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "
-	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "
-	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"
-	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"
-	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Virheellinen suutin "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Virheellinen suutin "
-	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
-	#define MSG_HEATING "Lammitan..."
-	#define MSG_HEATING_COMPLETE "Lammitys valmis."
-	#define MSG_BED_HEATING "Alusta lampiaa."
-	#define MSG_BED_DONE "Alusta valmis."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Laskuri X: "
-	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"
-	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"
-	#define MSG_RESEND "Uudelleenlahetys: "
-	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "
-	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"
-	#define MSG_ENDSTOP_HIT "AKTIIVISENA"
-	#define MSG_ENDSTOP_OPEN "avoinna"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"
-	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"
-	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"
-	#define MSG_SD_CARD_OK "SD kortti ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"
-	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "
-	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "
-	#define MSG_SD_SIZE " Koko: "
-	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"
-	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "
-	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "
-	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"
-	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
-
-	#define MSG_STEPPER_TOO_HIGH "Askellustaajuus liian suuri: "
-	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_ENDSTOP_ABORT "Endstop abort"
-	#define MSG_CONTRAST "Kontrasti"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Virhe valikon rakenteessa"
-
 #endif
 
 #if LANGUAGE_CHOICE == 10
@@ -2025,81 +1417,6 @@
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 	#define MSG_CONTRAST "Contrast"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "En coda \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Externo"
-	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
-	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
-	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_AUTHOR " | Autor: "
-	#define MSG_CONFIGURATION_VER " Zaguer esvielle: "
-	#define MSG_FREE_MEMORY " Memoria libre: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Guardau."
-	#define MSG_ERR_LINE_NO "O Numero de Linea no ye igual a l'Ultimo Numero de Linea+1, Ultima Linea:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "o checksum no coincide, Ultima Linea:"
-	#define MSG_ERR_NO_CHECKSUM "No se podió trobar o Checksum con o numero de linea, Ultima Linea:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se trobo o Numero de Linea con o Checksum, Ultima Linea:"
-	#define MSG_FILE_PRINTED "Impresion rematada"
-	#define MSG_BEGIN_FILE_LIST "Prencipio d'a lista de fichero"
-	#define MSG_END_FILE_LIST "Fin d'a lista de fichero"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor Invalido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Extrusor Invalido "
-	#define MSG_ERR_NO_THERMISTORS "No i hai termistores - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
-	#define MSG_HEATING "Calentando..."
-	#define MSG_HEATING_COMPLETE "Calentamiento Feito."
-	#define MSG_BED_HEATING "Calentando la base."
-	#define MSG_BED_DONE "Base Calient."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Cuenta X:"
-	#define MSG_ERR_KILLED "Impresora Aturada con kill()!!"
-	#define MSG_ERR_STOPPED "Impresora aturada por errors. Apanye a error y use M999 Ta reiniciar!. (a temperatura se reestablece. Ajustela antes de continar)"
-	#define MSG_RESEND "Reninviar:"
-	#define MSG_UNKNOWN_COMMAND "Comando Desconoixiu:\""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
-	#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Comprobando fins de corrida."
-	#define MSG_ENDSTOP_HIT "PULSAU"
-	#define MSG_ENDSTOP_OPEN "ubierto"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-	#define MSG_SD_CANT_OPEN_SUBDIR "No se podió ubrir a subcarpeta."
-	#define MSG_SD_INIT_FAIL "Fallo en encetar a SD"
-	#define MSG_SD_VOL_INIT_FAIL "Fallo en amontar o volumen"
-	#define MSG_SD_OPENROOT_FAIL "Fallo en ubrir a carpeta raiz"
-	#define MSG_SD_CARD_OK "Tarcheta SD OK"
-	#define MSG_SD_WORKDIR_FAIL "Fallo en ubrir a carpeta de treballo"
-	#define MSG_SD_OPEN_FILE_FAIL "Error en ubrir, Fichero: "
-	#define MSG_SD_FILE_OPENED "Fichero ubierto:"
-	#define MSG_SD_SIZE " Grandaria:"
-	#define MSG_SD_FILE_SELECTED "Fichero Seleccionau"
-	#define MSG_SD_WRITE_TO_FILE "Escribindo en o fichero: "
-	#define MSG_SD_PRINTING_BYTE "SD imprentando o byte "
-	#define MSG_SD_NOT_PRINTING "No se ye imprentando con SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Error en escribir en o fichero"
-	#define MSG_SD_CANT_ENTER_SUBDIR "No se puede ubrir a carpeta:"
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate masiau alto : "
-	#define MSG_ENDSTOPS_HIT "S'ha tocau a fin de carril: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria privada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion masiau larga privada"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error in menu structure"
-
 #endif
 
 #if LANGUAGE_CHOICE == 11 //Dutch
@@ -2223,82 +1540,6 @@
 	#define MSG_BABYSTEP_Z "Babystap Z"
 	#define MSG_ENDSTOP_ABORT "Endstop afbr."
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "Opstarten"
-	#define MSG_EXTERNAL_RESET " Externe Reset"
-	#define MSG_BROWNOUT_RESET " Lage voedingsspanning Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_AUTHOR " | Auteur: "
-	#define MSG_CONFIGURATION_VER " Laatst bijgewerkt: "
-	#define MSG_FREE_MEMORY " Vrij Geheugen: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Bestand opslaan voltooid."
-	#define MSG_ERR_LINE_NO "Regelnummer is niet het laatste regelnummer+1, Laatste regel: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "Checksum fout, Laatste regel: "
-	#define MSG_ERR_NO_CHECKSUM "Regel zonder checksum, Laatste regel: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Geen regelnummer met checksum, Laatste regel: "
-	#define MSG_FILE_PRINTED "Bestand afdrukken klaar"
-	#define MSG_BEGIN_FILE_LIST "Begin bestandslijst"
-	#define MSG_END_FILE_LIST "Einde bestandslijst"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Ongeldige extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Ongeldige extruder "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Ongeldige extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Ongeldige extruder "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Ongeldige extruder "
-	#define MSG_ERR_NO_THERMISTORS "Geen thermistors - geen temperatuur"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Ongeldige extruder "
-	#define MSG_HEATING "Opwarmen..."
-	#define MSG_HEATING_COMPLETE "Opwarmen klaar."
-	#define MSG_BED_HEATING "Bed opwarmen."
-	#define MSG_BED_DONE "Bed klaar."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup voor gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Aantal X: "
-	#define MSG_ERR_KILLED "Printer stopgezet. kill() aangeroepen!"
-	#define MSG_ERR_STOPPED "Printer gestopt vanwege fouten. Los de fout op en gebruik M999 om opnieuw te starten. (Temperatuur is gereset, stel deze opnieuw in na herstart)"
-	#define MSG_RESEND "Opnieuw sturen: "
-	#define MSG_UNKNOWN_COMMAND "Onbekend commando: \""
-	#define MSG_ACTIVE_EXTRUDER "Actieve Extruder: "
-	#define MSG_INVALID_EXTRUDER "Ongeldige extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Eindstop statusrapportage:"
-	#define MSG_ENDSTOP_HIT "GERAAKT"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend afwijking:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Kan subdirectory niet openen"
-	#define MSG_SD_INIT_FAIL "SD initialiseren mislukt"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init mislukt"
-	#define MSG_SD_OPENROOT_FAIL "openRoot mislukt"
-	#define MSG_SD_CARD_OK "SD kaart ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir openen mislukt"
-	#define MSG_SD_OPEN_FILE_FAIL "Openen mislukt, bestand: "
-	#define MSG_SD_FILE_OPENED "Bestand geopend: "
-	#define MSG_SD_SIZE " Grootte: "
-	#define MSG_SD_FILE_SELECTED "Bestanden geselecteerd:"
-	#define MSG_SD_WRITE_TO_FILE "Schrijven naar bestand: "
-	#define MSG_SD_PRINTING_BYTE "SD printen byte: "
-	#define MSG_SD_NOT_PRINTING "Niet SD printen"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Fout tijdens het schrijven naar bestand:"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Kan subdirectory niet in: "
-
-	#define MSG_STEPPER_TOO_HIGH "stapsnelheid te hoog:"
-	#define MSG_ENDSTOPS_HIT "endstops geraakt: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " Koude extrusie voorkomen"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " te lange extrusie voorkomen"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Fout in menustructuur"
-
 #endif
 
 
@@ -2424,82 +1665,6 @@
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop abort"
 
-// Serial Console Messages
-
-	#define MSG_Enqueing "en cua \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Extern"
-	#define MSG_BROWNOUT_RESET " Reset per Voltatge Incorrecte"
-	#define MSG_WATCHDOG_RESET " Reset per Bloqueix"
-	#define MSG_SOFTWARE_RESET " Reset per Software"
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER "Ultima actualitzacio: "
-	#define MSG_FREE_MEMORY " Memoria lliure: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Fitxer desat."
-	#define MSG_ERR_LINE_NO "El Numero de la Linia no es igual al Ultimo Numero de Linia+1, Ultima Linia:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincideix, Ultima Linia:"
-	#define MSG_ERR_NO_CHECKSUM "No s'ha trobat el Checksum amb el numero de linea, Ultima Linea:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No s'ha trobat Numero de Linea amb el Checksum, Ultima Linea:"
-	#define MSG_FILE_PRINTED "Impresio acabada"
-	#define MSG_BEGIN_FILE_LIST "Inici de la llista d'arxius"
-	#define MSG_END_FILE_LIST "Fi de la llista d'arxius"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalid "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalid "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Extrusor Invalid "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalid "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Extrusor Invalid "
-	#define MSG_ERR_NO_THERMISTORS "No hi ha termistors - sense temperatura"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalid "
-	#define MSG_HEATING "Escalfant..."
-	#define MSG_HEATING_COMPLETE "Escalfament acabat."
-	#define MSG_BED_HEATING "Escalfant llit."
-	#define MSG_BED_DONE "Llit Calent."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " Count X: "
-	#define MSG_ERR_KILLED "Impressora Parada per kill()!"
-	#define MSG_ERR_STOPPED "Impressora Parada per errors. Repara l'error i utilitza M999 per reiniciar!. (Hi ha un reset de temperatura, cal ajustarla abans de continuuar)"
-	#define MSG_RESEND "Reenviar: "
-	#define MSG_UNKNOWN_COMMAND "Comanda Desconeguda: \""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor Actiu: "
-	#define MSG_INVALID_EXTRUDER "Extrusor Invalid"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Comprobant finals de carrera."
-	#define MSG_ENDSTOP_HIT "Activat"
-	#define MSG_ENDSTOP_OPEN "obert"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "No s'ha pogut obrir la carpeta"
-	#define MSG_SD_INIT_FAIL "Error al iniciar la SD"
-	#define MSG_SD_VOL_INIT_FAIL "Error al montar el volum"
-	#define MSG_SD_OPENROOT_FAIL "Error al obrir la carpeta arrel"
-	#define MSG_SD_CARD_OK "Targeta SD OK"
-	#define MSG_SD_WORKDIR_FAIL "Error al obrir la carpeta de treball"
-	#define MSG_SD_OPEN_FILE_FAIL "Error al obrir, Fitxer: "
-	#define MSG_SD_FILE_OPENED "Fitxer obert:"
-	#define MSG_SD_SIZE " Mida: "
-	#define MSG_SD_FILE_SELECTED "Fitxer Seleccionat"
-	#define MSG_SD_WRITE_TO_FILE "Desant al fitxer: "
-	#define MSG_SD_PRINTING_BYTE "SD imprimint el byte "
-	#define MSG_SD_NOT_PRINTING "No s'està imprimint amb SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Error al esciure al fitxer"
-	#define MSG_SD_CANT_ENTER_SUBDIR "No es pot obrir la carpeta: "
-
-	#define MSG_STEPPER_TOO_HIGH "Steprate massa alt: "
-	#define MSG_ENDSTOPS_HIT "S'ha tocat el final de carrera: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusio freda evitada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusio massa llarga evitada"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Error a l'estructura dels menus"
-
 #endif
 
 //Basque-Euskera
@@ -2624,82 +1789,6 @@
 	#define MSG_BABYSTEP_Z "Babystep Z"
 	#define MSG_ENDSTOP_ABORT "Endstop deuseztat"
 	
-// Serial Console Messages
-
-	#define MSG_Enqueing "Zerrendan \""
-	#define MSG_POWERUP "Pizketa"
-	#define MSG_EXTERNAL_RESET " Kanpoko Reset"
-	#define MSG_BROWNOUT_RESET " Tentsio Okerra Reset"
-	#define MSG_WATCHDOG_RESET " Reset Blokeoa"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_AUTHOR " | Egilea: "
-	#define MSG_CONFIGURATION_VER " Azken Aktualizazio: "
-	#define MSG_FREE_MEMORY " Aske Memoria: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Gordetuta."
-	#define MSG_ERR_LINE_NO "Lerro zenbakia ez da azken zenbakia+1 berdina, Azken Lerroa: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum-ak ez du aldiberekotasuna, Azken Lerroa: "
-	#define MSG_ERR_NO_CHECKSUM "Ez da checksum-ik aurkitu lerro zenbakian, Azken Lerroa: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ez da lerro zenbakia aurkitu checksum-arekin, Azken Lerroa: "
-	#define MSG_FILE_PRINTED "Inprimaketa bukatua"
-	#define MSG_BEGIN_FILE_LIST "Hasi artxibo zerrenda"
-	#define MSG_END_FILE_LIST "Amaitu artxibo zerrenda"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Balio gabeko Estrusorea "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Balio gabeko Estrusorea "
-	#define MSG_M200_INVALID_EXTRUDER "M200 Balio gabeko Estrusorea "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Balio gabeko Estrusorea "
-	#define MSG_M221_INVALID_EXTRUDER "M221 Balio gabeko Estrusorea "
-	#define MSG_ERR_NO_THERMISTORS "Termistorerik ez dago - Tenperaturarik gabe"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Balio gabeko Estrusorea "
-	#define MSG_HEATING "Berotzen..."
-	#define MSG_HEATING_COMPLETE "berotuta."
-	#define MSG_BED_HEATING "Ohea berotzen."
-	#define MSG_BED_DONE "Ohea berotuta."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
-	#define MSG_COUNT_X " X Kontu: "
-	#define MSG_ERR_KILLED "Inprimagailua geldituta. kill() called!"
-	#define MSG_ERR_STOPPED "Akatsen eraginez inprimagailua geldituta. Errorea konpondu eta M999 erabili berrabiarazteko. (Tenperatura galdu egin da. Berriro ipini)"
-	#define MSG_RESEND "Bidali berriro: "
-	#define MSG_UNKNOWN_COMMAND "Agindu ezezaguna: \""
-	#define MSG_ACTIVE_EXTRUDER "Estrusore Aktiboa: "
-	#define MSG_INVALID_EXTRUDER "Balio gabeko Estrusorea"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Bide amaiera egiaztatzen"
-	#define MSG_ENDSTOP_HIT "Sakatuta"
-	#define MSG_ENDSTOP_OPEN "irekia"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Azpidirektorio ezin da ireki"
-	#define MSG_SD_INIT_FAIL "Akatsa txartela hasterakoan"
-	#define MSG_SD_VOL_INIT_FAIL "Akatsa partizioa hasterakoan"
-	#define MSG_SD_OPENROOT_FAIL "Akatsa direktorio nagusian"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "Akatsa lan direktorioan"
-	#define MSG_SD_OPEN_FILE_FAIL "Akatsa irekitzean, File: "
-	#define MSG_SD_FILE_OPENED "Artxiboa irekita: "
-	#define MSG_SD_SIZE " Tamaina: "
-	#define MSG_SD_FILE_SELECTED "Artxiboa aukeratuta"
-	#define MSG_SD_WRITE_TO_FILE "Artxiboa idazten: "
-	#define MSG_SD_PRINTING_BYTE "SD byte idazten "
-	#define MSG_SD_NOT_PRINTING "Ez dago SD-tik inprimatzen"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Akatsak artxiboa idazten"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Azpidirektorio ezin da ireki: "
-
-	#define MSG_STEPPER_TOO_HIGH "Motorra oso goi dago: "
-	#define MSG_ENDSTOPS_HIT "Bide amaiera ukitu da: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " estrusio hotza saihestua"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " estrusio oso luzea saihestua"
-	#define MSG_BABYSTEPPING_X "Babystepping X"
-	#define MSG_BABYSTEPPING_Y "Babystepping Y"
-	#define MSG_BABYSTEPPING_Z "Babystepping Z"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Akatsak menu-an"
-	
 #endif
 
 #endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 2a8fa7b..0546883 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -95,6 +95,76 @@
 #endif /* 88 */
 
 /****************************************************************************************
+* Leapfrog Driver board
+* 
+****************************************************************************************/
+#if MOTHERBOARD == 999  // Leapfrog board
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+#define X_STEP_PIN         28
+#define X_DIR_PIN          63
+#define X_ENABLE_PIN       29
+#define X_MIN_PIN          47
+#define X_MAX_PIN          -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+#define Y_STEP_PIN         14 // A6
+#define Y_DIR_PIN          15 // A0
+#define Y_ENABLE_PIN       39
+#define Y_MIN_PIN          48
+#define Y_MAX_PIN          -1   //15
+
+#define Z_STEP_PIN         31 // A2
+#define Z_DIR_PIN          32 // A6
+#define Z_ENABLE_PIN       30 // A1
+#define Z_MIN_PIN          49
+#define Z_MAX_PIN          -1
+
+#define E0_STEP_PIN         34  //34
+#define E0_DIR_PIN          35 //35
+#define E0_ENABLE_PIN       33 //33
+
+#define E1_STEP_PIN         37 //37
+#define E1_DIR_PIN          40 //40
+#define E1_ENABLE_PIN       36 //36
+
+#define Y2_STEP_PIN         37
+#define Y2_DIR_PIN          40
+#define Y2_ENABLE_PIN       36
+
+#define Z2_STEP_PIN         37
+#define Z2_DIR_PIN          40
+#define Z2_ENABLE_PIN       36
+
+#define SDPOWER            -1
+#define SDSS               11
+#define SDCARDDETECT       -1 // 10 optional also used as mode pin
+#define LED_PIN            13
+#define FAN_PIN            7
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+#define SOL1_PIN   16
+#define SOL2_PIN    17
+
+#define HEATER_0_PIN       9
+#define HEATER_1_PIN       8 // 12
+#define HEATER_2_PIN       11 //-1 // 13
+#define TEMP_0_PIN         13 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN         15 // 1
+#define TEMP_2_PIN         -1 // 2
+#define HEATER_BED_PIN     10 // 14/15
+#define TEMP_BED_PIN       14 // 1,2 or I2C
+/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
+
+
+#endif
+
+/****************************************************************************************
 *
 *
 ****************************************************************************************/
@@ -823,9 +893,9 @@
 
 #ifndef SDSUPPORT
 // these pins are defined in the SD library if building with SD support
-  #define MAX_SCK_PIN          52
-  #define MAX_MISO_PIN         50
-  #define MAX_MOSI_PIN         51
+  #define SCK_PIN          52
+  #define MISO_PIN         50
+  #define MOSI_PIN         51
   #define MAX6675_SS       53
 #else
   #define MAX6675_SS       49
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 5b20f86..4ae1871 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -96,6 +96,8 @@ float autotemp_factor=0.1;
 bool autotemp_enabled=false;
 #endif
 
+unsigned char g_uc_extruder_last_move[3] = {0,0,0};
+
 //===========================================================================
 //=================semi-private variables, used in inline  functions    =====
 //===========================================================================
@@ -662,11 +664,34 @@ block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-positi
   {
     if (DISABLE_INACTIVE_EXTRUDER) //enable only selected extruder
     {
+
+      if(g_uc_extruder_last_move[0] > 0) g_uc_extruder_last_move[0]--;
+      if(g_uc_extruder_last_move[1] > 0) g_uc_extruder_last_move[1]--;
+      if(g_uc_extruder_last_move[2] > 0) g_uc_extruder_last_move[2]--;
+      
       switch(extruder)
       {
-        case 0: enable_e0(); disable_e1(); disable_e2(); break;
-        case 1: disable_e0(); enable_e1(); disable_e2(); break;
-        case 2: disable_e0(); disable_e1(); enable_e2(); break;
+        case 0: 
+          enable_e0(); 
+          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
+          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
+        break;
+        case 1:
+          enable_e1(); 
+          g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
+          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
+        break;
+        case 2:
+          enable_e2(); 
+          g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
+          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
+        break;        
       }
     }
     else //enable all
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index a10c255..6a5d58e 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -34,6 +34,9 @@
 #include "temperature.h"
 #include "watchdog.h"
 
+#include "Sd2PinMap.h"
+
+
 //===========================================================================
 //=============================public variables============================
 //===========================================================================
@@ -748,18 +751,22 @@ void tp_init()
 
   #ifdef HEATER_0_USES_MAX6675
     #ifndef SDSUPPORT
-      SET_OUTPUT(MAX_SCK_PIN);
-      WRITE(MAX_SCK_PIN,0);
+      SET_OUTPUT(SCK_PIN);
+      WRITE(SCK_PIN,0);
     
-      SET_OUTPUT(MAX_MOSI_PIN);
-      WRITE(MAX_MOSI_PIN,1);
+      SET_OUTPUT(MOSI_PIN);
+      WRITE(MOSI_PIN,1);
     
-      SET_INPUT(MAX_MISO_PIN);
-      WRITE(MAX_MISO_PIN,1);
+      SET_INPUT(MISO_PIN);
+      WRITE(MISO_PIN,1);
     #endif
+    /* Using pinMode and digitalWrite, as that was the only way I could get it to compile */
     
-    SET_OUTPUT(MAX6675_SS);
-    WRITE(MAX6675_SS,1);
+    //Have to toggle SD card CS pin to low first, to enable firmware to talk with SD card
+	pinMode(SS_PIN, OUTPUT);
+	digitalWrite(SS_PIN,0);  
+	pinMode(MAX6675_SS, OUTPUT);
+	digitalWrite(MAX6675_SS,1);
   #endif
 
   // Set analog inputs
@@ -1045,7 +1052,7 @@ void bed_max_temp_error(void) {
 
 #ifdef HEATER_0_USES_MAX6675
 #define MAX6675_HEAT_INTERVAL 250
-long max6675_previous_millis = -HEAT_INTERVAL;
+long max6675_previous_millis = MAX6675_HEAT_INTERVAL;
 int max6675_temp = 2000;
 
 int read_max6675()
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 86bf5c2..07b385e 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -1021,81 +1021,6 @@ const short temptable_1047[][2] PROGMEM = {
   PtLine(300,1000,4700)
 };
 #endif
-#if (THERMISTORHEATER_0 == 70) || (THERMISTORHEATER_1 == 70) || (THERMISTORHEATER_2 == 70) || (THERMISTORBED == 70) // 500C thermistor for Pico hot end
-const short temptable_70[][2] PROGMEM = {
-  {  110.774119598719*OVERSAMPLENR ,  350 },
-  {  118.214386957249*OVERSAMPLENR ,  345 },
-  {  126.211418543166*OVERSAMPLENR ,  340 },
-  {  134.789559066223*OVERSAMPLENR ,  335 },
-  {  144.004513869701*OVERSAMPLENR ,  330 },
-  {  153.884483790827*OVERSAMPLENR ,  325 },
-  {  164.484880793637*OVERSAMPLENR ,  320 },
-  {  175.848885102724*OVERSAMPLENR ,  315 },
-  {  188.006799079015*OVERSAMPLENR ,  310 },
-  {  201.008072969044*OVERSAMPLENR ,  305 },
-  {  214.83716032276*OVERSAMPLENR ,  300 },
-  {  229.784739779664*OVERSAMPLENR ,  295 },
-  {  245.499466045473*OVERSAMPLENR ,  290 },
-  {  262.2766342096*OVERSAMPLENR ,  285 },
-  {  280.073883176433*OVERSAMPLENR ,  280 },
-  {  298.952693467726*OVERSAMPLENR ,  275 },
-  {  318.808251051674*OVERSAMPLENR ,  270 },
-  {  337.490932563222*OVERSAMPLENR ,  265 },
-  {  361.683649122745*OVERSAMPLENR ,  260 },
-  {  384.717024083981*OVERSAMPLENR ,  255 },
-  {  408.659301759076*OVERSAMPLENR ,  250 },
-  {  433.471659455884*OVERSAMPLENR ,  245 },
-  {  459.199039926034*OVERSAMPLENR ,  240 },
-  {  485.566500982316*OVERSAMPLENR ,  235 },
-  {  512.538918631075*OVERSAMPLENR ,  230 },
-  {  539.980999544838*OVERSAMPLENR ,  225 },
-  {  567.783095549935*OVERSAMPLENR ,  220 },
-  {  595.698041673552*OVERSAMPLENR ,  215 },
-  {  623.633922319597*OVERSAMPLENR ,  210 },
-  {  651.356162750829*OVERSAMPLENR ,  205 },
-  {  678.700901620956*OVERSAMPLENR ,  200 },
-  {  705.528145361264*OVERSAMPLENR ,  195 },
-  {  731.61267976339*OVERSAMPLENR ,  190 },
-  {  756.786212184365*OVERSAMPLENR ,  185 },
-  {  780.950223357761*OVERSAMPLENR ,  180 },
-  {  804.012961595082*OVERSAMPLENR ,  175 },
-  {  825.904975939166*OVERSAMPLENR ,  170 },
-  {  846.403941639008*OVERSAMPLENR ,  165 },
-  {  865.52326974895*OVERSAMPLENR ,  160 },
-  {  883.246145367727*OVERSAMPLENR ,  155 },
-  {  899.5821946515*OVERSAMPLENR ,  150 },
-  {  914.544289228582*OVERSAMPLENR ,  145 },
-  {  928.145628221761*OVERSAMPLENR ,  140 },
-  {  940.422208546562*OVERSAMPLENR ,  135 },
-  {  951.456922916497*OVERSAMPLENR ,  130 },
-  {  961.303500633788*OVERSAMPLENR ,  125 },
-  {  970.044756889055*OVERSAMPLENR ,  120 },
-  {  977.761456230051*OVERSAMPLENR ,  115 },
-  {  984.540978083453*OVERSAMPLENR ,  110 },
-  {  990.440780765757*OVERSAMPLENR ,  105 },
-  {  995.589621465301*OVERSAMPLENR ,  100 },
-  {  1000.02514280144*OVERSAMPLENR ,  95 },
-  {  1003.84429789876*OVERSAMPLENR ,  90 },
-  {  1007.10199009318*OVERSAMPLENR ,  85 },
-  {  1009.87151698323*OVERSAMPLENR ,  80 },
-  {  1012.21633594237*OVERSAMPLENR ,  75 },
-  {  1014.18959892949*OVERSAMPLENR ,  70 },
-  {  1015.84079162998*OVERSAMPLENR ,  65 },
-  {  1017.21555915335*OVERSAMPLENR ,  60 },
-  {  1018.35284662863*OVERSAMPLENR ,  55 },
-  {  1019.28926921888*OVERSAMPLENR ,  50 },
-  {  1020.05398015669*OVERSAMPLENR ,  45 },
-  {  1020.67737496272*OVERSAMPLENR ,  40 },
-  {  1021.1802909627*OVERSAMPLENR ,  35 },
-  {  1021.58459281248*OVERSAMPLENR ,  30 },
-  {  1021.90701441192*OVERSAMPLENR ,  25 },
-  {  1022.16215103698*OVERSAMPLENR ,  20 },
-  {  1022.36275529549*OVERSAMPLENR ,  15 },
-  {  1022.51930392497*OVERSAMPLENR ,  10 },
-  {  1022.64051573734*OVERSAMPLENR ,  5 },
-  {  1022.73355805611*OVERSAMPLENR ,  0 }
-};
-#endif
 
 #define _TT_NAME(_N) temptable_ ## _N
 #define TT_NAME(_N) _TT_NAME(_N)
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 0abc355..350eddf 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -19,6 +19,7 @@ int absPreheatHotendTemp;
 int absPreheatHPBTemp;
 int absPreheatFanSpeed;
 
+
 #ifdef ULTIPANEL
 static float manual_feedrate[] = MANUAL_FEEDRATE;
 #endif // ULTIPANEL
@@ -255,8 +256,8 @@ static void lcd_sdcard_stop()
         enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
     }
     autotempShutdown();
-    
-    cancel_heatup = true;
+
+	cancel_heatup = true;
 }
 
 /* Menu implementation */
@@ -869,6 +870,10 @@ static void lcd_control_motion_menu()
 #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
     MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);
 #endif
+#ifdef SCARA
+    MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);
+    MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS],0.5,2);
+#endif
     END_MENU();
 }
 
@@ -904,13 +909,13 @@ static void lcd_control_retract_menu()
     MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
     MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
-    #if EXTRUDERS > 1
+	#if EXTRUDERS > 1
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
     #endif
     MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
-    #if EXTRUDERS > 1
+	#if EXTRUDERS > 1
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
     #endif
     MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
@@ -1515,9 +1520,13 @@ char *itostr31(const int &xx)
   return conv;
 }
 
-char *itostr3(const int &xx)
+char *itostr3(const int &x)
 {
-  if (xx >= 100)
+  int xx = x;
+  if (xx < 0) {
+     conv[0]='-';
+     xx = -xx;
+  } else if (xx >= 100)
     conv[0]=(xx/100)%10+'0';
   else
     conv[0]=' ';
diff --git a/README.md b/README.md
index 17e920e..017e989 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ==========================
 Marlin 3D Printer Firmware
 ==========================
-[![Coverity Scan Build Status](https://scan.coverity.com/projects/2224/badge.svg)](https://scan.coverity.com/projects/2224)
-
+[![Coverity Scan Build Status](https://scan.coverity.com/projects/2224/badge.svg)](https://scan.coverity.com/projects/2224)
+
 Marlin has a GPL license because I believe in open development.
 Please do not use this code in products (3D printers, CNC etc) that are closed source or are crippled by a patent.
 
@@ -47,6 +47,7 @@ Features:
 *   PID tuning
 *   CoreXY kinematics (www.corexy.com/theory.html)
 *   Delta kinematics
+*   SCARA kinematics
 *   Dual X-carriage support for multiple extruder systems
 *   Configurable serial port to support connection of wireless adaptors.
 *   Automatic operation of extruder/cold-end cooling fans based on nozzle temperature
@@ -159,6 +160,8 @@ Implemented G Codes:
 *  G28 - Home all Axis
 *  G29 - Detailed Z-Probe, probes the bed at 3 points.  You must de at the home position for this to work correctly.
 *  G30 - Single Z Probe, probes bed at current XY location.
+*  G31 - Dock Z Probe sled (if enabled)
+*  G32 - Undock Z Probe sled (if enabled)
 *  G90 - Use Absolute Coordinates
 *  G91 - Use Relative Coordinates
 *  G92 - Set current position to cordinates given
@@ -207,15 +210,15 @@ M Codes
 *  M140 - Set bed target temp
 *  M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 *         Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
-*  M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
+*  M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
 *  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 *  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 *  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 *  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
 *  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
 *  M206 - set additional homeing offset
-*  M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
-*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
+*  M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
+*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
 *  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 *  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 *  M220 S<factor in percent>- set speed factor override percentage
@@ -272,8 +275,46 @@ That's ok.  Enjoy Silky Smooth Printing.
 ===============================================
 Instructions for configuring Bed Auto Leveling
 ===============================================
+There are two options for this feature. You may choose to use a servo mounted on the X carriage or you may use a sled that mounts on the X axis and can be docked when not in use.
+See the section for each option below for specifics about installation and configuration. Also included are instructions that apply to both options.
+
+Note for RAMPS users:
+---------------------
+
+By default, RAMPS have no power on servo bus (if you happen to have a multimeter, check the voltage on servo power pins).
+In order to get the servo working, you need to supply 5V to 5V pin.. You can do it using your power supply (if it has a 5V output) or jumping the "Vcc" from Arduino to the 5V RAMPS rail.
+These 2 pins are located just between the Reset Button and the yellow fuses... There are marks in the board showing 5V and VCC.. just connect them..
+If jumping the arduino Vcc do RAMPS 5V rail, take care to not use a power hungry servo, otherwise you will cause a blackout in the arduino board ;-)
+
+Instructions for Both Options
+-----------------------------
+
 Uncomment the "ENABLE_AUTO_BED_LEVELING" define (commented by default)
 
+The following options define the probing positions. These are good starting values.
+I recommend to keep a better clearance from borders in the first run and then make the probes as close as possible to borders:
+
+* \#define LEFT_PROBE_BED_POSITION 30
+* \#define RIGHT_PROBE_BED_POSITION 140
+* \#define BACK_PROBE_BED_POSITION 140
+* \#define FRONT_PROBE_BED_POSITION 30
+
+A few more options:
+
+* \#define XY_TRAVEL_SPEED 6000
+
+X and Y axis travel speed between probes, in mm/min.
+Bear in mind that really fast moves may render step skipping. 6000 mm/min (100mm/s) is a good value.
+
+* \#define Z_RAISE_BEFORE_PROBING 10
+* \#define Z_RAISE_BETWEEN_PROBINGS 10
+
+The Z axis is lifted when traveling to the first probe point by Z_RAISE_BEFORE_PROBING value
+and then lifted when traveling from first to second and second to third point by Z_RAISE_BETWEEN_PROBINGS.
+All values are in mm as usual.
+
+Servo Option Notes
+------------------
 You will probably need a swivel Z-MIN endstop in the extruder. A rc servo do a great job.
 Check the system working here: http://www.youtube.com/watch?v=3IKMeOYz-1Q (Enable English subtitles)
 Teasing ;-) video: http://www.youtube.com/watch?v=x8eqSQNAyro
@@ -286,20 +327,10 @@ In order to get the servo working, you need to enable:
 
 * \#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 165,60} // X,Y,Z Axis Extend and Retract angles
 
-
 The first define tells firmware how many servos you have.
 The second tells what axis this servo will be attached to. In the example above, we have a servo in Z axis.
 The third one tells the angle in 2 situations: Probing (165º) and resting (60º). Check this with command M280 P0 S{angle} (example: M280 P0 S60 moves the servo to 60º)
 
-For RAMPS users:
-----------------
-
-By default, RAMPS have no power on servo bus (if you happen to have a multimeter, check the voltage on servo power pins).
-In order to get the servo working, you need to supply 5V to 5V pin.. You can do it using your power supply (if it has a 5V output) or jumping the "Vcc" from Arduino to the 5V RAMPS rail.
-These 2 pins are located just between the Reset Button and the yellow fuses... There are marks in the board showing 5V and VCC.. just connect them..
-If jumping the arduino Vcc do RAMPS 5V rail, take care to not use a power hungry servo, otherwise you will cause a blackout in the arduino board ;-)
-
-
 Next you need to define the Z endstop (probe) offset from hotend.
 My preferred method:
 
@@ -317,27 +348,42 @@ My preferred method:
 * \#define Z_PROBE_OFFSET_FROM_EXTRUDER -5.1
 
 
-The following options define the probing positions. These are good starting values.
-I recommend to keep a better clearance from borders in the first run and then make the probes as close as possible to borders:
+Sled Option Notes
+-----------------
+The sled option uses an electromagnet to attach and detach to/from the X carriage. See http://www.thingiverse.com/thing:396692 for more details on how to print and install this feature. It uses the same connections as the servo option.
 
-* \#define LEFT_PROBE_BED_POSITION 30
-* \#define RIGHT_PROBE_BED_POSITION 140
-* \#define BACK_PROBE_BED_POSITION 140
-* \#define FRONT_PROBE_BED_POSITION 30
+To use the sled option, you must define two additional things in Configuration.h:
 
-A few more options:
+* \#define Z_PROBE_SLED
+* \#define SLED_DOCKING_OFFSET 5
 
-* \#define XY_TRAVEL_SPEED 6000
+Uncomment the Z_PROBE_SLED to define to enable the sled (commented out by default).
 
-X and Y axis travel speed between probes, in mm/min.
-Bear in mind that really fast moves may render step skipping. 6000 mm/min (100mm/s) is a good value.
+Uncomment the SLED_DOCKING_OFFSET to set the extra distance the X axis must travel to dock the sled. This value can be found by moving the X axis to its maximum position then measure the distance to the right X end and subtract the width of the sled (23mm if you printed the sled from Thingiverse).
 
-* \#define Z_RAISE_BEFORE_PROBING 10
-* \#define Z_RAISE_BETWEEN_PROBINGS 10
+Next you need to define the Z endstop (probe) offset from hotend.
+My preferred method:
 
-The Z axis is lifted when traveling to the first probe point by Z_RAISE_BEFORE_PROBING value
-and then lifted when traveling from first to second and second to third point by Z_RAISE_BETWEEN_PROBINGS.
-All values are in mm as usual. 
+* a) Home the X and Y axes.
+* b) Move the X axis to about the center of the print bed. Make a mark on the print bed.
+* c) Move the Y axis to the maximum position. Make another mark.
+* d) Home the X axis and use a straight edge to make a line between the two points.
+* e) Repeat (b)-(d) reversing the X and Y. When you are done you will have two lines on the print bed. We will use these to measure the offset for the Z probe endstop.
+* f) Move the nozzle so that it is positioned on the center point of the two lines. You can use fine movement of 0.1mm to get it as close as possible. Note the position of X and Y.
+* g) Zero the Z axis with the G92 Z0 command.
+* h) Raise the Z axis about 20mmm.
+* i) Use the G32 command to retrieve the sled.
+* j) Now more the X and Y axis to the position recorded in (f).
+* k) Lower the Z axis in 0.1mm steps until you hear the "click" meaning the mechanical endstop was trigged. You can confirm with the M119 command. Note the position of the Z axis.
+* l) Make a mark on the print bed where the endstop lever has touched the print bed. Raise the Z-axis about 30mm to give yourself some room.
+* m) Now measure the distance from the center point to the endstop impact site along the X and Y axis using the lines drawn previously.
+* n) Fill in the values below. If the endstop mark is in front of the line running left-to-right, use positive values. If it is behind, use negative values. For the Z axis use the value from (k) and subtract 0.1mm.
+
+For example, suppose you measured the endstop position and it was 20mm to the right of the line running front-to-back, 10mm toward the front of the line running left-to-right, and the value from (k) was 2.85. The values for the defines would be:
+
+* \#define X_PROBE_OFFSET_FROM_EXTRUDER 20
+* \#define Y_PROBE_OFFSET_FROM_EXTRUDER 10
+* \#define Z_PROBE_OFFSET_FROM_EXTRUDER 2.75
 
 That's it.. enjoy never having to calibrate your Z endstop neither leveling your bed by hand anymore ;-)
 
