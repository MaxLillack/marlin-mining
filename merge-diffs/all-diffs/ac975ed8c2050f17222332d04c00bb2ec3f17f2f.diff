commit ac975ed8c2050f17222332d04c00bb2ec3f17f2f (from 7ad12be763c842b4bf8e1a1da955ee3ac26f167d)
Merge: 7ad12be 58d12aa
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Mon Jun 10 18:20:29 2013 +0200

    Merge branch 'deltabot' into Marlin_v1

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 5c9137e..b552d20 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -808,9 +808,42 @@ void process_commands()
       for(int8_t i=0; i < NUM_AXIS; i++) {
         destination[i] = current_position[i];
       }
-      feedrate = 0.0;
-      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])))
-                    || ((code_seen(axis_codes[0])) && (code_seen(axis_codes[1])) && (code_seen(axis_codes[2])));
+          feedrate = 0.0;
+
+#ifdef DELTA
+          // A delta can only safely home all axis at the same time
+          // all axis have to home at the same time
+
+          // Move all carriages up together until the first endstop is hit.
+          current_position[X_AXIS] = 0;
+          current_position[Y_AXIS] = 0;
+          current_position[Z_AXIS] = 0;
+          plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
+
+          destination[X_AXIS] = 3 * Z_MAX_LENGTH;
+          destination[Y_AXIS] = 3 * Z_MAX_LENGTH;
+          destination[Z_AXIS] = 3 * Z_MAX_LENGTH;
+          feedrate = 1.732 * homing_feedrate[X_AXIS];
+          plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+          st_synchronize();
+          endstops_hit_on_purpose();
+
+          current_position[X_AXIS] = destination[X_AXIS];
+          current_position[Y_AXIS] = destination[Y_AXIS];
+          current_position[Z_AXIS] = destination[Z_AXIS];
+          
+          // take care of back off and rehome now we are all at the top
+          HOMEAXIS(X);
+          HOMEAXIS(Y);
+          HOMEAXIS(Z);
+
+          calculate_delta(current_position);
+          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+
+#else // NOT DELTA
+
+          home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
+
       #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
@@ -879,12 +912,9 @@ void process_commands()
           current_position[Z_AXIS]=code_value()+add_homeing[2];
         }
       }
-      #ifdef DELTA
-        calculate_delta(current_position);
-        plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
-      #else
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      #endif
+      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#endif // DELTA
+          
       #ifdef ENDSTOPS_ONLY_FOR_HOMING
         enable_endstops(false);
       #endif

commit ac975ed8c2050f17222332d04c00bb2ec3f17f2f (from 58d12aad73441df27d15abe53b6efb031ace0ea7)
Merge: 7ad12be 58d12aa
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Mon Jun 10 18:20:29 2013 +0200

    Merge branch 'deltabot' into Marlin_v1

diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
index 1711014..3b56dfd 100644
--- a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
@@ -168,7 +168,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
index 1711014..3b56dfd 100644
--- a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -168,7 +168,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp b/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
index 23713f4..c3362f6 100644
--- a/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
+++ b/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
@@ -21,7 +21,7 @@
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 
 LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
diff --git a/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c b/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
index f86bf06..4a8758c 100644
--- a/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
+++ b/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
@@ -72,7 +72,7 @@
 	- Castling: Need to check for fields under attack
 	    --> done
 	
-	- Check for WIN / LOOSE situation, perhaps call ce_Eval() once on the top-level board setup
+	- Check for WIN / LOSE situation, perhaps call ce_Eval() once on the top-level board setup
 	    just after the real move
 	- cleanup cu_Move
 	    --> almost done
diff --git a/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp b/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
index 0653487..61efca4 100644
--- a/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
+++ b/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
@@ -21,7 +21,7 @@
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 
 LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
diff --git a/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c b/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
index f86bf06..4a8758c 100644
--- a/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
+++ b/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
@@ -72,7 +72,7 @@
 	- Castling: Need to check for fields under attack
 	    --> done
 	
-	- Check for WIN / LOOSE situation, perhaps call ce_Eval() once on the top-level board setup
+	- Check for WIN / LOSE situation, perhaps call ce_Eval() once on the top-level board setup
 	    just after the real move
 	- cleanup cu_Move
 	    --> almost done
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
index 9354a78..1df3f03 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
@@ -301,7 +301,7 @@ int main(void)
 	WDTCSR = 0;
 
 	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-	if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+	if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
 		app_start();  // skip bootloader
 #else
 	asm volatile("nop\n\t");
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
index fd19d14..51bd8d5 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -172,7 +172,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
index 733542d..7e0adff 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
@@ -172,7 +172,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 0ad5639..43032a3 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -1,15 +1,15 @@
 #ifndef CONFIGURATION_H
 #define CONFIGURATION_H
 
-// This configurtion file contains the basic settings.
+// This configuration file contains the basic settings.
 // Advanced settings can be found in Configuration_adv.h
 // BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
 
-//User specified version info of this build to display in [Pronterface, etc] terminal window during startup.
-//Implementation of an idea by Prof Braino to inform user that any changes made
-//to this build by the user have been successfully uploaded into firmware.
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
 #define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
-#define STRING_CONFIG_H_AUTHOR "(none, default config)" //Who made the changes.
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 
 // SERIAL_PORT selects which serial port should be used for communication with the host.
 // This allows the connection of wireless adapters (for instance) to non-default port pins.
@@ -37,6 +37,7 @@
 // 64 = STB V1.1
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 77 = 3Drag Controller
 // 8  = Teensylu
 // 80 = Rumba
 // 81 = Printrboard (AT90USB1286)
@@ -54,6 +55,9 @@
 #define MOTHERBOARD 7
 #endif
 
+// Define this to set a custom name for your generic Mendel,
+// #define CUSTOM_MENDEL_NAME "This Mendel"
+
 // This defines the number of extruders
 #define EXTRUDERS 1
 
@@ -139,7 +143,7 @@
 // Actual temperature must be close to target for this long before M109 returns success
 #define TEMP_RESIDENCY_TIME 10  // (seconds)
 #define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
-#define TEMP_WINDOW     1       // (degC) Window around target to start the recidency timer x degC early.
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
 
 // The minimal temperature defines the temperature below which the heater will not be enabled It is used
 // to check that the wiring to the thermistor is not broken.
@@ -173,7 +177,7 @@
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
-  #define K1 0.95 //smoothing factor withing the PID
+  #define K1 0.95 //smoothing factor within the PID
   #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
 
 // If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
@@ -194,20 +198,20 @@
 #endif // PIDTEMP
 
 // Bed Temperature Control
-// Select PID or bang-bang with PIDTEMPBED.  If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
 //
-// uncomment this to enable PID on the bed.   It uses the same frequency PWM as the extruder.
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
 // If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
 // which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
 // This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
-// If your configuration is significantly different than this and you don't understand the issues involved, you proabaly
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
 // shouldn't use bed PID until someone else verifies your hardware works.
 // If this is enabled, find your own PID constants below.
 //#define PIDTEMPBED
 //
 //#define BED_LIMIT_SWITCHING
 
-// This sets the max power delived to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
 // all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
 // setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
 // so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
@@ -215,7 +219,7 @@
 
 #ifdef PIDTEMPBED
 //120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, argressive factor of .15 (vs .1, 1, 10)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
     #define  DEFAULT_bedKp 10.00
     #define  DEFAULT_bedKi .023
     #define  DEFAULT_bedKd 305.4
@@ -247,11 +251,11 @@
 // Uncomment the following line to enable CoreXY kinematics
 // #define COREXY
 
-// corse Endstop Settings
+// coarse Endstop Settings
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
 
 #ifndef ENDSTOPPULLUPS
-  // fine Enstop settings: Individual Pullups. will be ignord if ENDSTOPPULLUPS is defined
+  // fine Enstop settings: Individual Pullups. will be ignored if ENDSTOPPULLUPS is defined
   #define ENDSTOPPULLUP_XMAX
   #define ENDSTOPPULLUP_YMAX
   #define ENDSTOPPULLUP_ZMAX
@@ -275,6 +279,11 @@ const bool Y_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops.
 //#define DISABLE_MAX_ENDSTOPS
 
+// Disable max endstops for compatibility with endstop checking routine
+#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
+  #define DISABLE_MAX_ENDSTOPS
+#endif
+
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 #define X_ENABLE_ON 0
 #define Y_ENABLE_ON 0
@@ -300,8 +309,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Y_HOME_DIR -1
 #define Z_HOME_DIR -1
 
-#define min_software_endstops true //If true, axis won't move to coordinates less than HOME_POS.
-#define max_software_endstops true  //If true, axis won't move to coordinates greater than the defined lengths below.
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
 // Travel limits after homing
 #define X_MAX_POS 205
 #define X_MIN_POS 0
@@ -331,12 +340,12 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 
 // default settings
 
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for ultimaker
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for Ultimaker
 #define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 25}    // (mm/sec)
 #define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
 #define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
-#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for r retracts
+#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts
 
 // Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
 // The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
@@ -344,7 +353,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 // #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-// The speed change that does not require acceleration (i.e. the software might assume it can be done instanteneously)
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
 #define DEFAULT_XYJERK                20.0    // (mm/sec)
 #define DEFAULT_ZJERK                 0.4     // (mm/sec)
 #define DEFAULT_EJERK                 5.0    // (mm/sec)
@@ -496,6 +505,17 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
 //#define FAST_PWM_FAN
 
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not ass annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
 // M240  Triggers a camera by emulating a Canon RC-1 Remote
 // Data from: http://www.doc-diy.net/photo/rc-1_hacked/
 // #define PHOTOGRAPH_PIN     23
@@ -507,11 +527,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //#define BARICUDA
 
 /*********************************************************************\
-*
 * R/C SERVO support
-*
 * Sponsored by TrinityLabs, Reworked by codexmas
-*
 **********************************************************************/
 
 // Number of servos
@@ -521,7 +538,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // leaving it undefined or defining as 0 will disable the servo subsystem
 // If unsure, leave commented / disabled
 //
-//#define NUM_SERVOS 3 // Servo index starts with 0
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
 
 // Servo Endstops
 // 
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index fea219f..5f1c77a 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -319,7 +319,7 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 //=============================  Define Defines  ============================
 //===========================================================================
 #if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
-  #error "You cannot use  TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
 #endif
 
 #if TEMP_SENSOR_0 > 0
diff --git a/Marlin/LiquidCrystalRus.cpp b/Marlin/LiquidCrystalRus.cpp
index 4bd8de7..c193e44 100644
--- a/Marlin/LiquidCrystalRus.cpp
+++ b/Marlin/LiquidCrystalRus.cpp
@@ -36,7 +36,7 @@ const PROGMEM uint8_t utf_recode[] =
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 // 
 // modified 27 Jul 2011
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 2906b46..c9759eb 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -194,6 +194,10 @@ extern int ValvePressure;
 extern int EtoPPressure;
 #endif
 
+#ifdef FAN_SOFT_PWM
+extern unsigned char fanSpeedSoftPwm;
+#endif
+
 #ifdef FWRETRACT
 extern bool autoretract_enabled;
 extern bool retracted;
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index bfb57ba..b552d20 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -887,14 +887,14 @@ void process_commands()
       if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
         HOMEAXIS(Y);
       }
-      
+
       #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
       }
       #endif
-      
-      if(code_seen(axis_codes[X_AXIS])) 
+
+      if(code_seen(axis_codes[X_AXIS]))
       {
         if(code_value_long() != 0) {
           current_position[X_AXIS]=code_value()+add_homeing[0];
@@ -1607,17 +1607,22 @@ void process_commands()
     #if LARGE_FLASH == true && ( BEEPER > 0 || defined(ULTRALCD) )
     case 300: // M300
     {
-      int beepS = 400;
-      int beepP = 1000;
-      if(code_seen('S')) beepS = code_value();
-      if(code_seen('P')) beepP = code_value();
-      #if BEEPER > 0
-        tone(BEEPER, beepS);
+      int beepS = code_seen('S') ? code_value() : 110;
+      int beepP = code_seen('P') ? code_value() : 1000;
+      if (beepS > 0)
+      {
+        #if BEEPER > 0
+          tone(BEEPER, beepS);
+          delay(beepP);
+          noTone(BEEPER);
+        #elif defined(ULTRALCD)
+          lcd_buzz(beepS, beepP);
+        #endif
+      }
+      else
+      {
         delay(beepP);
-        noTone(BEEPER);
-      #elif defined(ULTRALCD)
-        lcd_buzz(beepS, beepP);
-      #endif
+      }
     }
     break;
     #endif // M300
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 89a77b9..791c4bb 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -18,6 +18,8 @@ CardReader::CardReader()
    saving = false;
    logging = false;
    autostart_atmillis=0;
+   workDirDepth = 0;
+   memset(workDirParents, 0, sizeof(workDirParents));
 
    autostart_stilltocheck=true; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
    lastnr=0;
@@ -521,19 +523,24 @@ void CardReader::chdir(const char * relpath)
   }
   else
   {
-    workDirParentParent=workDirParent;
-    workDirParent=*parent;
-    
+    if (workDirDepth < MAX_DIR_DEPTH) {
+      for (int d = ++workDirDepth; d--;)
+        workDirParents[d+1] = workDirParents[d];
+      workDirParents[0]=*parent;
+    }
     workDir=newfile;
   }
 }
 
 void CardReader::updir()
 {
-  if(!workDir.isRoot())
+  if(workDirDepth > 0)
   {
-    workDir=workDirParent;
-    workDirParent=workDirParentParent;
+    --workDirDepth;
+    workDir = workDirParents[0];
+    int d;
+    for (int d = 0; d < workDirDepth; d++)
+      workDirParents[d] = workDirParents[d+1];
   }
 }
 
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index fe5c8b7..6e59645 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -3,6 +3,8 @@
 
 #ifdef SDSUPPORT
 
+#define MAX_DIR_DEPTH 10
+
 #include "SdFile.h"
 enum LsAction {LS_SerialPrint,LS_Count,LS_GetFilename};
 class CardReader
@@ -53,7 +55,8 @@ public:
   bool filenameIsDir;
   int lastnr; //last number of the autostart;
 private:
-  SdFile root,*curDir,workDir,workDirParent,workDirParentParent;
+  SdFile root,*curDir,workDir,workDirParents[MAX_DIR_DEPTH];
+  uint16_t workDirDepth;
   Sd2Card card;
   SdVolume volume;
   SdFile file;
diff --git a/Marlin/language.h b/Marlin/language.h
index 6079ba7..796e177 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -3,13 +3,13 @@
 
 // NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES
 //
-//   ==&gt; ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
-//   ==&gt; ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
+//   ==> ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
+//   ==> ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
 
 // Languages
 // 1  English
 // 2  Polish
-// 3  French	(awaiting translation!)
+// 3  French
 // 4  German
 // 5  Spanish
 // 6  Russian
@@ -29,8 +29,15 @@
 #elif MOTHERBOARD == 80
 	#define MACHINE_NAME "Rumba"
 	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
+#elif MOTHERBOARD == 77
+	#define MACHINE_NAME "3Drag"
+	#define FIRMWARE_URL "http://3dprint.elettronicain.it/"
 #else
-	#define MACHINE_NAME "Mendel"
+	#ifdef CUSTOM_MENDEL_NAME
+		#define MACHINE_NAME CUSTOM_MENDEL_NAME
+	#else
+		#define MACHINE_NAME "Mendel"
+	#endif
 	#define FIRMWARE_URL "http://www.mendel-parts.com"
 #endif
 
@@ -188,7 +195,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
 
-	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
+	#define MSG_STEPPER_TOO_HIGH "Steprate too high: "
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
@@ -348,7 +355,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
 
-	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
+	#define MSG_STEPPER_TOO_HIGH "Za duza czestotliwosc krokow: "
 	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
@@ -512,7 +519,7 @@
 #define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
 #define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
 
-#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
+#define MSG_STEPPER_TOO_HIGH "Steprate trop eleve: "
 #define MSG_ENDSTOPS_HIT "Fin de course atteint: "
 #define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
 #define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
@@ -674,7 +681,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
 
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
+	#define MSG_STEPPER_TOO_HIGH "Steprate too high : "
 	#define MSG_ENDSTOPS_HIT "endstops hit: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
@@ -702,9 +709,9 @@
 #define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
 #define MSG_MOVE_AXIS " Mover Ejes      \x7E"
 #define MSG_SPEED " Velocidad:"
-#define MSG_NOZZLE " \002Nozzle:"
-#define MSG_NOZZLE1 " \002Nozzle2:"
-#define MSG_NOZZLE2 " \002Nozzle3:"
+#define MSG_NOZZLE " \002Fusor:"
+#define MSG_NOZZLE1 " \002Fusor2:"
+#define MSG_NOZZLE2 " \002Fusor3:"
 #define MSG_BED " \002Base:"
 #define MSG_FAN_SPEED " Ventilador:"
 #define MSG_FLOW " Flujo:"
@@ -720,9 +727,9 @@
 #define MSG_PID_D " PID-D: "
 #define MSG_PID_C " PID-C: "
 #define MSG_ACC  " Acc:"
-#define MSG_VXY_JERK " Vxy-jerk: "
-#define MSG_VZ_JERK "Vz-jerk"
-#define MSG_VE_JERK "Ve-jerk"
+#define MSG_VXY_JERK " Vxy-agit: "
+#define MSG_VZ_JERK "Vz-agit"
+#define MSG_VE_JERK "Ve-agit"
 #define MSG_VMAX " Vmax "
 #define MSG_X "x:"
 #define MSG_Y "y:"
@@ -817,7 +824,7 @@
 #define MSG_M119_REPORT "Comprobando fines de carrera."
 #define MSG_ENDSTOP_HIT "PULSADO"
 #define MSG_ENDSTOP_OPEN "abierto"
-#define MSG_HOTEND_OFFSET "Hotend offsets:"
+#define MSG_HOTEND_OFFSET "Despl. Hotend:"
         
 #define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
 #define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
@@ -835,7 +842,7 @@
 #define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
 #define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
 
-#define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
+#define MSG_STEPPER_TOO_HIGH "Steprate demasiado alto : "
 #define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
 #define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
 #define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
@@ -989,7 +996,7 @@
 #define MSG_SD_NOT_PRINTING					"нет SD печати"
 #define MSG_SD_ERR_WRITE_TO_FILE			"ошибка записи в файл"
 #define MSG_SD_CANT_ENTER_SUBDIR			"Не зайти в папку:"
-#define MSG_STEPPER_TO_HIGH					"Частота шагов очень высока : "
+#define MSG_STEPPER_TOO_HIGH				"Частота шагов очень высока : "
 #define MSG_ENDSTOPS_HIT					"концевик сработал: "
 #define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
 #define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
@@ -1000,7 +1007,7 @@
 #if LANGUAGE_CHOICE == 7
 
 	// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronto."
+	#define WELCOME_MSG MACHINE_NAME " Pronta"
 	#define MSG_SD_INSERTED          "SD Card inserita"
 	#define MSG_SD_REMOVED           "SD Card rimossa"
 	#define MSG_MAIN                 "Menu principale"
@@ -1012,7 +1019,7 @@
 	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"
 	#define MSG_PREHEAT_ABS          "Preriscalda ABS"
 	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"
-	#define MSG_COOLDOWN             "Rafredda"
+	#define MSG_COOLDOWN             "Raffredda"
 	#define MSG_EXTRUDE              "Estrudi"
 	#define MSG_RETRACT              "Ritrai"
 	#define MSG_MOVE_AXIS            "Muovi Asse"
@@ -1149,7 +1156,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
 
-	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto: "
+	#define MSG_STEPPER_TOO_HIGH     "Steprate troppo alto: "
 	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
@@ -1246,8 +1253,8 @@
 	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
 	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
 	#define MSG_AUTORETRACT " AutoRetr.:"
-        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
-        #define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
+	#define MSG_FILAMENTCHANGE "Change filament"
 
 // Serial Console Messages
 
@@ -1315,7 +1322,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
 
-	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
+	#define MSG_STEPPER_TOO_HIGH "Steprate muito alto : "
 	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
@@ -1476,7 +1483,7 @@
 	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
 	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
 
-	#define MSG_STEPPER_TO_HIGH "Askellustaajuus liian suuri: "
+	#define MSG_STEPPER_TOO_HIGH "Askellustaajuus liian suuri: "
 	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
 	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
 	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 7a8bdf2..ee0e3db 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -228,8 +228,8 @@
 #endif
 
 //x axis pins
-    #define X_STEP_PIN      21                  //different from stanard GEN7
-    #define X_DIR_PIN       20            //different from stanard GEN7
+    #define X_STEP_PIN      21                  // different from standard GEN7
+    #define X_DIR_PIN       20                  // different from standard GEN7
     #define X_ENABLE_PIN    24
     #define X_STOP_PIN      0
 
@@ -298,7 +298,7 @@
 * Arduino Mega pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
+#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 77
 #define KNOWN_BOARD 1
 
 //////////////////FIX THIS//////////////
@@ -308,47 +308,89 @@
  #endif
 #endif
 
+
 // uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
 // #define RAMPS_V_1_3
 // #define RAMPS_V_1_0
 
-#if MOTHERBOARD == 33 || MOTHERBOARD == 34
-
-  #define LARGE_FLASH        true
-
-  #define X_STEP_PIN         54
-  #define X_DIR_PIN          55
-  #define X_ENABLE_PIN       38
-  #define X_MIN_PIN           3
-  #define X_MAX_PIN           2
-
-  #define Y_STEP_PIN         60
-  #define Y_DIR_PIN          61
-  #define Y_ENABLE_PIN       56
-  #define Y_MIN_PIN          14
-  #define Y_MAX_PIN          15
-
-  #define Z_STEP_PIN         46
-  #define Z_DIR_PIN          48
-  #define Z_ENABLE_PIN       62
-  #define Z_MIN_PIN          18
-  #define Z_MAX_PIN          19
 
-  #define Z2_STEP_PIN        36
-  #define Z2_DIR_PIN         34
-  #define Z2_ENABLE_PIN      30
+#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 77
 
-  #define E0_STEP_PIN        26
-  #define E0_DIR_PIN         28
-  #define E0_ENABLE_PIN      24
+  #define LARGE_FLASH true
+  
+  #if MOTHERBOARD == 77
+    #define X_STEP_PIN         54
+    #define X_DIR_PIN          55
+    #define X_ENABLE_PIN       38
+    #define X_MIN_PIN           3
+    #define X_MAX_PIN           -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+    #define Y_STEP_PIN         60
+    #define Y_DIR_PIN          61
+    #define Y_ENABLE_PIN       56
+    #define Y_MIN_PIN          14
+    #define Y_MAX_PIN          -1   //15
+
+    #define Z_STEP_PIN         46
+    #define Z_DIR_PIN          48
+    #define Z_ENABLE_PIN       63
+    #define Z_MIN_PIN          18
+    #define Z_MAX_PIN          -1
+
+    #define Z2_STEP_PIN        36
+    #define Z2_DIR_PIN         34
+    #define Z2_ENABLE_PIN      30
+
+    #define E0_STEP_PIN        26
+    #define E0_DIR_PIN         28
+    #define E0_ENABLE_PIN      24
+
+    #define E1_STEP_PIN        36
+    #define E1_DIR_PIN         34
+    #define E1_ENABLE_PIN      30
+
+    #define SDPOWER            -1
+    #define SDSS               25//53
+    #define LED_PIN            13
+
+    #define BEEPER             33    
 
-  #define E1_STEP_PIN        36
-  #define E1_DIR_PIN         34
-  #define E1_ENABLE_PIN      30
+  #else
 
-  #define SDPOWER            -1
-  #define SDSS               53
-  #define LED_PIN            13
+    #define X_STEP_PIN         54
+    #define X_DIR_PIN          55
+    #define X_ENABLE_PIN       38
+    #define X_MIN_PIN           3
+    #define X_MAX_PIN           2
+
+    #define Y_STEP_PIN         60
+    #define Y_DIR_PIN          61
+    #define Y_ENABLE_PIN       56
+    #define Y_MIN_PIN          14
+    #define Y_MAX_PIN          15
+
+    #define Z_STEP_PIN         46
+    #define Z_DIR_PIN          48
+    #define Z_ENABLE_PIN       62
+    #define Z_MIN_PIN          18
+    #define Z_MAX_PIN          19
+
+    #define Z2_STEP_PIN        36
+    #define Z2_DIR_PIN         34
+    #define Z2_ENABLE_PIN      30
+
+    #define E0_STEP_PIN        26
+    #define E0_DIR_PIN         28
+    #define E0_ENABLE_PIN      24
+
+    #define E1_STEP_PIN        36
+    #define E1_DIR_PIN         34
+    #define E1_ENABLE_PIN      30
+
+    #define SDPOWER            -1
+    #define SDSS               53
+    #define LED_PIN            13
+  #endif
 
   #if MOTHERBOARD == 33
     #define FAN_PIN            9 // (Sprinter config)
@@ -356,6 +398,10 @@
     #define FAN_PIN            4 // IO pin. Buffer needed
   #endif
 
+  #if MOTHERBOARD == 77
+    #define FAN_PIN            8 
+  #endif
+
   #define PS_ON_PIN          12
 
   #if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
@@ -365,18 +411,27 @@
   #endif
 
   #define HEATER_0_PIN       10   // EXTRUDER 1
-
-  #if MOTHERBOARD == 33
+  #if MOTHERBOARD == 33 
     #define HEATER_1_PIN       -1
   #else
     #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
   #endif
+  #define HEATER_2_PIN       -1 
+
+  #if MOTHERBOARD == 77
+    #define HEATER_0_PIN       10   
+    #define HEATER_1_PIN       12 
+    #define HEATER_2_PIN       6   
+  #endif
 
-  #define HEATER_2_PIN       -1
   #define TEMP_0_PIN         13   // ANALOG NUMBERING
   #define TEMP_1_PIN         15   // ANALOG NUMBERING
   #define TEMP_2_PIN         -1   // ANALOG NUMBERING
-  #define HEATER_BED_PIN     8    // BED
+  #if MOTHERBOARD == 77
+    #define HEATER_BED_PIN     9    // BED
+  #else
+    #define HEATER_BED_PIN     8    // BED
+  #endif
   #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
 
@@ -403,7 +458,7 @@
       #define LCD_PINS_RS 16 
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25
+      #define LCD_PINS_D5 25 
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
 
@@ -440,22 +495,23 @@
         #endif
     
       #endif
+    
 
     #else //old style panel with shift register
       //arduino pin witch triggers an piezzo beeper
-      #define BEEPER 33   // No Beeper added 
+      #define BEEPER 33		//No Beeper added
 
       //buttons are attached to a shift register
-      // Not wired this yet
+	// Not wired this yet
       //#define SHIFT_CLK 38
       //#define SHIFT_LD 42
       //#define SHIFT_OUT 40
       //#define SHIFT_EN 17
-
-      #define LCD_PINS_RS 16
+    
+      #define LCD_PINS_RS 16 
       #define LCD_PINS_ENABLE 17
       #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25
+      #define LCD_PINS_D5 25 
       #define LCD_PINS_D6 27
       #define LCD_PINS_D7 29
     #endif 
@@ -463,57 +519,56 @@
 
 #else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
 
-  #define X_STEP_PIN         26
-  #define X_DIR_PIN          28
-  #define X_ENABLE_PIN       24
-  #define X_MIN_PIN           3
-  #define X_MAX_PIN          -1    //2
-
-  #define Y_STEP_PIN         38
-  #define Y_DIR_PIN          40
-  #define Y_ENABLE_PIN       36
-  #define Y_MIN_PIN          16
-  #define Y_MAX_PIN          -1    //17
-
-  #define Z_STEP_PIN         44
-  #define Z_DIR_PIN          46
-  #define Z_ENABLE_PIN       42
-  #define Z_MIN_PIN          18
-  #define Z_MAX_PIN          -1    //19
-
-  #define E0_STEP_PIN         32
-  #define E0_DIR_PIN          34
-  #define E0_ENABLE_PIN       30
-
-  #define SDPOWER            48
-  #define SDSS               53
-  #define LED_PIN            13
-  #define PS_ON_PIN          -1
-  #define KILL_PIN           -1
-
-  #ifdef RAMPS_V_1_0 // RAMPS_V_1_0
-    #define HEATER_0_PIN     12    // RAMPS 1.0
-    #define HEATER_BED_PIN   -1    // RAMPS 1.0
-    #define FAN_PIN          11    // RAMPS 1.0
-  #else // RAMPS_V_1_1 or RAMPS_V_1_2
-    #define HEATER_0_PIN     10    // RAMPS 1.1
-    #define HEATER_BED_PIN    8    // RAMPS 1.1
-    #define FAN_PIN           9    // RAMPS 1.1
-  #endif
+#define X_STEP_PIN         26
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       24
+#define X_MIN_PIN           3
+#define X_MAX_PIN          -1    //2
+
+#define Y_STEP_PIN         38
+#define Y_DIR_PIN          40
+#define Y_ENABLE_PIN       36
+#define Y_MIN_PIN          16
+#define Y_MAX_PIN          -1    //17
+
+#define Z_STEP_PIN         44
+#define Z_DIR_PIN          46
+#define Z_ENABLE_PIN       42
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          -1    //19
 
-  #define HEATER_1_PIN        -1
-  #define HEATER_2_PIN        -1
-  #define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-  #define TEMP_1_PIN          -1
-  #define TEMP_2_PIN          -1
-  #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define E0_STEP_PIN         32
+#define E0_DIR_PIN          34
+#define E0_ENABLE_PIN       30
 
-#endif// MOTHERBOARD == 33 || MOTHERBOARD == 34
+#define SDPOWER            48
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
 
-// SPI for Max6675 Thermocouple
+#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
+  #define HEATER_0_PIN     12    // RAMPS 1.0
+  #define HEATER_BED_PIN   -1    // RAMPS 1.0
+  #define FAN_PIN          11    // RAMPS 1.0
+#else // RAMPS_V_1_1 or RAMPS_V_1_2
+  #define HEATER_0_PIN     10    // RAMPS 1.1
+  #define HEATER_BED_PIN    8    // RAMPS 1.1
+  #define FAN_PIN           9    // RAMPS 1.1
+#endif
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN          -1   
+#define TEMP_2_PIN          -1   
+#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+
+#endif // MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 77
+
+// SPI for Max6675 Thermocouple 
 
 #ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support
+// these pins are defined in the SD library if building with SD support  
   #define MAX_SCK_PIN          52
   #define MAX_MISO_PIN         50
   #define MAX_MOSI_PIN         51
@@ -522,7 +577,9 @@
   #define MAX6675_SS       49
 #endif
 
-#endif//MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
+#endif //MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 77
+
+
 
 /****************************************************************************************
 * Duemilanove w/ ATMega328P pin assignment
@@ -1974,5 +2031,3 @@
                         analogInputToDigitalPin(TEMP_0_PIN), analogInputToDigitalPin(TEMP_1_PIN), analogInputToDigitalPin(TEMP_2_PIN), analogInputToDigitalPin(TEMP_BED_PIN) }
 #endif
 
-
-
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index fcebab9..8eff191 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -473,22 +473,24 @@ void check_axes_activity()
     disable_e2(); 
   }
 #if defined(FAN_PIN) && FAN_PIN > -1
-  #ifndef FAN_SOFT_PWM
-    #ifdef FAN_KICKSTART_TIME
-      static unsigned long fan_kick_end;
-      if (tail_fan_speed) {
-        if (fan_kick_end == 0) {
-          // Just starting up fan - run at full power.
-          fan_kick_end = millis() + FAN_KICKSTART_TIME;
-          tail_fan_speed = 255;
-        } else if (fan_kick_end > millis())
-          // Fan still spinning up.
-          tail_fan_speed = 255;
-      } else {
-        fan_kick_end = 0;
-      }
-    #endif//FAN_KICKSTART_TIME
-    analogWrite(FAN_PIN,tail_fan_speed);
+  #ifdef FAN_KICKSTART_TIME
+    static unsigned long fan_kick_end;
+    if (tail_fan_speed) {
+      if (fan_kick_end == 0) {
+        // Just starting up fan - run at full power.
+        fan_kick_end = millis() + FAN_KICKSTART_TIME;
+        tail_fan_speed = 255;
+      } else if (fan_kick_end > millis())
+        // Fan still spinning up.
+        tail_fan_speed = 255;
+    } else {
+      fan_kick_end = 0;
+    }
+  #endif//FAN_KICKSTART_TIME
+  #ifdef FAN_SOFT_PWM
+  fanSpeedSoftPwm = tail_fan_speed;
+  #else
+  analogWrite(FAN_PIN,tail_fan_speed);
   #endif//!FAN_SOFT_PWM
 #endif//FAN_PIN > -1
 #ifdef AUTOTEMP
@@ -562,8 +564,16 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   block->busy = false;
 
   // Number of steps for each axis
-  block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
-  block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
+#ifndef COREXY
+// default non-h-bot planning
+block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
+block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
+#else
+// corexy planning
+// these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
+block->steps_x = labs((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]));
+block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]));
+#endif
   block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
   block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
   block->steps_e *= extrudemultiply;
@@ -584,6 +594,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 
   // Compute direction bits for this block 
   block->direction_bits = 0;
+#ifndef COREXY
   if (target[X_AXIS] < position[X_AXIS])
   {
     block->direction_bits |= (1<<X_AXIS); 
@@ -592,6 +603,16 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   {
     block->direction_bits |= (1<<Y_AXIS); 
   }
+#else
+  if ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]) < 0)
+  {
+    block->direction_bits |= (1<<X_AXIS); 
+  }
+  if ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]) < 0)
+  {
+    block->direction_bits |= (1<<Y_AXIS); 
+  }
+#endif
   if (target[Z_AXIS] < position[Z_AXIS])
   {
     block->direction_bits |= (1<<Z_AXIS); 
@@ -636,8 +657,13 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   } 
 
   float delta_mm[4];
-  delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
-  delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
+  #ifndef COREXY
+    delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
+    delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
+  #else
+    delta_mm[X_AXIS] = ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[X_AXIS];
+    delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];
+  #endif
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
   if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
@@ -757,7 +783,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
       block->acceleration_st = axis_steps_per_sqr_second[Z_AXIS];
   }
   block->acceleration = block->acceleration_st / steps_per_mm;
-  block->acceleration_rate = (long)((float)block->acceleration_st * 8.388608);
+  block->acceleration_rate = (long)((float)block->acceleration_st * (16777216.0 / (F_CPU / 8.0)));
 
 #if 0  // Use old jerk for now
   // Compute path unit vector
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 6a012b5..a799150 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -272,7 +272,7 @@ FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
     timer = (unsigned short)pgm_read_word_near(table_address);
     timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))>>3);
   }
-  if(timer < 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)
+  if(timer < 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TOO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)
   return timer;
 }
 
@@ -345,12 +345,31 @@ ISR(TIMER1_COMPA_vect)
     // Set directions TO DO This should be done once during init of trapezoid. Endstops -> interrupt
     out_bits = current_block->direction_bits;
 
+
+    // Set the direction bits (X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY)
+    if((out_bits & (1<<X_AXIS))!=0){
+      WRITE(X_DIR_PIN, INVERT_X_DIR);
+      count_direction[X_AXIS]=-1;
+    }
+    else{
+      WRITE(X_DIR_PIN, !INVERT_X_DIR);
+      count_direction[X_AXIS]=1;
+    }
+    if((out_bits & (1<<Y_AXIS))!=0){
+      WRITE(Y_DIR_PIN, INVERT_Y_DIR);
+      count_direction[Y_AXIS]=-1;
+    }
+    else{
+      WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
+      count_direction[Y_AXIS]=1;
+    }
+    
     // Set direction en check limit switches
+    #ifndef COREXY
     if ((out_bits & (1<<X_AXIS)) != 0) {   // stepping along -X axis
-      #if !defined COREXY  //NOT COREXY
-        WRITE(X_DIR_PIN, INVERT_X_DIR);
-      #endif
-      count_direction[X_AXIS]=-1;
+    #else
+    if ((((out_bits & (1<<X_AXIS)) != 0)&&(out_bits & (1<<Y_AXIS)) != 0)) {   //-X occurs for -A and -B
+    #endif
       CHECK_ENDSTOPS
       {
         #if defined(X_MIN_PIN) && X_MIN_PIN > -1
@@ -365,11 +384,6 @@ ISR(TIMER1_COMPA_vect)
       }
     }
     else { // +direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(X_DIR_PIN,!INVERT_X_DIR);
-      #endif
-      
-      count_direction[X_AXIS]=1;
       CHECK_ENDSTOPS 
       {
         #if defined(X_MAX_PIN) && X_MAX_PIN > -1
@@ -384,11 +398,11 @@ ISR(TIMER1_COMPA_vect)
       }
     }
 
+    #ifndef COREXY
     if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(Y_DIR_PIN,INVERT_Y_DIR);
-      #endif
-      count_direction[Y_AXIS]=-1;
+    #else
+    if ((((out_bits & (1<<X_AXIS)) != 0)&&(out_bits & (1<<Y_AXIS)) == 0)) {   // -Y occurs for -A and +B
+    #endif
       CHECK_ENDSTOPS
       {
         #if defined(Y_MIN_PIN) && Y_MIN_PIN > -1
@@ -403,10 +417,6 @@ ISR(TIMER1_COMPA_vect)
       }
     }
     else { // +direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(Y_DIR_PIN,!INVERT_Y_DIR);
-      #endif
-      count_direction[Y_AXIS]=1;
       CHECK_ENDSTOPS
       {
         #if defined(Y_MAX_PIN) && Y_MAX_PIN > -1
@@ -420,28 +430,7 @@ ISR(TIMER1_COMPA_vect)
         #endif
       }
     }
-    
-    
-    #ifdef COREXY  //coreXY kinematics defined
-      if((current_block->steps_x >= current_block->steps_y)&&((out_bits & (1<<X_AXIS)) == 0)){  //+X is major axis
-        WRITE(X_DIR_PIN, !INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
-      }
-      if((current_block->steps_x >= current_block->steps_y)&&((out_bits & (1<<X_AXIS)) != 0)){  //-X is major axis
-        WRITE(X_DIR_PIN, INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, INVERT_Y_DIR);
-      }      
-      if((current_block->steps_y > current_block->steps_x)&&((out_bits & (1<<Y_AXIS)) == 0)){  //+Y is major axis
-        WRITE(X_DIR_PIN, !INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, INVERT_Y_DIR);
-      }        
-      if((current_block->steps_y > current_block->steps_x)&&((out_bits & (1<<Y_AXIS)) != 0)){  //-Y is major axis
-        WRITE(X_DIR_PIN, INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
-      }  
-    #endif //coreXY
-    
-    
+
     if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
       WRITE(Z_DIR_PIN,INVERT_Z_DIR);
       
@@ -516,7 +505,6 @@ ISR(TIMER1_COMPA_vect)
       }    
       #endif //ADVANCE
 
-      #if !defined COREXY      
         counter_x += current_block->steps_x;
         if (counter_x > 0) {
           WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
@@ -532,56 +520,7 @@ ISR(TIMER1_COMPA_vect)
           count_position[Y_AXIS]+=count_direction[Y_AXIS]; 
           WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
         }
-      #endif
   
-      #ifdef COREXY
-        counter_x += current_block->steps_x;        
-        counter_y += current_block->steps_y;
-        
-        if ((counter_x > 0)&&!(counter_y>0)){  //X step only
-          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-          counter_x -= current_block->step_event_count; 
-          count_position[X_AXIS]+=count_direction[X_AXIS];         
-          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-        }
-        
-        if (!(counter_x > 0)&&(counter_y>0)){  //Y step only
-          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-          counter_y -= current_block->step_event_count; 
-          count_position[Y_AXIS]+=count_direction[Y_AXIS];
-          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-        }        
-        
-        if ((counter_x > 0)&&(counter_y>0)){  //step in both axes
-          if (((out_bits & (1<<X_AXIS)) == 0)^((out_bits & (1<<Y_AXIS)) == 0)){  //X and Y in different directions
-            WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-            counter_x -= current_block->step_event_count;             
-            WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-            step_wait();
-            count_position[X_AXIS]+=count_direction[X_AXIS];
-            count_position[Y_AXIS]+=count_direction[Y_AXIS];
-            WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-            counter_y -= current_block->step_event_count;
-            WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-          }
-          else{  //X and Y in same direction
-            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-            counter_x -= current_block->step_event_count;             
-            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN) ;
-            step_wait();
-            count_position[X_AXIS]+=count_direction[X_AXIS];
-            count_position[Y_AXIS]+=count_direction[Y_AXIS];
-            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN); 
-            counter_y -= current_block->step_event_count;    
-            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);        
-          }
-        }
-      #endif //corexy
-      
       counter_z += current_block->steps_z;
       if (counter_z > 0) {
         WRITE(Z_STEP_PIN, !INVERT_Z_STEP_PIN);
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index b7c39f8..f5df7a1 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -62,6 +62,9 @@ float current_temperature_bed = 0.0;
   float bedKd=(DEFAULT_bedKd/PID_dT);
 #endif //PIDTEMPBED
   
+#ifdef FAN_SOFT_PWM
+  unsigned char fanSpeedSoftPwm;
+#endif
   
 //===========================================================================
 //=============================private variables============================
@@ -145,6 +148,10 @@ int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
 unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
 #endif //WATCH_TEMP_PERIOD
 
+#ifndef SOFT_PWM_SCALE
+#define SOFT_PWM_SCALE 0
+#endif
+
 //===========================================================================
 //=============================   functions      ============================
 //===========================================================================
@@ -269,7 +276,7 @@ void PID_autotune(float temp, int extruder, int ncycles)
       } 
     }
     if(input > (temp + 20)) {
-      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature to high");
+      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature too high");
       return;
     }
     if(millis() - temp_millis > 2000) {
@@ -293,7 +300,7 @@ void PID_autotune(float temp, int extruder, int ncycles)
       return;
     }
     if(cycles > ncycles) {
-      SERIAL_PROTOCOLLNPGM("PID Autotune finished ! Place the Kp, Ki and Kd constants in the configuration.h");
+      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the Kp, Ki and Kd constants into Configuration.h");
       return;
     }
     lcd_update();
@@ -720,8 +727,8 @@ void tp_init()
     setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
     #ifdef FAN_SOFT_PWM
-	soft_pwm_fan=(unsigned char)fanSpeed;
-	#endif
+    soft_pwm_fan = fanSpeedSoftPwm / 2;
+    #endif
   #endif  
 
   #ifdef HEATER_0_USES_MAX6675
@@ -1021,14 +1028,14 @@ int read_max6675()
 // Timer 0 is shared with millies
 ISR(TIMER0_COMPB_vect)
 {
-  //these variables are only accesible from the ISR, but static, so they don't loose their value
+  //these variables are only accesible from the ISR, but static, so they don't lose their value
   static unsigned char temp_count = 0;
   static unsigned long raw_temp_0_value = 0;
   static unsigned long raw_temp_1_value = 0;
   static unsigned long raw_temp_2_value = 0;
   static unsigned long raw_temp_bed_value = 0;
   static unsigned char temp_state = 0;
-  static unsigned char pwm_count = 1;
+  static unsigned char pwm_count = (1 << SOFT_PWM_SCALE);
   static unsigned char soft_pwm_0;
   #if EXTRUDERS > 1
   static unsigned char soft_pwm_1;
@@ -1056,7 +1063,7 @@ ISR(TIMER0_COMPB_vect)
     if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1);
     #endif
     #ifdef FAN_SOFT_PWM
-    soft_pwm_fan =(unsigned char) fanSpeed;
+    soft_pwm_fan = fanSpeedSoftPwm / 2;
     if(soft_pwm_fan > 0) WRITE(FAN_PIN,1);
     #endif
   }
@@ -1074,7 +1081,7 @@ ISR(TIMER0_COMPB_vect)
   if(soft_pwm_fan <= pwm_count) WRITE(FAN_PIN,0);
   #endif
   
-  pwm_count++;
+  pwm_count += (1 << SOFT_PWM_SCALE);
   pwm_count &= 0x7f;
   
   switch(temp_state) {
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index a025244..9be57a9 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -13,7 +13,7 @@ extern volatile uint16_t buttons;  //an extended version of the last checked but
 #endif
 
 ////////////////////////////////////
-// Setup button and encode mappings for each panel (into 'buttons' variable)
+// Setup button and encode mappings for each panel (into 'buttons' variable
 //
 // This is just to map common functions (across different panels) onto the same 
 // macro name. The mapping is independent of whether the button is directly connected or 
@@ -715,9 +715,9 @@ static void lcd_implementation_quick_feedback()
     for(int8_t i=0;i<10;i++)
     {
       WRITE(BEEPER,HIGH);
-      delay(3);
+      delayMicroseconds(100);
       WRITE(BEEPER,LOW);
-      delay(3);
+      delayMicroseconds(100);
     }
 #endif
 }
diff --git a/README.md b/README.md
index d73ff24..97c8477 100644
--- a/README.md
+++ b/README.md
@@ -1,249 +1,250 @@
-==========================
-Marlin 3D Printer Firmware
-==========================
-
-[![Flattr this git repo](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=ErikZalm&url=https://github.com/ErikZalm/Marlin&title=Marlin&language=&tags=github&category=software)
-
-Quick Information
-===================
-This RepRap firmware is a mashup between <a href="https://github.com/kliment/Sprinter">Sprinter</a>, <a href="https://github.com/simen/grbl/tree">grbl</a> and many original parts.
-
-Derived from Sprinter and Grbl by Erik van der Zalm.
-Sprinters lead developers are Kliment and caru.
-Grbls lead developer is Simen Svale Skogsrud. Sonney Jeon (Chamnit) improved some parts of grbl
-A fork by bkubicek for the Ultimaker was merged, and further development was aided by him.
-Some features have been added by:
-Lampmaker, Bradley Feldman, and others...
-
-
-Features:
-
-*   Interrupt based movement with real linear acceleration
-*   High steprate
-*   Look ahead (Keep the speed high when possible. High cornering speed)
-*   Interrupt based temperature protection
-*   preliminary support for Matthew Roberts advance algorithm 
-    For more info see: http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
-*   Full endstop support
-*   SD Card support
-*   SD Card folders (works in pronterface)
-*   SD Card autostart support
-*   LCD support (ideally 20x4) 
-*   LCD menu system for autonomous SD card printing, controlled by an click-encoder. 
-*   EEPROM storage of e.g. max-velocity, max-acceleration, and similar variables
-*   many small but handy things originating from bkubicek's fork.
-*   Arc support
-*   Temperature oversampling
-*   Dynamic Temperature setpointing aka "AutoTemp"
-*   Support for QTMarlin, a very beta GUI for PID-tuning and velocity-acceleration testing. https://github.com/bkubicek/QTMarlin
-*   Endstop trigger reporting to the host software.
-*   Updated sdcardlib
-*   Heater power reporting. Useful for PID monitoring.
-*   PID tuning
-*   CoreXY kinematics (www.corexy.com/theory.html)
-*   Configurable serial port to support connection of wireless adaptors.
-*   Automatic operation of extruder/cold-end cooling fans based on nozzle temperature
-
-The default baudrate is 250000. This baudrate has less jitter and hence errors than the usual 115200 baud, but is less supported by drivers and host-environments.
-
-
-Differences and additions to the already good Sprinter firmware:
-================================================================
-
-*Look-ahead:*
-
-Marlin has look-ahead. While sprinter has to break and re-accelerate at each corner, 
-lookahead will only decelerate and accelerate to a velocity, 
-so that the change in vectorial velocity magnitude is less than the xy_jerk_velocity.
-This is only possible, if some future moves are already processed, hence the name. 
-It leads to less over-deposition at corners, especially at flat angles.
-
-*Arc support:*
-
-Slic3r can find curves that, although broken into segments, were ment to describe an arc.
-Marlin is able to print those arcs. The advantage is the firmware can choose the resolution,
-and can perform the arc with nearly constant velocity, resulting in a nice finish. 
-Also, less serial communication is needed.
-
-*Temperature Oversampling:*
-
-To reduce noise and make the PID-differential term more useful, 16 ADC conversion results are averaged.
-
-*AutoTemp:*
-
-If your gcode contains a wide spread of extruder velocities, or you realtime change the building speed, the temperature should be changed accordingly.
-Usually, higher speed requires higher temperature.
-This can now be performed by the AutoTemp function
-By calling M109 S<mintemp> T<maxtemp> F<factor> you enter the autotemp mode.
-
-You can leave it by calling M109 without any F.
-If active, the maximal extruder stepper rate of all buffered moves will be calculated, and named "maxerate" [steps/sec].
-The wanted temperature then will be set to t=tempmin+factor*maxerate, while being limited between tempmin and tempmax.
-If the target temperature is set manually or by gcode to a value less then tempmin, it will be kept without change.
-Ideally, your gcode can be completely free of temperature controls, apart from a M109 S T F in the start.gcode, and a M109 S0 in the end.gcode.
-
-*EEPROM:*
-
-If you know your PID values, the acceleration and max-velocities of your unique machine, you can set them, and finally store them in the EEPROM.
-After each reboot, it will magically load them from EEPROM, independent what your Configuration.h says.
-
-*LCD Menu:*
-
-If your hardware supports it, you can build yourself a LCD-CardReader+Click+encoder combination. It will enable you to realtime tune temperatures,
-accelerations, velocities, flow rates, select and print files from the SD card, preheat, disable the steppers, and do other fancy stuff.
-One working hardware is documented here: http://www.thingiverse.com/thing:12663 
-Also, with just a 20x4 or 16x2 display, useful data is shown.
-
-*SD card folders:*
-
-If you have an SD card reader attached to your controller, also folders work now. Listing the files in pronterface will show "/path/subpath/file.g".
-You can write to file in a subfolder by specifying a similar text using small letters in the path.
-Also, backup copies of various operating systems are hidden, as well as files not ending with ".g".
-
-*SD card folders:*
-
-If you place a file auto[0-9].g into the root of the sd card, it will be automatically executed if you boot the printer. The same file will be executed by selecting "Autostart" from the menu.
-First *0 will be performed, than *1 and so on. That way, you can heat up or even print automatically without user interaction.
-
-*Endstop trigger reporting:*
-
-If an endstop is hit while moving towards the endstop, the location at which the firmware thinks that the endstop was triggered is outputed on the serial port.
-This is useful, because the user gets a warning message.
-However, also tools like QTMarlin can use this for finding acceptable combinations of velocity+acceleration.
-
-*Coding paradigm:*
-
-Not relevant from a user side, but Marlin was split into thematic junks, and has tried to partially enforced private variables.
-This is intended to make it clearer, what interacts which what, and leads to a higher level of modularization.
-We think that this is a useful prestep for porting this firmware to e.g. an ARM platform in the future.
-A lot of RAM (with enabled LCD ~2200 bytes) was saved by storing char []="some message" in Program memory.
-In the serial communication, a #define based level of abstraction was enforced, so that it is clear that
-some transfer is information (usually beginning with "echo:"), an error "error:", or just normal protocol,
-necessary for backwards compatibility.
-
-*Interrupt based temperature measurements:*
-
-An interrupt is used to manage ADC conversions, and enforce checking for critical temperatures.
-This leads to less blocking in the heater management routine.
-
-Implemented G Codes:
-====================
-
-*  G0  -> G1
-*  G1  - Coordinated Movement X Y Z E
-*  G2  - CW ARC
-*  G3  - CCW ARC
-*  G4  - Dwell S<seconds> or P<milliseconds>
-*  G10 - retract filament according to settings of M207
-*  G11 - retract recover filament according to settings of M208
-*  G28 - Home all Axis
-*  G90 - Use Absolute Coordinates
-*  G91 - Use Relative Coordinates
-*  G92 - Set current position to cordinates given
-
-RepRap M Codes
-*  M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
-*  M1   - Same as M0
-*  M104 - Set extruder target temp
-*  M105 - Read current temp
-*  M106 - Fan on
-*  M107 - Fan off
-*  M109 - Wait for extruder current temp to reach target temp.
-*  M114 - Display current position
-
-Custom M Codes
-*  M17  - Enable/Power all stepper motors
-*  M18  - Disable all stepper motors; same as M84
-*  M20  - List SD card
-*  M21  - Init SD card
-*  M22  - Release SD card
-*  M23  - Select SD file (M23 filename.g)
-*  M24  - Start/resume SD print
-*  M25  - Pause SD print
-*  M26  - Set SD position in bytes (M26 S12345)
-*  M27  - Report SD print status
-*  M28  - Start SD write (M28 filename.g)
-*  M29  - Stop SD write
-*  M30  - Delete file from SD (M30 filename.g)
-*  M31  - Output time since last M109 or SD card start to serial
-*  M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
-*  M80  - Turn on Power Supply
-*  M81  - Turn off Power Supply
-*  M82  - Set E codes absolute (default)
-*  M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-*  M84  - Disable steppers until next move, or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
-*  M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
-*  M92  - Set axis_steps_per_unit - same syntax as G92
-*  M114 - Output current position to serial port
-*  M115 - Capabilities string
-*  M117 - display message
-*  M119 - Output Endstop status to serial port
-*  M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
-*  M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
-*  M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
-*  M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
-*  M140 - Set bed target temp
-*  M190 - Wait for bed current temp to reach target temp.
-*  M200 - Set filament diameter
-*  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
-*  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-*  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-*  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-*  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
-*  M206 - set additional homeing offset
-*  M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
-*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
-*  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
-*  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
-*  M220 S<factor in percent>- set speed factor override percentage
-*  M221 S<factor in percent>- set extrude factor override percentage
-*  M240 - Trigger a camera to take a photograph
-*  M280 - set servo position absolute. P: servo index, S: angle or microseconds
-*  M300 - Play beepsound S<frequency Hz> P<duration ms>
-*  M301 - Set PID parameters P I and D
-*  M302 - Allow cold extrudes
-*  M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-*  M304 - Set bed PID parameters P I and D
-*  M400 - Finish all moves
-*  M500 - stores paramters in EEPROM
-*  M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
-*  M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-*  M503 - print the current settings (from memory not from eeprom)
-*  M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-*  M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
-*  M907 - Set digital trimpot motor current using axis codes.
-*  M908 - Control digital trimpot directly.
-*  M350 - Set microstepping mode.
-*  M351 - Toggle MS1 MS2 pins directly.
-*  M928 - Start SD logging (M928 filename.g) - ended by M29
-*  M999 - Restart after being stopped by error
-
-
-Configuring and compilation:
-============================
-
-Install the arduino software IDE/toolset v23 (Some configurations also work with 1.x.x)
-   http://www.arduino.cc/en/Main/Software
-
-For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
-  copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
-
-Copy the Marlin firmware
-   https://github.com/ErikZalm/Marlin/tree/Marlin_v1
-   (Use the download button)
-
-Start the arduino IDE.
-Select Tools -> Board -> Arduino Mega 2560    or your microcontroller
-Select the correct serial port in Tools ->Serial Port
-Open Marlin.pde
-
-Click the Verify/Compile button
-
-Click the Upload button
-If all goes well the firmware is uploading
-
-That's ok.  Enjoy Silky Smooth Printing.
-
-
-
-
+==========================
+Marlin 3D Printer Firmware
+==========================
+
+[![Flattr this git repo](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=ErikZalm&url=https://github.com/ErikZalm/Marlin&title=Marlin&language=&tags=github&category=software)
+
+Quick Information
+===================
+This RepRap firmware is a mashup between <a href="https://github.com/kliment/Sprinter">Sprinter</a>, <a href="https://github.com/simen/grbl/tree">grbl</a> and many original parts.
+
+Derived from Sprinter and Grbl by Erik van der Zalm.
+Sprinters lead developers are Kliment and caru.
+Grbls lead developer is Simen Svale Skogsrud. Sonney Jeon (Chamnit) improved some parts of grbl
+A fork by bkubicek for the Ultimaker was merged, and further development was aided by him.
+Some features have been added by:
+Lampmaker, Bradley Feldman, and others...
+
+
+Features:
+
+*   Interrupt based movement with real linear acceleration
+*   High steprate
+*   Look ahead (Keep the speed high when possible. High cornering speed)
+*   Interrupt based temperature protection
+*   preliminary support for Matthew Roberts advance algorithm
+    For more info see: http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
+*   Full endstop support
+*   SD Card support
+*   SD Card folders (works in pronterface)
+*   SD Card autostart support
+*   LCD support (ideally 20x4)
+*   LCD menu system for autonomous SD card printing, controlled by an click-encoder.
+*   EEPROM storage of e.g. max-velocity, max-acceleration, and similar variables
+*   many small but handy things originating from bkubicek's fork.
+*   Arc support
+*   Temperature oversampling
+*   Dynamic Temperature setpointing aka "AutoTemp"
+*   Support for QTMarlin, a very beta GUI for PID-tuning and velocity-acceleration testing. https://github.com/bkubicek/QTMarlin
+*   Endstop trigger reporting to the host software.
+*   Updated sdcardlib
+*   Heater power reporting. Useful for PID monitoring.
+*   PID tuning
+*   CoreXY kinematics (www.corexy.com/theory.html)
+*   Configurable serial port to support connection of wireless adaptors.
+*   Automatic operation of extruder/cold-end cooling fans based on nozzle temperature
+*   RC Servo Support, specify angle or duration for continuous rotation servos.
+
+The default baudrate is 250000. This baudrate has less jitter and hence errors than the usual 115200 baud, but is less supported by drivers and host-environments.
+
+
+Differences and additions to the already good Sprinter firmware:
+================================================================
+
+*Look-ahead:*
+
+Marlin has look-ahead. While sprinter has to break and re-accelerate at each corner,
+lookahead will only decelerate and accelerate to a velocity,
+so that the change in vectorial velocity magnitude is less than the xy_jerk_velocity.
+This is only possible, if some future moves are already processed, hence the name.
+It leads to less over-deposition at corners, especially at flat angles.
+
+*Arc support:*
+
+Slic3r can find curves that, although broken into segments, were ment to describe an arc.
+Marlin is able to print those arcs. The advantage is the firmware can choose the resolution,
+and can perform the arc with nearly constant velocity, resulting in a nice finish.
+Also, less serial communication is needed.
+
+*Temperature Oversampling:*
+
+To reduce noise and make the PID-differential term more useful, 16 ADC conversion results are averaged.
+
+*AutoTemp:*
+
+If your gcode contains a wide spread of extruder velocities, or you realtime change the building speed, the temperature should be changed accordingly.
+Usually, higher speed requires higher temperature.
+This can now be performed by the AutoTemp function
+By calling M109 S<mintemp> T<maxtemp> F<factor> you enter the autotemp mode.
+
+You can leave it by calling M109 without any F.
+If active, the maximal extruder stepper rate of all buffered moves will be calculated, and named "maxerate" [steps/sec].
+The wanted temperature then will be set to t=tempmin+factor*maxerate, while being limited between tempmin and tempmax.
+If the target temperature is set manually or by gcode to a value less then tempmin, it will be kept without change.
+Ideally, your gcode can be completely free of temperature controls, apart from a M109 S T F in the start.gcode, and a M109 S0 in the end.gcode.
+
+*EEPROM:*
+
+If you know your PID values, the acceleration and max-velocities of your unique machine, you can set them, and finally store them in the EEPROM.
+After each reboot, it will magically load them from EEPROM, independent what your Configuration.h says.
+
+*LCD Menu:*
+
+If your hardware supports it, you can build yourself a LCD-CardReader+Click+encoder combination. It will enable you to realtime tune temperatures,
+accelerations, velocities, flow rates, select and print files from the SD card, preheat, disable the steppers, and do other fancy stuff.
+One working hardware is documented here: http://www.thingiverse.com/thing:12663
+Also, with just a 20x4 or 16x2 display, useful data is shown.
+
+*SD card folders:*
+
+If you have an SD card reader attached to your controller, also folders work now. Listing the files in pronterface will show "/path/subpath/file.g".
+You can write to file in a subfolder by specifying a similar text using small letters in the path.
+Also, backup copies of various operating systems are hidden, as well as files not ending with ".g".
+
+*SD card folders:*
+
+If you place a file auto[0-9].g into the root of the sd card, it will be automatically executed if you boot the printer. The same file will be executed by selecting "Autostart" from the menu.
+First *0 will be performed, than *1 and so on. That way, you can heat up or even print automatically without user interaction.
+
+*Endstop trigger reporting:*
+
+If an endstop is hit while moving towards the endstop, the location at which the firmware thinks that the endstop was triggered is outputed on the serial port.
+This is useful, because the user gets a warning message.
+However, also tools like QTMarlin can use this for finding acceptable combinations of velocity+acceleration.
+
+*Coding paradigm:*
+
+Not relevant from a user side, but Marlin was split into thematic junks, and has tried to partially enforced private variables.
+This is intended to make it clearer, what interacts which what, and leads to a higher level of modularization.
+We think that this is a useful prestep for porting this firmware to e.g. an ARM platform in the future.
+A lot of RAM (with enabled LCD ~2200 bytes) was saved by storing char []="some message" in Program memory.
+In the serial communication, a #define based level of abstraction was enforced, so that it is clear that
+some transfer is information (usually beginning with "echo:"), an error "error:", or just normal protocol,
+necessary for backwards compatibility.
+
+*Interrupt based temperature measurements:*
+
+An interrupt is used to manage ADC conversions, and enforce checking for critical temperatures.
+This leads to less blocking in the heater management routine.
+
+Implemented G Codes:
+====================
+
+*  G0  -> G1
+*  G1  - Coordinated Movement X Y Z E
+*  G2  - CW ARC
+*  G3  - CCW ARC
+*  G4  - Dwell S<seconds> or P<milliseconds>
+*  G10 - retract filament according to settings of M207
+*  G11 - retract recover filament according to settings of M208
+*  G28 - Home all Axis
+*  G90 - Use Absolute Coordinates
+*  G91 - Use Relative Coordinates
+*  G92 - Set current position to cordinates given
+
+RepRap M Codes
+*  M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+*  M1   - Same as M0
+*  M104 - Set extruder target temp
+*  M105 - Read current temp
+*  M106 - Fan on
+*  M107 - Fan off
+*  M109 - Wait for extruder current temp to reach target temp.
+*  M114 - Display current position
+
+Custom M Codes
+*  M17  - Enable/Power all stepper motors
+*  M18  - Disable all stepper motors; same as M84
+*  M20  - List SD card
+*  M21  - Init SD card
+*  M22  - Release SD card
+*  M23  - Select SD file (M23 filename.g)
+*  M24  - Start/resume SD print
+*  M25  - Pause SD print
+*  M26  - Set SD position in bytes (M26 S12345)
+*  M27  - Report SD print status
+*  M28  - Start SD write (M28 filename.g)
+*  M29  - Stop SD write
+*  M30  - Delete file from SD (M30 filename.g)
+*  M31  - Output time since last M109 or SD card start to serial
+*  M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
+*  M80  - Turn on Power Supply
+*  M81  - Turn off Power Supply
+*  M82  - Set E codes absolute (default)
+*  M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+*  M84  - Disable steppers until next move, or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+*  M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+*  M92  - Set axis_steps_per_unit - same syntax as G92
+*  M114 - Output current position to serial port
+*  M115 - Capabilities string
+*  M117 - display message
+*  M119 - Output Endstop status to serial port
+*  M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
+*  M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
+*  M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M140 - Set bed target temp
+*  M190 - Wait for bed current temp to reach target temp.
+*  M200 - Set filament diameter
+*  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+*  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+*  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+*  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+*  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+*  M206 - set additional homeing offset
+*  M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+*  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+*  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
+*  M220 S<factor in percent>- set speed factor override percentage
+*  M221 S<factor in percent>- set extrude factor override percentage
+*  M240 - Trigger a camera to take a photograph
+*  M280 - Position an RC Servo P<index> S<angle/microseconds>, ommit S to report back current angle
+*  M300 - Play beepsound S<frequency Hz> P<duration ms>
+*  M301 - Set PID parameters P I and D
+*  M302 - Allow cold extrudes
+*  M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+*  M304 - Set bed PID parameters P I and D
+*  M400 - Finish all moves
+*  M500 - stores paramters in EEPROM
+*  M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+*  M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+*  M503 - print the current settings (from memory not from eeprom)
+*  M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+*  M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+*  M907 - Set digital trimpot motor current using axis codes.
+*  M908 - Control digital trimpot directly.
+*  M350 - Set microstepping mode.
+*  M351 - Toggle MS1 MS2 pins directly.
+*  M928 - Start SD logging (M928 filename.g) - ended by M29
+*  M999 - Restart after being stopped by error
+
+
+Configuring and compilation:
+============================
+
+Install the arduino software IDE/toolset v23 (Some configurations also work with 1.x.x)
+   http://www.arduino.cc/en/Main/Software
+
+For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
+  copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
+
+Copy the Marlin firmware
+   https://github.com/ErikZalm/Marlin/tree/Marlin_v1
+   (Use the download button)
+
+Start the arduino IDE.
+Select Tools -> Board -> Arduino Mega 2560    or your microcontroller
+Select the correct serial port in Tools ->Serial Port
+Open Marlin.pde
+
+Click the Verify/Compile button
+
+Click the Upload button
+If all goes well the firmware is uploading
+
+That's ok.  Enjoy Silky Smooth Printing.
+
+
+
+

