commit 54f4f80077bf93db3e030617318691ccb754232e (from 169c21b477cdedb266e98b2031674099c8f6317a)
Merge: 169c21b 750a1e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 24 19:26:39 2016 -0700

    Merge pull request #4404 from thinkyhead/rc_better_stepper_indirection
    
    Arrange stepper_indirection by axis

diff --git a/Marlin/stepper_indirection.cpp b/Marlin/stepper_indirection.cpp
index 0ede056..d7d627a 100644
--- a/Marlin/stepper_indirection.cpp
+++ b/Marlin/stepper_indirection.cpp
@@ -42,6 +42,7 @@
 */
 
 #include "stepper_indirection.h"
+
 #include "Configuration.h"
 
 #if ENABLED(HAVE_TMCDRIVER)
diff --git a/Marlin/stepper_indirection.h b/Marlin/stepper_indirection.h
index 4052e39..6326663 100644
--- a/Marlin/stepper_indirection.h
+++ b/Marlin/stepper_indirection.h
@@ -44,144 +44,311 @@
 #ifndef STEPPER_INDIRECTION_H
 #define STEPPER_INDIRECTION_H
 
-#include "macros.h"
+#include "Configuration.h"
 
-// X motor
+// TMC26X drivers have STEP/DIR on normal pins, but ENABLE via SPI
+#if ENABLED(HAVE_TMCDRIVER)
+  #include <SPI.h>
+  #include <TMC26XStepper.h>
+  void tmc_init();
+#endif
+
+// L6470 has STEP on normal pins, but DIR/ENABLE via SPI
+#if ENABLED(HAVE_L6470DRIVER)
+  #include <SPI.h>
+  #include <L6470.h>
+  void L6470_init();
+#endif
+
+// X Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(X_IS_L6470)
+  extern L6470 stepperX;
+  #define X_ENABLE_INIT NOOP
+  #define X_ENABLE_WRITE(STATE) do{if(STATE) stepperX.Step_Clock(stepperX.getStatus() & STATUS_HIZ); else stepperX.softFree();}while(0)
+  #define X_ENABLE_READ (stepperX.getStatus() & STATUS_HIZ)
+  #define X_DIR_INIT NOOP
+  #define X_DIR_WRITE(STATE) stepperX.Step_Clock(STATE)
+  #define X_DIR_READ (stepperX.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(X_IS_TMC)
+    extern TMC26XStepper stepperX;
+    #define X_ENABLE_INIT NOOP
+    #define X_ENABLE_WRITE(STATE) stepperX.setEnabled(STATE)
+    #define X_ENABLE_READ stepperX.isEnabled()
+  #else
+    #define X_ENABLE_INIT SET_OUTPUT(X_ENABLE_PIN)
+    #define X_ENABLE_WRITE(STATE) WRITE(X_ENABLE_PIN,STATE)
+    #define X_ENABLE_READ READ(X_ENABLE_PIN)
+  #endif
+  #define X_DIR_INIT SET_OUTPUT(X_DIR_PIN)
+  #define X_DIR_WRITE(STATE) WRITE(X_DIR_PIN,STATE)
+  #define X_DIR_READ READ(X_DIR_PIN)
+#endif
 #define X_STEP_INIT SET_OUTPUT(X_STEP_PIN)
 #define X_STEP_WRITE(STATE) WRITE(X_STEP_PIN,STATE)
 #define X_STEP_READ READ(X_STEP_PIN)
 
-#define X_DIR_INIT SET_OUTPUT(X_DIR_PIN)
-#define X_DIR_WRITE(STATE) WRITE(X_DIR_PIN,STATE)
-#define X_DIR_READ READ(X_DIR_PIN)
+// Y Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(Y_IS_L6470)
+  extern L6470 stepperY;
+  #define Y_ENABLE_INIT NOOP
+  #define Y_ENABLE_WRITE(STATE) do{if(STATE) stepperY.Step_Clock(stepperY.getStatus() & STATUS_HIZ); else stepperY.softFree();}while(0)
+  #define Y_ENABLE_READ (stepperY.getStatus() & STATUS_HIZ)
+  #define Y_DIR_INIT NOOP
+  #define Y_DIR_WRITE(STATE) stepperY.Step_Clock(STATE)
+  #define Y_DIR_READ (stepperY.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(Y_IS_TMC)
+    extern TMC26XStepper stepperY;
+    #define Y_ENABLE_INIT NOOP
+    #define Y_ENABLE_WRITE(STATE) stepperY.setEnabled(STATE)
+    #define Y_ENABLE_READ stepperY.isEnabled()
+  #else
+    #define Y_ENABLE_INIT SET_OUTPUT(Y_ENABLE_PIN)
+    #define Y_ENABLE_WRITE(STATE) WRITE(Y_ENABLE_PIN,STATE)
+    #define Y_ENABLE_READ READ(Y_ENABLE_PIN)
+  #endif
+  #define Y_DIR_INIT SET_OUTPUT(Y_DIR_PIN)
+  #define Y_DIR_WRITE(STATE) WRITE(Y_DIR_PIN,STATE)
+  #define Y_DIR_READ READ(Y_DIR_PIN)
+#endif
+#define Y_STEP_INIT SET_OUTPUT(Y_STEP_PIN)
+#define Y_STEP_WRITE(STATE) WRITE(Y_STEP_PIN,STATE)
+#define Y_STEP_READ READ(Y_STEP_PIN)
 
-#define X_ENABLE_INIT SET_OUTPUT(X_ENABLE_PIN)
-#define X_ENABLE_WRITE(STATE) WRITE(X_ENABLE_PIN,STATE)
-#define X_ENABLE_READ READ(X_ENABLE_PIN)
+// Z Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(Z_IS_L6470)
+  extern L6470 stepperZ;
+  #define Z_ENABLE_INIT NOOP
+  #define Z_ENABLE_WRITE(STATE) do{if(STATE) stepperZ.Step_Clock(stepperZ.getStatus() & STATUS_HIZ); else stepperZ.softFree();}while(0)
+  #define Z_ENABLE_READ (stepperZ.getStatus() & STATUS_HIZ)
+  #define Z_DIR_INIT NOOP
+  #define Z_DIR_WRITE(STATE) stepperZ.Step_Clock(STATE)
+  #define Z_DIR_READ (stepperZ.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(Z_IS_TMC)
+    extern TMC26XStepper stepperZ;
+    #define Z_ENABLE_INIT NOOP
+    #define Z_ENABLE_WRITE(STATE) stepperZ.setEnabled(STATE)
+    #define Z_ENABLE_READ stepperZ.isEnabled()
+  #else
+    #define Z_ENABLE_INIT SET_OUTPUT(Z_ENABLE_PIN)
+    #define Z_ENABLE_WRITE(STATE) WRITE(Z_ENABLE_PIN,STATE)
+    #define Z_ENABLE_READ READ(Z_ENABLE_PIN)
+  #endif
+  #define Z_DIR_INIT SET_OUTPUT(Z_DIR_PIN)
+  #define Z_DIR_WRITE(STATE) WRITE(Z_DIR_PIN,STATE)
+  #define Z_DIR_READ READ(Z_DIR_PIN)
+#endif
+#define Z_STEP_INIT SET_OUTPUT(Z_STEP_PIN)
+#define Z_STEP_WRITE(STATE) WRITE(Z_STEP_PIN,STATE)
+#define Z_STEP_READ READ(Z_STEP_PIN)
 
-// X2 motor
+// X2 Stepper
 #if HAS_X2_ENABLE
+  #if ENABLED(HAVE_L6470DRIVER) && ENABLED(X2_IS_L6470)
+    extern L6470 stepperX2;
+    #define X2_ENABLE_INIT NOOP
+    #define X2_ENABLE_WRITE(STATE) do{if(STATE) stepperX2.Step_Clock(stepperX2.getStatus() & STATUS_HIZ); else stepperX2.softFree();}while(0)
+    #define X2_ENABLE_READ (stepperX2.getStatus() & STATUS_HIZ)
+    #define X2_DIR_INIT NOOP
+    #define X2_DIR_WRITE(STATE) stepperX2.Step_Clock(STATE)
+    #define X2_DIR_READ (stepperX2.getStatus() & STATUS_DIR)
+  #else
+    #if ENABLED(HAVE_TMCDRIVER) && ENABLED(X2_IS_TMC)
+      extern TMC26XStepper stepperX2;
+      #define X2_ENABLE_INIT NOOP
+      #define X2_ENABLE_WRITE(STATE) stepperX2.setEnabled(STATE)
+      #define X2_ENABLE_READ stepperX2.isEnabled()
+    #else
+      #define X2_ENABLE_INIT SET_OUTPUT(X2_ENABLE_PIN)
+      #define X2_ENABLE_WRITE(STATE) WRITE(X2_ENABLE_PIN,STATE)
+      #define X2_ENABLE_READ READ(X2_ENABLE_PIN)
+    #endif
+    #define X2_DIR_INIT SET_OUTPUT(X2_DIR_PIN)
+    #define X2_DIR_WRITE(STATE) WRITE(X2_DIR_PIN,STATE)
+    #define X2_DIR_READ READ(X2_DIR_PIN)
+  #endif
   #define X2_STEP_INIT SET_OUTPUT(X2_STEP_PIN)
   #define X2_STEP_WRITE(STATE) WRITE(X2_STEP_PIN,STATE)
   #define X2_STEP_READ READ(X2_STEP_PIN)
-
-  #define X2_DIR_INIT SET_OUTPUT(X2_DIR_PIN)
-  #define X2_DIR_WRITE(STATE) WRITE(X2_DIR_PIN,STATE)
-  #define X2_DIR_READ READ(X_DIR_PIN)
-
-  #define X2_ENABLE_INIT SET_OUTPUT(X2_ENABLE_PIN)
-  #define X2_ENABLE_WRITE(STATE) WRITE(X2_ENABLE_PIN,STATE)
-  #define X2_ENABLE_READ READ(X_ENABLE_PIN)
 #endif
 
-// Y motor
-#define Y_STEP_INIT SET_OUTPUT(Y_STEP_PIN)
-#define Y_STEP_WRITE(STATE) WRITE(Y_STEP_PIN,STATE)
-#define Y_STEP_READ READ(Y_STEP_PIN)
-
-#define Y_DIR_INIT SET_OUTPUT(Y_DIR_PIN)
-#define Y_DIR_WRITE(STATE) WRITE(Y_DIR_PIN,STATE)
-#define Y_DIR_READ READ(Y_DIR_PIN)
-
-#define Y_ENABLE_INIT SET_OUTPUT(Y_ENABLE_PIN)
-#define Y_ENABLE_WRITE(STATE) WRITE(Y_ENABLE_PIN,STATE)
-#define Y_ENABLE_READ READ(Y_ENABLE_PIN)
-
-// Y2 motor
+// Y2 Stepper
 #if HAS_Y2_ENABLE
+  #if ENABLED(HAVE_L6470DRIVER) && ENABLED(Y2_IS_L6470)
+    extern L6470 stepperY2;
+    #define Y2_ENABLE_INIT NOOP
+    #define Y2_ENABLE_WRITE(STATE) do{if(STATE) stepperY2.Step_Clock(stepperY2.getStatus() & STATUS_HIZ); else stepperY2.softFree();}while(0)
+    #define Y2_ENABLE_READ (stepperY2.getStatus() & STATUS_HIZ)
+    #define Y2_DIR_INIT NOOP
+    #define Y2_DIR_WRITE(STATE) stepperY2.Step_Clock(STATE)
+    #define Y2_DIR_READ (stepperY2.getStatus() & STATUS_DIR)
+  #else
+    #if ENABLED(HAVE_TMCDRIVER) && ENABLED(Y2_IS_TMC)
+      extern TMC26XStepper stepperY2;
+      #define Y2_ENABLE_INIT NOOP
+      #define Y2_ENABLE_WRITE(STATE) stepperY2.setEnabled(STATE)
+      #define Y2_ENABLE_READ stepperY2.isEnabled()
+    #else
+      #define Y2_ENABLE_INIT SET_OUTPUT(Y2_ENABLE_PIN)
+      #define Y2_ENABLE_WRITE(STATE) WRITE(Y2_ENABLE_PIN,STATE)
+      #define Y2_ENABLE_READ READ(Y2_ENABLE_PIN)
+    #endif
+    #define Y2_DIR_INIT SET_OUTPUT(Y2_DIR_PIN)
+    #define Y2_DIR_WRITE(STATE) WRITE(Y2_DIR_PIN,STATE)
+    #define Y2_DIR_READ READ(Y2_DIR_PIN)
+  #endif
   #define Y2_STEP_INIT SET_OUTPUT(Y2_STEP_PIN)
   #define Y2_STEP_WRITE(STATE) WRITE(Y2_STEP_PIN,STATE)
   #define Y2_STEP_READ READ(Y2_STEP_PIN)
+#endif
 
-  #define Y2_DIR_INIT SET_OUTPUT(Y2_DIR_PIN)
-  #define Y2_DIR_WRITE(STATE) WRITE(Y2_DIR_PIN,STATE)
-  #define Y2_DIR_READ READ(Y2_DIR_PIN)
-
-  #define Y2_ENABLE_INIT SET_OUTPUT(Y2_ENABLE_PIN)
-  #define Y2_ENABLE_WRITE(STATE) WRITE(Y2_ENABLE_PIN,STATE)
-  #define Y2_ENABLE_READ READ(Y2_ENABLE_PIN)
-#endif // Y_DUAL_STEPPER_DRIVERS
-
-// Z motor
-#define Z_STEP_INIT SET_OUTPUT(Z_STEP_PIN)
-#define Z_STEP_WRITE(STATE) WRITE(Z_STEP_PIN,STATE)
-#define Z_STEP_READ READ(Z_STEP_PIN)
-
-#define Z_DIR_INIT SET_OUTPUT(Z_DIR_PIN)
-#define Z_DIR_WRITE(STATE) WRITE(Z_DIR_PIN,STATE)
-#define Z_DIR_READ READ(Z_DIR_PIN)
-
-#define Z_ENABLE_INIT SET_OUTPUT(Z_ENABLE_PIN)
-#define Z_ENABLE_WRITE(STATE) WRITE(Z_ENABLE_PIN,STATE)
-#define Z_ENABLE_READ READ(Z_ENABLE_PIN)
-
-// Z2 motor
+// Z2 Stepper
 #if HAS_Z2_ENABLE
+  #if ENABLED(HAVE_L6470DRIVER) && ENABLED(Z2_IS_L6470)
+    extern L6470 stepperZ2;
+    #define Z2_ENABLE_INIT NOOP
+    #define Z2_ENABLE_WRITE(STATE) do{if(STATE) stepperZ2.Step_Clock(stepperZ2.getStatus() & STATUS_HIZ); else stepperZ2.softFree();}while(0)
+    #define Z2_ENABLE_READ (stepperZ2.getStatus() & STATUS_HIZ)
+    #define Z2_DIR_INIT NOOP
+    #define Z2_DIR_WRITE(STATE) stepperZ2.Step_Clock(STATE)
+    #define Z2_DIR_READ (stepperZ2.getStatus() & STATUS_DIR)
+  #else
+    #if ENABLED(HAVE_TMCDRIVER) && ENABLED(Z2_IS_TMC)
+      extern TMC26XStepper stepperZ2;
+      #define Z2_ENABLE_INIT NOOP
+      #define Z2_ENABLE_WRITE(STATE) stepperZ2.setEnabled(STATE)
+      #define Z2_ENABLE_READ stepperZ2.isEnabled()
+    #else
+      #define Z2_ENABLE_INIT SET_OUTPUT(Z2_ENABLE_PIN)
+      #define Z2_ENABLE_WRITE(STATE) WRITE(Z2_ENABLE_PIN,STATE)
+      #define Z2_ENABLE_READ READ(Z2_ENABLE_PIN)
+    #endif
+    #define Z2_DIR_INIT SET_OUTPUT(Z2_DIR_PIN)
+    #define Z2_DIR_WRITE(STATE) WRITE(Z2_DIR_PIN,STATE)
+    #define Z2_DIR_READ READ(Z2_DIR_PIN)
+  #endif
   #define Z2_STEP_INIT SET_OUTPUT(Z2_STEP_PIN)
   #define Z2_STEP_WRITE(STATE) WRITE(Z2_STEP_PIN,STATE)
   #define Z2_STEP_READ READ(Z2_STEP_PIN)
+#endif
 
-  #define Z2_DIR_INIT SET_OUTPUT(Z2_DIR_PIN)
-  #define Z2_DIR_WRITE(STATE) WRITE(Z2_DIR_PIN,STATE)
-  #define Z2_DIR_READ READ(Z2_DIR_PIN)
-
-  #define Z2_ENABLE_INIT SET_OUTPUT(Z2_ENABLE_PIN)
-  #define Z2_ENABLE_WRITE(STATE) WRITE(Z2_ENABLE_PIN,STATE)
-  #define Z2_ENABLE_READ READ(Z2_ENABLE_PIN)
-#endif // Z_DUAL_STEPPER_DRIVERS
-
-// E0 motor
+// E0 Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(E0_IS_L6470)
+  extern L6470 stepperE0;
+  #define E0_ENABLE_INIT NOOP
+  #define E0_ENABLE_WRITE(STATE) do{if(STATE) stepperE0.Step_Clock(stepperE0.getStatus() & STATUS_HIZ); else stepperE0.softFree();}while(0)
+  #define E0_ENABLE_READ (stepperE0.getStatus() & STATUS_HIZ)
+  #define E0_DIR_INIT NOOP
+  #define E0_DIR_WRITE(STATE) stepperE0.Step_Clock(STATE)
+  #define E0_DIR_READ (stepperE0.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(E0_IS_TMC)
+    extern TMC26XStepper stepperE0;
+    #define E0_ENABLE_INIT NOOP
+    #define E0_ENABLE_WRITE(STATE) stepperE0.setEnabled(STATE)
+    #define E0_ENABLE_READ stepperE0.isEnabled()
+  #else
+    #define E0_ENABLE_INIT SET_OUTPUT(E0_ENABLE_PIN)
+    #define E0_ENABLE_WRITE(STATE) WRITE(E0_ENABLE_PIN,STATE)
+    #define E0_ENABLE_READ READ(E0_ENABLE_PIN)
+  #endif
+  #define E0_DIR_INIT SET_OUTPUT(E0_DIR_PIN)
+  #define E0_DIR_WRITE(STATE) WRITE(E0_DIR_PIN,STATE)
+  #define E0_DIR_READ READ(E0_DIR_PIN)
+#endif
 #define E0_STEP_INIT SET_OUTPUT(E0_STEP_PIN)
 #define E0_STEP_WRITE(STATE) WRITE(E0_STEP_PIN,STATE)
 #define E0_STEP_READ READ(E0_STEP_PIN)
 
-#define E0_DIR_INIT SET_OUTPUT(E0_DIR_PIN)
-#define E0_DIR_WRITE(STATE) WRITE(E0_DIR_PIN,STATE)
-#define E0_DIR_READ READ(E0_DIR_PIN)
-
-#define E0_ENABLE_INIT SET_OUTPUT(E0_ENABLE_PIN)
-#define E0_ENABLE_WRITE(STATE) WRITE(E0_ENABLE_PIN,STATE)
-#define E0_ENABLE_READ READ(E0_ENABLE_PIN)
-
-// E1 motor
+// E1 Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(E1_IS_L6470)
+  extern L6470 stepperE1;
+  #define E1_ENABLE_INIT NOOP
+  #define E1_ENABLE_WRITE(STATE) do{if(STATE) stepperE1.Step_Clock(stepperE1.getStatus() & STATUS_HIZ); else stepperE1.softFree();}while(0)
+  #define E1_ENABLE_READ (stepperE1.getStatus() & STATUS_HIZ)
+  #define E1_DIR_INIT NOOP
+  #define E1_DIR_WRITE(STATE) stepperE1.Step_Clock(STATE)
+  #define E1_DIR_READ (stepperE1.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(E1_IS_TMC)
+    extern TMC26XStepper stepperE1;
+    #define E1_ENABLE_INIT NOOP
+    #define E1_ENABLE_WRITE(STATE) stepperE1.setEnabled(STATE)
+    #define E1_ENABLE_READ stepperE1.isEnabled()
+  #else
+    #define E1_ENABLE_INIT SET_OUTPUT(E1_ENABLE_PIN)
+    #define E1_ENABLE_WRITE(STATE) WRITE(E1_ENABLE_PIN,STATE)
+    #define E1_ENABLE_READ READ(E1_ENABLE_PIN)
+  #endif
+  #define E1_DIR_INIT SET_OUTPUT(E1_DIR_PIN)
+  #define E1_DIR_WRITE(STATE) WRITE(E1_DIR_PIN,STATE)
+  #define E1_DIR_READ READ(E1_DIR_PIN)
+#endif
 #define E1_STEP_INIT SET_OUTPUT(E1_STEP_PIN)
 #define E1_STEP_WRITE(STATE) WRITE(E1_STEP_PIN,STATE)
 #define E1_STEP_READ READ(E1_STEP_PIN)
 
-#define E1_DIR_INIT SET_OUTPUT(E1_DIR_PIN)
-#define E1_DIR_WRITE(STATE) WRITE(E1_DIR_PIN,STATE)
-#define E1_DIR_READ READ(E1_DIR_PIN)
-
-#define E1_ENABLE_INIT SET_OUTPUT(E1_ENABLE_PIN)
-#define E1_ENABLE_WRITE(STATE) WRITE(E1_ENABLE_PIN,STATE)
-#define E1_ENABLE_READ READ(E1_ENABLE_PIN)
-
-// E2 motor
+// E2 Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(E2_IS_L6470)
+  extern L6470 stepperE2;
+  #define E2_ENABLE_INIT NOOP
+  #define E2_ENABLE_WRITE(STATE) do{if(STATE) stepperE2.Step_Clock(stepperE2.getStatus() & STATUS_HIZ); else stepperE2.softFree();}while(0)
+  #define E2_ENABLE_READ (stepperE2.getStatus() & STATUS_HIZ)
+  #define E2_DIR_INIT NOOP
+  #define E2_DIR_WRITE(STATE) stepperE2.Step_Clock(STATE)
+  #define E2_DIR_READ (stepperE2.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(E2_IS_TMC)
+    extern TMC26XStepper stepperE2;
+    #define E2_ENABLE_INIT NOOP
+    #define E2_ENABLE_WRITE(STATE) stepperE2.setEnabled(STATE)
+    #define E2_ENABLE_READ stepperE2.isEnabled()
+  #else
+    #define E2_ENABLE_INIT SET_OUTPUT(E2_ENABLE_PIN)
+    #define E2_ENABLE_WRITE(STATE) WRITE(E2_ENABLE_PIN,STATE)
+    #define E2_ENABLE_READ READ(E2_ENABLE_PIN)
+  #endif
+  #define E2_DIR_INIT SET_OUTPUT(E2_DIR_PIN)
+  #define E2_DIR_WRITE(STATE) WRITE(E2_DIR_PIN,STATE)
+  #define E2_DIR_READ READ(E2_DIR_PIN)
+#endif
 #define E2_STEP_INIT SET_OUTPUT(E2_STEP_PIN)
 #define E2_STEP_WRITE(STATE) WRITE(E2_STEP_PIN,STATE)
 #define E2_STEP_READ READ(E2_STEP_PIN)
 
-#define E2_DIR_INIT SET_OUTPUT(E2_DIR_PIN)
-#define E2_DIR_WRITE(STATE) WRITE(E2_DIR_PIN,STATE)
-#define E2_DIR_READ READ(E2_DIR_PIN)
-
-#define E2_ENABLE_INIT SET_OUTPUT(E2_ENABLE_PIN)
-#define E2_ENABLE_WRITE(STATE) WRITE(E2_ENABLE_PIN,STATE)
-#define E2_ENABLE_READ READ(E2_ENABLE_PIN)
-
-// E3 motor
+// E3 Stepper
+#if ENABLED(HAVE_L6470DRIVER) && ENABLED(E3_IS_L6470)
+  extern L6470 stepperE3;
+  #define E3_ENABLE_INIT NOOP
+  #define E3_ENABLE_WRITE(STATE) do{if(STATE) stepperE3.Step_Clock(stepperE3.getStatus() & STATUS_HIZ); else stepperE3.softFree();}while(0)
+  #define E3_ENABLE_READ (stepperE3.getStatus() & STATUS_HIZ)
+  #define E3_DIR_INIT NOOP
+  #define E3_DIR_WRITE(STATE) stepperE3.Step_Clock(STATE)
+  #define E3_DIR_READ (stepperE3.getStatus() & STATUS_DIR)
+#else
+  #if ENABLED(HAVE_TMCDRIVER) && ENABLED(E3_IS_TMC)
+    extern TMC26XStepper stepperE3;
+    #define E3_ENABLE_INIT NOOP
+    #define E3_ENABLE_WRITE(STATE) stepperE3.setEnabled(STATE)
+    #define E3_ENABLE_READ stepperE3.isEnabled()
+  #else
+    #define E3_ENABLE_INIT SET_OUTPUT(E3_ENABLE_PIN)
+    #define E3_ENABLE_WRITE(STATE) WRITE(E3_ENABLE_PIN,STATE)
+    #define E3_ENABLE_READ READ(E3_ENABLE_PIN)
+  #endif
+  #define E3_DIR_INIT SET_OUTPUT(E3_DIR_PIN)
+  #define E3_DIR_WRITE(STATE) WRITE(E3_DIR_PIN,STATE)
+  #define E3_DIR_READ READ(E3_DIR_PIN)
+#endif
 #define E3_STEP_INIT SET_OUTPUT(E3_STEP_PIN)
 #define E3_STEP_WRITE(STATE) WRITE(E3_STEP_PIN,STATE)
 #define E3_STEP_READ READ(E3_STEP_PIN)
 
-#define E3_DIR_INIT SET_OUTPUT(E3_DIR_PIN)
-#define E3_DIR_WRITE(STATE) WRITE(E3_DIR_PIN,STATE)
-#define E3_DIR_READ READ(E3_DIR_PIN)
-
-#define E3_ENABLE_INIT SET_OUTPUT(E3_ENABLE_PIN)
-#define E3_ENABLE_WRITE(STATE) WRITE(E3_ENABLE_PIN,STATE)
-#define E3_ENABLE_READ READ(E3_ENABLE_PIN)
-
+/**
+ * Extruder indirection for the single E axis
+ */
 #if ENABLED(SWITCHING_EXTRUDER)
   #define E_STEP_WRITE(v) E0_STEP_WRITE(v)
   #define NORM_E_DIR() E0_DIR_WRITE(current_block->active_extruder ?  INVERT_E0_DIR : !INVERT_E0_DIR)
@@ -225,341 +392,4 @@
   #define REV_E_DIR() E0_DIR_WRITE(INVERT_E0_DIR)
 #endif
 
-//////////////////////////////////
-// Pin redefines for TMC drivers.
-// TMC26X drivers have step and dir on normal pins, but everything else via SPI
-//////////////////////////////////
-#if ENABLED(HAVE_TMCDRIVER)
-  #include <SPI.h>
-  #include <TMC26XStepper.h>
-
-  void tmc_init();
-  #if ENABLED(X_IS_TMC)
-    extern TMC26XStepper stepperX;
-    #undef X_ENABLE_INIT
-    #define X_ENABLE_INIT ((void)0)
-
-    #undef X_ENABLE_WRITE
-    #define X_ENABLE_WRITE(STATE) stepperX.setEnabled(STATE)
-
-    #undef X_ENABLE_READ
-    #define X_ENABLE_READ stepperX.isEnabled()
-
-  #endif
-  #if ENABLED(X2_IS_TMC)
-    extern TMC26XStepper stepperX2;
-    #undef X2_ENABLE_INIT
-    #define X2_ENABLE_INIT ((void)0)
-
-    #undef X2_ENABLE_WRITE
-    #define X2_ENABLE_WRITE(STATE) stepperX2.setEnabled(STATE)
-
-    #undef X2_ENABLE_READ
-    #define X2_ENABLE_READ stepperX2.isEnabled()
-  #endif
-  #if ENABLED(Y_IS_TMC)
-    extern TMC26XStepper stepperY;
-    #undef Y_ENABLE_INIT
-    #define Y_ENABLE_INIT ((void)0)
-
-    #undef Y_ENABLE_WRITE
-    #define Y_ENABLE_WRITE(STATE) stepperY.setEnabled(STATE)
-
-    #undef Y_ENABLE_READ
-    #define Y_ENABLE_READ stepperY.isEnabled()
-  #endif
-  #if ENABLED(Y2_IS_TMC)
-    extern TMC26XStepper stepperY2;
-    #undef Y2_ENABLE_INIT
-    #define Y2_ENABLE_INIT ((void)0)
-
-    #undef Y2_ENABLE_WRITE
-    #define Y2_ENABLE_WRITE(STATE) stepperY2.setEnabled(STATE)
-
-    #undef Y2_ENABLE_READ
-    #define Y2_ENABLE_READ stepperY2.isEnabled()
-  #endif
-  #if ENABLED(Z_IS_TMC)
-    extern TMC26XStepper stepperZ;
-    #undef Z_ENABLE_INIT
-    #define Z_ENABLE_INIT ((void)0)
-
-    #undef Z_ENABLE_WRITE
-    #define Z_ENABLE_WRITE(STATE) stepperZ.setEnabled(STATE)
-
-    #undef Z_ENABLE_READ
-    #define Z_ENABLE_READ stepperZ.isEnabled()
-  #endif
-  #if ENABLED(Z2_IS_TMC)
-    extern TMC26XStepper stepperZ2;
-    #undef Z2_ENABLE_INIT
-    #define Z2_ENABLE_INIT ((void)0)
-
-    #undef Z2_ENABLE_WRITE
-    #define Z2_ENABLE_WRITE(STATE) stepperZ2.setEnabled(STATE)
-
-    #undef Z2_ENABLE_READ
-    #define Z2_ENABLE_READ stepperZ2.isEnabled()
-  #endif
-  #if ENABLED(E0_IS_TMC)
-    extern TMC26XStepper stepperE0;
-    #undef E0_ENABLE_INIT
-    #define E0_ENABLE_INIT ((void)0)
-
-    #undef E0_ENABLE_WRITE
-    #define E0_ENABLE_WRITE(STATE) stepperE0.setEnabled(STATE)
-
-    #undef E0_ENABLE_READ
-    #define E0_ENABLE_READ stepperE0.isEnabled()
-  #endif
-  #if ENABLED(E1_IS_TMC)
-    extern TMC26XStepper stepperE1;
-    #undef E1_ENABLE_INIT
-    #define E1_ENABLE_INIT ((void)0)
-
-    #undef E1_ENABLE_WRITE
-    #define E1_ENABLE_WRITE(STATE) stepperE1.setEnabled(STATE)
-
-    #undef E1_ENABLE_READ
-    #define E1_ENABLE_READ stepperE1.isEnabled()
-  #endif
-  #if ENABLED(E2_IS_TMC)
-    extern TMC26XStepper stepperE2;
-    #undef E2_ENABLE_INIT
-    #define E2_ENABLE_INIT ((void)0)
-
-    #undef E2_ENABLE_WRITE
-    #define E2_ENABLE_WRITE(STATE) stepperE2.setEnabled(STATE)
-
-    #undef E2_ENABLE_READ
-    #define E2_ENABLE_READ stepperE2.isEnabled()
-  #endif
-  #if ENABLED(E3_IS_TMC)
-    extern TMC26XStepper stepperE3;
-    #undef E3_ENABLE_INIT
-    #define E3_ENABLE_INIT ((void)0)
-
-    #undef E3_ENABLE_WRITE
-    #define E3_ENABLE_WRITE(STATE) stepperE3.setEnabled(STATE)
-
-    #undef E3_ENABLE_READ
-    #define E3_ENABLE_READ stepperE3.isEnabled()
-  #endif
-
-#endif  // HAVE_TMCDRIVER
-
-//////////////////////////////////
-// Pin redefines for L6470 drivers.
-// L640 drivers have step on normal pins, but dir and everything else via SPI
-//////////////////////////////////
-#if ENABLED(HAVE_L6470DRIVER)
-
-  #include <SPI.h>
-  #include <L6470.h>
-
-  void L6470_init();
-  #if ENABLED(X_IS_L6470)
-    extern L6470 stepperX;
-    #undef X_ENABLE_INIT
-    #define X_ENABLE_INIT ((void)0)
-
-    #undef X_ENABLE_WRITE
-    #define X_ENABLE_WRITE(STATE) {if(STATE) stepperX.Step_Clock(stepperX.getStatus() & STATUS_HIZ); else stepperX.softFree();}
-
-    #undef X_ENABLE_READ
-    #define X_ENABLE_READ (stepperX.getStatus() & STATUS_HIZ)
-
-    #undef X_DIR_INIT
-    #define X_DIR_INIT ((void)0)
-
-    #undef X_DIR_WRITE
-    #define X_DIR_WRITE(STATE) stepperX.Step_Clock(STATE)
-
-    #undef X_DIR_READ
-    #define X_DIR_READ (stepperX.getStatus() & STATUS_DIR)
-
-  #endif
-  #if ENABLED(X2_IS_L6470)
-    extern L6470 stepperX2;
-    #undef X2_ENABLE_INIT
-    #define X2_ENABLE_INIT ((void)0)
-
-    #undef X2_ENABLE_WRITE
-    #define X2_ENABLE_WRITE(STATE) (if(STATE) stepperX2.Step_Clock(stepperX2.getStatus() & STATUS_HIZ); else stepperX2.softFree();)
-
-    #undef X2_ENABLE_READ
-    #define X2_ENABLE_READ (stepperX2.getStatus() & STATUS_HIZ)
-
-    #undef X2_DIR_INIT
-    #define X2_DIR_INIT ((void)0)
-
-    #undef X2_DIR_WRITE
-    #define X2_DIR_WRITE(STATE) stepperX2.Step_Clock(STATE)
-
-    #undef X2_DIR_READ
-    #define X2_DIR_READ (stepperX2.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(Y_IS_L6470)
-    extern L6470 stepperY;
-    #undef Y_ENABLE_INIT
-    #define Y_ENABLE_INIT ((void)0)
-
-    #undef Y_ENABLE_WRITE
-    #define Y_ENABLE_WRITE(STATE) (if(STATE) stepperY.Step_Clock(stepperY.getStatus() & STATUS_HIZ); else stepperY.softFree();)
-
-    #undef Y_ENABLE_READ
-    #define Y_ENABLE_READ (stepperY.getStatus() & STATUS_HIZ)
-
-    #undef Y_DIR_INIT
-    #define Y_DIR_INIT ((void)0)
-
-    #undef Y_DIR_WRITE
-    #define Y_DIR_WRITE(STATE) stepperY.Step_Clock(STATE)
-
-    #undef Y_DIR_READ
-    #define Y_DIR_READ (stepperY.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(Y2_IS_L6470)
-    extern L6470 stepperY2;
-    #undef Y2_ENABLE_INIT
-    #define Y2_ENABLE_INIT ((void)0)
-
-    #undef Y2_ENABLE_WRITE
-    #define Y2_ENABLE_WRITE(STATE) (if(STATE) stepperY2.Step_Clock(stepperY2.getStatus() & STATUS_HIZ); else stepperY2.softFree();)
-
-    #undef Y2_ENABLE_READ
-    #define Y2_ENABLE_READ (stepperY2.getStatus() & STATUS_HIZ)
-
-    #undef Y2_DIR_INIT
-    #define Y2_DIR_INIT ((void)0)
-
-    #undef Y2_DIR_WRITE
-    #define Y2_DIR_WRITE(STATE) stepperY2.Step_Clock(STATE)
-
-    #undef Y2_DIR_READ
-    #define Y2_DIR_READ (stepperY2.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(Z_IS_L6470)
-    extern L6470 stepperZ;
-    #undef Z_ENABLE_INIT
-    #define Z_ENABLE_INIT ((void)0)
-
-    #undef Z_ENABLE_WRITE
-    #define Z_ENABLE_WRITE(STATE) (if(STATE) stepperZ.Step_Clock(stepperZ.getStatus() & STATUS_HIZ); else stepperZ.softFree();)
-
-    #undef Z_ENABLE_READ
-    #define Z_ENABLE_READ (stepperZ.getStatus() & STATUS_HIZ)
-
-    #undef Z_DIR_INIT
-    #define Z_DIR_INIT ((void)0)
-
-    #undef Z_DIR_WRITE
-    #define Z_DIR_WRITE(STATE) stepperZ.Step_Clock(STATE)
-
-    #undef Y_DIR_READ
-    #define Y_DIR_READ (stepperZ.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(Z2_IS_L6470)
-    extern L6470 stepperZ2;
-    #undef Z2_ENABLE_INIT
-    #define Z2_ENABLE_INIT ((void)0)
-
-    #undef Z2_ENABLE_WRITE
-    #define Z2_ENABLE_WRITE(STATE) (if(STATE) stepperZ2.Step_Clock(stepperZ2.getStatus() & STATUS_HIZ); else stepperZ2.softFree();)
-
-    #undef Z2_ENABLE_READ
-    #define Z2_ENABLE_READ (stepperZ2.getStatus() & STATUS_HIZ)
-
-    #undef Z2_DIR_INIT
-    #define Z2_DIR_INIT ((void)0)
-
-    #undef Z2_DIR_WRITE
-    #define Z2_DIR_WRITE(STATE) stepperZ2.Step_Clock(STATE)
-
-    #undef Y2_DIR_READ
-    #define Y2_DIR_READ (stepperZ2.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(E0_IS_L6470)
-    extern L6470 stepperE0;
-    #undef E0_ENABLE_INIT
-    #define E0_ENABLE_INIT ((void)0)
-
-    #undef E0_ENABLE_WRITE
-    #define E0_ENABLE_WRITE(STATE) (if(STATE) stepperE0.Step_Clock(stepperE0.getStatus() & STATUS_HIZ); else stepperE0.softFree();)
-
-    #undef E0_ENABLE_READ
-    #define E0_ENABLE_READ (stepperE0.getStatus() & STATUS_HIZ)
-
-    #undef E0_DIR_INIT
-    #define E0_DIR_INIT ((void)0)
-
-    #undef E0_DIR_WRITE
-    #define E0_DIR_WRITE(STATE) stepperE0.Step_Clock(STATE)
-
-    #undef E0_DIR_READ
-    #define E0_DIR_READ (stepperE0.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(E1_IS_L6470)
-    extern L6470 stepperE1;
-    #undef E1_ENABLE_INIT
-    #define E1_ENABLE_INIT ((void)0)
-
-    #undef E1_ENABLE_WRITE
-    #define E1_ENABLE_WRITE(STATE) (if(STATE) stepperE1.Step_Clock(stepperE1.getStatus() & STATUS_HIZ); else stepperE1.softFree();)
-
-    #undef E1_ENABLE_READ
-    #define E1_ENABLE_READ (stepperE1.getStatus() & STATUS_HIZ)
-
-    #undef E1_DIR_INIT
-    #define E1_DIR_INIT ((void)0)
-
-    #undef E1_DIR_WRITE
-    #define E1_DIR_WRITE(STATE) stepperE1.Step_Clock(STATE)
-
-    #undef E1_DIR_READ
-    #define E1_DIR_READ (stepperE1.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(E2_IS_L6470)
-    extern L6470 stepperE2;
-    #undef E2_ENABLE_INIT
-    #define E2_ENABLE_INIT ((void)0)
-
-    #undef E2_ENABLE_WRITE
-    #define E2_ENABLE_WRITE(STATE) (if(STATE) stepperE2.Step_Clock(stepperE2.getStatus() & STATUS_HIZ); else stepperE2.softFree();)
-
-    #undef E2_ENABLE_READ
-    #define E2_ENABLE_READ (stepperE2.getStatus() & STATUS_HIZ)
-
-    #undef E2_DIR_INIT
-    #define E2_DIR_INIT ((void)0)
-
-    #undef E2_DIR_WRITE
-    #define E2_DIR_WRITE(STATE) stepperE2.Step_Clock(STATE)
-
-    #undef E2_DIR_READ
-    #define E2_DIR_READ (stepperE2.getStatus() & STATUS_DIR)
-  #endif
-  #if ENABLED(E3_IS_L6470)
-    extern L6470 stepperE3;
-    #undef E3_ENABLE_INIT
-    #define E3_ENABLE_INIT ((void)0)
-
-    #undef E3_ENABLE_WRITE
-    #define E3_ENABLE_WRITE(STATE) (if(STATE) stepperE3.Step_Clock(stepperE3.getStatus() & STATUS_HIZ); else stepperE3.softFree();)
-
-    #undef E3_ENABLE_READ
-    #define E3_ENABLE_READ (stepperE3.getStatus() & STATUS_HIZ)
-
-    #undef E3_DIR_INIT
-    #define E3_DIR_INIT ((void)0)
-
-    #undef E3_DIR_WRITE
-    #define E3_DIR_WRITE(STATE) stepperE3.Step_Clock(STATE)
-
-    #undef E3_DIR_READ
-    #define E3_DIR_READ (stepperE3.getStatus() & STATUS_DIR)
-  #endif
-
-#endif  //HAVE_L6470DRIVER
-
 #endif // STEPPER_INDIRECTION_H

commit 54f4f80077bf93db3e030617318691ccb754232e (from 750a1e5116acf57a314eb01a6936dec0f6ad45f7)
Merge: 169c21b 750a1e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 24 19:26:39 2016 -0700

    Merge pull request #4404 from thinkyhead/rc_better_stepper_indirection
    
    Arrange stepper_indirection by axis

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 42269b7..53a66ed 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -293,14 +293,26 @@ extern bool volumetric_enabled;
 extern int extruder_multiplier[EXTRUDERS]; // sets extrude multiply factor (in percent) for each extruder individually
 extern float filament_size[EXTRUDERS]; // cross-sectional area of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder.
 extern float volumetric_multiplier[EXTRUDERS]; // reciprocal of cross-sectional area of filament (in square millimeters), stored this way to reduce computational burden in planner
-extern float current_position[NUM_AXIS];
-extern float home_offset[3]; // axis[n].home_offset
-extern float sw_endstop_min[3]; // axis[n].sw_endstop_min
-extern float sw_endstop_max[3]; // axis[n].sw_endstop_max
 extern bool axis_known_position[3]; // axis[n].is_known
 extern bool axis_homed[3]; // axis[n].is_homed
 extern volatile bool wait_for_heatup;
 
+extern float current_position[NUM_AXIS];
+extern float position_shift[3];
+extern float home_offset[3];
+extern float sw_endstop_min[3];
+extern float sw_endstop_max[3];
+
+#define LOGICAL_POSITION(POS, AXIS) (POS + home_offset[AXIS] + position_shift[AXIS])
+#define RAW_POSITION(POS, AXIS)     (POS - home_offset[AXIS] - position_shift[AXIS])
+#define LOGICAL_X_POSITION(POS)     LOGICAL_POSITION(POS, X_AXIS)
+#define LOGICAL_Y_POSITION(POS)     LOGICAL_POSITION(POS, Y_AXIS)
+#define LOGICAL_Z_POSITION(POS)     LOGICAL_POSITION(POS, Z_AXIS)
+#define RAW_X_POSITION(POS)         RAW_POSITION(POS, X_AXIS)
+#define RAW_Y_POSITION(POS)         RAW_POSITION(POS, Y_AXIS)
+#define RAW_Z_POSITION(POS)         RAW_POSITION(POS, Z_AXIS)
+#define RAW_CURRENT_POSITION(AXIS)  RAW_POSITION(current_position[AXIS], AXIS)
+
 // GCode support for external objects
 bool code_seen(char);
 int code_value_int();
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 7b8fcb0..42f67e8 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -331,10 +331,6 @@ float position_shift[3] = { 0 };
 // Set by M206, M428, or menu item. Saved to EEPROM.
 float home_offset[3] = { 0 };
 
-#define LOGICAL_POSITION(POS, AXIS) (POS + home_offset[AXIS] + position_shift[AXIS])
-#define RAW_POSITION(POS, AXIS) (POS - home_offset[AXIS] - position_shift[AXIS])
-#define RAW_CURRENT_POSITION(AXIS) (RAW_POSITION(current_position[AXIS], AXIS))
-
 // Software Endstops. Default to configured limits.
 float sw_endstop_min[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
 float sw_endstop_max[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
@@ -1421,7 +1417,7 @@ XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
 
   static float x_home_pos(int extruder) {
     if (extruder == 0)
-      return LOGICAL_POSITION(base_home_pos(X_AXIS), X_AXIS);
+      return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
@@ -1437,11 +1433,11 @@ XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   }
 
   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
-  static bool active_extruder_parked = false; // used in mode 1 & 2
-  static float raised_parked_position[NUM_AXIS]; // used in mode 1
-  static millis_t delayed_move_time = 0; // used in mode 1
+  static bool active_extruder_parked = false;        // used in mode 1 & 2
+  static float raised_parked_position[NUM_AXIS];     // used in mode 1
+  static millis_t delayed_move_time = 0;             // used in mode 1
   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
-  static float duplicate_extruder_temp_offset = 0; // used in mode 2
+  static float duplicate_extruder_temp_offset = 0;   // used in mode 2
 
 #endif //DUAL_X_CARRIAGE
 
@@ -1526,7 +1522,7 @@ static void set_axis_is_at_home(AxisEnum axis) {
       if (active_extruder != 0)
         current_position[X_AXIS] = x_home_pos(active_extruder);
       else
-        current_position[X_AXIS] = LOGICAL_POSITION(base_home_pos(X_AXIS), X_AXIS);
+        current_position[X_AXIS] = LOGICAL_X_POSITION(base_home_pos(X_AXIS));
       update_software_endstops(X_AXIS);
       return;
     }
@@ -1803,7 +1799,7 @@ static void clean_up_after_endstop_or_probe_move() {
         SERIAL_ECHOLNPGM(")");
       }
     #endif
-    float z_dest = LOGICAL_POSITION(z_raise, Z_AXIS);
+    float z_dest = LOGICAL_Z_POSITION(z_raise);
 
     if (zprobe_zoffset < 0)
       z_dest -= zprobe_zoffset;
@@ -2964,7 +2960,7 @@ inline void gcode_G28() {
 
       if (home_all_axis || homeX || homeY) {
         // Raise Z before homing any other axes and z is not already high enough (never lower z)
-        destination[Z_AXIS] = LOGICAL_POSITION(MIN_Z_HEIGHT_FOR_HOMING, Z_AXIS);
+        destination[Z_AXIS] = LOGICAL_Z_POSITION(MIN_Z_HEIGHT_FOR_HOMING);
         if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3004,7 +3000,7 @@ inline void gcode_G28() {
         int tmp_extruder = active_extruder;
         active_extruder = !active_extruder;
         HOMEAXIS(X);
-        inactive_extruder_x_pos = current_position[X_AXIS];
+        inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
         active_extruder = tmp_extruder;
         HOMEAXIS(X);
         // reset state used by the different modes
@@ -3079,7 +3075,7 @@ inline void gcode_G28() {
            * NOTE: This doesn't necessarily ensure the Z probe is also
            * within the bed!
            */
-          float cpx = current_position[X_AXIS], cpy = current_position[Y_AXIS];
+          float cpx = RAW_CURRENT_POSITION(X_AXIS), cpy = RAW_CURRENT_POSITION(Y_AXIS);
           if (   cpx >= X_MIN_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
               && cpx <= X_MAX_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
               && cpy >= Y_MIN_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
@@ -3218,12 +3214,12 @@ inline void gcode_G28() {
     ;
     line_to_current_position();
 
-    current_position[X_AXIS] = LOGICAL_POSITION(x, X_AXIS);
-    current_position[Y_AXIS] = LOGICAL_POSITION(y, Y_AXIS);
+    current_position[X_AXIS] = LOGICAL_X_POSITION(x);
+    current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
     line_to_current_position();
 
     #if Z_RAISE_BETWEEN_PROBINGS > 0 || MIN_Z_HEIGHT_FOR_HOMING > 0
-      current_position[Z_AXIS] = LOGICAL_POSITION(MESH_HOME_SEARCH_Z, Z_AXIS);
+      current_position[Z_AXIS] = LOGICAL_Z_POSITION(MESH_HOME_SEARCH_Z);
       line_to_current_position();
     #endif
 
@@ -3476,36 +3472,36 @@ inline void gcode_G28() {
 
       xy_probe_feedrate_mm_m = code_seen('S') ? (int)code_value_linear_units() : XY_PROBE_SPEED;
 
-      int left_probe_bed_position = code_seen('L') ? (int)code_value_axis_units(X_AXIS) : LEFT_PROBE_BED_POSITION,
-          right_probe_bed_position = code_seen('R') ? (int)code_value_axis_units(X_AXIS) : RIGHT_PROBE_BED_POSITION,
-          front_probe_bed_position = code_seen('F') ? (int)code_value_axis_units(Y_AXIS) : FRONT_PROBE_BED_POSITION,
-          back_probe_bed_position = code_seen('B') ? (int)code_value_axis_units(Y_AXIS) : BACK_PROBE_BED_POSITION;
+      int left_probe_bed_position = code_seen('L') ? (int)code_value_axis_units(X_AXIS) : LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION),
+          right_probe_bed_position = code_seen('R') ? (int)code_value_axis_units(X_AXIS) : LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION),
+          front_probe_bed_position = code_seen('F') ? (int)code_value_axis_units(Y_AXIS) : LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION),
+          back_probe_bed_position = code_seen('B') ? (int)code_value_axis_units(Y_AXIS) : LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION);
 
-      bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
+      bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
            left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
-           right_out_r = right_probe_bed_position > MAX_PROBE_X,
+           right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
            right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
-           front_out_f = front_probe_bed_position < MIN_PROBE_Y,
+           front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
            front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
-           back_out_b = back_probe_bed_position > MAX_PROBE_Y,
+           back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
            back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
 
       if (left_out || right_out || front_out || back_out) {
         if (left_out) {
           out_of_range_error(PSTR("(L)eft"));
-          left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
+          left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
         }
         if (right_out) {
           out_of_range_error(PSTR("(R)ight"));
-          right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
+          right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
         }
         if (front_out) {
           out_of_range_error(PSTR("(F)ront"));
-          front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
+          front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
         }
         if (back_out) {
           out_of_range_error(PSTR("(B)ack"));
-          back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
+          back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
         }
         return;
       }
@@ -3641,14 +3637,14 @@ inline void gcode_G28() {
       #endif
 
       // Probe at 3 arbitrary points
-      float z_at_pt_1 = probe_pt( LOGICAL_POSITION(ABL_PROBE_PT_1_X, X_AXIS),
-                                  LOGICAL_POSITION(ABL_PROBE_PT_1_Y, Y_AXIS),
+      float z_at_pt_1 = probe_pt( LOGICAL_X_POSITION(ABL_PROBE_PT_1_X, X_AXIS),
+                                  LOGICAL_Y_POSITION(ABL_PROBE_PT_1_Y, Y_AXIS),
                                   stow_probe_after_each, verbose_level),
-            z_at_pt_2 = probe_pt( LOGICAL_POSITION(ABL_PROBE_PT_2_X, X_AXIS),
-                                  LOGICAL_POSITION(ABL_PROBE_PT_2_Y, Y_AXIS),
+            z_at_pt_2 = probe_pt( LOGICAL_X_POSITION(ABL_PROBE_PT_2_X, X_AXIS),
+                                  LOGICAL_Y_POSITION(ABL_PROBE_PT_2_Y, Y_AXIS),
                                   stow_probe_after_each, verbose_level),
-            z_at_pt_3 = probe_pt( LOGICAL_POSITION(ABL_PROBE_PT_3_X, X_AXIS),
-                                  LOGICAL_POSITION(ABL_PROBE_PT_3_Y, Y_AXIS),
+            z_at_pt_3 = probe_pt( LOGICAL_X_POSITION(ABL_PROBE_PT_3_X, X_AXIS),
+                                  LOGICAL_Y_POSITION(ABL_PROBE_PT_3_Y, Y_AXIS),
                                   stow_probe_after_each, verbose_level);
 
       if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
@@ -4212,7 +4208,7 @@ inline void gcode_M42() {
 
     float X_probe_location = code_seen('X') ? code_value_axis_units(X_AXIS) : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
-      if (X_probe_location < MIN_PROBE_X || X_probe_location > MAX_PROBE_X) {
+      if (X_probe_location < LOGICAL_X_POSITION(MIN_PROBE_X) || X_probe_location > LOGICAL_X_POSITION(MAX_PROBE_X)) {
         out_of_range_error(PSTR("X"));
         return;
       }
@@ -4220,12 +4216,12 @@ inline void gcode_M42() {
 
     float Y_probe_location = code_seen('Y') ? code_value_axis_units(Y_AXIS) : Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
-      if (Y_probe_location < MIN_PROBE_Y || Y_probe_location > MAX_PROBE_Y) {
+      if (Y_probe_location < LOGICAL_Y_POSITION(MIN_PROBE_Y) || Y_probe_location > LOGICAL_Y_POSITION(MAX_PROBE_Y)) {
         out_of_range_error(PSTR("Y"));
         return;
       }
     #else
-      if (HYPOT(X_probe_location, Y_probe_location) > DELTA_PROBEABLE_RADIUS) {
+      if (HYPOT(RAW_X_POSITION(X_probe_location), RAW_Y_POSITION(Y_probe_location)) > DELTA_PROBEABLE_RADIUS) {
         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
         return;
       }
@@ -6751,16 +6747,16 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_m/*=0.0*/, bool n
 
           switch (dual_x_carriage_mode) {
             case DXC_FULL_CONTROL_MODE:
-              current_position[X_AXIS] = inactive_extruder_x_pos;
-              inactive_extruder_x_pos = destination[X_AXIS];
+              current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
               break;
             case DXC_DUPLICATION_MODE:
               active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
               if (active_extruder_parked)
-                current_position[X_AXIS] = inactive_extruder_x_pos;
+                current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
               else
                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
-              inactive_extruder_x_pos = destination[X_AXIS];
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
               extruder_duplication_enabled = false;
               break;
             default:
@@ -7749,9 +7745,9 @@ void clamp_to_software_endstops(float target[3]) {
   void inverse_kinematics(const float in_cartesian[3]) {
 
     const float cartesian[3] = {
-      RAW_POSITION(in_cartesian[X_AXIS], X_AXIS),
-      RAW_POSITION(in_cartesian[Y_AXIS], Y_AXIS),
-      RAW_POSITION(in_cartesian[Z_AXIS], Z_AXIS)
+      RAW_X_POSITION(in_cartesian[X_AXIS]),
+      RAW_Y_POSITION(in_cartesian[Y_AXIS]),
+      RAW_Z_POSITION(in_cartesian[Z_AXIS])
     };
 
     delta[TOWER_1] = sqrt(delta_diagonal_rod_2_tower_1
@@ -7779,13 +7775,13 @@ void clamp_to_software_endstops(float target[3]) {
 
   float delta_safe_distance_from_top() {
     float cartesian[3] = {
-      LOGICAL_POSITION(0, X_AXIS),
-      LOGICAL_POSITION(0, Y_AXIS),
-      LOGICAL_POSITION(0, Z_AXIS)
+      LOGICAL_X_POSITION(0),
+      LOGICAL_Y_POSITION(0),
+      LOGICAL_Z_POSITION(0)
     };
     inverse_kinematics(cartesian);
     float distance = delta[TOWER_3];
-    cartesian[Y_AXIS] = LOGICAL_POSITION(DELTA_PRINTABLE_RADIUS, Y_AXIS);
+    cartesian[Y_AXIS] = LOGICAL_Y_POSITION(DELTA_PRINTABLE_RADIUS);
     inverse_kinematics(cartesian);
     return abs(distance - delta[TOWER_3]);
   }
@@ -7877,8 +7873,8 @@ void clamp_to_software_endstops(float target[3]) {
 
       int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
       float h1 = 0.001 - half, h2 = half - 0.001,
-            grid_x = max(h1, min(h2, RAW_POSITION(cartesian[X_AXIS], X_AXIS) / delta_grid_spacing[0])),
-            grid_y = max(h1, min(h2, RAW_POSITION(cartesian[Y_AXIS], Y_AXIS) / delta_grid_spacing[1]));
+            grid_x = max(h1, min(h2, RAW_X_POSITION(cartesian[X_AXIS]) / delta_grid_spacing[0])),
+            grid_y = max(h1, min(h2, RAW_Y_POSITION(cartesian[Y_AXIS]) / delta_grid_spacing[1]));
       int floor_x = floor(grid_x), floor_y = floor(grid_y);
       float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
             z1 = bed_level[floor_x + half][floor_y + half],
@@ -7919,9 +7915,9 @@ void set_current_from_steppers_for_axis(AxisEnum axis) {
     current_position[axis] = LOGICAL_POSITION(cartesian_position[axis], axis);
   #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
     vector_3 pos = planner.adjusted_position();
-    current_position[axis] = LOGICAL_POSITION(axis == X_AXIS ? pos.x : axis == Y_AXIS ? pos.y : pos.z, axis);
+    current_position[axis] = axis == X_AXIS ? pos.x : axis == Y_AXIS ? pos.y : pos.z;
   #else
-    current_position[axis] = LOGICAL_POSITION(stepper.get_axis_position_mm(axis), axis); // CORE handled transparently
+    current_position[axis] = stepper.get_axis_position_mm(axis); // CORE handled transparently
   #endif
 }
 
@@ -7931,8 +7927,8 @@ void set_current_from_steppers_for_axis(AxisEnum axis) {
 void mesh_line_to_destination(float fr_mm_m, uint8_t x_splits = 0xff, uint8_t y_splits = 0xff) {
   int cx1 = mbl.cell_index_x(RAW_CURRENT_POSITION(X_AXIS)),
       cy1 = mbl.cell_index_y(RAW_CURRENT_POSITION(Y_AXIS)),
-      cx2 = mbl.cell_index_x(RAW_POSITION(destination[X_AXIS], X_AXIS)),
-      cy2 = mbl.cell_index_y(RAW_POSITION(destination[Y_AXIS], Y_AXIS));
+      cx2 = mbl.cell_index_x(RAW_X_POSITION(destination[X_AXIS])),
+      cy2 = mbl.cell_index_y(RAW_Y_POSITION(destination[Y_AXIS]));
   NOMORE(cx1, MESH_NUM_X_POINTS - 2);
   NOMORE(cy1, MESH_NUM_Y_POINTS - 2);
   NOMORE(cx2, MESH_NUM_X_POINTS - 2);
@@ -7953,14 +7949,14 @@ void mesh_line_to_destination(float fr_mm_m, uint8_t x_splits = 0xff, uint8_t y_
   int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   if (cx2 != cx1 && TEST(x_splits, gcx)) {
     memcpy(end, destination, sizeof(end));
-    destination[X_AXIS] = LOGICAL_POSITION(mbl.get_probe_x(gcx), X_AXIS);
+    destination[X_AXIS] = LOGICAL_X_POSITION(mbl.get_probe_x(gcx));
     normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
     destination[Y_AXIS] = MBL_SEGMENT_END(Y);
     CBI(x_splits, gcx);
   }
   else if (cy2 != cy1 && TEST(y_splits, gcy)) {
     memcpy(end, destination, sizeof(end));
-    destination[Y_AXIS] = LOGICAL_POSITION(mbl.get_probe_y(gcy), Y_AXIS);
+    destination[Y_AXIS] = LOGICAL_Y_POSITION(mbl.get_probe_y(gcy));
     normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
     destination[X_AXIS] = MBL_SEGMENT_END(X);
     CBI(y_splits, gcy);
@@ -8031,7 +8027,12 @@ void mesh_line_to_destination(float fr_mm_m, uint8_t x_splits = 0xff, uint8_t y_
     if (active_extruder_parked) {
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
         // move duplicate extruder into correct duplication position.
-        planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        planner.set_position_mm(
+          LOGICAL_X_POSITION(inactive_extruder_x_pos),
+          current_position[Y_AXIS],
+          current_position[Z_AXIS],
+          current_position[E_AXIS]
+        );
         planner.buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
                          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate_mm_s[X_AXIS], 1);
         SYNC_PLAN_POSITION_KINEMATIC();
@@ -8375,8 +8376,8 @@ void prepare_move_to_destination() {
     float SCARA_pos[2];
     static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi;
 
-    SCARA_pos[X_AXIS] = RAW_POSITION(cartesian[X_AXIS], X_AXIS) * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y
-    SCARA_pos[Y_AXIS] = RAW_POSITION(cartesian[Y_AXIS], Y_AXIS) * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.
+    SCARA_pos[X_AXIS] = RAW_X_POSITION(cartesian[X_AXIS]) * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y
+    SCARA_pos[Y_AXIS] = RAW_Y_POSITION(cartesian[Y_AXIS]) * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.
 
     #if (Linkage_1 == Linkage_2)
       SCARA_C2 = ((sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS])) / (2 * (float)L1_2)) - 1;
@@ -8394,7 +8395,7 @@ void prepare_move_to_destination() {
 
     delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle
     delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)
-    delta[Z_AXIS] = RAW_POSITION(cartesian[Z_AXIS], Z_AXIS);
+    delta[Z_AXIS] = RAW_Z_POSITION(cartesian[Z_AXIS]);
 
     /**
     SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index d59f6c8..3ffa00f 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -1157,10 +1157,14 @@ void Planner::check_axes_activity() {
 #endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING
   {
     #if ENABLED(MESH_BED_LEVELING)
+
       if (mbl.active())
-        z += mbl.get_z(x - home_offset[X_AXIS], y - home_offset[Y_AXIS]);
+        z += mbl.get_z(RAW_X_POSITION(x), RAW_Y_POSITION(y));
+
     #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
+
       apply_rotation_xyz(bed_level_matrix, x, y, z);
+
     #endif
 
     long nx = position[X_AXIS] = lround(x * axis_steps_per_mm[X_AXIS]),

