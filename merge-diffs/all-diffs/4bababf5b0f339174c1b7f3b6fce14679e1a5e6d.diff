commit 4bababf5b0f339174c1b7f3b6fce14679e1a5e6d (from f312216e972533e99b5ee34b01a319ad4de6e6d8)
Merge: f312216 554cc17
Author: Bernhard <bkubicek@x201.(none)>
Date:   Thu Dec 22 09:22:39 2011 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index dc8c799..58f5bca 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -43,16 +43,20 @@
 // 5 is ParCan supplied 104GT-2 100K
 // 6 is EPCOS 100k
 // 7 is 100k Honeywell thermistor 135-104LAG-J01
+
 //#define THERMISTORHEATER_0 3
-//#define THERMISTORHEATER_1 3
-//#define THERMISTORBED 3
+//#define THERMISTORHEATER_1 1
+//#define THERMISTORHEATER_2 1
 
 //#define HEATER_0_USES_THERMISTOR
 //#define HEATER_1_USES_THERMISTOR
+//#define HEATER_2_USES_THERMISTOR
 #define HEATER_0_USES_AD595
 //#define HEATER_1_USES_AD595
+//#define HEATER_2_USES_AD595
 
 // Select one of these only to define how the bed temp is read.
+//#define THERMISTORBED 1
 //#define BED_USES_THERMISTOR
 //#define BED_USES_AD595
 
@@ -65,12 +69,13 @@
 //#define WATCHPERIOD 20000 //20 seconds
 
 // Actual temperature must be close to target for this long before M109 returns success
-//#define TEMP_RESIDENCY_TIME 20  // (seconds)
-//#define TEMP_HYSTERESIS 5       // (C°) range of +/- temperatures considered "close" to the target one
+#define TEMP_RESIDENCY_TIME 30  // (seconds)
+#define TEMP_HYSTERESIS 3       // (C°) range of +/- temperatures considered "close" to the target one
 
 //// The minimal temperature defines the temperature below which the heater will not be enabled
 #define HEATER_0_MINTEMP 5
 //#define HEATER_1_MINTEMP 5
+//#define HEATER_2_MINTEMP 5
 //#define BED_MINTEMP 5
 
 
@@ -79,6 +84,7 @@
 // You should use MINTEMP for thermistor short/failure protection.
 #define HEATER_0_MAXTEMP 275
 //#define HEATER_1_MAXTEMP 275
+//#define HEATER_2_MAXTEMP 275
 //#define BED_MAXTEMP 150
 
 
@@ -90,21 +96,17 @@
 
 // Heating is finished if a temperature close to this degree shift is reached
 #define HEATING_EARLY_FINISH_DEG_OFFSET 1 //Degree
+
 // PID settings:
 // Uncomment the following line to enable PID support.
-  
 #define PIDTEMP
+#define PID_MAX 255 // limits current to nozzle; 255=full current
 #ifdef PIDTEMP
-  #if MOTHERBOARD == 62
-    #error Sanguinololu does not support PID, sorry. Please disable it.
-  #endif
   //#define PID_DEBUG // Sends debug data to the serial port. 
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
-  
-  #define PID_MAX 255 // limits current to nozzle; 255=full current
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
   #define K1 0.95 //smoothing factor withing the PID
-  #define PID_dT 0.1 //sampling period of the PID
+  #define PID_dT 0.128 //sampling period of the PID
 
   //To develop some PID settings for your machine, you can initiall follow 
   // the Ziegler-Nichols method.
@@ -132,6 +134,11 @@
     #define  DEFAULT_Ki (1.25*PID_dT)  
     #define  DEFAULT_Kd (99/PID_dT)  
 
+// Makergear
+//    #define  DEFAULT_Kp 7.0
+//    #define  DEFAULT_Ki 0.1  
+//    #define  DEFAULT_Kd 12  
+
 // Mendel Parts V9 on 12V    
 //    #define  DEFAULT_Kp  63.0
 //    #define  DEFAULT_Ki (2.25*PID_dT)  
@@ -149,7 +156,7 @@
   // if Kc is choosen well, the additional required power due to increased melting should be compensated.
   #define PID_ADD_EXTRUSION_RATE  
   #ifdef PID_ADD_EXTRUSION_RATE
-    #define  DEFAULT_Kc (3) //heatingpower=Kc*(e_speed)
+    #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)
   #endif
 #endif // PIDTEMP
 
@@ -169,36 +176,39 @@
 
 // Endstop Settings
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
 const bool X_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
 const bool Y_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
 const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
 // For optos H21LOB set to true, for Mendel-Parts newer optos TCST2103 set to false
 
-//#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
+#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
 
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 #define X_ENABLE_ON 0
 #define Y_ENABLE_ON 0
 #define Z_ENABLE_ON 0
-#define E_ENABLE_ON 0
+#define E_ENABLE_ON 0 // For all extruders
 
 // Disables axis when it's not being used.
 #define DISABLE_X false
 #define DISABLE_Y false
 #define DISABLE_Z false
-#define DISABLE_E false
+#define DISABLE_E false // For all extruders
 
 // Inverting axis direction
 //#define INVERT_X_DIR false    // for Mendel set to false, for Orca set to true
 //#define INVERT_Y_DIR true   // for Mendel set to true, for Orca set to false
 //#define INVERT_Z_DIR false    // for Mendel set to false, for Orca set to true
-//#define INVERT_E_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false
+//#define INVERT_E*_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false, used for all extruders
 
-#define INVERT_X_DIR true     // for Mendel set to false, for Orca set to true
+#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
 #define INVERT_Y_DIR false    // for Mendel set to true, for Orca set to false
 #define INVERT_Z_DIR true     // for Mendel set to false, for Orca set to true
-#define INVERT_E_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
 
 //// ENDSTOP SETTINGS:
 // Sets direction of endstops when homing; 1=MAX, -1=MIN
@@ -206,11 +216,11 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Y_HOME_DIR -1
 #define Z_HOME_DIR -1
 
-#define min_software_endstops false //If true, axis won't move to coordinates less than zero.
-#define max_software_endstops false  //If true, axis won't move to coordinates greater than the defined lengths below.
-#define X_MAX_LENGTH 210
-#define Y_MAX_LENGTH 210
-#define Z_MAX_LENGTH 210
+#define min_software_endstops true //If true, axis won't move to coordinates less than zero.
+#define max_software_endstops true  //If true, axis won't move to coordinates greater than the defined lengths below.
+#define X_MAX_LENGTH 205
+#define Y_MAX_LENGTH 205
+#define Z_MAX_LENGTH 200
 
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
@@ -229,7 +239,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // default settings 
 
 #define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200*8/3,760*1.1}                    // default steps per unit for ultimaker 
-//#define DEFAULT_AXIS_STEPS_PER_UNIT   {40, 40, 3333.92, 67} //sells mendel with v9 extruder
+//#define DEFAULT_AXIS_STEPS_PER_UNIT   {40, 40, 3333.92, 360} //sells mendel with v9 extruder
+//#define DEFAULT_AXIS_STEPS_PER_UNIT   {80.3232, 80.8900, 2284.7651, 757.2218} // SAE Prusa w/ Wade extruder
 #define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 45}    // (mm/sec)    
 #define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
@@ -285,10 +296,10 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // hooke's law says:		force = k * distance
 // bernoulli's priniciple says:	v ^ 2 / 2 + g . h + pressure / density = constant
 // so: v ^ 2 is proportional to number of steps we advance the extruder
-//#define ADVANCE
+#define ADVANCE
 
 #ifdef ADVANCE
-  #define EXTRUDER_ADVANCE_K .3
+  #define EXTRUDER_ADVANCE_K .0
 
   #define D_FILAMENT 2.85
   #define STEPS_MM_E 836
@@ -304,7 +315,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
 #define SD_FINISHED_RELEASECOMMAND "M84 X Y E" // no z because of layer shift.
 
-//#define ULTIPANEL
+#define ULTIPANEL
 #ifdef ULTIPANEL
   //#define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 8f98244..f8ded92 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -101,14 +101,31 @@ void manage_inactivity(byte debug);
   #define disable_z() ;
 #endif
 
-#if E_ENABLE_PIN > -1
-  #define  enable_e() WRITE(E_ENABLE_PIN, E_ENABLE_ON)
-  #define disable_e() WRITE(E_ENABLE_PIN,!E_ENABLE_ON)
+#if defined(E0_ENABLE_PIN) && (E0_ENABLE_PIN > -1)
+  #define enable_e0() WRITE(E0_ENABLE_PIN, E_ENABLE_ON)
+  #define disable_e0() WRITE(E0_ENABLE_PIN,!E_ENABLE_ON)
 #else
-  #define enable_e() ;
-  #define disable_e() ;
+  #define enable_e0()  /* nothing */
+  #define disable_e0() /* nothing */
 #endif
 
+#if (EXTRUDERS > 1) && defined(E1_ENABLE_PIN) && (E1_ENABLE_PIN > -1)
+  #define enable_e1() WRITE(E1_ENABLE_PIN, E_ENABLE_ON)
+  #define disable_e1() WRITE(E1_ENABLE_PIN,!E_ENABLE_ON)
+#else
+  #define enable_e1()  /* nothing */
+  #define disable_e1() /* nothing */
+#endif
+
+#if (EXTRUDERS > 2) && defined(E2_ENABLE_PIN) && (E2_ENABLE_PIN > -1)
+  #define enable_e2() WRITE(E2_ENABLE_PIN, E_ENABLE_ON)
+  #define disable_e2() WRITE(E2_ENABLE_PIN,!E_ENABLE_ON)
+#else
+  #define enable_e2()  /* nothing */
+  #define disable_e2() /* nothing */
+#endif
+
+
 enum AxisEnum {X_AXIS=0, Y_AXIS=1, Z_AXIS=2, E_AXIS=3};
 
 
@@ -133,4 +150,7 @@ extern float current_position[NUM_AXIS] ;
 extern float add_homeing[3];
 extern bool stop_heating_wait;
 
+// Handling multiple extruders pins
+extern uint8_t active_extruder;
+
 #endif
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 4d031ea..1dbfb86 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -122,7 +122,6 @@
 //===========================================================================
 //=============================imported variables============================
 //===========================================================================
-extern float HeaterPower;
 
 
 //===========================================================================
@@ -136,9 +135,11 @@ bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
 volatile int feedmultiply=100; //100->1 200->2
 int saved_feedmultiply;
 volatile bool feedmultiplychanged=false;
-float current_position[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
 float add_homeing[3]={0,0,0};
+uint8_t active_extruder = 0;
 bool stop_heating_wait=false;
+
 //===========================================================================
 //=============================private variables=============================
 //===========================================================================
@@ -470,16 +471,16 @@ FORCE_INLINE bool code_seen(char code)
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); \
     destination[LETTER##_AXIS] = 1.5 * LETTER##_MAX_LENGTH * LETTER##_HOME_DIR; \
     feedrate = homing_feedrate[LETTER##_AXIS]; \
-    prepare_move(); \
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
     \
     current_position[LETTER##_AXIS] = 0;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     destination[LETTER##_AXIS] = -LETTER##_HOME_RETRACT_MM * LETTER##_HOME_DIR;\
-    prepare_move(); \
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
     \
     destination[LETTER##_AXIS] = 2*LETTER##_HOME_RETRACT_MM * LETTER##_HOME_DIR;\
     feedrate = homing_feedrate[LETTER##_AXIS]/2 ;  \
-    prepare_move(); \
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
     \
     current_position[LETTER##_AXIS] = (LETTER##_HOME_DIR == -1) ? 0 : LETTER##_MAX_LENGTH;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
@@ -543,6 +544,7 @@ FORCE_INLINE void process_commands()
       if( code_seen(axis_codes[0]) && code_seen(axis_codes[1]) )  //first diagonal move
       {
         current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
+
         plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
         destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
         feedrate = homing_feedrate[X_AXIS]; 
@@ -582,7 +584,7 @@ FORCE_INLINE void process_commands()
       }
 
       if(code_seen(axis_codes[Y_AXIS])) {
-       current_position[1]=code_value()+add_homeing[1];
+        current_position[1]=code_value()+add_homeing[1];
       }
 
       if(code_seen(axis_codes[Z_AXIS])) {
@@ -610,9 +612,11 @@ FORCE_INLINE void process_commands()
         if(code_seen(axis_codes[i])) { 
            current_position[i] = code_value()+add_homeing[i];  
            if(i == E_AXIS) {
+             current_position[i] = code_value();  
              plan_set_e_position(current_position[E_AXIS]);
            }
            else {
+             current_position[i] = code_value()+add_homeing[i];  
              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            }
         }
@@ -623,7 +627,6 @@ FORCE_INLINE void process_commands()
 
   else if(code_seen('M'))
   {
-
     switch( (int)code_value() ) 
     {
     case 17:
@@ -631,10 +634,12 @@ FORCE_INLINE void process_commands()
         enable_x(); 
         enable_y(); 
         enable_z(); 
-        enable_e(); 
+        enable_e0(); 
+        enable_e1(); 
+        enable_e2(); 
       break;
-    #ifdef SDSUPPORT
 
+#ifdef SDSUPPORT
     case 20: // M20 - list SD card
       SERIAL_PROTOCOLLNPGM("Begin file list");
       card.ls();
@@ -663,9 +668,8 @@ FORCE_INLINE void process_commands()
       card.pauseSDPrint();
       break;
     case 26: //M26 - Set SD index
-      if(card.cardOK && code_seen('S')){
+      if(card.cardOK && code_seen('S')) {
         card.setIndex(code_value_long());
-        
       }
       break;
     case 27: //M27 - Get SD status
@@ -679,16 +683,15 @@ FORCE_INLINE void process_commands()
         *(starpos-1) = '\0';
       }
       card.openFile(strchr_pointer+4,false);
-      
       break;
     case 29: //M29 - Stop SD write
       //processed in write to file routine above
       //card,saving = false;
       break;
-    #endif //SDSUPPORT
+#endif //SDSUPPORT
 
     case 30: //M30 take time since the start of the SD print or an M109 command
-    {
+      {
       stoptime=millis();
       char time[30];
       unsigned long t=(stoptime-starttime)/1000;
@@ -700,8 +703,8 @@ FORCE_INLINE void process_commands()
       SERIAL_ECHOLN(time);
       LCD_MESSAGE(time);
       autotempShutdown();
-    }
-    break;
+      }
+      break;
     case 42: //M42 -Change pin status via gcode
       if (code_seen('S'))
       {
@@ -755,21 +758,20 @@ FORCE_INLINE void process_commands()
           break;
         }
       }
-      #if (TEMP_0_PIN > -1) || (TEMP_2_PIN > -1)
+      #if (TEMP_0_PIN > -1)
         SERIAL_PROTOCOLPGM("ok T:");
-        SERIAL_PROTOCOL( degHotend(tmp_extruder)); 
-        #if TEMP_1_PIN > -1 
+        SERIAL_PROTOCOL(degHotend(tmp_extruder)); 
+        #if TEMP_BED_PIN > -1 
           SERIAL_PROTOCOLPGM(" B:");  
           SERIAL_PROTOCOL(degBed());
-        #endif //TEMP_1_PIN
+        #endif //TEMP_BED_PIN
       #else
         SERIAL_ERROR_START;
         SERIAL_ERRORLNPGM("No thermistors - no temp");
       #endif
       #ifdef PIDTEMP
         SERIAL_PROTOCOLPGM(" @:");
-        SERIAL_PROTOCOL( HeaterPower); 
-       
+        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
       #endif
         SERIAL_PROTOCOLLN("");
       return;
@@ -812,19 +814,33 @@ FORCE_INLINE void process_commands()
         residencyStart = -1;
         /* continue to loop until we have reached the target temp   
           _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
-        while((target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder))) ||
-                (residencyStart > -1 && (millis() - residencyStart) < TEMP_RESIDENCY_TIME*1000) ) {
+        while((residencyStart == -1) ||
+              (residencyStart > -1 && (millis() - residencyStart) < TEMP_RESIDENCY_TIME*1000) ) {
       #else
         while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
       #endif //TEMP_RESIDENCY_TIME
-        if( (millis() - codenum) > 1000 ) 
-        { //Print Temp Reading every 1 second while heating up/cooling down
-          SERIAL_PROTOCOLPGM("T:");
-          SERIAL_PROTOCOLLN( degHotend(tmp_extruder) ); 
-          codenum = millis();
-        }
-        manage_heater();
-        LCD_STATUS;
+          if( (millis() - codenum) > 1000 ) 
+          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOL( degHotend(tmp_extruder) ); 
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL( (int)tmp_extruder ); 
+            #ifdef TEMP_RESIDENCY_TIME
+              SERIAL_PROTOCOLPGM(" W:");
+              if(residencyStart > -1)
+              {
+                 codenum = TEMP_RESIDENCY_TIME - ((millis() - residencyStart) / 1000);
+                 SERIAL_PROTOCOLLN( codenum );
+              }
+              else 
+              {
+                 SERIAL_PROTOCOLLN( "?" );
+              }
+            #endif
+            codenum = millis();
+          }
+          manage_heater();
+          LCD_STATUS;
         if(stop_heating_wait) break;
         #ifdef TEMP_RESIDENCY_TIME
             /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
@@ -842,8 +858,8 @@ FORCE_INLINE void process_commands()
         previous_millis_cmd = millis();
       }
       break;
-    case 190: // M190 - Wait bed for heater to reach target.
-    #if TEMP_1_PIN > -1
+    case 190: // M190 - Wait for bed heater to reach target.
+    #if TEMP_BED_PIN > -1
         LCD_MESSAGEPGM("Bed Heating.");
         if (code_seen('S')) setTargetBed(code_value());
         codenum = millis(); 
@@ -851,13 +867,13 @@ FORCE_INLINE void process_commands()
         {
           if( (millis()-codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
           {
-            float tt=degHotend0();
+            float tt=degHotend(active_extruder);
             SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOLLN(tt );
-            SERIAL_PROTOCOLPGM("ok T:");
-            SERIAL_PROTOCOL(tt );
+            SERIAL_PROTOCOL(tt);
+            SERIAL_PROTOCOLPGM(" E:");
+            SERIAL_PROTOCOL( (int)active_extruder ); 
             SERIAL_PROTOCOLPGM(" B:");
-            SERIAL_PROTOCOLLN(degBed() ); 
+            SERIAL_PROTOCOLLN(degBed()); 
             codenum = millis(); 
           }
           manage_heater();
@@ -910,6 +926,9 @@ FORCE_INLINE void process_commands()
         bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
         if(all_axis)
         {
+          disable_e0();
+          disable_e1();
+          disable_e2();
           finishAndDisableSteppers();
         }
         else
@@ -918,8 +937,12 @@ FORCE_INLINE void process_commands()
           if(code_seen('X')) disable_x();
           if(code_seen('Y')) disable_y();
           if(code_seen('Z')) disable_z();
-          #if ((E_ENABLE_PIN != X_ENABLE_PIN) && (E_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
-            if(code_seen('E')) disable_e();
+          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
+            if(code_seen('E')) {
+              disable_e0();
+              disable_e1();
+              disable_e2();
+            }
           #endif 
           LCD_MESSAGEPGM("Partial Release");
         }
@@ -1100,7 +1123,9 @@ FORCE_INLINE void process_commands()
 
     }
   }
-  else if(code_seen('T')) {
+
+  else if(code_seen('T')) 
+  {
     tmp_extruder = code_value();
     if(tmp_extruder >= EXTRUDERS) {
       SERIAL_ECHO_START;
@@ -1110,8 +1135,12 @@ FORCE_INLINE void process_commands()
     }
     else {
       active_extruder = tmp_extruder;
+      SERIAL_ECHO_START;
+      SERIAL_ECHO("Active Extruder: ");
+      SERIAL_PROTOCOLLN((int)active_extruder);
     }
   }
+
   else
   {
     SERIAL_ECHO_START;
@@ -1219,8 +1248,8 @@ void manage_inactivity(byte debug)
     if( (millis()-previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
     if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
     {
-     bool oldstatus=READ(E_ENABLE_PIN);
-     enable_e();
+     bool oldstatus=READ(E0_ENABLE_PIN);
+     enable_e0();
      float oldepos=current_position[E_AXIS];
      float oldedes=destination[E_AXIS];
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
@@ -1232,7 +1261,7 @@ void manage_inactivity(byte debug)
      previous_millis_cmd=millis();
      //enquecommand(DEFAULT_STEPPER_DEACTIVE_COMMAND);
      st_synchronize();
-     WRITE(E_ENABLE_PIN,oldstatus);
+     WRITE(E0_ENABLE_PIN,oldstatus);
     }
   #endif
   check_axes_activity();
@@ -1240,12 +1269,15 @@ void manage_inactivity(byte debug)
 
 void kill()
 {
+  cli(); // Stop interrupts
   disable_heater();
 
   disable_x();
   disable_y();
   disable_z();
-  disable_e();
+  disable_e0();
+  disable_e1();
+  disable_e2();
   
   if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
   SERIAL_ERROR_START;
diff --git a/Marlin/cardreader.pde b/Marlin/cardreader.pde
index 2cf44e6..0c346e1 100644
--- a/Marlin/cardreader.pde
+++ b/Marlin/cardreader.pde
@@ -442,4 +442,4 @@ void CardReader::printingHasFinished()
  }
  autotempShutdown();
 }
-#endif //SDSUPPORT
\ No newline at end of file
+#endif //SDSUPPORT
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index 7fd42a6..5188a06 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -1,2559 +1,2582 @@
-/*
-	This code contibuted by Triffid_Hunter and modified by Kliment
-	why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
-*/
-
-#ifndef	_ARDUINO_H
-#define	_ARDUINO_H
-
-#include	<avr/io.h>
-
-/*
-	utility functions
-*/
-
-#ifndef		MASK
-/// MASKING- returns \f$2^PIN\f$
-	#define		MASK(PIN)				(1 << PIN)
-#endif
-
-/*
-	magic I/O routines
-
-	now you can simply SET_OUTPUT(STEP); WRITE(STEP, 1); WRITE(STEP, 0);
-*/
-
-/// Read a pin
-#define         _READ(IO)                                       ((bool)(DIO ## IO ## _RPORT & MASK(DIO ## IO ## _PIN)))
-/// write to a pin
-#define         _WRITE(IO, v)                   do { if (v) {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); } else {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }; } while (0)
-//#define               _WRITE(IO, v)   do { #if (DIO ##  IO ## _WPORT >= 0x100) CRITICAL_SECTION_START; if (v) {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); } else {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); };#if (DIO ##  IO ## _WPORT >= 0x100) CRITICAL_SECTION_END; } while (0)
-/// toggle a pin
-#define         _TOGGLE(IO)                             do {DIO ##  IO ## _RPORT = MASK(DIO ## IO ## _PIN); } while (0)
-
-/// set pin as input
-#define		_SET_INPUT(IO)		do {DIO ##  IO ## _DDR &= ~MASK(DIO ## IO ## _PIN); } while (0)
-/// set pin as output
-#define		_SET_OUTPUT(IO)		do {DIO ##  IO ## _DDR |=  MASK(DIO ## IO ## _PIN); } while (0)
-
-/// check if pin is an input
-#define		_GET_INPUT(IO)		((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) == 0)
-/// check if pin is an output
-#define		_GET_OUTPUT(IO)		((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) != 0)
-
-//	why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
-
-/// Read a pin wrapper
-#define		READ(IO)					_READ(IO)
-/// Write to a pin wrapper
-#define		WRITE(IO, v)			_WRITE(IO, v)
-/// toggle a pin wrapper
-#define		TOGGLE(IO)				_TOGGLE(IO)
-
-/// set pin as input wrapper
-#define		SET_INPUT(IO)			_SET_INPUT(IO)
-/// set pin as output wrapper
-#define		SET_OUTPUT(IO)		_SET_OUTPUT(IO)
-
-/// check if pin is an input wrapper
-#define		GET_INPUT(IO)			_GET_INPUT(IO)
-/// check if pin is an output wrapper
-#define		GET_OUTPUT(IO)		_GET_OUTPUT(IO)
-
-/*
-	ports and functions
-
-	added as necessary or if I feel like it- not a comprehensive list!
-*/
-
-#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega328__) || defined (__AVR_ATmega328P__)
-// UART
-#define	RXD					DIO0
-#define	TXD					DIO1
-
-// SPI
-#define	SCK					DIO13
-#define	MISO				DIO12
-#define	MOSI				DIO11
-#define	SS					DIO10
-
-// TWI (I2C)
-#define	SCL					AIO5
-#define	SDA					AIO4
-
-// timers and PWM
-#define	OC0A				DIO6
-#define	OC0B				DIO5
-#define	OC1A				DIO9
-#define	OC1B				DIO10
-#define	OC2A				DIO11
-#define	OC2B				DIO3
-
-#define	DEBUG_LED		AIO5
-
-/*
-pins
-*/
-
-#define DIO0_PIN		PIND0
-#define DIO0_RPORT	PIND
-#define DIO0_WPORT	PORTD
-#define DIO0_DDR		DDRD
-#define DIO0_PWM		NULL
-
-#define DIO1_PIN		PIND1
-#define DIO1_RPORT	PIND
-#define DIO1_WPORT	PORTD
-#define DIO1_DDR		DDRD
-#define DIO1_PWM		NULL
-
-#define DIO2_PIN		PIND2
-#define DIO2_RPORT	PIND
-#define DIO2_WPORT	PORTD
-#define DIO2_DDR		DDRD
-#define DIO2_PWM		NULL
-
-#define DIO3_PIN		PIND3
-#define DIO3_RPORT	PIND
-#define DIO3_WPORT	PORTD
-#define DIO3_DDR		DDRD
-#define DIO3_PWM		&OCR2B
-
-#define DIO4_PIN		PIND4
-#define DIO4_RPORT	PIND
-#define DIO4_WPORT	PORTD
-#define DIO4_DDR		DDRD
-#define DIO4_PWM		NULL
-
-#define DIO5_PIN		PIND5
-#define DIO5_RPORT	PIND
-#define DIO5_WPORT	PORTD
-#define DIO5_DDR		DDRD
-#define DIO5_PWM		&OCR0B
-
-#define DIO6_PIN		PIND6
-#define DIO6_RPORT	PIND
-#define DIO6_WPORT	PORTD
-#define DIO6_DDR		DDRD
-#define DIO6_PWM		&OCR0A
-
-#define DIO7_PIN		PIND7
-#define DIO7_RPORT	PIND
-#define DIO7_WPORT	PORTD
-#define DIO7_DDR		DDRD
-#define DIO7_PWM		NULL
-
-#define DIO8_PIN		PINB0
-#define DIO8_RPORT	PINB
-#define DIO8_WPORT	PORTB
-#define DIO8_DDR		DDRB
-#define DIO8_PWM		NULL
-
-#define DIO9_PIN		PINB1
-#define DIO9_RPORT	PINB
-#define DIO9_WPORT	PORTB
-#define DIO9_DDR		DDRB
-#define DIO9_PWM		NULL
-
-#define DIO10_PIN		PINB2
-#define DIO10_RPORT	PINB
-#define DIO10_WPORT	PORTB
-#define DIO10_DDR		DDRB
-#define DIO10_PWM		NULL
-
-#define DIO11_PIN		PINB3
-#define DIO11_RPORT	PINB
-#define DIO11_WPORT	PORTB
-#define DIO11_DDR		DDRB
-#define DIO11_PWM		&OCR2A
-
-#define DIO12_PIN		PINB4
-#define DIO12_RPORT	PINB
-#define DIO12_WPORT	PORTB
-#define DIO12_DDR		DDRB
-#define DIO12_PWM		NULL
-
-#define DIO13_PIN		PINB5
-#define DIO13_RPORT	PINB
-#define DIO13_WPORT	PORTB
-#define DIO13_DDR		DDRB
-#define DIO13_PWM		NULL
-
-
-#define DIO14_PIN		PINC0
-#define DIO14_RPORT	PINC
-#define DIO14_WPORT	PORTC
-#define DIO14_DDR		DDRC
-#define DIO14_PWM		NULL
-
-#define DIO15_PIN		PINC1
-#define DIO15_RPORT	PINC
-#define DIO15_WPORT	PORTC
-#define DIO15_DDR		DDRC
-#define DIO15_PWM		NULL
-
-#define DIO16_PIN		PINC2
-#define DIO16_RPORT	PINC
-#define DIO16_WPORT	PORTC
-#define DIO16_DDR		DDRC
-#define DIO16_PWM		NULL
-
-#define DIO17_PIN		PINC3
-#define DIO17_RPORT	PINC
-#define DIO17_WPORT	PORTC
-#define DIO17_DDR		DDRC
-#define DIO17_PWM		NULL
-
-#define DIO18_PIN		PINC4
-#define DIO18_RPORT	PINC
-#define DIO18_WPORT	PORTC
-#define DIO18_DDR		DDRC
-#define DIO18_PWM		NULL
-
-#define DIO19_PIN		PINC5
-#define DIO19_RPORT	PINC
-#define DIO19_WPORT	PORTC
-#define DIO19_DDR		DDRC
-#define DIO19_PWM		NULL
-
-#define DIO20_PIN		PINC6
-#define DIO20_RPORT	PINC
-#define DIO20_WPORT	PORTC
-#define DIO20_DDR		DDRC
-#define DIO20_PWM		NULL
-
-#define DIO21_PIN		PINC7
-#define DIO21_RPORT	PINC
-#define DIO21_WPORT	PORTC
-#define DIO21_DDR		DDRC
-#define DIO21_PWM		NULL
-
-
-
-#undef PB0
-#define PB0_PIN			PINB0
-#define PB0_RPORT		PINB
-#define PB0_WPORT		PORTB
-#define PB0_DDR			DDRB
-#define PB0_PWM			NULL
-
-#undef PB1
-#define PB1_PIN			PINB1
-#define PB1_RPORT		PINB
-#define PB1_WPORT		PORTB
-#define PB1_DDR			DDRB
-#define PB1_PWM			NULL
-
-#undef PB2
-#define PB2_PIN			PINB2
-#define PB2_RPORT		PINB
-#define PB2_WPORT		PORTB
-#define PB2_DDR			DDRB
-#define PB2_PWM			NULL
-
-#undef PB3
-#define PB3_PIN			PINB3
-#define PB3_RPORT		PINB
-#define PB3_WPORT		PORTB
-#define PB3_DDR			DDRB
-#define PB3_PWM			&OCR2A
-
-#undef PB4
-#define PB4_PIN			PINB4
-#define PB4_RPORT		PINB
-#define PB4_WPORT		PORTB
-#define PB4_DDR			DDRB
-#define PB4_PWM			NULL
-
-#undef PB5
-#define PB5_PIN			PINB5
-#define PB5_RPORT		PINB
-#define PB5_WPORT		PORTB
-#define PB5_DDR			DDRB
-#define PB5_PWM			NULL
-
-#undef PB6
-#define PB6_PIN			PINB6
-#define PB6_RPORT		PINB
-#define PB6_WPORT		PORTB
-#define PB6_DDR			DDRB
-#define PB6_PWM			NULL
-
-#undef PB7
-#define PB7_PIN			PINB7
-#define PB7_RPORT		PINB
-#define PB7_WPORT		PORTB
-#define PB7_DDR			DDRB
-#define PB7_PWM			NULL
-
-
-#undef PC0
-#define PC0_PIN			PINC0
-#define PC0_RPORT		PINC
-#define PC0_WPORT		PORTC
-#define PC0_DDR			DDRC
-#define PC0_PWM			NULL
-
-#undef PC1
-#define PC1_PIN			PINC1
-#define PC1_RPORT		PINC
-#define PC1_WPORT		PORTC
-#define PC1_DDR			DDRC
-#define PC1_PWM			NULL
-
-#undef PC2
-#define PC2_PIN			PINC2
-#define PC2_RPORT		PINC
-#define PC2_WPORT		PORTC
-#define PC2_DDR			DDRC
-#define PC2_PWM			NULL
-
-#undef PC3
-#define PC3_PIN			PINC3
-#define PC3_RPORT		PINC
-#define PC3_WPORT		PORTC
-#define PC3_DDR			DDRC
-#define PC3_PWM			NULL
-
-#undef PC4
-#define PC4_PIN			PINC4
-#define PC4_RPORT		PINC
-#define PC4_WPORT		PORTC
-#define PC4_DDR			DDRC
-#define PC4_PWM			NULL
-
-#undef PC5
-#define PC5_PIN			PINC5
-#define PC5_RPORT		PINC
-#define PC5_WPORT		PORTC
-#define PC5_DDR			DDRC
-#define PC5_PWM			NULL
-
-#undef PC6
-#define PC6_PIN			PINC6
-#define PC6_RPORT		PINC
-#define PC6_WPORT		PORTC
-#define PC6_DDR			DDRC
-#define PC6_PWM			NULL
-
-#undef PC7
-#define PC7_PIN			PINC7
-#define PC7_RPORT		PINC
-#define PC7_WPORT		PORTC
-#define PC7_DDR			DDRC
-#define PC7_PWM			NULL
-
-
-#undef PD0
-#define PD0_PIN			PIND0
-#define PD0_RPORT		PIND
-#define PD0_WPORT		PORTD
-#define PD0_DDR			DDRD
-#define PD0_PWM			NULL
-
-#undef PD1
-#define PD1_PIN			PIND1
-#define PD1_RPORT		PIND
-#define PD1_WPORT		PORTD
-#define PD1_DDR			DDRD
-#define PD1_PWM			NULL
-
-#undef PD2
-#define PD2_PIN			PIND2
-#define PD2_RPORT		PIND
-#define PD2_WPORT		PORTD
-#define PD2_DDR			DDRD
-#define PD2_PWM			NULL
-
-#undef PD3
-#define PD3_PIN			PIND3
-#define PD3_RPORT		PIND
-#define PD3_WPORT		PORTD
-#define PD3_DDR			DDRD
-#define PD3_PWM			&OCR2B
-
-#undef PD4
-#define PD4_PIN			PIND4
-#define PD4_RPORT		PIND
-#define PD4_WPORT		PORTD
-#define PD4_DDR			DDRD
-#define PD4_PWM			NULL
-
-#undef PD5
-#define PD5_PIN			PIND5
-#define PD5_RPORT		PIND
-#define PD5_WPORT		PORTD
-#define PD5_DDR			DDRD
-#define PD5_PWM			&OCR0B
-
-#undef PD6
-#define PD6_PIN			PIND6
-#define PD6_RPORT		PIND
-#define PD6_WPORT		PORTD
-#define PD6_DDR			DDRD
-#define PD6_PWM			&OCR0A
-
-#undef PD7
-#define PD7_PIN			PIND7
-#define PD7_RPORT		PIND
-#define PD7_WPORT		PORTD
-#define PD7_DDR			DDRD
-#define PD7_PWM			NULL
-#endif	/*	_AVR_ATmega{168,328,328P}__ */
-
-#if defined (__AVR_ATmega644__) || defined (__AVR_ATmega644P__) || defined (__AVR_ATmega644PA__)
-// UART
-#define	RXD					DIO8
-#define	TXD					DIO9
-#define	RXD0				DIO8
-#define	TXD0				DIO9
-
-#define	RXD1				DIO10
-#define	TXD1				DIO11
-
-// SPI
-#define	SCK					DIO7
-#define	MISO				DIO6
-#define	MOSI				DIO5
-#define	SS					DIO4
-
-// TWI (I2C)
-#define	SCL					DIO16
-#define	SDA					DIO17
-
-// timers and PWM
-#define	OC0A				DIO3
-#define	OC0B				DIO4
-#define	OC1A				DIO13
-#define	OC1B				DIO12
-#define	OC2A				DIO15
-#define	OC2B				DIO14
-
-#define	DEBUG_LED		DIO0
-/*
-pins
-*/
-
-#define DIO0_PIN		PINB0
-#define DIO0_RPORT	PINB
-#define DIO0_WPORT	PORTB
-#define DIO0_DDR		DDRB
-#define DIO0_PWM		NULL
-
-#define DIO1_PIN		PINB1
-#define DIO1_RPORT	PINB
-#define DIO1_WPORT	PORTB
-#define DIO1_DDR		DDRB
-#define DIO1_PWM		NULL
-
-#define DIO2_PIN		PINB2
-#define DIO2_RPORT	PINB
-#define DIO2_WPORT	PORTB
-#define DIO2_DDR		DDRB
-#define DIO2_PWM		NULL
-
-#define DIO3_PIN		PINB3
-#define DIO3_RPORT	PINB
-#define DIO3_WPORT	PORTB
-#define DIO3_DDR		DDRB
-#define DIO3_PWM		&OCR0A
-
-#define DIO4_PIN		PINB4
-#define DIO4_RPORT	PINB
-#define DIO4_WPORT	PORTB
-#define DIO4_DDR		DDRB
-#define DIO4_PWM		&OCR0B
-
-#define DIO5_PIN		PINB5
-#define DIO5_RPORT	PINB
-#define DIO5_WPORT	PORTB
-#define DIO5_DDR		DDRB
-#define DIO5_PWM		NULL
-
-#define DIO6_PIN		PINB6
-#define DIO6_RPORT	PINB
-#define DIO6_WPORT	PORTB
-#define DIO6_DDR		DDRB
-#define DIO6_PWM		NULL
-
-#define DIO7_PIN		PINB7
-#define DIO7_RPORT	PINB
-#define DIO7_WPORT	PORTB
-#define DIO7_DDR		DDRB
-#define DIO7_PWM		NULL
-
-#define DIO8_PIN		PIND0
-#define DIO8_RPORT	PIND
-#define DIO8_WPORT	PORTD
-#define DIO8_DDR		DDRD
-#define DIO8_PWM		NULL
-
-#define DIO9_PIN		PIND1
-#define DIO9_RPORT	PIND
-#define DIO9_WPORT	PORTD
-#define DIO9_DDR		DDRD
-#define DIO9_PWM		NULL
-
-#define DIO10_PIN		PIND2
-#define DIO10_RPORT	PIND
-#define DIO10_WPORT	PORTD
-#define DIO10_DDR		DDRD
-#define DIO10_PWM		NULL
-
-#define DIO11_PIN		PIND3
-#define DIO11_RPORT	PIND
-#define DIO11_WPORT	PORTD
-#define DIO11_DDR		DDRD
-#define DIO11_PWM		NULL
-
-#define DIO12_PIN		PIND4
-#define DIO12_RPORT	PIND
-#define DIO12_WPORT	PORTD
-#define DIO12_DDR		DDRD
-#define DIO12_PWM		NULL
-
-#define DIO13_PIN		PIND5
-#define DIO13_RPORT	PIND
-#define DIO13_WPORT	PORTD
-#define DIO13_DDR		DDRD
-#define DIO13_PWM		NULL
-
-#define DIO14_PIN		PIND6
-#define DIO14_RPORT	PIND
-#define DIO14_WPORT	PORTD
-#define DIO14_DDR		DDRD
-#define DIO14_PWM		&OCR2B
-
-#define DIO15_PIN		PIND7
-#define DIO15_RPORT	PIND
-#define DIO15_WPORT	PORTD
-#define DIO15_DDR		DDRD
-#define DIO15_PWM		&OCR2A
-
-#define DIO16_PIN		PINC0
-#define DIO16_RPORT	PINC
-#define DIO16_WPORT	PORTC
-#define DIO16_DDR		DDRC
-#define DIO16_PWM		NULL
-
-#define DIO17_PIN		PINC1
-#define DIO17_RPORT	PINC
-#define DIO17_WPORT	PORTC
-#define DIO17_DDR		DDRC
-#define DIO17_PWM		NULL
-
-#define DIO18_PIN		PINC2
-#define DIO18_RPORT	PINC
-#define DIO18_WPORT	PORTC
-#define DIO18_DDR		DDRC
-#define DIO18_PWM		NULL
-
-#define DIO19_PIN		PINC3
-#define DIO19_RPORT	PINC
-#define DIO19_WPORT	PORTC
-#define DIO19_DDR		DDRC
-#define DIO19_PWM		NULL
-
-#define DIO20_PIN		PINC4
-#define DIO20_RPORT	PINC
-#define DIO20_WPORT	PORTC
-#define DIO20_DDR		DDRC
-#define DIO20_PWM		NULL
-
-#define DIO21_PIN		PINC5
-#define DIO21_RPORT	PINC
-#define DIO21_WPORT	PORTC
-#define DIO21_DDR		DDRC
-#define DIO21_PWM		NULL
-
-#define DIO22_PIN		PINC6
-#define DIO22_RPORT	PINC
-#define DIO22_WPORT	PORTC
-#define DIO22_DDR		DDRC
-#define DIO22_PWM		NULL
-
-#define DIO23_PIN		PINC7
-#define DIO23_RPORT	PINC
-#define DIO23_WPORT	PORTC
-#define DIO23_DDR		DDRC
-#define DIO23_PWM		NULL
-
-#define DIO24_PIN		PINA7
-#define DIO24_RPORT	PINA
-#define DIO24_WPORT	PORTA
-#define DIO24_DDR		DDRA
-#define DIO24_PWM		NULL
-
-#define DIO25_PIN		PINA6
-#define DIO25_RPORT	PINA
-#define DIO25_WPORT	PORTA
-#define DIO25_DDR		DDRA
-#define DIO25_PWM		NULL
-
-#define DIO26_PIN		PINA5
-#define DIO26_RPORT	PINA
-#define DIO26_WPORT	PORTA
-#define DIO26_DDR		DDRA
-#define DIO26_PWM		NULL
-
-#define DIO27_PIN		PINA4
-#define DIO27_RPORT	PINA
-#define DIO27_WPORT	PORTA
-#define DIO27_DDR		DDRA
-#define DIO27_PWM		NULL
-
-#define DIO28_PIN		PINA3
-#define DIO28_RPORT	PINA
-#define DIO28_WPORT	PORTA
-#define DIO28_DDR		DDRA
-#define DIO28_PWM		NULL
-
-#define DIO29_PIN		PINA2
-#define DIO29_RPORT	PINA
-#define DIO29_WPORT	PORTA
-#define DIO29_DDR		DDRA
-#define DIO29_PWM		NULL
-
-#define DIO30_PIN		PINA1
-#define DIO30_RPORT	PINA
-#define DIO30_WPORT	PORTA
-#define DIO30_DDR		DDRA
-#define DIO30_PWM		NULL
-
-#define DIO31_PIN		PINA0
-#define DIO31_RPORT	PINA
-#define DIO31_WPORT	PORTA
-#define DIO31_DDR		DDRA
-#define DIO31_PWM		NULL
-
-#define AIO0_PIN		PINA0
-#define AIO0_RPORT	PINA
-#define AIO0_WPORT	PORTA
-#define AIO0_DDR		DDRA
-#define AIO0_PWM		NULL
-
-#define AIO1_PIN		PINA1
-#define AIO1_RPORT	PINA
-#define AIO1_WPORT	PORTA
-#define AIO1_DDR		DDRA
-#define AIO1_PWM		NULL
-
-#define AIO2_PIN		PINA2
-#define AIO2_RPORT	PINA
-#define AIO2_WPORT	PORTA
-#define AIO2_DDR		DDRA
-#define AIO2_PWM		NULL
-
-#define AIO3_PIN		PINA3
-#define AIO3_RPORT	PINA
-#define AIO3_WPORT	PORTA
-#define AIO3_DDR		DDRA
-#define AIO3_PWM		NULL
-
-#define AIO4_PIN		PINA4
-#define AIO4_RPORT	PINA
-#define AIO4_WPORT	PORTA
-#define AIO4_DDR		DDRA
-#define AIO4_PWM		NULL
-
-#define AIO5_PIN		PINA5
-#define AIO5_RPORT	PINA
-#define AIO5_WPORT	PORTA
-#define AIO5_DDR		DDRA
-#define AIO5_PWM		NULL
-
-#define AIO6_PIN		PINA6
-#define AIO6_RPORT	PINA
-#define AIO6_WPORT	PORTA
-#define AIO6_DDR		DDRA
-#define AIO6_PWM		NULL
-
-#define AIO7_PIN		PINA7
-#define AIO7_RPORT	PINA
-#define AIO7_WPORT	PORTA
-#define AIO7_DDR		DDRA
-#define AIO7_PWM		NULL
-
-
-
-#undef PA0
-#define PA0_PIN			PINA0
-#define PA0_RPORT		PINA
-#define PA0_WPORT		PORTA
-#define PA0_DDR			DDRA
-#define PA0_PWM			NULL
-
-#undef PA1
-#define PA1_PIN			PINA1
-#define PA1_RPORT		PINA
-#define PA1_WPORT		PORTA
-#define PA1_DDR			DDRA
-#define PA1_PWM			NULL
-
-#undef PA2
-#define PA2_PIN			PINA2
-#define PA2_RPORT		PINA
-#define PA2_WPORT		PORTA
-#define PA2_DDR			DDRA
-#define PA2_PWM			NULL
-
-#undef PA3
-#define PA3_PIN			PINA3
-#define PA3_RPORT		PINA
-#define PA3_WPORT		PORTA
-#define PA3_DDR			DDRA
-#define PA3_PWM			NULL
-
-#undef PA4
-#define PA4_PIN			PINA4
-#define PA4_RPORT		PINA
-#define PA4_WPORT		PORTA
-#define PA4_DDR			DDRA
-#define PA4_PWM			NULL
-
-#undef PA5
-#define PA5_PIN			PINA5
-#define PA5_RPORT		PINA
-#define PA5_WPORT		PORTA
-#define PA5_DDR			DDRA
-#define PA5_PWM			NULL
-
-#undef PA6
-#define PA6_PIN			PINA6
-#define PA6_RPORT		PINA
-#define PA6_WPORT		PORTA
-#define PA6_DDR			DDRA
-#define PA6_PWM			NULL
-
-#undef PA7
-#define PA7_PIN			PINA7
-#define PA7_RPORT		PINA
-#define PA7_WPORT		PORTA
-#define PA7_DDR			DDRA
-#define PA7_PWM			NULL
-
-
-#undef PB0
-#define PB0_PIN			PINB0
-#define PB0_RPORT		PINB
-#define PB0_WPORT		PORTB
-#define PB0_DDR			DDRB
-#define PB0_PWM			NULL
-
-#undef PB1
-#define PB1_PIN			PINB1
-#define PB1_RPORT		PINB
-#define PB1_WPORT		PORTB
-#define PB1_DDR			DDRB
-#define PB1_PWM			NULL
-
-#undef PB2
-#define PB2_PIN			PINB2
-#define PB2_RPORT		PINB
-#define PB2_WPORT		PORTB
-#define PB2_DDR			DDRB
-#define PB2_PWM			NULL
-
-#undef PB3
-#define PB3_PIN			PINB3
-#define PB3_RPORT		PINB
-#define PB3_WPORT		PORTB
-#define PB3_DDR			DDRB
-#define PB3_PWM			&OCR0A
-
-#undef PB4
-#define PB4_PIN			PINB4
-#define PB4_RPORT		PINB
-#define PB4_WPORT		PORTB
-#define PB4_DDR			DDRB
-#define PB4_PWM			&OCR0B
-
-#undef PB5
-#define PB5_PIN			PINB5
-#define PB5_RPORT		PINB
-#define PB5_WPORT		PORTB
-#define PB5_DDR			DDRB
-#define PB5_PWM			NULL
-
-#undef PB6
-#define PB6_PIN			PINB6
-#define PB6_RPORT		PINB
-#define PB6_WPORT		PORTB
-#define PB6_DDR			DDRB
-#define PB6_PWM			NULL
-
-#undef PB7
-#define PB7_PIN			PINB7
-#define PB7_RPORT		PINB
-#define PB7_WPORT		PORTB
-#define PB7_DDR			DDRB
-#define PB7_PWM			NULL
-
-
-#undef PC0
-#define PC0_PIN			PINC0
-#define PC0_RPORT		PINC
-#define PC0_WPORT		PORTC
-#define PC0_DDR			DDRC
-#define PC0_PWM			NULL
-
-#undef PC1
-#define PC1_PIN			PINC1
-#define PC1_RPORT		PINC
-#define PC1_WPORT		PORTC
-#define PC1_DDR			DDRC
-#define PC1_PWM			NULL
-
-#undef PC2
-#define PC2_PIN			PINC2
-#define PC2_RPORT		PINC
-#define PC2_WPORT		PORTC
-#define PC2_DDR			DDRC
-#define PC2_PWM			NULL
-
-#undef PC3
-#define PC3_PIN			PINC3
-#define PC3_RPORT		PINC
-#define PC3_WPORT		PORTC
-#define PC3_DDR			DDRC
-#define PC3_PWM			NULL
-
-#undef PC4
-#define PC4_PIN			PINC4
-#define PC4_RPORT		PINC
-#define PC4_WPORT		PORTC
-#define PC4_DDR			DDRC
-#define PC4_PWM			NULL
-
-#undef PC5
-#define PC5_PIN			PINC5
-#define PC5_RPORT		PINC
-#define PC5_WPORT		PORTC
-#define PC5_DDR			DDRC
-#define PC5_PWM			NULL
-
-#undef PC6
-#define PC6_PIN			PINC6
-#define PC6_RPORT		PINC
-#define PC6_WPORT		PORTC
-#define PC6_DDR			DDRC
-#define PC6_PWM			NULL
-
-#undef PC7
-#define PC7_PIN			PINC7
-#define PC7_RPORT		PINC
-#define PC7_WPORT		PORTC
-#define PC7_DDR			DDRC
-#define PC7_PWM			NULL
-
-
-#undef PD0
-#define PD0_PIN			PIND0
-#define PD0_RPORT		PIND
-#define PD0_WPORT		PORTD
-#define PD0_DDR			DDRD
-#define PD0_PWM			NULL
-
-#undef PD1
-#define PD1_PIN			PIND1
-#define PD1_RPORT		PIND
-#define PD1_WPORT		PORTD
-#define PD1_DDR			DDRD
-#define PD1_PWM			NULL
-
-#undef PD2
-#define PD2_PIN			PIND2
-#define PD2_RPORT		PIND
-#define PD2_WPORT		PORTD
-#define PD2_DDR			DDRD
-#define PD2_PWM			NULL
-
-#undef PD3
-#define PD3_PIN			PIND3
-#define PD3_RPORT		PIND
-#define PD3_WPORT		PORTD
-#define PD3_DDR			DDRD
-#define PD3_PWM			NULL
-
-#undef PD4
-#define PD4_PIN			PIND4
-#define PD4_RPORT		PIND
-#define PD4_WPORT		PORTD
-#define PD4_DDR			DDRD
-#define PD4_PWM			NULL
-
-#undef PD5
-#define PD5_PIN			PIND5
-#define PD5_RPORT		PIND
-#define PD5_WPORT		PORTD
-#define PD5_DDR			DDRD
-#define PD5_PWM			NULL
-
-#undef PD6
-#define PD6_PIN			PIND6
-#define PD6_RPORT		PIND
-#define PD6_WPORT		PORTD
-#define PD6_DDR			DDRD
-#define PD6_PWM			&OCR2B
-
-#undef PD7
-#define PD7_PIN			PIND7
-#define PD7_RPORT		PIND
-#define PD7_WPORT		PORTD
-#define PD7_DDR			DDRD
-#define PD7_PWM			&OCR2A
-#endif	/*	_AVR_ATmega{644,644P,644PA}__ */
-
-#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
-// UART
-#define	RXD					DIO0
-#define	TXD					DIO1
-
-// SPI
-#define	SCK					DIO52
-#define	MISO				DIO50
-#define	MOSI				DIO51
-#define	SS					DIO53
-
-// TWI (I2C)
-#define	SCL					DIO21
-#define	SDA					DIO20
-
-// timers and PWM
-#define	OC0A				DIO13
-#define	OC0B				DIO4
-#define	OC1A				DIO11
-#define	OC1B				DIO12
-#define	OC2A				DIO10
-#define	OC2B				DIO9
-#define	OC3A				DIO5
-#define	OC3B				DIO2
-#define	OC3C				DIO3
-#define	OC4A				DIO6
-#define	OC4B				DIO7
-#define	OC4C				DIO8
-#define	OC5A				DIO46
-#define	OC5B				DIO45
-#define	OC5C				DIO44
-
-// change for your board
-#define	DEBUG_LED		DIO21
-
-/*
-pins
-*/
-#define	DIO0_PIN		PINE0
-#define	DIO0_RPORT	PINE
-#define	DIO0_WPORT	PORTE
-#define	DIO0_DDR		DDRE
-#define DIO0_PWM		NULL
-
-#define	DIO1_PIN		PINE1
-#define	DIO1_RPORT	PINE
-#define	DIO1_WPORT	PORTE
-#define	DIO1_DDR		DDRE
-#define DIO1_PWM		NULL
-
-#define	DIO2_PIN		PINE4
-#define	DIO2_RPORT	PINE
-#define	DIO2_WPORT	PORTE
-#define	DIO2_DDR		DDRE
-#define DIO2_PWM		&OCR3BL
-
-#define	DIO3_PIN		PINE5
-#define	DIO3_RPORT	PINE
-#define	DIO3_WPORT	PORTE
-#define	DIO3_DDR		DDRE
-#define DIO3_PWM		&OCR3CL
-
-#define	DIO4_PIN		PING5
-#define	DIO4_RPORT	PING
-#define	DIO4_WPORT	PORTG
-#define	DIO4_DDR		DDRG
-#define DIO4_PWM		&OCR0B
-
-#define	DIO5_PIN		PINE3
-#define	DIO5_RPORT	PINE
-#define	DIO5_WPORT	PORTE
-#define	DIO5_DDR		DDRE
-#define DIO5_PWM		&OCR3AL
-
-#define	DIO6_PIN		PINH3
-#define	DIO6_RPORT	PINH
-#define	DIO6_WPORT	PORTH
-#define	DIO6_DDR		DDRH
-#define DIO6_PWM		&OCR4AL
-
-#define	DIO7_PIN		PINH4
-#define	DIO7_RPORT	PINH
-#define	DIO7_WPORT	PORTH
-#define	DIO7_DDR		DDRH
-#define DIO7_PWM		&OCR4BL
-
-#define	DIO8_PIN		PINH5
-#define	DIO8_RPORT	PINH
-#define	DIO8_WPORT	PORTH
-#define	DIO8_DDR		DDRH
-#define DIO8_PWM		&OCR4CL
-
-#define	DIO9_PIN		PINH6
-#define	DIO9_RPORT	PINH
-#define	DIO9_WPORT	PORTH
-#define	DIO9_DDR		DDRH
-#define DIO9_PWM		&OCR2B
-
-#define	DIO10_PIN		PINB4
-#define	DIO10_RPORT	PINB
-#define	DIO10_WPORT	PORTB
-#define	DIO10_DDR		DDRB
-#define DIO10_PWM		&OCR2A
-
-#define	DIO11_PIN		PINB5
-#define	DIO11_RPORT	PINB
-#define	DIO11_WPORT	PORTB
-#define	DIO11_DDR		DDRB
-#define DIO11_PWM		NULL
-
-#define	DIO12_PIN		PINB6
-#define	DIO12_RPORT	PINB
-#define	DIO12_WPORT	PORTB
-#define	DIO12_DDR		DDRB
-#define DIO12_PWM		NULL
-
-#define	DIO13_PIN		PINB7
-#define	DIO13_RPORT	PINB
-#define	DIO13_WPORT	PORTB
-#define	DIO13_DDR		DDRB
-#define DIO13_PWM		&OCR0A
-
-#define	DIO14_PIN		PINJ1
-#define	DIO14_RPORT	PINJ
-#define	DIO14_WPORT	PORTJ
-#define	DIO14_DDR		DDRJ
-#define DIO14_PWM		NULL
-
-#define	DIO15_PIN		PINJ0
-#define	DIO15_RPORT	PINJ
-#define	DIO15_WPORT	PORTJ
-#define	DIO15_DDR		DDRJ
-#define DIO15_PWM		NULL
-
-#define	DIO16_PIN		PINH1
-#define	DIO16_RPORT	PINH
-#define	DIO16_WPORT	PORTH
-#define	DIO16_DDR		DDRH
-#define DIO16_PWM		NULL
-
-#define	DIO17_PIN		PINH0
-#define	DIO17_RPORT	PINH
-#define	DIO17_WPORT	PORTH
-#define	DIO17_DDR		DDRH
-#define DIO17_PWM		NULL
-
-#define	DIO18_PIN		PIND3
-#define	DIO18_RPORT	PIND
-#define	DIO18_WPORT	PORTD
-#define	DIO18_DDR		DDRD
-#define DIO18_PWM		NULL
-
-#define	DIO19_PIN		PIND2
-#define	DIO19_RPORT	PIND
-#define	DIO19_WPORT	PORTD
-#define	DIO19_DDR		DDRD
-#define DIO19_PWM		NULL
-
-#define	DIO20_PIN		PIND1
-#define	DIO20_RPORT	PIND
-#define	DIO20_WPORT	PORTD
-#define	DIO20_DDR		DDRD
-#define DIO20_PWM		NULL
-
-#define	DIO21_PIN		PIND0
-#define	DIO21_RPORT	PIND
-#define	DIO21_WPORT	PORTD
-#define	DIO21_DDR		DDRD
-#define DIO21_PWM		NULL
-
-#define	DIO22_PIN		PINA0
-#define	DIO22_RPORT	PINA
-#define	DIO22_WPORT	PORTA
-#define	DIO22_DDR		DDRA
-#define DIO22_PWM		NULL
-
-#define	DIO23_PIN		PINA1
-#define	DIO23_RPORT	PINA
-#define	DIO23_WPORT	PORTA
-#define	DIO23_DDR		DDRA
-#define DIO23_PWM		NULL
-
-#define	DIO24_PIN		PINA2
-#define	DIO24_RPORT	PINA
-#define	DIO24_WPORT	PORTA
-#define	DIO24_DDR		DDRA
-#define DIO24_PWM		NULL
-
-#define	DIO25_PIN		PINA3
-#define	DIO25_RPORT	PINA
-#define	DIO25_WPORT	PORTA
-#define	DIO25_DDR		DDRA
-#define DIO25_PWM		NULL
-
-#define	DIO26_PIN		PINA4
-#define	DIO26_RPORT	PINA
-#define	DIO26_WPORT	PORTA
-#define	DIO26_DDR		DDRA
-#define DIO26_PWM		NULL
-
-#define	DIO27_PIN		PINA5
-#define	DIO27_RPORT	PINA
-#define	DIO27_WPORT	PORTA
-#define	DIO27_DDR		DDRA
-#define DIO27_PWM		NULL
-
-#define	DIO28_PIN		PINA6
-#define	DIO28_RPORT	PINA
-#define	DIO28_WPORT	PORTA
-#define	DIO28_DDR		DDRA
-#define DIO28_PWM		NULL
-
-#define	DIO29_PIN		PINA7
-#define	DIO29_RPORT	PINA
-#define	DIO29_WPORT	PORTA
-#define	DIO29_DDR		DDRA
-#define DIO29_PWM		NULL
-
-#define	DIO30_PIN		PINC7
-#define	DIO30_RPORT	PINC
-#define	DIO30_WPORT	PORTC
-#define	DIO30_DDR		DDRC
-#define DIO30_PWM		NULL
-
-#define	DIO31_PIN		PINC6
-#define	DIO31_RPORT	PINC
-#define	DIO31_WPORT	PORTC
-#define	DIO31_DDR		DDRC
-#define DIO31_PWM		NULL
-
-#define	DIO32_PIN		PINC5
-#define	DIO32_RPORT	PINC
-#define	DIO32_WPORT	PORTC
-#define	DIO32_DDR		DDRC
-#define DIO32_PWM		NULL
-
-#define	DIO33_PIN		PINC4
-#define	DIO33_RPORT	PINC
-#define	DIO33_WPORT	PORTC
-#define	DIO33_DDR		DDRC
-#define DIO33_PWM		NULL
-
-#define	DIO34_PIN		PINC3
-#define	DIO34_RPORT	PINC
-#define	DIO34_WPORT	PORTC
-#define	DIO34_DDR		DDRC
-#define DIO34_PWM		NULL
-
-#define	DIO35_PIN		PINC2
-#define	DIO35_RPORT	PINC
-#define	DIO35_WPORT	PORTC
-#define	DIO35_DDR		DDRC
-#define DIO35_PWM		NULL
-
-#define	DIO36_PIN		PINC1
-#define	DIO36_RPORT	PINC
-#define	DIO36_WPORT	PORTC
-#define	DIO36_DDR		DDRC
-#define DIO36_PWM		NULL
-
-#define	DIO37_PIN		PINC0
-#define	DIO37_RPORT	PINC
-#define	DIO37_WPORT	PORTC
-#define	DIO37_DDR		DDRC
-#define DIO37_PWM		NULL
-
-#define	DIO38_PIN		PIND7
-#define	DIO38_RPORT	PIND
-#define	DIO38_WPORT	PORTD
-#define	DIO38_DDR		DDRD
-#define DIO38_PWM		NULL
-
-#define	DIO39_PIN		PING2
-#define	DIO39_RPORT	PING
-#define	DIO39_WPORT	PORTG
-#define	DIO39_DDR		DDRG
-#define DIO39_PWM		NULL
-
-#define	DIO40_PIN		PING1
-#define	DIO40_RPORT	PING
-#define	DIO40_WPORT	PORTG
-#define	DIO40_DDR		DDRG
-#define DIO40_PWM		NULL
-
-#define	DIO41_PIN		PING0
-#define	DIO41_RPORT	PING
-#define	DIO41_WPORT	PORTG
-#define	DIO41_DDR		DDRG
-#define DIO41_PWM		NULL
-
-#define	DIO42_PIN		PINL7
-#define	DIO42_RPORT	PINL
-#define	DIO42_WPORT	PORTL
-#define	DIO42_DDR		DDRL
-#define DIO42_PWM		NULL
-
-#define	DIO43_PIN		PINL6
-#define	DIO43_RPORT	PINL
-#define	DIO43_WPORT	PORTL
-#define	DIO43_DDR		DDRL
-#define DIO43_PWM		NULL
-
-#define	DIO44_PIN		PINL5
-#define	DIO44_RPORT	PINL
-#define	DIO44_WPORT	PORTL
-#define	DIO44_DDR		DDRL
-#define DIO44_PWM		&OCR5CL
-
-#define	DIO45_PIN		PINL4
-#define	DIO45_RPORT	PINL
-#define	DIO45_WPORT	PORTL
-#define	DIO45_DDR		DDRL
-#define DIO45_PWM		&OCR5BL
-
-#define	DIO46_PIN		PINL3
-#define	DIO46_RPORT	PINL
-#define	DIO46_WPORT	PORTL
-#define	DIO46_DDR		DDRL
-#define DIO46_PWM		&OCR5AL
-
-#define	DIO47_PIN		PINL2
-#define	DIO47_RPORT	PINL
-#define	DIO47_WPORT	PORTL
-#define	DIO47_DDR		DDRL
-#define DIO47_PWM		NULL
-
-#define	DIO48_PIN		PINL1
-#define	DIO48_RPORT	PINL
-#define	DIO48_WPORT	PORTL
-#define	DIO48_DDR		DDRL
-#define DIO48_PWM		NULL
-
-#define	DIO49_PIN		PINL0
-#define	DIO49_RPORT	PINL
-#define	DIO49_WPORT	PORTL
-#define	DIO49_DDR		DDRL
-#define DIO49_PWM		NULL
-
-#define	DIO50_PIN		PINB3
-#define	DIO50_RPORT	PINB
-#define	DIO50_WPORT	PORTB
-#define	DIO50_DDR		DDRB
-#define DIO50_PWM		NULL
-
-#define	DIO51_PIN		PINB2
-#define	DIO51_RPORT	PINB
-#define	DIO51_WPORT	PORTB
-#define	DIO51_DDR		DDRB
-#define DIO51_PWM		NULL
-
-#define	DIO52_PIN		PINB1
-#define	DIO52_RPORT	PINB
-#define	DIO52_WPORT	PORTB
-#define	DIO52_DDR		DDRB
-#define DIO52_PWM		NULL
-
-#define	DIO53_PIN		PINB0
-#define	DIO53_RPORT	PINB
-#define	DIO53_WPORT	PORTB
-#define	DIO53_DDR		DDRB
-#define DIO53_PWM		NULL
-
-#define DIO54_PIN		PINF0
-#define DIO54_RPORT	PINF
-#define DIO54_WPORT	PORTF
-#define DIO54_DDR		DDRF
-#define DIO54_PWM		NULL
-
-#define DIO55_PIN		PINF1
-#define DIO55_RPORT	PINF
-#define DIO55_WPORT	PORTF
-#define DIO55_DDR		DDRF
-#define DIO55_PWM		NULL
-
-#define DIO56_PIN		PINF2
-#define DIO56_RPORT	PINF
-#define DIO56_WPORT	PORTF
-#define DIO56_DDR		DDRF
-#define DIO56_PWM		NULL
-
-#define DIO57_PIN		PINF3
-#define DIO57_RPORT	PINF
-#define DIO57_WPORT	PORTF
-#define DIO57_DDR		DDRF
-#define DIO57_PWM		NULL
-
-#define DIO58_PIN		PINF4
-#define DIO58_RPORT	PINF
-#define DIO58_WPORT	PORTF
-#define DIO58_DDR		DDRF
-#define DIO58_PWM		NULL
-
-#define DIO59_PIN		PINF5
-#define DIO59_RPORT	PINF
-#define DIO59_WPORT	PORTF
-#define DIO59_DDR		DDRF
-#define DIO59_PWM		NULL
-
-#define DIO60_PIN		PINF6
-#define DIO60_RPORT	PINF
-#define DIO60_WPORT	PORTF
-#define DIO60_DDR		DDRF
-#define DIO60_PWM		NULL
-
-#define DIO61_PIN		PINF7
-#define DIO61_RPORT	PINF
-#define DIO61_WPORT	PORTF
-#define DIO61_DDR		DDRF
-#define DIO61_PWM		NULL
-
-#define DIO62_PIN		PINK0
-#define DIO62_RPORT	PINK
-#define DIO62_WPORT	PORTK
-#define DIO62_DDR		DDRK
-#define DIO62_PWM		NULL
-
-#define DIO63_PIN		PINK1
-#define DIO63_RPORT	PINK
-#define DIO63_WPORT	PORTK
-#define DIO63_DDR		DDRK
-#define DIO63_PWM		NULL
-
-#define DIO64_PIN		PINK2
-#define DIO64_RPORT	PINK
-#define DIO64_WPORT	PORTK
-#define DIO64_DDR		DDRK
-#define DIO64_PWM		NULL
-
-#define DIO65_PIN		PINK3
-#define DIO65_RPORT	PINK
-#define DIO65_WPORT	PORTK
-#define DIO65_DDR		DDRK
-#define DIO65_PWM		NULL
-
-#define DIO66_PIN		PINK4
-#define DIO66_RPORT	PINK
-#define DIO66_WPORT	PORTK
-#define DIO66_DDR		DDRK
-#define DIO66_PWM		NULL
-
-#define DIO67_PIN		PINK5
-#define DIO67_RPORT	PINK
-#define DIO67_WPORT	PORTK
-#define DIO67_DDR		DDRK
-#define DIO67_PWM		NULL
-
-#define DIO68_PIN		PINK6
-#define DIO68_RPORT	PINK
-#define DIO68_WPORT	PORTK
-#define DIO68_DDR		DDRK
-#define DIO68_PWM		NULL
-
-#define DIO69_PIN		PINK7
-#define DIO69_RPORT	PINK
-#define DIO69_WPORT	PORTK
-#define DIO69_DDR		DDRK
-#define DIO69_PWM		NULL
-
-
-
-#undef PA0
-#define PA0_PIN			PINA0
-#define PA0_RPORT		PINA
-#define PA0_WPORT		PORTA
-#define PA0_DDR			DDRA
-#define PA0_PWM			NULL
-#undef PA1
-#define PA1_PIN			PINA1
-#define PA1_RPORT		PINA
-#define PA1_WPORT		PORTA
-#define PA1_DDR			DDRA
-#define PA1_PWM			NULL
-#undef PA2
-#define PA2_PIN			PINA2
-#define PA2_RPORT		PINA
-#define PA2_WPORT		PORTA
-#define PA2_DDR			DDRA
-#define PA2_PWM			NULL
-#undef PA3
-#define PA3_PIN			PINA3
-#define PA3_RPORT		PINA
-#define PA3_WPORT		PORTA
-#define PA3_DDR			DDRA
-#define PA3_PWM			NULL
-#undef PA4
-#define PA4_PIN			PINA4
-#define PA4_RPORT		PINA
-#define PA4_WPORT		PORTA
-#define PA4_DDR			DDRA
-#define PA4_PWM			NULL
-#undef PA5
-#define PA5_PIN			PINA5
-#define PA5_RPORT		PINA
-#define PA5_WPORT		PORTA
-#define PA5_DDR			DDRA
-#define PA5_PWM			NULL
-#undef PA6
-#define PA6_PIN			PINA6
-#define PA6_RPORT		PINA
-#define PA6_WPORT		PORTA
-#define PA6_DDR			DDRA
-#define PA6_PWM			NULL
-#undef PA7
-#define PA7_PIN			PINA7
-#define PA7_RPORT		PINA
-#define PA7_WPORT		PORTA
-#define PA7_DDR			DDRA
-#define PA7_PWM			NULL
-
-#undef PB0
-#define PB0_PIN			PINB0
-#define PB0_RPORT		PINB
-#define PB0_WPORT		PORTB
-#define PB0_DDR			DDRB
-#define PB0_PWM			NULL
-#undef PB1
-#define PB1_PIN			PINB1
-#define PB1_RPORT		PINB
-#define PB1_WPORT		PORTB
-#define PB1_DDR			DDRB
-#define PB1_PWM			NULL
-#undef PB2
-#define PB2_PIN			PINB2
-#define PB2_RPORT		PINB
-#define PB2_WPORT		PORTB
-#define PB2_DDR			DDRB
-#define PB2_PWM			NULL
-#undef PB3
-#define PB3_PIN			PINB3
-#define PB3_RPORT		PINB
-#define PB3_WPORT		PORTB
-#define PB3_DDR			DDRB
-#define PB3_PWM			NULL
-#undef PB4
-#define PB4_PIN			PINB4
-#define PB4_RPORT		PINB
-#define PB4_WPORT		PORTB
-#define PB4_DDR			DDRB
-#define PB4_PWM			&OCR2A
-#undef PB5
-#define PB5_PIN			PINB5
-#define PB5_RPORT		PINB
-#define PB5_WPORT		PORTB
-#define PB5_DDR			DDRB
-#define PB5_PWM			NULL
-#undef PB6
-#define PB6_PIN			PINB6
-#define PB6_RPORT		PINB
-#define PB6_WPORT		PORTB
-#define PB6_DDR			DDRB
-#define PB6_PWM			NULL
-#undef PB7
-#define PB7_PIN			PINB7
-#define PB7_RPORT		PINB
-#define PB7_WPORT		PORTB
-#define PB7_DDR			DDRB
-#define PB7_PWM			&OCR0A
-
-#undef PC0
-#define PC0_PIN			PINC0
-#define PC0_RPORT		PINC
-#define PC0_WPORT		PORTC
-#define PC0_DDR			DDRC
-#define PC0_PWM			NULL
-#undef PC1
-#define PC1_PIN			PINC1
-#define PC1_RPORT		PINC
-#define PC1_WPORT		PORTC
-#define PC1_DDR			DDRC
-#define PC1_PWM			NULL
-#undef PC2
-#define PC2_PIN			PINC2
-#define PC2_RPORT		PINC
-#define PC2_WPORT		PORTC
-#define PC2_DDR			DDRC
-#define PC2_PWM			NULL
-#undef PC3
-#define PC3_PIN			PINC3
-#define PC3_RPORT		PINC
-#define PC3_WPORT		PORTC
-#define PC3_DDR			DDRC
-#define PC3_PWM			NULL
-#undef PC4
-#define PC4_PIN			PINC4
-#define PC4_RPORT		PINC
-#define PC4_WPORT		PORTC
-#define PC4_DDR			DDRC
-#define PC4_PWM			NULL
-#undef PC5
-#define PC5_PIN			PINC5
-#define PC5_RPORT		PINC
-#define PC5_WPORT		PORTC
-#define PC5_DDR			DDRC
-#define PC5_PWM			NULL
-#undef PC6
-#define PC6_PIN			PINC6
-#define PC6_RPORT		PINC
-#define PC6_WPORT		PORTC
-#define PC6_DDR			DDRC
-#define PC6_PWM			NULL
-#undef PC7
-#define PC7_PIN			PINC7
-#define PC7_RPORT		PINC
-#define PC7_WPORT		PORTC
-#define PC7_DDR			DDRC
-#define PC7_PWM			NULL
-
-#undef PD0
-#define PD0_PIN			PIND0
-#define PD0_RPORT		PIND
-#define PD0_WPORT		PORTD
-#define PD0_DDR			DDRD
-#define PD0_PWM			NULL
-#undef PD1
-#define PD1_PIN			PIND1
-#define PD1_RPORT		PIND
-#define PD1_WPORT		PORTD
-#define PD1_DDR			DDRD
-#define PD1_PWM			NULL
-#undef PD2
-#define PD2_PIN			PIND2
-#define PD2_RPORT		PIND
-#define PD2_WPORT		PORTD
-#define PD2_DDR			DDRD
-#define PD2_PWM			NULL
-#undef PD3
-#define PD3_PIN			PIND3
-#define PD3_RPORT		PIND
-#define PD3_WPORT		PORTD
-#define PD3_DDR			DDRD
-#define PD3_PWM			NULL
-#undef PD4
-#define PD4_PIN			PIND4
-#define PD4_RPORT		PIND
-#define PD4_WPORT		PORTD
-#define PD4_DDR			DDRD
-#define PD4_PWM			NULL
-#undef PD5
-#define PD5_PIN			PIND5
-#define PD5_RPORT		PIND
-#define PD5_WPORT		PORTD
-#define PD5_DDR			DDRD
-#define PD5_PWM			NULL
-#undef PD6
-#define PD6_PIN			PIND6
-#define PD6_RPORT		PIND
-#define PD6_WPORT		PORTD
-#define PD6_DDR			DDRD
-#define PD6_PWM			NULL
-#undef PD7
-#define PD7_PIN			PIND7
-#define PD7_RPORT		PIND
-#define PD7_WPORT		PORTD
-#define PD7_DDR			DDRD
-#define PD7_PWM			NULL
-
-#undef PE0
-#define PE0_PIN			PINE0
-#define PE0_RPORT		PINE
-#define PE0_WPORT		PORTE
-#define PE0_DDR			DDRE
-#define PE0_PWM			NULL
-#undef PE1
-#define PE1_PIN			PINE1
-#define PE1_RPORT		PINE
-#define PE1_WPORT		PORTE
-#define PE1_DDR			DDRE
-#define PE1_PWM			NULL
-#undef PE2
-#define PE2_PIN			PINE2
-#define PE2_RPORT		PINE
-#define PE2_WPORT		PORTE
-#define PE2_DDR			DDRE
-#define PE2_PWM			NULL
-#undef PE3
-#define PE3_PIN			PINE3
-#define PE3_RPORT		PINE
-#define PE3_WPORT		PORTE
-#define PE3_DDR			DDRE
-#define PE3_PWM			&OCR3AL
-#undef PE4
-#define PE4_PIN			PINE4
-#define PE4_RPORT		PINE
-#define PE4_WPORT		PORTE
-#define PE4_DDR			DDRE
-#define PE4_PWM			&OCR3BL
-#undef PE5
-#define PE5_PIN			PINE5
-#define PE5_RPORT		PINE
-#define PE5_WPORT		PORTE
-#define PE5_DDR			DDRE
-#define PE5_PWM			&OCR3CL
-#undef PE6
-#define PE6_PIN			PINE6
-#define PE6_RPORT		PINE
-#define PE6_WPORT		PORTE
-#define PE6_DDR			DDRE
-#define PE6_PWM			NULL
-#undef PE7
-#define PE7_PIN			PINE7
-#define PE7_RPORT		PINE
-#define PE7_WPORT		PORTE
-#define PE7_DDR			DDRE
-#define PE7_PWM			NULL
-
-#undef PF0
-#define PF0_PIN			PINF0
-#define PF0_RPORT		PINF
-#define PF0_WPORT		PORTF
-#define PF0_DDR			DDRF
-#define PF0_PWM			NULL
-#undef PF1
-#define PF1_PIN			PINF1
-#define PF1_RPORT		PINF
-#define PF1_WPORT		PORTF
-#define PF1_DDR			DDRF
-#define PF1_PWM			NULL
-#undef PF2
-#define PF2_PIN			PINF2
-#define PF2_RPORT		PINF
-#define PF2_WPORT		PORTF
-#define PF2_DDR			DDRF
-#define PF2_PWM			NULL
-#undef PF3
-#define PF3_PIN			PINF3
-#define PF3_RPORT		PINF
-#define PF3_WPORT		PORTF
-#define PF3_DDR			DDRF
-#define PF3_PWM			NULL
-#undef PF4
-#define PF4_PIN			PINF4
-#define PF4_RPORT		PINF
-#define PF4_WPORT		PORTF
-#define PF4_DDR			DDRF
-#define PF4_PWM			NULL
-#undef PF5
-#define PF5_PIN			PINF5
-#define PF5_RPORT		PINF
-#define PF5_WPORT		PORTF
-#define PF5_DDR			DDRF
-#define PF5_PWM			NULL
-#undef PF6
-#define PF6_PIN			PINF6
-#define PF6_RPORT		PINF
-#define PF6_WPORT		PORTF
-#define PF6_DDR			DDRF
-#define PF6_PWM			NULL
-#undef PF7
-#define PF7_PIN			PINF7
-#define PF7_RPORT		PINF
-#define PF7_WPORT		PORTF
-#define PF7_DDR			DDRF
-#define PF7_PWM			NULL
-
-#undef PG0
-#define PG0_PIN			PING0
-#define PG0_RPORT		PING
-#define PG0_WPORT		PORTG
-#define PG0_DDR			DDRG
-#define PG0_PWM			NULL
-#undef PG1
-#define PG1_PIN			PING1
-#define PG1_RPORT		PING
-#define PG1_WPORT		PORTG
-#define PG1_DDR			DDRG
-#define PG1_PWM			NULL
-#undef PG2
-#define PG2_PIN			PING2
-#define PG2_RPORT		PING
-#define PG2_WPORT		PORTG
-#define PG2_DDR			DDRG
-#define PG2_PWM			NULL
-#undef PG3
-#define PG3_PIN			PING3
-#define PG3_RPORT		PING
-#define PG3_WPORT		PORTG
-#define PG3_DDR			DDRG
-#define PG3_PWM			NULL
-#undef PG4
-#define PG4_PIN			PING4
-#define PG4_RPORT		PING
-#define PG4_WPORT		PORTG
-#define PG4_DDR			DDRG
-#define PG4_PWM			NULL
-#undef PG5
-#define PG5_PIN			PING5
-#define PG5_RPORT		PING
-#define PG5_WPORT		PORTG
-#define PG5_DDR			DDRG
-#define PG5_PWM			&OCR0B
-#undef PG6
-#define PG6_PIN			PING6
-#define PG6_RPORT		PING
-#define PG6_WPORT		PORTG
-#define PG6_DDR			DDRG
-#define PG6_PWM			NULL
-#undef PG7
-#define PG7_PIN			PING7
-#define PG7_RPORT		PING
-#define PG7_WPORT		PORTG
-#define PG7_DDR			DDRG
-#define PG7_PWM			NULL
-
-#undef PH0
-#define PH0_PIN			PINH0
-#define PH0_RPORT		PINH
-#define PH0_WPORT		PORTH
-#define PH0_DDR			DDRH
-#define PH0_PWM			NULL
-#undef PH1
-#define PH1_PIN			PINH1
-#define PH1_RPORT		PINH
-#define PH1_WPORT		PORTH
-#define PH1_DDR			DDRH
-#define PH1_PWM			NULL
-#undef PH2
-#define PH2_PIN			PINH2
-#define PH2_RPORT		PINH
-#define PH2_WPORT		PORTH
-#define PH2_DDR			DDRH
-#define PH2_PWM			NULL
-#undef PH3
-#define PH3_PIN			PINH3
-#define PH3_RPORT		PINH
-#define PH3_WPORT		PORTH
-#define PH3_DDR			DDRH
-#define PH3_PWM			&OCR4AL
-#undef PH4
-#define PH4_PIN			PINH4
-#define PH4_RPORT		PINH
-#define PH4_WPORT		PORTH
-#define PH4_DDR			DDRH
-#define PH4_PWM			&OCR4BL
-#undef PH5
-#define PH5_PIN			PINH5
-#define PH5_RPORT		PINH
-#define PH5_WPORT		PORTH
-#define PH5_DDR			DDRH
-#define PH5_PWM			&OCR4CL
-#undef PH6
-#define PH6_PIN			PINH6
-#define PH6_RPORT		PINH
-#define PH6_WPORT		PORTH
-#define PH6_DDR			DDRH
-#define PH6_PWM			&OCR2B
-#undef PH7
-#define PH7_PIN			PINH7
-#define PH7_RPORT		PINH
-#define PH7_WPORT		PORTH
-#define PH7_DDR			DDRH
-#define PH7_PWM			NULL
-
-#undef PJ0
-#define PJ0_PIN			PINJ0
-#define PJ0_RPORT		PINJ
-#define PJ0_WPORT		PORTJ
-#define PJ0_DDR			DDRJ
-#define PJ0_PWM			NULL
-#undef PJ1
-#define PJ1_PIN			PINJ1
-#define PJ1_RPORT		PINJ
-#define PJ1_WPORT		PORTJ
-#define PJ1_DDR			DDRJ
-#define PJ1_PWM			NULL
-#undef PJ2
-#define PJ2_PIN			PINJ2
-#define PJ2_RPORT		PINJ
-#define PJ2_WPORT		PORTJ
-#define PJ2_DDR			DDRJ
-#define PJ2_PWM			NULL
-#undef PJ3
-#define PJ3_PIN			PINJ3
-#define PJ3_RPORT		PINJ
-#define PJ3_WPORT		PORTJ
-#define PJ3_DDR			DDRJ
-#define PJ3_PWM			NULL
-#undef PJ4
-#define PJ4_PIN			PINJ4
-#define PJ4_RPORT		PINJ
-#define PJ4_WPORT		PORTJ
-#define PJ4_DDR			DDRJ
-#define PJ4_PWM			NULL
-#undef PJ5
-#define PJ5_PIN			PINJ5
-#define PJ5_RPORT		PINJ
-#define PJ5_WPORT		PORTJ
-#define PJ5_DDR			DDRJ
-#define PJ5_PWM			NULL
-#undef PJ6
-#define PJ6_PIN			PINJ6
-#define PJ6_RPORT		PINJ
-#define PJ6_WPORT		PORTJ
-#define PJ6_DDR			DDRJ
-#define PJ6_PWM			NULL
-#undef PJ7
-#define PJ7_PIN			PINJ7
-#define PJ7_RPORT		PINJ
-#define PJ7_WPORT		PORTJ
-#define PJ7_DDR			DDRJ
-#define PJ7_PWM			NULL
-
-#undef PK0
-#define PK0_PIN			PINK0
-#define PK0_RPORT		PINK
-#define PK0_WPORT		PORTK
-#define PK0_DDR			DDRK
-#define PK0_PWM			NULL
-#undef PK1
-#define PK1_PIN			PINK1
-#define PK1_RPORT		PINK
-#define PK1_WPORT		PORTK
-#define PK1_DDR			DDRK
-#define PK1_PWM			NULL
-#undef PK2
-#define PK2_PIN			PINK2
-#define PK2_RPORT		PINK
-#define PK2_WPORT		PORTK
-#define PK2_DDR			DDRK
-#define PK2_PWM			NULL
-#undef PK3
-#define PK3_PIN			PINK3
-#define PK3_RPORT		PINK
-#define PK3_WPORT		PORTK
-#define PK3_DDR			DDRK
-#define PK3_PWM			NULL
-#undef PK4
-#define PK4_PIN			PINK4
-#define PK4_RPORT		PINK
-#define PK4_WPORT		PORTK
-#define PK4_DDR			DDRK
-#define PK4_PWM			NULL
-#undef PK5
-#define PK5_PIN			PINK5
-#define PK5_RPORT		PINK
-#define PK5_WPORT		PORTK
-#define PK5_DDR			DDRK
-#define PK5_PWM			NULL
-#undef PK6
-#define PK6_PIN			PINK6
-#define PK6_RPORT		PINK
-#define PK6_WPORT		PORTK
-#define PK6_DDR			DDRK
-#define PK6_PWM			NULL
-#undef PK7
-#define PK7_PIN			PINK7
-#define PK7_RPORT		PINK
-#define PK7_WPORT		PORTK
-#define PK7_DDR			DDRK
-#define PK7_PWM			NULL
-
-#undef PL0
-#define PL0_PIN			PINL0
-#define PL0_RPORT		PINL
-#define PL0_WPORT		PORTL
-#define PL0_DDR			DDRL
-#define PL0_PWM			NULL
-#undef PL1
-#define PL1_PIN			PINL1
-#define PL1_RPORT		PINL
-#define PL1_WPORT		PORTL
-#define PL1_DDR			DDRL
-#define PL1_PWM			NULL
-#undef PL2
-#define PL2_PIN			PINL2
-#define PL2_RPORT		PINL
-#define PL2_WPORT		PORTL
-#define PL2_DDR			DDRL
-#define PL2_PWM			NULL
-#undef PL3
-#define PL3_PIN			PINL3
-#define PL3_RPORT		PINL
-#define PL3_WPORT		PORTL
-#define PL3_DDR			DDRL
-#define PL3_PWM			&OCR5AL
-#undef PL4
-#define PL4_PIN			PINL4
-#define PL4_RPORT		PINL
-#define PL4_WPORT		PORTL
-#define PL4_DDR			DDRL
-#define PL4_PWM			&OCR5BL
-#undef PL5
-#define PL5_PIN			PINL5
-#define PL5_RPORT		PINL
-#define PL5_WPORT		PORTL
-#define PL5_DDR			DDRL
-#define PL5_PWM			&OCR5CL
-#undef PL6
-#define PL6_PIN			PINL6
-#define PL6_RPORT		PINL
-#define PL6_WPORT		PORTL
-#define PL6_DDR			DDRL
-#define PL6_PWM			NULL
-#undef PL7
-#define PL7_PIN			PINL7
-#define PL7_RPORT		PINL
-#define PL7_WPORT		PORTL
-#define PL7_DDR			DDRL
-#define PL7_PWM			NULL
-
-#endif
-
-#if defined (__AVR_AT90USB1287__)
-// SPI
-#define	SCK					DIO9
-#define	MISO				DIO11
-#define	MOSI				DIO10
-#define	SS					DIO8
-
-// change for your board
-#define	DEBUG_LED		DIO31 /* led D5 red */
-
-/*
-pins
-*/
-#define DIO0_PIN        PINA0
-#define DIO0_RPORT      PINA
-#define DIO0_WPORT      PORTA
-#define DIO0_PWM			NULL
-#define DIO0_DDR        DDRA
-
-#define DIO1_PIN        PINA1
-#define DIO1_RPORT      PINA
-#define DIO1_WPORT      PORTA
-#define DIO1_PWM			NULL
-#define DIO1_DDR        DDRA
-
-#define DIO2_PIN        PINA2
-#define DIO2_RPORT      PINA
-#define DIO2_WPORT      PORTA
-#define DIO2_PWM			NULL
-#define DIO2_DDR        DDRA
-
-#define DIO3_PIN        PINA3
-#define DIO3_RPORT      PINA
-#define DIO3_WPORT      PORTA
-#define DIO3_PWM			NULL
-#define DIO3_DDR        DDRA
-
-#define DIO4_PIN        PINA4
-#define DIO4_RPORT      PINA
-#define DIO4_WPORT      PORTA
-#define DIO4_PWM			NULL
-#define DIO4_DDR        DDRA
-
-#define DIO5_PIN        PINA5
-#define DIO5_RPORT      PINA
-#define DIO5_WPORT      PORTA
-#define DIO5_PWM			NULL
-#define DIO5_DDR        DDRA
-
-#define DIO6_PIN        PINA6
-#define DIO6_RPORT      PINA
-#define DIO6_WPORT      PORTA
-#define DIO6_PWM			NULL
-#define DIO6_DDR        DDRA
-
-#define DIO7_PIN        PINA7
-#define DIO7_RPORT      PINA
-#define DIO7_WPORT      PORTA
-#define DIO7_PWM			NULL
-#define DIO7_DDR        DDRA
-
-#define DIO8_PIN        PINB0
-#define DIO8_RPORT      PINB
-#define DIO8_WPORT      PORTB
-#define DIO8_PWM			NULL
-#define DIO8_DDR        DDRB
-
-#define DIO9_PIN        PINB1
-#define DIO9_RPORT      PINB
-#define DIO9_WPORT      PORTB
-#define DIO9_PWM			NULL
-#define DIO9_DDR        DDRB
-
-#define DIO10_PIN       PINB2
-#define DIO10_RPORT     PINB
-#define DIO10_WPORT     PORTB
-#define DIO10_PWM			NULL
-#define DIO10_DDR       DDRB
-
-#define DIO11_PIN       PINB3
-#define DIO11_RPORT     PINB
-#define DIO11_WPORT     PORTB
-#define DIO11_PWM			NULL
-#define DIO11_DDR       DDRB
-
-#define DIO12_PIN       PINB4
-#define DIO12_RPORT     PINB
-#define DIO12_WPORT     PORTB
-#define DIO12_PWM			NULL
-#define DIO12_DDR       DDRB
-
-#define DIO13_PIN       PINB5
-#define DIO13_RPORT     PINB
-#define DIO13_WPORT     PORTB
-#define DIO13_PWM			NULL
-#define DIO13_DDR       DDRB
-
-#define DIO14_PIN       PINB6
-#define DIO14_RPORT     PINB
-#define DIO14_WPORT     PORTB
-#define DIO14_PWM			NULL
-#define DIO14_DDR       DDRB
-
-#define DIO15_PIN       PINB7
-#define DIO15_RPORT     PINB
-#define DIO15_WPORT     PORTB
-#define DIO15_PWM			NULL
-#define DIO15_DDR       DDRB
-
-#define DIO16_PIN       PINC0
-#define DIO16_RPORT     PINC
-#define DIO16_WPORT     PORTC
-#define DIO16_PWM			NULL
-#define DIO16_DDR       DDRC
-
-#define DIO17_PIN       PINC1
-#define DIO17_RPORT     PINC
-#define DIO17_WPORT     PORTC
-#define DIO17_PWM			NULL
-#define DIO17_DDR       DDRC
-
-#define DIO18_PIN       PINC2
-#define DIO18_RPORT     PINC
-#define DIO18_WPORT     PORTC
-#define DIO18_PWM			NULL
-#define DIO18_DDR       DDRC
-
-#define DIO19_PIN       PINC3
-#define DIO19_RPORT     PINC
-#define DIO19_WPORT     PORTC
-#define DIO19_PWM			NULL
-#define DIO19_DDR       DDRC
-
-#define DIO20_PIN       PINC4
-#define DIO20_RPORT     PINC
-#define DIO20_WPORT     PORTC
-#define DIO20_PWM			NULL
-#define DIO20_DDR       DDRC
-
-#define DIO21_PIN       PINC5
-#define DIO21_RPORT     PINC
-#define DIO21_WPORT     PORTC
-#define DIO21_PWM			NULL
-#define DIO21_DDR       DDRC
-
-#define DIO22_PIN       PINC6
-#define DIO22_RPORT     PINC
-#define DIO22_WPORT     PORTC
-#define DIO22_PWM			NULL
-#define DIO22_DDR       DDRC
-
-#define DIO23_PIN       PINC7
-#define DIO23_RPORT     PINC
-#define DIO23_WPORT     PORTC
-#define DIO23_PWM			NULL
-#define DIO23_DDR       DDRC
-
-#define DIO24_PIN       PIND0
-#define DIO24_RPORT     PIND
-#define DIO24_WPORT     PORTD
-#define DIO24_PWM			NULL
-#define DIO24_DDR       DDRD
-
-#define DIO25_PIN       PIND1
-#define DIO25_RPORT     PIND
-#define DIO25_WPORT     PORTD
-#define DIO25_PWM			NULL
-#define DIO25_DDR       DDRD
-
-#define DIO26_PIN       PIND2
-#define DIO26_RPORT     PIND
-#define DIO26_WPORT     PORTD
-#define DIO26_PWM			NULL
-#define DIO26_DDR       DDRD
-
-#define DIO27_PIN       PIND3
-#define DIO27_RPORT     PIND
-#define DIO27_WPORT     PORTD
-#define DIO27_PWM			NULL
-#define DIO27_DDR       DDRD
-
-#define DIO28_PIN       PIND4
-#define DIO28_RPORT     PIND
-#define DIO28_WPORT     PORTD
-#define DIO28_PWM			NULL
-#define DIO28_DDR       DDRD
-
-#define DIO29_PIN       PIND5
-#define DIO29_RPORT     PIND
-#define DIO29_WPORT     PORTD
-#define DIO29_PWM			NULL
-#define DIO29_DDR       DDRD
-
-#define DIO30_PIN       PIND6
-#define DIO30_RPORT     PIND
-#define DIO30_WPORT     PORTD
-#define DIO30_PWM			NULL
-#define DIO30_DDR       DDRD
-
-#define DIO31_PIN       PIND7
-#define DIO31_RPORT     PIND
-#define DIO31_WPORT     PORTD
-#define DIO31_PWM			NULL
-#define DIO31_DDR       DDRD
-
-
-#define DIO32_PIN       PINE0
-#define DIO32_RPORT     PINE
-#define DIO32_WPORT     PORTE
-#define DIO32_PWM			NULL
-#define DIO32_DDR       DDRE
-
-#define DIO33_PIN       PINE1
-#define DIO33_RPORT     PINE
-#define DIO33_WPORT     PORTE
-#define DIO33_PWM			NULL
-#define DIO33_DDR       DDRE
-
-#define DIO34_PIN       PINE2
-#define DIO34_RPORT     PINE
-#define DIO34_WPORT     PORTE
-#define DIO34_PWM			NULL
-#define DIO34_DDR       DDRE
-
-#define DIO35_PIN       PINE3
-#define DIO35_RPORT     PINE
-#define DIO35_WPORT     PORTE
-#define DIO35_PWM			NULL
-#define DIO35_DDR       DDRE
-
-#define DIO36_PIN       PINE4
-#define DIO36_RPORT     PINE
-#define DIO36_WPORT     PORTE
-#define DIO36_PWM			NULL
-#define DIO36_DDR       DDRE
-
-#define DIO37_PIN       PINE5
-#define DIO37_RPORT     PINE
-#define DIO37_WPORT     PORTE
-#define DIO37_PWM			NULL
-#define DIO37_DDR       DDRE
-
-#define DIO38_PIN       PINE6
-#define DIO38_RPORT     PINE
-#define DIO38_WPORT     PORTE
-#define DIO38_PWM			NULL
-#define DIO38_DDR       DDRE
-
-#define DIO39_PIN       PINE7
-#define DIO39_RPORT     PINE
-#define DIO39_WPORT     PORTE
-#define DIO39_PWM			NULL
-#define DIO39_DDR       DDRE
-
-#define AIO0_PIN PINF0
-#define AIO0_RPORT PINF
-#define AIO0_WPORT PORTF
-#define AIO0_PWM			NULL
-#define AIO0_DDR DDRF
-
-#define AIO1_PIN PINF1
-#define AIO1_RPORT PINF
-#define AIO1_WPORT PORTF
-#define AIO1_PWM			NULL
-#define AIO1_DDR DDRF
-
-#define AIO2_PIN PINF2
-#define AIO2_RPORT PINF
-#define AIO2_WPORT PORTF
-#define AIO2_PWM			NULL
-#define AIO2_DDR DDRF
-
-#define AIO3_PIN PINF3
-#define AIO3_RPORT PINF
-#define AIO3_WPORT PORTF
-#define AIO3_PWM			NULL
-#define AIO3_DDR DDRF
-
-#define AIO4_PIN PINF4
-#define AIO4_RPORT PINF
-#define AIO4_WPORT PORTF
-#define AIO4_PWM			NULL
-#define AIO4_DDR DDRF
-
-#define AIO5_PIN PINF5
-#define AIO5_RPORT PINF
-#define AIO5_WPORT PORTF
-#define AIO5_PWM			NULL
-#define AIO5_DDR DDRF
-
-#define AIO6_PIN PINF6
-#define AIO6_RPORT PINF
-#define AIO6_WPORT PORTF
-#define AIO6_PWM			NULL
-#define AIO6_DDR DDRF
-
-#define AIO7_PIN PINF7
-#define AIO7_RPORT PINF
-#define AIO7_WPORT PORTF
-#define AIO7_PWM			NULL
-#define AIO7_DDR DDRF
-
-#define DIO40_PIN       PINF0
-#define DIO40_RPORT     PINF
-#define DIO40_WPORT     PORTF
-#define DIO40_PWM			NULL
-#define DIO40_DDR       DDRF
-
-#define DIO41_PIN       PINF1
-#define DIO41_RPORT     PINF
-#define DIO41_WPORT     PORTF
-#define DIO41_PWM			NULL
-#define DIO41_DDR       DDRF
-
-#define DIO42_PIN       PINF2
-#define DIO42_RPORT     PINF
-#define DIO42_WPORT     PORTF
-#define DIO42_PWM			NULL
-#define DIO42_DDR       DDRF
-
-#define DIO43_PIN       PINF3
-#define DIO43_RPORT     PINF
-#define DIO43_WPORT     PORTF
-#define DIO43_PWM			NULL
-#define DIO43_DDR       DDRF
-
-#define DIO44_PIN       PINF4
-#define DIO44_RPORT     PINF
-#define DIO44_WPORT     PORTF
-#define DIO44_PWM			NULL
-#define DIO44_DDR       DDRF
-
-#define DIO45_PIN       PINF5
-#define DIO45_RPORT     PINF
-#define DIO45_WPORT     PORTF
-#define DIO45_PWM			NULL
-#define DIO45_DDR       DDRF
-
-#define DIO46_PIN       PINF6
-#define DIO46_RPORT     PINF
-#define DIO46_WPORT     PORTF
-#define DIO46_PWM			NULL
-#define DIO46_DDR       DDRF
-
-#define DIO47_PIN       PINF7
-#define DIO47_RPORT     PINF
-#define DIO47_WPORT     PORTF
-#define DIO47_PWM			NULL
-#define DIO47_DDR       DDRF
-
-
-
-#undef PA0
-#define PA0_PIN			PINA0
-#define PA0_RPORT		PINA
-#define PA0_WPORT		PORTA
-#define PA0_PWM			NULL
-#define PA0_DDR			DDRA
-#undef PA1
-#define PA1_PIN			PINA1
-#define PA1_RPORT		PINA
-#define PA1_WPORT		PORTA
-#define PA1_PWM			NULL
-#define PA1_DDR			DDRA
-#undef PA2
-#define PA2_PIN			PINA2
-#define PA2_RPORT		PINA
-#define PA2_WPORT		PORTA
-#define PA2_PWM			NULL
-#define PA2_DDR			DDRA
-#undef PA3
-#define PA3_PIN			PINA3
-#define PA3_RPORT		PINA
-#define PA3_WPORT		PORTA
-#define PA3_PWM			NULL
-#define PA3_DDR			DDRA
-#undef PA4
-#define PA4_PIN			PINA4
-#define PA4_RPORT		PINA
-#define PA4_WPORT		PORTA
-#define PA4_PWM			NULL
-#define PA4_DDR			DDRA
-#undef PA5
-#define PA5_PIN			PINA5
-#define PA5_RPORT		PINA
-#define PA5_WPORT		PORTA
-#define PA5_PWM			NULL
-#define PA5_DDR			DDRA
-#undef PA6
-#define PA6_PIN			PINA6
-#define PA6_RPORT		PINA
-#define PA6_WPORT		PORTA
-#define PA6_PWM			NULL
-#define PA6_DDR			DDRA
-#undef PA7
-#define PA7_PIN			PINA7
-#define PA7_RPORT		PINA
-#define PA7_WPORT		PORTA
-#define PA7_PWM			NULL
-#define PA7_DDR			DDRA
-
-#undef PB0
-#define PB0_PIN			PINB0
-#define PB0_RPORT		PINB
-#define PB0_WPORT		PORTB
-#define PB0_PWM			NULL
-#define PB0_DDR			DDRB
-#undef PB1
-#define PB1_PIN			PINB1
-#define PB1_RPORT		PINB
-#define PB1_WPORT		PORTB
-#define PB1_PWM			NULL
-#define PB1_DDR			DDRB
-#undef PB2
-#define PB2_PIN			PINB2
-#define PB2_RPORT		PINB
-#define PB2_WPORT		PORTB
-#define PB2_PWM			NULL
-#define PB2_DDR			DDRB
-#undef PB3
-#define PB3_PIN			PINB3
-#define PB3_RPORT		PINB
-#define PB3_WPORT		PORTB
-#define PB3_PWM			NULL
-#define PB3_DDR			DDRB
-#undef PB4
-#define PB4_PIN			PINB4
-#define PB4_RPORT		PINB
-#define PB4_WPORT		PORTB
-#define PB4_PWM			NULL
-#define PB4_DDR			DDRB
-#undef PB5
-#define PB5_PIN			PINB5
-#define PB5_RPORT		PINB
-#define PB5_WPORT		PORTB
-#define PB5_PWM			NULL
-#define PB5_DDR			DDRB
-#undef PB6
-#define PB6_PIN			PINB6
-#define PB6_RPORT		PINB
-#define PB6_WPORT		PORTB
-#define PB6_PWM			NULL
-#define PB6_DDR			DDRB
-#undef PB7
-#define PB7_PIN			PINB7
-#define PB7_RPORT		PINB
-#define PB7_WPORT		PORTB
-#define PB7_PWM			NULL
-#define PB7_DDR			DDRB
-
-#undef PC0
-#define PC0_PIN			PINC0
-#define PC0_RPORT		PINC
-#define PC0_WPORT		PORTC
-#define PC0_PWM			NULL
-#define PC0_DDR			DDRC
-#undef PC1
-#define PC1_PIN			PINC1
-#define PC1_RPORT		PINC
-#define PC1_WPORT		PORTC
-#define PC1_PWM			NULL
-#define PC1_DDR			DDRC
-#undef PC2
-#define PC2_PIN			PINC2
-#define PC2_RPORT		PINC
-#define PC2_WPORT		PORTC
-#define PC2_PWM			NULL
-#define PC2_DDR			DDRC
-#undef PC3
-#define PC3_PIN			PINC3
-#define PC3_RPORT		PINC
-#define PC3_WPORT		PORTC
-#define PC3_PWM			NULL
-#define PC3_DDR			DDRC
-#undef PC4
-#define PC4_PIN			PINC4
-#define PC4_RPORT		PINC
-#define PC4_WPORT		PORTC
-#define PC4_PWM			NULL
-#define PC4_DDR			DDRC
-#undef PC5
-#define PC5_PIN			PINC5
-#define PC5_RPORT		PINC
-#define PC5_WPORT		PORTC
-#define PC5_PWM			NULL
-#define PC5_DDR			DDRC
-#undef PC6
-#define PC6_PIN			PINC6
-#define PC6_RPORT		PINC
-#define PC6_WPORT		PORTC
-#define PC6_PWM			NULL
-#define PC6_DDR			DDRC
-#undef PC7
-#define PC7_PIN			PINC7
-#define PC7_RPORT		PINC
-#define PC7_WPORT		PORTC
-#define PC7_PWM			NULL
-#define PC7_DDR			DDRC
-
-#undef PD0
-#define PD0_PIN			PIND0
-#define PD0_RPORT		PIND
-#define PD0_WPORT		PORTD
-#define PD0_PWM			NULL
-#define PD0_DDR			DDRD
-#undef PD1
-#define PD1_PIN			PIND1
-#define PD1_RPORT		PIND
-#define PD1_WPORT		PORTD
-#define PD1_PWM			NULL
-#define PD1_DDR			DDRD
-#undef PD2
-#define PD2_PIN			PIND2
-#define PD2_RPORT		PIND
-#define PD2_WPORT		PORTD
-#define PD2_PWM			NULL
-#define PD2_DDR			DDRD
-#undef PD3
-#define PD3_PIN			PIND3
-#define PD3_RPORT		PIND
-#define PD3_WPORT		PORTD
-#define PD3_PWM			NULL
-#define PD3_DDR			DDRD
-#undef PD4
-#define PD4_PIN			PIND4
-#define PD4_RPORT		PIND
-#define PD4_WPORT		PORTD
-#define PD4_PWM			NULL
-#define PD4_DDR			DDRD
-#undef PD5
-#define PD5_PIN			PIND5
-#define PD5_RPORT		PIND
-#define PD5_WPORT		PORTD
-#define PD5_PWM			NULL
-#define PD5_DDR			DDRD
-#undef PD6
-#define PD6_PIN			PIND6
-#define PD6_RPORT		PIND
-#define PD6_WPORT		PORTD
-#define PD6_PWM			NULL
-#define PD6_DDR			DDRD
-#undef PD7
-#define PD7_PIN			PIND7
-#define PD7_RPORT		PIND
-#define PD7_WPORT		PORTD
-#define PD7_PWM			NULL
-#define PD7_DDR			DDRD
-
-#undef PE0
-#define PE0_PIN			PINE0
-#define PE0_RPORT		PINE
-#define PE0_WPORT		PORTE
-#define PE0_PWM			NULL
-#define PE0_DDR			DDRE
-#undef PE1
-#define PE1_PIN			PINE1
-#define PE1_RPORT		PINE
-#define PE1_WPORT		PORTE
-#define PE1_PWM			NULL
-#define PE1_DDR			DDRE
-#undef PE2
-#define PE2_PIN			PINE2
-#define PE2_RPORT		PINE
-#define PE2_WPORT		PORTE
-#define PE2_PWM			NULL
-#define PE2_DDR			DDRE
-#undef PE3
-#define PE3_PIN			PINE3
-#define PE3_RPORT		PINE
-#define PE3_WPORT		PORTE
-#define PE3_PWM			NULL
-#define PE3_DDR			DDRE
-#undef PE4
-#define PE4_PIN			PINE4
-#define PE4_RPORT		PINE
-#define PE4_WPORT		PORTE
-#define PE4_PWM			NULL
-#define PE4_DDR			DDRE
-#undef PE5
-#define PE5_PIN			PINE5
-#define PE5_RPORT		PINE
-#define PE5_WPORT		PORTE
-#define PE5_PWM			NULL
-#define PE5_DDR			DDRE
-#undef PE6
-#define PE6_PIN			PINE6
-#define PE6_RPORT		PINE
-#define PE6_WPORT		PORTE
-#define PE6_PWM			NULL
-#define PE6_DDR			DDRE
-#undef PE7
-#define PE7_PIN			PINE7
-#define PE7_RPORT		PINE
-#define PE7_WPORT		PORTE
-#define PE7_PWM			NULL
-#define PE7_DDR			DDRE
-
-#undef PF0
-#define PF0_PIN			PINF0
-#define PF0_RPORT		PINF
-#define PF0_WPORT		PORTF
-#define PF0_PWM			NULL
-#define PF0_DDR			DDRF
-#undef PF1
-#define PF1_PIN			PINF1
-#define PF1_RPORT		PINF
-#define PF1_WPORT		PORTF
-#define PF1_PWM			NULL
-#define PF1_DDR			DDRF
-#undef PF2
-#define PF2_PIN			PINF2
-#define PF2_RPORT		PINF
-#define PF2_WPORT		PORTF
-#define PF2_PWM			NULL
-#define PF2_DDR			DDRF
-#undef PF3
-#define PF3_PIN			PINF3
-#define PF3_RPORT		PINF
-#define PF3_WPORT		PORTF
-#define PF3_PWM			NULL
-#define PF3_DDR			DDRF
-#undef PF4
-#define PF4_PIN			PINF4
-#define PF4_RPORT		PINF
-#define PF4_WPORT		PORTF
-#define PF4_PWM			NULL
-#define PF4_DDR			DDRF
-#undef PF5
-#define PF5_PIN			PINF5
-#define PF5_RPORT		PINF
-#define PF5_WPORT		PORTF
-#define PF5_PWM			NULL
-#define PF5_DDR			DDRF
-#undef PF6
-#define PF6_PIN			PINF6
-#define PF6_RPORT		PINF
-#define PF6_WPORT		PORTF
-#define PF6_PWM			NULL
-#define PF6_DDR			DDRF
-#undef PF7
-#define PF7_PIN			PINF7
-#define PF7_RPORT		PINF
-#define PF7_WPORT		PORTF
-#define PF7_PWM			NULL
-#define PF7_DDR			DDRF
-#endif
-
-#ifndef	DIO0_PIN
-#error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
-#endif
-
+/*
+  This code contibuted by Triffid_Hunter and modified by Kliment
+  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
+*/
+
+#ifndef	_ARDUINO_H
+#define	_ARDUINO_H
+
+#include <avr/io.h>
+
+/*
+  utility functions
+*/
+
+#ifndef MASK
+/// MASKING- returns \f$2^PIN\f$
+#define MASK(PIN)  (1 << PIN)
+#endif
+
+/*
+  magic I/O routines
+  now you can simply SET_OUTPUT(STEP); WRITE(STEP, 1); WRITE(STEP, 0);
+*/
+
+/// Read a pin
+#define _READ(IO) ((bool)(DIO ## IO ## _RPORT & MASK(DIO ## IO ## _PIN)))
+/// write to a pin
+// On some boards pins > 0x100 are used. These are not converted to atomic actions. An critical section is needed.
+
+#define _WRITE_NC(IO, v)  do { if (v) {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); } else {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }; } while (0)
+
+#define _WRITE_C(IO, v)   do { if (v) { \
+                                         CRITICAL_SECTION_START; \
+                                         {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); }\
+                                         CRITICAL_SECTION_END; \
+                                       }\
+                                       else {\
+                                         CRITICAL_SECTION_START; \
+                                         {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }\
+                                         CRITICAL_SECTION_END; \
+                                       }\
+                                     }\
+                                     while (0)
+
+#define _WRITE(IO, v)  do {  if (&(DIO ##  IO ## _RPORT) >= (uint8_t *)0x100) {_WRITE_C(IO, v); } else {_WRITE_NC(IO, v); }; } while (0)
+
+/// toggle a pin
+#define _TOGGLE(IO)  do {DIO ##  IO ## _RPORT = MASK(DIO ## IO ## _PIN); } while (0)
+
+/// set pin as input
+#define	_SET_INPUT(IO) do {DIO ##  IO ## _DDR &= ~MASK(DIO ## IO ## _PIN); } while (0)
+/// set pin as output
+#define	_SET_OUTPUT(IO) do {DIO ##  IO ## _DDR |=  MASK(DIO ## IO ## _PIN); } while (0)
+
+/// check if pin is an input
+#define	_GET_INPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) == 0)
+/// check if pin is an output
+#define	_GET_OUTPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) != 0)
+
+/// check if pin is an timer
+#define	_GET_TIMER(IO)  ((DIO ## IO ## _PWM)
+
+//  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
+
+/// Read a pin wrapper
+#define READ(IO)  _READ(IO)
+/// Write to a pin wrapper
+#define WRITE(IO, v)  _WRITE(IO, v)
+
+/// toggle a pin wrapper
+#define TOGGLE(IO)  _TOGGLE(IO)
+
+/// set pin as input wrapper
+#define SET_INPUT(IO)  _SET_INPUT(IO)
+/// set pin as output wrapper
+#define SET_OUTPUT(IO)  _SET_OUTPUT(IO)
+
+/// check if pin is an input wrapper
+#define GET_INPUT(IO)  _GET_INPUT(IO)
+/// check if pin is an output wrapper
+#define GET_OUTPUT(IO)  _GET_OUTPUT(IO)
+
+/// check if pin is an timer wrapper
+#define GET_TIMER(IO)  _GET_TIMER(IO)
+
+/*
+	ports and functions
+
+	added as necessary or if I feel like it- not a comprehensive list!
+*/
+
+#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega328__) || defined (__AVR_ATmega328P__)
+// UART
+#define	RXD					DIO0
+#define	TXD					DIO1
+
+// SPI
+#define	SCK					DIO13
+#define	MISO				DIO12
+#define	MOSI				DIO11
+#define	SS					DIO10
+
+// TWI (I2C)
+#define	SCL					AIO5
+#define	SDA					AIO4
+
+// timers and PWM
+#define	OC0A				DIO6
+#define	OC0B				DIO5
+#define	OC1A				DIO9
+#define	OC1B				DIO10
+#define	OC2A				DIO11
+#define	OC2B				DIO3
+
+#define	DEBUG_LED		AIO5
+
+/*
+pins
+*/
+
+#define DIO0_PIN		PIND0
+#define DIO0_RPORT	PIND
+#define DIO0_WPORT	PORTD
+#define DIO0_DDR		DDRD
+#define DIO0_PWM		NULL
+
+#define DIO1_PIN		PIND1
+#define DIO1_RPORT	PIND
+#define DIO1_WPORT	PORTD
+#define DIO1_DDR		DDRD
+#define DIO1_PWM		NULL
+
+#define DIO2_PIN		PIND2
+#define DIO2_RPORT	PIND
+#define DIO2_WPORT	PORTD
+#define DIO2_DDR		DDRD
+#define DIO2_PWM		NULL
+
+#define DIO3_PIN		PIND3
+#define DIO3_RPORT	PIND
+#define DIO3_WPORT	PORTD
+#define DIO3_DDR		DDRD
+#define DIO3_PWM		&OCR2B
+
+#define DIO4_PIN		PIND4
+#define DIO4_RPORT	PIND
+#define DIO4_WPORT	PORTD
+#define DIO4_DDR		DDRD
+#define DIO4_PWM		NULL
+
+#define DIO5_PIN		PIND5
+#define DIO5_RPORT	PIND
+#define DIO5_WPORT	PORTD
+#define DIO5_DDR		DDRD
+#define DIO5_PWM		&OCR0B
+
+#define DIO6_PIN		PIND6
+#define DIO6_RPORT	PIND
+#define DIO6_WPORT	PORTD
+#define DIO6_DDR		DDRD
+#define DIO6_PWM		&OCR0A
+
+#define DIO7_PIN		PIND7
+#define DIO7_RPORT	PIND
+#define DIO7_WPORT	PORTD
+#define DIO7_DDR		DDRD
+#define DIO7_PWM		NULL
+
+#define DIO8_PIN		PINB0
+#define DIO8_RPORT	PINB
+#define DIO8_WPORT	PORTB
+#define DIO8_DDR		DDRB
+#define DIO8_PWM		NULL
+
+#define DIO9_PIN		PINB1
+#define DIO9_RPORT	PINB
+#define DIO9_WPORT	PORTB
+#define DIO9_DDR		DDRB
+#define DIO9_PWM		NULL
+
+#define DIO10_PIN		PINB2
+#define DIO10_RPORT	PINB
+#define DIO10_WPORT	PORTB
+#define DIO10_DDR		DDRB
+#define DIO10_PWM		NULL
+
+#define DIO11_PIN		PINB3
+#define DIO11_RPORT	PINB
+#define DIO11_WPORT	PORTB
+#define DIO11_DDR		DDRB
+#define DIO11_PWM		&OCR2A
+
+#define DIO12_PIN		PINB4
+#define DIO12_RPORT	PINB
+#define DIO12_WPORT	PORTB
+#define DIO12_DDR		DDRB
+#define DIO12_PWM		NULL
+
+#define DIO13_PIN		PINB5
+#define DIO13_RPORT	PINB
+#define DIO13_WPORT	PORTB
+#define DIO13_DDR		DDRB
+#define DIO13_PWM		NULL
+
+
+#define DIO14_PIN		PINC0
+#define DIO14_RPORT	PINC
+#define DIO14_WPORT	PORTC
+#define DIO14_DDR		DDRC
+#define DIO14_PWM		NULL
+
+#define DIO15_PIN		PINC1
+#define DIO15_RPORT	PINC
+#define DIO15_WPORT	PORTC
+#define DIO15_DDR		DDRC
+#define DIO15_PWM		NULL
+
+#define DIO16_PIN		PINC2
+#define DIO16_RPORT	PINC
+#define DIO16_WPORT	PORTC
+#define DIO16_DDR		DDRC
+#define DIO16_PWM		NULL
+
+#define DIO17_PIN		PINC3
+#define DIO17_RPORT	PINC
+#define DIO17_WPORT	PORTC
+#define DIO17_DDR		DDRC
+#define DIO17_PWM		NULL
+
+#define DIO18_PIN		PINC4
+#define DIO18_RPORT	PINC
+#define DIO18_WPORT	PORTC
+#define DIO18_DDR		DDRC
+#define DIO18_PWM		NULL
+
+#define DIO19_PIN		PINC5
+#define DIO19_RPORT	PINC
+#define DIO19_WPORT	PORTC
+#define DIO19_DDR		DDRC
+#define DIO19_PWM		NULL
+
+#define DIO20_PIN		PINC6
+#define DIO20_RPORT	PINC
+#define DIO20_WPORT	PORTC
+#define DIO20_DDR		DDRC
+#define DIO20_PWM		NULL
+
+#define DIO21_PIN		PINC7
+#define DIO21_RPORT	PINC
+#define DIO21_WPORT	PORTC
+#define DIO21_DDR		DDRC
+#define DIO21_PWM		NULL
+
+
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_DDR			DDRB
+#define PB0_PWM			NULL
+
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_DDR			DDRB
+#define PB1_PWM			NULL
+
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_DDR			DDRB
+#define PB2_PWM			NULL
+
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_DDR			DDRB
+#define PB3_PWM			&OCR2A
+
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_DDR			DDRB
+#define PB4_PWM			NULL
+
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_DDR			DDRB
+#define PB5_PWM			NULL
+
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_DDR			DDRB
+#define PB6_PWM			NULL
+
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_DDR			DDRB
+#define PB7_PWM			NULL
+
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_DDR			DDRC
+#define PC0_PWM			NULL
+
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_DDR			DDRC
+#define PC1_PWM			NULL
+
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_DDR			DDRC
+#define PC2_PWM			NULL
+
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_DDR			DDRC
+#define PC3_PWM			NULL
+
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_DDR			DDRC
+#define PC4_PWM			NULL
+
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_DDR			DDRC
+#define PC5_PWM			NULL
+
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_DDR			DDRC
+#define PC6_PWM			NULL
+
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_DDR			DDRC
+#define PC7_PWM			NULL
+
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_DDR			DDRD
+#define PD0_PWM			NULL
+
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_DDR			DDRD
+#define PD1_PWM			NULL
+
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_DDR			DDRD
+#define PD2_PWM			NULL
+
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_DDR			DDRD
+#define PD3_PWM			&OCR2B
+
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_DDR			DDRD
+#define PD4_PWM			NULL
+
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_DDR			DDRD
+#define PD5_PWM			&OCR0B
+
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_DDR			DDRD
+#define PD6_PWM			&OCR0A
+
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_DDR			DDRD
+#define PD7_PWM			NULL
+#endif	/*	_AVR_ATmega{168,328,328P}__ */
+
+#if defined (__AVR_ATmega644__) || defined (__AVR_ATmega644P__) || defined (__AVR_ATmega644PA__)
+// UART
+#define	RXD					DIO8
+#define	TXD					DIO9
+#define	RXD0				DIO8
+#define	TXD0				DIO9
+
+#define	RXD1				DIO10
+#define	TXD1				DIO11
+
+// SPI
+#define	SCK					DIO7
+#define	MISO				DIO6
+#define	MOSI				DIO5
+#define	SS					DIO4
+
+// TWI (I2C)
+#define	SCL					DIO16
+#define	SDA					DIO17
+
+// timers and PWM
+#define	OC0A				DIO3
+#define	OC0B				DIO4
+#define	OC1A				DIO13
+#define	OC1B				DIO12
+#define	OC2A				DIO15
+#define	OC2B				DIO14
+
+#define	DEBUG_LED		DIO0
+/*
+pins
+*/
+
+#define DIO0_PIN		PINB0
+#define DIO0_RPORT	PINB
+#define DIO0_WPORT	PORTB
+#define DIO0_DDR		DDRB
+#define DIO0_PWM		NULL
+
+#define DIO1_PIN		PINB1
+#define DIO1_RPORT	PINB
+#define DIO1_WPORT	PORTB
+#define DIO1_DDR		DDRB
+#define DIO1_PWM		NULL
+
+#define DIO2_PIN		PINB2
+#define DIO2_RPORT	PINB
+#define DIO2_WPORT	PORTB
+#define DIO2_DDR		DDRB
+#define DIO2_PWM		NULL
+
+#define DIO3_PIN		PINB3
+#define DIO3_RPORT	PINB
+#define DIO3_WPORT	PORTB
+#define DIO3_DDR		DDRB
+#define DIO3_PWM		OCR0A
+
+#define DIO4_PIN		PINB4
+#define DIO4_RPORT	PINB
+#define DIO4_WPORT	PORTB
+#define DIO4_DDR		DDRB
+#define DIO4_PWM		OCR0B
+
+#define DIO5_PIN		PINB5
+#define DIO5_RPORT	PINB
+#define DIO5_WPORT	PORTB
+#define DIO5_DDR		DDRB
+#define DIO5_PWM		NULL
+
+#define DIO6_PIN		PINB6
+#define DIO6_RPORT	PINB
+#define DIO6_WPORT	PORTB
+#define DIO6_DDR		DDRB
+#define DIO6_PWM		NULL
+
+#define DIO7_PIN		PINB7
+#define DIO7_RPORT	PINB
+#define DIO7_WPORT	PORTB
+#define DIO7_DDR		DDRB
+#define DIO7_PWM		NULL
+
+#define DIO8_PIN		PIND0
+#define DIO8_RPORT	PIND
+#define DIO8_WPORT	PORTD
+#define DIO8_DDR		DDRD
+#define DIO8_PWM		NULL
+
+#define DIO9_PIN		PIND1
+#define DIO9_RPORT	PIND
+#define DIO9_WPORT	PORTD
+#define DIO9_DDR		DDRD
+#define DIO9_PWM		NULL
+
+#define DIO10_PIN		PIND2
+#define DIO10_RPORT	PIND
+#define DIO10_WPORT	PORTD
+#define DIO10_DDR		DDRD
+#define DIO10_PWM		NULL
+
+#define DIO11_PIN		PIND3
+#define DIO11_RPORT	PIND
+#define DIO11_WPORT	PORTD
+#define DIO11_DDR		DDRD
+#define DIO11_PWM		NULL
+
+#define DIO12_PIN		PIND4
+#define DIO12_RPORT	PIND
+#define DIO12_WPORT	PORTD
+#define DIO12_DDR		DDRD
+#define DIO12_PWM		OCR1B
+
+#define DIO13_PIN		PIND5
+#define DIO13_RPORT	PIND
+#define DIO13_WPORT	PORTD
+#define DIO13_DDR		DDRD
+#define DIO13_PWM		OCR1A
+
+#define DIO14_PIN		PIND6
+#define DIO14_RPORT	PIND
+#define DIO14_WPORT	PORTD
+#define DIO14_DDR		DDRD
+#define DIO14_PWM		OCR2B
+
+#define DIO15_PIN		PIND7
+#define DIO15_RPORT	PIND
+#define DIO15_WPORT	PORTD
+#define DIO15_DDR		DDRD
+#define DIO15_PWM		OCR2A
+
+#define DIO16_PIN		PINC0
+#define DIO16_RPORT	PINC
+#define DIO16_WPORT	PORTC
+#define DIO16_DDR		DDRC
+#define DIO16_PWM		NULL
+
+#define DIO17_PIN		PINC1
+#define DIO17_RPORT	PINC
+#define DIO17_WPORT	PORTC
+#define DIO17_DDR		DDRC
+#define DIO17_PWM		NULL
+
+#define DIO18_PIN		PINC2
+#define DIO18_RPORT	PINC
+#define DIO18_WPORT	PORTC
+#define DIO18_DDR		DDRC
+#define DIO18_PWM		NULL
+
+#define DIO19_PIN		PINC3
+#define DIO19_RPORT	PINC
+#define DIO19_WPORT	PORTC
+#define DIO19_DDR		DDRC
+#define DIO19_PWM		NULL
+
+#define DIO20_PIN		PINC4
+#define DIO20_RPORT	PINC
+#define DIO20_WPORT	PORTC
+#define DIO20_DDR		DDRC
+#define DIO20_PWM		NULL
+
+#define DIO21_PIN		PINC5
+#define DIO21_RPORT	PINC
+#define DIO21_WPORT	PORTC
+#define DIO21_DDR		DDRC
+#define DIO21_PWM		NULL
+
+#define DIO22_PIN		PINC6
+#define DIO22_RPORT	PINC
+#define DIO22_WPORT	PORTC
+#define DIO22_DDR		DDRC
+#define DIO22_PWM		NULL
+
+#define DIO23_PIN		PINC7
+#define DIO23_RPORT	PINC
+#define DIO23_WPORT	PORTC
+#define DIO23_DDR		DDRC
+#define DIO23_PWM		NULL
+
+#define DIO24_PIN		PINA7
+#define DIO24_RPORT	PINA
+#define DIO24_WPORT	PORTA
+#define DIO24_DDR		DDRA
+#define DIO24_PWM		NULL
+
+#define DIO25_PIN		PINA6
+#define DIO25_RPORT	PINA
+#define DIO25_WPORT	PORTA
+#define DIO25_DDR		DDRA
+#define DIO25_PWM		NULL
+
+#define DIO26_PIN		PINA5
+#define DIO26_RPORT	PINA
+#define DIO26_WPORT	PORTA
+#define DIO26_DDR		DDRA
+#define DIO26_PWM		NULL
+
+#define DIO27_PIN		PINA4
+#define DIO27_RPORT	PINA
+#define DIO27_WPORT	PORTA
+#define DIO27_DDR		DDRA
+#define DIO27_PWM		NULL
+
+#define DIO28_PIN		PINA3
+#define DIO28_RPORT	PINA
+#define DIO28_WPORT	PORTA
+#define DIO28_DDR		DDRA
+#define DIO28_PWM		NULL
+
+#define DIO29_PIN		PINA2
+#define DIO29_RPORT	PINA
+#define DIO29_WPORT	PORTA
+#define DIO29_DDR		DDRA
+#define DIO29_PWM		NULL
+
+#define DIO30_PIN		PINA1
+#define DIO30_RPORT	PINA
+#define DIO30_WPORT	PORTA
+#define DIO30_DDR		DDRA
+#define DIO30_PWM		NULL
+
+#define DIO31_PIN		PINA0
+#define DIO31_RPORT	PINA
+#define DIO31_WPORT	PORTA
+#define DIO31_DDR		DDRA
+#define DIO31_PWM		NULL
+
+#define AIO0_PIN		PINA0
+#define AIO0_RPORT	PINA
+#define AIO0_WPORT	PORTA
+#define AIO0_DDR		DDRA
+#define AIO0_PWM		NULL
+
+#define AIO1_PIN		PINA1
+#define AIO1_RPORT	PINA
+#define AIO1_WPORT	PORTA
+#define AIO1_DDR		DDRA
+#define AIO1_PWM		NULL
+
+#define AIO2_PIN		PINA2
+#define AIO2_RPORT	PINA
+#define AIO2_WPORT	PORTA
+#define AIO2_DDR		DDRA
+#define AIO2_PWM		NULL
+
+#define AIO3_PIN		PINA3
+#define AIO3_RPORT	PINA
+#define AIO3_WPORT	PORTA
+#define AIO3_DDR		DDRA
+#define AIO3_PWM		NULL
+
+#define AIO4_PIN		PINA4
+#define AIO4_RPORT	PINA
+#define AIO4_WPORT	PORTA
+#define AIO4_DDR		DDRA
+#define AIO4_PWM		NULL
+
+#define AIO5_PIN		PINA5
+#define AIO5_RPORT	PINA
+#define AIO5_WPORT	PORTA
+#define AIO5_DDR		DDRA
+#define AIO5_PWM		NULL
+
+#define AIO6_PIN		PINA6
+#define AIO6_RPORT	PINA
+#define AIO6_WPORT	PORTA
+#define AIO6_DDR		DDRA
+#define AIO6_PWM		NULL
+
+#define AIO7_PIN		PINA7
+#define AIO7_RPORT	PINA
+#define AIO7_WPORT	PORTA
+#define AIO7_DDR		DDRA
+#define AIO7_PWM		NULL
+
+
+
+#undef PA0
+#define PA0_PIN			PINA0
+#define PA0_RPORT		PINA
+#define PA0_WPORT		PORTA
+#define PA0_DDR			DDRA
+#define PA0_PWM			NULL
+
+#undef PA1
+#define PA1_PIN			PINA1
+#define PA1_RPORT		PINA
+#define PA1_WPORT		PORTA
+#define PA1_DDR			DDRA
+#define PA1_PWM			NULL
+
+#undef PA2
+#define PA2_PIN			PINA2
+#define PA2_RPORT		PINA
+#define PA2_WPORT		PORTA
+#define PA2_DDR			DDRA
+#define PA2_PWM			NULL
+
+#undef PA3
+#define PA3_PIN			PINA3
+#define PA3_RPORT		PINA
+#define PA3_WPORT		PORTA
+#define PA3_DDR			DDRA
+#define PA3_PWM			NULL
+
+#undef PA4
+#define PA4_PIN			PINA4
+#define PA4_RPORT		PINA
+#define PA4_WPORT		PORTA
+#define PA4_DDR			DDRA
+#define PA4_PWM			NULL
+
+#undef PA5
+#define PA5_PIN			PINA5
+#define PA5_RPORT		PINA
+#define PA5_WPORT		PORTA
+#define PA5_DDR			DDRA
+#define PA5_PWM			NULL
+
+#undef PA6
+#define PA6_PIN			PINA6
+#define PA6_RPORT		PINA
+#define PA6_WPORT		PORTA
+#define PA6_DDR			DDRA
+#define PA6_PWM			NULL
+
+#undef PA7
+#define PA7_PIN			PINA7
+#define PA7_RPORT		PINA
+#define PA7_WPORT		PORTA
+#define PA7_DDR			DDRA
+#define PA7_PWM			NULL
+
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_DDR			DDRB
+#define PB0_PWM			NULL
+
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_DDR			DDRB
+#define PB1_PWM			NULL
+
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_DDR			DDRB
+#define PB2_PWM			NULL
+
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_DDR			DDRB
+#define PB3_PWM			OCR0A
+
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_DDR			DDRB
+#define PB4_PWM			OCR0B
+
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_DDR			DDRB
+#define PB5_PWM			NULL
+
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_DDR			DDRB
+#define PB6_PWM			NULL
+
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_DDR			DDRB
+#define PB7_PWM			NULL
+
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_DDR			DDRC
+#define PC0_PWM			NULL
+
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_DDR			DDRC
+#define PC1_PWM			NULL
+
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_DDR			DDRC
+#define PC2_PWM			NULL
+
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_DDR			DDRC
+#define PC3_PWM			NULL
+
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_DDR			DDRC
+#define PC4_PWM			NULL
+
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_DDR			DDRC
+#define PC5_PWM			NULL
+
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_DDR			DDRC
+#define PC6_PWM			NULL
+
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_DDR			DDRC
+#define PC7_PWM			NULL
+
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_DDR			DDRD
+#define PD0_PWM			NULL
+
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_DDR			DDRD
+#define PD1_PWM			NULL
+
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_DDR			DDRD
+#define PD2_PWM			NULL
+
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_DDR			DDRD
+#define PD3_PWM			NULL
+
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_DDR			DDRD
+#define PD4_PWM			NULL
+
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_DDR			DDRD
+#define PD5_PWM			NULL
+
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_DDR			DDRD
+#define PD6_PWM			OCR2B
+
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_DDR			DDRD
+#define PD7_PWM			OCR2A
+#endif	/*	_AVR_ATmega{644,644P,644PA}__ */
+
+#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)
+// UART
+#define	RXD					DIO0
+#define	TXD					DIO1
+
+// SPI
+#define	SCK					DIO52
+#define	MISO				DIO50
+#define	MOSI				DIO51
+#define	SS					DIO53
+
+// TWI (I2C)
+#define	SCL					DIO21
+#define	SDA					DIO20
+
+// timers and PWM
+#define	OC0A				DIO13
+#define	OC0B				DIO4
+#define	OC1A				DIO11
+#define	OC1B				DIO12
+#define	OC2A				DIO10
+#define	OC2B				DIO9
+#define	OC3A				DIO5
+#define	OC3B				DIO2
+#define	OC3C				DIO3
+#define	OC4A				DIO6
+#define	OC4B				DIO7
+#define	OC4C				DIO8
+#define	OC5A				DIO46
+#define	OC5B				DIO45
+#define	OC5C				DIO44
+
+// change for your board
+#define	DEBUG_LED		DIO21
+
+/*
+pins
+*/
+#define	DIO0_PIN		PINE0
+#define	DIO0_RPORT	PINE
+#define	DIO0_WPORT	PORTE
+#define	DIO0_DDR		DDRE
+#define DIO0_PWM		NULL
+
+#define	DIO1_PIN		PINE1
+#define	DIO1_RPORT	PINE
+#define	DIO1_WPORT	PORTE
+#define	DIO1_DDR		DDRE
+#define DIO1_PWM		NULL
+
+#define	DIO2_PIN		PINE4
+#define	DIO2_RPORT	PINE
+#define	DIO2_WPORT	PORTE
+#define	DIO2_DDR		DDRE
+#define DIO2_PWM		&OCR3BL
+
+#define	DIO3_PIN		PINE5
+#define	DIO3_RPORT	PINE
+#define	DIO3_WPORT	PORTE
+#define	DIO3_DDR		DDRE
+#define DIO3_PWM		&OCR3CL
+
+#define	DIO4_PIN		PING5
+#define	DIO4_RPORT	PING
+#define	DIO4_WPORT	PORTG
+#define	DIO4_DDR		DDRG
+#define DIO4_PWM		&OCR0B
+
+#define	DIO5_PIN		PINE3
+#define	DIO5_RPORT	PINE
+#define	DIO5_WPORT	PORTE
+#define	DIO5_DDR		DDRE
+#define DIO5_PWM		&OCR3AL
+
+#define	DIO6_PIN		PINH3
+#define	DIO6_RPORT	PINH
+#define	DIO6_WPORT	PORTH
+#define	DIO6_DDR		DDRH
+#define DIO6_PWM		&OCR4AL
+
+#define	DIO7_PIN		PINH4
+#define	DIO7_RPORT	PINH
+#define	DIO7_WPORT	PORTH
+#define	DIO7_DDR		DDRH
+#define DIO7_PWM		&OCR4BL
+
+#define	DIO8_PIN		PINH5
+#define	DIO8_RPORT	PINH
+#define	DIO8_WPORT	PORTH
+#define	DIO8_DDR		DDRH
+#define DIO8_PWM		&OCR4CL
+
+#define	DIO9_PIN		PINH6
+#define	DIO9_RPORT	PINH
+#define	DIO9_WPORT	PORTH
+#define	DIO9_DDR		DDRH
+#define DIO9_PWM		&OCR2B
+
+#define	DIO10_PIN		PINB4
+#define	DIO10_RPORT	PINB
+#define	DIO10_WPORT	PORTB
+#define	DIO10_DDR		DDRB
+#define DIO10_PWM		&OCR2A
+
+#define	DIO11_PIN		PINB5
+#define	DIO11_RPORT	PINB
+#define	DIO11_WPORT	PORTB
+#define	DIO11_DDR		DDRB
+#define DIO11_PWM		NULL
+
+#define	DIO12_PIN		PINB6
+#define	DIO12_RPORT	PINB
+#define	DIO12_WPORT	PORTB
+#define	DIO12_DDR		DDRB
+#define DIO12_PWM		NULL
+
+#define	DIO13_PIN		PINB7
+#define	DIO13_RPORT	PINB
+#define	DIO13_WPORT	PORTB
+#define	DIO13_DDR		DDRB
+#define DIO13_PWM		&OCR0A
+
+#define	DIO14_PIN		PINJ1
+#define	DIO14_RPORT	PINJ
+#define	DIO14_WPORT	PORTJ
+#define	DIO14_DDR		DDRJ
+#define DIO14_PWM		NULL
+
+#define	DIO15_PIN		PINJ0
+#define	DIO15_RPORT	PINJ
+#define	DIO15_WPORT	PORTJ
+#define	DIO15_DDR		DDRJ
+#define DIO15_PWM		NULL
+
+#define	DIO16_PIN		PINH1
+#define	DIO16_RPORT	PINH
+#define	DIO16_WPORT	PORTH
+#define	DIO16_DDR		DDRH
+#define DIO16_PWM		NULL
+
+#define	DIO17_PIN		PINH0
+#define	DIO17_RPORT	PINH
+#define	DIO17_WPORT	PORTH
+#define	DIO17_DDR		DDRH
+#define DIO17_PWM		NULL
+
+#define	DIO18_PIN		PIND3
+#define	DIO18_RPORT	PIND
+#define	DIO18_WPORT	PORTD
+#define	DIO18_DDR		DDRD
+#define DIO18_PWM		NULL
+
+#define	DIO19_PIN		PIND2
+#define	DIO19_RPORT	PIND
+#define	DIO19_WPORT	PORTD
+#define	DIO19_DDR		DDRD
+#define DIO19_PWM		NULL
+
+#define	DIO20_PIN		PIND1
+#define	DIO20_RPORT	PIND
+#define	DIO20_WPORT	PORTD
+#define	DIO20_DDR		DDRD
+#define DIO20_PWM		NULL
+
+#define	DIO21_PIN		PIND0
+#define	DIO21_RPORT	PIND
+#define	DIO21_WPORT	PORTD
+#define	DIO21_DDR		DDRD
+#define DIO21_PWM		NULL
+
+#define	DIO22_PIN		PINA0
+#define	DIO22_RPORT	PINA
+#define	DIO22_WPORT	PORTA
+#define	DIO22_DDR		DDRA
+#define DIO22_PWM		NULL
+
+#define	DIO23_PIN		PINA1
+#define	DIO23_RPORT	PINA
+#define	DIO23_WPORT	PORTA
+#define	DIO23_DDR		DDRA
+#define DIO23_PWM		NULL
+
+#define	DIO24_PIN		PINA2
+#define	DIO24_RPORT	PINA
+#define	DIO24_WPORT	PORTA
+#define	DIO24_DDR		DDRA
+#define DIO24_PWM		NULL
+
+#define	DIO25_PIN		PINA3
+#define	DIO25_RPORT	PINA
+#define	DIO25_WPORT	PORTA
+#define	DIO25_DDR		DDRA
+#define DIO25_PWM		NULL
+
+#define	DIO26_PIN		PINA4
+#define	DIO26_RPORT	PINA
+#define	DIO26_WPORT	PORTA
+#define	DIO26_DDR		DDRA
+#define DIO26_PWM		NULL
+
+#define	DIO27_PIN		PINA5
+#define	DIO27_RPORT	PINA
+#define	DIO27_WPORT	PORTA
+#define	DIO27_DDR		DDRA
+#define DIO27_PWM		NULL
+
+#define	DIO28_PIN		PINA6
+#define	DIO28_RPORT	PINA
+#define	DIO28_WPORT	PORTA
+#define	DIO28_DDR		DDRA
+#define DIO28_PWM		NULL
+
+#define	DIO29_PIN		PINA7
+#define	DIO29_RPORT	PINA
+#define	DIO29_WPORT	PORTA
+#define	DIO29_DDR		DDRA
+#define DIO29_PWM		NULL
+
+#define	DIO30_PIN		PINC7
+#define	DIO30_RPORT	PINC
+#define	DIO30_WPORT	PORTC
+#define	DIO30_DDR		DDRC
+#define DIO30_PWM		NULL
+
+#define	DIO31_PIN		PINC6
+#define	DIO31_RPORT	PINC
+#define	DIO31_WPORT	PORTC
+#define	DIO31_DDR		DDRC
+#define DIO31_PWM		NULL
+
+#define	DIO32_PIN		PINC5
+#define	DIO32_RPORT	PINC
+#define	DIO32_WPORT	PORTC
+#define	DIO32_DDR		DDRC
+#define DIO32_PWM		NULL
+
+#define	DIO33_PIN		PINC4
+#define	DIO33_RPORT	PINC
+#define	DIO33_WPORT	PORTC
+#define	DIO33_DDR		DDRC
+#define DIO33_PWM		NULL
+
+#define	DIO34_PIN		PINC3
+#define	DIO34_RPORT	PINC
+#define	DIO34_WPORT	PORTC
+#define	DIO34_DDR		DDRC
+#define DIO34_PWM		NULL
+
+#define	DIO35_PIN		PINC2
+#define	DIO35_RPORT	PINC
+#define	DIO35_WPORT	PORTC
+#define	DIO35_DDR		DDRC
+#define DIO35_PWM		NULL
+
+#define	DIO36_PIN		PINC1
+#define	DIO36_RPORT	PINC
+#define	DIO36_WPORT	PORTC
+#define	DIO36_DDR		DDRC
+#define DIO36_PWM		NULL
+
+#define	DIO37_PIN		PINC0
+#define	DIO37_RPORT	PINC
+#define	DIO37_WPORT	PORTC
+#define	DIO37_DDR		DDRC
+#define DIO37_PWM		NULL
+
+#define	DIO38_PIN		PIND7
+#define	DIO38_RPORT	PIND
+#define	DIO38_WPORT	PORTD
+#define	DIO38_DDR		DDRD
+#define DIO38_PWM		NULL
+
+#define	DIO39_PIN		PING2
+#define	DIO39_RPORT	PING
+#define	DIO39_WPORT	PORTG
+#define	DIO39_DDR		DDRG
+#define DIO39_PWM		NULL
+
+#define	DIO40_PIN		PING1
+#define	DIO40_RPORT	PING
+#define	DIO40_WPORT	PORTG
+#define	DIO40_DDR		DDRG
+#define DIO40_PWM		NULL
+
+#define	DIO41_PIN		PING0
+#define	DIO41_RPORT	PING
+#define	DIO41_WPORT	PORTG
+#define	DIO41_DDR		DDRG
+#define DIO41_PWM		NULL
+
+#define	DIO42_PIN		PINL7
+#define	DIO42_RPORT	PINL
+#define	DIO42_WPORT	PORTL
+#define	DIO42_DDR		DDRL
+#define DIO42_PWM		NULL
+
+#define	DIO43_PIN		PINL6
+#define	DIO43_RPORT	PINL
+#define	DIO43_WPORT	PORTL
+#define	DIO43_DDR		DDRL
+#define DIO43_PWM		NULL
+
+#define	DIO44_PIN		PINL5
+#define	DIO44_RPORT	PINL
+#define	DIO44_WPORT	PORTL
+#define	DIO44_DDR		DDRL
+#define DIO44_PWM		&OCR5CL
+
+#define	DIO45_PIN		PINL4
+#define	DIO45_RPORT	PINL
+#define	DIO45_WPORT	PORTL
+#define	DIO45_DDR		DDRL
+#define DIO45_PWM		&OCR5BL
+
+#define	DIO46_PIN		PINL3
+#define	DIO46_RPORT	PINL
+#define	DIO46_WPORT	PORTL
+#define	DIO46_DDR		DDRL
+#define DIO46_PWM		&OCR5AL
+
+#define	DIO47_PIN		PINL2
+#define	DIO47_RPORT	PINL
+#define	DIO47_WPORT	PORTL
+#define	DIO47_DDR		DDRL
+#define DIO47_PWM		NULL
+
+#define	DIO48_PIN		PINL1
+#define	DIO48_RPORT	PINL
+#define	DIO48_WPORT	PORTL
+#define	DIO48_DDR		DDRL
+#define DIO48_PWM		NULL
+
+#define	DIO49_PIN		PINL0
+#define	DIO49_RPORT	PINL
+#define	DIO49_WPORT	PORTL
+#define	DIO49_DDR		DDRL
+#define DIO49_PWM		NULL
+
+#define	DIO50_PIN		PINB3
+#define	DIO50_RPORT	PINB
+#define	DIO50_WPORT	PORTB
+#define	DIO50_DDR		DDRB
+#define DIO50_PWM		NULL
+
+#define	DIO51_PIN		PINB2
+#define	DIO51_RPORT	PINB
+#define	DIO51_WPORT	PORTB
+#define	DIO51_DDR		DDRB
+#define DIO51_PWM		NULL
+
+#define	DIO52_PIN		PINB1
+#define	DIO52_RPORT	PINB
+#define	DIO52_WPORT	PORTB
+#define	DIO52_DDR		DDRB
+#define DIO52_PWM		NULL
+
+#define	DIO53_PIN		PINB0
+#define	DIO53_RPORT	PINB
+#define	DIO53_WPORT	PORTB
+#define	DIO53_DDR		DDRB
+#define DIO53_PWM		NULL
+
+#define DIO54_PIN		PINF0
+#define DIO54_RPORT	PINF
+#define DIO54_WPORT	PORTF
+#define DIO54_DDR		DDRF
+#define DIO54_PWM		NULL
+
+#define DIO55_PIN		PINF1
+#define DIO55_RPORT	PINF
+#define DIO55_WPORT	PORTF
+#define DIO55_DDR		DDRF
+#define DIO55_PWM		NULL
+
+#define DIO56_PIN		PINF2
+#define DIO56_RPORT	PINF
+#define DIO56_WPORT	PORTF
+#define DIO56_DDR		DDRF
+#define DIO56_PWM		NULL
+
+#define DIO57_PIN		PINF3
+#define DIO57_RPORT	PINF
+#define DIO57_WPORT	PORTF
+#define DIO57_DDR		DDRF
+#define DIO57_PWM		NULL
+
+#define DIO58_PIN		PINF4
+#define DIO58_RPORT	PINF
+#define DIO58_WPORT	PORTF
+#define DIO58_DDR		DDRF
+#define DIO58_PWM		NULL
+
+#define DIO59_PIN		PINF5
+#define DIO59_RPORT	PINF
+#define DIO59_WPORT	PORTF
+#define DIO59_DDR		DDRF
+#define DIO59_PWM		NULL
+
+#define DIO60_PIN		PINF6
+#define DIO60_RPORT	PINF
+#define DIO60_WPORT	PORTF
+#define DIO60_DDR		DDRF
+#define DIO60_PWM		NULL
+
+#define DIO61_PIN		PINF7
+#define DIO61_RPORT	PINF
+#define DIO61_WPORT	PORTF
+#define DIO61_DDR		DDRF
+#define DIO61_PWM		NULL
+
+#define DIO62_PIN		PINK0
+#define DIO62_RPORT	PINK
+#define DIO62_WPORT	PORTK
+#define DIO62_DDR		DDRK
+#define DIO62_PWM		NULL
+
+#define DIO63_PIN		PINK1
+#define DIO63_RPORT	PINK
+#define DIO63_WPORT	PORTK
+#define DIO63_DDR		DDRK
+#define DIO63_PWM		NULL
+
+#define DIO64_PIN		PINK2
+#define DIO64_RPORT	PINK
+#define DIO64_WPORT	PORTK
+#define DIO64_DDR		DDRK
+#define DIO64_PWM		NULL
+
+#define DIO65_PIN		PINK3
+#define DIO65_RPORT	PINK
+#define DIO65_WPORT	PORTK
+#define DIO65_DDR		DDRK
+#define DIO65_PWM		NULL
+
+#define DIO66_PIN		PINK4
+#define DIO66_RPORT	PINK
+#define DIO66_WPORT	PORTK
+#define DIO66_DDR		DDRK
+#define DIO66_PWM		NULL
+
+#define DIO67_PIN		PINK5
+#define DIO67_RPORT	PINK
+#define DIO67_WPORT	PORTK
+#define DIO67_DDR		DDRK
+#define DIO67_PWM		NULL
+
+#define DIO68_PIN		PINK6
+#define DIO68_RPORT	PINK
+#define DIO68_WPORT	PORTK
+#define DIO68_DDR		DDRK
+#define DIO68_PWM		NULL
+
+#define DIO69_PIN		PINK7
+#define DIO69_RPORT	PINK
+#define DIO69_WPORT	PORTK
+#define DIO69_DDR		DDRK
+#define DIO69_PWM		NULL
+
+
+
+#undef PA0
+#define PA0_PIN			PINA0
+#define PA0_RPORT		PINA
+#define PA0_WPORT		PORTA
+#define PA0_DDR			DDRA
+#define PA0_PWM			NULL
+#undef PA1
+#define PA1_PIN			PINA1
+#define PA1_RPORT		PINA
+#define PA1_WPORT		PORTA
+#define PA1_DDR			DDRA
+#define PA1_PWM			NULL
+#undef PA2
+#define PA2_PIN			PINA2
+#define PA2_RPORT		PINA
+#define PA2_WPORT		PORTA
+#define PA2_DDR			DDRA
+#define PA2_PWM			NULL
+#undef PA3
+#define PA3_PIN			PINA3
+#define PA3_RPORT		PINA
+#define PA3_WPORT		PORTA
+#define PA3_DDR			DDRA
+#define PA3_PWM			NULL
+#undef PA4
+#define PA4_PIN			PINA4
+#define PA4_RPORT		PINA
+#define PA4_WPORT		PORTA
+#define PA4_DDR			DDRA
+#define PA4_PWM			NULL
+#undef PA5
+#define PA5_PIN			PINA5
+#define PA5_RPORT		PINA
+#define PA5_WPORT		PORTA
+#define PA5_DDR			DDRA
+#define PA5_PWM			NULL
+#undef PA6
+#define PA6_PIN			PINA6
+#define PA6_RPORT		PINA
+#define PA6_WPORT		PORTA
+#define PA6_DDR			DDRA
+#define PA6_PWM			NULL
+#undef PA7
+#define PA7_PIN			PINA7
+#define PA7_RPORT		PINA
+#define PA7_WPORT		PORTA
+#define PA7_DDR			DDRA
+#define PA7_PWM			NULL
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_DDR			DDRB
+#define PB0_PWM			NULL
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_DDR			DDRB
+#define PB1_PWM			NULL
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_DDR			DDRB
+#define PB2_PWM			NULL
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_DDR			DDRB
+#define PB3_PWM			NULL
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_DDR			DDRB
+#define PB4_PWM			&OCR2A
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_DDR			DDRB
+#define PB5_PWM			NULL
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_DDR			DDRB
+#define PB6_PWM			NULL
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_DDR			DDRB
+#define PB7_PWM			&OCR0A
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_DDR			DDRC
+#define PC0_PWM			NULL
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_DDR			DDRC
+#define PC1_PWM			NULL
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_DDR			DDRC
+#define PC2_PWM			NULL
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_DDR			DDRC
+#define PC3_PWM			NULL
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_DDR			DDRC
+#define PC4_PWM			NULL
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_DDR			DDRC
+#define PC5_PWM			NULL
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_DDR			DDRC
+#define PC6_PWM			NULL
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_DDR			DDRC
+#define PC7_PWM			NULL
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_DDR			DDRD
+#define PD0_PWM			NULL
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_DDR			DDRD
+#define PD1_PWM			NULL
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_DDR			DDRD
+#define PD2_PWM			NULL
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_DDR			DDRD
+#define PD3_PWM			NULL
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_DDR			DDRD
+#define PD4_PWM			NULL
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_DDR			DDRD
+#define PD5_PWM			NULL
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_DDR			DDRD
+#define PD6_PWM			NULL
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_DDR			DDRD
+#define PD7_PWM			NULL
+
+#undef PE0
+#define PE0_PIN			PINE0
+#define PE0_RPORT		PINE
+#define PE0_WPORT		PORTE
+#define PE0_DDR			DDRE
+#define PE0_PWM			NULL
+#undef PE1
+#define PE1_PIN			PINE1
+#define PE1_RPORT		PINE
+#define PE1_WPORT		PORTE
+#define PE1_DDR			DDRE
+#define PE1_PWM			NULL
+#undef PE2
+#define PE2_PIN			PINE2
+#define PE2_RPORT		PINE
+#define PE2_WPORT		PORTE
+#define PE2_DDR			DDRE
+#define PE2_PWM			NULL
+#undef PE3
+#define PE3_PIN			PINE3
+#define PE3_RPORT		PINE
+#define PE3_WPORT		PORTE
+#define PE3_DDR			DDRE
+#define PE3_PWM			&OCR3AL
+#undef PE4
+#define PE4_PIN			PINE4
+#define PE4_RPORT		PINE
+#define PE4_WPORT		PORTE
+#define PE4_DDR			DDRE
+#define PE4_PWM			&OCR3BL
+#undef PE5
+#define PE5_PIN			PINE5
+#define PE5_RPORT		PINE
+#define PE5_WPORT		PORTE
+#define PE5_DDR			DDRE
+#define PE5_PWM			&OCR3CL
+#undef PE6
+#define PE6_PIN			PINE6
+#define PE6_RPORT		PINE
+#define PE6_WPORT		PORTE
+#define PE6_DDR			DDRE
+#define PE6_PWM			NULL
+#undef PE7
+#define PE7_PIN			PINE7
+#define PE7_RPORT		PINE
+#define PE7_WPORT		PORTE
+#define PE7_DDR			DDRE
+#define PE7_PWM			NULL
+
+#undef PF0
+#define PF0_PIN			PINF0
+#define PF0_RPORT		PINF
+#define PF0_WPORT		PORTF
+#define PF0_DDR			DDRF
+#define PF0_PWM			NULL
+#undef PF1
+#define PF1_PIN			PINF1
+#define PF1_RPORT		PINF
+#define PF1_WPORT		PORTF
+#define PF1_DDR			DDRF
+#define PF1_PWM			NULL
+#undef PF2
+#define PF2_PIN			PINF2
+#define PF2_RPORT		PINF
+#define PF2_WPORT		PORTF
+#define PF2_DDR			DDRF
+#define PF2_PWM			NULL
+#undef PF3
+#define PF3_PIN			PINF3
+#define PF3_RPORT		PINF
+#define PF3_WPORT		PORTF
+#define PF3_DDR			DDRF
+#define PF3_PWM			NULL
+#undef PF4
+#define PF4_PIN			PINF4
+#define PF4_RPORT		PINF
+#define PF4_WPORT		PORTF
+#define PF4_DDR			DDRF
+#define PF4_PWM			NULL
+#undef PF5
+#define PF5_PIN			PINF5
+#define PF5_RPORT		PINF
+#define PF5_WPORT		PORTF
+#define PF5_DDR			DDRF
+#define PF5_PWM			NULL
+#undef PF6
+#define PF6_PIN			PINF6
+#define PF6_RPORT		PINF
+#define PF6_WPORT		PORTF
+#define PF6_DDR			DDRF
+#define PF6_PWM			NULL
+#undef PF7
+#define PF7_PIN			PINF7
+#define PF7_RPORT		PINF
+#define PF7_WPORT		PORTF
+#define PF7_DDR			DDRF
+#define PF7_PWM			NULL
+
+#undef PG0
+#define PG0_PIN			PING0
+#define PG0_RPORT		PING
+#define PG0_WPORT		PORTG
+#define PG0_DDR			DDRG
+#define PG0_PWM			NULL
+#undef PG1
+#define PG1_PIN			PING1
+#define PG1_RPORT		PING
+#define PG1_WPORT		PORTG
+#define PG1_DDR			DDRG
+#define PG1_PWM			NULL
+#undef PG2
+#define PG2_PIN			PING2
+#define PG2_RPORT		PING
+#define PG2_WPORT		PORTG
+#define PG2_DDR			DDRG
+#define PG2_PWM			NULL
+#undef PG3
+#define PG3_PIN			PING3
+#define PG3_RPORT		PING
+#define PG3_WPORT		PORTG
+#define PG3_DDR			DDRG
+#define PG3_PWM			NULL
+#undef PG4
+#define PG4_PIN			PING4
+#define PG4_RPORT		PING
+#define PG4_WPORT		PORTG
+#define PG4_DDR			DDRG
+#define PG4_PWM			NULL
+#undef PG5
+#define PG5_PIN			PING5
+#define PG5_RPORT		PING
+#define PG5_WPORT		PORTG
+#define PG5_DDR			DDRG
+#define PG5_PWM			&OCR0B
+#undef PG6
+#define PG6_PIN			PING6
+#define PG6_RPORT		PING
+#define PG6_WPORT		PORTG
+#define PG6_DDR			DDRG
+#define PG6_PWM			NULL
+#undef PG7
+#define PG7_PIN			PING7
+#define PG7_RPORT		PING
+#define PG7_WPORT		PORTG
+#define PG7_DDR			DDRG
+#define PG7_PWM			NULL
+
+#undef PH0
+#define PH0_PIN			PINH0
+#define PH0_RPORT		PINH
+#define PH0_WPORT		PORTH
+#define PH0_DDR			DDRH
+#define PH0_PWM			NULL
+#undef PH1
+#define PH1_PIN			PINH1
+#define PH1_RPORT		PINH
+#define PH1_WPORT		PORTH
+#define PH1_DDR			DDRH
+#define PH1_PWM			NULL
+#undef PH2
+#define PH2_PIN			PINH2
+#define PH2_RPORT		PINH
+#define PH2_WPORT		PORTH
+#define PH2_DDR			DDRH
+#define PH2_PWM			NULL
+#undef PH3
+#define PH3_PIN			PINH3
+#define PH3_RPORT		PINH
+#define PH3_WPORT		PORTH
+#define PH3_DDR			DDRH
+#define PH3_PWM			&OCR4AL
+#undef PH4
+#define PH4_PIN			PINH4
+#define PH4_RPORT		PINH
+#define PH4_WPORT		PORTH
+#define PH4_DDR			DDRH
+#define PH4_PWM			&OCR4BL
+#undef PH5
+#define PH5_PIN			PINH5
+#define PH5_RPORT		PINH
+#define PH5_WPORT		PORTH
+#define PH5_DDR			DDRH
+#define PH5_PWM			&OCR4CL
+#undef PH6
+#define PH6_PIN			PINH6
+#define PH6_RPORT		PINH
+#define PH6_WPORT		PORTH
+#define PH6_DDR			DDRH
+#define PH6_PWM			&OCR2B
+#undef PH7
+#define PH7_PIN			PINH7
+#define PH7_RPORT		PINH
+#define PH7_WPORT		PORTH
+#define PH7_DDR			DDRH
+#define PH7_PWM			NULL
+
+#undef PJ0
+#define PJ0_PIN			PINJ0
+#define PJ0_RPORT		PINJ
+#define PJ0_WPORT		PORTJ
+#define PJ0_DDR			DDRJ
+#define PJ0_PWM			NULL
+#undef PJ1
+#define PJ1_PIN			PINJ1
+#define PJ1_RPORT		PINJ
+#define PJ1_WPORT		PORTJ
+#define PJ1_DDR			DDRJ
+#define PJ1_PWM			NULL
+#undef PJ2
+#define PJ2_PIN			PINJ2
+#define PJ2_RPORT		PINJ
+#define PJ2_WPORT		PORTJ
+#define PJ2_DDR			DDRJ
+#define PJ2_PWM			NULL
+#undef PJ3
+#define PJ3_PIN			PINJ3
+#define PJ3_RPORT		PINJ
+#define PJ3_WPORT		PORTJ
+#define PJ3_DDR			DDRJ
+#define PJ3_PWM			NULL
+#undef PJ4
+#define PJ4_PIN			PINJ4
+#define PJ4_RPORT		PINJ
+#define PJ4_WPORT		PORTJ
+#define PJ4_DDR			DDRJ
+#define PJ4_PWM			NULL
+#undef PJ5
+#define PJ5_PIN			PINJ5
+#define PJ5_RPORT		PINJ
+#define PJ5_WPORT		PORTJ
+#define PJ5_DDR			DDRJ
+#define PJ5_PWM			NULL
+#undef PJ6
+#define PJ6_PIN			PINJ6
+#define PJ6_RPORT		PINJ
+#define PJ6_WPORT		PORTJ
+#define PJ6_DDR			DDRJ
+#define PJ6_PWM			NULL
+#undef PJ7
+#define PJ7_PIN			PINJ7
+#define PJ7_RPORT		PINJ
+#define PJ7_WPORT		PORTJ
+#define PJ7_DDR			DDRJ
+#define PJ7_PWM			NULL
+
+#undef PK0
+#define PK0_PIN			PINK0
+#define PK0_RPORT		PINK
+#define PK0_WPORT		PORTK
+#define PK0_DDR			DDRK
+#define PK0_PWM			NULL
+#undef PK1
+#define PK1_PIN			PINK1
+#define PK1_RPORT		PINK
+#define PK1_WPORT		PORTK
+#define PK1_DDR			DDRK
+#define PK1_PWM			NULL
+#undef PK2
+#define PK2_PIN			PINK2
+#define PK2_RPORT		PINK
+#define PK2_WPORT		PORTK
+#define PK2_DDR			DDRK
+#define PK2_PWM			NULL
+#undef PK3
+#define PK3_PIN			PINK3
+#define PK3_RPORT		PINK
+#define PK3_WPORT		PORTK
+#define PK3_DDR			DDRK
+#define PK3_PWM			NULL
+#undef PK4
+#define PK4_PIN			PINK4
+#define PK4_RPORT		PINK
+#define PK4_WPORT		PORTK
+#define PK4_DDR			DDRK
+#define PK4_PWM			NULL
+#undef PK5
+#define PK5_PIN			PINK5
+#define PK5_RPORT		PINK
+#define PK5_WPORT		PORTK
+#define PK5_DDR			DDRK
+#define PK5_PWM			NULL
+#undef PK6
+#define PK6_PIN			PINK6
+#define PK6_RPORT		PINK
+#define PK6_WPORT		PORTK
+#define PK6_DDR			DDRK
+#define PK6_PWM			NULL
+#undef PK7
+#define PK7_PIN			PINK7
+#define PK7_RPORT		PINK
+#define PK7_WPORT		PORTK
+#define PK7_DDR			DDRK
+#define PK7_PWM			NULL
+
+#undef PL0
+#define PL0_PIN			PINL0
+#define PL0_RPORT		PINL
+#define PL0_WPORT		PORTL
+#define PL0_DDR			DDRL
+#define PL0_PWM			NULL
+#undef PL1
+#define PL1_PIN			PINL1
+#define PL1_RPORT		PINL
+#define PL1_WPORT		PORTL
+#define PL1_DDR			DDRL
+#define PL1_PWM			NULL
+#undef PL2
+#define PL2_PIN			PINL2
+#define PL2_RPORT		PINL
+#define PL2_WPORT		PORTL
+#define PL2_DDR			DDRL
+#define PL2_PWM			NULL
+#undef PL3
+#define PL3_PIN			PINL3
+#define PL3_RPORT		PINL
+#define PL3_WPORT		PORTL
+#define PL3_DDR			DDRL
+#define PL3_PWM			&OCR5AL
+#undef PL4
+#define PL4_PIN			PINL4
+#define PL4_RPORT		PINL
+#define PL4_WPORT		PORTL
+#define PL4_DDR			DDRL
+#define PL4_PWM			&OCR5BL
+#undef PL5
+#define PL5_PIN			PINL5
+#define PL5_RPORT		PINL
+#define PL5_WPORT		PORTL
+#define PL5_DDR			DDRL
+#define PL5_PWM			&OCR5CL
+#undef PL6
+#define PL6_PIN			PINL6
+#define PL6_RPORT		PINL
+#define PL6_WPORT		PORTL
+#define PL6_DDR			DDRL
+#define PL6_PWM			NULL
+#undef PL7
+#define PL7_PIN			PINL7
+#define PL7_RPORT		PINL
+#define PL7_WPORT		PORTL
+#define PL7_DDR			DDRL
+#define PL7_PWM			NULL
+
+#endif
+
+#if defined (__AVR_AT90USB1287__)
+// SPI
+#define	SCK					DIO9
+#define	MISO				DIO11
+#define	MOSI				DIO10
+#define	SS					DIO8
+
+// change for your board
+#define	DEBUG_LED		DIO31 /* led D5 red */
+
+/*
+pins
+*/
+#define DIO0_PIN        PINA0
+#define DIO0_RPORT      PINA
+#define DIO0_WPORT      PORTA
+#define DIO0_PWM			NULL
+#define DIO0_DDR        DDRA
+
+#define DIO1_PIN        PINA1
+#define DIO1_RPORT      PINA
+#define DIO1_WPORT      PORTA
+#define DIO1_PWM			NULL
+#define DIO1_DDR        DDRA
+
+#define DIO2_PIN        PINA2
+#define DIO2_RPORT      PINA
+#define DIO2_WPORT      PORTA
+#define DIO2_PWM			NULL
+#define DIO2_DDR        DDRA
+
+#define DIO3_PIN        PINA3
+#define DIO3_RPORT      PINA
+#define DIO3_WPORT      PORTA
+#define DIO3_PWM			NULL
+#define DIO3_DDR        DDRA
+
+#define DIO4_PIN        PINA4
+#define DIO4_RPORT      PINA
+#define DIO4_WPORT      PORTA
+#define DIO4_PWM			NULL
+#define DIO4_DDR        DDRA
+
+#define DIO5_PIN        PINA5
+#define DIO5_RPORT      PINA
+#define DIO5_WPORT      PORTA
+#define DIO5_PWM			NULL
+#define DIO5_DDR        DDRA
+
+#define DIO6_PIN        PINA6
+#define DIO6_RPORT      PINA
+#define DIO6_WPORT      PORTA
+#define DIO6_PWM			NULL
+#define DIO6_DDR        DDRA
+
+#define DIO7_PIN        PINA7
+#define DIO7_RPORT      PINA
+#define DIO7_WPORT      PORTA
+#define DIO7_PWM			NULL
+#define DIO7_DDR        DDRA
+
+#define DIO8_PIN        PINB0
+#define DIO8_RPORT      PINB
+#define DIO8_WPORT      PORTB
+#define DIO8_PWM			NULL
+#define DIO8_DDR        DDRB
+
+#define DIO9_PIN        PINB1
+#define DIO9_RPORT      PINB
+#define DIO9_WPORT      PORTB
+#define DIO9_PWM			NULL
+#define DIO9_DDR        DDRB
+
+#define DIO10_PIN       PINB2
+#define DIO10_RPORT     PINB
+#define DIO10_WPORT     PORTB
+#define DIO10_PWM			NULL
+#define DIO10_DDR       DDRB
+
+#define DIO11_PIN       PINB3
+#define DIO11_RPORT     PINB
+#define DIO11_WPORT     PORTB
+#define DIO11_PWM			NULL
+#define DIO11_DDR       DDRB
+
+#define DIO12_PIN       PINB4
+#define DIO12_RPORT     PINB
+#define DIO12_WPORT     PORTB
+#define DIO12_PWM			NULL
+#define DIO12_DDR       DDRB
+
+#define DIO13_PIN       PINB5
+#define DIO13_RPORT     PINB
+#define DIO13_WPORT     PORTB
+#define DIO13_PWM			NULL
+#define DIO13_DDR       DDRB
+
+#define DIO14_PIN       PINB6
+#define DIO14_RPORT     PINB
+#define DIO14_WPORT     PORTB
+#define DIO14_PWM			NULL
+#define DIO14_DDR       DDRB
+
+#define DIO15_PIN       PINB7
+#define DIO15_RPORT     PINB
+#define DIO15_WPORT     PORTB
+#define DIO15_PWM			NULL
+#define DIO15_DDR       DDRB
+
+#define DIO16_PIN       PINC0
+#define DIO16_RPORT     PINC
+#define DIO16_WPORT     PORTC
+#define DIO16_PWM			NULL
+#define DIO16_DDR       DDRC
+
+#define DIO17_PIN       PINC1
+#define DIO17_RPORT     PINC
+#define DIO17_WPORT     PORTC
+#define DIO17_PWM			NULL
+#define DIO17_DDR       DDRC
+
+#define DIO18_PIN       PINC2
+#define DIO18_RPORT     PINC
+#define DIO18_WPORT     PORTC
+#define DIO18_PWM			NULL
+#define DIO18_DDR       DDRC
+
+#define DIO19_PIN       PINC3
+#define DIO19_RPORT     PINC
+#define DIO19_WPORT     PORTC
+#define DIO19_PWM			NULL
+#define DIO19_DDR       DDRC
+
+#define DIO20_PIN       PINC4
+#define DIO20_RPORT     PINC
+#define DIO20_WPORT     PORTC
+#define DIO20_PWM			NULL
+#define DIO20_DDR       DDRC
+
+#define DIO21_PIN       PINC5
+#define DIO21_RPORT     PINC
+#define DIO21_WPORT     PORTC
+#define DIO21_PWM			NULL
+#define DIO21_DDR       DDRC
+
+#define DIO22_PIN       PINC6
+#define DIO22_RPORT     PINC
+#define DIO22_WPORT     PORTC
+#define DIO22_PWM			NULL
+#define DIO22_DDR       DDRC
+
+#define DIO23_PIN       PINC7
+#define DIO23_RPORT     PINC
+#define DIO23_WPORT     PORTC
+#define DIO23_PWM			NULL
+#define DIO23_DDR       DDRC
+
+#define DIO24_PIN       PIND0
+#define DIO24_RPORT     PIND
+#define DIO24_WPORT     PORTD
+#define DIO24_PWM			NULL
+#define DIO24_DDR       DDRD
+
+#define DIO25_PIN       PIND1
+#define DIO25_RPORT     PIND
+#define DIO25_WPORT     PORTD
+#define DIO25_PWM			NULL
+#define DIO25_DDR       DDRD
+
+#define DIO26_PIN       PIND2
+#define DIO26_RPORT     PIND
+#define DIO26_WPORT     PORTD
+#define DIO26_PWM			NULL
+#define DIO26_DDR       DDRD
+
+#define DIO27_PIN       PIND3
+#define DIO27_RPORT     PIND
+#define DIO27_WPORT     PORTD
+#define DIO27_PWM			NULL
+#define DIO27_DDR       DDRD
+
+#define DIO28_PIN       PIND4
+#define DIO28_RPORT     PIND
+#define DIO28_WPORT     PORTD
+#define DIO28_PWM			NULL
+#define DIO28_DDR       DDRD
+
+#define DIO29_PIN       PIND5
+#define DIO29_RPORT     PIND
+#define DIO29_WPORT     PORTD
+#define DIO29_PWM			NULL
+#define DIO29_DDR       DDRD
+
+#define DIO30_PIN       PIND6
+#define DIO30_RPORT     PIND
+#define DIO30_WPORT     PORTD
+#define DIO30_PWM			NULL
+#define DIO30_DDR       DDRD
+
+#define DIO31_PIN       PIND7
+#define DIO31_RPORT     PIND
+#define DIO31_WPORT     PORTD
+#define DIO31_PWM			NULL
+#define DIO31_DDR       DDRD
+
+
+#define DIO32_PIN       PINE0
+#define DIO32_RPORT     PINE
+#define DIO32_WPORT     PORTE
+#define DIO32_PWM			NULL
+#define DIO32_DDR       DDRE
+
+#define DIO33_PIN       PINE1
+#define DIO33_RPORT     PINE
+#define DIO33_WPORT     PORTE
+#define DIO33_PWM			NULL
+#define DIO33_DDR       DDRE
+
+#define DIO34_PIN       PINE2
+#define DIO34_RPORT     PINE
+#define DIO34_WPORT     PORTE
+#define DIO34_PWM			NULL
+#define DIO34_DDR       DDRE
+
+#define DIO35_PIN       PINE3
+#define DIO35_RPORT     PINE
+#define DIO35_WPORT     PORTE
+#define DIO35_PWM			NULL
+#define DIO35_DDR       DDRE
+
+#define DIO36_PIN       PINE4
+#define DIO36_RPORT     PINE
+#define DIO36_WPORT     PORTE
+#define DIO36_PWM			NULL
+#define DIO36_DDR       DDRE
+
+#define DIO37_PIN       PINE5
+#define DIO37_RPORT     PINE
+#define DIO37_WPORT     PORTE
+#define DIO37_PWM			NULL
+#define DIO37_DDR       DDRE
+
+#define DIO38_PIN       PINE6
+#define DIO38_RPORT     PINE
+#define DIO38_WPORT     PORTE
+#define DIO38_PWM			NULL
+#define DIO38_DDR       DDRE
+
+#define DIO39_PIN       PINE7
+#define DIO39_RPORT     PINE
+#define DIO39_WPORT     PORTE
+#define DIO39_PWM			NULL
+#define DIO39_DDR       DDRE
+
+#define AIO0_PIN PINF0
+#define AIO0_RPORT PINF
+#define AIO0_WPORT PORTF
+#define AIO0_PWM			NULL
+#define AIO0_DDR DDRF
+
+#define AIO1_PIN PINF1
+#define AIO1_RPORT PINF
+#define AIO1_WPORT PORTF
+#define AIO1_PWM			NULL
+#define AIO1_DDR DDRF
+
+#define AIO2_PIN PINF2
+#define AIO2_RPORT PINF
+#define AIO2_WPORT PORTF
+#define AIO2_PWM			NULL
+#define AIO2_DDR DDRF
+
+#define AIO3_PIN PINF3
+#define AIO3_RPORT PINF
+#define AIO3_WPORT PORTF
+#define AIO3_PWM			NULL
+#define AIO3_DDR DDRF
+
+#define AIO4_PIN PINF4
+#define AIO4_RPORT PINF
+#define AIO4_WPORT PORTF
+#define AIO4_PWM			NULL
+#define AIO4_DDR DDRF
+
+#define AIO5_PIN PINF5
+#define AIO5_RPORT PINF
+#define AIO5_WPORT PORTF
+#define AIO5_PWM			NULL
+#define AIO5_DDR DDRF
+
+#define AIO6_PIN PINF6
+#define AIO6_RPORT PINF
+#define AIO6_WPORT PORTF
+#define AIO6_PWM			NULL
+#define AIO6_DDR DDRF
+
+#define AIO7_PIN PINF7
+#define AIO7_RPORT PINF
+#define AIO7_WPORT PORTF
+#define AIO7_PWM			NULL
+#define AIO7_DDR DDRF
+
+#define DIO40_PIN       PINF0
+#define DIO40_RPORT     PINF
+#define DIO40_WPORT     PORTF
+#define DIO40_PWM			NULL
+#define DIO40_DDR       DDRF
+
+#define DIO41_PIN       PINF1
+#define DIO41_RPORT     PINF
+#define DIO41_WPORT     PORTF
+#define DIO41_PWM			NULL
+#define DIO41_DDR       DDRF
+
+#define DIO42_PIN       PINF2
+#define DIO42_RPORT     PINF
+#define DIO42_WPORT     PORTF
+#define DIO42_PWM			NULL
+#define DIO42_DDR       DDRF
+
+#define DIO43_PIN       PINF3
+#define DIO43_RPORT     PINF
+#define DIO43_WPORT     PORTF
+#define DIO43_PWM			NULL
+#define DIO43_DDR       DDRF
+
+#define DIO44_PIN       PINF4
+#define DIO44_RPORT     PINF
+#define DIO44_WPORT     PORTF
+#define DIO44_PWM			NULL
+#define DIO44_DDR       DDRF
+
+#define DIO45_PIN       PINF5
+#define DIO45_RPORT     PINF
+#define DIO45_WPORT     PORTF
+#define DIO45_PWM			NULL
+#define DIO45_DDR       DDRF
+
+#define DIO46_PIN       PINF6
+#define DIO46_RPORT     PINF
+#define DIO46_WPORT     PORTF
+#define DIO46_PWM			NULL
+#define DIO46_DDR       DDRF
+
+#define DIO47_PIN       PINF7
+#define DIO47_RPORT     PINF
+#define DIO47_WPORT     PORTF
+#define DIO47_PWM			NULL
+#define DIO47_DDR       DDRF
+
+
+
+#undef PA0
+#define PA0_PIN			PINA0
+#define PA0_RPORT		PINA
+#define PA0_WPORT		PORTA
+#define PA0_PWM			NULL
+#define PA0_DDR			DDRA
+#undef PA1
+#define PA1_PIN			PINA1
+#define PA1_RPORT		PINA
+#define PA1_WPORT		PORTA
+#define PA1_PWM			NULL
+#define PA1_DDR			DDRA
+#undef PA2
+#define PA2_PIN			PINA2
+#define PA2_RPORT		PINA
+#define PA2_WPORT		PORTA
+#define PA2_PWM			NULL
+#define PA2_DDR			DDRA
+#undef PA3
+#define PA3_PIN			PINA3
+#define PA3_RPORT		PINA
+#define PA3_WPORT		PORTA
+#define PA3_PWM			NULL
+#define PA3_DDR			DDRA
+#undef PA4
+#define PA4_PIN			PINA4
+#define PA4_RPORT		PINA
+#define PA4_WPORT		PORTA
+#define PA4_PWM			NULL
+#define PA4_DDR			DDRA
+#undef PA5
+#define PA5_PIN			PINA5
+#define PA5_RPORT		PINA
+#define PA5_WPORT		PORTA
+#define PA5_PWM			NULL
+#define PA5_DDR			DDRA
+#undef PA6
+#define PA6_PIN			PINA6
+#define PA6_RPORT		PINA
+#define PA6_WPORT		PORTA
+#define PA6_PWM			NULL
+#define PA6_DDR			DDRA
+#undef PA7
+#define PA7_PIN			PINA7
+#define PA7_RPORT		PINA
+#define PA7_WPORT		PORTA
+#define PA7_PWM			NULL
+#define PA7_DDR			DDRA
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_PWM			NULL
+#define PB0_DDR			DDRB
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_PWM			NULL
+#define PB1_DDR			DDRB
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_PWM			NULL
+#define PB2_DDR			DDRB
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_PWM			NULL
+#define PB3_DDR			DDRB
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_PWM			NULL
+#define PB4_DDR			DDRB
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_PWM			NULL
+#define PB5_DDR			DDRB
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_PWM			NULL
+#define PB6_DDR			DDRB
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_PWM			NULL
+#define PB7_DDR			DDRB
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_PWM			NULL
+#define PC0_DDR			DDRC
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_PWM			NULL
+#define PC1_DDR			DDRC
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_PWM			NULL
+#define PC2_DDR			DDRC
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_PWM			NULL
+#define PC3_DDR			DDRC
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_PWM			NULL
+#define PC4_DDR			DDRC
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_PWM			NULL
+#define PC5_DDR			DDRC
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_PWM			NULL
+#define PC6_DDR			DDRC
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_PWM			NULL
+#define PC7_DDR			DDRC
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_PWM			NULL
+#define PD0_DDR			DDRD
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_PWM			NULL
+#define PD1_DDR			DDRD
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_PWM			NULL
+#define PD2_DDR			DDRD
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_PWM			NULL
+#define PD3_DDR			DDRD
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_PWM			NULL
+#define PD4_DDR			DDRD
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_PWM			NULL
+#define PD5_DDR			DDRD
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_PWM			NULL
+#define PD6_DDR			DDRD
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_PWM			NULL
+#define PD7_DDR			DDRD
+
+#undef PE0
+#define PE0_PIN			PINE0
+#define PE0_RPORT		PINE
+#define PE0_WPORT		PORTE
+#define PE0_PWM			NULL
+#define PE0_DDR			DDRE
+#undef PE1
+#define PE1_PIN			PINE1
+#define PE1_RPORT		PINE
+#define PE1_WPORT		PORTE
+#define PE1_PWM			NULL
+#define PE1_DDR			DDRE
+#undef PE2
+#define PE2_PIN			PINE2
+#define PE2_RPORT		PINE
+#define PE2_WPORT		PORTE
+#define PE2_PWM			NULL
+#define PE2_DDR			DDRE
+#undef PE3
+#define PE3_PIN			PINE3
+#define PE3_RPORT		PINE
+#define PE3_WPORT		PORTE
+#define PE3_PWM			NULL
+#define PE3_DDR			DDRE
+#undef PE4
+#define PE4_PIN			PINE4
+#define PE4_RPORT		PINE
+#define PE4_WPORT		PORTE
+#define PE4_PWM			NULL
+#define PE4_DDR			DDRE
+#undef PE5
+#define PE5_PIN			PINE5
+#define PE5_RPORT		PINE
+#define PE5_WPORT		PORTE
+#define PE5_PWM			NULL
+#define PE5_DDR			DDRE
+#undef PE6
+#define PE6_PIN			PINE6
+#define PE6_RPORT		PINE
+#define PE6_WPORT		PORTE
+#define PE6_PWM			NULL
+#define PE6_DDR			DDRE
+#undef PE7
+#define PE7_PIN			PINE7
+#define PE7_RPORT		PINE
+#define PE7_WPORT		PORTE
+#define PE7_PWM			NULL
+#define PE7_DDR			DDRE
+
+#undef PF0
+#define PF0_PIN			PINF0
+#define PF0_RPORT		PINF
+#define PF0_WPORT		PORTF
+#define PF0_PWM			NULL
+#define PF0_DDR			DDRF
+#undef PF1
+#define PF1_PIN			PINF1
+#define PF1_RPORT		PINF
+#define PF1_WPORT		PORTF
+#define PF1_PWM			NULL
+#define PF1_DDR			DDRF
+#undef PF2
+#define PF2_PIN			PINF2
+#define PF2_RPORT		PINF
+#define PF2_WPORT		PORTF
+#define PF2_PWM			NULL
+#define PF2_DDR			DDRF
+#undef PF3
+#define PF3_PIN			PINF3
+#define PF3_RPORT		PINF
+#define PF3_WPORT		PORTF
+#define PF3_PWM			NULL
+#define PF3_DDR			DDRF
+#undef PF4
+#define PF4_PIN			PINF4
+#define PF4_RPORT		PINF
+#define PF4_WPORT		PORTF
+#define PF4_PWM			NULL
+#define PF4_DDR			DDRF
+#undef PF5
+#define PF5_PIN			PINF5
+#define PF5_RPORT		PINF
+#define PF5_WPORT		PORTF
+#define PF5_PWM			NULL
+#define PF5_DDR			DDRF
+#undef PF6
+#define PF6_PIN			PINF6
+#define PF6_RPORT		PINF
+#define PF6_WPORT		PORTF
+#define PF6_PWM			NULL
+#define PF6_DDR			DDRF
+#undef PF7
+#define PF7_PIN			PINF7
+#define PF7_RPORT		PINF
+#define PF7_WPORT		PORTF
+#define PF7_PWM			NULL
+#define PF7_DDR			DDRF
+#endif
+
+#ifndef	DIO0_PIN
+#error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
+#endif
+
 #endif /* _ARDUINO_H */
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 60dd6e5..4ec2279 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -1,695 +1,737 @@
-#ifndef PINS_H
-#define PINS_H
-
-/****************************************************************************************
-* Arduino pin assignment
-*
-*                  ATMega168
-*                   +-\/-+
-*             PC6  1|    |28  PC5 (AI 5 / D19)
-*       (D 0) PD0  2|    |27  PC4 (AI 4 / D18)
-*       (D 1) PD1  3|    |26  PC3 (AI 3 / D17)
-*       (D 2) PD2  4|    |25  PC2 (AI 2 / D16)
-*  PWM+ (D 3) PD3  5|    |24  PC1 (AI 1 / D15)
-*       (D 4) PD4  6|    |23  PC0 (AI 0 / D14)
-*             VCC  7|    |22  GND
-*             GND  8|    |21  AREF
-*             PB6  9|    |20  AVCC
-*             PB7 10|    |19  PB5 (D 13)
-*  PWM+ (D 5) PD5 11|    |18  PB4 (D 12)
-*  PWM+ (D 6) PD6 12|    |17  PB3 (D 11) PWM
-*       (D 7) PD7 13|    |16  PB2 (D 10) PWM
-*       (D 8) PB0 14|    |15  PB1 (D 9)  PWM
-*                   +----+
-****************************************************************************************/
-#if MOTHERBOARD == 0
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega168__
-#error Oops!  Make sure you have 'Arduino Diecimila' selected from the boards menu.
-#endif
-
-#define X_STEP_PIN          2
-#define X_DIR_PIN           3
-#define X_ENABLE_PIN       -1
-#define X_MIN_PIN           4
-#define X_MAX_PIN           9
-
-#define Y_STEP_PIN         10
-#define Y_DIR_PIN           7
-#define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           8
-#define Y_MAX_PIN          13
-
-#define Z_STEP_PIN         19
-#define Z_DIR_PIN          18
-#define Z_ENABLE_PIN        5
-#define Z_MIN_PIN          17
-#define Z_MAX_PIN          16
-
-#define E_STEP_PIN         11
-#define E_DIR_PIN          12
-#define E_ENABLE_PIN       -1
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN            -1
-#define FAN_PIN            -1
-#define PS_ON_PIN          15
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN        6
-#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-#endif
-
-
-
-/****************************************************************************************
-* Sanguino/RepRap Motherboard with direct-drive extruders
-*
-*                        ATMega644P
-*
-*                        +---\/---+
-*            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-*            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-*       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-*        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-*        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-*       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-*       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-*        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-*                  RST  9|        |32  AREF
-*                  VCC 10|        |31  GND 
-*                  GND 11|        |30  AVCC
-*                XTAL2 12|        |29  PC7 (D 23)
-*                XTAL1 13|        |28  PC6 (D 22)
-*       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-*       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-*  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-*  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-*       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-*       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-*       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-*                        +--------+
-*
-****************************************************************************************/
-#if MOTHERBOARD == 1
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         15
-#define X_DIR_PIN          18
-#define X_ENABLE_PIN       19
-#define X_MIN_PIN          20
-#define X_MAX_PIN          21
-
-#define Y_STEP_PIN         23
-#define Y_DIR_PIN          22
-#define Y_ENABLE_PIN       19
-#define Y_MIN_PIN          25
-#define Y_MAX_PIN          26
-
-#define Z_STEP_PIN         29
-#define Z_DIR_PIN          30
-#define Z_ENABLE_PIN       31
-#define Z_MIN_PIN           2
-#define Z_MAX_PIN           1
-
-#define E_STEP_PIN         12
-#define E_DIR_PIN          16
-#define E_ENABLE_PIN        3
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN             0
-#define FAN_PIN            -1
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       14
-#define TEMP_0_PIN          4 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
-
-
-
-#endif
-
-
-/****************************************************************************************
-* RepRap Motherboard  ****---NOOOOOO RS485/EXTRUDER CONTROLLER!!!!!!!!!!!!!!!!!---*******
-*
-****************************************************************************************/
-#if MOTHERBOARD == 2
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN      15
-#define X_DIR_PIN       18
-#define X_ENABLE_PIN    19
-#define X_MIN_PIN       20
-#define X_MAX_PIN       21
-
-#define Y_STEP_PIN      23
-#define Y_DIR_PIN       22
-#define Y_ENABLE_PIN    24
-#define Y_MIN_PIN       25
-#define Y_MAX_PIN       26
-
-#define Z_STEP_PINN     27
-#define Z_DIR_PINN      28
-#define Z_ENABLE_PIN    29
-#define Z_MIN_PIN       30
-#define Z_MAX_PIN       31
-
-#define E_STEP_PIN      17
-#define E_DIR_PIN       16
-#define E_ENABLE_PIN    -1
-
-#define SDPOWER          -1
-#define SDSS          4
-#define LED_PIN          0
-
-#define SD_CARD_WRITE    2
-#define SD_CARD_DETECT   3
-#define SD_CARD_SELECT   4
-
-//our RS485 pins
-#define TX_ENABLE_PIN	12
-#define RX_ENABLE_PIN	13
-
-//pin for controlling the PSU.
-#define PS_ON_PIN       14
-
-#define FAN_PIN         -1
-#define KILL_PIN        -1
-
-#define HEATER_0_PIN    -1
-#define TEMP_0_PIN      -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-
-
-
-#endif
-
-/****************************************************************************************
-* Arduino Mega pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 33
-#define MOTHERBOARD 3
-#define RAMPS_V_1_3
-#endif
-#if MOTHERBOARD == 3
-#define KNOWN_BOARD 1
-
-//////////////////FIX THIS//////////////
-#ifndef __AVR_ATmega1280__
- #ifndef __AVR_ATmega2560__
- #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
- #endif
-#endif
-
-// uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
-// #define RAMPS_V_1_3
-// #define RAMPS_V_1_0
-
-#ifdef RAMPS_V_1_3
-
-#define X_STEP_PIN         54
-#define X_DIR_PIN          55
-#define X_ENABLE_PIN       38
-#define X_MIN_PIN           3
-#define X_MAX_PIN          -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
-
-#define Y_STEP_PIN         60
-#define Y_DIR_PIN          61
-#define Y_ENABLE_PIN       56
-#define Y_MIN_PIN          14
-#define Y_MAX_PIN          -1   //15
-
-#define Z_STEP_PIN         46
-#define Z_DIR_PIN          48
-#define Z_ENABLE_PIN       62
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          -1   //19
-
-#define E_STEP_PIN         26
-#define E_DIR_PIN          28
-#define E_ENABLE_PIN       24
-
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
-#define FAN_PIN            9
-#define PS_ON_PIN          12
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       10
-#define HEATER_1_PIN       8
-#define HEATER_2_PIN        -1
-#define TEMP_0_PIN         13   // ANALOG NUMBERING
-#define TEMP_1_PIN         14   // ANALOG NUMBERING
-#define TEMP_2_PIN         -1   // ANALOG NUMBERING
-
-
-#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
-
-#define X_STEP_PIN         26
-#define X_DIR_PIN          28
-#define X_ENABLE_PIN       24
-#define X_MIN_PIN           3
-#define X_MAX_PIN          -1    //2
-
-#define Y_STEP_PIN         38
-#define Y_DIR_PIN          40
-#define Y_ENABLE_PIN       36
-#define Y_MIN_PIN          16
-#define Y_MAX_PIN          -1    //17
-
-#define Z_STEP_PIN         44
-#define Z_DIR_PIN          46
-#define Z_ENABLE_PIN       42
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          -1    //19
-
-#define E_STEP_PIN         32
-#define E_DIR_PIN          34
-#define E_ENABLE_PIN       30
-
-#define SDPOWER            48
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-
-
-#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
-  #define HEATER_0_PIN     12    // RAMPS 1.0
-  #define HEATER_1_PIN     -1    // RAMPS 1.0
-  #define FAN_PIN          11    // RAMPS 1.0
-
-#else // RAMPS_V_1_1 or RAMPS_V_1_2
-  #define HEATER_0_PIN     10    // RAMPS 1.1
-  #define HEATER_1_PIN      8    // RAMPS 1.1
-  #define FAN_PIN           9    // RAMPS 1.1
-#endif
-#define HEATER_2_PIN        -1
-#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_2_PIN          -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#endif
-
-// SPI for Max6675 Thermocouple 
-
-#ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  #define SCK_PIN          52
-  #define MISO_PIN         50
-  #define MOSI_PIN         51
-  #define MAX6675_SS       53
-#else
-  #define MAX6675_SS       49
-#endif
-
-
-#endif
-/****************************************************************************************
-* Duemilanove w/ ATMega328P pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 4
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega328P__
-#error Oops!  Make sure you have 'Arduino Duemilanove w/ ATMega328' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         19
-#define X_DIR_PIN          18
-#define X_ENABLE_PIN       -1
-#define X_MIN_PIN          17
-#define X_MAX_PIN          -1
-
-#define Y_STEP_PIN         10
-#define Y_DIR_PIN           7
-#define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           8
-#define Y_MAX_PIN          -1
-
-#define Z_STEP_PIN         13
-#define Z_DIR_PIN           3
-#define Z_ENABLE_PIN        2
-#define Z_MIN_PIN           4
-#define Z_MAX_PIN          -1
-
-#define E_STEP_PIN         11
-#define E_DIR_PIN          12
-#define E_ENABLE_PIN       -1
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN            -1
-#define FAN_PIN             5
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN        6
-#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-
-#endif
-
-/****************************************************************************************
-* Gen6 pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 5
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-    #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-//x axis pins
-    #define X_STEP_PIN      15
-    #define X_DIR_PIN       18
-    #define X_ENABLE_PIN    19
-    #define X_MIN_PIN       20
-    #define X_MAX_PIN       -1
-    
-    //y axis pins
-    #define Y_STEP_PIN      23
-    #define Y_DIR_PIN       22
-    #define Y_ENABLE_PIN    24
-    #define Y_MIN_PIN       25
-    #define Y_MAX_PIN       -1
-    
-    //z axis pins
-    #define Z_STEP_PIN      27
-    #define Z_DIR_PIN       28
-    #define Z_ENABLE_PIN    29
-    #define Z_MIN_PIN       30
-    #define Z_MAX_PIN       -1
-    
-    //extruder pins
-    #define E_STEP_PIN      4     //Edited @ EJE Electronics 20100715
-    #define E_DIR_PIN       2     //Edited @ EJE Electronics 20100715
-    #define E_ENABLE_PIN    3     //Added @ EJE Electronics 20100715
-    #define TEMP_0_PIN      5     //changed @ rkoeppl 20110410
-    #define HEATER_0_PIN    14    //changed @ rkoeppl 20110410
-    #define HEATER_1_PIN    -1    //changed @ rkoeppl 20110410
-    #define HEATER_2_PIN        -1
-    
-    #define SDPOWER          -1
-    #define SDSS          17
-    #define LED_PIN         -1    //changed @ rkoeppl 20110410
-    #define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410
-    #define TEMP_2_PIN      -1
-    #define FAN_PIN         -1    //changed @ rkoeppl 20110410
-    #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
-    //our pin for debugging.
-    
-    #define DEBUG_PIN        0
-    
-    //our RS485 pins
-    #define TX_ENABLE_PIN	12
-    #define RX_ENABLE_PIN	13
-
-    
-#endif
-
-/****************************************************************************************
-* Sanguinololu pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 62
-#define MOTHERBOARD 6
-#define SANGUINOLOLU_V_1_2 
-#endif
-#if MOTHERBOARD == 6
-#define KNOWN_BOARD 1
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         15
-#define X_DIR_PIN          21
-#define X_MIN_PIN          18
-#define X_MAX_PIN           -2
-
-#define Y_STEP_PIN         22
-#define Y_DIR_PIN          23
-#define Y_MIN_PIN          19
-#define Y_MAX_PIN          -1
-
-#define Z_STEP_PIN         3
-#define Z_DIR_PIN          2
-#define Z_MIN_PIN          20
-#define Z_MAX_PIN          -1
-
-#define E_STEP_PIN         1
-#define E_DIR_PIN          0
-
-#define LED_PIN            -1
-
-#define FAN_PIN            -1 
-
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       13 // (extruder)
-
-#ifdef SANGUINOLOLU_V_1_2
-
-#define HEATER_1_PIN       12 // (bed)
-#define X_ENABLE_PIN       14
-#define Y_ENABLE_PIN       14
-#define Z_ENABLE_PIN       26
-#define E_ENABLE_PIN       14
-
-#else
-
-#define HEATER_1_PIN       14  // (bed)
-#define X_ENABLE_PIN       -1
-#define Y_ENABLE_PIN       -1
-#define Z_ENABLE_PIN       -1
-#define E_ENABLE_PIN       -1
-
-#endif
-
-#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
-#define TEMP_1_PIN          6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
-#define TEMP_2_PIN         -1
-#define SDPOWER            -1
-#define SDSS               31
-#define HEATER_2_PIN       -1
-
-#endif
-
-
-#if MOTHERBOARD == 7
-#define KNOWN_BOARD
-/*****************************************************************
-* Ultimaker pin assignment
-******************************************************************/
-
-#ifndef __AVR_ATmega1280__
- #ifndef __AVR_ATmega2560__
- #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
- #endif
-#endif
-
-#define X_STEP_PIN 25
-#define X_DIR_PIN 23
-#define X_MIN_PIN 22
-#define X_MAX_PIN 24
-#define X_ENABLE_PIN 27
-
-#define Y_STEP_PIN 31
-#define Y_DIR_PIN 33
-#define Y_MIN_PIN 26
-#define Y_MAX_PIN 28
-#define Y_ENABLE_PIN 29
-
-#define Z_STEP_PIN 37 
-#define Z_DIR_PIN 39
-#define Z_MIN_PIN 30
-#define Z_MAX_PIN 32
-#define Z_ENABLE_PIN 35
-
-#define HEATER_1_PIN 4 
-#define TEMP_1_PIN 11  
-
-#define EXTRUDER_0_STEP_PIN 43 
-#define EXTRUDER_0_DIR_PIN 45
-#define EXTRUDER_0_ENABLE_PIN 41
-#define HEATER_0_PIN  2
-#define TEMP_0_PIN 8   
-
-#define EXTRUDER_1_STEP_PIN 49 
-#define EXTRUDER_1_DIR_PIN 47
-#define EXTRUDER_1_ENABLE_PIN 51
-#define EXTRUDER_1_HEATER_PIN 3
-#define EXTRUDER_1_TEMPERATURE_PIN 10 
-#define HEATER_2_PIN 51
-#define TEMP_2_PIN 3
-
-
-
-#define E_STEP_PIN         EXTRUDER_0_STEP_PIN
-#define E_DIR_PIN          EXTRUDER_0_DIR_PIN
-#define E_ENABLE_PIN       EXTRUDER_0_ENABLE_PIN
-
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
-#define FAN_PIN            7
-#define PS_ON_PIN          12
-#define KILL_PIN           -1
-
-#ifdef ULTRA_LCD
-
-  #ifdef NEWPANEL
-  //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 18
-
-    #define LCD_PINS_RS 20 
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 16
-    #define LCD_PINS_D5 21 
-    #define LCD_PINS_D6 5
-    #define LCD_PINS_D7 6
-    
-    //buttons are directly attached
-    #define BTN_EN1 40
-    #define BTN_EN2 42
-    #define BTN_ENC 19  //the click
-    
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
-    
-    #define SDCARDDETECT 38
-    
-      //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-  #else //old style panel with shift register
-    //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 18
-
-    //buttons are attached to a shift register
-    #define SHIFT_CLK 38
-    #define SHIFT_LD 42
-    #define SHIFT_OUT 40
-    #define SHIFT_EN 17
-    
-    #define LCD_PINS_RS 16 
-    #define LCD_PINS_ENABLE 5
-    #define LCD_PINS_D4 6
-    #define LCD_PINS_D5 21 
-    #define LCD_PINS_D6 20
-    #define LCD_PINS_D7 19
-    
-    //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-
-    
-    //bits in the shift register that carry the buttons for:
-    // left up center down right red
-    #define BL_LE 7
-    #define BL_UP 6
-    #define BL_MI 5
-    #define BL_DW 4
-    #define BL_RI 3
-    #define BL_ST 2
-
-    #define BLEN_B 1
-    #define BLEN_A 0
-  #endif 
-#endif //ULTRA_LCD
-
-#endif
-
-/****************************************************************************************
-* Teensylu 0.7 pin assingments (ATMEGA90USB)
-* Requires the Teensyduino software with Teensy2.0++ selected in arduino IDE!
-****************************************************************************************/
-#if MOTHERBOARD == 8
-#define MOTHERBOARD 8
-#define KNOWN_BOARD 1
-
-
-#define X_STEP_PIN          0  
-#define X_DIR_PIN           1  
-#define X_ENABLE_PIN       39 
-#define X_MIN_PIN          13 
-#define X_MAX_PIN          -1    
-
-#define Y_STEP_PIN          2  
-#define Y_DIR_PIN           3 
-#define Y_ENABLE_PIN       38 
-#define Y_MIN_PIN          14 
-#define Y_MAX_PIN          -1    
-
-#define Z_STEP_PIN          4
-#define Z_DIR_PIN           5 
-#define Z_ENABLE_PIN       23 
-#define Z_MIN_PIN          15 
-#define Z_MAX_PIN          -1    
-
-#define E_STEP_PIN          6  
-#define E_DIR_PIN           7 
-#define E_ENABLE_PIN       19 
-
-
-
-#define HEATER_0_PIN       21  // Extruder
-#define HEATER_1_PIN       20  // Bed
-#define HEATER_2_PIN       -1
-#define FAN_PIN            22  // Fan   
-
-#define TEMP_0_PIN          7  // Extruder
-#define TEMP_1_PIN          6  // Bed
-#define TEMP_2_PIN         -1
-
-#define SDPOWER            -1
-#define SDSS                8
-#define LED_PIN            -1
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1 
-#define ALARM_PIN          -1
-
-#ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  
-  #define SCK_PIN           9 
-  #define MISO_PIN         11 
-  #define MOSI_PIN         10 
-#endif
-#endif
-
-#ifndef KNOWN_BOARD
-#error Unknown MOTHERBOARD value in configuration.h
-#endif
-
-//List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
-#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, E_STEP_PIN, E_DIR_PIN, E_ENABLE_PIN, LED_PIN, PS_ON_PIN, HEATER_0_PIN, HEATER_1_PIN, HEATER_2_PIN, FAN_PIN, TEMP_0_PIN, TEMP_1_PIN, TEMP_2_PIN}
-
+#ifndef PINS_H
+#define PINS_H
+
+/****************************************************************************************
+* Arduino pin assignment
+*
+*                  ATMega168
+*                   +-\/-+
+*             PC6  1|    |28  PC5 (AI 5 / D19)
+*       (D 0) PD0  2|    |27  PC4 (AI 4 / D18)
+*       (D 1) PD1  3|    |26  PC3 (AI 3 / D17)
+*       (D 2) PD2  4|    |25  PC2 (AI 2 / D16)
+*  PWM+ (D 3) PD3  5|    |24  PC1 (AI 1 / D15)
+*       (D 4) PD4  6|    |23  PC0 (AI 0 / D14)
+*             VCC  7|    |22  GND
+*             GND  8|    |21  AREF
+*             PB6  9|    |20  AVCC
+*             PB7 10|    |19  PB5 (D 13)
+*  PWM+ (D 5) PD5 11|    |18  PB4 (D 12)
+*  PWM+ (D 6) PD6 12|    |17  PB3 (D 11) PWM
+*       (D 7) PD7 13|    |16  PB2 (D 10) PWM
+*       (D 8) PB0 14|    |15  PB1 (D 9)  PWM
+*                   +----+
+****************************************************************************************/
+#if MOTHERBOARD == 0
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega168__
+#error Oops!  Make sure you have 'Arduino Diecimila' selected from the boards menu.
+#endif
+
+#define X_STEP_PIN          2
+#define X_DIR_PIN           3
+#define X_ENABLE_PIN       -1
+#define X_MIN_PIN           4
+#define X_MAX_PIN           9
+
+#define Y_STEP_PIN         10
+#define Y_DIR_PIN           7
+#define Y_ENABLE_PIN       -1
+#define Y_MIN_PIN           8
+#define Y_MAX_PIN          13
+
+#define Z_STEP_PIN         19
+#define Z_DIR_PIN          18
+#define Z_ENABLE_PIN        5
+#define Z_MIN_PIN          17
+#define Z_MAX_PIN          16
+
+#define E0_STEP_PIN         11
+#define E0_DIR_PIN          12
+#define E0_ENABLE_PIN       -1
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN            -1
+#define FAN_PIN            -1
+#define PS_ON_PIN          15
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN        6
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN          -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_2_PIN          -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define HEATER_BED_PIN      -1
+#define TEMP_BED_PIN        -1
+#endif
+
+
+
+/****************************************************************************************
+* Sanguino/RepRap Motherboard with direct-drive extruders
+*
+*                        ATMega644P
+*
+*                        +---\/---+
+*            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+*            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+*       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+*        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+*        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+*       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+*       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+*        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+*                  RST  9|        |32  AREF
+*                  VCC 10|        |31  GND 
+*                  GND 11|        |30  AVCC
+*                XTAL2 12|        |29  PC7 (D 23)
+*                XTAL1 13|        |28  PC6 (D 22)
+*       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+*       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+*  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+*  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+*       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+*       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+*       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+*                        +--------+
+*
+****************************************************************************************/
+#if MOTHERBOARD == 1
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         15
+#define X_DIR_PIN          18
+#define X_ENABLE_PIN       19
+#define X_MIN_PIN          20
+#define X_MAX_PIN          21
+
+#define Y_STEP_PIN         23
+#define Y_DIR_PIN          22
+#define Y_ENABLE_PIN       19
+#define Y_MIN_PIN          25
+#define Y_MAX_PIN          26
+
+#define Z_STEP_PIN         29
+#define Z_DIR_PIN          30
+#define Z_ENABLE_PIN       31
+#define Z_MIN_PIN           2
+#define Z_MAX_PIN           1
+
+#define E0_STEP_PIN         12
+#define E0_DIR_PIN          16
+#define E0_ENABLE_PIN        3
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN             0
+#define FAN_PIN            -1
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       14
+#define HEATER_1_PIN       -1
+#define HEATER_2_PIN       -1
+#define TEMP_0_PIN          4 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN         -1 
+#define TEMP_2_PIN         -1 
+#define HEATER_BED_PIN     -1
+#define TEMP_BED_PIN       -1
+/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
+
+
+
+#endif
+
+
+/****************************************************************************************
+* RepRap Motherboard  ****---NOOOOOO RS485/EXTRUDER CONTROLLER!!!!!!!!!!!!!!!!!---*******
+*
+****************************************************************************************/
+#if MOTHERBOARD == 2
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN      15
+#define X_DIR_PIN       18
+#define X_ENABLE_PIN    19
+#define X_MIN_PIN       20
+#define X_MAX_PIN       21
+
+#define Y_STEP_PIN      23
+#define Y_DIR_PIN       22
+#define Y_ENABLE_PIN    24
+#define Y_MIN_PIN       25
+#define Y_MAX_PIN       26
+
+#define Z_STEP_PINN     27
+#define Z_DIR_PINN      28
+#define Z_ENABLE_PIN    29
+#define Z_MIN_PIN       30
+#define Z_MAX_PIN       31
+
+#define E0_STEP_PIN      17
+#define E0_DIR_PIN       16
+#define E0_ENABLE_PIN    -1
+
+#define SDPOWER          -1
+#define SDSS          4
+#define LED_PIN          0
+
+#define SD_CARD_WRITE    2
+#define SD_CARD_DETECT   3
+#define SD_CARD_SELECT   4
+
+//our RS485 pins
+#define TX_ENABLE_PIN	12
+#define RX_ENABLE_PIN	13
+
+//pin for controlling the PSU.
+#define PS_ON_PIN       14
+
+#define FAN_PIN         -1
+#define KILL_PIN        -1
+
+#define HEATER_0_PIN    -1
+#define HEATER_1_PIN    -1
+#define HEATER_2_PIN    -1
+#define TEMP_0_PIN      -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN      -1    
+#define TEMP_2_PIN      -1    
+#define HEATER_BED_PIN  -1
+#define TEMP_BED_PIN    -1
+
+#endif
+
+/****************************************************************************************
+* Arduino Mega pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 33
+#define MOTHERBOARD 3
+#define RAMPS_V_1_3
+#endif
+#if MOTHERBOARD == 3
+#define KNOWN_BOARD 1
+
+//////////////////FIX THIS//////////////
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+// uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
+// #define RAMPS_V_1_3
+// #define RAMPS_V_1_0
+
+#ifdef RAMPS_V_1_3
+
+#define X_STEP_PIN         54
+#define X_DIR_PIN          55
+#define X_ENABLE_PIN       38
+#define X_MIN_PIN           3
+#define X_MAX_PIN           2   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+#define Y_STEP_PIN         60
+#define Y_DIR_PIN          61
+#define Y_ENABLE_PIN       56
+#define Y_MIN_PIN          14
+#define Y_MAX_PIN          15   //15
+
+#define Z_STEP_PIN         46
+#define Z_DIR_PIN          48
+#define Z_ENABLE_PIN       62
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          19   //19
+
+#define E0_STEP_PIN        26
+#define E0_DIR_PIN         28
+#define E0_ENABLE_PIN      24
+
+#define E1_STEP_PIN        36
+#define E1_DIR_PIN         34
+#define E1_ENABLE_PIN      30
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+#define FAN_PIN            4
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       10   // EXTRUDER 1
+#define HEATER_1_PIN       9    // EXTRUDER 2
+#define HEATER_2_PIN       -1   // EXTRUDER 2
+#define TEMP_0_PIN         13   // ANALOG NUMBERING
+#define TEMP_1_PIN         15   // ANALOG NUMBERING
+#define TEMP_2_PIN         -1   // ANALOG NUMBERING
+#define HEATER_BED_PIN     8    // BED
+#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+
+
+#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
+
+#define X_STEP_PIN         26
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       24
+#define X_MIN_PIN           3
+#define X_MAX_PIN          -1    //2
+
+#define Y_STEP_PIN         38
+#define Y_DIR_PIN          40
+#define Y_ENABLE_PIN       36
+#define Y_MIN_PIN          16
+#define Y_MAX_PIN          -1    //17
+
+#define Z_STEP_PIN         44
+#define Z_DIR_PIN          46
+#define Z_ENABLE_PIN       42
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          -1    //19
+
+#define E0_STEP_PIN         32
+#define E0_DIR_PIN          34
+#define E0_ENABLE_PIN       30
+
+#define SDPOWER            48
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+
+
+#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
+  #define HEATER_0_PIN     12    // RAMPS 1.0
+  #define HEATER_BED_PIN   -1    // RAMPS 1.0
+  #define FAN_PIN          11    // RAMPS 1.0
+#else // RAMPS_V_1_1 or RAMPS_V_1_2
+  #define HEATER_0_PIN     10    // RAMPS 1.1
+  #define HEATER_BED_PIN    8    // RAMPS 1.1
+  #define FAN_PIN           9    // RAMPS 1.1
+#endif
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN          -1   
+#define TEMP_2_PIN          -1   
+#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#endif
+
+// SPI for Max6675 Thermocouple 
+
+#ifndef SDSUPPORT
+// these pins are defined in the SD library if building with SD support  #define SCK_PIN          52
+  #define MISO_PIN         50
+  #define MOSI_PIN         51
+  #define MAX6675_SS       53
+#else
+  #define MAX6675_SS       49
+#endif
+
+
+#endif
+/****************************************************************************************
+* Duemilanove w/ ATMega328P pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 4
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega328P__
+#error Oops!  Make sure you have 'Arduino Duemilanove w/ ATMega328' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         19
+#define X_DIR_PIN          18
+#define X_ENABLE_PIN       -1
+#define X_MIN_PIN          17
+#define X_MAX_PIN          -1
+
+#define Y_STEP_PIN         10
+#define Y_DIR_PIN           7
+#define Y_ENABLE_PIN       -1
+#define Y_MIN_PIN           8
+#define Y_MAX_PIN          -1
+
+#define Z_STEP_PIN         13
+#define Z_DIR_PIN           3
+#define Z_ENABLE_PIN        2
+#define Z_MIN_PIN           4
+#define Z_MAX_PIN          -1
+
+#define E0_STEP_PIN         11
+#define E0_DIR_PIN          12
+#define E0_ENABLE_PIN       -1
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN            -1
+#define FAN_PIN             5
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN        6
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN          -1    
+#define TEMP_2_PIN          -1    
+#define HEATER_BED_PIN      -1
+#define TEMP_BED_PIN        -1
+
+#endif
+
+/****************************************************************************************
+* Gen6 pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 5
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+    #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+//x axis pins
+    #define X_STEP_PIN      15
+    #define X_DIR_PIN       18
+    #define X_ENABLE_PIN    19
+    #define X_MIN_PIN       20
+    #define X_MAX_PIN       -1
+    
+    //y axis pins
+    #define Y_STEP_PIN      23
+    #define Y_DIR_PIN       22
+    #define Y_ENABLE_PIN    24
+    #define Y_MIN_PIN       25
+    #define Y_MAX_PIN       -1
+    
+    //z axis pins
+    #define Z_STEP_PIN      27
+    #define Z_DIR_PIN       28
+    #define Z_ENABLE_PIN    29
+    #define Z_MIN_PIN       30
+    #define Z_MAX_PIN       -1
+    
+    //extruder pins
+    #define E0_STEP_PIN      4    //Edited @ EJE Electronics 20100715
+    #define E0_DIR_PIN       2    //Edited @ EJE Electronics 20100715
+    #define E0_ENABLE_PIN    3    //Added @ EJE Electronics 20100715
+    #define TEMP_0_PIN      5     //changed @ rkoeppl 20110410
+    #define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410
+    #define TEMP_2_PIN      -1    //changed @ rkoeppl 20110410
+    #define HEATER_0_PIN    14    //changed @ rkoeppl 20110410
+    #define HEATER_1_PIN    -1
+    #define HEATER_2_PIN    -1
+    #define HEATER_BED_PIN  -1    //changed @ rkoeppl 20110410
+    #define TEMP_BED_PIN    -1    //changed @ rkoeppl 20110410
+    
+    #define SDPOWER          -1
+    #define SDSS          17
+    #define LED_PIN         -1    //changed @ rkoeppl 20110410
+    #define FAN_PIN         -1    //changed @ rkoeppl 20110410
+    #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
+    //our pin for debugging.
+    
+    #define DEBUG_PIN        0
+    
+    //our RS485 pins
+    #define TX_ENABLE_PIN	12
+    #define RX_ENABLE_PIN	13
+
+    
+#endif
+
+/****************************************************************************************
+* Sanguinololu pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 62
+#define MOTHERBOARD 6
+#define SANGUINOLOLU_V_1_2 
+#endif
+#if MOTHERBOARD == 6
+#define KNOWN_BOARD 1
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         15
+#define X_DIR_PIN          21
+#define X_MIN_PIN          18
+#define X_MAX_PIN           -2
+
+#define Y_STEP_PIN         22
+#define Y_DIR_PIN          23
+#define Y_MIN_PIN          19
+#define Y_MAX_PIN          -1
+
+#define Z_STEP_PIN         3
+#define Z_DIR_PIN          2
+#define Z_MIN_PIN          20
+#define Z_MAX_PIN          -1
+
+#define E0_STEP_PIN         1
+#define E0_DIR_PIN          0
+
+#define LED_PIN            -1
+
+#define FAN_PIN            -1 
+
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       13 // (extruder)
+#define HEATER_1_PIN       -1
+#define HEATER_2_PIN       -1
+
+#ifdef SANGUINOLOLU_V_1_2
+
+#define HEATER_BED_PIN     12 // (bed)
+#define X_ENABLE_PIN       14
+#define Y_ENABLE_PIN       14
+#define Z_ENABLE_PIN       26
+#define E0_ENABLE_PIN       14
+
+#else
+
+#define HEATER_BED_PIN       14  // (bed)
+#define X_ENABLE_PIN       -1
+#define Y_ENABLE_PIN       -1
+#define Z_ENABLE_PIN       -1
+#define E0_ENABLE_PIN       -1
+
+#endif
+
+#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
+#define TEMP_1_PIN         -1
+#define TEMP_2_PIN         -1
+#define TEMP_BED_PIN        6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
+#define SDPOWER            -1
+#define SDSS               31
+
+#endif
+
+
+#if MOTHERBOARD == 7
+#define KNOWN_BOARD
+/*****************************************************************
+* Ultimaker pin assignment
+******************************************************************/
+
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+#define X_STEP_PIN 25
+#define X_DIR_PIN 23
+#define X_MIN_PIN 22
+#define X_MAX_PIN 24
+#define X_ENABLE_PIN 27
+
+#define Y_STEP_PIN 31
+#define Y_DIR_PIN 33
+#define Y_MIN_PIN 26
+#define Y_MAX_PIN 28
+#define Y_ENABLE_PIN 29
+
+#define Z_STEP_PIN 37 
+#define Z_DIR_PIN 39
+#define Z_MIN_PIN 30
+#define Z_MAX_PIN 32
+#define Z_ENABLE_PIN 35
+
+#define HEATER_BED_PIN 4 
+#define TEMP_BED_PIN 11  
+
+#define HEATER_0_PIN  2
+#define TEMP_0_PIN 8   
+
+#define EXTRUDER_1_HEATER_PIN 3
+#define EXTRUDER_1_TEMPERATURE_PIN 10 
+#define HEATER_1_PIN 51
+#define TEMP_1_PIN 3
+
+#define HEATER_2_PIN -1
+#define TEMP_2_PIN -1
+
+#define E0_STEP_PIN         43
+#define E0_DIR_PIN          45
+#define E0_ENABLE_PIN       41
+
+#define E1_STEP_PIN         49
+#define E1_DIR_PIN          47
+#define E1_ENABLE_PIN       51
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+#define FAN_PIN            7
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#ifdef ULTRA_LCD
+
+  #ifdef NEWPANEL
+  //arduino pin witch triggers an piezzo beeper
+    #define BEEPER 18
+
+    #define LCD_PINS_RS 20 
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 16
+    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D6 5
+    #define LCD_PINS_D7 6
+    
+    //buttons are directly attached
+    #define BTN_EN1 40
+    #define BTN_EN2 42
+    #define BTN_ENC 19  //the click
+    
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+    
+    #define SDCARDDETECT 38
+    
+      //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+  #else //old style panel with shift register
+    //arduino pin witch triggers an piezzo beeper
+    #define BEEPER 18
+
+    //buttons are attached to a shift register
+    #define SHIFT_CLK 38
+    #define SHIFT_LD 42
+    #define SHIFT_OUT 40
+    #define SHIFT_EN 17
+    
+    #define LCD_PINS_RS 16 
+    #define LCD_PINS_ENABLE 5
+    #define LCD_PINS_D4 6
+    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D6 20
+    #define LCD_PINS_D7 19
+    
+    //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+
+    
+    //bits in the shift register that carry the buttons for:
+    // left up center down right red
+    #define BL_LE 7
+    #define BL_UP 6
+    #define BL_MI 5
+    #define BL_DW 4
+    #define BL_RI 3
+    #define BL_ST 2
+
+    #define BLEN_B 1
+    #define BLEN_A 0
+  #endif 
+#endif //ULTRA_LCD
+
+#endif
+
+/****************************************************************************************
+* Teensylu 0.7 pin assingments (ATMEGA90USB)
+* Requires the Teensyduino software with Teensy2.0++ selected in arduino IDE!
+****************************************************************************************/
+#if MOTHERBOARD == 8
+#define MOTHERBOARD 8
+#define KNOWN_BOARD 1
+
+
+#define X_STEP_PIN          0  
+#define X_DIR_PIN           1  
+#define X_ENABLE_PIN       39 
+#define X_MIN_PIN          13 
+#define X_MAX_PIN          -1    
+
+#define Y_STEP_PIN          2  
+#define Y_DIR_PIN           3 
+#define Y_ENABLE_PIN       38 
+#define Y_MIN_PIN          14 
+#define Y_MAX_PIN          -1    
+
+#define Z_STEP_PIN          4
+#define Z_DIR_PIN           5 
+#define Z_ENABLE_PIN       23 
+#define Z_MIN_PIN          15 
+#define Z_MAX_PIN          -1    
+
+#define E0_STEP_PIN         6  
+#define E0_DIR_PIN          7 
+#define E0_ENABLE_PIN       19 
+
+
+
+#define HEATER_0_PIN       21  // Extruder
+#define HEATER_1_PIN       -1
+#define HEATER_2_PIN       -1
+#define HEATER_BED_PIN     20  // Bed
+#define FAN_PIN            22  // Fan   
+
+#define TEMP_0_PIN          7  // Extruder
+#define TEMP_1_PIN         -1
+#define TEMP_2_PIN         -1
+#define TEMP_BED_PIN        6  // Bed
+
+#define SDPOWER            -1
+#define SDSS                8
+#define LED_PIN            -1
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1 
+#define ALARM_PIN          -1
+
+#ifndef SDSUPPORT
+// these pins are defined in the SD library if building with SD support  
+  #define SCK_PIN           9 
+  #define MISO_PIN         11 
+  #define MOSI_PIN         10 
+#endif
+#endif
+
+#ifndef KNOWN_BOARD
+#error Unknown MOTHERBOARD value in configuration.h
+#endif
+
+//List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
+#define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN
+#if EXTRUDERS == 3
+  #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN
+  #define _E2_PINS E2_STEP_PIN, E2_DIR_PIN, E2_ENABLE_PIN
+#elif EXTRUDERS == 2
+  #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN
+  #define _E2_PINS -1
+#elif EXTRUDERS == 1
+  #define _E1_PINS -1 
+  #define _E2_PINS -1
+#else
+  #error Unsupported number of extruders
+#endif
+#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, LED_PIN, PS_ON_PIN, \
+                        HEATER_0_PIN, HEATER_1_PIN, HEATER_2_PIN, \
+                        HEATER_BED_PIN, FAN_PIN,                  \
+                        _E0_PINS, _E1_PINS, _E2_PINS,             \
+                        TEMP_0_PIN, TEMP_1_PIN, TEMP_2_PIN, TEMP_BED_PIN }
 #endif
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index df25544..1d66dad 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -56,9 +56,9 @@
 //#include <math.h>       
 //#include <stdlib.h>
 
-#include "Marlin.h"
 #include "Configuration.h"
 #include "pins.h"
+#include "Marlin.h"
 #include "fastio.h"
 #include "planner.h"
 #include "stepper.h"
@@ -81,8 +81,6 @@ float max_z_jerk;
 float mintravelfeedrate;
 unsigned long axis_steps_per_sqr_second[NUM_AXIS];
 
-uint8_t active_extruder = 0;
-
 // The current position of the tool in absolute steps
 long position[4];   //rescaled from extern when axis_steps_per_unit are changed by gcode
 static float previous_speed[4]; // Speed of previous path line segment
@@ -95,7 +93,6 @@ static float previous_nominal_speed; // Nominal speed of previous path line segm
     bool autotemp_enabled=false;
 #endif
 
-    
 //===========================================================================
 //=================semi-private variables, used in inline  functions    =====
 //===========================================================================
@@ -196,8 +193,8 @@ void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exi
   }
 
   #ifdef ADVANCE
-    long initial_advance = block->advance*entry_factor*entry_factor;
-    long final_advance = block->advance*exit_factor*exit_factor;
+    volatile long initial_advance = block->advance*entry_factor*entry_factor; 
+    volatile long final_advance = block->advance*exit_factor*exit_factor;
   #endif // ADVANCE
   
  // block->accelerate_until = accelerate_steps;
@@ -439,7 +436,7 @@ void check_axes_activity() {
   if((DISABLE_X) && (x_active == 0)) disable_x();
   if((DISABLE_Y) && (y_active == 0)) disable_y();
   if((DISABLE_Z) && (z_active == 0)) disable_z();
-  if((DISABLE_E) && (e_active == 0)) disable_e();
+  if((DISABLE_E) && (e_active == 0)) { disable_e0();disable_e1();disable_e2(); }
 }
 
 
@@ -514,15 +511,10 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   if(block->steps_x != 0) enable_x();
   if(block->steps_y != 0) enable_y();
   if(block->steps_z != 0) enable_z();
-  if(extruder == 0) {
-    if(block->steps_e != 0) enable_e();
-  }
-  #if (EXTRUDERS > 1)
-  if(extruder == 1) {
-    if(block->steps_e != 0) enable_e1();
-  }
-  #endif
-  
+
+  // Enable all
+  if(block->steps_e != 0) { enable_e0();enable_e1();enable_e2(); }
+
   float delta_mm[4];
   delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
   delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
@@ -809,4 +801,4 @@ void allow_cold_extrudes(bool allow)
   #ifdef PREVENT_DANGEROUS_EXTRUDE
     allow_cold_extrude=allow;
   #endif
-}
\ No newline at end of file
+}
diff --git a/Marlin/planner.h b/Marlin/planner.h
index b2d1c6c..82f5341 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -91,8 +91,6 @@ extern float max_z_jerk;
 extern float mintravelfeedrate;
 extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];
 
-extern uint8_t active_extruder;
-
 #ifdef AUTOTEMP
     extern bool autotemp_enabled;
     extern float autotemp_max;
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 51a9fe0..cffa25f 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -24,9 +24,9 @@
 
 #include "stepper.h"
 #include "Configuration.h"
+#include "pins.h"
 #include "Marlin.h"
 #include "planner.h"
-#include "pins.h"
 #include "fastio.h"
 #include "temperature.h"
 #include "ultralcd.h"
@@ -41,7 +41,6 @@
 block_t *current_block;  // A pointer to the block currently being traced
 
 
-
 //===========================================================================
 //=============================private variables ============================
 //===========================================================================
@@ -58,7 +57,7 @@ volatile static unsigned long step_events_completed; // The number of step event
   static long advance_rate, advance, final_advance = 0;
   static long old_advance = 0;
 #endif
-static long e_steps;
+static long e_steps[3];
 static unsigned char busy = false; // TRUE when SIG_OUTPUT_COMPARE1A is being serviced. Used to avoid retriggering that handler.
 static long acceleration_time, deceleration_time;
 //static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
@@ -267,7 +266,7 @@ FORCE_INLINE void trapezoid_generator_reset() {
     advance = current_block->initial_advance;
     final_advance = current_block->final_advance;
     // Do E steps + advance steps
-    e_steps += ((advance >>8) - old_advance);
+    e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
     old_advance = advance >>8;  
   #endif
   deceleration_time = 0;
@@ -304,8 +303,8 @@ ISR(TIMER1_COMPA_vect)
       counter_z = counter_x;
       counter_e = counter_x;
       step_events_completed = 0;
- //     #ifdef ADVANCE
-      e_steps = 0;
+//      #ifdef ADVANCE
+//      e_steps[current_block->active_extruder] = 0;
 //      #endif
     } 
     else {
@@ -419,11 +418,11 @@ ISR(TIMER1_COMPA_vect)
 
     #ifndef ADVANCE
       if ((out_bits & (1<<E_AXIS)) != 0) {  // -direction
-        WRITE(E_DIR_PIN,INVERT_E_DIR);
+        REV_E_DIR();
         count_direction[E_AXIS]=-1;
       }
       else { // +direction
-        WRITE(E_DIR_PIN,!INVERT_E_DIR);
+        NORM_E_DIR();
         count_direction[E_AXIS]=-1;
       }
     #endif //!ADVANCE
@@ -438,10 +437,10 @@ ISR(TIMER1_COMPA_vect)
       if (counter_e > 0) {
         counter_e -= current_block->step_event_count;
         if ((out_bits & (1<<E_AXIS)) != 0) { // - direction
-          e_steps--;
+          e_steps[current_block->active_extruder]--;
         }
         else {
-          e_steps++;
+          e_steps[current_block->active_extruder]++;
         }
       }    
       #endif //ADVANCE
@@ -473,9 +472,9 @@ ISR(TIMER1_COMPA_vect)
       #ifndef ADVANCE
         counter_e += current_block->steps_e;
         if (counter_e > 0) {
-          WRITE(E_STEP_PIN, HIGH);
+          WRITE_E_STEP(HIGH);
           counter_e -= current_block->step_event_count;
-          WRITE(E_STEP_PIN, LOW);
+          WRITE_E_STEP(LOW);
           count_position[E_AXIS]+=count_direction[E_AXIS];
         }
       #endif //!ADVANCE
@@ -504,7 +503,7 @@ ISR(TIMER1_COMPA_vect)
         }
         //if(advance > current_block->advance) advance = current_block->advance;
         // Do E steps + advance steps
-        e_steps += ((advance >>8) - old_advance);
+        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
         old_advance = advance >>8;  
         
       #endif
@@ -533,7 +532,7 @@ ISR(TIMER1_COMPA_vect)
         }
         if(advance < final_advance) advance = final_advance;
         // Do E steps + advance steps
-        e_steps += ((advance >>8) - old_advance);
+        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
         old_advance = advance >>8;  
       #endif //ADVANCE
     }
@@ -558,27 +557,57 @@ ISR(TIMER1_COMPA_vect)
     old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
     OCR0A = old_OCR0A;
     // Set E direction (Depends on E direction + advance)
-    for(unsigned char i=0; i<4;) {
-      WRITE(E_STEP_PIN, LOW);
-      if (e_steps == 0) break;
-      i++;
-      if (e_steps < 0) {
-        WRITE(E_DIR_PIN,INVERT_E_DIR);    
-        e_steps++;
-        WRITE(E_STEP_PIN, HIGH);
-      } 
-      else if (e_steps > 0) {
-        WRITE(E_DIR_PIN,!INVERT_E_DIR);
-        e_steps--;
-        WRITE(E_STEP_PIN, HIGH);
+    for(unsigned char i=0; i<4;i++) {
+      if (e_steps[0] != 0) {
+        WRITE(E0_STEP_PIN, LOW);
+        if (e_steps[0] < 0) {
+          WRITE(E0_DIR_PIN, INVERT_E0_DIR);
+          e_steps[0]++;
+          WRITE(E0_STEP_PIN, HIGH);
+        } 
+        else if (e_steps[0] > 0) {
+          WRITE(E0_DIR_PIN, !INVERT_E0_DIR);
+          e_steps[0]--;
+          WRITE(E0_STEP_PIN, HIGH);
+        }
+      }
+ #if EXTRUDERS > 1
+      if (e_steps[1] != 0) {
+        WRITE(E1_STEP_PIN, LOW);
+        if (e_steps[1] < 0) {
+          WRITE(E1_DIR_PIN, INVERT_E1_DIR);
+          e_steps[1]++;
+          WRITE(E1_STEP_PIN, HIGH);
+        } 
+        else if (e_steps[1] > 0) {
+          WRITE(E1_DIR_PIN, !INVERT_E1_DIR);
+          e_steps[1]--;
+          WRITE(E1_STEP_PIN, HIGH);
+        }
+      }
+ #endif
+ #if EXTRUDERS > 2
+      if (e_steps[2] != 0) {
+        WRITE(E2_STEP_PIN, LOW);
+        if (e_steps[2] < 0) {
+          WRITE(E2_DIR_PIN, INVERT_E2_DIR);
+          e_steps[2]++;
+          WRITE(E2_STEP_PIN, HIGH);
+        } 
+        else if (e_steps[2] > 0) {
+          WRITE(E2_DIR_PIN, !INVERT_E2_DIR);
+          e_steps[2]--;
+          WRITE(E2_STEP_PIN, HIGH);
+        }
       }
+ #endif
     }
   }
 #endif // ADVANCE
 
 void st_init()
 {
-    //Initialize Dir Pins
+  //Initialize Dir Pins
   #if X_DIR_PIN > -1
     SET_OUTPUT(X_DIR_PIN);
   #endif
@@ -588,8 +617,14 @@ void st_init()
   #if Z_DIR_PIN > -1 
     SET_OUTPUT(Z_DIR_PIN);
   #endif
-  #if E_DIR_PIN > -1 
-    SET_OUTPUT(E_DIR_PIN);
+  #if E0_DIR_PIN > -1 
+    SET_OUTPUT(E0_DIR_PIN);
+  #endif
+  #if defined(E1_DIR_PIN) && (E1_DIR_PIN > -1)
+    SET_OUTPUT(E1_DIR_PIN);
+  #endif
+  #if defined(E2_DIR_PIN) && (E2_DIR_PIN > -1)
+    SET_OUTPUT(E2_DIR_PIN);
   #endif
 
   //Initialize Enable Pins - steppers default to disabled.
@@ -606,9 +641,17 @@ void st_init()
     SET_OUTPUT(Z_ENABLE_PIN);
     if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
   #endif
-  #if (E_ENABLE_PIN > -1)
-    SET_OUTPUT(E_ENABLE_PIN);
-    if(!E_ENABLE_ON) WRITE(E_ENABLE_PIN,HIGH);
+  #if (E0_ENABLE_PIN > -1)
+    SET_OUTPUT(E0_ENABLE_PIN);
+    if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);
+  #endif
+  #if defined(E1_ENABLE_PIN) && (E1_ENABLE_PIN > -1)
+    SET_OUTPUT(E1_ENABLE_PIN);
+    if(!E_ENABLE_ON) WRITE(E1_ENABLE_PIN,HIGH);
+  #endif
+  #if defined(E2_ENABLE_PIN) && (E2_ENABLE_PIN > -1)
+    SET_OUTPUT(E2_ENABLE_PIN);
+    if(!E_ENABLE_ON) WRITE(E2_ENABLE_PIN,HIGH);
   #endif
 
   //endstops and pullups
@@ -669,8 +712,14 @@ void st_init()
   #if (Z_STEP_PIN > -1) 
     SET_OUTPUT(Z_STEP_PIN);
   #endif  
-  #if (E_STEP_PIN > -1) 
-    SET_OUTPUT(E_STEP_PIN);
+  #if (E0_STEP_PIN > -1) 
+    SET_OUTPUT(E0_STEP_PIN);
+  #endif  
+  #if defined(E1_STEP_PIN) && (E1_STEP_PIN > -1) 
+    SET_OUTPUT(E1_STEP_PIN);
+  #endif  
+  #if defined(E2_STEP_PIN) && (E2_STEP_PIN > -1) 
+    SET_OUTPUT(E2_STEP_PIN);
   #endif  
 
   // waveform generation = 0100 = CTC
@@ -693,7 +742,9 @@ void st_init()
     TCCR0A &= ~(1<<WGM01);
     TCCR0A &= ~(1<<WGM00);
   #endif  
-    e_steps = 0;
+    e_steps[0] = 0;
+    e_steps[1] = 0;
+    e_steps[2] = 0;
     TIMSK0 |= (1<<OCIE0A);
   #endif //ADVANCE
   
@@ -750,7 +801,9 @@ void finishAndDisableSteppers()
   disable_x(); 
   disable_y(); 
   disable_z(); 
-  disable_e(); 
+  disable_e0(); 
+  disable_e1(); 
+  disable_e2(); 
 }
 
 void quickStop()
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 37ce3b5..7671a65 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -23,6 +23,21 @@
 
 #include "planner.h"
 
+#if EXTRUDERS > 2
+  #define WRITE_E_STEP(v) { if(current_block->active_extruder == 2) { WRITE(E2_STEP_PIN, v); } else { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}}
+  #define NORM_E_DIR() { if(current_block->active_extruder == 2) { WRITE(!E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(!E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}
+  #define REV_E_DIR() { if(current_block->active_extruder == 2) { WRITE(E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}}
+#elif EXTRUDERS > 1
+  #define WRITE_E_STEP(v) { if(current_block->active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}
+  #define NORM_E_DIR() { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}
+  #define REV_E_DIR() { if(current_block->active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}
+#else
+  #define WRITE_E_STEP(v) WRITE(E0_STEP_PIN, v)
+  #define NORM_E_DIR() WRITE(E0_DIR_PIN, !INVERT_E0_DIR)
+  #define REV_E_DIR() WRITE(E0_DIR_PIN, INVERT_E0_DIR)
+#endif
+
+
 // Initialize and start the stepper motor subsystem
 void st_init();
 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 785da6c..ba116c7 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -26,7 +26,6 @@
  It has preliminary support for Matthew Roberts advance algorithm 
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
 
- This firmware is optimized for gen6 electronics.
  */
 #include <avr/pgmspace.h>
 
@@ -41,17 +40,14 @@
 //===========================================================================
 //=============================public variables============================
 //===========================================================================
-int target_raw[3] = {0, 0, 0};
-int current_raw[3] = {0, 0, 0};
-int heatingtarget_raw[3]= {0, 0, 0};
-
+int target_raw[EXTRUDERS] = { 0 };
+int target_raw_bed = 0;
+int current_raw[EXTRUDERS] = { 0 };
+int current_raw_bed = 0;
 
 #ifdef PIDTEMP
-  
-  // probably used external
-  float HeaterPower;
-  float pid_setpoint = 0.0;
-
+  // used external
+  float pid_setpoint[EXTRUDERS] = { 0.0 };
   
   float Kp=DEFAULT_Kp;
   float Ki=DEFAULT_Ki;
@@ -72,45 +68,83 @@ static unsigned long  previous_millis_bed_heater;
 
 #ifdef PIDTEMP
   //static cannot be external:
-  static float temp_iState = 0;
-  static float temp_dState = 0;
-  static float pTerm;
-  static float iTerm;
-  static float dTerm;
+  static float temp_iState[EXTRUDERS] = { 0 };
+  static float temp_dState[EXTRUDERS] = { 0 };
+  static float pTerm[EXTRUDERS];
+  static float iTerm[EXTRUDERS];
+  static float dTerm[EXTRUDERS];
   //int output;
-  static float pid_error;
-  static float temp_iState_min;
-  static float temp_iState_max;
- // static float pid_input; 
- // static float pid_output;
-  static bool pid_reset;
- 
+  static float pid_error[EXTRUDERS];
+  static float temp_iState_min[EXTRUDERS];
+  static float temp_iState_max[EXTRUDERS];
+  // static float pid_input[EXTRUDERS];
+  // static float pid_output[EXTRUDERS];
+  static bool pid_reset[EXTRUDERS];
 #endif //PIDTEMP
+  static unsigned char soft_pwm[EXTRUDERS];
   
 #ifdef WATCHPERIOD
+  static int watch_raw[EXTRUDERS] = { -1000 }; // the first value used for all
   static int watch_oldtemp[3] = {0,0,0};
   static unsigned long watchmillis = 0;
 #endif //WATCHPERIOD
 
 // Init min and max temp with extreme values to prevent false errors during startup
-  static int minttemp_0   = 0;
-  static int maxttemp_0   = 16383;
-  //static int minttemp_1   = 0;
-  //static int maxttemp_1   = 16383;
+  static int minttemp[EXTRUDERS] = { 0 };
+  static int maxttemp[EXTRUDERS] = { 16383 }; // the first value used for all
   static int bed_minttemp = 0;
   static int bed_maxttemp = 16383;
+  static int heater_pin_map[EXTRUDERS] = { HEATER_0_PIN
+#if EXTRUDERS > 1
+                                         , HEATER_1_PIN
+#endif
+#if EXTRUDERS > 2
+                                         , HEATER_2_PIN
+#endif
+#if EXTRUDERS > 3
+  #error Unsupported number of extruders
+#endif
+  };
+  static void *heater_ttbl_map[EXTRUDERS] = { (void *)heater_0_temptable
+#if EXTRUDERS > 1
+                                            , (void *)heater_1_temptable
+#endif
+#if EXTRUDERS > 2
+                                            , (void *)heater_2_temptable
+#endif
+#if EXTRUDERS > 3
+  #error Unsupported number of extruders
+#endif
+  };
+  static int heater_ttbllen_map[EXTRUDERS] = { heater_0_temptable_len
+#if EXTRUDERS > 1
+                                             , heater_1_temptable_len
+#endif
+#if EXTRUDERS > 2
+                                             , heater_2_temptable_len
+#endif
+#if EXTRUDERS > 3
+  #error Unsupported number of extruders
+#endif
+  };
 
 //===========================================================================
-//=============================functions         ============================
+//=============================   functions      ============================
 //===========================================================================
   
 void updatePID()
 {
 #ifdef PIDTEMP
-  temp_iState_max = PID_INTEGRAL_DRIVE_MAX / Ki;
+  for(int e = 0; e < EXTRUDERS; e++) { 
+     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  
+  }
 #endif
 }
   
+int getHeaterPower(int heater) {
+  return soft_pwm[heater];
+}
+
 void manage_heater()
 {
   #ifdef USE_WATCHDOG
@@ -119,73 +153,67 @@ void manage_heater()
   
   float pid_input;
   float pid_output;
+
   if(temp_meas_ready != true)   //better readability
     return; 
 
   CRITICAL_SECTION_START;
-    temp_meas_ready = false;
+  temp_meas_ready = false;
   CRITICAL_SECTION_END;
 
+  for(int e = 0; e < EXTRUDERS; e++) 
+  {
+
   #ifdef PIDTEMP
-    pid_input = analog2temp(current_raw[TEMPSENSOR_HOTEND_0]);
+    pid_input = analog2temp(current_raw[e], e);
 
     #ifndef PID_OPENLOOP
-        pid_error = pid_setpoint - pid_input;
-        if(pid_error > 10){
+        pid_error[e] = pid_setpoint[e] - pid_input;
+        if(pid_error[e] > 10) {
           pid_output = PID_MAX;
-          pid_reset = true;
+          pid_reset[e] = true;
         }
-        else if(pid_error < -10) {
+        else if(pid_error[e] < -10) {
           pid_output = 0;
-          pid_reset = true;
+          pid_reset[e] = true;
         }
         else {
-          if(pid_reset == true) {
-            temp_iState = 0.0;
-            pid_reset = false;
+          if(pid_reset[e] == true) {
+            temp_iState[e] = 0.0;
+            pid_reset[e] = false;
           }
-          pTerm = Kp * pid_error;
-          temp_iState += pid_error;
-          temp_iState = constrain(temp_iState, temp_iState_min, temp_iState_max);
-          iTerm = Ki * temp_iState;
+          pTerm[e] = Kp * pid_error[e];
+          temp_iState[e] += pid_error[e];
+          temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);
+          iTerm[e] = Ki * temp_iState[e];
           //K1 defined in Configuration.h in the PID settings
           #define K2 (1.0-K1)
-          dTerm = (Kd * (pid_input - temp_dState))*K2 + (K1 * dTerm);
-          temp_dState = pid_input;
-//          #ifdef PID_ADD_EXTRUSION_RATE
-//            pTerm+=Kc*current_block->speed_e; //additional heating if extrusion speed is high
-//          #endif
-          pid_output = constrain(pTerm + iTerm - dTerm, 0, PID_MAX);
-          
+          dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);
+          temp_dState[e] = pid_input;
+          pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);
         }
     #endif //PID_OPENLOOP
     #ifdef PID_DEBUG
-     //SERIAL_ECHOLN(" PIDDEBUG Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm<<" iTerm "<<iTerm<<" dTerm "<<dTerm);  
+    SERIAL_ECHOLN(" PIDDEBUG "<<e<<": Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm[e]<<" iTerm "<<iTerm[e]<<" dTerm "<<dTerm[e]);  
     #endif //PID_DEBUG
-    HeaterPower=pid_output;
-    // Check if temperature is within the correct range
-    if((current_raw[TEMPSENSOR_HOTEND_0] > minttemp_0) && (current_raw[TEMPSENSOR_HOTEND_0] < maxttemp_0)) {
-      analogWrite(HEATER_0_PIN, pid_output);
+  #else /* PID off */
+    pid_output = 0;
+    if(current_raw[e] < target_raw[e]) {
+      pid_output = PID_MAX;
     }
-    else {
-      analogWrite(HEATER_0_PIN, 0);
-    }
-  #endif //PIDTEMP
+  #endif
 
-  #ifndef PIDTEMP
     // Check if temperature is within the correct range
-    if((current_raw[TEMPSENSOR_HOTEND_0] > minttemp_0) && (current_raw[TEMPSENSOR_HOTEND_0] < maxttemp_0)) {
-      if(current_raw[TEMPSENSOR_HOTEND_0] >= target_raw[TEMPSENSOR_HOTEND_0]) {
-        WRITE(HEATER_0_PIN,LOW);
-      }
-      else {
-        WRITE(HEATER_0_PIN,HIGH);
-      }
+    if((current_raw[e] > minttemp[e]) && (current_raw[e] < maxttemp[e])) 
+    {
+      //analogWrite(heater_pin_map[e], pid_output);
+      soft_pwm[e] = (int)pid_output >> 1;
     }
     else {
-      WRITE(HEATER_0_PIN,LOW);
-    }    
-  #endif
+      //analogWrite(heater_pin_map[e], 0);
+      soft_pwm[e] = 0;
+    }
+  } // End extruder for loop
   
   #ifdef WATCHPERIOD
     if(watchmillis && millis() - watchmillis > WATCHPERIOD){
@@ -204,20 +232,20 @@ void manage_heater()
     return;
   previous_millis_bed_heater = millis();
   
-  #if TEMP_1_PIN > -1
+  #if TEMP_BED_PIN > -1
     // Check if temperature is within the correct range
-    if((current_raw[TEMPSENSOR_BED] > bed_minttemp) && (current_raw[TEMPSENSOR_BED] < bed_maxttemp)) {
-      if(current_raw[TEMPSENSOR_BED] >= target_raw[TEMPSENSOR_BED])
+    if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
+      if(current_raw_bed >= target_raw_bed)
       {
-        WRITE(HEATER_1_PIN,LOW);
+        WRITE(HEATER_BED_PIN,LOW);
       }
       else 
       {
-        WRITE(HEATER_1_PIN,HIGH);
+        WRITE(HEATER_BED_PIN,HIGH);
       }
     }
     else {
-      WRITE(HEATER_1_PIN,LOW);
+      WRITE(HEATER_BED_PIN,LOW);
     }  
   #endif
 }
@@ -227,30 +255,38 @@ void manage_heater()
 // For a thermistor, it uses the RepRap thermistor temp table.
 // This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
 // This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analog(int celsius) {
-  #ifdef HEATER_0_USES_THERMISTOR
+int temp2analog(int celsius, uint8_t e) {
+  if(e >= EXTRUDERS)
+  {
+      SERIAL_ERROR_START;
+      SERIAL_ERROR((int)e);
+      SERIAL_ERRORLNPGM(" - Invalid extruder number!");
+      kill();
+  }
+  if(heater_ttbl_map[e] != 0)
+  {
     int raw = 0;
     byte i;
+    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
 
-    for (i=1; i<NUMTEMPS_HEATER_0; i++)
+    for (i=1; i<heater_ttbllen_map[e]; i++)
     {
-      if (PGM_RD_W(heater_0_temptable[i][1]) < celsius)
+      if (PGM_RD_W((*tt)[i][1]) < celsius)
       {
-        raw = PGM_RD_W(heater_0_temptable[i-1][0]) + 
-          (celsius - PGM_RD_W(heater_0_temptable[i-1][1])) * 
-          (PGM_RD_W(heater_0_temptable[i][0]) - PGM_RD_W(heater_0_temptable[i-1][0])) /
-          (PGM_RD_W(heater_0_temptable[i][1]) - PGM_RD_W(heater_0_temptable[i-1][1]));  
+        raw = PGM_RD_W((*tt)[i-1][0]) + 
+          (celsius - PGM_RD_W((*tt)[i-1][1])) * 
+          (PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0])) /
+          (PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1]));  
         break;
       }
     }
 
     // Overflow: Set to last value in the table
-    if (i == NUMTEMPS_HEATER_0) raw = PGM_RD_W(heater_0_temptable[i-1][0]);
+    if (i == heater_ttbllen_map[e]) raw = PGM_RD_W((*tt)[i-1][0]);
 
     return (1023 * OVERSAMPLENR) - raw;
-  #elif defined HEATER_0_USES_AD595
-    return celsius * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
-  #endif
+  }
+  return celsius * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
 }
 
 // Takes bed temperature value as input and returns corresponding raw value. 
@@ -258,12 +294,11 @@ int temp2analog(int celsius) {
 // This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
 // This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
 int temp2analogBed(int celsius) {
-  #ifdef BED_USES_THERMISTOR
-
+#ifdef BED_USES_THERMISTOR
     int raw = 0;
     byte i;
     
-    for (i=1; i<BNUMTEMPS; i++)
+    for (i=1; i<bedtemptable_len; i++)
     {
       if (PGM_RD_W(bedtemptable[i][1]) < celsius)
       {
@@ -277,45 +312,52 @@ int temp2analogBed(int celsius) {
     }
 
     // Overflow: Set to last value in the table
-    if (i == BNUMTEMPS) raw = PGM_RD_W(bedtemptable[i-1][0]);
+    if (i == bedtemptable_len) raw = PGM_RD_W(bedtemptable[i-1][0]);
 
     return (1023 * OVERSAMPLENR) - raw;
-  #elif defined BED_USES_AD595
+#elif defined BED_USES_AD595
     return lround(celsius * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
-  #else
+#else
     #warning No heater-type defined for the bed.
-  #endif
-  return 0;
+    return 0;
+#endif
 }
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
-float analog2temp(int raw) {
-  #ifdef HEATER_0_USES_THERMISTOR
+float analog2temp(int raw, uint8_t e) {
+  if(e >= EXTRUDERS)
+  {
+      SERIAL_ERROR_START;
+      SERIAL_ERROR((int)e);
+      SERIAL_ERRORLNPGM(" - Invalid extruder number !");
+      kill();
+  }
+  if(heater_ttbl_map[e] != 0)
+  {
     float celsius = 0;
     byte i;  
+    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
+
     raw = (1023 * OVERSAMPLENR) - raw;
-    for (i=1; i<NUMTEMPS_HEATER_0; i++)
+    for (i=1; i<heater_ttbllen_map[e]; i++)
     {
-      if (PGM_RD_W(heater_0_temptable[i][0]) > raw)
+      if (PGM_RD_W((*tt)[i][0]) > raw)
       {
-        celsius  = PGM_RD_W(heater_0_temptable[i-1][1]) + 
-          (raw - PGM_RD_W(heater_0_temptable[i-1][0])) * 
-          (float)(PGM_RD_W(heater_0_temptable[i][1]) - PGM_RD_W(heater_0_temptable[i-1][1])) /
-          (float)(PGM_RD_W(heater_0_temptable[i][0]) - PGM_RD_W(heater_0_temptable[i-1][0]));
+        celsius = PGM_RD_W((*tt)[i-1][1]) + 
+          (raw - PGM_RD_W((*tt)[i-1][0])) * 
+          (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /
+          (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));
         break;
       }
     }
 
     // Overflow: Set to last value in the table
-    if (i == NUMTEMPS_HEATER_0) celsius = PGM_RD_W(heater_0_temptable[i-1][1]);
+    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);
 
     return celsius;
-  #elif defined HEATER_0_USES_AD595
-    return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
-  #else
-    #error PLEASE DEFINE HEATER TYPE 
-  #endif
+  }
+  return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
 }
 
 // Derived from RepRap FiveD extruder::getTemperature()
@@ -327,7 +369,7 @@ float analog2tempBed(int raw) {
 
     raw = (1023 * OVERSAMPLENR) - raw;
 
-    for (i=1; i<BNUMTEMPS; i++)
+    for (i=1; i<bedtemptable_len; i++)
     {
       if (PGM_RD_W(bedtemptable[i][0]) > raw)
       {
@@ -341,7 +383,7 @@ float analog2tempBed(int raw) {
     }
 
     // Overflow: Set to last value in the table
-    if (i == BNUMTEMPS) celsius = PGM_RD_W(bedtemptable[i-1][1]);
+    if (i == bedtemptable_len) celsius = PGM_RD_W(bedtemptable[i-1][1]);
 
     return celsius;
     
@@ -355,6 +397,19 @@ float analog2tempBed(int raw) {
 
 void tp_init()
 {
+  // Finish init of mult extruder arrays 
+  for(int e = 0; e < EXTRUDERS; e++) {
+    // populate with the first value 
+#ifdef WATCHPERIOD
+    watch_raw[e] = watch_raw[0];
+#endif
+    maxttemp[e] = maxttemp[0];
+#ifdef PIDTEMP
+    temp_iState_min[e] = 0.0;
+    temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;
+#endif //PIDTEMP
+  }
+
   #if (HEATER_0_PIN > -1) 
     SET_OUTPUT(HEATER_0_PIN);
   #endif  
@@ -364,11 +419,12 @@ void tp_init()
   #if (HEATER_2_PIN > -1) 
     SET_OUTPUT(HEATER_2_PIN);
   #endif  
-
-  #ifdef PIDTEMP
-    temp_iState_min = 0.0;
-    temp_iState_max = PID_INTEGRAL_DRIVE_MAX / Ki;
-  #endif //PIDTEMP
+  #if (HEATER_BED_PIN > -1) 
+    SET_OUTPUT(HEATER_BED_PIN);
+  #endif  
+  #if (FAN_PIN > -1) 
+    SET_OUTPUT(FAN_PIN);
+  #endif  
 
   // Set analog inputs
   ADCSRA = 1<<ADEN | 1<<ADSC | 1<<ADIF | 0x07;
@@ -381,7 +437,6 @@ void tp_init()
        DIDR0 |= 1 << TEMP_0_PIN; 
     #else
        DIDR2 |= 1<<(TEMP_0_PIN - 8); 
-       ADCSRB = 1<<MUX5;
     #endif
   #endif
   #if (TEMP_1_PIN > -1)
@@ -389,7 +444,6 @@ void tp_init()
        DIDR0 |= 1<<TEMP_1_PIN; 
     #else
        DIDR2 |= 1<<(TEMP_1_PIN - 8); 
-       ADCSRB = 1<<MUX5;
     #endif
   #endif
   #if (TEMP_2_PIN > -1)
@@ -397,7 +451,13 @@ void tp_init()
        DIDR0 |= 1 << TEMP_2_PIN; 
     #else
        DIDR2 = 1<<(TEMP_2_PIN - 8); 
-       ADCSRB = 1<<MUX5;
+    #endif
+  #endif
+  #if (TEMP_BED_PIN > -1)
+    #if TEMP_BED_PIN < 8
+       DIDR0 |= 1<<TEMP_BED_PIN; 
+    #else
+       DIDR2 |= 1<<(TEMP_BED_PIN - 8); 
     #endif
   #endif
   
@@ -407,27 +467,34 @@ void tp_init()
   TIMSK0 |= (1<<OCIE0B);  
   
   // Wait for temperature measurement to settle
-  delay(200);
+  delay(250);
 
 #ifdef HEATER_0_MINTEMP
-  minttemp_0 = temp2analog(HEATER_0_MINTEMP);
+  minttemp[0] = temp2analog(HEATER_0_MINTEMP, 0);
 #endif //MINTEMP
 #ifdef HEATER_0_MAXTEMP
-  maxttemp_0 = temp2analog(HEATER_0_MAXTEMP);
+  maxttemp[0] = temp2analog(HEATER_0_MAXTEMP, 0);
 #endif //MAXTEMP
 
-#ifdef HEATER_1_MINTEMP
-  minttemp_1 = temp2analog(HEATER_1_MINTEMP);
-#endif //MINTEMP
-#ifdef HEATER_1_MAXTEMP
-  maxttemp_1 = temp2analog(HEATER_1_MAXTEMP);
-#endif //MAXTEMP
+#if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
+  minttemp[1] = temp2analog(HEATER_1_MINTEMP, 1);
+#endif // MINTEMP 1
+#if (EXTRUDERS > 1) && defined(HEATER_1_MAXTEMP)
+  maxttemp[1] = temp2analog(HEATER_1_MAXTEMP, 1);
+#endif //MAXTEMP 1
+
+#if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
+  minttemp[2] = temp2analog(HEATER_2_MINTEMP, 2);
+#endif //MINTEMP 2
+#if (EXTRUDERS > 2) && defined(HEATER_2_MAXTEMP)
+  maxttemp[2] = temp2analog(HEATER_2_MAXTEMP, 2);
+#endif //MAXTEMP 2
 
 #ifdef BED_MINTEMP
-  bed_minttemp = temp2analog(BED_MINTEMP);
+  bed_minttemp = temp2analogBed(BED_MINTEMP);
 #endif //BED_MINTEMP
 #ifdef BED_MAXTEMP
-  bed_maxttemp = temp2analog(BED_MAXTEMP);
+  bed_maxttemp = temp2analogBed(BED_MAXTEMP);
 #endif //BED_MAXTEMP
 }
 
@@ -436,15 +503,17 @@ void tp_init()
 void setWatch() 
 {  
 #ifdef WATCHPERIOD
-  if(isHeatingHotend0())
+  int t = 0;
+  for (int e = 0; e < EXTRUDERS; e++)
   {
-    watchmillis = max(1,millis());
+    if(isHeatingHotend(e))
     watch_oldtemp[TEMPSENSOR_HOTEND_0] = degHotend(0);
+    {
+      t = max(t,millis());
+      watch_raw[e] = current_raw[e];
+    } 
   }
-  else
-  {
-    watchmillis = 0;
-  } 
+  watchmillis = t;
 #endif 
 }
 
@@ -453,6 +522,7 @@ void disable_heater()
 {
   #if TEMP_0_PIN > -1
   target_raw[0]=0;
+  soft_pwm[0]=0;
    #if HEATER_0_PIN > -1  
      digitalWrite(HEATER_0_PIN,LOW);
    #endif
@@ -460,6 +530,7 @@ void disable_heater()
      
   #if TEMP_1_PIN > -1
     target_raw[1]=0;
+    soft_pwm[1]=0;
     #if HEATER_1_PIN > -1 
       digitalWrite(HEATER_1_PIN,LOW);
     #endif
@@ -467,10 +538,38 @@ void disable_heater()
       
   #if TEMP_2_PIN > -1
     target_raw[2]=0;
+    soft_pwm[2]=0;
     #if HEATER_2_PIN > -1  
       digitalWrite(HEATER_2_PIN,LOW);
     #endif
   #endif 
+
+  #if TEMP_BED_PIN > -1
+    target_raw_bed=0;
+    #if HEATER_BED_PIN > -1  
+      digitalWrite(HEATER_BED_PIN,LOW);
+    #endif
+  #endif 
+}
+
+void max_temp_error(uint8_t e) {
+  digitalWrite(heater_pin_map[e], 0);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLN(e);
+  SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");
+}
+
+void min_temp_error(uint8_t e) {
+  digitalWrite(heater_pin_map[e], 0);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLN(e);
+  SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");
+}
+
+void bed_max_temp_error(void) {
+  digitalWrite(HEATER_BED_PIN, 0);
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
 }
 
 // Timer 0 is shared with millies
@@ -481,7 +580,35 @@ ISR(TIMER0_COMPB_vect)
   static unsigned long raw_temp_0_value = 0;
   static unsigned long raw_temp_1_value = 0;
   static unsigned long raw_temp_2_value = 0;
+  static unsigned long raw_temp_bed_value = 0;
   static unsigned char temp_state = 0;
+  static unsigned char pwm_count = 1;
+  static unsigned char soft_pwm_0;
+  static unsigned char soft_pwm_1;
+  static unsigned char soft_pwm_2;
+  
+  if(pwm_count == 0){
+    soft_pwm_0 = soft_pwm[0];
+    if(soft_pwm_0 > 0) WRITE(HEATER_0_PIN,1);
+    #if EXTRUDERS > 1
+    soft_pwm_1 = soft_pwm[1];
+    if(soft_pwm_1 > 0) WRITE(HEATER_1_PIN,1);
+    #endif
+    #if EXTRUDERS > 2
+    soft_pwm_2 = soft_pwm[2];
+    if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1);
+    #endif
+  }
+  if(soft_pwm_0 <= pwm_count) WRITE(HEATER_0_PIN,0);
+  #if EXTRUDERS > 1
+  if(soft_pwm_1 <= pwm_count) WRITE(HEATER_1_PIN,0);
+  #endif
+  #if EXTRUDERS > 2
+  if(soft_pwm_2 <= pwm_count) WRITE(HEATER_2_PIN,0);
+  #endif
+  
+  pwm_count++;
+  pwm_count &= 0x7f;
   
   switch(temp_state) {
     case 0: // Prepare TEMP_0
@@ -505,7 +632,26 @@ ISR(TIMER0_COMPB_vect)
       #endif
       temp_state = 2;
       break;
-    case 2: // Prepare TEMP_1
+    case 2: // Prepare TEMP_BED
+      #if (TEMP_BED_PIN > -1)
+        #if TEMP_BED_PIN > 7
+          ADCSRB = 1<<MUX5;
+        #endif
+        ADMUX = ((1 << REFS0) | (TEMP_BED_PIN & 0x07));
+        ADCSRA |= 1<<ADSC; // Start conversion
+      #endif
+      #ifdef ULTIPANEL
+        buttons_check();
+      #endif
+      temp_state = 3;
+      break;
+    case 3: // Measure TEMP_BED
+      #if (TEMP_BED_PIN > -1)
+        raw_temp_bed_value += ADC;
+      #endif
+      temp_state = 4;
+      break;
+    case 4: // Prepare TEMP_1
       #if (TEMP_1_PIN > -1)
         #if TEMP_1_PIN > 7
           ADCSRB = 1<<MUX5;
@@ -518,15 +664,15 @@ ISR(TIMER0_COMPB_vect)
       #ifdef ULTIPANEL
         buttons_check();
       #endif
-      temp_state = 3;
+      temp_state = 5;
       break;
-    case 3: // Measure TEMP_1
+    case 5: // Measure TEMP_1
       #if (TEMP_1_PIN > -1)
         raw_temp_1_value += ADC;
       #endif
-      temp_state = 4;
+      temp_state = 6;
       break;
-    case 4: // Prepare TEMP_2
+    case 6: // Prepare TEMP_2
       #if (TEMP_2_PIN > -1)
         #if TEMP_2_PIN > 7
           ADCSRB = 1<<MUX5;
@@ -539,39 +685,49 @@ ISR(TIMER0_COMPB_vect)
       #ifdef ULTIPANEL
         buttons_check();
       #endif
-      temp_state = 5;
+      temp_state = 7;
       break;
-    case 5: // Measure TEMP_2
+    case 7: // Measure TEMP_2
       #if (TEMP_2_PIN > -1)
         raw_temp_2_value += ADC;
       #endif
       temp_state = 0;
       temp_count++;
       break;
-    default:
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("Temp measurement error!");
-      break;
+//    default:
+//      SERIAL_ERROR_START;
+//      SERIAL_ERRORLNPGM("Temp measurement error!");
+//      break;
   }
     
-  if(temp_count >= 16) // 6 ms * 16 = 96ms.
+  if(temp_count >= 16) // 8 ms * 16 = 128ms.
   {
     #ifdef HEATER_0_USES_AD595
       current_raw[0] = raw_temp_0_value;
     #else
       current_raw[0] = 16383 - raw_temp_0_value;
     #endif
-    
+
+#if EXTRUDERS > 1    
     #ifdef HEATER_1_USES_AD595
+      current_raw[1] = raw_temp_1_value;
+    #else
+      current_raw[1] = 16383 - raw_temp_1_value;
+    #endif
+#endif
+    
+#if EXTRUDERS > 2
+    #ifdef HEATER_2_USES_AD595
       current_raw[2] = raw_temp_2_value;
     #else
       current_raw[2] = 16383 - raw_temp_2_value;
     #endif
+#endif
     
     #ifdef BED_USES_AD595
-      current_raw[1] = raw_temp_1_value;
+      current_raw_bed = raw_temp_bed_value;
     #else
-      current_raw[1] = 16383 - raw_temp_1_value;
+      current_raw_bed = 16383 - raw_temp_bed_value;
     #endif
     
     temp_meas_ready = true;
@@ -579,77 +735,28 @@ ISR(TIMER0_COMPB_vect)
     raw_temp_0_value = 0;
     raw_temp_1_value = 0;
     raw_temp_2_value = 0;
-    #ifdef HEATER_0_MAXTEMP
-      #if (HEATER_0_PIN > -1)
-        if(current_raw[TEMPSENSOR_HOTEND_0] >= maxttemp_0) {
-          target_raw[TEMPSENSOR_HOTEND_0] = 0;
-          digitalWrite(HEATER_0_PIN, 0);
-          SERIAL_ERROR_START;
-          SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MAXTEMP triggered !!");
+    raw_temp_bed_value = 0;
+
+    for(unsigned char e = 0; e < EXTRUDERS; e++) {
+       if(current_raw[e] >= maxttemp[e]) {
+          target_raw[e] = 0;
+          max_temp_error(e);
+          kill();;
+       }
+       if(current_raw[e] <= minttemp[e]) {
+          target_raw[e] = 0;
+          min_temp_error(e);
           kill();
-        }
-      #endif
-    #endif
-  #ifdef HEATER_1_MAXTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_1] >= maxttemp_1) {
-        target_raw[TEMPSENSOR_HOTEND_1] = 0;
-        digitalWrite(HEATER_2_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MAXTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif //MAXTEMP
-  
-  #ifdef HEATER_0_MINTEMP
-    #if (HEATER_0_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_0] <= minttemp_0) {
-        target_raw[TEMPSENSOR_HOTEND_0] = 0;
-        digitalWrite(HEATER_0_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
-  
-  #ifdef HEATER_1_MINTEMP
-    #if (HEATER_2_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_1] <= minttemp_1) {
-        target_raw[TEMPSENSOR_HOTEND_1] = 0;
-        digitalWrite(HEATER_2_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif //MAXTEMP
-  
-  #ifdef BED_MINTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[1] <= bed_minttemp) {
-        target_raw[1] = 0;
-        digitalWrite(HEATER_1_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperatur heated bed switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
+       }
+    }
   
-  #ifdef BED_MAXTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[1] >= bed_maxttemp) {
-        target_raw[1] = 0;
-        digitalWrite(HEATER_1_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
+#if defined(BED_MAXTEMP) && (HEATER_BED_PIN > -1)
+    if(current_raw_bed >= bed_maxttemp) {
+       target_raw_bed = 0;
+       bed_max_temp_error();
+       kill();
+    }
+#endif
   }
 }
 
-
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 2580947..f8b0964 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -32,95 +32,111 @@
 void tp_init();  //initialise the heating
 void manage_heater(); //it is critical that this is called periodically.
 
-
-enum TempSensor {TEMPSENSOR_HOTEND_0=0,TEMPSENSOR_BED=1, TEMPSENSOR_HOTEND_1=2};
-
 //low leven conversion routines
 // do not use this routines and variables outsie of temperature.cpp
-int temp2analog(int celsius);
+int temp2analog(int celsius, uint8_t e);
 int temp2analogBed(int celsius);
-float analog2temp(int raw);
+float analog2temp(int raw, uint8_t e);
 float analog2tempBed(int raw);
-extern int target_raw[3];  
-extern int heatingtarget_raw[3];
-extern int current_raw[3];
+extern int target_raw[EXTRUDERS];  
+extern int heatingtarget_raw[EXTRUDERS];  
+extern int current_raw[EXTRUDERS];
+extern int target_raw_bed;
+extern int current_raw_bed;
 extern float Kp,Ki,Kd,Kc;
 
 #ifdef PIDTEMP
-  extern float pid_setpoint ;
+  extern float pid_setpoint[EXTRUDERS];
 #endif
   
 // #ifdef WATCHPERIOD
-//   extern int watch_raw[3] ;
+  extern int watch_raw[EXTRUDERS] ;
 //   extern unsigned long watchmillis;
 // #endif
 
 
-
 //high level conversion routines, for use outside of temperature.cpp
 //inline so that there is no performance decrease.
 //deg=degreeCelsius
 
-FORCE_INLINE float degHotend0(){  return analog2temp(current_raw[TEMPSENSOR_HOTEND_0]);};
-FORCE_INLINE float degHotend1(){  return analog2temp(current_raw[TEMPSENSOR_HOTEND_1]);};
-FORCE_INLINE float degBed() {  return analog2tempBed(current_raw[TEMPSENSOR_BED]);};
-FORCE_INLINE float degHotend(uint8_t extruder){  
-  if(extruder == 0) return analog2temp(current_raw[TEMPSENSOR_HOTEND_0]);
-  if(extruder == 1) return analog2temp(current_raw[TEMPSENSOR_HOTEND_1]);
+FORCE_INLINE float degHotend(uint8_t extruder) {  
+  return analog2temp(current_raw[extruder], extruder);
 };
 
-FORCE_INLINE float degTargetHotend0() {  return analog2temp(target_raw[TEMPSENSOR_HOTEND_0]);};
-FORCE_INLINE float degTargetHotend1() {  return analog2temp(target_raw[TEMPSENSOR_HOTEND_1]);};
-FORCE_INLINE float degTargetHotend(uint8_t extruder){  
-  if(extruder == 0) return analog2temp(target_raw[TEMPSENSOR_HOTEND_0]);
-  if(extruder == 1) return analog2temp(target_raw[TEMPSENSOR_HOTEND_1]);
+FORCE_INLINE float degBed() {
+  return analog2tempBed(current_raw_bed);
 };
 
-FORCE_INLINE float degTargetBed() {   return analog2tempBed(target_raw[TEMPSENSOR_BED]);};
+FORCE_INLINE float degTargetHotend(uint8_t extruder) {  
+  return analog2temp(target_raw[extruder], extruder);
+};
 
-FORCE_INLINE void setTargetHotend0(const float &celsius) 
-{  
-  target_raw[TEMPSENSOR_HOTEND_0]=temp2analog(celsius);
-  heatingtarget_raw[TEMPSENSOR_HOTEND_0]=temp2analog(celsius-HEATING_EARLY_FINISH_DEG_OFFSET);
-  #ifdef PIDTEMP
-    pid_setpoint = celsius;
-  #endif //PIDTEMP
+FORCE_INLINE float degTargetBed() {   
+  return analog2tempBed(target_raw_bed);
 };
-FORCE_INLINE void setTargetHotend1(const float &celsius) {  target_raw[TEMPSENSOR_HOTEND_1]=temp2analog(celsius);};
-FORCE_INLINE void setTargetHotend(const float &celcius, uint8_t extruder){  
-  if(extruder == 0) setTargetHotend0(celcius);
-  if(extruder == 1) setTargetHotend1(celcius);
+
+FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  
+  target_raw[extruder] = temp2analog(celsius, extruder);
+#ifdef PIDTEMP
+  pid_setpoint[extruder] = celsius;
+#endif //PIDTEMP
+};
+
+FORCE_INLINE void setTargetBed(const float &celsius) {  
+  target_raw_bed = temp2analogBed(celsius);
 };
-FORCE_INLINE void setTargetBed(const float &celsius)     {  target_raw[TEMPSENSOR_BED     ]=temp2analogBed(celsius);};
 
-FORCE_INLINE bool isHeatingHotend0() {return heatingtarget_raw[TEMPSENSOR_HOTEND_0] > current_raw[TEMPSENSOR_HOTEND_0];};
-FORCE_INLINE bool isHeatingHotend1() {return target_raw[TEMPSENSOR_HOTEND_1] > current_raw[TEMPSENSOR_HOTEND_1];};
 FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  
-  if(extruder == 0) return heatingtarget_raw[TEMPSENSOR_HOTEND_0] > current_raw[TEMPSENSOR_HOTEND_0];
-  if(extruder == 1) return target_raw[TEMPSENSOR_HOTEND_1] > current_raw[TEMPSENSOR_HOTEND_1];
-  return false; 
+  return target_raw[extruder] > current_raw[extruder];
+};
+
+FORCE_INLINE bool isHeatingBed() {
+  return target_raw_bed > current_raw_bed;
 };
-FORCE_INLINE bool isHeatingBed() {return target_raw[TEMPSENSOR_BED] > current_raw[TEMPSENSOR_BED];};
-
-FORCE_INLINE bool isCoolingHotend0() {return target_raw[TEMPSENSOR_HOTEND_0] < current_raw[TEMPSENSOR_HOTEND_0];};
-FORCE_INLINE bool isCoolingHotend1() {return target_raw[TEMPSENSOR_HOTEND_1] < current_raw[TEMPSENSOR_HOTEND_1];};
-FORCE_INLINE bool isCoolingHotend(uint8_t extruder){  
-  if(extruder == 0) return target_raw[TEMPSENSOR_HOTEND_0] < current_raw[TEMPSENSOR_HOTEND_0];
-  if(extruder == 1) return target_raw[TEMPSENSOR_HOTEND_1] < current_raw[TEMPSENSOR_HOTEND_1];
-  return false; 
+
+FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  
+  return target_raw[extruder] < current_raw[extruder];
 };
-FORCE_INLINE bool isCoolingBed() {return target_raw[TEMPSENSOR_BED] < current_raw[TEMPSENSOR_BED];};
+
+FORCE_INLINE bool isCoolingBed() {
+  return target_raw_bed < current_raw_bed;
+};
+
+#define degHotend0() degHotend(0)
+#define degTargetHotend0() degTargetHotend(0)
+#define setTargetHotend0(_celsius) setTargetHotend((_celsius), 0)
+#define isHeatingHotend0() isHeatingHotend(0)
+#define isCoolingHotend0() isCoolingHotend(0)
+#if EXTRUDERS > 1
+#define degHotend1() degHotend(1)
+#define degTargetHotend1() degTargetHotend(1)
+#define setTargetHotend1(_celsius) setTargetHotend((_celsius), 1)
+#define isHeatingHotend1() isHeatingHotend(1)
+#define isCoolingHotend1() isCoolingHotend(1)
+#endif
+#if EXTRUDERS > 2
+#define degHotend2() degHotend(2)
+#define degTargetHotend2() degTargetHotend(2)
+#define setTargetHotend2(_celsius) setTargetHotend((_celsius), 2)
+#define isHeatingHotend2() isHeatingHotend(2)
+#define isCoolingHotend2() isCoolingHotend(2)
+#endif
+#if EXTRUDERS > 3
+#error Invalid number of extruders
+#endif
 
 FORCE_INLINE void autotempShutdown(){
  #ifdef AUTOTEMP
  if(autotemp_enabled)
  {
   autotemp_enabled=false;
-  if(degTargetHotend0()>autotemp_min)
-    setTargetHotend0(0);
+  if(degTargetHotend(ACTIVE_EXTRUDER)>autotemp_min)
+    setTargetHotend(0,ACTIVE_EXTRUDER);
  }
  #endif
 }
+
+int getHeaterPower(int heater);
 void disable_heater();
 void setWatch();
 void updatePID();
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 22d9f02..30f5b62 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -5,10 +5,9 @@
 
 #define OVERSAMPLENR 16
 
-#if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1) || (THERMISTORBED == 1) //100k bed thermistor
+#if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1)  || (THERMISTORHEATER_2 == 1) || (THERMISTORBED == 1) //100k bed thermistor
 
-#define NUMTEMPS_1 61
-const short temptable_1[NUMTEMPS_1][2] PROGMEM = {
+const short temptable_1[][2] PROGMEM = {
 {       23*OVERSAMPLENR ,       300     },
 {       25*OVERSAMPLENR ,       295     },
 {       27*OVERSAMPLENR ,       290     },
@@ -72,9 +71,8 @@ const short temptable_1[NUMTEMPS_1][2] PROGMEM = {
 {       1008*OVERSAMPLENR       ,       0       } //safety
 };
 #endif
-#if (THERMISTORHEATER_0 == 2) || (THERMISTORHEATER_1 == 2) || (THERMISTORBED == 2) //200k bed thermistor
-#define NUMTEMPS_2 21
-const short temptable_2[NUMTEMPS_2][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 2) || (THERMISTORHEATER_1 == 2) || (THERMISTORHEATER_2 == 2) || (THERMISTORBED == 2) //200k bed thermistor
+const short temptable_2[][2] PROGMEM = {
    {1*OVERSAMPLENR, 848},
    {54*OVERSAMPLENR, 275},
    {107*OVERSAMPLENR, 228},
@@ -99,9 +97,8 @@ const short temptable_2[NUMTEMPS_2][2] PROGMEM = {
 };
 
 #endif
-#if (THERMISTORHEATER_0 == 3) || (THERMISTORHEATER_1 == 3) || (THERMISTORBED == 3) //mendel-parts
-#define NUMTEMPS_3 28
-const short temptable_3[NUMTEMPS_3][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 3) || (THERMISTORHEATER_1 == 3) || (THERMISTORHEATER_2 == 3) || (THERMISTORBED == 3) //mendel-parts
+const short temptable_3[][2] PROGMEM = {
                 {1*OVERSAMPLENR,864},
                 {21*OVERSAMPLENR,300},
                 {25*OVERSAMPLENR,290},
@@ -133,10 +130,8 @@ const short temptable_3[NUMTEMPS_3][2] PROGMEM = {
         };
 
 #endif
-#if (THERMISTORHEATER_0 == 4) || (THERMISTORHEATER_1 == 4) || (THERMISTORBED == 4) //10k thermistor
-
-#define NUMTEMPS_4 20
-const short temptable_4[NUMTEMPS_4][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 4) || (THERMISTORHEATER_1 == 4) || (THERMISTORHEATER_2 == 4) || (THERMISTORBED == 4) //10k thermistor
+const short temptable_4[][2] PROGMEM = {
    {1*OVERSAMPLENR, 430},
    {54*OVERSAMPLENR, 137},
    {107*OVERSAMPLENR, 107},
@@ -160,10 +155,8 @@ const short temptable_4[NUMTEMPS_4][2] PROGMEM = {
 };
 #endif
 
-#if (THERMISTORHEATER_0 == 5) || (THERMISTORHEATER_1 == 5) || (THERMISTORBED == 5) //100k ParCan thermistor (104GT-2)
-
-#define NUMTEMPS_5 61
-const short temptable_5[NUMTEMPS_5][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 5) || (THERMISTORHEATER_1 == 5) || (THERMISTORHEATER_2 == 5) || (THERMISTORBED == 5) //100k ParCan thermistor (104GT-2)
+const short temptable_5[][2] PROGMEM = {
 {1*OVERSAMPLENR, 713},
 {18*OVERSAMPLENR, 316},
 {35*OVERSAMPLENR, 266},
@@ -228,9 +221,8 @@ const short temptable_5[NUMTEMPS_5][2] PROGMEM = {
 };
 #endif
 
-#if (THERMISTORHEATER_0 == 6) || (THERMISTORHEATER_1 == 6) || (THERMISTORBED == 6) // 100k Epcos thermistor
-#define NUMTEMPS_6 36
-const short temptable_6[NUMTEMPS_6][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 6) || (THERMISTORHEATER_1 == 6) || (THERMISTORHEATER_2 == 6) || (THERMISTORBED == 6) // 100k Epcos thermistor
+const short temptable_6[][2] PROGMEM = {
    {28*OVERSAMPLENR, 250},
    {31*OVERSAMPLENR, 245},
    {35*OVERSAMPLENR, 240},
@@ -270,9 +262,8 @@ const short temptable_6[NUMTEMPS_6][2] PROGMEM = {
 };
 #endif
 
-#if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01
-#define NUMTEMPS_7 54
-const short temptable_7[NUMTEMPS_7][2] PROGMEM = {
+#if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORHEATER_2 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01
+const short temptable_7[][2] PROGMEM = {
    {46*OVERSAMPLENR, 270},
    {50*OVERSAMPLENR, 265},
    {54*OVERSAMPLENR, 260},
@@ -330,82 +321,52 @@ const short temptable_7[NUMTEMPS_7][2] PROGMEM = {
 };
 #endif
 
+#define _TT_NAME(_N) temptable_ ## _N
+#define TT_NAME(_N) _TT_NAME(_N)
 
-
-#if THERMISTORHEATER_0 == 1
-#define NUMTEMPS_HEATER_0 NUMTEMPS_1
-#define heater_0_temptable temptable_1
-#elif THERMISTORHEATER_0 == 2
-#define NUMTEMPS_HEATER_0 NUMTEMPS_2
-#define heater_0_temptable temptable_2
-#elif THERMISTORHEATER_0 == 3
-#define NUMTEMPS_HEATER_0 NUMTEMPS_3
-#define heater_0_temptable temptable_3
-#elif THERMISTORHEATER_0 == 4
-#define NUMTEMPS_HEATER_0 NUMTEMPS_4
-#define heater_0_temptable temptable_4
-#elif THERMISTORHEATER_0 == 5
-#define NUMTEMPS_HEATER_0 NUMTEMPS_5
-#define heater_0_temptable temptable_5
-#elif THERMISTORHEATER_0 == 6
-#define NUMTEMPS_HEATER_0 NUMTEMPS_6
-#define heater_0_temptable temptable_6
-#elif THERMISTORHEATER_0 == 7
-#define NUMTEMPS_HEATER_0 NUMTEMPS_7
-#define heater_0_temptable temptable_7
-#elif defined HEATER_0_USES_THERMISTOR
-#error No heater 0 thermistor table specified
+#ifdef THERMISTORHEATER_0
+  #define heater_0_temptable TT_NAME(THERMISTORHEATER_0)
+  #define heater_0_temptable_len (sizeof(heater_0_temptable)/sizeof(*heater_0_temptable))
+#else
+#ifdef HEATER_0_USES_THERMISTOR
+  #error No heater 0 thermistor table specified
+#else  // HEATER_0_USES_THERMISTOR
+  #define heater_0_temptable 0
+  #define heater_0_temptable_len 0
+#endif // HEATER_0_USES_THERMISTOR
 #endif
 
-#if THERMISTORHEATER_1 == 1
-#define NUMTEMPS_HEATER_1 NUMTEMPS_1
-#define heater_1_temptable temptable_1
-#elif THERMISTORHEATER_1 == 2
-#define NUMTEMPS_HEATER_1 NUMTEMPS_2
-#define heater_1_temptable temptable_2
-#elif THERMISTORHEATER_1 == 3
-#define NUMTEMPS_HEATER_1 NUMTEMPS_3
-#define heater_1_temptable temptable_3
-#elif THERMISTORHEATER_1 == 4
-#define NUMTEMPS_HEATER_1 NUMTEMPS_4
-#define heater_1_temptable temptable_4
-#elif THERMISTORHEATER_1 == 5
-#define NUMTEMPS_HEATER_1 NUMTEMPS_5
-#define heater_1_temptable temptable_5
-#elif THERMISTORHEATER_1 == 6
-#define NUMTEMPS_HEATER_1 NUMTEMPS_6
-#define heater_1_temptable temptable_6
-#elif THERMISTORHEATER_1 == 7
-#define NUMTEMPS_HEATER_1 NUMTEMPS_7
-#define heater_1_temptable temptable_7
-#elif defined HEATER_1_USES_THERMISTOR
-#error No heater 1 thermistor table specified
+#ifdef THERMISTORHEATER_1
+  #define heater_1_temptable TT_NAME(THERMISTORHEATER_1)
+  #define heater_1_temptable_len (sizeof(heater_1_temptable)/sizeof(*heater_1_temptable))
+#else
+#ifdef HEATER_1_USES_THERMISTOR
+  #error No heater 1 thermistor table specified
+#else  // HEATER_1_USES_THERMISTOR
+  #define heater_1_temptable 0
+  #define heater_1_temptable_len 0
+#endif // HEATER_1_USES_THERMISTOR
 #endif
 
+#ifdef THERMISTORHEATER_2
+  #define heater_2_temptable TT_NAME(THERMISTORHEATER_2)
+  #define heater_2_temptable_len (sizeof(heater_2_temptable)/sizeof(*heater_2_temptable))
+#else
+#ifdef HEATER_2_USES_THERMISTOR
+  #error No heater 2 thermistor table specified
+#else  // HEATER_2_USES_THERMISTOR
+  #define heater_2_temptable 0
+  #define heater_2_temptable_len 0
+#endif // HEATER_2_USES_THERMISTOR
+#endif
 
-#if THERMISTORBED == 1
-#define BNUMTEMPS NUMTEMPS_1
-#define bedtemptable temptable_1
-#elif THERMISTORBED == 2
-#define BNUMTEMPS NUMTEMPS_2
-#define bedtemptable temptable_2
-#elif THERMISTORBED == 3
-#define BNUMTEMPS NUMTEMPS_3
-#define bedtemptable temptable_3
-#elif THERMISTORBED == 4
-#define BNUMTEMPS NUMTEMPS_4
-#define bedtemptable temptable_4
-#elif THERMISTORBED == 5
-#define BNUMTEMPS NUMTEMPS_5
-#define bedtemptable temptable_5
-#elif THERMISTORBED == 6
-#define BNUMTEMPS NUMTEMPS_6
-#define bedtemptable temptable_6
-#elif THERMISTORBED == 7
-#define BNUMTEMPS NUMTEMPS_7
-#define bedtemptable temptable_7
-#elif defined BED_USES_THERMISTOR
-#error No bed thermistor table specified
+#ifdef THERMISTORBED
+  #define bedtemptable TT_NAME(THERMISTORBED)
+  #define bedtemptable_len (sizeof(bedtemptable)/sizeof(*bedtemptable))
+#else
+#ifdef BED_USES_THERMISTOR
+  #error No bed thermistor table specified
+#endif // BED_USES_THERMISTOR
 #endif
 
 #endif //THERMISTORTABLES_H_
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index e89474e..3b7663b 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -1,1844 +1,1848 @@
-#include "ultralcd.h"
-#ifdef ULTRA_LCD
-
-//===========================================================================
-//=============================imported variables============================
-//===========================================================================
-
-extern volatile int feedmultiply;
-extern volatile bool feedmultiplychanged;
-
-extern long position[4];   
-extern CardReader card;
-
-//===========================================================================
-//=============================public variables============================
-//===========================================================================
-volatile char buttons=0;  //the last checked buttons in a bit array.
-int encoderpos=0;
-short lastenc=0;
-
-
-//===========================================================================
-//=============================private  variables============================
-//===========================================================================
-static char messagetext[LCD_WIDTH]="";
-
-//return for string conversion routines
-static char conv[8];
-
-#include <LiquidCrystal.h>
-LiquidCrystal lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7 
-
-static unsigned long previous_millis_lcd=0;
-static long previous_millis_buttons=0;
-
-
-#ifdef NEWPANEL
- static long blocking=0;
-#else
- static long blocking[8]={0,0,0,0,0,0,0,0};
-#endif
- 
-static MainMenu menu;
-
-#include <avr/pgmspace.h>
-
-void lcdProgMemprint(const char *str)
-{
-  char ch=pgm_read_byte(str);
-  while(ch)
-  {
-    lcd.print(ch);
-    ch=pgm_read_byte(++str);
-  }
-}
-#define lcdprintPGM(x) lcdProgMemprint(MYPGM(x))
-
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-
-FORCE_INLINE int intround(const float &x){return int(0.5+x);}
-
-void lcd_status(const char* message)
-{
-  strncpy(messagetext,message,LCD_WIDTH);
-  messagetext[strlen(message)]=0;
-}
-
-void lcd_statuspgm(const char* message)
-{
-  char ch=pgm_read_byte(message);
-  char *target=messagetext;
-  uint8_t cnt=0;
-  while(ch &&cnt<LCD_WIDTH)
-  {
-    *target=ch;
-    target++;
-    cnt++;
-    ch=pgm_read_byte(++message);
-  }
-  *target=0;
-}
-
-FORCE_INLINE void clear()
-{
-  lcd.clear();
-}
-
-
-void lcd_init()
-{
-  //beep();
-  byte Degree[8] =
-  {
-    B01100,
-    B10010,
-    B10010,
-    B01100,
-    B00000,
-    B00000,
-    B00000,
-    B00000
-  };
-  byte Thermometer[8] =
-  {
-    B00100,
-    B01010,
-    B01010,
-    B01010,
-    B01010,
-    B10001,
-    B10001,
-    B01110
-  };
-  byte uplevel[8]={0x04, 0x0e, 0x1f, 0x04, 0x1c, 0x00, 0x00, 0x00};//thanks joris
-  byte refresh[8]={0x00, 0x06, 0x19, 0x18, 0x03, 0x13, 0x0c, 0x00}; //thanks joris
-  byte folder [8]={0x00, 0x1c, 0x1f, 0x11, 0x11, 0x1f, 0x00, 0x00}; //thanks joris
-  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-  lcd.createChar(1,Degree);
-  lcd.createChar(2,Thermometer);
-  lcd.createChar(3,uplevel);
-  lcd.createChar(4,refresh);
-  lcd.createChar(5,folder);
-  LCD_MESSAGEPGM("UltiMarlin ready.");
-}
-
-
-void beep()
-{
-  //return;
-  #ifdef ULTIPANEL
-    pinMode(BEEPER,OUTPUT);
-    for(int8_t i=0;i<20;i++){
-      WRITE(BEEPER,HIGH);
-      delay(5);
-      WRITE(BEEPER,LOW);
-      delay(5);
-    }
-  #endif
-}
-
-void beepshort()
-{
-  //return;
-  #ifdef ULTIPANEL
-    pinMode(BEEPER,OUTPUT);
-    for(int8_t i=0;i<10;i++){
-      WRITE(BEEPER,HIGH);
-      delay(3);
-      WRITE(BEEPER,LOW);
-      delay(3);
-    }
-  #endif  
-}
-
-void lcd_status()
-{
-  #ifdef ULTIPANEL
-    static uint8_t oldbuttons=0;
-    //static long previous_millis_buttons=0;
-    //static long previous_lcdinit=0;
-  //  buttons_check(); // Done in temperature interrupt
-    //previous_millis_buttons=millis();
-    
-    if((buttons==oldbuttons) &&  ((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-    oldbuttons=buttons;
-  #else
-  
-    if(((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
-      return;
-  #endif
-    
-  previous_millis_lcd=millis();
-  menu.update();
-}
-#ifdef ULTIPANEL  
-
-
-void buttons_init()
-{
-  #ifdef NEWPANEL
-    pinMode(BTN_EN1,INPUT);
-    pinMode(BTN_EN2,INPUT); 
-    pinMode(BTN_ENC,INPUT); 
-    pinMode(SDCARDDETECT,INPUT);
-    WRITE(BTN_EN1,HIGH);
-    WRITE(BTN_EN2,HIGH);
-    WRITE(BTN_ENC,HIGH);
-    WRITE(SDCARDDETECT,HIGH);
-  #else
-    pinMode(SHIFT_CLK,OUTPUT);
-    pinMode(SHIFT_LD,OUTPUT);
-    pinMode(SHIFT_EN,OUTPUT);
-    pinMode(SHIFT_OUT,INPUT);
-    WRITE(SHIFT_OUT,HIGH);
-    WRITE(SHIFT_LD,HIGH); 
-    WRITE(SHIFT_EN,LOW); 
-  #endif
-}
-
-
-void buttons_check()
-{
-  
-  #ifdef NEWPANEL
-    uint8_t newbutton=0;
-    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
-    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
-    if((blocking<millis()) &&(READ(BTN_ENC)==0))
-      newbutton|=EN_C;
-    buttons=newbutton;
-  #else   //read it from the shift register
-    uint8_t newbutton=0;
-    WRITE(SHIFT_LD,LOW);
-    WRITE(SHIFT_LD,HIGH);
-    unsigned char tmp_buttons=0;
-    for(int8_t i=0;i<8;i++)
-    { 
-      newbutton = newbutton>>1;
-      if(READ(SHIFT_OUT))
-        newbutton|=(1<<7);
-      WRITE(SHIFT_CLK,HIGH);
-      WRITE(SHIFT_CLK,LOW);
-    }
-    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
-  #endif
-  
-  //manage encoder rotation
-  char enc=0;
-  if(buttons&EN_A)
-    enc|=(1<<0);
-  if(buttons&EN_B)
-    enc|=(1<<1);
-  if(enc!=lastenc)
-	{
-    switch(enc)
-    {
-    case encrot0:
-      if(lastenc==encrot3)
-        encoderpos++;
-      else if(lastenc==encrot1)
-        encoderpos--;
-      break;
-    case encrot1:
-      if(lastenc==encrot0)
-        encoderpos++;
-      else if(lastenc==encrot2)
-        encoderpos--;
-      break;
-    case encrot2:
-      if(lastenc==encrot1)
-        encoderpos++;
-      else if(lastenc==encrot3)
-        encoderpos--;
-      break;
-    case encrot3:
-      if(lastenc==encrot2)
-        encoderpos++;
-      else if(lastenc==encrot0)
-        encoderpos--;
-      break;
-    default:
-      ;
-    }
-  }
-  lastenc=enc;
-}
-
-#endif
-
-MainMenu::MainMenu()
-{
-  status=Main_Status;
-  displayStartingRow=0;
-  activeline=0;
-  force_lcd_update=true;
-  #ifdef ULTIPANEL
-    buttons_init();
-  #endif
-  lcd_init();
-  linechanging=false;
-  tune=false;
-}
-
-void MainMenu::showStatus()
-{ 
-#if LCD_HEIGHT==4
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  //force_lcd_update=true;
-  if(force_lcd_update||feedmultiplychanged)  //initial display of content
-  {
-    feedmultiplychanged=false;
-    encoderpos=feedmultiply;
-    clear();
-    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-      lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
-    #endif
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update) //>1 because otherwise the lcd is refreshed to often.
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  int ttHotEnd0=intround(degTargetHotend0());
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-  #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-    static int oldtBed=-1;
-    static int oldtargetBed=-1; 
-    int tBed=intround(degBed());
-    if((tBed!=oldtBed)||force_lcd_update)
-    {
-      lcd.setCursor(1,0);
-      lcd.print(ftostr3(tBed));
-      oldtBed=tBed;
-    }
-    int targetBed=intround(degTargetBed());
-    if((targetBed!=oldtargetBed)||force_lcd_update)
-    {
-      lcd.setCursor(5,0);
-      lcd.print(ftostr3(targetBed));
-      oldtargetBed=targetBed;
-    }
-  #endif
-  //starttime=2;
-  static uint16_t oldtime=0;
-  if(starttime!=0)
-  {
-    lcd.setCursor(0,1);
-    uint16_t time=millis()/60000-starttime/60000;
-    
-    if(starttime!=oldtime)
-    {
-      lcd.print(itostr2(time/60));lcdprintPGM("h ");lcd.print(itostr2(time%60));lcdprintPGM("m");
-      oldtime=time;
-    }
-  }
-  static int oldzpos=0;
-  int currentz=current_position[2]*10;
-  if((currentz!=oldzpos)||force_lcd_update)
-  {
-    lcd.setCursor(10,1);
-    lcdprintPGM("Z:");lcd.print(itostr31(currentz));
-    oldzpos=currentz;
-  }
-  static int oldfeedmultiply=0;
-  int curfeedmultiply=feedmultiply;
-  if(encoderpos!=curfeedmultiply||force_lcd_update)
-  {
-   curfeedmultiply=encoderpos;
-   if(curfeedmultiply<10)
-     curfeedmultiply=10;
-   if(curfeedmultiply>999)
-     curfeedmultiply=999;
-   feedmultiply=curfeedmultiply;
-   encoderpos=curfeedmultiply;
-  }
-  if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
-  {
-   oldfeedmultiply=curfeedmultiply;
-   lcd.setCursor(0,2);
-   lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
-  }
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    
-    messagetext[0]='\0';
-  }
-  
-  static uint8_t oldpercent=101;
-  uint8_t percent=card.percentDone();
-  if(oldpercent!=percent ||force_lcd_update)
-  {
-     lcd.setCursor(7,2);
-    lcd.print(itostr3((int)percent));
-    lcdprintPGM("%SD");
-    
-  }
-  
-#else //smaller LCDS----------------------------------
-  static int olddegHotEnd0=-1;
-  static int oldtargetHotEnd0=-1;
-  if(force_lcd_update)  //initial display of content
-  {
-    encoderpos=feedmultiply;
-    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
-    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-    lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
-    #endif
-  }
-    
-  int tHotEnd0=intround(degHotend0());
-  int ttHotEnd0=intround(degTargetHotend0());
-
-
-  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tHotEnd0));
-    olddegHotEnd0=tHotEnd0;
-  }
-  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(ttHotEnd0));
-    oldtargetHotEnd0=ttHotEnd0;
-  }
-
-  if(messagetext[0]!='\0')
-  {
-    lcd.setCursor(0,LCD_HEIGHT-1);
-    lcd.print(messagetext);
-    uint8_t n=strlen(messagetext);
-    for(int8_t i=0;i<LCD_WIDTH-n;i++)
-      lcd.print(" ");
-    messagetext[0]='\0';
-  }
-
-#endif
-  force_lcd_update=false;
-}
-
-enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat, ItemP_extrude};
-
-//any action must not contain a ',' character anywhere, or this breaks:
-#define MENUITEM(repaint_action, click_action) \
-  {\
-    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-    if((activeline==line) && CLICKED) {click_action} \
-  }
-  
-void MainMenu::showPrepare()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-    case ItemP_exit:
-      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemP_autostart:
-      MENUITEM(  lcdprintPGM(" Autostart")  ,  BLOCK;card.lastnr=0;card.checkautostart(true);beepshort(); ) ;
-      break;
-    case ItemP_disstep:
-      MENUITEM(  lcdprintPGM(" Disable Steppers")  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
-      break;
-    case ItemP_home:
-      MENUITEM(  lcdprintPGM(" Auto Home")  ,  BLOCK;enquecommand("G28 X-105 Y-105 Z0");beepshort(); ) ;
-      break;
-    case ItemP_origin:
-      MENUITEM(  lcdprintPGM(" Set Origin")  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
-      break;
-    case ItemP_preheat:
-      MENUITEM(  lcdprintPGM(" Preheat")  ,  BLOCK;setTargetHotend0(170);beepshort(); ) ;
-      break;
-    case ItemP_extrude:
-      MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
-      break;
-    
-    
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemP_extrude,encoderpos);
-}
-
-enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,ItemT_fan};
-
-void MainMenu::showTune()
-{ 
-  uint8_t line=0;
-  clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-   //Serial.println((int)(line-lineoffset));
-  switch(i)
-  {
-  case ItemT_exit:
-      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-  case ItemT_speed:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(" Speed:");
-        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
-      }
-      
-      if((activeline!=line) )
-        break;
-      
-      if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-      {
-        linechanging=!linechanging;
-        if(linechanging)
-        {
-            encoderpos=feedmultiply;
-        }
-        else
-        {
-          encoderpos=activeline*lcdslow;
-          beepshort();
-        }
-        BLOCK;
-      }
-      if(linechanging)
-      {
-        if(encoderpos<1) encoderpos=1;
-        if(encoderpos>400) encoderpos=400;
-        feedmultiply = encoderpos;
-        feedmultiplychanged=true;
-        lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-      }
-      
-    }break;
-    case ItemT_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-      }break;
-      
-      case ItemT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=fanpwm;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          fanpwm=encoderpos;
-            analogWrite(FAN_PIN,  fanpwm);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      case ItemT_flow://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Flow:");
-          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)axis_steps_per_unit[3];
-          }
-          else
-          {
-            float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[3]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemT_fan,encoderpos);
-}
-
-//does not work
-// #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
-//   {\
-//     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
-//     if(activeline==line)  \
-//     { \
-//       if(CLICKED) \
-//       { \
-//         linechanging=!linechanging; \
-//         if(linechanging)  {enter_action;} \
-//         else {accept_action;} \
-//       }  \
-//       else \
-//       if(linechanging) {change_action};}\
-//   }
-//   
-
-enum {
-  ItemCT_exit,ItemCT_nozzle,
-#ifdef AUTOTEMP
-  ItemCT_autotempactive,
-  ItemCT_autotempmin,ItemCT_autotempmax,ItemCT_autotempfact,
-#endif
-  ItemCT_fan,
-  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C
-};
-
-void MainMenu::showControlTemp()
-{
-  uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCT_exit:
-      MENUITEM(  lcdprintPGM(" Control \003")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCT_nozzle:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(degTargetHotend0());
-          }
-          else
-          {
-            setTargetHotend0(encoderpos);
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      #ifdef AUTOTEMP
-      case ItemCT_autotempmin:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" \002 Min:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_min));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_min);
-          }
-          else
-          {
-            autotemp_min=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-      case ItemCT_autotempmax:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" \002 Max:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_max));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_max);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>260) encoderpos=260;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;  
-      case ItemCT_autotempfact:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" \002 Fact:");
-          lcd.setCursor(13,line);lcd.print(ftostr32(autotemp_factor));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=intround(autotemp_factor*100);
-          }
-          else
-          {
-            autotemp_max=encoderpos;
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>99) encoderpos=99;
-          lcd.setCursor(13,line);lcd.print(ftostr32(encoderpos/100.));
-        }
-        
-      }break;
-      case ItemCT_autotempactive:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Autotemp:");
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM("On");
-          else
-            lcdprintPGM("Off");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          autotemp_enabled=!autotemp_enabled;
-          lcd.setCursor(13,line);
-          if(autotemp_enabled)
-            lcdprintPGM("On ");
-          else
-            lcdprintPGM("Off");
-          BLOCK;
-        }
-        
-      }break;  
-      #endif //autotemp
-      case ItemCT_fan:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=fanpwm;
-          }
-          else
-          {
-            encoderpos=activeline*lcdslow;
-            beepshort();
-          }
-          BLOCK;
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>255) encoderpos=255;
-          fanpwm=encoderpos;
-            analogWrite(FAN_PIN,  fanpwm);
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      case ItemCT_PID_P: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)Kp;
-          }
-          else
-          {
-            Kp= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-        
-      }break;
-    case ItemCT_PID_I: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-I: ");
-          lcd.setCursor(13,line);lcd.print(ftostr51(Ki/PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)(Ki*10/PID_dT);
-          }
-          else
-          {
-            Ki= encoderpos/10.*PID_dT;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
-        }
-        
-      }break;
-      case ItemCT_PID_D: 
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-D: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kd*PID_dT));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)(Kd/5./PID_dT);
-          }
-          else
-          {
-            Kd= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>9990) encoderpos=9990;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-       
-      }break;   
-    case ItemCT_PID_C: 
-      #ifdef PID_ADD_EXTRUSION_RATE
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-C: ");
-          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)Kc;
-          }
-          else
-          {
-            Kc= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }
-      #endif
-      break;
-    default:   
-      break;
-  }
-  line++;
- }
- #ifdef PID_ADD_EXTRUSION_RATE
-  updateActiveLines(ItemCT_PID_C,encoderpos);
- #else
-  updateActiveLines(ItemCT_PID_D,encoderpos);
- #endif
-}
-
-
-enum {
-  ItemCM_exit, 
-  ItemCM_acc, ItemCM_xyjerk, 
-  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
-  ItemCM_vtravmin,ItemCM_vmin,  
-  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
-  ItemCM_aret,ItemCM_esteps
-};
-
-
-
-void MainMenu::showControlMotion()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemCM_exit:
-      MENUITEM(  lcdprintPGM(" Control \003")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-    case ItemCM_acc:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Acc:");
-          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)acceleration/100;
-          }
-          else
-          {
-            acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-    case ItemCM_xyjerk: //max_xy_jerk
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)max_xy_jerk;
-          }
-          else
-          {
-            max_xy_jerk= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-      
-    case ItemCM_vmaxx:
-    case ItemCM_vmaxy:
-    case ItemCM_vmaxz:
-    case ItemCM_vmaxe:
-      {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Vmax ");
-          if(i==ItemCM_vmaxx)lcdprintPGM("x:");
-          if(i==ItemCM_vmaxy)lcdprintPGM("y:");
-          if(i==ItemCM_vmaxz)lcdprintPGM("z:");
-          if(i==ItemCM_vmaxe)lcdprintPGM("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)max_feedrate[i-ItemCM_vmaxx];
-          }
-          else
-          {
-            max_feedrate[i-ItemCM_vmaxx]= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_vmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Vmin:");
-          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)(minimumfeedrate);
-          }
-          else
-          {
-            minimumfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    case ItemCM_vtravmin:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" VTrav min:");
-          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)mintravelfeedrate;
-          }
-          else
-          {
-            mintravelfeedrate= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<0) encoderpos=0;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
-        }
-        
-      }break;
-    
-    case ItemCM_amaxx:      
-    case ItemCM_amaxy:
-    case ItemCM_amaxz:
-    case ItemCM_amaxe:
-    {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Amax ");
-          if(i==ItemCM_amaxx)lcdprintPGM("x:");
-          if(i==ItemCM_amaxy)lcdprintPGM("y:");
-          if(i==ItemCM_amaxz)lcdprintPGM("z:");
-          if(i==ItemCM_amaxe)lcdprintPGM("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
-          }
-          else
-          {
-            max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<1) encoderpos=1;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-    case ItemCM_aret://float retract_acceleration = 7000;
-    {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" A-retract:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcdprintPGM("00");
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)retract_acceleration/100;
-          }
-          else
-          {
-            retract_acceleration= encoderpos*100;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<10) encoderpos=10;
-          if(encoderpos>990) encoderpos=990;
-          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
-        }
-        
-      }break;
-    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
-         {
-      if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Esteps/mm:");
-          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
-        }
-        
-        if((activeline!=line) )
-          break;
-        
-        if(CLICKED)
-        {
-          linechanging=!linechanging;
-          if(linechanging)
-          {
-              encoderpos=(int)axis_steps_per_unit[3];
-          }
-          else
-          {
-            float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
-            position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[3]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos;
-            encoderpos=activeline*lcdslow;
-              
-          }
-          BLOCK;
-          beepshort();
-        }
-        if(linechanging)
-        {
-          if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
-        }
-        
-      }break; 
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemCM_esteps,encoderpos);
-}
-
-
-enum {
-  ItemC_exit,ItemC_temp,ItemC_move,
-  ItemC_store, ItemC_load,ItemC_failsafe
-};
-
-void MainMenu::showControl()
-{
- uint8_t line=0;
- clearIfNecessary();
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case ItemC_exit:
-      MENUITEM(  lcdprintPGM(" Main        \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-    case ItemC_temp:
-      MENUITEM(  lcdprintPGM(" Temperature \x7E")  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
-      break;
-   case ItemC_move:
-      MENUITEM(  lcdprintPGM(" Motion      \x7E")  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
-      break;
-    case ItemC_store:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(" Store EPROM");
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_StoreSettings();
-      }
-    }break;
-    case ItemC_load:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(" Load EPROM");
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings();
-      }
-    }break;
-    case ItemC_failsafe:
-    {
-      if(force_lcd_update)
-      {
-        lcd.setCursor(0,line);lcdprintPGM(" Restore Failsafe");
-      }
-      if((activeline==line) && CLICKED)
-      {
-        //enquecommand("M84");
-        beepshort();
-        BLOCK;
-        EEPROM_RetrieveSettings(true);
-      }
-    }break;
-    default:   
-      break;
-  }
-  line++;
- }
- updateActiveLines(ItemC_failsafe,encoderpos);
-}
-
-
-
-
-
-void MainMenu::showSD()
-{
-#ifdef SDSUPPORT
- uint8_t line=0;
-
- clearIfNecessary();
- static uint8_t nrfiles=0;
- if(force_lcd_update)
- {
-  if(card.cardOK)
-  {
-    nrfiles=card.getnrfilenames();
-  }
-  else
-  {
-    nrfiles=0;
-    lineoffset=0;
-  }
- }
- bool enforceupdate=false;
- for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
- {
-  switch(i)
-  {
-    case 0:
-      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
-      break;
-//     case 1:
-//       {
-//         if(force_lcd_update)
-//         {
-//           lcd.setCursor(0,line);
-//            #ifdef CARDINSERTED
-//           if(CARDINSERTED)
-//           #else
-//           if(true)
-//           #endif
-//           {
-//             lcdprintPGM(" \004Refresh");
-//           }
-//           else
-//           {
-//             lcdprintPGM(" \004Insert Card");
-//           }
-//           
-//         }
-//         if((activeline==line) && CLICKED)
-//         {
-//           BLOCK;
-//           beepshort();
-//           card.initsd();
-//           force_lcd_update=true;
-//            nrfiles=card.getnrfilenames();
-//         }
-//       }break;
-    case 1:
-      MENUITEM(  lcd.print(" ");card.getWorkDirName();if(card.filename[0]=='/') lcdprintPGM("\004Refresh");else {lcd.print("\005");lcd.print(card.filename);lcd.print("/..");}  ,  BLOCK;card.updir();enforceupdate=true;lineoffset=0;beepshort(); ) ;
-      
-      break;
-    default:
-    {
-      #define FIRSTITEM 2
-      if(i-FIRSTITEM<nrfiles)
-      {
-        if(force_lcd_update)
-        {
-          card.getfilename(i-FIRSTITEM);
-          //Serial.print("Filenr:");Serial.println(i-2);
-          lcd.setCursor(0,line);lcdprintPGM(" ");
-          if(card.filenameIsDir) lcd.print("\005");
-          lcd.print(card.filename);
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          card.getfilename(i-FIRSTITEM);
-          if(card.filenameIsDir)
-          {
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            card.chdir(card.filename);
-            lineoffset=0;
-            enforceupdate=true;
-          }
-          else
-          {
-            char cmd[30];
-            for(int8_t i=0;i<strlen(card.filename);i++)
-              card.filename[i]=tolower(card.filename[i]);
-            sprintf(cmd,"M23 %s",card.filename);
-            //sprintf(cmd,"M115");
-            enquecommand(cmd);
-            enquecommand("M24");
-            beep(); 
-            status=Main_Status;
-            lcd_status(card.filename);
-          }
-        }
-      }
-      
-    }
-      break;
-  }
-  line++;
- }
- updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
- if(enforceupdate)
- {
-   force_lcd_update=true;
-   enforceupdate=false;
- }
-#endif
-}
-
-enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file };
-void MainMenu::showMainMenu()
-{
-
-  #ifndef ULTIPANEL
-    force_lcd_update=false;
-  #endif
-  if(tune)
-  {
-    if(!(movesplanned() ||card.sdprinting))
-    {
-      force_lcd_update=true;
-      tune=false;
-    }
-  }
-  else 
-  {
-    if(movesplanned() ||card.sdprinting)
-    {
-      force_lcd_update=true;
-      tune=true;
-    }
-  } 
-  clearIfNecessary();
-  for(int8_t line=0;line<LCD_HEIGHT;line++)
-  {
-    switch(line)
-    { 
-      case ItemM_watch:
-        MENUITEM(  lcdprintPGM(" Watch   \003")  ,  BLOCK;status=Main_Status;beepshort(); ) ;
-       break;
-      case ItemM_prepare:
-        MENUITEM(  if(!tune) lcdprintPGM(" Prepare \x7E");else  lcdprintPGM(" Tune    \x7E"); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
-      break;
-       
-      case ItemM_control:
-        MENUITEM(  lcdprintPGM(" Control \x7E")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
-      break;
-      #ifdef SDSUPPORT
-      case ItemM_file:    
-      {
-        if(force_lcd_update) 
-        {
-          lcd.setCursor(0,line);
-          #ifdef CARDINSERTED
-            if(CARDINSERTED)
-          #else
-            if(true)
-          #endif
-          {
-            if(card.sdprinting)
-              lcdprintPGM(" Stop Print   \x7E");
-            else
-              lcdprintPGM(" Card Menu    \x7E");
-          }
-          else
-          {
-           lcdprintPGM(" No Card"); 
-          }
-        }
-        #ifdef CARDINSERTED
-          if(CARDINSERTED)
-        #endif
-        if((activeline==line)&&CLICKED)
-        {
-          card.printingHasFinished();
-          BLOCK;
-          status=Main_SD;
-          beepshort();
-        }
-      }break;
-      #else
-      case ItemM_file:
-        break;
-      #endif
-      default: 
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Something is wrong in the MenuStructure.");
-      break;
-    }
-  }
-  updateActiveLines(3,encoderpos);
-}
-
-void MainMenu::update()
-{
-  static MainStatus oldstatus=Main_Menu;  //init automatically causes foce_lcd_update=true
-  static long timeoutToStatus=0;
-  static bool oldcardstatus=false;
-  #ifdef CARDINSERTED
-    if((CARDINSERTED != oldcardstatus))
-    {
-      force_lcd_update=true;
-      oldcardstatus=CARDINSERTED;
-      //Serial.println("echo: SD CHANGE");
-      if(CARDINSERTED)
-      {
-        card.initsd();
-        LCD_MESSAGEPGM("Card inserted");
-      }
-      else
-      {
-        card.release();
-        LCD_MESSAGEPGM("Card removed");
-      }
-    }
-  #endif
- 
-  if(status!=oldstatus)
-  {
-    force_lcd_update=true;
-    encoderpos=0;
-    lineoffset=0;
-    
-    oldstatus=status;
-  }
-  if( (encoderpos!=lastencoderpos) || CLICKED)
-    timeoutToStatus=millis()+STATUSTIMEOUT;
-
-  switch(status)
-  { 
-      case Main_Status: 
-      {  
-        showStatus();
-        if(CLICKED)
-        {
-           linechanging=false;
-           BLOCK
-           status=Main_Menu;
-           timeoutToStatus=millis()+STATUSTIMEOUT;
-        }
-      }break;
-      case Main_Menu: 
-      {
-        showMainMenu();
-        linechanging=false;
-      }break;
-      case Main_Prepare: 
-      {
-        if(tune)
-        {
-          showTune();
-        }
-        else
-        {
-          showPrepare(); 
-        }
-      }break;
-      case Main_Control:
-      {
-        showControl(); 
-      }break;
-      case Sub_MotionControl:
-      {
-        showControlMotion(); 
-      }break;
-      case Sub_TempControl:
-      {
-        showControlTemp(); 
-      }break;
-      case Main_SD: 
-      {
-        showSD();
-      }break;
-  }
-  
-  if(timeoutToStatus<millis())
-    status=Main_Status;
-  //force_lcd_update=false;
-  lastencoderpos=encoderpos;
-}
-
-
-
-
-
-
-//  convert float to string with +123.4 format
-char *ftostr3(const float &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr2(const uint8_t &x)
-{
-  //sprintf(conv,"%5.1f",x);
-  int xx=x;
-  conv[0]=(xx/10)%10+'0';
-  conv[1]=(xx)%10+'0';
-  conv[2]=0;
-  return conv;
-}
-
-//  convert float to string with +123.4 format
-char *ftostr31(const float &x)
-{
-  int xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *ftostr32(const float &x)
-{
-  int xx=x*100;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/100)%10+'0';
-  conv[2]='.';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr31(const int &xx)
-{
-  conv[0]=(xx>=0)?'+':'-';
-  conv[1]=(xx/1000)%10+'0';
-  conv[2]=(xx/100)%10+'0';
-  conv[3]=(xx/10)%10+'0';
-  conv[4]='.';
-  conv[5]=(xx)%10+'0';
-  conv[6]=0;
-  return conv;
-}
-
-char *itostr3(const int &xx)
-{
-  conv[0]=(xx/100)%10+'0';
-  conv[1]=(xx/10)%10+'0';
-  conv[2]=(xx)%10+'0';
-  conv[3]=0;
-  return conv;
-}
-
-char *itostr4(const int &xx)
-{
-  conv[0]=(xx/1000)%10+'0';
-  conv[1]=(xx/100)%10+'0';
-  conv[2]=(xx/10)%10+'0';
-  conv[3]=(xx)%10+'0';
-  conv[4]=0;
-  return conv;
-}
-
-//  convert float to string with +1234.5 format
-char *ftostr51(const float &x)
-{
-  int xx=x*10;
-  conv[0]=(xx>=0)?'+':'-';
-  xx=abs(xx);
-  conv[1]=(xx/10000)%10+'0';
-  conv[2]=(xx/1000)%10+'0';
-  conv[3]=(xx/100)%10+'0';
-  conv[4]=(xx/10)%10+'0';
-  conv[5]='.';
-  conv[6]=(xx)%10+'0';
-  conv[7]=0;
-  return conv;
-}
-
-
-#endif //ULTRA_LCD
-
-
+#include "ultralcd.h"
+#ifdef ULTRA_LCD
+
+//===========================================================================
+//=============================imported variables============================
+//===========================================================================
+
+extern volatile int feedmultiply;
+extern volatile bool feedmultiplychanged;
+
+extern long position[4];   
+extern CardReader card;
+
+//===========================================================================
+//=============================public variables============================
+//===========================================================================
+volatile char buttons=0;  //the last checked buttons in a bit array.
+int encoderpos=0;
+short lastenc=0;
+
+
+//===========================================================================
+//=============================private  variables============================
+//===========================================================================
+static char messagetext[LCD_WIDTH]="";
+
+//return for string conversion routines
+static char conv[8];
+
+#include <LiquidCrystal.h>
+LiquidCrystal lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7 
+
+static unsigned long previous_millis_lcd=0;
+static long previous_millis_buttons=0;
+
+
+#ifdef NEWPANEL
+ static long blocking=0;
+#else
+ static long blocking[8]={0,0,0,0,0,0,0,0};
+#endif
+ 
+static MainMenu menu;
+
+#include <avr/pgmspace.h>
+
+void lcdProgMemprint(const char *str)
+{
+  char ch=pgm_read_byte(str);
+  while(ch)
+  {
+    lcd.print(ch);
+    ch=pgm_read_byte(++str);
+  }
+}
+#define lcdprintPGM(x) lcdProgMemprint(MYPGM(x))
+
+
+//===========================================================================
+//=============================functions         ============================
+//===========================================================================
+
+FORCE_INLINE int intround(const float &x){return int(0.5+x);}
+
+void lcd_status(const char* message)
+{
+  strncpy(messagetext,message,LCD_WIDTH);
+  messagetext[strlen(message)]=0;
+}
+
+void lcd_statuspgm(const char* message)
+{
+  char ch=pgm_read_byte(message);
+  char *target=messagetext;
+  uint8_t cnt=0;
+  while(ch &&cnt<LCD_WIDTH)
+  {
+    *target=ch;
+    target++;
+    cnt++;
+    ch=pgm_read_byte(++message);
+  }
+  *target=0;
+}
+
+FORCE_INLINE void clear()
+{
+  lcd.clear();
+}
+
+
+void lcd_init()
+{
+  //beep();
+  byte Degree[8] =
+  {
+    B01100,
+    B10010,
+    B10010,
+    B01100,
+    B00000,
+    B00000,
+    B00000,
+    B00000
+  };
+  byte Thermometer[8] =
+  {
+    B00100,
+    B01010,
+    B01010,
+    B01010,
+    B01010,
+    B10001,
+    B10001,
+    B01110
+  };
+  byte uplevel[8]={0x04, 0x0e, 0x1f, 0x04, 0x1c, 0x00, 0x00, 0x00};//thanks joris
+  byte refresh[8]={0x00, 0x06, 0x19, 0x18, 0x03, 0x13, 0x0c, 0x00}; //thanks joris
+  byte folder [8]={0x00, 0x1c, 0x1f, 0x11, 0x11, 0x1f, 0x00, 0x00}; //thanks joris
+  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+  lcd.createChar(1,Degree);
+  lcd.createChar(2,Thermometer);
+  lcd.createChar(3,uplevel);
+  lcd.createChar(4,refresh);
+  lcd.createChar(5,folder);
+  LCD_MESSAGEPGM("UltiMarlin ready.");
+}
+
+
+void beep()
+{
+  //return;
+  #ifdef ULTIPANEL
+    pinMode(BEEPER,OUTPUT);
+    for(int8_t i=0;i<20;i++){
+      WRITE(BEEPER,HIGH);
+      delay(5);
+      WRITE(BEEPER,LOW);
+      delay(5);
+    }
+  #endif
+}
+
+void beepshort()
+{
+  //return;
+  #ifdef ULTIPANEL
+    pinMode(BEEPER,OUTPUT);
+    for(int8_t i=0;i<10;i++){
+      WRITE(BEEPER,HIGH);
+      delay(3);
+      WRITE(BEEPER,LOW);
+      delay(3);
+    }
+  #endif  
+}
+
+void lcd_status()
+{
+  #ifdef ULTIPANEL
+    static uint8_t oldbuttons=0;
+    //static long previous_millis_buttons=0;
+    //static long previous_lcdinit=0;
+  //  buttons_check(); // Done in temperature interrupt
+    //previous_millis_buttons=millis();
+    long ms=millis();
+    for(int8_t i=0; i<8; i++) {
+      if((blocking[i]>ms))
+        buttons &= ~(1<<i);
+    }
+    if((buttons==oldbuttons) &&  ((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
+      return;
+    oldbuttons=buttons;
+  #else
+  
+    if(((millis() - previous_millis_lcd) < LCD_UPDATE_INTERVAL)   )
+      return;
+  #endif
+    
+  previous_millis_lcd=millis();
+  menu.update();
+}
+#ifdef ULTIPANEL  
+
+
+void buttons_init()
+{
+  #ifdef NEWPANEL
+    pinMode(BTN_EN1,INPUT);
+    pinMode(BTN_EN2,INPUT); 
+    pinMode(BTN_ENC,INPUT); 
+    pinMode(SDCARDDETECT,INPUT);
+    WRITE(BTN_EN1,HIGH);
+    WRITE(BTN_EN2,HIGH);
+    WRITE(BTN_ENC,HIGH);
+    WRITE(SDCARDDETECT,HIGH);
+  #else
+    pinMode(SHIFT_CLK,OUTPUT);
+    pinMode(SHIFT_LD,OUTPUT);
+    pinMode(SHIFT_EN,OUTPUT);
+    pinMode(SHIFT_OUT,INPUT);
+    WRITE(SHIFT_OUT,HIGH);
+    WRITE(SHIFT_LD,HIGH); 
+    WRITE(SHIFT_EN,LOW); 
+  #endif
+}
+
+
+void buttons_check()
+{
+  
+  #ifdef NEWPANEL
+    uint8_t newbutton=0;
+    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
+    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
+    if((blocking<millis()) &&(READ(BTN_ENC)==0))
+      newbutton|=EN_C;
+    buttons=newbutton;
+  #else   //read it from the shift register
+    uint8_t newbutton=0;
+    WRITE(SHIFT_LD,LOW);
+    WRITE(SHIFT_LD,HIGH);
+    unsigned char tmp_buttons=0;
+    for(int8_t i=0;i<8;i++)
+    { 
+      newbutton = newbutton>>1;
+      if(READ(SHIFT_OUT))
+        newbutton|=(1<<7);
+      WRITE(SHIFT_CLK,HIGH);
+      WRITE(SHIFT_CLK,LOW);
+    }
+    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
+  #endif
+  
+  //manage encoder rotation
+  char enc=0;
+  if(buttons&EN_A)
+    enc|=(1<<0);
+  if(buttons&EN_B)
+    enc|=(1<<1);
+  if(enc!=lastenc)
+	{
+    switch(enc)
+    {
+    case encrot0:
+      if(lastenc==encrot3)
+        encoderpos++;
+      else if(lastenc==encrot1)
+        encoderpos--;
+      break;
+    case encrot1:
+      if(lastenc==encrot0)
+        encoderpos++;
+      else if(lastenc==encrot2)
+        encoderpos--;
+      break;
+    case encrot2:
+      if(lastenc==encrot1)
+        encoderpos++;
+      else if(lastenc==encrot3)
+        encoderpos--;
+      break;
+    case encrot3:
+      if(lastenc==encrot2)
+        encoderpos++;
+      else if(lastenc==encrot0)
+        encoderpos--;
+      break;
+    default:
+      ;
+    }
+  }
+  lastenc=enc;
+}
+
+#endif
+
+MainMenu::MainMenu()
+{
+  status=Main_Status;
+  displayStartingRow=0;
+  activeline=0;
+  force_lcd_update=true;
+  #ifdef ULTIPANEL
+    buttons_init();
+  #endif
+  lcd_init();
+  linechanging=false;
+  tune=false;
+}
+
+void MainMenu::showStatus()
+{ 
+#if LCD_HEIGHT==4
+  static int olddegHotEnd0=-1;
+  static int oldtargetHotEnd0=-1;
+  //force_lcd_update=true;
+  if(force_lcd_update||feedmultiplychanged)  //initial display of content
+  {
+    feedmultiplychanged=false;
+    encoderpos=feedmultiply;
+    clear();
+    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
+    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
+      lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
+    #endif
+  }
+    
+  int tHotEnd0=intround(degHotend0());
+  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update) //>1 because otherwise the lcd is refreshed to often.
+  {
+    lcd.setCursor(1,0);
+    lcd.print(ftostr3(tHotEnd0));
+    olddegHotEnd0=tHotEnd0;
+  }
+  int ttHotEnd0=intround(degTargetHotend0());
+  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
+  {
+    lcd.setCursor(5,0);
+    lcd.print(ftostr3(ttHotEnd0));
+    oldtargetHotEnd0=ttHotEnd0;
+  }
+  #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
+    static int oldtBed=-1;
+    static int oldtargetBed=-1; 
+    int tBed=intround(degBed());
+    if((tBed!=oldtBed)||force_lcd_update)
+    {
+      lcd.setCursor(1,0);
+      lcd.print(ftostr3(tBed));
+      oldtBed=tBed;
+    }
+    int targetBed=intround(degTargetBed());
+    if((targetBed!=oldtargetBed)||force_lcd_update)
+    {
+      lcd.setCursor(5,0);
+      lcd.print(ftostr3(targetBed));
+      oldtargetBed=targetBed;
+    }
+  #endif
+  //starttime=2;
+  static uint16_t oldtime=0;
+  if(starttime!=0)
+  {
+    lcd.setCursor(0,1);
+    uint16_t time=millis()/60000-starttime/60000;
+    
+    if(starttime!=oldtime)
+    {
+      lcd.print(itostr2(time/60));lcdprintPGM("h ");lcd.print(itostr2(time%60));lcdprintPGM("m");
+      oldtime=time;
+    }
+  }
+  static int oldzpos=0;
+  int currentz=current_position[2]*10;
+  if((currentz!=oldzpos)||force_lcd_update)
+  {
+    lcd.setCursor(10,1);
+    lcdprintPGM("Z:");lcd.print(itostr31(currentz));
+    oldzpos=currentz;
+  }
+  static int oldfeedmultiply=0;
+  int curfeedmultiply=feedmultiply;
+  if(encoderpos!=curfeedmultiply||force_lcd_update)
+  {
+   curfeedmultiply=encoderpos;
+   if(curfeedmultiply<10)
+     curfeedmultiply=10;
+   if(curfeedmultiply>999)
+     curfeedmultiply=999;
+   feedmultiply=curfeedmultiply;
+   encoderpos=curfeedmultiply;
+  }
+  if((curfeedmultiply!=oldfeedmultiply)||force_lcd_update)
+  {
+   oldfeedmultiply=curfeedmultiply;
+   lcd.setCursor(0,2);
+   lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
+  }
+  if(messagetext[0]!='\0')
+  {
+    lcd.setCursor(0,LCD_HEIGHT-1);
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
+    
+    messagetext[0]='\0';
+  }
+  
+  static uint8_t oldpercent=101;
+  uint8_t percent=card.percentDone();
+  if(oldpercent!=percent ||force_lcd_update)
+  {
+     lcd.setCursor(7,2);
+    lcd.print(itostr3((int)percent));
+    lcdprintPGM("%SD");
+    
+  }
+  
+#else //smaller LCDS----------------------------------
+  static int olddegHotEnd0=-1;
+  static int oldtargetHotEnd0=-1;
+  if(force_lcd_update)  //initial display of content
+  {
+    encoderpos=feedmultiply;
+    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
+    #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
+    lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
+    #endif
+  }
+    
+  int tHotEnd0=intround(degHotend0());
+  int ttHotEnd0=intround(degTargetHotend0());
+
+
+  if((abs(tHotEnd0-olddegHotEnd0)>1)||force_lcd_update)
+  {
+    lcd.setCursor(1,0);
+    lcd.print(ftostr3(tHotEnd0));
+    olddegHotEnd0=tHotEnd0;
+  }
+  if((ttHotEnd0!=oldtargetHotEnd0)||force_lcd_update)
+  {
+    lcd.setCursor(5,0);
+    lcd.print(ftostr3(ttHotEnd0));
+    oldtargetHotEnd0=ttHotEnd0;
+  }
+
+  if(messagetext[0]!='\0')
+  {
+    lcd.setCursor(0,LCD_HEIGHT-1);
+    lcd.print(messagetext);
+    uint8_t n=strlen(messagetext);
+    for(int8_t i=0;i<LCD_WIDTH-n;i++)
+      lcd.print(" ");
+    messagetext[0]='\0';
+  }
+
+#endif
+  force_lcd_update=false;
+}
+
+enum {ItemP_exit, ItemP_autostart,ItemP_disstep,ItemP_home, ItemP_origin, ItemP_preheat, ItemP_extrude};
+
+//any action must not contain a ',' character anywhere, or this breaks:
+#define MENUITEM(repaint_action, click_action) \
+  {\
+    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+    if((activeline==line) && CLICKED) {click_action} \
+  }
+  
+void MainMenu::showPrepare()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+   //Serial.println((int)(line-lineoffset));
+  switch(i)
+  {
+    case ItemP_exit:
+      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+    case ItemP_autostart:
+      MENUITEM(  lcdprintPGM(" Autostart")  ,  BLOCK;card.lastnr=0;card.checkautostart(true);beepshort(); ) ;
+      break;
+    case ItemP_disstep:
+      MENUITEM(  lcdprintPGM(" Disable Steppers")  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
+      break;
+    case ItemP_home:
+      MENUITEM(  lcdprintPGM(" Auto Home")  ,  BLOCK;enquecommand("G28 X-105 Y-105 Z0");beepshort(); ) ;
+      break;
+    case ItemP_origin:
+      MENUITEM(  lcdprintPGM(" Set Origin")  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
+      break;
+    case ItemP_preheat:
+      MENUITEM(  lcdprintPGM(" Preheat")  ,  BLOCK;setTargetHotend0(170);beepshort(); ) ;
+      break;
+    case ItemP_extrude:
+      MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
+      break;
+    
+    
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemP_extrude,encoderpos);
+}
+
+enum {ItemT_exit,ItemT_speed,ItemT_flow,ItemT_nozzle,ItemT_fan};
+
+void MainMenu::showTune()
+{ 
+  uint8_t line=0;
+  clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+   //Serial.println((int)(line-lineoffset));
+  switch(i)
+  {
+  case ItemT_exit:
+      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+  case ItemT_speed:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);lcdprintPGM(" Speed:");
+        lcd.setCursor(13,line);lcd.print(ftostr3(feedmultiply));
+      }
+      
+      if((activeline!=line) )
+        break;
+      
+      if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+      {
+        linechanging=!linechanging;
+        if(linechanging)
+        {
+            encoderpos=feedmultiply;
+        }
+        else
+        {
+          encoderpos=activeline*lcdslow;
+          beepshort();
+        }
+        BLOCK;
+      }
+      if(linechanging)
+      {
+        if(encoderpos<1) encoderpos=1;
+        if(encoderpos>400) encoderpos=400;
+        feedmultiply = encoderpos;
+        feedmultiplychanged=true;
+        lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+      }
+      
+    }break;
+    case ItemT_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend0());
+          }
+          else
+          {
+            setTargetHotend0(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+      }break;
+      
+      case ItemT_fan:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=fanpwm;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          fanpwm=encoderpos;
+            analogWrite(FAN_PIN,  fanpwm);
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      case ItemT_flow://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Flow:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)axis_steps_per_unit[3];
+          }
+          else
+          {
+            float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
+            position[E_AXIS]=lround(position[E_AXIS]*factor);
+            //current_position[3]*=factor;
+            axis_steps_per_unit[E_AXIS]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>9999) encoderpos=9999;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemT_fan,encoderpos);
+}
+
+//does not work
+// #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
+//   {\
+//     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+//     if(activeline==line)  \
+//     { \
+//       if(CLICKED) \
+//       { \
+//         linechanging=!linechanging; \
+//         if(linechanging)  {enter_action;} \
+//         else {accept_action;} \
+//       }  \
+//       else \
+//       if(linechanging) {change_action};}\
+//   }
+//   
+
+enum {
+  ItemCT_exit,ItemCT_nozzle,
+#ifdef AUTOTEMP
+  ItemCT_autotempactive,
+  ItemCT_autotempmin,ItemCT_autotempmax,ItemCT_autotempfact,
+#endif
+  ItemCT_fan,
+  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C
+};
+
+void MainMenu::showControlTemp()
+{
+  uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemCT_exit:
+      MENUITEM(  lcdprintPGM(" Control \003")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCT_nozzle:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(intround(degTargetHotend0())));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(degTargetHotend0());
+          }
+          else
+          {
+            setTargetHotend0(encoderpos);
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      #ifdef AUTOTEMP
+      case ItemCT_autotempmin:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002 Min:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_min));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_min);
+          }
+          else
+          {
+            autotemp_min=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;  
+      case ItemCT_autotempmax:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002 Max:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(autotemp_max));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_max);
+          }
+          else
+          {
+            autotemp_max=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>260) encoderpos=260;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;  
+      case ItemCT_autotempfact:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" \002 Fact:");
+          lcd.setCursor(13,line);lcd.print(ftostr32(autotemp_factor));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=intround(autotemp_factor*100);
+          }
+          else
+          {
+            autotemp_max=encoderpos;
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>99) encoderpos=99;
+          lcd.setCursor(13,line);lcd.print(ftostr32(encoderpos/100.));
+        }
+        
+      }break;
+      case ItemCT_autotempactive:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Autotemp:");
+          lcd.setCursor(13,line);
+          if(autotemp_enabled)
+            lcdprintPGM("On");
+          else
+            lcdprintPGM("Off");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          autotemp_enabled=!autotemp_enabled;
+          lcd.setCursor(13,line);
+          if(autotemp_enabled)
+            lcdprintPGM("On ");
+          else
+            lcdprintPGM("Off");
+          BLOCK;
+        }
+        
+      }break;  
+      #endif //autotemp
+      case ItemCT_fan:
+      {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED) //nalogWrite(FAN_PIN,  fanpwm);
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=fanpwm;
+          }
+          else
+          {
+            encoderpos=activeline*lcdslow;
+            beepshort();
+          }
+          BLOCK;
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>255) encoderpos=255;
+          fanpwm=encoderpos;
+            analogWrite(FAN_PIN,  fanpwm);
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      case ItemCT_PID_P: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
+          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)Kp;
+          }
+          else
+          {
+            Kp= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break;
+    case ItemCT_PID_I: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" PID-I: ");
+          lcd.setCursor(13,line);lcd.print(ftostr51(Ki/PID_dT));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)(Ki*10/PID_dT);
+          }
+          else
+          {
+            Ki= encoderpos/10.*PID_dT;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
+        }
+        
+      }break;
+      case ItemCT_PID_D: 
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" PID-D: ");
+          lcd.setCursor(13,line);lcd.print(itostr4(Kd*PID_dT));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)(Kd/5./PID_dT);
+          }
+          else
+          {
+            Kd= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>9990) encoderpos=9990;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+       
+      }break;   
+    case ItemCT_PID_C: 
+      #ifdef PID_ADD_EXTRUSION_RATE
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" PID-C: ");
+          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)Kc;
+          }
+          else
+          {
+            Kc= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }
+      #endif
+      break;
+    default:   
+      break;
+  }
+  line++;
+ }
+ #ifdef PID_ADD_EXTRUSION_RATE
+  updateActiveLines(ItemCT_PID_C,encoderpos);
+ #else
+  updateActiveLines(ItemCT_PID_D,encoderpos);
+ #endif
+}
+
+
+enum {
+  ItemCM_exit, 
+  ItemCM_acc, ItemCM_xyjerk, 
+  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
+  ItemCM_vtravmin,ItemCM_vmin,  
+  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
+  ItemCM_aret,ItemCM_esteps
+};
+
+
+
+void MainMenu::showControlMotion()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemCM_exit:
+      MENUITEM(  lcdprintPGM(" Control \003")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCM_acc:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Acc:");
+          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)acceleration/100;
+          }
+          else
+          {
+            acceleration= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
+        }
+        
+      }break;
+    case ItemCM_xyjerk: //max_xy_jerk
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)max_xy_jerk;
+          }
+          else
+          {
+            max_xy_jerk= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+      
+    case ItemCM_vmaxx:
+    case ItemCM_vmaxy:
+    case ItemCM_vmaxz:
+    case ItemCM_vmaxe:
+      {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Vmax ");
+          if(i==ItemCM_vmaxx)lcdprintPGM("x:");
+          if(i==ItemCM_vmaxy)lcdprintPGM("y:");
+          if(i==ItemCM_vmaxz)lcdprintPGM("z:");
+          if(i==ItemCM_vmaxe)lcdprintPGM("e:");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)max_feedrate[i-ItemCM_vmaxx];
+          }
+          else
+          {
+            max_feedrate[i-ItemCM_vmaxx]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    
+    case ItemCM_vmin:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Vmin:");
+          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)(minimumfeedrate);
+          }
+          else
+          {
+            minimumfeedrate= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    case ItemCM_vtravmin:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" VTrav min:");
+          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)mintravelfeedrate;
+          }
+          else
+          {
+            mintravelfeedrate= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<0) encoderpos=0;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+        }
+        
+      }break;
+    
+    case ItemCM_amaxx:      
+    case ItemCM_amaxy:
+    case ItemCM_amaxz:
+    case ItemCM_amaxe:
+    {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Amax ");
+          if(i==ItemCM_amaxx)lcdprintPGM("x:");
+          if(i==ItemCM_amaxy)lcdprintPGM("y:");
+          if(i==ItemCM_amaxz)lcdprintPGM("z:");
+          if(i==ItemCM_amaxe)lcdprintPGM("e:");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));lcdprintPGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
+          }
+          else
+          {
+            max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<1) encoderpos=1;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
+        }
+        
+      }break;
+    case ItemCM_aret://float retract_acceleration = 7000;
+    {
+        if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" A-retract:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcdprintPGM("00");
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)retract_acceleration/100;
+          }
+          else
+          {
+            retract_acceleration= encoderpos*100;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<10) encoderpos=10;
+          if(encoderpos>990) encoderpos=990;
+          lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
+        }
+        
+      }break;
+    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
+         {
+      if(force_lcd_update)
+        {
+          lcd.setCursor(0,line);lcdprintPGM(" Esteps/mm:");
+          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
+        }
+        
+        if((activeline!=line) )
+          break;
+        
+        if(CLICKED)
+        {
+          linechanging=!linechanging;
+          if(linechanging)
+          {
+              encoderpos=(int)axis_steps_per_unit[3];
+          }
+          else
+          {
+            float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
+            position[E_AXIS]=lround(position[E_AXIS]*factor);
+            //current_position[3]*=factor;
+            axis_steps_per_unit[E_AXIS]= encoderpos;
+            encoderpos=activeline*lcdslow;
+              
+          }
+          BLOCK;
+          beepshort();
+        }
+        if(linechanging)
+        {
+          if(encoderpos<5) encoderpos=5;
+          if(encoderpos>9999) encoderpos=9999;
+          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+        }
+        
+      }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemCM_esteps,encoderpos);
+}
+
+
+enum {
+  ItemC_exit,ItemC_temp,ItemC_move,
+  ItemC_store, ItemC_load,ItemC_failsafe
+};
+
+void MainMenu::showControl()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemC_exit:
+      MENUITEM(  lcdprintPGM(" Main        \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+    case ItemC_temp:
+      MENUITEM(  lcdprintPGM(" Temperature \x7E")  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
+      break;
+   case ItemC_move:
+      MENUITEM(  lcdprintPGM(" Motion      \x7E")  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
+      break;
+    case ItemC_store:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);lcdprintPGM(" Store EPROM");
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        EEPROM_StoreSettings();
+      }
+    }break;
+    case ItemC_load:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);lcdprintPGM(" Load EPROM");
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        EEPROM_RetrieveSettings();
+      }
+    }break;
+    case ItemC_failsafe:
+    {
+      if(force_lcd_update)
+      {
+        lcd.setCursor(0,line);lcdprintPGM(" Restore Failsafe");
+      }
+      if((activeline==line) && CLICKED)
+      {
+        //enquecommand("M84");
+        beepshort();
+        BLOCK;
+        EEPROM_RetrieveSettings(true);
+      }
+    }break;
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemC_failsafe,encoderpos);
+}
+
+
+
+
+
+void MainMenu::showSD()
+{
+#ifdef SDSUPPORT
+ uint8_t line=0;
+
+ clearIfNecessary();
+ static uint8_t nrfiles=0;
+ if(force_lcd_update)
+ {
+  if(card.cardOK)
+  {
+    nrfiles=card.getnrfilenames();
+  }
+  else
+  {
+    nrfiles=0;
+    lineoffset=0;
+  }
+ }
+ bool enforceupdate=false;
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case 0:
+      MENUITEM(  lcdprintPGM(" Main \003")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+//     case 1:
+//       {
+//         if(force_lcd_update)
+//         {
+//           lcd.setCursor(0,line);
+//            #ifdef CARDINSERTED
+//           if(CARDINSERTED)
+//           #else
+//           if(true)
+//           #endif
+//           {
+//             lcdprintPGM(" \004Refresh");
+//           }
+//           else
+//           {
+//             lcdprintPGM(" \004Insert Card");
+//           }
+//           
+//         }
+//         if((activeline==line) && CLICKED)
+//         {
+//           BLOCK;
+//           beepshort();
+//           card.initsd();
+//           force_lcd_update=true;
+//            nrfiles=card.getnrfilenames();
+//         }
+//       }break;
+    case 1:
+      MENUITEM(  lcd.print(" ");card.getWorkDirName();if(card.filename[0]=='/') lcdprintPGM("\004Refresh");else {lcd.print("\005");lcd.print(card.filename);lcd.print("/..");}  ,  BLOCK;card.updir();enforceupdate=true;lineoffset=0;beepshort(); ) ;
+      
+      break;
+    default:
+    {
+      #define FIRSTITEM 2
+      if(i-FIRSTITEM<nrfiles)
+      {
+        if(force_lcd_update)
+        {
+          card.getfilename(i-FIRSTITEM);
+          //Serial.print("Filenr:");Serial.println(i-2);
+          lcd.setCursor(0,line);lcdprintPGM(" ");
+          if(card.filenameIsDir) lcd.print("\005");
+          lcd.print(card.filename);
+        }
+        if((activeline==line) && CLICKED)
+        {
+          BLOCK
+          card.getfilename(i-FIRSTITEM);
+          if(card.filenameIsDir)
+          {
+            for(int8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            card.chdir(card.filename);
+            lineoffset=0;
+            enforceupdate=true;
+          }
+          else
+          {
+            char cmd[30];
+            for(int8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            sprintf(cmd,"M23 %s",card.filename);
+            //sprintf(cmd,"M115");
+            enquecommand(cmd);
+            enquecommand("M24");
+            beep(); 
+            status=Main_Status;
+            lcd_status(card.filename);
+          }
+        }
+      }
+      
+    }
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
+ if(enforceupdate)
+ {
+   force_lcd_update=true;
+   enforceupdate=false;
+ }
+#endif
+}
+
+enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file };
+void MainMenu::showMainMenu()
+{
+
+  #ifndef ULTIPANEL
+    force_lcd_update=false;
+  #endif
+  if(tune)
+  {
+    if(!(movesplanned() ||card.sdprinting))
+    {
+      force_lcd_update=true;
+      tune=false;
+    }
+  }
+  else 
+  {
+    if(movesplanned() ||card.sdprinting)
+    {
+      force_lcd_update=true;
+      tune=true;
+    }
+  } 
+  clearIfNecessary();
+  for(int8_t line=0;line<LCD_HEIGHT;line++)
+  {
+    switch(line)
+    { 
+      case ItemM_watch:
+        MENUITEM(  lcdprintPGM(" Watch   \003")  ,  BLOCK;status=Main_Status;beepshort(); ) ;
+       break;
+      case ItemM_prepare:
+        MENUITEM(  if(!tune) lcdprintPGM(" Prepare \x7E");else  lcdprintPGM(" Tune    \x7E"); ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
+      break;
+       
+      case ItemM_control:
+        MENUITEM(  lcdprintPGM(" Control \x7E")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+      #ifdef SDSUPPORT
+      case ItemM_file:    
+      {
+        if(force_lcd_update) 
+        {
+          lcd.setCursor(0,line);
+          #ifdef CARDINSERTED
+            if(CARDINSERTED)
+          #else
+            if(true)
+          #endif
+          {
+            if(card.sdprinting)
+              lcdprintPGM(" Stop Print   \x7E");
+            else
+              lcdprintPGM(" Card Menu    \x7E");
+          }
+          else
+          {
+           lcdprintPGM(" No Card"); 
+          }
+        }
+        #ifdef CARDINSERTED
+          if(CARDINSERTED)
+        #endif
+        if((activeline==line)&&CLICKED)
+        {
+          card.printingHasFinished();
+          BLOCK;
+          status=Main_SD;
+          beepshort();
+        }
+      }break;
+      #else
+      case ItemM_file:
+        break;
+      #endif
+      default: 
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Something is wrong in the MenuStructure.");
+      break;
+    }
+  }
+  updateActiveLines(3,encoderpos);
+}
+
+void MainMenu::update()
+{
+  static MainStatus oldstatus=Main_Menu;  //init automatically causes foce_lcd_update=true
+  static long timeoutToStatus=0;
+  static bool oldcardstatus=false;
+  #ifdef CARDINSERTED
+    if((CARDINSERTED != oldcardstatus))
+    {
+      force_lcd_update=true;
+      oldcardstatus=CARDINSERTED;
+      //Serial.println("echo: SD CHANGE");
+      if(CARDINSERTED)
+      {
+        card.initsd();
+        LCD_MESSAGEPGM("Card inserted");
+      }
+      else
+      {
+        card.release();
+        LCD_MESSAGEPGM("Card removed");
+      }
+    }
+  #endif
+ 
+  if(status!=oldstatus)
+  {
+    force_lcd_update=true;
+    encoderpos=0;
+    lineoffset=0;
+    
+    oldstatus=status;
+  }
+  if( (encoderpos!=lastencoderpos) || CLICKED)
+    timeoutToStatus=millis()+STATUSTIMEOUT;
+
+  switch(status)
+  { 
+      case Main_Status: 
+      {  
+        showStatus();
+        if(CLICKED)
+        {
+           linechanging=false;
+           BLOCK
+           status=Main_Menu;
+           timeoutToStatus=millis()+STATUSTIMEOUT;
+        }
+      }break;
+      case Main_Menu: 
+      {
+        showMainMenu();
+        linechanging=false;
+      }break;
+      case Main_Prepare: 
+      {
+        if(tune)
+        {
+          showTune();
+        }
+        else
+        {
+          showPrepare(); 
+        }
+      }break;
+      case Main_Control:
+      {
+        showControl(); 
+      }break;
+      case Sub_MotionControl:
+      {
+        showControlMotion(); 
+      }break;
+      case Sub_TempControl:
+      {
+        showControlTemp(); 
+      }break;
+      case Main_SD: 
+      {
+        showSD();
+      }break;
+  }
+  
+  if(timeoutToStatus<millis())
+    status=Main_Status;
+  //force_lcd_update=false;
+  lastencoderpos=encoderpos;
+}
+
+
+
+
+
+
+//  convert float to string with +123.4 format
+char *ftostr3(const float &x)
+{
+  //sprintf(conv,"%5.1f",x);
+  int xx=x;
+  conv[0]=(xx/100)%10+'0';
+  conv[1]=(xx/10)%10+'0';
+  conv[2]=(xx)%10+'0';
+  conv[3]=0;
+  return conv;
+}
+
+char *itostr2(const uint8_t &x)
+{
+  //sprintf(conv,"%5.1f",x);
+  int xx=x;
+  conv[0]=(xx/10)%10+'0';
+  conv[1]=(xx)%10+'0';
+  conv[2]=0;
+  return conv;
+}
+
+//  convert float to string with +123.4 format
+char *ftostr31(const float &x)
+{
+  int xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *ftostr32(const float &x)
+{
+  int xx=x*100;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/100)%10+'0';
+  conv[2]='.';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr31(const int &xx)
+{
+  conv[0]=(xx>=0)?'+':'-';
+  conv[1]=(xx/1000)%10+'0';
+  conv[2]=(xx/100)%10+'0';
+  conv[3]=(xx/10)%10+'0';
+  conv[4]='.';
+  conv[5]=(xx)%10+'0';
+  conv[6]=0;
+  return conv;
+}
+
+char *itostr3(const int &xx)
+{
+  conv[0]=(xx/100)%10+'0';
+  conv[1]=(xx/10)%10+'0';
+  conv[2]=(xx)%10+'0';
+  conv[3]=0;
+  return conv;
+}
+
+char *itostr4(const int &xx)
+{
+  conv[0]=(xx/1000)%10+'0';
+  conv[1]=(xx/100)%10+'0';
+  conv[2]=(xx/10)%10+'0';
+  conv[3]=(xx)%10+'0';
+  conv[4]=0;
+  return conv;
+}
+
+//  convert float to string with +1234.5 format
+char *ftostr51(const float &x)
+{
+  int xx=x*10;
+  conv[0]=(xx>=0)?'+':'-';
+  xx=abs(xx);
+  conv[1]=(xx/10000)%10+'0';
+  conv[2]=(xx/1000)%10+'0';
+  conv[3]=(xx/100)%10+'0';
+  conv[4]=(xx/10)%10+'0';
+  conv[5]='.';
+  conv[6]=(xx)%10+'0';
+  conv[7]=0;
+  return conv;
+}
+
+
+#endif //ULTRA_LCD
+
+

