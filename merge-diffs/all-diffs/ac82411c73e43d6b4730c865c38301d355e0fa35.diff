commit ac82411c73e43d6b4730c865c38301d355e0fa35 (from 65934eee9c6ae792c708bc1cea9996c8a5df67f5)
Merge: 65934ee 9980ceb
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Sun Nov 13 20:46:44 2011 +0100

    Merge remote-tracking branch 'origin/Marlin_v1' into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 2f1e8ad..6c8b3a4 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -1,10 +1,13 @@
 #ifndef __CONFIGURATION_H
 #define __CONFIGURATION_H
 
-//#define DEBUG_STEPS
 
-#define MM_PER_ARC_SEGMENT 1
-#define N_ARC_CORRECTION 25
+
+// This determines the communication speed of the printer
+//#define BAUDRATE 250000
+#define BAUDRATE 115200
+//#define BAUDRATE 230400
+
 
 // Frequency limit
 // See nophead's blog for more info
@@ -26,7 +29,9 @@
 // Teensylu = 8
 #define MOTHERBOARD 7
 
-
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
 
 //// Thermistor settings:
 // 1 is 100k thermistor
@@ -49,49 +54,103 @@
 //#define BED_USES_THERMISTOR
 //#define BED_USES_AD595
 
-#define HEATER_CHECK_INTERVAL 50
-#define BED_CHECK_INTERVAL 5000
+#define HEATER_CHECK_INTERVAL 50 //ms
+#define BED_CHECK_INTERVAL 5000 //ms
 
+//// Experimental watchdog and minimal temp
+// The watchdog waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
+// If the temperature has not increased at the end of that period, the target temperature is set to zero. It can be reset with another M104/M109
+/// CURRENTLY NOT IMPLEMENTED AND UNUSEABLE
+//#define WATCHPERIOD 5000 //5 seconds
 
-//// Endstop Settings
-#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
-// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
-// For optos H21LOB set to true, for Mendel-Parts newer optos TCST2103 set to false
+// Actual temperature must be close to target for this long before M109 returns success
+//#define TEMP_RESIDENCY_TIME 20  // (seconds)
+//#define TEMP_HYSTERESIS 5       // (C°) range of +/- temperatures considered "close" to the target one
 
-// This determines the communication speed of the printer
-#define BAUDRATE 250000
-//#define BAUDRATE 115200
-//#define BAUDRATE 230400
+//// The minimal temperature defines the temperature below which the heater will not be enabled
+#define HEATER_0_MINTEMP 5
+//#define HEATER_1_MINTEMP 5
+//#define BED_MINTEMP 5
 
-// Comment out (using // at the start of the line) to disable SD support:
 
-// #define ULTRA_LCD  //any lcd 
+// When temperature exceeds max temp, your heater will be switched off.
+// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
+// You should use MINTEMP for thermistor short/failure protection.
+#define HEATER_0_MAXTEMP 275
+//#define_HEATER_1_MAXTEMP 275
+//#define BED_MAXTEMP 150
 
-#define ULTIPANEL
-#ifdef ULTIPANEL
-  //#define NEWPANEL  //enable this if you have a click-encoder panel
-  #define SDSUPPORT
-  #define ULTRA_LCD
-  #define LCD_WIDTH 20
-  #define LCD_HEIGHT 4
-#else //no panel but just lcd 
-  #ifdef ULTRA_LCD
-    #define LCD_WIDTH 16
-    #define LCD_HEIGHT 2
+
+
+// PID settings:
+// Uncomment the following line to enable PID support.
+  
+#define PIDTEMP
+#ifdef PIDTEMP
+  //#define PID_DEBUG // Sends debug data to the serial port. 
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
+  
+  #define PID_MAX 255 // limits current to nozzle; 255=full current
+  #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
+  #define K1 0.95 //smoothing factor withing the PID
+  #define PID_dT 0.1 //sampling period of the PID
+
+  //To develop some PID settings for your machine, you can initiall follow 
+  // the Ziegler-Nichols method.
+  // set Ki and Kd to zero. 
+  // heat with a defined Kp and see if the temperature stabilizes
+  // ideally you do this graphically with repg.
+  // the PID_CRITIAL_GAIN should be the Kp at which temperature oscillatins are not dampned out/decreas in amplitutde
+  // PID_SWING_AT_CRITIAL is the time for a full period of the oscillations at the critical Gain
+  // usually further manual tunine is necessary.
+
+  #define PID_CRITIAL_GAIN 3000
+  #define PID_SWING_AT_CRITIAL 45 //seconds
+  
+  #define PID_PI    //no differentail term
+  //#define PID_PID //normal PID
+
+  #ifdef PID_PID
+    //PID according to Ziegler-Nichols method
+    #define  DEFAULT_Kp  (0.6*PID_CRITIAL_GAIN)
+    #define  DEFAULT_Ki (2*Kp/PID_SWING_AT_CRITIAL*PID_dT)  
+    #define  DEFAULT_Kd (PID_SWING_AT_CRITIAL/8./PID_dT)  
   #endif
-#endif
+ 
+  #ifdef PID_PI
+    //PI according to Ziegler-Nichols method
+    #define  DEFAULT_Kp (PID_CRITIAL_GAIN/2.2) 
+    #define  DEFAULT_Ki (1.2*Kp/PID_SWING_AT_CRITIAL*PID_dT)
+    #define  DEFAULT_Kd (0)
+  #endif
+  
+  // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
+  // if Kc is choosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE  
+  #ifdef PID_ADD_EXTRUSION_RATE
+    #define  DEFAULT_Kc (3) //heatingpower=Kc*(e_speed)
+  #endif
+#endif // PIDTEMP
 
 
-//#define SDSUPPORT // Enable SD Card Support in Hardware Console
 
 
 
-const int dropsegments=5; //everything with this number of steps  will be ignored as move
 
-//// ADVANCED SETTINGS - to tweak parameters
 
-#include "thermistortables.h"
+
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+
+// Endstop Settings
+#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
+const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
+// For optos H21LOB set to true, for Mendel-Parts newer optos TCST2103 set to false
+
 
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 #define X_ENABLE_ON 0
@@ -156,88 +215,33 @@ const int dropsegments=5; //everything with this number of steps  will be ignore
 #define DEFAULT_ZJERK                 0.4     // (mm/sec)
 
 
-// The watchdog waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
-//this enables the watchdog interrupt.
-#define USE_WATCHDOG
-//you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
-#define RESET_MANUAL
-
-#define WATCHDOG_TIMEOUT 4
-
-
 
-//// Experimental watchdog and minimal temp
-// The watchdog waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
-// If the temperature has not increased at the end of that period, the target temperature is set to zero. It can be reset with another M104/M109
-/// CURRENTLY NOT IMPLEMENTED AND UNUSEABLE
-//#define WATCHPERIOD 5000 //5 seconds
-
-// Actual temperature must be close to target for this long before M109 returns success
-//#define TEMP_RESIDENCY_TIME 20  // (seconds)
-//#define TEMP_HYSTERESIS 5       // (C°) range of +/- temperatures considered "close" to the target one
 
-//// The minimal temperature defines the temperature below which the heater will not be enabled
-//#define HEATER_0_MINTEMP 5
-//#define HEATER_1_MINTEMP 5
-//#define BED_MINTEMP 5
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
 
+// EEPROM
+// the microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+//define this to enable eeprom support
+#define EEPROM_SETTINGS
+//to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
+// please keep turned on if you can.
+#define EEPROM_CHITCHAT
 
-// When temperature exceeds max temp, your heater will be switched off.
-// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
-// You should use MINTEMP for thermistor short/failure protection.
-//#define HEATER_0_MAXTEMP 275
-//#define_HEATER_1_MAXTEMP 275
-//#define BED_MAXTEMP 150
 
-/// PID settings:
-// Uncomment the following line to enable PID support.
-  
-#define PIDTEMP
-#ifdef PIDTEMP
-  //#define PID_DEBUG // Sends debug data to the serial port. 
-  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104 sets the output power in %
-  
-  #define PID_MAX 255 // limits current to nozzle; 255=full current
-  #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
-  #define K1 0.95 //smoothing factor withing the PID
-  #define PID_dT 0.1 //sampling period of the PID
+// The watchdog waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
+// this enables the watchdog interrupt.
+#define USE_WATCHDOG
+// you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
+#define RESET_MANUAL
+#define WATCHDOG_TIMEOUT 4  //seconds
 
-  //To develop some PID settings for your machine, you can initiall follow 
-  // the Ziegler-Nichols method.
-  // set Ki and Kd to zero. 
-  // heat with a defined Kp and see if the temperature stabilizes
-  // ideally you do this graphically with repg.
-  // the PID_CRITIAL_GAIN should be the Kp at which temperature oscillatins are not dampned out/decreas in amplitutde
-  // PID_SWING_AT_CRITIAL is the time for a full period of the oscillations at the critical Gain
-  // usually further manual tunine is necessary.
 
-  #define PID_CRITIAL_GAIN 3000
-  #define PID_SWING_AT_CRITIAL 45 //seconds
-  
-  #define PID_PI    //no differentail term
-  //#define PID_PID //normal PID
 
-  #ifdef PID_PID
-    //PID according to Ziegler-Nichols method
-    #define  DEFAULT_Kp  (0.6*PID_CRITIAL_GAIN)
-    #define  DEFAULT_Ki (2*Kp/PID_SWING_AT_CRITIAL*PID_dT)  
-    #define  DEFAULT_Kd (PID_SWING_AT_CRITIAL/8./PID_dT)  
-  #endif
- 
-  #ifdef PID_PI
-    //PI according to Ziegler-Nichols method
-    #define  DEFAULT_Kp (PID_CRITIAL_GAIN/2.2) 
-    #define  DEFAULT_Ki (1.2*Kp/PID_SWING_AT_CRITIAL*PID_dT)
-    #define  DEFAULT_Kd (0)
-  #endif
-  
-  // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
-  // if Kc is choosen well, the additional required power due to increased melting should be compensated.
-  #define PID_ADD_EXTRUSION_RATE  
-  #ifdef PID_ADD_EXTRUSION_RATE
-    #define  DEFAULT_Kc (5) //heatingpower=Kc*(e_speed)
-  #endif
-#endif // PIDTEMP
 
 // extruder advance constant (s2/mm3)
 //
@@ -258,6 +262,52 @@ const int dropsegments=5; //everything with this number of steps  will be ignore
 
 #endif // ADVANCE
 
+
+//LCD and SD support
+//#define ULTRA_LCD  //general lcd support, also 16x2
+//#define SDSUPPORT // Enable SD Card Support in Hardware Console
+
+#define ULTIPANEL
+#ifdef ULTIPANEL
+  #define NEWPANEL  //enable this if you have a click-encoder panel
+  #define SDSUPPORT
+  #define ULTRA_LCD
+  #define LCD_WIDTH 20
+  #define LCD_HEIGHT 4
+#else //no panel but just lcd 
+  #ifdef ULTRA_LCD
+    #define LCD_WIDTH 16
+    #define LCD_HEIGHT 2
+  #endif
+#endif
+
+// A debugging feature to compare calculated vs performed steps, to see if steps are lost by the software.
+//#define DEBUG_STEPS
+
+
+// Arc interpretation settings:
+#define MM_PER_ARC_SEGMENT 1
+#define N_ARC_CORRECTION 25
+
+
+//automatic temperature: just for testing, this is very dangerous, keep disabled!
+// not working yet.
+//Erik: the settings currently depend dramatically on skeinforge39 or 41.
+//#define AUTOTEMP
+#define AUTOTEMP_MIN 190
+#define AUTOTEMP_MAX 260
+#define AUTOTEMP_FACTOR 1000.  //current target temperature= min+largest buffered espeeds)*FACTOR
+
+
+
+const int dropsegments=0; //everything with less than this number of steps  will be ignored as move and joined with the next movement
+
+//===========================================================================
+//=============================Buffers           ============================
+//===========================================================================
+
+
+
 // The number of linear motions that can be in the plan at any give time.  
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
 #if defined SDSUPPORT
@@ -266,8 +316,12 @@ const int dropsegments=5; //everything with this number of steps  will be ignore
   #define BLOCK_BUFFER_SIZE 8 // maximize block buffer
 #endif
 
+
 //The ASCII buffer for recieving from the serial:
 #define MAX_CMD_SIZE 96
 #define BUFSIZE 4
 
+
+#include "thermistortables.h"
+
 #endif //__CONFIGURATION_H
diff --git a/Marlin/EEPROMwrite.h b/Marlin/EEPROMwrite.h
index db9f2fd..3d8a0b2 100644
--- a/Marlin/EEPROMwrite.h
+++ b/Marlin/EEPROMwrite.h
@@ -25,6 +25,9 @@ template <class T> int EEPROM_readAnything(int &ee, T& value)
 }
 //======================================================================================
 
+
+
+
 #define EEPROM_OFFSET 100
 
 
@@ -35,8 +38,9 @@ template <class T> int EEPROM_readAnything(int &ee, T& value)
 // ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
 #define EEPROM_VERSION "V04"  
 
-void StoreSettings() 
+inline void StoreSettings() 
 {
+#ifdef EEPROM_SETTINGS
   char ver[4]= "000";
   int i=EEPROM_OFFSET;
   EEPROM_writeAnything(i,ver); // invalidate data first 
@@ -62,71 +66,115 @@ void StoreSettings()
   char ver2[4]=EEPROM_VERSION;
   i=EEPROM_OFFSET;
   EEPROM_writeAnything(i,ver2); // validate data
-  SERIAL_ECHOLN("Settings Stored");
+  SERIAL_ECHO_START;
+  SERIAL_ECHOLNPGM("Settings Stored");
+#endif //EEPROM_SETTINGS
 }
 
-void RetrieveSettings(bool def=false)
+inline void RetrieveSettings(bool def=false)
 {  // if def=true, the default values will be used
-  int i=EEPROM_OFFSET;
-  char stored_ver[4];
-  char ver[4]=EEPROM_VERSION;
-  EEPROM_readAnything(i,stored_ver); //read stored version
-  //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
-  if ((!def)&&(strncmp(ver,stored_ver,3)==0)) 
-  {   // version number match
-    EEPROM_readAnything(i,axis_steps_per_unit);  
-    EEPROM_readAnything(i,max_feedrate);  
-    EEPROM_readAnything(i,max_acceleration_units_per_sq_second);
-    EEPROM_readAnything(i,acceleration);
-    EEPROM_readAnything(i,retract_acceleration);
-    EEPROM_readAnything(i,minimumfeedrate);
-    EEPROM_readAnything(i,mintravelfeedrate);
-    EEPROM_readAnything(i,minsegmenttime);
-    EEPROM_readAnything(i,max_xy_jerk);
-    EEPROM_readAnything(i,max_z_jerk);
-    #ifndef PIDTEMP
-      float Kp,Ki,Kd;
-    #endif
-    EEPROM_readAnything(i,Kp);
-    EEPROM_readAnything(i,Ki);
-    EEPROM_readAnything(i,Kd);
+  #ifdef EEPROM_SETTINGS
+    int i=EEPROM_OFFSET;
+    char stored_ver[4];
+    char ver[4]=EEPROM_VERSION;
+    EEPROM_readAnything(i,stored_ver); //read stored version
+    //  SERIAL_ECHOLN("Version: [" << ver << "] Stored version: [" << stored_ver << "]");
+    if ((!def)&&(strncmp(ver,stored_ver,3)==0)) 
+    {   // version number match
+      EEPROM_readAnything(i,axis_steps_per_unit);  
+      EEPROM_readAnything(i,max_feedrate);  
+      EEPROM_readAnything(i,max_acceleration_units_per_sq_second);
+      EEPROM_readAnything(i,acceleration);
+      EEPROM_readAnything(i,retract_acceleration);
+      EEPROM_readAnything(i,minimumfeedrate);
+      EEPROM_readAnything(i,mintravelfeedrate);
+      EEPROM_readAnything(i,minsegmenttime);
+      EEPROM_readAnything(i,max_xy_jerk);
+      EEPROM_readAnything(i,max_z_jerk);
+      #ifndef PIDTEMP
+        float Kp,Ki,Kd;
+      #endif
+      EEPROM_readAnything(i,Kp);
+      EEPROM_readAnything(i,Ki);
+      EEPROM_readAnything(i,Kd);
 
-    SERIAL_ECHOLN("Stored settings retreived:");
-  }
-  else 
-  {
-    float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
-    float tmp2[]=DEFAULT_MAX_FEEDRATE;
-    long tmp3[]=DEFAULT_MAX_ACCELERATION;
-    for (short i=0;i<4;i++) 
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Stored settings retreived:");
+    }
+    else 
     {
-      axis_steps_per_unit[i]=tmp1[i];  
-      max_feedrate[i]=tmp2[i];  
-      max_acceleration_units_per_sq_second[i]=tmp3[i];
+      float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;
+      float tmp2[]=DEFAULT_MAX_FEEDRATE;
+      long tmp3[]=DEFAULT_MAX_ACCELERATION;
+      for (short i=0;i<4;i++) 
+      {
+        axis_steps_per_unit[i]=tmp1[i];  
+        max_feedrate[i]=tmp2[i];  
+        max_acceleration_units_per_sq_second[i]=tmp3[i];
+      }
+      acceleration=DEFAULT_ACCELERATION;
+      retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
+      minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
+      minsegmenttime=DEFAULT_MINSEGMENTTIME;       
+      mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
+      max_xy_jerk=DEFAULT_XYJERK;
+      max_z_jerk=DEFAULT_ZJERK;
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLN("Using Default settings:");
     }
-    acceleration=DEFAULT_ACCELERATION;
-    retract_acceleration=DEFAULT_RETRACT_ACCELERATION;
-    minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;
-    minsegmenttime=DEFAULT_MINSEGMENTTIME;       
-    mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;
-    max_xy_jerk=DEFAULT_XYJERK;
-    max_z_jerk=DEFAULT_ZJERK;
-    SERIAL_ECHOLN("Using Default settings:");
-  }
-  SERIAL_ECHOLN("Steps per unit:");
-  SERIAL_ECHOLN("   M92 X"   <<_FLOAT(axis_steps_per_unit[0],3) << " Y" <<  _FLOAT(axis_steps_per_unit[1],3) << " Z" << _FLOAT(axis_steps_per_unit[2],3) << " E" << _FLOAT(axis_steps_per_unit[3],3));
-  SERIAL_ECHOLN("Maximum feedrates (mm/s):");
-  SERIAL_ECHOLN("   M203 X"  <<_FLOAT(max_feedrate[0]/60,2)<<" Y" << _FLOAT(max_feedrate[1]/60,2) << " Z" << _FLOAT(max_feedrate[2]/60,2) << " E" << _FLOAT(max_feedrate[3]/60,2));
-  SERIAL_ECHOLN("Maximum Acceleration (mm/s2):");
-  SERIAL_ECHOLN("   M201 X"  <<_FLOAT(max_acceleration_units_per_sq_second[0],0) << " Y" << _FLOAT(max_acceleration_units_per_sq_second[1],0) << " Z" << _FLOAT(max_acceleration_units_per_sq_second[2],0) << " E" << _FLOAT(max_acceleration_units_per_sq_second[3],0));
-  SERIAL_ECHOLN("Acceleration: S=acceleration, T=retract acceleration");
-  SERIAL_ECHOLN("   M204 S"  <<_FLOAT(acceleration,2) << " T" << _FLOAT(retract_acceleration,2));
-  SERIAL_ECHOLN("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
-  SERIAL_ECHOLN("   M205 S"  <<_FLOAT(minimumfeedrate/60,2) << " T" << _FLOAT(mintravelfeedrate/60,2) << " B" << _FLOAT(minsegmenttime,2) << " X" << _FLOAT(max_xy_jerk/60,2) << " Z" << _FLOAT(max_z_jerk/60,2));
-  #ifdef PIDTEMP
-    SERIAL_ECHOLN("PID settings:");
-    SERIAL_ECHOLN("   M301 P"  << _FLOAT(Kp,3) << " I" << _FLOAT(Ki,3) << " D" << _FLOAT(Kd,3));  
+  #ifdef EEPROM_CHITCHAT
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Steps per unit:");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
+      SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
+      SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
+      SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
+      SERIAL_ECHOLN("");
+      
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]/60);
+      SERIAL_ECHOPAIR(" Y",max_feedrate[1]/60 ); 
+      SERIAL_ECHOPAIR(" Z", max_feedrate[2]/60 ); 
+      SERIAL_ECHOPAIR(" E", max_feedrate[3]/60);
+      SERIAL_ECHOLN("");
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
+      SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
+      SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
+      SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
+      SERIAL_ECHOLN("");
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M204 S",acceleration ); 
+      SERIAL_ECHOPAIR(" T" ,retract_acceleration);
+      SERIAL_ECHOLN("");
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M205 S",minimumfeedrate/60 ); 
+      SERIAL_ECHOPAIR(" T" ,mintravelfeedrate/60 ); 
+      SERIAL_ECHOPAIR(" B" ,minsegmenttime ); 
+      SERIAL_ECHOPAIR(" X" ,max_xy_jerk/60 ); 
+      SERIAL_ECHOPAIR(" Z" ,max_z_jerk/60);
+      SERIAL_ECHOLN(""); 
+    #ifdef PIDTEMP
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("PID settings:");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("   M301 P",Kp ); 
+      SERIAL_ECHOPAIR(" I" ,Ki ); 
+      SERIAL_ECHOPAIR(" D" ,Kd);
+      SERIAL_ECHOLN(""); 
+    #endif
   #endif
+    
+  #endif //EEPROM_SETTINGS
 }  
 
 #endif
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 21eadee..440a44a 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -5,12 +5,52 @@
 // Licence: GPL
 #include <WProgram.h>
 #include "fastio.h"
+#include <avr/pgmspace.h>
+#include "Configuration.h"
+
+//#define SERIAL_ECHO(x) Serial << "echo: " << x;
+//#define SERIAL_ECHOLN(x) Serial << "echo: "<<x<<endl;
+//#define SERIAL_ERROR(x) Serial << "Error: " << x;
+//#define SERIAL_ERRORLN(x) Serial << "Error: " << x<<endl;
+//#define SERIAL_PROTOCOL(x) Serial << x;
+//#define SERIAL_PROTOCOLLN(x) Serial << x<<endl;
+
+
+
+#define SERIAL_PROTOCOL(x) Serial.print(x);
+#define SERIAL_PROTOCOLPGM(x) serialprintPGM(PSTR(x));
+#define SERIAL_PROTOCOLLN(x) {Serial.print(x);Serial.write('\n');}
+#define SERIAL_PROTOCOLLNPGM(x) {serialprintPGM(PSTR(x));Serial.write('\n');}
+
+const char errormagic[] PROGMEM ="Error:";
+const char echomagic[] PROGMEM ="echo:";
+#define SERIAL_ERROR_START serialprintPGM(errormagic);
+#define SERIAL_ERROR(x) SERIAL_PROTOCOL(x)
+#define SERIAL_ERRORPGM(x) SERIAL_PROTOCOLPGM(x)
+#define SERIAL_ERRORLN(x) SERIAL_PROTOCOLLN(x)
+#define SERIAL_ERRORLNPGM(x) SERIAL_PROTOCOLLNPGM(x)
+
+#define SERIAL_ECHO_START serialprintPGM(echomagic);
+#define SERIAL_ECHO(x) SERIAL_PROTOCOL(x)
+#define SERIAL_ECHOPGM(x) SERIAL_PROTOCOLPGM(x)
+#define SERIAL_ECHOLN(x) SERIAL_PROTOCOLLN(x)
+#define SERIAL_ECHOLNPGM(x) SERIAL_PROTOCOLLNPGM(x)
+
+#define SERIAL_ECHOPAIR(name,value) {SERIAL_ECHOPGM(name);SERIAL_ECHO(value);}
+
+
+//things to write to serial from Programmemory. saves 400 to 2k of RAM.
+#define SerialprintPGM(x) serialprintPGM(PSTR(x))
+inline void serialprintPGM(const char *str)
+{
+  char ch=pgm_read_byte(str);
+  while(ch)
+  {
+    Serial.write(ch);
+    ch=pgm_read_byte(++str);
+  }
+}
 
-#include "streaming.h"
-#define SERIAL_ECHO(x) Serial << "echo: " << x;
-#define SERIAL_ECHOLN(x) Serial << "echo: "<<x<<endl;
-#define SERIAL_ERROR(x) Serial << "echo: ERROR: " << x;
-#define SERIAL_ERRORLN(x) Serial << "echo: ERROR: " << x<<endl;
 
 void get_command();
 void process_commands();
@@ -69,5 +109,6 @@ void enquecommand(const char *cmd); //put an ascii command at the end of the cur
 
 extern float homing_feedrate[];
 extern bool axis_relative_modes[];
+extern float current_position[NUM_AXIS] ;
 
 #endif
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 1d72287..7ef5399 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -32,7 +32,6 @@
 #include "pins.h"
 #include "Marlin.h"
 #include "ultralcd.h"
-#include "streaming.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
@@ -40,7 +39,8 @@
 #include "cardreader.h"
 
 
-char version_string[] = "1.0.0 Alpha 1";
+#define VERSION_STRING  "1.0.0 Alpha 1"
+
 
 
 
@@ -99,8 +99,9 @@ char version_string[] = "1.0.0 Alpha 1";
 // M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
 // M220 - set speed factor override percentage S:factor in percent
 // M301 - Set PID parameters P I and D
+// M400 - Finish all moves
 // M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  D
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
 
 //Stepper Movement Variables
@@ -122,13 +123,14 @@ bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
 volatile int feedmultiply=100; //100->1 200->2
 int saved_feedmultiply;
 volatile bool feedmultiplychanged=false;
+float current_position[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+
 
 //===========================================================================
 //=============================private variables=============================
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
-static float current_position[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
 static float offset[3] = {0.0, 0.0, 0.0};
 static bool home_all_axis = true;
 static float feedrate = 1500.0, next_feedrate, saved_feedrate;
@@ -173,6 +175,23 @@ static unsigned long stoptime=0;
 //===========================================================================
 
 
+extern "C"{
+  extern unsigned int __bss_end;
+  extern unsigned int __heap_start;
+  extern void *__brkval;
+
+  int freeMemory() {
+    int free_memory;
+
+    if((int)__brkval == 0)
+      free_memory = ((int)&free_memory) - ((int)&__bss_end);
+    else
+      free_memory = ((int)&free_memory) - ((int)__brkval);
+
+    return free_memory;
+  }
+}
+
 
 //adds an command to the main command buffer
 //thats really done in a non-safe way.
@@ -183,7 +202,10 @@ void enquecommand(const char *cmd)
   {
     //this is dangerous if a mixing of serial and this happsens
     strcpy(&(cmdbuffer[bufindw][0]),cmd);
-    SERIAL_ECHOLN("enqueing \""<<cmdbuffer[bufindw]<<"\"");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHO(cmdbuffer[bufindw]);
+    SERIAL_ECHOLNPGM("\"");
     bufindw= (bufindw + 1)%BUFSIZE;
     buflen += 1;
   }
@@ -192,8 +214,12 @@ void enquecommand(const char *cmd)
 void setup()
 { 
   Serial.begin(BAUDRATE);
-  SERIAL_ECHOLN("Marlin "<<version_string);
-  Serial.println("start");
+  SERIAL_ECHO_START;
+  SERIAL_ECHOLNPGM(VERSION_STRING);
+  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPGM("Free Memory:");
+  SERIAL_ECHOLN(freeMemory());
   for(int8_t i = 0; i < BUFSIZE; i++)
   {
     fromsd[i] = false;
@@ -228,12 +254,12 @@ void loop()
 	if(strstr(cmdbuffer[bufindr],"M29") == NULL)
 	{
 	  card.write_command(cmdbuffer[bufindr]);
-	  Serial.println("ok");
+	  SERIAL_PROTOCOLLNPGM("ok");
 	}
 	else
 	{
 	  card.closefile();
-	  Serial.println("Done saving file.");
+	  SERIAL_PROTOCOLLNPGM("Done saving file.");
 	}
       }
       else
@@ -249,6 +275,7 @@ void loop()
   //check heater every n milliseconds
   manage_heater();
   manage_inactivity(1);
+  checkHitEndstops();
   LCD_STATUS;
 }
 
@@ -268,8 +295,9 @@ inline void get_command()
           strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
           gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
           if(gcode_N != gcode_LastN+1 && (strstr(cmdbuffer[bufindw], "M110") == NULL) ) {
-            Serial.print("Serial Error: Line Number is not Last Line Number+1, Last Line:");
-            Serial.println(gcode_LastN);
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM("Line Number is not Last Line Number+1, Last Line:");
+            SERIAL_ERRORLN(gcode_LastN);
             //Serial.println(gcode_N);
             FlushSerialRequestResend();
             serial_count = 0;
@@ -284,8 +312,9 @@ inline void get_command()
             strchr_pointer = strchr(cmdbuffer[bufindw], '*');
 
             if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
-              Serial.print("Error: checksum mismatch, Last Line:");
-              Serial.println(gcode_LastN);
+              SERIAL_ERROR_START;
+              SERIAL_ERRORPGM("checksum mismatch, Last Line:");
+              SERIAL_ERRORLN(gcode_LastN);
               FlushSerialRequestResend();
               serial_count = 0;
               return;
@@ -294,8 +323,9 @@ inline void get_command()
           }
           else 
           {
-            Serial.print("Error: No Checksum with line number, Last Line:");
-            Serial.println(gcode_LastN);
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM("No Checksum with line number, Last Line:");
+            SERIAL_ERRORLN(gcode_LastN);
             FlushSerialRequestResend();
             serial_count = 0;
             return;
@@ -308,8 +338,9 @@ inline void get_command()
         {
           if((strstr(cmdbuffer[bufindw], "*") != NULL))
           {
-            Serial.print("Error: No Line Number with checksum, Last Line:");
-            Serial.println(gcode_LastN);
+            SERIAL_ERROR_START;
+            SERIAL_ERRORPGM("No Line Number with checksum, Last Line:");
+            SERIAL_ERRORLN(gcode_LastN);
             serial_count = 0;
             return;
           }
@@ -325,7 +356,7 @@ inline void get_command()
             if(card.saving)
               break;
 	    #endif //SDSUPPORT
-            Serial.println("ok"); 
+            SERIAL_PROTOCOLLNPGM("ok"); 
             break;
           default:
             break;
@@ -350,22 +381,23 @@ inline void get_command()
     return;
   }
   while( !card.eof()  && buflen < BUFSIZE) {
-    
-    serial_char = card.get();
-    if(serial_char == '\n' || serial_char == '\r' || serial_char == ':' || serial_count >= (MAX_CMD_SIZE - 1)) 
+    int16_t n=card.get();
+    serial_char = (char)n;
+    if(serial_char == '\n' || serial_char == '\r' || serial_char == ':' || serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
     {
      
       if(card.eof()){
         card.sdprinting = false;
-        Serial.println("echo: Done printing file");
+        SERIAL_PROTOCOLLNPGM("Done printing file");
         stoptime=millis();
         char time[30];
         unsigned long t=(stoptime-starttime)/1000;
         int sec,min;
         min=t/60;
         sec=t%60;
-        sprintf(time,"echo: %i min, %i sec",min,sec);
-        Serial.println(time);
+        sprintf(time,"%i min, %i sec",min,sec);
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLN(time);
         LCD_MESSAGE(time);
         card.checkautostart(true);
       }
@@ -386,6 +418,7 @@ inline void get_command()
       if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
     }
   }
+  
   #endif //SDSUPPORT
 
 }
@@ -417,20 +450,25 @@ inline bool code_seen(char code)
     destination[LETTER##_AXIS] = 1.5 * LETTER##_MAX_LENGTH * LETTER##_HOME_DIR; \
     feedrate = homing_feedrate[LETTER##_AXIS]; \
     prepare_move(); \
+    st_synchronize();\
     \
     current_position[LETTER##_AXIS] = 0;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     destination[LETTER##_AXIS] = -5 * LETTER##_HOME_DIR;\
     prepare_move(); \
+    st_synchronize();\
     \
     destination[LETTER##_AXIS] = 10 * LETTER##_HOME_DIR;\
     feedrate = homing_feedrate[LETTER##_AXIS]/2 ;  \
     prepare_move(); \
+    st_synchronize();\
     \
     current_position[LETTER##_AXIS] = (LETTER##_HOME_DIR == -1) ? 0 : LETTER##_MAX_LENGTH;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     destination[LETTER##_AXIS] = current_position[LETTER##_AXIS];\
     feedrate = 0.0;\
+    st_synchronize();\
+    endstops_hit_on_purpose();\
   }
 
 inline void process_commands()
@@ -461,6 +499,7 @@ inline void process_commands()
       previous_millis_cmd = millis();
       return;
     case 4: // G4 dwell
+      LCD_MESSAGEPGM("DWELL...");
       codenum = 0;
       if(code_seen('P')) codenum = code_value(); // milliseconds to wait
       if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
@@ -495,6 +534,7 @@ inline void process_commands()
       feedrate = saved_feedrate;
       feedmultiply = saved_feedmultiply;
       previous_millis_cmd = millis();
+      endstops_hit_on_purpose();
       break;
     case 90: // G90
       relative_mode = false;
@@ -521,13 +561,14 @@ inline void process_commands()
     #ifdef SDSUPPORT
 
     case 20: // M20 - list SD card
-      Serial.println("Begin file list");
+      SERIAL_PROTOCOLLNPGM("Begin file list");
       card.ls();
-      Serial.println("End file list");
+      SERIAL_PROTOCOLLNPGM("End file list");
       break;
     case 21: // M21 - init SD card
       
       card.initsd();
+      
       break;
     case 22: //M22 - release SD card
       card.release();
@@ -579,8 +620,9 @@ inline void process_commands()
       int sec,min;
       min=t/60;
       sec=t%60;
-      sprintf(time,"echo: time needed %i min, %i sec",min,sec);
-      Serial.println(time);
+      sprintf(time,"%i min, %i sec",min,sec);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLN(time);
       LCD_MESSAGE(time);
     }
     break;
@@ -617,37 +659,30 @@ inline void process_commands()
       if (code_seen('S')) setTargetBed(code_value());
       break;
     case 105: // M105
+      //SERIAL_ECHOLN(freeMemory());
+          
       #if (TEMP_0_PIN > -1) || defined (HEATER_USES_AD595)
-        tt = degHotend0();
-      #endif
-      #if TEMP_1_PIN > -1
-          bt = degBed();
-      #endif
-      #if (TEMP_0_PIN > -1) || defined (HEATER_USES_AD595)
-        Serial.print("ok T:");
-        Serial.print(tt); 
+        SERIAL_PROTOCOLPGM("ok T:");
+        SERIAL_PROTOCOL( degHotend0()); 
         #if TEMP_1_PIN > -1 
-          #ifdef PIDTEMP
-            Serial.print(" B:");
-            #if TEMP_1_PIN > -1
-              Serial.println(bt); 
-            #else
-              Serial.println(HeaterPower); 
-            #endif
-          #else //not PIDTEMP
-            Serial.println();
-           #endif //PIDTEMP
-         #else
-            Serial.println();
-          #endif //TEMP_1_PIN
-        #else
-          SERIAL_ERRORLN("No thermistors - no temp");
+          SERIAL_PROTOCOLPGM(" B:");  
+          SERIAL_PROTOCOL(degBed());
+        #endif //TEMP_1_PIN
+      #else
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("No thermistors - no temp");
+      #endif
+      #ifdef PIDTEMP
+        SERIAL_PROTOCOLPGM(" @:");
+        SERIAL_PROTOCOL( HeaterPower); 
+       
       #endif
+        SERIAL_PROTOCOLLN("");
       return;
       break;
     case 109: 
     {// M109 - Wait for extruder heater to reach target.
-        LCD_MESSAGE("Heating...");
+        LCD_MESSAGEPGM("Heating...");
         if (code_seen('S')) setTargetHotend0(code_value());
         
         setWatch();
@@ -668,8 +703,8 @@ inline void process_commands()
         #endif //TEMP_RESIDENCY_TIME
         if( (millis() - codenum) > 1000 ) 
         { //Print Temp Reading every 1 second while heating up/cooling down
-          Serial.print("T:");
-        Serial.println( degHotend0() ); 
+          SERIAL_PROTOCOLPGM("T:");
+          SERIAL_PROTOCOLLN( degHotend0() ); 
           codenum = millis();
         }
         manage_heater();
@@ -685,12 +720,13 @@ inline void process_commands()
           }
         #endif //TEMP_RESIDENCY_TIME
         }
-        LCD_MESSAGE("Heating done.");
+        LCD_MESSAGEPGM("Heating done.");
         starttime=millis();
       }
       break;
     case 190: // M190 - Wait bed for heater to reach target.
     #if TEMP_1_PIN > -1
+        LCD_MESSAGEPGM("Bed Heating.");
         if (code_seen('S')) setTargetBed(code_value());
         codenum = millis(); 
         while(isHeatingBed()) 
@@ -698,16 +734,17 @@ inline void process_commands()
           if( (millis()-codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
           {
             float tt=degHotend0();
-            Serial.print("T:");
-            Serial.println( tt );
-            Serial.print("ok T:");
-            Serial.print( tt ); 
-            Serial.print(" B:");
-            Serial.println( degBed() ); 
+            SERIAL_PROTOCOLPGM("T:");
+            SERIAL_PROTOCOLLN(tt );
+            SERIAL_PROTOCOLPGM("ok T:");
+            SERIAL_PROTOCOL(tt );
+            SERIAL_PROTOCOLPGM(" B:");
+            SERIAL_PROTOCOLLN(degBed() ); 
             codenum = millis(); 
           }
           manage_heater();
         }
+        LCD_MESSAGEPGM("Bed done.");
     #endif
     break;
 
@@ -752,6 +789,7 @@ inline void process_commands()
       else
       { 
         st_synchronize(); 
+        LCD_MESSAGEPGM("Free move.");
         disable_x(); 
         disable_y(); 
         disable_z(); 
@@ -770,53 +808,53 @@ inline void process_commands()
       }
       break;
     case 115: // M115
-      Serial.println("FIRMWARE_NAME:Marlin; Sprinter/grbl mashup for gen6 FIRMWARE_URL:http://www.mendel-parts.com PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:1");
+      SerialprintPGM("FIRMWARE_NAME:Marlin; Sprinter/grbl mashup for gen6 FIRMWARE_URL:http://www.mendel-parts.com PROTOCOL_VERSION:1.0 MACHINE_TYPE:Mendel EXTRUDER_COUNT:1");
       break;
     case 114: // M114
-      Serial.print("X:");
-      Serial.print(current_position[X_AXIS]);
-      Serial.print("Y:");
-      Serial.print(current_position[Y_AXIS]);
-      Serial.print("Z:");
-      Serial.print(current_position[Z_AXIS]);
-      Serial.print("E:");      
-      Serial.print(current_position[E_AXIS]);
+      SERIAL_PROTOCOLPGM("X:");
+      SERIAL_PROTOCOL(current_position[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(current_position[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(current_position[Z_AXIS]);
+      SERIAL_PROTOCOLPGM("E:");      
+      SERIAL_PROTOCOL(current_position[E_AXIS]);
       #ifdef DEBUG_STEPS
-        Serial.print(" Count X:");
-        Serial.print(float(count_position[X_AXIS])/axis_steps_per_unit[X_AXIS]);
-        Serial.print("Y:");
-        Serial.print(float(count_position[Y_AXIS])/axis_steps_per_unit[Y_AXIS]);
-        Serial.print("Z:");
-        Serial.println(float(count_position[Z_AXIS])/axis_steps_per_unit[Z_AXIS]);
+        SERIAL_PROTOCOLPGM(" Count X:");
+        SERIAL_PROTOCOL(float(count_position[X_AXIS])/axis_steps_per_unit[X_AXIS]);
+        SERIAL_PROTOCOLPGM("Y:");
+        SERIAL_PROTOCOL(float(count_position[Y_AXIS])/axis_steps_per_unit[Y_AXIS]);
+        SERIAL_PROTOCOLPGM("Z:");
+        SERIAL_PROTOCOL(float(count_position[Z_AXIS])/axis_steps_per_unit[Z_AXIS]);
       #endif
-      Serial.println("");
+      SERIAL_PROTOCOLLN("");
       break;
     case 119: // M119
       #if (X_MIN_PIN > -1)
-        Serial.print("x_min:");
-        Serial.print((READ(X_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("x_min:");
+        SERIAL_PROTOCOL(((READ(X_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
       #if (X_MAX_PIN > -1)
-        Serial.print("x_max:");
-        Serial.print((READ(X_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("x_max:");
+        SERIAL_PROTOCOL(((READ(X_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
       #if (Y_MIN_PIN > -1)
-        Serial.print("y_min:");
-        Serial.print((READ(Y_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("y_min:");
+        SERIAL_PROTOCOL(((READ(Y_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
       #if (Y_MAX_PIN > -1)
-        Serial.print("y_max:");
-        Serial.print((READ(Y_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("y_max:");
+        SERIAL_PROTOCOL(((READ(Y_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
       #if (Z_MIN_PIN > -1)
-        Serial.print("z_min:");
-        Serial.print((READ(Z_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("z_min:");
+        SERIAL_PROTOCOL(((READ(Z_MIN_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
       #if (Z_MAX_PIN > -1)
-        Serial.print("z_max:");
-        Serial.print((READ(Z_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L ");
+        SERIAL_PROTOCOLPGM("z_max:");
+        SERIAL_PROTOCOL(((READ(Z_MAX_PIN)^ENDSTOPS_INVERTING)?"H ":"L "));
       #endif
-      Serial.println("");
+      SERIAL_PROTOCOLLN("");
       break;
       //TODO: update for all axis, use for loop
     case 201: // M201
@@ -867,8 +905,28 @@ inline void process_commands()
       if(code_seen('P')) Kp = code_value();
       if(code_seen('I')) Ki = code_value()*PID_dT;
       if(code_seen('D')) Kd = code_value()/PID_dT;
+      #ifdef PID_ADD_EXTRUSION_RATE
+      if(code_seen('C')) Kc = code_value();
+      #endif
+      SERIAL_PROTOCOL("ok p:");
+      SERIAL_PROTOCOL(Kp);
+      SERIAL_PROTOCOL(" i:");
+      SERIAL_PROTOCOL(Ki/PID_dT);
+      SERIAL_PROTOCOL(" d:");
+      SERIAL_PROTOCOL(Kd*PID_dT);
+      #ifdef PID_ADD_EXTRUSION_RATE
+      SERIAL_PROTOCOL(" c:");
+      SERIAL_PROTOCOL(Kc*PID_dT);
+      #endif
+      SERIAL_PROTOCOLLN("");
+      
       break;
     #endif //PIDTEMP
+    case 400: // finish all moves
+    {
+      st_synchronize();
+    }
+    break;
     case 500: // Store settings in EEPROM
     {
         StoreSettings();
@@ -889,9 +947,10 @@ inline void process_commands()
   }
   else
   {
-    Serial.print("echo: Unknown command:\"");
-    Serial.print(cmdbuffer[bufindr]);
-    Serial.println("\"");
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPGM("Unknown command:\"");
+    SERIAL_ECHO(cmdbuffer[bufindr]);
+    SERIAL_ECHOLNPGM("\"");
   }
 
   ClearToSend();
@@ -901,8 +960,8 @@ void FlushSerialRequestResend()
 {
   //char cmdbuffer[bufindr][100]="Resend:";
   Serial.flush();
-  Serial.print("Resend:");
-  Serial.println(gcode_LastN + 1);
+  SERIAL_PROTOCOLPGM("Resend:");
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
   ClearToSend();
 }
 
@@ -913,7 +972,7 @@ void ClearToSend()
   if(fromsd[bufindr])
     return;
   #endif //SDSUPPORT
-  Serial.println("ok"); 
+  SERIAL_PROTOCOLLNPGM("ok"); 
 }
 
 inline void get_coordinates()
@@ -987,7 +1046,9 @@ void kill()
   disable_e();
   
   if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
-  SERIAL_ERRORLN("Printer halted. kill() called !!");
+  SERIAL_ERROR_START;
+  SERIAL_ERRORLNPGM("Printer halted. kill() called !!");
+  LCD_MESSAGEPGM("KILLED. ");
   while(1); // Wait for reset
 }
 
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 583c55c..b3f514f 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -30,8 +30,8 @@ public:
   
 
   inline void ls() {root.ls();};
-  inline bool eof() { sdpos = file.curPosition();return sdpos>=filesize ;};
-  inline char get() {  int16_t n = file.read(); return (n!=-1)?(char)n:'\n';};
+  inline bool eof() { return sdpos>=filesize ;};
+  inline int16_t get() {  sdpos = file.curPosition();return (int16_t)file.read();};
   inline void setIndex(long index) {sdpos = index;file.seekSet(index);};
 
 public:
@@ -52,6 +52,35 @@ private:
   bool autostart_stilltocheck; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
 };
   
+
+#else
+class CardReader
+{
+public:
+  inline CardReader(){};
+  
+  inline static void initsd(){};
+  inline static void write_command(char *buf){};
+  
+  inline static void checkautostart(bool x) {}; 
+  
+  inline static void closefile() {};
+  inline static void release(){};
+  inline static void startFileprint(){};
+  inline static void startFilewrite(char *name){};
+  inline static void pauseSDPrint(){};
+  inline static void getStatus(){};
+  
+  inline static void selectFile(char* name){};
+  inline static void getfilename(const uint8_t nr){};
+  inline static uint8_t getnrfilenames(){return 0;};
+  
+
+  inline static void ls() {};
+  inline static bool eof() {return true;};
+  inline static char get() {return 0;};
+  inline static void setIndex(){};
+};
 #endif //SDSUPPORT
   
   
diff --git a/Marlin/cardreader.pde b/Marlin/cardreader.pde
index a49b999..605af11 100644
--- a/Marlin/cardreader.pde
+++ b/Marlin/cardreader.pde
@@ -29,20 +29,24 @@ void CardReader::initsd()
     if (!card.init(SPI_FULL_SPEED,SDSS))
     {
       //if (!card.init(SPI_HALF_SPEED,SDSS))
-      SERIAL_ECHOLN("SD init fail");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("SD init fail");
     }
     else if (!volume.init(&card))
     {
-      SERIAL_ERRORLN("volume.init failed");
+      SERIAL_ERROR_START;
+      SERIAL_ERRORLNPGM("volume.init failed");
     }
     else if (!root.openRoot(&volume)) 
     {
-      SERIAL_ERRORLN("openRoot failed");
+      SERIAL_ERROR_START;
+      SERIAL_ERRORLNPGM("openRoot failed");
     }
     else 
     {
       cardOK = true;
-      SERIAL_ECHOLN("SD card ok");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("SD card ok");
     }
   #endif //SDSS
 }
@@ -76,17 +80,17 @@ void CardReader::selectFile(char* name)
     file.close();
    
     if (file.open(&root, name, O_READ)) {
-      Serial.print("File opened:");
-      Serial.print(name);
-      Serial.print(" Size:");
       filesize = file.fileSize();
-      Serial.println(filesize);
+      SERIAL_PROTOCOLPGM("File opened:");
+      SERIAL_PROTOCOL(name);
+      SERIAL_PROTOCOLPGM(" Size:");
+      SERIAL_PROTOCOLLN(filesize);
       sdpos = 0;
       
-      Serial.println("File selected");
+      SERIAL_PROTOCOLLNPGM("File selected");
     }
     else{
-      Serial.println("file.open failed");
+      SERIAL_PROTOCOLLNPGM("file.open failed");
     }
   }
 }
@@ -101,14 +105,14 @@ void CardReader::startFilewrite(char *name)
     
     if (!file.open(&root, name, O_CREAT | O_APPEND | O_WRITE | O_TRUNC))
     {
-      Serial.print("open failed, File: ");
-      Serial.print(name);
-      Serial.print(".");
+      SERIAL_PROTOCOLPGM("open failed, File: ");
+      SERIAL_PROTOCOL(name);
+      SERIAL_PROTOCOLLNPGM(".");
     }
     else{
       saving = true;
-      Serial.print("Writing to file: ");
-      Serial.println(name);
+      SERIAL_PROTOCOLPGM("Writing to file: ");
+      SERIAL_PROTOCOLLN(name);
     }
   }
 }
@@ -116,13 +120,13 @@ void CardReader::startFilewrite(char *name)
 void CardReader::getStatus()
 {
   if(cardOK){
-    Serial.print("SD printing byte ");
-    Serial.print(sdpos);
-    Serial.print("/");
-    Serial.println(filesize);
+    SERIAL_PROTOCOLPGM("SD printing byte ");
+    SERIAL_PROTOCOL(sdpos);
+    SERIAL_PROTOCOLPGM("/");
+    SERIAL_PROTOCOLLN(filesize);
   }
   else{
-    Serial.println("Not SD printing");
+    SERIAL_PROTOCOLLNPGM("Not SD printing");
   }
 }
 void CardReader::write_command(char *buf)
@@ -143,7 +147,8 @@ void CardReader::write_command(char *buf)
   file.write(begin);
   if (file.writeError)
   {
-    SERIAL_ERRORLN("error writing to file");
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("error writing to file");
   }
 }
 
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 807709e..fbb4f19 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -1,694 +1,694 @@
-#ifndef PINS_H
-#define PINS_H
-
-/****************************************************************************************
-* Arduino pin assignment
-*
-*                  ATMega168
-*                   +-\/-+
-*             PC6  1|    |28  PC5 (AI 5 / D19)
-*       (D 0) PD0  2|    |27  PC4 (AI 4 / D18)
-*       (D 1) PD1  3|    |26  PC3 (AI 3 / D17)
-*       (D 2) PD2  4|    |25  PC2 (AI 2 / D16)
-*  PWM+ (D 3) PD3  5|    |24  PC1 (AI 1 / D15)
-*       (D 4) PD4  6|    |23  PC0 (AI 0 / D14)
-*             VCC  7|    |22  GND
-*             GND  8|    |21  AREF
-*             PB6  9|    |20  AVCC
-*             PB7 10|    |19  PB5 (D 13)
-*  PWM+ (D 5) PD5 11|    |18  PB4 (D 12)
-*  PWM+ (D 6) PD6 12|    |17  PB3 (D 11) PWM
-*       (D 7) PD7 13|    |16  PB2 (D 10) PWM
-*       (D 8) PB0 14|    |15  PB1 (D 9)  PWM
-*                   +----+
-****************************************************************************************/
-#if MOTHERBOARD == 0
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega168__
-#error Oops!  Make sure you have 'Arduino Diecimila' selected from the boards menu.
-#endif
-
-#define X_STEP_PIN          2
-#define X_DIR_PIN           3
-#define X_ENABLE_PIN       -1
-#define X_MIN_PIN           4
-#define X_MAX_PIN           9
-
-#define Y_STEP_PIN         10
-#define Y_DIR_PIN           7
-#define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           8
-#define Y_MAX_PIN          13
-
-#define Z_STEP_PIN         19
-#define Z_DIR_PIN          18
-#define Z_ENABLE_PIN        5
-#define Z_MIN_PIN          17
-#define Z_MAX_PIN          16
-
-#define E_STEP_PIN         11
-#define E_DIR_PIN          12
-#define E_ENABLE_PIN       -1
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN            -1
-#define FAN_PIN            -1
-#define PS_ON_PIN          15
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN        6
-#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-#endif
-
-
-
-/****************************************************************************************
-* Sanguino/RepRap Motherboard with direct-drive extruders
-*
-*                        ATMega644P
-*
-*                        +---\/---+
-*            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-*            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-*       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-*        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-*        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-*       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-*       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-*        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-*                  RST  9|        |32  AREF
-*                  VCC 10|        |31  GND 
-*                  GND 11|        |30  AVCC
-*                XTAL2 12|        |29  PC7 (D 23)
-*                XTAL1 13|        |28  PC6 (D 22)
-*       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-*       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-*  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-*  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-*       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-*       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-*       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-*                        +--------+
-*
-****************************************************************************************/
-#if MOTHERBOARD == 1
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         15
-#define X_DIR_PIN          18
-#define X_ENABLE_PIN       19
-#define X_MIN_PIN          20
-#define X_MAX_PIN          21
-
-#define Y_STEP_PIN         23
-#define Y_DIR_PIN          22
-#define Y_ENABLE_PIN       19
-#define Y_MIN_PIN          25
-#define Y_MAX_PIN          26
-
-#define Z_STEP_PIN         29
-#define Z_DIR_PIN          30
-#define Z_ENABLE_PIN       31
-#define Z_MIN_PIN           2
-#define Z_MAX_PIN           1
-
-#define E_STEP_PIN         12
-#define E_DIR_PIN          16
-#define E_ENABLE_PIN        3
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN             0
-#define FAN_PIN            -1
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       14
-#define TEMP_0_PIN          4 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
-
-
-
-#endif
-
-
-/****************************************************************************************
-* RepRap Motherboard  ****---NOOOOOO RS485/EXTRUDER CONTROLLER!!!!!!!!!!!!!!!!!---*******
-*
-****************************************************************************************/
-#if MOTHERBOARD == 2
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN      15
-#define X_DIR_PIN       18
-#define X_ENABLE_PIN    19
-#define X_MIN_PIN       20
-#define X_MAX_PIN       21
-
-#define Y_STEP_PIN      23
-#define Y_DIR_PIN       22
-#define Y_ENABLE_PIN    24
-#define Y_MIN_PIN       25
-#define Y_MAX_PIN       26
-
-#define Z_STEP_PINN     27
-#define Z_DIR_PINN      28
-#define Z_ENABLE_PIN    29
-#define Z_MIN_PIN       30
-#define Z_MAX_PIN       31
-
-#define E_STEP_PIN      17
-#define E_DIR_PIN       16
-#define E_ENABLE_PIN    -1
-
-#define SDPOWER          -1
-#define SDSS          4
-#define LED_PIN          0
-
-#define SD_CARD_WRITE    2
-#define SD_CARD_DETECT   3
-#define SD_CARD_SELECT   4
-
-//our RS485 pins
-#define TX_ENABLE_PIN	12
-#define RX_ENABLE_PIN	13
-
-//pin for controlling the PSU.
-#define PS_ON_PIN       14
-
-#define FAN_PIN         -1
-#define KILL_PIN        -1
-
-#define HEATER_0_PIN    -1
-#define TEMP_0_PIN      -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-
-
-
-#endif
-
-/****************************************************************************************
-* Arduino Mega pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 33
-#define MOTHERBOARD 3
-#define RAMPS_V_1_3
-#endif
-#if MOTHERBOARD == 3
-#define KNOWN_BOARD 1
-
-//////////////////FIX THIS//////////////
-#ifndef __AVR_ATmega1280__
- #ifndef __AVR_ATmega2560__
- #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
- #endif
-#endif
-
-// uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
-// #define RAMPS_V_1_3
-// #define RAMPS_V_1_0
-
-#ifdef RAMPS_V_1_3
-
-#define X_STEP_PIN         54
-#define X_DIR_PIN          55
-#define X_ENABLE_PIN       38
-#define X_MIN_PIN           3
-#define X_MAX_PIN          -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
-
-#define Y_STEP_PIN         60
-#define Y_DIR_PIN          61
-#define Y_ENABLE_PIN       56
-#define Y_MIN_PIN          14
-#define Y_MAX_PIN          -1   //15
-
-#define Z_STEP_PIN         46
-#define Z_DIR_PIN          48
-#define Z_ENABLE_PIN       62
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          -1   //19
-
-#define E_STEP_PIN         26
-#define E_DIR_PIN          28
-#define E_ENABLE_PIN       24
-
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
-#define FAN_PIN            9
-#define PS_ON_PIN          12
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       10
-#define HEATER_1_PIN       8
-#define HEATER_2_PIN        -1
-#define TEMP_0_PIN         13   // ANALOG NUMBERING
-#define TEMP_1_PIN         14   // ANALOG NUMBERING
-#define TEMP_2_PIN         -1   // ANALOG NUMBERING
-
-
-#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
-
-#define X_STEP_PIN         26
-#define X_DIR_PIN          28
-#define X_ENABLE_PIN       24
-#define X_MIN_PIN           3
-#define X_MAX_PIN          -1    //2
-
-#define Y_STEP_PIN         38
-#define Y_DIR_PIN          40
-#define Y_ENABLE_PIN       36
-#define Y_MIN_PIN          16
-#define Y_MAX_PIN          -1    //17
-
-#define Z_STEP_PIN         44
-#define Z_DIR_PIN          46
-#define Z_ENABLE_PIN       42
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          -1    //19
-
-#define E_STEP_PIN         32
-#define E_DIR_PIN          34
-#define E_ENABLE_PIN       30
-
-#define SDPOWER            48
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-
-
-#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
-  #define HEATER_0_PIN     12    // RAMPS 1.0
-  #define HEATER_1_PIN     -1    // RAMPS 1.0
-  #define FAN_PIN          11    // RAMPS 1.0
-
-#else // RAMPS_V_1_1 or RAMPS_V_1_2
-  #define HEATER_0_PIN     10    // RAMPS 1.1
-  #define HEATER_1_PIN      8    // RAMPS 1.1
-  #define FAN_PIN           9    // RAMPS 1.1
-#endif
-#define HEATER_2_PIN        -1
-#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_2_PIN          -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#endif
-
-// SPI for Max6675 Thermocouple 
-
-#ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  #define SCK_PIN          52
-  #define MISO_PIN         50
-  #define MOSI_PIN         51
-  #define MAX6675_SS       53
-#else
-  #define MAX6675_SS       49
-#endif
-
-
-#endif
-/****************************************************************************************
-* Duemilanove w/ ATMega328P pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 4
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega328P__
-#error Oops!  Make sure you have 'Arduino Duemilanove w/ ATMega328' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         19
-#define X_DIR_PIN          18
-#define X_ENABLE_PIN       -1
-#define X_MIN_PIN          17
-#define X_MAX_PIN          -1
-
-#define Y_STEP_PIN         10
-#define Y_DIR_PIN           7
-#define Y_ENABLE_PIN       -1
-#define Y_MIN_PIN           8
-#define Y_MAX_PIN          -1
-
-#define Z_STEP_PIN         13
-#define Z_DIR_PIN           3
-#define Z_ENABLE_PIN        2
-#define Z_MIN_PIN           4
-#define Z_MAX_PIN          -1
-
-#define E_STEP_PIN         11
-#define E_DIR_PIN          12
-#define E_ENABLE_PIN       -1
-
-#define SDPOWER          -1
-#define SDSS          -1
-#define LED_PIN            -1
-#define FAN_PIN             5
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN        6
-#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define HEATER_1_PIN        -1
-#define HEATER_2_PIN        -1
-
-#endif
-
-/****************************************************************************************
-* Gen6 pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 5
-#define KNOWN_BOARD 1
-
-#ifndef __AVR_ATmega644P__
-    #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-//x axis pins
-    #define X_STEP_PIN      15
-    #define X_DIR_PIN       18
-    #define X_ENABLE_PIN    19
-    #define X_MIN_PIN       20
-    #define X_MAX_PIN       -1
-    
-    //y axis pins
-    #define Y_STEP_PIN      23
-    #define Y_DIR_PIN       22
-    #define Y_ENABLE_PIN    24
-    #define Y_MIN_PIN       25
-    #define Y_MAX_PIN       -1
-    
-    //z axis pins
-    #define Z_STEP_PIN      27
-    #define Z_DIR_PIN       28
-    #define Z_ENABLE_PIN    29
-    #define Z_MIN_PIN       30
-    #define Z_MAX_PIN       -1
-    
-    //extruder pins
-    #define E_STEP_PIN      4     //Edited @ EJE Electronics 20100715
-    #define E_DIR_PIN       2     //Edited @ EJE Electronics 20100715
-    #define E_ENABLE_PIN    3     //Added @ EJE Electronics 20100715
-    #define TEMP_0_PIN      5     //changed @ rkoeppl 20110410
-    #define HEATER_0_PIN    14    //changed @ rkoeppl 20110410
-    #define HEATER_1_PIN    -1    //changed @ rkoeppl 20110410
-    #define HEATER_2_PIN        -1
-    
-    #define SDPOWER          -1
-    #define SDSS          17
-    #define LED_PIN         -1    //changed @ rkoeppl 20110410
-    #define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410
-    #define TEMP_2_PIN      -1
-    #define FAN_PIN         -1    //changed @ rkoeppl 20110410
-    #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
-    //our pin for debugging.
-    
-    #define DEBUG_PIN        0
-    
-    //our RS485 pins
-    #define TX_ENABLE_PIN	12
-    #define RX_ENABLE_PIN	13
-
-#endif
-
-/****************************************************************************************
-* Sanguinololu pin assignment
-*
-****************************************************************************************/
-#if MOTHERBOARD == 62
-#define MOTHERBOARD 6
-#define SANGUINOLOLU_V_1_2 
-#endif
-#if MOTHERBOARD == 6
-#define KNOWN_BOARD 1
-#ifndef __AVR_ATmega644P__
-#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
-#endif
-
-#define X_STEP_PIN         15
-#define X_DIR_PIN          21
-#define X_MIN_PIN          18
-#define X_MAX_PIN           -2
-
-#define Y_STEP_PIN         22
-#define Y_DIR_PIN          23
-#define Y_MIN_PIN          19
-#define Y_MAX_PIN          -1
-
-#define Z_STEP_PIN         3
-#define Z_DIR_PIN          2
-#define Z_MIN_PIN          20
-#define Z_MAX_PIN          -1
-
-#define E_STEP_PIN         1
-#define E_DIR_PIN          0
-
-#define LED_PIN            -1
-
-#define FAN_PIN            -1 
-
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1
-
-#define HEATER_0_PIN       13 // (extruder)
-
-#ifdef SANGUINOLOLU_V_1_2
-
-#define HEATER_1_PIN       12 // (bed)
-#define X_ENABLE_PIN       14
-#define Y_ENABLE_PIN       14
-#define Z_ENABLE_PIN       26
-#define E_ENABLE_PIN       14
-
-#else
-
-#define HEATER_1_PIN       14  // (bed)
-#define X_ENABLE_PIN       -1
-#define Y_ENABLE_PIN       -1
-#define Z_ENABLE_PIN       -1
-#define E_ENABLE_PIN       -1
-
-#endif
-
-#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
-#define TEMP_1_PIN          6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
-#define TEMP_2_PIN         -1
-#define SDPOWER            -1
-#define SDSS               31
-#define HEATER_2_PIN       -1
-
-#endif
-
-
-#if MOTHERBOARD == 7
-#define KNOWN_BOARD
-/*****************************************************************
-* Ultimaker pin assignment
-******************************************************************/
-
-#ifndef __AVR_ATmega1280__
- #ifndef __AVR_ATmega2560__
- #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
- #endif
-#endif
-
-#define X_STEP_PIN 25
-#define X_DIR_PIN 23
-#define X_MIN_PIN 22
-#define X_MAX_PIN 24
-#define X_ENABLE_PIN 27
-
-#define Y_STEP_PIN 31
-#define Y_DIR_PIN 33
-#define Y_MIN_PIN 26
-#define Y_MAX_PIN 28
-#define Y_ENABLE_PIN 29
-
-#define Z_STEP_PIN 37 
-#define Z_DIR_PIN 39
-#define Z_MIN_PIN 30
-#define Z_MAX_PIN 32
-#define Z_ENABLE_PIN 35
-
-#define HEATER_1_PIN 4 
-#define TEMP_1_PIN 11  
-
-#define EXTRUDER_0_STEP_PIN 43 
-#define EXTRUDER_0_DIR_PIN 45
-#define EXTRUDER_0_ENABLE_PIN 41
-#define HEATER_0_PIN  2
-#define TEMP_0_PIN 8   
-
-#define EXTRUDER_1_STEP_PIN 49 
-#define EXTRUDER_1_DIR_PIN 47
-#define EXTRUDER_1_ENABLE_PIN 51
-#define EXTRUDER_1_HEATER_PIN 3
-#define EXTRUDER_1_TEMPERATURE_PIN 10 
-#define HEATER_2_PIN 51
-#define TEMP_2_PIN 3
-
-
-
-#define E_STEP_PIN         EXTRUDER_0_STEP_PIN
-#define E_DIR_PIN          EXTRUDER_0_DIR_PIN
-#define E_ENABLE_PIN       EXTRUDER_0_ENABLE_PIN
-
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
-#define FAN_PIN            7
-#define PS_ON_PIN          12
-#define KILL_PIN           -1
-
-#ifdef ULTRA_LCD
-
-  #ifdef NEWPANEL
-  //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 18
-
-    #define LCD_PINS_RS 20 
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 16
-    #define LCD_PINS_D5 21 
-    #define LCD_PINS_D6 5
-    #define LCD_PINS_D7 6
-    
-    //buttons are directly attached
-    #define BTN_EN1 40
-    #define BTN_EN2 42
-    #define BTN_ENC 19  //the click
-    
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
-    
-    #define SDCARDDETECT 38
-    
-      //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-  #else //old style panel with shift register
-    //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 18
-
-    //buttons are attached to a shift register
-    #define SHIFT_CLK 38
-    #define SHIFT_LD 42
-    #define SHIFT_OUT 40
-    #define SHIFT_EN 17
-    
-    #define LCD_PINS_RS 16 
-    #define LCD_PINS_ENABLE 5
-    #define LCD_PINS_D4 6
-    #define LCD_PINS_D5 21 
-    #define LCD_PINS_D6 20
-    #define LCD_PINS_D7 19
-    
-    //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-
-    
-    //bits in the shift register that carry the buttons for:
-    // left up center down right red
-    #define BL_LE 7
-    #define BL_UP 6
-    #define BL_MI 5
-    #define BL_DW 4
-    #define BL_RI 3
-    #define BL_ST 2
-
-    #define BLEN_B 1
-    #define BLEN_A 0
-  #endif 
-#endif //ULTRA_LCD
-
-#endif
-
-/****************************************************************************************
-* Teensylu 0.7 pin assingments (ATMEGA90USB)
-* Requires the Teensyduino software with Teensy2.0++ selected in arduino IDE!
-****************************************************************************************/
-#if MOTHERBOARD == 8
-#define MOTHERBOARD 8
-#define KNOWN_BOARD 1
-
-
-#define X_STEP_PIN          0  
-#define X_DIR_PIN           1  
-#define X_ENABLE_PIN       39 
-#define X_MIN_PIN          13 
-#define X_MAX_PIN          -1    
-
-#define Y_STEP_PIN          2  
-#define Y_DIR_PIN           3 
-#define Y_ENABLE_PIN       38 
-#define Y_MIN_PIN          14 
-#define Y_MAX_PIN          -1    
-
-#define Z_STEP_PIN          4
-#define Z_DIR_PIN           5 
-#define Z_ENABLE_PIN       23 
-#define Z_MIN_PIN          15 
-#define Z_MAX_PIN          -1    
-
-#define E_STEP_PIN          6  
-#define E_DIR_PIN           7 
-#define E_ENABLE_PIN       19 
-
-
-
-#define HEATER_0_PIN       21  // Extruder
-#define HEATER_1_PIN       20  // Bed
-#define HEATER_2_PIN       -1
-#define FAN_PIN            22  // Fan   
-
-#define TEMP_0_PIN          7  // Extruder
-#define TEMP_1_PIN          6  // Bed
-#define TEMP_2_PIN         -1
-
-#define SDPOWER            -1
-#define SDSS                8
-#define LED_PIN            -1
-#define PS_ON_PIN          -1
-#define KILL_PIN           -1 
-#define ALARM_PIN          -1
-
-#ifndef SDSUPPORT
-// these pins are defined in the SD library if building with SD support  
-  #define SCK_PIN           9 
-  #define MISO_PIN         11 
-  #define MOSI_PIN         10 
-#endif
-#endif
-
-#ifndef KNOWN_BOARD
-#error Unknown MOTHERBOARD value in configuration.h
-#endif
-
-//List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
-#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, E_STEP_PIN, E_DIR_PIN, E_ENABLE_PIN, LED_PIN, PS_ON_PIN, HEATER_0_PIN, HEATER_1_PIN, HEATER_2_PIN, FAN_PIN, TEMP_0_PIN, TEMP_1_PIN, TEMP_2_PIN}
-
+#ifndef PINS_H
+#define PINS_H
+
+/****************************************************************************************
+* Arduino pin assignment
+*
+*                  ATMega168
+*                   +-\/-+
+*             PC6  1|    |28  PC5 (AI 5 / D19)
+*       (D 0) PD0  2|    |27  PC4 (AI 4 / D18)
+*       (D 1) PD1  3|    |26  PC3 (AI 3 / D17)
+*       (D 2) PD2  4|    |25  PC2 (AI 2 / D16)
+*  PWM+ (D 3) PD3  5|    |24  PC1 (AI 1 / D15)
+*       (D 4) PD4  6|    |23  PC0 (AI 0 / D14)
+*             VCC  7|    |22  GND
+*             GND  8|    |21  AREF
+*             PB6  9|    |20  AVCC
+*             PB7 10|    |19  PB5 (D 13)
+*  PWM+ (D 5) PD5 11|    |18  PB4 (D 12)
+*  PWM+ (D 6) PD6 12|    |17  PB3 (D 11) PWM
+*       (D 7) PD7 13|    |16  PB2 (D 10) PWM
+*       (D 8) PB0 14|    |15  PB1 (D 9)  PWM
+*                   +----+
+****************************************************************************************/
+#if MOTHERBOARD == 0
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega168__
+#error Oops!  Make sure you have 'Arduino Diecimila' selected from the boards menu.
+#endif
+
+#define X_STEP_PIN          2
+#define X_DIR_PIN           3
+#define X_ENABLE_PIN       -1
+#define X_MIN_PIN           4
+#define X_MAX_PIN           9
+
+#define Y_STEP_PIN         10
+#define Y_DIR_PIN           7
+#define Y_ENABLE_PIN       -1
+#define Y_MIN_PIN           8
+#define Y_MAX_PIN          13
+
+#define Z_STEP_PIN         19
+#define Z_DIR_PIN          18
+#define Z_ENABLE_PIN        5
+#define Z_MIN_PIN          17
+#define Z_MAX_PIN          16
+
+#define E_STEP_PIN         11
+#define E_DIR_PIN          12
+#define E_ENABLE_PIN       -1
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN            -1
+#define FAN_PIN            -1
+#define PS_ON_PIN          15
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN        6
+#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+#endif
+
+
+
+/****************************************************************************************
+* Sanguino/RepRap Motherboard with direct-drive extruders
+*
+*                        ATMega644P
+*
+*                        +---\/---+
+*            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+*            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+*       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+*        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+*        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+*       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+*       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+*        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+*                  RST  9|        |32  AREF
+*                  VCC 10|        |31  GND 
+*                  GND 11|        |30  AVCC
+*                XTAL2 12|        |29  PC7 (D 23)
+*                XTAL1 13|        |28  PC6 (D 22)
+*       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+*       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+*  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+*  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+*       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+*       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+*       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+*                        +--------+
+*
+****************************************************************************************/
+#if MOTHERBOARD == 1
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         15
+#define X_DIR_PIN          18
+#define X_ENABLE_PIN       19
+#define X_MIN_PIN          20
+#define X_MAX_PIN          21
+
+#define Y_STEP_PIN         23
+#define Y_DIR_PIN          22
+#define Y_ENABLE_PIN       19
+#define Y_MIN_PIN          25
+#define Y_MAX_PIN          26
+
+#define Z_STEP_PIN         29
+#define Z_DIR_PIN          30
+#define Z_ENABLE_PIN       31
+#define Z_MIN_PIN           2
+#define Z_MAX_PIN           1
+
+#define E_STEP_PIN         12
+#define E_DIR_PIN          16
+#define E_ENABLE_PIN        3
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN             0
+#define FAN_PIN            -1
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       14
+#define TEMP_0_PIN          4 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
+
+
+
+#endif
+
+
+/****************************************************************************************
+* RepRap Motherboard  ****---NOOOOOO RS485/EXTRUDER CONTROLLER!!!!!!!!!!!!!!!!!---*******
+*
+****************************************************************************************/
+#if MOTHERBOARD == 2
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN      15
+#define X_DIR_PIN       18
+#define X_ENABLE_PIN    19
+#define X_MIN_PIN       20
+#define X_MAX_PIN       21
+
+#define Y_STEP_PIN      23
+#define Y_DIR_PIN       22
+#define Y_ENABLE_PIN    24
+#define Y_MIN_PIN       25
+#define Y_MAX_PIN       26
+
+#define Z_STEP_PINN     27
+#define Z_DIR_PINN      28
+#define Z_ENABLE_PIN    29
+#define Z_MIN_PIN       30
+#define Z_MAX_PIN       31
+
+#define E_STEP_PIN      17
+#define E_DIR_PIN       16
+#define E_ENABLE_PIN    -1
+
+#define SDPOWER          -1
+#define SDSS          4
+#define LED_PIN          0
+
+#define SD_CARD_WRITE    2
+#define SD_CARD_DETECT   3
+#define SD_CARD_SELECT   4
+
+//our RS485 pins
+#define TX_ENABLE_PIN	12
+#define RX_ENABLE_PIN	13
+
+//pin for controlling the PSU.
+#define PS_ON_PIN       14
+
+#define FAN_PIN         -1
+#define KILL_PIN        -1
+
+#define HEATER_0_PIN    -1
+#define TEMP_0_PIN      -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+
+
+
+#endif
+
+/****************************************************************************************
+* Arduino Mega pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 33
+#define MOTHERBOARD 3
+#define RAMPS_V_1_3
+#endif
+#if MOTHERBOARD == 3
+#define KNOWN_BOARD 1
+
+//////////////////FIX THIS//////////////
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+// uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
+// #define RAMPS_V_1_3
+// #define RAMPS_V_1_0
+
+#ifdef RAMPS_V_1_3
+
+#define X_STEP_PIN         54
+#define X_DIR_PIN          55
+#define X_ENABLE_PIN       38
+#define X_MIN_PIN           3
+#define X_MAX_PIN          -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+#define Y_STEP_PIN         60
+#define Y_DIR_PIN          61
+#define Y_ENABLE_PIN       56
+#define Y_MIN_PIN          14
+#define Y_MAX_PIN          -1   //15
+
+#define Z_STEP_PIN         46
+#define Z_DIR_PIN          48
+#define Z_ENABLE_PIN       62
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          -1   //19
+
+#define E_STEP_PIN         26
+#define E_DIR_PIN          28
+#define E_ENABLE_PIN       24
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+#define FAN_PIN            9
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       10
+#define HEATER_1_PIN       8
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN         13   // ANALOG NUMBERING
+#define TEMP_1_PIN         14   // ANALOG NUMBERING
+#define TEMP_2_PIN         -1   // ANALOG NUMBERING
+
+
+#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default
+
+#define X_STEP_PIN         26
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       24
+#define X_MIN_PIN           3
+#define X_MAX_PIN          -1    //2
+
+#define Y_STEP_PIN         38
+#define Y_DIR_PIN          40
+#define Y_ENABLE_PIN       36
+#define Y_MIN_PIN          16
+#define Y_MAX_PIN          -1    //17
+
+#define Z_STEP_PIN         44
+#define Z_DIR_PIN          46
+#define Z_ENABLE_PIN       42
+#define Z_MIN_PIN          18
+#define Z_MAX_PIN          -1    //19
+
+#define E_STEP_PIN         32
+#define E_DIR_PIN          34
+#define E_ENABLE_PIN       30
+
+#define SDPOWER            48
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+
+
+#ifdef RAMPS_V_1_0 // RAMPS_V_1_0
+  #define HEATER_0_PIN     12    // RAMPS 1.0
+  #define HEATER_1_PIN     -1    // RAMPS 1.0
+  #define FAN_PIN          11    // RAMPS 1.0
+
+#else // RAMPS_V_1_1 or RAMPS_V_1_2
+  #define HEATER_0_PIN     10    // RAMPS 1.1
+  #define HEATER_1_PIN      8    // RAMPS 1.1
+  #define FAN_PIN           9    // RAMPS 1.1
+#endif
+#define HEATER_2_PIN        -1
+#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN          1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_2_PIN          -1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#endif
+
+// SPI for Max6675 Thermocouple 
+
+#ifndef SDSUPPORT
+// these pins are defined in the SD library if building with SD support  #define SCK_PIN          52
+  #define MISO_PIN         50
+  #define MOSI_PIN         51
+  #define MAX6675_SS       53
+#else
+  #define MAX6675_SS       49
+#endif
+
+
+#endif
+/****************************************************************************************
+* Duemilanove w/ ATMega328P pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 4
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega328P__
+#error Oops!  Make sure you have 'Arduino Duemilanove w/ ATMega328' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         19
+#define X_DIR_PIN          18
+#define X_ENABLE_PIN       -1
+#define X_MIN_PIN          17
+#define X_MAX_PIN          -1
+
+#define Y_STEP_PIN         10
+#define Y_DIR_PIN           7
+#define Y_ENABLE_PIN       -1
+#define Y_MIN_PIN           8
+#define Y_MAX_PIN          -1
+
+#define Z_STEP_PIN         13
+#define Z_DIR_PIN           3
+#define Z_ENABLE_PIN        2
+#define Z_MIN_PIN           4
+#define Z_MAX_PIN          -1
+
+#define E_STEP_PIN         11
+#define E_DIR_PIN          12
+#define E_ENABLE_PIN       -1
+
+#define SDPOWER          -1
+#define SDSS          -1
+#define LED_PIN            -1
+#define FAN_PIN             5
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN        6
+#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define HEATER_1_PIN        -1
+#define HEATER_2_PIN        -1
+
+#endif
+
+/****************************************************************************************
+* Gen6 pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 5
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega644P__
+    #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+//x axis pins
+    #define X_STEP_PIN      15
+    #define X_DIR_PIN       18
+    #define X_ENABLE_PIN    19
+    #define X_MIN_PIN       20
+    #define X_MAX_PIN       -1
+    
+    //y axis pins
+    #define Y_STEP_PIN      23
+    #define Y_DIR_PIN       22
+    #define Y_ENABLE_PIN    24
+    #define Y_MIN_PIN       25
+    #define Y_MAX_PIN       -1
+    
+    //z axis pins
+    #define Z_STEP_PIN      27
+    #define Z_DIR_PIN       28
+    #define Z_ENABLE_PIN    29
+    #define Z_MIN_PIN       30
+    #define Z_MAX_PIN       -1
+    
+    //extruder pins
+    #define E_STEP_PIN      4     //Edited @ EJE Electronics 20100715
+    #define E_DIR_PIN       2     //Edited @ EJE Electronics 20100715
+    #define E_ENABLE_PIN    3     //Added @ EJE Electronics 20100715
+    #define TEMP_0_PIN      5     //changed @ rkoeppl 20110410
+    #define HEATER_0_PIN    14    //changed @ rkoeppl 20110410
+    #define HEATER_1_PIN    -1    //changed @ rkoeppl 20110410
+    #define HEATER_2_PIN        -1
+    
+    #define SDPOWER          -1
+    #define SDSS          17
+    #define LED_PIN         -1    //changed @ rkoeppl 20110410
+    #define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410
+    #define TEMP_2_PIN      -1
+    #define FAN_PIN         -1    //changed @ rkoeppl 20110410
+    #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
+    //our pin for debugging.
+    
+    #define DEBUG_PIN        0
+    
+    //our RS485 pins
+    #define TX_ENABLE_PIN	12
+    #define RX_ENABLE_PIN	13
+
+#endif
+
+/****************************************************************************************
+* Sanguinololu pin assignment
+*
+****************************************************************************************/
+#if MOTHERBOARD == 62
+#define MOTHERBOARD 6
+#define SANGUINOLOLU_V_1_2 
+#endif
+#if MOTHERBOARD == 6
+#define KNOWN_BOARD 1
+#ifndef __AVR_ATmega644P__
+#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define X_STEP_PIN         15
+#define X_DIR_PIN          21
+#define X_MIN_PIN          18
+#define X_MAX_PIN           -2
+
+#define Y_STEP_PIN         22
+#define Y_DIR_PIN          23
+#define Y_MIN_PIN          19
+#define Y_MAX_PIN          -1
+
+#define Z_STEP_PIN         3
+#define Z_DIR_PIN          2
+#define Z_MIN_PIN          20
+#define Z_MAX_PIN          -1
+
+#define E_STEP_PIN         1
+#define E_DIR_PIN          0
+
+#define LED_PIN            -1
+
+#define FAN_PIN            -1 
+
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+
+#define HEATER_0_PIN       13 // (extruder)
+
+#ifdef SANGUINOLOLU_V_1_2
+
+#define HEATER_1_PIN       12 // (bed)
+#define X_ENABLE_PIN       14
+#define Y_ENABLE_PIN       14
+#define Z_ENABLE_PIN       26
+#define E_ENABLE_PIN       14
+
+#else
+
+#define HEATER_1_PIN       14  // (bed)
+#define X_ENABLE_PIN       -1
+#define Y_ENABLE_PIN       -1
+#define Z_ENABLE_PIN       -1
+#define E_ENABLE_PIN       -1
+
+#endif
+
+#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
+#define TEMP_1_PIN          6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
+#define TEMP_2_PIN         -1
+#define SDPOWER            -1
+#define SDSS               31
+#define HEATER_2_PIN       -1
+
+#endif
+
+
+#if MOTHERBOARD == 7
+#define KNOWN_BOARD
+/*****************************************************************
+* Ultimaker pin assignment
+******************************************************************/
+
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+#define X_STEP_PIN 25
+#define X_DIR_PIN 23
+#define X_MIN_PIN 22
+#define X_MAX_PIN 24
+#define X_ENABLE_PIN 27
+
+#define Y_STEP_PIN 31
+#define Y_DIR_PIN 33
+#define Y_MIN_PIN 26
+#define Y_MAX_PIN 28
+#define Y_ENABLE_PIN 29
+
+#define Z_STEP_PIN 37 
+#define Z_DIR_PIN 39
+#define Z_MIN_PIN 30
+#define Z_MAX_PIN 32
+#define Z_ENABLE_PIN 35
+
+#define HEATER_1_PIN 4 
+#define TEMP_1_PIN 11  
+
+#define EXTRUDER_0_STEP_PIN 43 
+#define EXTRUDER_0_DIR_PIN 45
+#define EXTRUDER_0_ENABLE_PIN 41
+#define HEATER_0_PIN  2
+#define TEMP_0_PIN 8   
+
+#define EXTRUDER_1_STEP_PIN 49 
+#define EXTRUDER_1_DIR_PIN 47
+#define EXTRUDER_1_ENABLE_PIN 51
+#define EXTRUDER_1_HEATER_PIN 3
+#define EXTRUDER_1_TEMPERATURE_PIN 10 
+#define HEATER_2_PIN 51
+#define TEMP_2_PIN 3
+
+
+
+#define E_STEP_PIN         EXTRUDER_0_STEP_PIN
+#define E_DIR_PIN          EXTRUDER_0_DIR_PIN
+#define E_ENABLE_PIN       EXTRUDER_0_ENABLE_PIN
+
+#define SDPOWER            -1
+#define SDSS               53
+#define LED_PIN            13
+#define FAN_PIN            7
+#define PS_ON_PIN          12
+#define KILL_PIN           -1
+
+#ifdef ULTRA_LCD
+
+  #ifdef NEWPANEL
+  //arduino pin witch triggers an piezzo beeper
+    #define BEEPER 18
+
+    #define LCD_PINS_RS 20 
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 16
+    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D6 5
+    #define LCD_PINS_D7 6
+    
+    //buttons are directly attached
+    #define BTN_EN1 40
+    #define BTN_EN2 42
+    #define BTN_ENC 19  //the click
+    
+    #define BLEN_C 2
+    #define BLEN_B 1
+    #define BLEN_A 0
+    
+    #define SDCARDDETECT 38
+    
+      //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+  #else //old style panel with shift register
+    //arduino pin witch triggers an piezzo beeper
+    #define BEEPER 18
+
+    //buttons are attached to a shift register
+    #define SHIFT_CLK 38
+    #define SHIFT_LD 42
+    #define SHIFT_OUT 40
+    #define SHIFT_EN 17
+    
+    #define LCD_PINS_RS 16 
+    #define LCD_PINS_ENABLE 5
+    #define LCD_PINS_D4 6
+    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D6 20
+    #define LCD_PINS_D7 19
+    
+    //encoder rotation values
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+
+    
+    //bits in the shift register that carry the buttons for:
+    // left up center down right red
+    #define BL_LE 7
+    #define BL_UP 6
+    #define BL_MI 5
+    #define BL_DW 4
+    #define BL_RI 3
+    #define BL_ST 2
+
+    #define BLEN_B 1
+    #define BLEN_A 0
+  #endif 
+#endif //ULTRA_LCD
+
+#endif
+
+/****************************************************************************************
+* Teensylu 0.7 pin assingments (ATMEGA90USB)
+* Requires the Teensyduino software with Teensy2.0++ selected in arduino IDE!
+****************************************************************************************/
+#if MOTHERBOARD == 8
+#define MOTHERBOARD 8
+#define KNOWN_BOARD 1
+
+
+#define X_STEP_PIN          0  
+#define X_DIR_PIN           1  
+#define X_ENABLE_PIN       39 
+#define X_MIN_PIN          13 
+#define X_MAX_PIN          -1    
+
+#define Y_STEP_PIN          2  
+#define Y_DIR_PIN           3 
+#define Y_ENABLE_PIN       38 
+#define Y_MIN_PIN          14 
+#define Y_MAX_PIN          -1    
+
+#define Z_STEP_PIN          4
+#define Z_DIR_PIN           5 
+#define Z_ENABLE_PIN       23 
+#define Z_MIN_PIN          15 
+#define Z_MAX_PIN          -1    
+
+#define E_STEP_PIN          6  
+#define E_DIR_PIN           7 
+#define E_ENABLE_PIN       19 
+
+
+
+#define HEATER_0_PIN       21  // Extruder
+#define HEATER_1_PIN       20  // Bed
+#define HEATER_2_PIN       -1
+#define FAN_PIN            22  // Fan   
+
+#define TEMP_0_PIN          7  // Extruder
+#define TEMP_1_PIN          6  // Bed
+#define TEMP_2_PIN         -1
+
+#define SDPOWER            -1
+#define SDSS                8
+#define LED_PIN            -1
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1 
+#define ALARM_PIN          -1
+
+#ifndef SDSUPPORT
+// these pins are defined in the SD library if building with SD support  
+  #define SCK_PIN           9 
+  #define MISO_PIN         11 
+  #define MOSI_PIN         10 
+#endif
+#endif
+
+#ifndef KNOWN_BOARD
+#error Unknown MOTHERBOARD value in configuration.h
+#endif
+
+//List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
+#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, E_STEP_PIN, E_DIR_PIN, E_ENABLE_PIN, LED_PIN, PS_ON_PIN, HEATER_0_PIN, HEATER_1_PIN, HEATER_2_PIN, FAN_PIN, TEMP_0_PIN, TEMP_1_PIN, TEMP_2_PIN}
+
 #endif
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index fe19055..998a609 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -86,6 +86,10 @@ long position[4];   //rescaled from extern when axis_steps_per_unit are changed
 static float previous_speed[4]; // Speed of previous path line segment
 static float previous_nominal_speed; // Nominal speed of previous path line segment
 
+#ifdef AUTOTEMP
+float high_e_speed=0;
+#endif
+
 
 //===========================================================================
 //=============================private variables ============================
@@ -372,6 +376,34 @@ block_t *plan_get_current_block() {
   return(block);
 }
 
+#ifdef AUTOTEMP
+void getHighESpeed()
+{
+  if(degTargetHotend0()+2<AUTOTEMP_MIN)  //probably temperature set to zero.
+    return; //do nothing
+  float high=0;
+  char block_index = block_buffer_tail;
+  
+  while(block_index != block_buffer_head) {
+    float se=block_buffer[block_index].speed_e;
+    if(se>high)
+    {
+      high=se;
+    }
+    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
+  }
+  high_e_speed=high*axis_steps_per_unit[E_AXIS]/(1000000.0);  //so it is independent of the esteps/mm. before 
+   
+  float g=AUTOTEMP_MIN+high_e_speed*AUTOTEMP_FACTOR;
+  float t=constrain(AUTOTEMP_MIN,g,AUTOTEMP_MAX);
+  setTargetHotend0(t);
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPAIR("highe",high_e_speed);
+  SERIAL_ECHOPAIR(" t",t);
+  SERIAL_ECHOLN("");
+}
+#endif
+
 void check_axes_activity() {
   unsigned char x_active = 0;
   unsigned char y_active = 0;  
@@ -686,7 +718,9 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   memcpy(position, target, sizeof(target)); // position[] = target[]
 
   planner_recalculate();
-  
+  #ifdef AUTOTEMP
+    getHighESpeed();
+  #endif
   st_wake_up();
 }
 
@@ -702,4 +736,4 @@ void plan_set_position(const float &x, const float &y, const float &z, const flo
   previous_speed[2] = 0.0;
   previous_speed[3] = 0.0;
 }
-
+
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 40f214e..f5c01ea 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -92,5 +92,7 @@ extern float max_xy_jerk; //speed than can be stopped at once, if i understand c
 extern float max_z_jerk;
 extern float mintravelfeedrate;
 extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];
-
-#endif
+#ifdef AUTOTEMP
+extern float high_e_speed;
+#endif
+#endif
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index e50818c..2f5f3a8 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -33,12 +33,14 @@
 #include "speed_lookuptable.h"
 
 
+
 //===========================================================================
 //=============================public variables  ============================
 //===========================================================================
 block_t *current_block;  // A pointer to the block currently being traced
 
 
+
 //===========================================================================
 //=============================private variables ============================
 //===========================================================================
@@ -62,7 +64,9 @@ static long acceleration_time, deceleration_time;
 static unsigned short acc_step_rate; // needed for deccelaration start point
 static char step_loops;
 
-
+volatile long endstops_trigsteps[3]={0,0,0};
+volatile long endstops_stepsTotal,endstops_stepsDone;
+static volatile bool endstops_hit=false;
 
 // if DEBUG_STEPS is enabled, M114 can be used to compare two methods of determining the X,Y,Z position of the printer.
 // for debugging purposes only, should be disabled by default
@@ -152,9 +156,49 @@ asm volatile ( \
 #define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1<<OCIE1A)
 
 
+void endstops_triggered(const unsigned long &stepstaken)  
+{
+  //this will only work if there is no bufferig
+  //however, if you perform a move at which the endstops should be triggered, and wait for it to complete, i.e. by blocking command, it should work
+  //yes, it uses floats, but: if endstops are triggered, thats hopefully not critical anymore anyways.
+  //endstops_triggerpos;
+  
+  if(endstops_hit) //hitting a second time while the first hit is not reported
+    return;
+  if(current_block == NULL)
+    return;
+  endstops_stepsTotal=current_block->step_event_count;
+  endstops_stepsDone=stepstaken;
+  endstops_trigsteps[0]=current_block->steps_x;
+  endstops_trigsteps[1]=current_block->steps_y;
+  endstops_trigsteps[2]=current_block->steps_z;
+
+  endstops_hit=true;
+}
 
+void checkHitEndstops()
+{
+  if( !endstops_hit)
+   return;
+  float endstops_triggerpos[3]={0,0,0};
+  float ratiodone=endstops_stepsDone/float(endstops_stepsTotal);  //ratio of current_block thas was performed
+  
+  endstops_triggerpos[0]=current_position[0]-(endstops_trigsteps[0]*ratiodone)/float(axis_steps_per_unit[0]);
+  endstops_triggerpos[1]=current_position[1]-(endstops_trigsteps[1]*ratiodone)/float(axis_steps_per_unit[1]);
+  endstops_triggerpos[2]=current_position[2]-(endstops_trigsteps[2]*ratiodone)/float(axis_steps_per_unit[2]);
+ SERIAL_ECHO_START;
+ SERIAL_ECHOPGM("endstops hit: ");
+ SERIAL_ECHOPAIR(" X:",endstops_triggerpos[0]);
+ SERIAL_ECHOPAIR(" Y:",endstops_triggerpos[1]);
+ SERIAL_ECHOPAIR(" Z:",endstops_triggerpos[2]);
+ SERIAL_ECHOLN("");
+ endstops_hit=false;
+}
 
-
+void endstops_hit_on_purpose()
+{
+  endstops_hit=false;
+}
 
 //         __________________________
 //        /|                        |\     _________________         ^
@@ -232,7 +276,9 @@ inline void trapezoid_generator_reset() {
 ISR(TIMER1_COMPA_vect)
 {        
   if(busy){ 
-/*    SERIAL_ERRORLN(*(unsigned short *)OCR1A<< " ISR overtaking itself.");*/
+    SERIAL_ERROR_START
+    SERIAL_ERROR(*(unsigned short *)OCR1A);
+    SERIAL_ERRORLNPGM(" ISR overtaking itself.");
     return; 
   } // The busy-flag is used to avoid reentering this interrupt
 
@@ -294,6 +340,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if X_MIN_PIN > -1
             if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
+              endstops_triggered(step_events_completed);
               step_events_completed = current_block->step_event_count;
             }
       #endif
@@ -305,6 +352,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if X_MAX_PIN > -1
         if((READ(X_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_x >0)){
+          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
         #endif
@@ -317,6 +365,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Y_MIN_PIN > -1
         if(READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) {
+          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -328,6 +377,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Y_MAX_PIN > -1
       if((READ(Y_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y >0)){
+          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -340,6 +390,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Z_MIN_PIN > -1
         if(READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) {
+          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -351,6 +402,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Z_MAX_PIN > -1
         if((READ(Z_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_z >0)){
+          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -614,4 +666,4 @@ void st_synchronize()
     manage_inactivity(1);
     LCD_STATUS;
   }   
-}
+}
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index fb64969..ecbc713 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -39,6 +39,13 @@ void st_wake_up();
   extern volatile long count_position[NUM_AXIS];
   extern volatile int count_direction[NUM_AXIS];
 #endif
+  
+void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered
+void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();
+
+
 
 extern block_t *current_block;  // A pointer to the block currently being traced
+
+
 #endif
diff --git a/Marlin/streaming.h b/Marlin/streaming.h
deleted file mode 100644
index 1a6afe7..0000000
--- a/Marlin/streaming.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-Streaming.h - Arduino library for supporting the << streaming operator
-Copyright (c) 2010 Mikal Hart.  All rights reserved.
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef ARDUINO_STREAMING
-#define ARDUINO_STREAMING
-
-//#include <WProgram.h>
-
-#define STREAMING_LIBRARY_VERSION 4
-
-// Generic template
-template<class T> 
-inline Print &operator <<(Print &stream, T arg) 
-{ stream.print(arg); return stream; }
-
-struct _BASED 
-{ 
-  long val; 
-  int base;
-  _BASED(long v, int b): val(v), base(b) 
-  {}
-};
-
-#define _HEX(a)     _BASED(a, HEX)
-#define _DEC(a)     _BASED(a, DEC)
-#define _OCT(a)     _BASED(a, OCT)
-#define _BIN(a)     _BASED(a, BIN)
-#define _BYTE(a)    _BASED(a, BYTE)
-
-// Specialization for class _BASED
-// Thanks to Arduino forum user Ben Combee who suggested this 
-// clever technique to allow for expressions like
-//   Serial << _HEX(a);
-
-inline Print &operator <<(Print &obj, const _BASED &arg)
-{ obj.print(arg.val, arg.base); return obj; } 
-
-#if ARDUINO >= 18
-// Specialization for class _FLOAT
-// Thanks to Michael Margolis for suggesting a way
-// to accommodate Arduino 0018's floating point precision
-// feature like this:
-//   Serial << _FLOAT(gps_latitude, 6); // 6 digits of precision
-
-struct _FLOAT
-{
-  float val;
-  int digits;
-  _FLOAT(double v, int d): val(v), digits(d)
-  {}
-};
-
-inline Print &operator <<(Print &obj, const _FLOAT &arg)
-{ obj.print(arg.val, arg.digits); return obj; }
-#endif
-
-// Specialization for enum _EndLineCode
-// Thanks to Arduino forum user Paul V. who suggested this
-// clever technique to allow for expressions like
-//   Serial << "Hello!" << endl;
-
-enum _EndLineCode { endl };
-
-inline Print &operator <<(Print &obj, _EndLineCode arg) 
-{ obj.println(); return obj; }
-
-#endif
-
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index a39cc40..3e6edee 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -35,7 +35,6 @@
 #include "pins.h"
 #include "Marlin.h"
 #include "ultralcd.h"
-#include "streaming.h"
 #include "temperature.h"
 #include "watchdog.h"
 
@@ -160,11 +159,13 @@ void manage_heater()
 //            pTerm+=Kc*current_block->speed_e; //additional heating if extrusion speed is high
 //          #endif
           pid_output = constrain(pTerm + iTerm - dTerm, 0, PID_MAX);
+          
         }
     #endif //PID_OPENLOOP
     #ifdef PID_DEBUG
-     SERIAL_ECHOLN(" PIDDEBUG Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm<<" iTerm "<<iTerm<<" dTerm "<<dTerm);  
+     //SERIAL_ECHOLN(" PIDDEBUG Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm<<" iTerm "<<iTerm<<" dTerm "<<dTerm);  
     #endif //PID_DEBUG
+    HeaterPower=pid_output;
     analogWrite(HEATER_0_PIN, pid_output);
   #endif //PIDTEMP
 
@@ -253,7 +254,7 @@ int temp2analogBed(int celsius) {
 
     return (1023 * OVERSAMPLENR) - raw;
   #elif defined BED_USES_AD595
-    return celsius * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
+    return lround(celsius * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
   #endif
 }
 
@@ -464,7 +465,8 @@ ISR(TIMER0_COMPB_vect)
       temp_count++;
       break;
     default:
-      SERIAL_ERRORLN("Temp measurement error!");
+      SERIAL_ERROR_START;
+      SERIAL_ERRORLNPGM("Temp measurement error!");
       break;
   }
     
@@ -498,7 +500,8 @@ ISR(TIMER0_COMPB_vect)
         if(current_raw[TEMPSENSOR_HOTEND_0] >= maxttemp_0) {
           target_raw[TEMPSENSOR_HOTEND_0] = 0;
           analogWrite(HEATER_0_PIN, 0);
-          SERIAL_ERRORLN("Temperature extruder 0 switched off. MAXTEMP triggered !!");
+          SERIAL_ERROR_START;
+          SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MAXTEMP triggered !!");
           kill();
         }
       #endif
@@ -509,7 +512,8 @@ ISR(TIMER0_COMPB_vect)
         target_raw[TEMPSENSOR_HOTEND_1] = 0;
       if(current_raw[2] >= maxttemp_1) {
         analogWrite(HEATER_2_PIN, 0);
-        SERIAL_ERRORLN("Temperature extruder 1 switched off. MAXTEMP triggered !!");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MAXTEMP triggered !!");
         kill()
       }
     #endif
@@ -520,7 +524,8 @@ ISR(TIMER0_COMPB_vect)
       if(current_raw[TEMPSENSOR_HOTEND_0] <= minttemp_0) {
         target_raw[TEMPSENSOR_HOTEND_0] = 0;
         analogWrite(HEATER_0_PIN, 0);
-        SERIAL_ERRORLN("Temperature extruder 0 switched off. MINTEMP triggered !!");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MINTEMP triggered !!");
         kill();
       }
     #endif
@@ -531,7 +536,8 @@ ISR(TIMER0_COMPB_vect)
       if(current_raw[TEMPSENSOR_HOTEND_1] <= minttemp_1) {
         target_raw[TEMPSENSOR_HOTEND_1] = 0;
         analogWrite(HEATER_2_PIN, 0);
-        SERIAL_ERRORLN("Temperature extruder 1 switched off. MINTEMP triggered !!");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MINTEMP triggered !!");
         kill();
       }
     #endif
@@ -542,7 +548,8 @@ ISR(TIMER0_COMPB_vect)
       if(current_raw[1] <= bed_minttemp) {
         target_raw[1] = 0;
         WRITE(HEATER_1_PIN, 0);
-        SERIAL_ERRORLN("Temperatur heated bed switched off. MINTEMP triggered !!");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperatur heated bed switched off. MINTEMP triggered !!");
         kill();
       }
     #endif
@@ -553,7 +560,8 @@ ISR(TIMER0_COMPB_vect)
       if(current_raw[1] >= bed_maxttemp) {
         target_raw[1] = 0;
         WRITE(HEATER_1_PIN, 0);
-        SERIAL_ERRORLN("Temperature heated bed switched off. MAXTEMP triggered !!");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
         kill();
       }
     #endif
@@ -561,4 +569,4 @@ ISR(TIMER0_COMPB_vect)
   }
 }
 
-
+
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 0822e50..4c72532 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -83,6 +83,7 @@
 
 
   #define LCD_MESSAGE(x) lcd_status(x);
+  #define LCD_MESSAGEPGM(x) lcd_statuspgm(PSTR(x));
   #define LCD_STATUS lcd_status()
 #else //no lcd
   #define LCD_STATUS
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index 981aa81..d951671 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -42,6 +42,19 @@ static long previous_millis_buttons=0;
  
 static MainMenu menu;
 
+#include <avr/pgmspace.h>
+
+void lcdProgMemprint(const char *str)
+{
+  char ch=pgm_read_byte(str);
+  while(ch)
+  {
+    lcd.print(ch);
+    ch=pgm_read_byte(++str);
+  }
+}
+#define lcdprintPGM(x) lcdProgMemprint(PSTR(x))
+
 
 //===========================================================================
 //=============================functions         ============================
@@ -54,6 +67,20 @@ void lcd_status(const char* message)
   strncpy(messagetext,message,LCD_WIDTH);
 }
 
+void lcd_statuspgm(const char* message)
+{
+  char ch=pgm_read_byte(message);
+  char *target=messagetext;
+  uint8_t cnt=0;
+  while(ch &&cnt<LCD_WIDTH)
+  {
+    *target=ch;
+    target++;
+    cnt++;
+    ch=pgm_read_byte(++message);
+  }
+}
+
 inline void clear()
 {
   lcd.clear();
@@ -92,7 +119,7 @@ void lcd_init()
   lcd.createChar(2,Thermometer);
   lcd.createChar(3,uplevel);
   lcd.createChar(4,refresh);
-  LCD_MESSAGE(fillto(LCD_WIDTH,"UltiMarlin ready."));
+  LCD_MESSAGEPGM("UltiMarlin ready.");
 }
 
 
@@ -264,9 +291,9 @@ void MainMenu::showStatus()
     feedmultiplychanged=false;
     encoderpos=feedmultiply;
     clear();
-    lcd.setCursor(0,0);lcd.print("\002123/567\001 ");
+    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
     #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-      lcd.setCursor(10,0);lcd.print("B123/567\001 ");
+      lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
     #endif
   }
     
@@ -311,7 +338,7 @@ void MainMenu::showStatus()
     
     if(starttime!=oldtime)
     {
-      lcd.print(itostr2(time/60));lcd.print("h ");lcd.print(itostr2(time%60));lcd.print("m");
+      lcd.print(itostr2(time/60));lcdprintPGM("h ");lcd.print(itostr2(time%60));lcdprintPGM("m");
       oldtime=time;
     }
   }
@@ -320,7 +347,7 @@ void MainMenu::showStatus()
   if((currentz!=oldzpos)||force_lcd_update)
   {
     lcd.setCursor(10,1);
-    lcd.print("Z:");lcd.print(itostr31(currentz));
+    lcdprintPGM("Z:");lcd.print(itostr31(currentz));
     oldzpos=currentz;
   }
   static int oldfeedmultiply=0;
@@ -339,7 +366,7 @@ void MainMenu::showStatus()
   {
    oldfeedmultiply=curfeedmultiply;
    lcd.setCursor(0,2);
-   lcd.print(itostr3(curfeedmultiply));lcd.print("% ");
+   lcd.print(itostr3(curfeedmultiply));lcdprintPGM("% ");
   }
   if(messagetext[0]!='\0')
   {
@@ -353,9 +380,9 @@ void MainMenu::showStatus()
   if(force_lcd_update)  //initial display of content
   {
     encoderpos=feedmultiply;
-    lcd.setCursor(0,0);lcd.print("\002123/567\001 ");
+    lcd.setCursor(0,0);lcdprintPGM("\002123/567\001 ");
     #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-    lcd.setCursor(10,0);lcd.print("B123/567\001 ");
+    lcd.setCursor(10,0);lcdprintPGM("B123/567\001 ");
     #endif
   }
     
@@ -405,7 +432,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Prepare");
+          lcd.setCursor(0,line);lcdprintPGM(" Prepare");
         }
         if((activeline==line) && CLICKED)
         {
@@ -418,7 +445,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Auto Home");
+          lcd.setCursor(0,line);lcdprintPGM(" Auto Home");
         }
         if((activeline==line) && CLICKED)
         {
@@ -431,7 +458,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Set Origin");
+          lcd.setCursor(0,line);lcdprintPGM(" Set Origin");
           
         }
         if((activeline==line) && CLICKED)
@@ -445,7 +472,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Preheat"); 
+          lcd.setCursor(0,line);lcdprintPGM(" Preheat"); 
         }
         if((activeline==line) && CLICKED)
         {
@@ -458,7 +485,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Extrude");
+          lcd.setCursor(0,line);lcdprintPGM(" Extrude");
         }
         if((activeline==line) && CLICKED)
         {
@@ -472,7 +499,7 @@ void MainMenu::showPrepare()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Disable Steppers");
+          lcd.setCursor(0,line);lcdprintPGM(" Disable Steppers");
         }
         if((activeline==line) && CLICKED)
         {
@@ -541,7 +568,7 @@ void MainMenu::showControl()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Control");
+          lcd.setCursor(0,line);lcdprintPGM(" Control");
         }
         if((activeline==line) && CLICKED)
         {
@@ -554,7 +581,7 @@ void MainMenu::showControl()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" \002Nozzle:");
+          lcd.setCursor(0,line);lcdprintPGM(" \002Nozzle:");
           lcd.setCursor(13,line);lcd.print(ftostr3(intround(degHotend0())));
         }
         
@@ -588,7 +615,7 @@ void MainMenu::showControl()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Fan speed:");
+          lcd.setCursor(0,line);lcdprintPGM(" Fan speed:");
           lcd.setCursor(13,line);lcd.print(ftostr3(fanpwm));
         }
         
@@ -625,8 +652,8 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Acc:");
-          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcd.print("00");
+          lcd.setCursor(0,line);lcdprintPGM(" Acc:");
+          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
         }
         
         if((activeline==line) )
@@ -650,7 +677,7 @@ void MainMenu::showControl()
           {
             if(encoderpos<5) encoderpos=5;
             if(encoderpos>990) encoderpos=990;
-            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcd.print("00");
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
           }
         }
       }break;
@@ -658,7 +685,7 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Vxy-jerk: ");
+          lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
           lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk/60));
         }
         
@@ -692,7 +719,7 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" PID-P: ");
+          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
           lcd.setCursor(13,line);lcd.print(itostr4(Kp));
         }
         
@@ -726,7 +753,7 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" PID-I: ");
+          lcd.setCursor(0,line);lcdprintPGM(" PID-I: ");
           lcd.setCursor(13,line);lcd.print(ftostr51(Ki));
         }
         
@@ -760,7 +787,7 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" PID-D: ");
+          lcd.setCursor(0,line);lcdprintPGM(" PID-D: ");
           lcd.setCursor(13,line);lcd.print(itostr4(Kd));
         }
         
@@ -797,7 +824,7 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" PID-C: ");
+          lcd.setCursor(0,line);lcdprintPGM(" PID-C: ");
           lcd.setCursor(13,line);lcd.print(itostr3(Kc));
         }
         
@@ -834,11 +861,11 @@ void MainMenu::showControl()
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Vmax ");
-          if(i==ItemC_vmaxx)lcd.print("x:");
-          if(i==ItemC_vmaxy)lcd.print("y:");
-          if(i==ItemC_vmaxz)lcd.print("z:");
-          if(i==ItemC_vmaxe)lcd.print("e:");
+          lcd.setCursor(0,line);lcdprintPGM(" Vmax ");
+          if(i==ItemC_vmaxx)lcdprintPGM("x:");
+          if(i==ItemC_vmaxy)lcdprintPGM("y:");
+          if(i==ItemC_vmaxz)lcdprintPGM("z:");
+          if(i==ItemC_vmaxe)lcdprintPGM("e:");
           lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemC_vmaxx]/60));
         }
         
@@ -873,7 +900,7 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Vmin:");
+          lcd.setCursor(0,line);lcdprintPGM(" Vmin:");
           lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate/60));
         }
         
@@ -907,7 +934,7 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" VTrav min:");
+          lcd.setCursor(0,line);lcdprintPGM(" VTrav min:");
           lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate/60));
         }
         
@@ -945,12 +972,12 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Amax ");
-          if(i==ItemC_amaxx)lcd.print("x:");
-          if(i==ItemC_amaxy)lcd.print("y:");
-          if(i==ItemC_amaxz)lcd.print("z:");
-          if(i==ItemC_amaxe)lcd.print("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemC_amaxx]/100));lcd.print("00");
+          lcd.setCursor(0,line);lcdprintPGM(" Amax ");
+          if(i==ItemC_amaxx)lcdprintPGM("x:");
+          if(i==ItemC_amaxy)lcdprintPGM("y:");
+          if(i==ItemC_amaxz)lcdprintPGM("z:");
+          if(i==ItemC_amaxe)lcdprintPGM("e:");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemC_amaxx]/100));lcdprintPGM("00");
         }
         
         if((activeline==line) )
@@ -974,7 +1001,7 @@ void MainMenu::showControl()
           {
             if(encoderpos<1) encoderpos=1;
             if(encoderpos>990) encoderpos=990;
-            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcd.print("00");
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
           }
         }
       }break;
@@ -982,8 +1009,8 @@ void MainMenu::showControl()
     {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" A-retract:");
-          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcd.print("00");
+          lcd.setCursor(0,line);lcdprintPGM(" A-retract:");
+          lcd.setCursor(13,line);lcd.print(ftostr3(retract_acceleration/100));lcdprintPGM("00");
         }
         
         if((activeline==line) )
@@ -1008,7 +1035,7 @@ void MainMenu::showControl()
           {
             if(encoderpos<10) encoderpos=10;
             if(encoderpos>990) encoderpos=990;
-            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcd.print("00");
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
           }
         }
       }break;
@@ -1016,7 +1043,7 @@ void MainMenu::showControl()
          {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" Esteps/mm:");
+          lcd.setCursor(0,line);lcdprintPGM(" Esteps/mm:");
           lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
         }
         
@@ -1053,7 +1080,7 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
       {
-        lcd.setCursor(0,line);lcd.print(" Store EPROM");
+        lcd.setCursor(0,line);lcdprintPGM(" Store EPROM");
       }
       if((activeline==line) && CLICKED)
       {
@@ -1067,7 +1094,7 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
       {
-        lcd.setCursor(0,line);lcd.print(" Load EPROM");
+        lcd.setCursor(0,line);lcdprintPGM(" Load EPROM");
       }
       if((activeline==line) && CLICKED)
       {
@@ -1081,7 +1108,7 @@ void MainMenu::showControl()
     {
       if(force_lcd_update)
       {
-        lcd.setCursor(0,line);lcd.print(" Restore Failsafe");
+        lcd.setCursor(0,line);lcdprintPGM(" Restore Failsafe");
       }
       if((activeline==line) && CLICKED)
       {
@@ -1165,7 +1192,7 @@ void MainMenu::showSD()
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcd.print(" File");
+          lcd.setCursor(0,line);lcdprintPGM(" File");
         }
         if((activeline==line) && CLICKED)
         {
@@ -1185,11 +1212,11 @@ void MainMenu::showSD()
           if(true)
           #endif
           {
-            lcd.print(" \004Refresh");
+            lcdprintPGM(" \004Refresh");
           }
           else
           {
-            lcd.print(" \004Insert Card");
+            lcdprintPGM(" \004Insert Card");
           }
           
         }
@@ -1210,7 +1237,7 @@ void MainMenu::showSD()
         {
           card.getfilename(i-2);
           //Serial.print("Filenr:");Serial.println(i-2);
-          lcd.setCursor(0,line);lcd.print(" ");lcd.print(card.filename);
+          lcd.setCursor(0,line);lcdprintPGM(" ");lcd.print(card.filename);
         }
         if((activeline==line) && CLICKED)
         {
@@ -1292,7 +1319,7 @@ void MainMenu::showMainMenu()
     { 
       case ItemM_watch:
       {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcd.print(" Watch   \x7E");}
+        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Watch   \x7E");}
         if((activeline==line)&&CLICKED)
         {
           BLOCK;
@@ -1302,7 +1329,7 @@ void MainMenu::showMainMenu()
       } break;
       case ItemM_prepare:
       {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcd.print(" Prepare \x7E");}
+        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Prepare \x7E");}
         if((activeline==line)&&CLICKED)
         {
           BLOCK;
@@ -1313,7 +1340,7 @@ void MainMenu::showMainMenu()
        
       case ItemM_control:
       {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcd.print(" Control \x7E");}
+        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Control \x7E");}
         if((activeline==line)&&CLICKED)
         {
           BLOCK;
@@ -1334,13 +1361,13 @@ void MainMenu::showMainMenu()
           #endif
           {
             if(card.sdprinting)
-              lcd.print(" Stop Print   \x7E");
+              lcdprintPGM(" Stop Print   \x7E");
             else
-              lcd.print(" Card Menu    \x7E");
+              lcdprintPGM(" Card Menu    \x7E");
           }
           else
           {
-           lcd.print(" No Card"); 
+           lcdprintPGM(" No Card"); 
           }
         }
         #ifdef CARDINSERTED
@@ -1356,7 +1383,8 @@ void MainMenu::showMainMenu()
       }break;
       #endif
       default: 
-        SERIAL_ERRORLN("Something is wrong in the MenuStructure.");
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Something is wrong in the MenuStructure.");
       break;
     }
   }
diff --git a/Marlin/watchdog.pde b/Marlin/watchdog.pde
index 167bc63..9cf710a 100644
--- a/Marlin/watchdog.pde
+++ b/Marlin/watchdog.pde
@@ -41,10 +41,11 @@ ISR(WDT_vect)
   {
  
     #ifdef RESET_MANUAL
-      LCD_MESSAGE("Please Reset!");
-      SERIAL_ERRORLN("Something is wrong, please turn off the printer.");
+      LCD_MESSAGEPGM("Please Reset!");
+      SERIAL_ERROR_START;
+      SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
     #else
-      LCD_MESSAGE("Timeout, resetting!");
+      LCD_MESSAGEPGM("Timeout, resetting!");
     #endif 
     //disable watchdog, it will survife reboot.
     WDTCSR |= (1<<WDCE) | (1<<WDE);

commit ac82411c73e43d6b4730c865c38301d355e0fa35 (from 9980ceb4a37ec1d2cae99b73ceae146ef7340e88)
Merge: 65934ee 9980ceb
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Sun Nov 13 20:46:44 2011 +0100

    Merge remote-tracking branch 'origin/Marlin_v1' into Marlin_v1

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 8661ae4..6c8b3a4 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -9,6 +9,15 @@
 //#define BAUDRATE 230400
 
 
+// Frequency limit
+// See nophead's blog for more info
+#define XY_FREQUENCY_LIMIT  15
+
+// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end
+// of the buffer and all stops. This should not be much greater than zero and should only be changed
+// if unwanted behavior is observed on a user's machine when running at very slow speeds.
+#define MINIMUM_PLANNER_SPEED 2.0 // (mm/sec)
+
 // BASIC SETTINGS: select your board type, thermistor type, axis scaling, and endstop configuration
 
 //// The following define selects which electronics board you have. Please choose the one that matches your setup
@@ -156,6 +165,11 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 #define DISABLE_E false
 
 // Inverting axis direction
+//#define INVERT_X_DIR false    // for Mendel set to false, for Orca set to true
+//#define INVERT_Y_DIR true   // for Mendel set to true, for Orca set to false
+//#define INVERT_Z_DIR false    // for Mendel set to false, for Orca set to true
+//#define INVERT_E_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false
+
 #define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
 #define INVERT_Y_DIR false   // for Mendel set to true, for Orca set to false
 #define INVERT_Z_DIR true    // for Mendel set to false, for Orca set to true
@@ -176,7 +190,7 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
 //note: on bernhards ultimaker 200 200 12 are working well.
-#define HOMING_FEEDRATE {50*60, 50*60, 12*60, 0}  // set the homing speeds
+#define HOMING_FEEDRATE {50*60, 50*60, 4*60, 0}  // set the homing speeds (mm/min)
 
 #define AXIS_RELATIVE_MODES {false, false, false, false}
 
@@ -185,19 +199,20 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 // default settings 
 
 #define DEFAULT_AXIS_STEPS_PER_UNIT   {79.87220447,79.87220447,200*8/3,14}                    // default steps per unit for ultimaker 
-#define DEFAULT_MAX_FEEDRATE          {160*60, 160*60, 10*60, 500000}        
-#define DEFAULT_MAX_ACCELERATION      {9000,9000,150,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
+//#define DEFAULT_AXIS_STEPS_PER_UNIT   {40, 40, 3333.92, 67} 
+#define DEFAULT_MAX_FEEDRATE          {500, 500, 10, 500000}    // (mm/min)    
+#define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
 #define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves 
 #define DEFAULT_RETRACT_ACCELERATION  7000   // X, Y, Z and E max acceleration in mm/s^2 for r retracts
 
-#define DEFAULT_MINIMUMFEEDRATE       10     // minimum feedrate
-#define DEFAULT_MINTRAVELFEEDRATE     10
+#define DEFAULT_MINIMUMFEEDRATE       0     // minimum feedrate
+#define DEFAULT_MINTRAVELFEEDRATE     0
 
 // minimum time in microseconds that a movement needs to take if the buffer is emptied.   Increase this number if you see blobs while printing high speed & high detail.  It will slowdown on the detailed stuff.
 #define DEFAULT_MINSEGMENTTIME        20000
-#define DEFAULT_XYJERK                30.0*60    
-#define DEFAULT_ZJERK                 10.0*60
+#define DEFAULT_XYJERK                30.0    // (mm/sec)
+#define DEFAULT_ZJERK                 0.4     // (mm/sec)
 
 
 
@@ -296,9 +311,9 @@ const int dropsegments=0; //everything with less than this number of steps  will
 // The number of linear motions that can be in the plan at any give time.  
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
 #if defined SDSUPPORT
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 8   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
-  #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
+  #define BLOCK_BUFFER_SIZE 8 // maximize block buffer
 #endif
 
 
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index e15f025..7ef5399 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -115,7 +115,9 @@ extern float HeaterPower;
 //===========================================================================
 //=============================public variables=============================
 //===========================================================================
+#ifdef SDSUPPORT
 CardReader card;
+#endif
 float homing_feedrate[] = HOMING_FEEDRATE;
 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
 volatile int feedmultiply=100; //100->1 200->2
@@ -241,7 +243,9 @@ void loop()
 {
   if(buflen<3)
     get_command();
+  #ifdef SDSUPPORT
   card.checkautostart(false);
+  #endif
   if(buflen)
   {
     #ifdef SDSUPPORT
@@ -992,7 +996,7 @@ inline void get_arc_coordinates()
 
 void prepare_move()
 {
-  plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60.0/100.0);
+  plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0);
   for(int8_t i=0; i < NUM_AXIS; i++) {
     current_position[i] = destination[i];
   }
@@ -1002,7 +1006,7 @@ void prepare_arc_move(char isclockwise) {
   float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc
 
   // Trace the arc
-  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60.0/100.0, r, isclockwise);
+  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise);
   
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 863b116..998a609 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -1,629 +1,739 @@
-/*
-  planner.c - buffers movement commands and manages the acceleration profile plan
-  Part of Grbl
-
-  Copyright (c) 2009-2011 Simen Svale Skogsrud
-
-  Grbl is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  Grbl is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/* The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis. */
-
-/*  
-  Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
-  
-  s == speed, a == acceleration, t == time, d == distance
-
-  Basic definitions:
-
-    Speed[s_, a_, t_] := s + (a*t) 
-    Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
-
-  Distance to reach a specific speed with a constant acceleration:
-
-    Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
-      d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
-
-  Speed after a given distance of travel with constant acceleration:
-
-    Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
-      m -> Sqrt[2 a d + s^2]    
-
-    DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
-
-  When to start braking (di) to reach a specified destionation speed (s2) after accelerating
-  from initial speed s1 without ever stopping at a plateau:
-
-    Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
-      di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
-
-    IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
-*/
-                                                                                                            
-
-//#include <inttypes.h>
-//#include <math.h>       
-//#include <stdlib.h>
-
-#include "Marlin.h"
-#include "Configuration.h"
-#include "pins.h"
-#include "fastio.h"
-#include "planner.h"
-#include "stepper.h"
-#include "temperature.h"
-#include "ultralcd.h"
-
-//===========================================================================
-//=============================public variables ============================
-//===========================================================================
-
-unsigned long minsegmenttime;
-float max_feedrate[4]; // set the max speeds
-float axis_steps_per_unit[4];
-long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
-float minimumfeedrate;
-float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
-float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
-float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
-float max_z_jerk;
-float mintravelfeedrate;
-unsigned long axis_steps_per_sqr_second[NUM_AXIS];
-
-// The current position of the tool in absolute steps
-long position[4];   //rescaled from extern when axis_steps_per_unit are changed by gcode
-
-#ifdef AUTOTEMP
-float high_e_speed=0;
-#endif
-
-
-//===========================================================================
-//=============================private variables ============================
-//===========================================================================
-static block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions
-static volatile unsigned char block_buffer_head;           // Index of the next block to be pushed
-static volatile unsigned char block_buffer_tail;           // Index of the block to process now
-
-
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-#define ONE_MINUTE_OF_MICROSECONDS 60000000.0
-
-// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the 
-// given acceleration:
-inline float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {
-  if (acceleration!=0) {
-  return((target_rate*target_rate-initial_rate*initial_rate)/
-         (2.0*acceleration));
-  }
-  else {
-    return 0.0;  // acceleration was 0, set acceleration distance to 0
-  }
-}
-
-// This function gives you the point at which you must start braking (at the rate of -acceleration) if 
-// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after
-// a total travel of distance. This can be used to compute the intersection point between acceleration and
-// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)
-
-inline float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {
- if (acceleration!=0) {
-  return((2.0*acceleration*distance-initial_rate*initial_rate+final_rate*final_rate)/
-         (4.0*acceleration) );
-  }
-  else {
-    return 0.0;  // acceleration was 0, set intersection distance to 0
-  }
-}
-
-// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.
-
-void calculate_trapezoid_for_block(block_t *block, float entry_speed, float exit_speed) {
-  if(block->busy == true) return; // If block is busy then bail out.
-  float entry_factor = entry_speed / block->nominal_speed;
-  float exit_factor = exit_speed / block->nominal_speed;
-  long initial_rate = ceil(block->nominal_rate*entry_factor);
-  long final_rate = ceil(block->nominal_rate*exit_factor);
-  
-  #ifdef ADVANCE
-    long initial_advance = block->advance*entry_factor*entry_factor;
-    long final_advance = block->advance*exit_factor*exit_factor;
-  #endif // ADVANCE
-
-  // Limit minimal step rate (Otherwise the timer will overflow.)
-  if(initial_rate <120) initial_rate=120;
-  if(final_rate < 120) final_rate=120;
-  
-  // Calculate the acceleration steps
-  long acceleration = block->acceleration_st;
-  long accelerate_steps = estimate_acceleration_distance(initial_rate, block->nominal_rate, acceleration);
-  long decelerate_steps = estimate_acceleration_distance(final_rate, block->nominal_rate, acceleration);
-  // Calculate the size of Plateau of Nominal Rate. 
-  long plateau_steps = block->step_event_count-accelerate_steps-decelerate_steps;
-
-  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
-  // have to use intersection_distance() to calculate when to abort acceleration and start braking 
-  // in order to reach the final_rate exactly at the end of this block.
-  if (plateau_steps < 0) {  
-    accelerate_steps = intersection_distance(initial_rate, final_rate, acceleration, block->step_event_count);
-    plateau_steps = 0;
-  }  
-
-  long decelerate_after = accelerate_steps+plateau_steps;
-
-  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
-  if(block->busy == false) { // Don't update variables if block is busy.
-    block->accelerate_until = accelerate_steps;
-    block->decelerate_after = decelerate_after;
-    block->initial_rate = initial_rate;
-    block->final_rate = final_rate;
-  #ifdef ADVANCE
-      block->initial_advance = initial_advance;
-      block->final_advance = final_advance;
-  #endif //ADVANCE
-  }
-  CRITICAL_SECTION_END;
-}                    
-
-// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the 
-// acceleration within the allotted distance.
-inline float max_allowable_speed(float acceleration, float target_velocity, float distance) {
-  return  sqrt(target_velocity*target_velocity-2*acceleration*60*60*distance);
-}
-
-// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
-// This method will calculate the junction jerk as the euclidean distance between the nominal 
-// velocities of the respective blocks.
-inline float junction_jerk(block_t *before, block_t *after) {
-  return sqrt(
-    pow((before->speed_x-after->speed_x), 2)+pow((before->speed_y-after->speed_y), 2));
-}
-
-// Return the safe speed which is max_jerk/2, e.g. the 
-// speed under which you cannot exceed max_jerk no matter what you do.
-float safe_speed(block_t *block) {
-  float safe_speed;
-  safe_speed = max_xy_jerk/2;  
-  if(abs(block->speed_z) > max_z_jerk/2) 
-    safe_speed = max_z_jerk/2;
-  if (safe_speed > block->nominal_speed) 
-    safe_speed = block->nominal_speed;
-  return safe_speed;  
-}
-
-// The kernel called by planner_recalculate() when scanning the plan from last to first entry.
-void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {
-  if(!current) { 
-    return; 
-  }
-
-  float entry_speed = current->nominal_speed;
-  float exit_factor;
-  float exit_speed;
-  if (next) {
-    exit_speed = next->entry_speed;
-  } 
-  else {
-    exit_speed = safe_speed(current);
-  }
-
-  // Calculate the entry_factor for the current block. 
-  if (previous) {
-    // Reduce speed so that junction_jerk is within the maximum allowed
-    float jerk = junction_jerk(previous, current);
-    if((previous->steps_x == 0) && (previous->steps_y == 0)) {
-      entry_speed = safe_speed(current);
-    }
-    else if (jerk > max_xy_jerk) {
-      entry_speed = (max_xy_jerk/jerk) * entry_speed;
-    } 
-    if(abs(previous->speed_z - current->speed_z) > max_z_jerk) {
-      entry_speed = (max_z_jerk/abs(previous->speed_z - current->speed_z)) * entry_speed;
-    } 
-    // If the required deceleration across the block is too rapid, reduce the entry_factor accordingly.
-    if (entry_speed > exit_speed) {
-      float max_entry_speed = max_allowable_speed(-current->acceleration,exit_speed, current->millimeters);
-      if (max_entry_speed < entry_speed) {
-        entry_speed = max_entry_speed;
-      }
-    }    
-  } 
-  else {
-    entry_speed = safe_speed(current);
-  }
-  // Store result
-  current->entry_speed = entry_speed;
-}
-
-// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
-// implements the reverse pass.
-void planner_reverse_pass() {
-  char block_index = block_buffer_head;
-  if(((block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1)) > 3) {
-    block_index = (block_buffer_head - 3) & (BLOCK_BUFFER_SIZE - 1);
-    block_t *block[5] = {
-      NULL, NULL, NULL, NULL, NULL  };
-    while(block_index != block_buffer_tail) { 
-      block_index = (block_index-1) & (BLOCK_BUFFER_SIZE -1); 
-      block[2]= block[1];
-      block[1]= block[0];
-      block[0] = &block_buffer[block_index];
-      planner_reverse_pass_kernel(block[0], block[1], block[2]);
-    }
-    planner_reverse_pass_kernel(NULL, block[0], block[1]);
-  }
-}
-
-// The kernel called by planner_recalculate() when scanning the plan from first to last entry.
-void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {
-  if(!current) { 
-    return; 
-  }
-  if(previous) {
-    // If the previous block is an acceleration block, but it is not long enough to 
-    // complete the full speed change within the block, we need to adjust out entry
-    // speed accordingly. Remember current->entry_factor equals the exit factor of 
-    // the previous block.
-    if(previous->entry_speed < current->entry_speed) {
-      float max_entry_speed = max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters);
-      if (max_entry_speed < current->entry_speed) {
-        current->entry_speed = max_entry_speed;
-      }
-    }
-  }
-}
-
-// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
-// implements the forward pass.
-void planner_forward_pass() {
-  char block_index = block_buffer_tail;
-  block_t *block[3] = {
-    NULL, NULL, NULL  };
-
-  while(block_index != block_buffer_head) {
-    block[0] = block[1];
-    block[1] = block[2];
-    block[2] = &block_buffer[block_index];
-    planner_forward_pass_kernel(block[0],block[1],block[2]);
-    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
-  }
-  planner_forward_pass_kernel(block[1], block[2], NULL);
-}
-
-// Recalculates the trapezoid speed profiles for all blocks in the plan according to the 
-// entry_factor for each junction. Must be called by planner_recalculate() after 
-// updating the blocks.
-void planner_recalculate_trapezoids() {
-  char block_index = block_buffer_tail;
-  block_t *current;
-  block_t *next = NULL;
-  while(block_index != block_buffer_head) {
-    current = next;
-    next = &block_buffer[block_index];
-    if (current) {
-      calculate_trapezoid_for_block(current, current->entry_speed, next->entry_speed);      
-    }
-    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
-  }
-  calculate_trapezoid_for_block(next, next->entry_speed, safe_speed(next));
-}
-
-// Recalculates the motion plan according to the following algorithm:
-//
-//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) 
-//      so that:
-//     a. The junction jerk is within the set limit
-//     b. No speed reduction within one block requires faster deceleration than the one, true constant 
-//        acceleration.
-//   2. Go over every block in chronological order and dial down junction speed reduction values if 
-//     a. The speed increase within one block would require faster accelleration than the one, true 
-//        constant acceleration.
-//
-// When these stages are complete all blocks have an entry_factor that will allow all speed changes to 
-// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than 
-// the set limit. Finally it will:
-//
-//   3. Recalculate trapezoids for all blocks.
-
-void planner_recalculate() {   
-  planner_reverse_pass();
-  planner_forward_pass();
-  planner_recalculate_trapezoids();
-}
-
-void plan_init() {
-  block_buffer_head = 0;
-  block_buffer_tail = 0;
-  memset(position, 0, sizeof(position)); // clear position
-}
-
-
-void plan_discard_current_block() {
-  if (block_buffer_head != block_buffer_tail) {
-    block_buffer_tail = (block_buffer_tail + 1) & (BLOCK_BUFFER_SIZE - 1);  
-  }
-}
-
-block_t *plan_get_current_block() {
-  if (block_buffer_head == block_buffer_tail) { 
-    return(NULL); 
-  }
-  block_t *block = &block_buffer[block_buffer_tail];
-  block->busy = true;
-  return(block);
-}
-
-#ifdef AUTOTEMP
-void getHighESpeed()
-{
-  if(degTargetHotend0()+2<AUTOTEMP_MIN)  //probably temperature set to zero.
-    return; //do nothing
-  float high=0;
-  char block_index = block_buffer_tail;
-  
-  while(block_index != block_buffer_head) {
-    float se=block_buffer[block_index].speed_e;
-    if(se>high)
-    {
-      high=se;
-    }
-    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
-  }
-  high_e_speed=high*axis_steps_per_unit[E_AXIS]/(1000000.0);  //so it is independent of the esteps/mm. before 
-   
-  float g=AUTOTEMP_MIN+high_e_speed*AUTOTEMP_FACTOR;
-  float t=constrain(AUTOTEMP_MIN,g,AUTOTEMP_MAX);
-  setTargetHotend0(t);
-  SERIAL_ECHO_START;
-  SERIAL_ECHOPAIR("highe",high_e_speed);
-  SERIAL_ECHOPAIR(" t",t);
-  SERIAL_ECHOLN("");
-}
-#endif
-
-void check_axes_activity() {
-  unsigned char x_active = 0;
-  unsigned char y_active = 0;  
-  unsigned char z_active = 0;
-  unsigned char e_active = 0;
-  block_t *block;
-
-  if(block_buffer_tail != block_buffer_head) {
-    char block_index = block_buffer_tail;
-    while(block_index != block_buffer_head) {
-      block = &block_buffer[block_index];
-      if(block->steps_x != 0) x_active++;
-      if(block->steps_y != 0) y_active++;
-      if(block->steps_z != 0) z_active++;
-      if(block->steps_e != 0) e_active++;
-      block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
-    }
-  }
-  if((DISABLE_X) && (x_active == 0)) disable_x();
-  if((DISABLE_Y) && (y_active == 0)) disable_y();
-  if((DISABLE_Z) && (z_active == 0)) disable_z();
-  if((DISABLE_E) && (e_active == 0)) disable_e();
-}
-
-// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in 
-// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration
-// calculation the caller must also provide the physical length of the line in millimeters.
-void plan_buffer_line(const float &x, const float &y, const float &z, const float &e,  float feed_rate)
-{
-  // Calculate the buffer head after we push this byte
-  int next_buffer_head = (block_buffer_head + 1) & (BLOCK_BUFFER_SIZE - 1);
-
-  // If the buffer is full: good! That means we are well ahead of the robot. 
-  // Rest here until there is room in the buffer.
-  while(block_buffer_tail == next_buffer_head) { 
-    manage_heater(); 
-    manage_inactivity(1); 
-    LCD_STATUS;
-  }
-
-  // The target position of the tool in absolute steps
-  // Calculate target position in absolute steps
-  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
-  long target[4];
-  target[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
-  target[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
-  target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
-  target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]); 
-  
-  // Prepare to set up new block
-  block_t *block = &block_buffer[block_buffer_head];
-  
-  // Mark block as not busy (Not executed by the stepper interrupt)
-  block->busy = false;
-
-  // Number of steps for each axis
-  block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
-  block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
-  block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
-  block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
-  block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));
-
-  // Bail if this is a zero-length block
-  if (block->step_event_count <=dropsegments) { 
-    return; 
-  };
-
-  //enable active axes
-  if(block->steps_x != 0) enable_x();
-  if(block->steps_y != 0) enable_y();
-  if(block->steps_z != 0) enable_z();
-  if(block->steps_e != 0) enable_e();
-
-  float delta_x_mm = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
-  float delta_y_mm = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
-  float delta_z_mm = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
-  float delta_e_mm = (target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS];
-  block->millimeters = sqrt(square(delta_x_mm) + square(delta_y_mm) + square(delta_z_mm) + square(delta_e_mm));
-
-  unsigned long microseconds;
-
-  if (block->steps_e == 0) {
-        if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
-  }
-  else {
-    	if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
-  } 
-
-  microseconds = lround((block->millimeters/feed_rate)*1000000);
-
-  // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
-  // reduces/removes corner blobs as the machine won't come to a full stop.
-  int blockcount=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
-  
-  if ((blockcount>0) && (blockcount < (BLOCK_BUFFER_SIZE - 4))) {
-    if (microseconds<minsegmenttime)  { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
-        microseconds=microseconds+lround(2*(minsegmenttime-microseconds)/blockcount);
-    }
-  }
-  else {
-    if (microseconds<minsegmenttime) microseconds=minsegmenttime;
-  }
-  //  END OF SLOW DOWN SECTION  
-  
-  
-  // Calculate speed in mm/minute for each axis
-  float multiplier = 60.0*1000000.0/microseconds;
-  block->speed_z = delta_z_mm * multiplier; 
-  block->speed_x = delta_x_mm * multiplier;
-  block->speed_y = delta_y_mm * multiplier;
-  block->speed_e = delta_e_mm * multiplier; 
-
-
-  // Limit speed per axis
-  float speed_factor = 1; //factor <=1 do decrease speed
-  if(abs(block->speed_x) > max_feedrate[X_AXIS]) {
-    speed_factor = max_feedrate[X_AXIS] / abs(block->speed_x);
-    //if(speed_factor > tmp_speed_factor) speed_factor = tmp_speed_factor; /is not need here because auf the init above
-  }
-  if(abs(block->speed_y) > max_feedrate[Y_AXIS]){
-    float tmp_speed_factor = max_feedrate[Y_AXIS] / abs(block->speed_y);
-    if(speed_factor > tmp_speed_factor) speed_factor = tmp_speed_factor;
-  }
-  if(abs(block->speed_z) > max_feedrate[Z_AXIS]){
-    float tmp_speed_factor = max_feedrate[Z_AXIS] / abs(block->speed_z);
-    if(speed_factor > tmp_speed_factor) speed_factor = tmp_speed_factor;
-  }
-  if(abs(block->speed_e) > max_feedrate[E_AXIS]){
-    float tmp_speed_factor = max_feedrate[E_AXIS] / abs(block->speed_e);
-    if(speed_factor > tmp_speed_factor) speed_factor = tmp_speed_factor;
-  }
-  multiplier = multiplier * speed_factor;
-  block->speed_z = delta_z_mm * multiplier; 
-  block->speed_x = delta_x_mm * multiplier;
-  block->speed_y = delta_y_mm * multiplier;
-  block->speed_e = delta_e_mm * multiplier; 
-  block->nominal_speed = block->millimeters * multiplier;
-  block->nominal_rate = ceil(block->step_event_count * multiplier / 60);  
-
-  if(block->nominal_rate < 120) 
-    block->nominal_rate = 120;
-  block->entry_speed = safe_speed(block);
-
-  // Compute the acceleration rate for the trapezoid generator. 
-  float travel_per_step = block->millimeters/block->step_event_count;
-  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0) {
-    block->acceleration_st = ceil( (retract_acceleration)/travel_per_step); // convert to: acceleration steps/sec^2
-  }
-  else {
-    block->acceleration_st = ceil( (acceleration)/travel_per_step);      // convert to: acceleration steps/sec^2
-    float tmp_acceleration = (float)block->acceleration_st / (float)block->step_event_count;
-    // Limit acceleration per axis
-    if((tmp_acceleration * block->steps_x) > axis_steps_per_sqr_second[X_AXIS]) {
-      block->acceleration_st = axis_steps_per_sqr_second[X_AXIS];
-      tmp_acceleration = (float)block->acceleration_st / (float)block->step_event_count;
-    }
-    if((tmp_acceleration * block->steps_y) > axis_steps_per_sqr_second[Y_AXIS]) {
-      block->acceleration_st = axis_steps_per_sqr_second[Y_AXIS];
-      tmp_acceleration = (float)block->acceleration_st / (float)block->step_event_count;
-    }
-    if((tmp_acceleration * block->steps_e) > axis_steps_per_sqr_second[E_AXIS]) {
-      block->acceleration_st = axis_steps_per_sqr_second[E_AXIS];
-      tmp_acceleration = (float)block->acceleration_st / (float)block->step_event_count;
-    }
-    if((tmp_acceleration * block->steps_z) > axis_steps_per_sqr_second[Z_AXIS]) {
-      block->acceleration_st = axis_steps_per_sqr_second[Z_AXIS];
-      tmp_acceleration = (float)block->acceleration_st / (float)block->step_event_count;
-    }
-  }
-  block->acceleration = block->acceleration_st * travel_per_step;
-  block->acceleration_rate = (long)((float)block->acceleration_st * 8.388608);
-
-  #ifdef ADVANCE
-    // Calculate advance rate
-    if((block->steps_e == 0) || (block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)) {
-      block->advance_rate = 0;
-      block->advance = 0;
-    }
-    else {
-      long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
-      float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * 
-        (block->speed_e * block->speed_e * EXTRUTION_AREA * EXTRUTION_AREA / 3600.0)*65536;
-      block->advance = advance;
-      if(acc_dist == 0) {
-        block->advance_rate = 0;
-      } 
-      else {
-        block->advance_rate = advance / (float)acc_dist;
-      }
-    }
-  #endif // ADVANCE
-
-  // compute a preliminary conservative acceleration trapezoid
-  float safespeed = safe_speed(block);
-  calculate_trapezoid_for_block(block, safespeed, safespeed); 
-
-  // Compute direction bits for this block
-  block->direction_bits = 0;
-  if (target[X_AXIS] < position[X_AXIS]) { 
-    block->direction_bits |= (1<<X_AXIS); 
-  }
-  if (target[Y_AXIS] < position[Y_AXIS]) { 
-    block->direction_bits |= (1<<Y_AXIS); 
-  }
-  if (target[Z_AXIS] < position[Z_AXIS]) { 
-    block->direction_bits |= (1<<Z_AXIS); 
-  }
-  if (target[E_AXIS] < position[E_AXIS]) { 
-    block->direction_bits |= (1<<E_AXIS); 
-  }
-
-  // Move buffer head
-  block_buffer_head = next_buffer_head;     
-
-  // Update position 
-  memcpy(position, target, sizeof(target)); // position[] = target[]
-
-  planner_recalculate();
-  #ifdef AUTOTEMP
-    getHighESpeed();
-  #endif
-  st_wake_up();
-}
-
-void plan_set_position(const float &x, const float &y, const float &z, const float &e)
-{
-  position[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
-  position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
-  position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
-  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);     
-}
-
+/*
+  planner.c - buffers movement commands and manages the acceleration profile plan
+  Part of Grbl
+
+  Copyright (c) 2009-2011 Simen Svale Skogsrud
+
+  Grbl is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  Grbl is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis. */
+
+/*  
+  Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
+  
+  s == speed, a == acceleration, t == time, d == distance
+
+  Basic definitions:
+
+    Speed[s_, a_, t_] := s + (a*t) 
+    Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
+
+  Distance to reach a specific speed with a constant acceleration:
+
+    Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
+      d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
+
+  Speed after a given distance of travel with constant acceleration:
+
+    Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
+      m -> Sqrt[2 a d + s^2]    
+
+    DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
+
+  When to start braking (di) to reach a specified destionation speed (s2) after accelerating
+  from initial speed s1 without ever stopping at a plateau:
+
+    Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
+      di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
+
+    IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
+*/
+                                                                                                            
+
+//#include <inttypes.h>
+//#include <math.h>       
+//#include <stdlib.h>
+
+#include "Marlin.h"
+#include "Configuration.h"
+#include "pins.h"
+#include "fastio.h"
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+#include "ultralcd.h"
+
+//===========================================================================
+//=============================public variables ============================
+//===========================================================================
+
+unsigned long minsegmenttime;
+float max_feedrate[4]; // set the max speeds
+float axis_steps_per_unit[4];
+long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
+float minimumfeedrate;
+float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
+float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
+float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
+float max_z_jerk;
+float mintravelfeedrate;
+unsigned long axis_steps_per_sqr_second[NUM_AXIS];
+
+// The current position of the tool in absolute steps
+long position[4];   //rescaled from extern when axis_steps_per_unit are changed by gcode
+static float previous_speed[4]; // Speed of previous path line segment
+static float previous_nominal_speed; // Nominal speed of previous path line segment
+
+#ifdef AUTOTEMP
+float high_e_speed=0;
+#endif
+
+
+//===========================================================================
+//=============================private variables ============================
+//===========================================================================
+static block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions
+static volatile unsigned char block_buffer_head;           // Index of the next block to be pushed
+static volatile unsigned char block_buffer_tail;           // Index of the block to process now
+
+// Used for the frequency limit
+static unsigned char old_direction_bits = 0;               // Old direction bits. Used for speed calculations
+static long x_segment_time[3]={0,0,0};                     // Segment times (in us). Used for speed calculations
+static long y_segment_time[3]={0,0,0};
+
+// Returns the index of the next block in the ring buffer
+// NOTE: Removed modulo (%) operator, which uses an expensive divide and multiplication.
+static int8_t next_block_index(int8_t block_index) {
+  block_index++;
+  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
+  return(block_index);
+}
+
+
+// Returns the index of the previous block in the ring buffer
+static int8_t prev_block_index(int8_t block_index) {
+  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
+  block_index--;
+  return(block_index);
+}
+
+//===========================================================================
+//=============================functions         ============================
+//===========================================================================
+
+// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the 
+// given acceleration:
+inline float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {
+  if (acceleration!=0) {
+  return((target_rate*target_rate-initial_rate*initial_rate)/
+         (2.0*acceleration));
+  }
+  else {
+    return 0.0;  // acceleration was 0, set acceleration distance to 0
+  }
+}
+
+// This function gives you the point at which you must start braking (at the rate of -acceleration) if 
+// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after
+// a total travel of distance. This can be used to compute the intersection point between acceleration and
+// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)
+
+inline float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {
+ if (acceleration!=0) {
+  return((2.0*acceleration*distance-initial_rate*initial_rate+final_rate*final_rate)/
+         (4.0*acceleration) );
+  }
+  else {
+    return 0.0;  // acceleration was 0, set intersection distance to 0
+  }
+}
+
+// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.
+
+void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {
+  long initial_rate = ceil(block->nominal_rate*entry_factor); // (step/min)
+  long final_rate = ceil(block->nominal_rate*exit_factor); // (step/min)
+
+  // Limit minimal step rate (Otherwise the timer will overflow.)
+  if(initial_rate <120) {initial_rate=120; }
+  if(final_rate < 120) {final_rate=120;  }
+  
+  long acceleration = block->acceleration_st;
+  int32_t accelerate_steps =
+    ceil(estimate_acceleration_distance(block->initial_rate, block->nominal_rate, acceleration));
+  int32_t decelerate_steps =
+    floor(estimate_acceleration_distance(block->nominal_rate, block->final_rate, -acceleration));
+    
+  // Calculate the size of Plateau of Nominal Rate.
+  int32_t plateau_steps = block->step_event_count-accelerate_steps-decelerate_steps;
+  
+  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
+  // have to use intersection_distance() to calculate when to abort acceleration and start braking
+  // in order to reach the final_rate exactly at the end of this block.
+  if (plateau_steps < 0) {
+    accelerate_steps = ceil(
+      intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
+    accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off
+    accelerate_steps = min(accelerate_steps,block->step_event_count);
+    plateau_steps = 0;
+  }
+
+  #ifdef ADVANCE
+    long initial_advance = block->advance*entry_factor*entry_factor;
+    long final_advance = block->advance*exit_factor*exit_factor;
+  #endif // ADVANCE
+  
+ // block->accelerate_until = accelerate_steps;
+ // block->decelerate_after = accelerate_steps+plateau_steps;
+  
+  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
+  if(block->busy == false) { // Don't update variables if block is busy.
+    block->accelerate_until = accelerate_steps;
+    block->decelerate_after = accelerate_steps+plateau_steps;
+    block->initial_rate = initial_rate;
+    block->final_rate = final_rate;
+  #ifdef ADVANCE
+      block->initial_advance = initial_advance;
+      block->final_advance = final_advance;
+  #endif //ADVANCE
+  }
+  CRITICAL_SECTION_END;
+}                    
+
+// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the 
+// acceleration within the allotted distance.
+inline float max_allowable_speed(float acceleration, float target_velocity, float distance) {
+  return  sqrt(target_velocity*target_velocity-2*acceleration*distance);
+}
+
+// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
+// This method will calculate the junction jerk as the euclidean distance between the nominal 
+// velocities of the respective blocks.
+//inline float junction_jerk(block_t *before, block_t *after) {
+//  return sqrt(
+//    pow((before->speed_x-after->speed_x), 2)+pow((before->speed_y-after->speed_y), 2));
+//}
+
+
+// The kernel called by planner_recalculate() when scanning the plan from last to first entry.
+void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {
+  if(!current) { return; }
+  
+    if (next) {
+    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
+    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
+    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
+    if (current->entry_speed != current->max_entry_speed) {
+    
+      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
+      // for max allowable speed if block is decelerating and nominal length is false.
+      if ((!current->nominal_length_flag) && (current->max_entry_speed > next->entry_speed)) {
+        current->entry_speed = min( current->max_entry_speed,
+          max_allowable_speed(-current->acceleration,next->entry_speed,current->millimeters));
+      } else {
+        current->entry_speed = current->max_entry_speed;
+      }
+      current->recalculate_flag = true;
+    
+    }
+  } // Skip last block. Already initialized and set for recalculation.
+}
+
+// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
+// implements the reverse pass.
+void planner_reverse_pass() {
+  char block_index = block_buffer_head;
+  if(((block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1)) > 3) {
+    block_index = (block_buffer_head - 3) & (BLOCK_BUFFER_SIZE - 1);
+    block_t *block[3] = { NULL, NULL, NULL };
+    while(block_index != block_buffer_tail) { 
+      block_index = prev_block_index(block_index); 
+      block[2]= block[1];
+      block[1]= block[0];
+      block[0] = &block_buffer[block_index];
+      planner_reverse_pass_kernel(block[0], block[1], block[2]);
+    }
+  }
+}
+
+// The kernel called by planner_recalculate() when scanning the plan from first to last entry.
+void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {
+  if(!previous) { return; }
+  
+  // If the previous block is an acceleration block, but it is not long enough to complete the
+  // full speed change within the block, we need to adjust the entry speed accordingly. Entry
+  // speeds have already been reset, maximized, and reverse planned by reverse planner.
+  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
+  if (!previous->nominal_length_flag) {
+    if (previous->entry_speed < current->entry_speed) {
+      double entry_speed = min( current->entry_speed,
+        max_allowable_speed(-previous->acceleration,previous->entry_speed,previous->millimeters) );
+
+      // Check for junction speed change
+      if (current->entry_speed != entry_speed) {
+        current->entry_speed = entry_speed;
+        current->recalculate_flag = true;
+      }
+    }
+  }
+}
+
+// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
+// implements the forward pass.
+void planner_forward_pass() {
+  char block_index = block_buffer_tail;
+  block_t *block[3] = { NULL, NULL, NULL };
+
+  while(block_index != block_buffer_head) {
+    block[0] = block[1];
+    block[1] = block[2];
+    block[2] = &block_buffer[block_index];
+    planner_forward_pass_kernel(block[0],block[1],block[2]);
+    block_index = next_block_index(block_index);
+  }
+  planner_forward_pass_kernel(block[1], block[2], NULL);
+}
+
+// Recalculates the trapezoid speed profiles for all blocks in the plan according to the 
+// entry_factor for each junction. Must be called by planner_recalculate() after 
+// updating the blocks.
+void planner_recalculate_trapezoids() {
+  int8_t block_index = block_buffer_tail;
+  block_t *current;
+  block_t *next = NULL;
+  
+  while(block_index != block_buffer_head) {
+    current = next;
+    next = &block_buffer[block_index];
+    if (current) {
+      // Recalculate if current block entry or exit junction speed has changed.
+      if (current->recalculate_flag || next->recalculate_flag) {
+        // NOTE: Entry and exit factors always > 0 by all previous logic operations.
+        calculate_trapezoid_for_block(current, current->entry_speed/current->nominal_speed,
+          next->entry_speed/current->nominal_speed);
+        current->recalculate_flag = false; // Reset current only to ensure next trapezoid is computed
+      }
+    }
+    block_index = next_block_index( block_index );
+  }
+  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
+  if(next != NULL) {
+    calculate_trapezoid_for_block(next, next->entry_speed/next->nominal_speed,
+      MINIMUM_PLANNER_SPEED/next->nominal_speed);
+    next->recalculate_flag = false;
+  }
+}
+
+// Recalculates the motion plan according to the following algorithm:
+//
+//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) 
+//      so that:
+//     a. The junction jerk is within the set limit
+//     b. No speed reduction within one block requires faster deceleration than the one, true constant 
+//        acceleration.
+//   2. Go over every block in chronological order and dial down junction speed reduction values if 
+//     a. The speed increase within one block would require faster accelleration than the one, true 
+//        constant acceleration.
+//
+// When these stages are complete all blocks have an entry_factor that will allow all speed changes to 
+// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than 
+// the set limit. Finally it will:
+//
+//   3. Recalculate trapezoids for all blocks.
+
+void planner_recalculate() {   
+  planner_reverse_pass();
+  planner_forward_pass();
+  planner_recalculate_trapezoids();
+}
+
+void plan_init() {
+  block_buffer_head = 0;
+  block_buffer_tail = 0;
+  memset(position, 0, sizeof(position)); // clear position
+  previous_speed[0] = 0.0;
+  previous_speed[1] = 0.0;
+  previous_speed[2] = 0.0;
+  previous_speed[3] = 0.0;
+  previous_nominal_speed = 0.0;
+}
+
+
+void plan_discard_current_block() {
+  if (block_buffer_head != block_buffer_tail) {
+    block_buffer_tail = (block_buffer_tail + 1) & (BLOCK_BUFFER_SIZE - 1);  
+  }
+}
+
+block_t *plan_get_current_block() {
+  if (block_buffer_head == block_buffer_tail) { 
+    return(NULL); 
+  }
+  block_t *block = &block_buffer[block_buffer_tail];
+  block->busy = true;
+  return(block);
+}
+
+#ifdef AUTOTEMP
+void getHighESpeed()
+{
+  if(degTargetHotend0()+2<AUTOTEMP_MIN)  //probably temperature set to zero.
+    return; //do nothing
+  float high=0;
+  char block_index = block_buffer_tail;
+  
+  while(block_index != block_buffer_head) {
+    float se=block_buffer[block_index].speed_e;
+    if(se>high)
+    {
+      high=se;
+    }
+    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
+  }
+  high_e_speed=high*axis_steps_per_unit[E_AXIS]/(1000000.0);  //so it is independent of the esteps/mm. before 
+   
+  float g=AUTOTEMP_MIN+high_e_speed*AUTOTEMP_FACTOR;
+  float t=constrain(AUTOTEMP_MIN,g,AUTOTEMP_MAX);
+  setTargetHotend0(t);
+  SERIAL_ECHO_START;
+  SERIAL_ECHOPAIR("highe",high_e_speed);
+  SERIAL_ECHOPAIR(" t",t);
+  SERIAL_ECHOLN("");
+}
+#endif
+
+void check_axes_activity() {
+  unsigned char x_active = 0;
+  unsigned char y_active = 0;  
+  unsigned char z_active = 0;
+  unsigned char e_active = 0;
+  block_t *block;
+
+  if(block_buffer_tail != block_buffer_head) {
+    char block_index = block_buffer_tail;
+    while(block_index != block_buffer_head) {
+      block = &block_buffer[block_index];
+      if(block->steps_x != 0) x_active++;
+      if(block->steps_y != 0) y_active++;
+      if(block->steps_z != 0) z_active++;
+      if(block->steps_e != 0) e_active++;
+      block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
+    }
+  }
+  if((DISABLE_X) && (x_active == 0)) disable_x();
+  if((DISABLE_Y) && (y_active == 0)) disable_y();
+  if((DISABLE_Z) && (z_active == 0)) disable_z();
+  if((DISABLE_E) && (e_active == 0)) disable_e();
+}
+
+
+float junction_deviation = 0.1;
+// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in 
+// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration
+// calculation the caller must also provide the physical length of the line in millimeters.
+void plan_buffer_line(const float &x, const float &y, const float &z, const float &e,  float feed_rate)
+{
+  // Calculate the buffer head after we push this byte
+  int next_buffer_head = next_block_index(block_buffer_head);
+
+  // If the buffer is full: good! That means we are well ahead of the robot. 
+  // Rest here until there is room in the buffer.
+  while(block_buffer_tail == next_buffer_head) { 
+    manage_heater(); 
+    manage_inactivity(1); 
+    LCD_STATUS;
+  }
+
+  // The target position of the tool in absolute steps
+  // Calculate target position in absolute steps
+  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
+  long target[4];
+  target[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
+  target[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
+  target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
+  target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]); 
+  
+  // Prepare to set up new block
+  block_t *block = &block_buffer[block_buffer_head];
+  
+  // Mark block as not busy (Not executed by the stepper interrupt)
+  block->busy = false;
+
+  // Number of steps for each axis
+  block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
+  block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
+  block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
+  block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
+  block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));
+
+  // Bail if this is a zero-length block
+  if (block->step_event_count <=dropsegments) { return; };
+
+  // Compute direction bits for this block
+  block->direction_bits = 0;
+  if (target[X_AXIS] < position[X_AXIS]) { block->direction_bits |= (1<<X_AXIS); }
+  if (target[Y_AXIS] < position[Y_AXIS]) { block->direction_bits |= (1<<Y_AXIS); }
+  if (target[Z_AXIS] < position[Z_AXIS]) { block->direction_bits |= (1<<Z_AXIS); }
+  if (target[E_AXIS] < position[E_AXIS]) { block->direction_bits |= (1<<E_AXIS); }
+  
+  //enable active axes
+  if(block->steps_x != 0) enable_x();
+  if(block->steps_y != 0) enable_y();
+  if(block->steps_z != 0) enable_z();
+  if(block->steps_e != 0) enable_e();
+
+  float delta_mm[4];
+  delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
+  delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
+  delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
+  delta_mm[E_AXIS] = (target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS];
+  block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) +
+                            square(delta_mm[Z_AXIS]));
+  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple divides 
+  
+  // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.
+  float inverse_second = feed_rate * inverse_millimeters;
+  
+  block->nominal_speed = block->millimeters * inverse_second; // (mm/sec) Always > 0
+  block->nominal_rate = ceil(block->step_event_count * inverse_second); // (step/sec) Always > 0
+
+//  unsigned long microseconds;
+#if 0
+  if (block->steps_e == 0) {
+        if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
+  }
+  else {
+    	if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
+  } 
+
+  microseconds = lround((block->millimeters/feed_rate)*1000000);
+
+  // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
+  // reduces/removes corner blobs as the machine won't come to a full stop.
+  int blockcount=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
+  
+  if ((blockcount>0) && (blockcount < (BLOCK_BUFFER_SIZE - 4))) {
+    if (microseconds<minsegmenttime)  { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
+        microseconds=microseconds+lround(2*(minsegmenttime-microseconds)/blockcount);
+    }
+  }
+  else {
+    if (microseconds<minsegmenttime) microseconds=minsegmenttime;
+  }
+  //  END OF SLOW DOWN SECTION  
+#endif  
+
+ // Calculate speed in mm/sec for each axis
+  float current_speed[4];
+  for(int i=0; i < 4; i++) {
+    current_speed[i] = delta_mm[i] * inverse_second;
+  }
+
+  // Limit speed per axis
+  float speed_factor = 1.0; //factor <=1 do decrease speed
+  for(int i=0; i < 4; i++) {
+    if(abs(current_speed[i]) > max_feedrate[i])
+      speed_factor = min(speed_factor, max_feedrate[i] / abs(current_speed[i]));
+  }
+
+// Max segement time in us.
+
+#ifdef XY_FREQUENCY_LIMIT
+#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
+
+  // Check and limit the xy direction change frequency
+  unsigned char direction_change = block->direction_bits ^ old_direction_bits;
+  old_direction_bits = block->direction_bits;
+  long segment_time = lround(1000000.0/inverse_second);
+  if((direction_change & (1<<X_AXIS)) == 0) {
+     x_segment_time[0] += segment_time;
+  }
+  else {
+    x_segment_time[2] = x_segment_time[1];
+    x_segment_time[1] = x_segment_time[0];
+    x_segment_time[0] = segment_time;
+  }
+  if((direction_change & (1<<Y_AXIS)) == 0) {
+     y_segment_time[0] += segment_time;
+  }
+  else {
+    y_segment_time[2] = y_segment_time[1];
+    y_segment_time[1] = y_segment_time[0];
+    y_segment_time[0] = segment_time;
+  }
+  long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));
+  long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));
+  long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);
+  if(min_xy_segment_time < MAX_FREQ_TIME) speed_factor = min(speed_factor, (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
+#endif
+
+
+  // Correct the speed  
+  if( speed_factor < 1.0) {
+//    Serial.print("speed factor : "); Serial.println(speed_factor);
+    for(int i=0; i < 4; i++) {
+    if(abs(current_speed[i]) > max_feedrate[i])
+      speed_factor = min(speed_factor, max_feedrate[i] / abs(current_speed[i]));
+//      Serial.print("current_speed"); Serial.print(i); Serial.print(" : "); Serial.println(current_speed[i]);
+  }
+    for(unsigned char i=0; i < 4; i++) {
+      current_speed[i] *= speed_factor;
+    }
+    block->nominal_speed *= speed_factor;
+    block->nominal_rate *= speed_factor;
+  }
+
+  // Compute and limit the acceleration rate for the trapezoid generator.  
+  float steps_per_mm = block->step_event_count/block->millimeters;
+  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0) {
+    block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+  }
+  else {
+    block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    // Limit acceleration per axis
+    if(((float)block->acceleration_st * (float)block->steps_x / (float)block->step_event_count) > axis_steps_per_sqr_second[X_AXIS])
+      block->acceleration_st = axis_steps_per_sqr_second[X_AXIS];
+    if(((float)block->acceleration_st * (float)block->steps_y / (float)block->step_event_count) > axis_steps_per_sqr_second[Y_AXIS])
+      block->acceleration_st = axis_steps_per_sqr_second[Y_AXIS];
+    if(((float)block->acceleration_st * (float)block->steps_e / (float)block->step_event_count) > axis_steps_per_sqr_second[E_AXIS])
+      block->acceleration_st = axis_steps_per_sqr_second[E_AXIS];
+    if(((float)block->acceleration_st * (float)block->steps_z / (float)block->step_event_count ) > axis_steps_per_sqr_second[Z_AXIS])
+      block->acceleration_st = axis_steps_per_sqr_second[Z_AXIS];
+  }
+  block->acceleration = block->acceleration_st / steps_per_mm;
+  block->acceleration_rate = (long)((float)block->acceleration_st * 8.388608);
+  
+#if 0  // Use old jerk for now
+  // Compute path unit vector
+  double unit_vec[3];
+
+  unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;
+  unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;
+  unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;
+  
+  // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
+  // Let a circle be tangent to both previous and current path line segments, where the junction
+  // deviation is defined as the distance from the junction to the closest edge of the circle,
+  // colinear with the circle center. The circular segment joining the two paths represents the
+  // path of centripetal acceleration. Solve for max velocity based on max acceleration about the
+  // radius of the circle, defined indirectly by junction deviation. This may be also viewed as
+  // path width or max_jerk in the previous grbl version. This approach does not actually deviate
+  // from path, but used as a robust way to compute cornering speeds, as it takes into account the
+  // nonlinearities of both the junction angle and junction velocity.
+  double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
+
+  // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
+  if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed > 0.0)) {
+    // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
+    // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
+    double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
+                       - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
+                       - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
+                           
+    // Skip and use default max junction speed for 0 degree acute junction.
+    if (cos_theta < 0.95) {
+      vmax_junction = min(previous_nominal_speed,block->nominal_speed);
+      // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
+      if (cos_theta > -0.95) {
+        // Compute maximum junction velocity based on maximum acceleration and junction deviation
+        double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.
+        vmax_junction = min(vmax_junction,
+          sqrt(block->acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );
+      }
+    }
+  }
+#endif
+  // Start with a safe speed
+  float vmax_junction = max_xy_jerk/2;  
+  if(abs(current_speed[Z_AXIS]) > max_z_jerk/2) 
+    vmax_junction = max_z_jerk/2;
+  vmax_junction = min(vmax_junction, block->nominal_speed);
+
+  if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed > 0.0)) {
+    float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));
+    if((previous_speed[X_AXIS] != 0.0) || (previous_speed[Y_AXIS] != 0.0)) {
+      vmax_junction = block->nominal_speed;
+    }
+    if (jerk > max_xy_jerk) {
+      vmax_junction *= (max_xy_jerk/jerk);
+    } 
+    if(abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
+      vmax_junction *= (max_z_jerk/abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
+    } 
+  }
+  block->max_entry_speed = vmax_junction;
+    
+  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
+  double v_allowable = max_allowable_speed(-block->acceleration,MINIMUM_PLANNER_SPEED,block->millimeters);
+  block->entry_speed = min(vmax_junction, v_allowable);
+
+  // Initialize planner efficiency flags
+  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
+  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
+  // the current block and next block junction speeds are guaranteed to always be at their maximum
+  // junction speeds in deceleration and acceleration, respectively. This is due to how the current
+  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
+  // the reverse and forward planners, the corresponding block junction speed will always be at the
+  // the maximum junction speed and may always be ignored for any speed reduction checks.
+  if (block->nominal_speed <= v_allowable) { block->nominal_length_flag = true; }
+  else { block->nominal_length_flag = false; }
+  block->recalculate_flag = true; // Always calculate trapezoid for new block
+  
+  // Update previous path unit_vector and nominal speed
+  memcpy(previous_speed, current_speed, sizeof(previous_speed)); // previous_speed[] = current_speed[]
+  previous_nominal_speed = block->nominal_speed;
+  
+  #ifdef ADVANCE
+    // Calculate advance rate
+    if((block->steps_e == 0) || (block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)) {
+      block->advance_rate = 0;
+      block->advance = 0;
+    }
+    else {
+      long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
+      float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * 
+        (block->speed_e * block->speed_e * EXTRUTION_AREA * EXTRUTION_AREA / 3600.0)*65536;
+      block->advance = advance;
+      if(acc_dist == 0) {
+        block->advance_rate = 0;
+      } 
+      else {
+        block->advance_rate = advance / (float)acc_dist;
+      }
+    }
+  #endif // ADVANCE
+
+
+
+
+  calculate_trapezoid_for_block(block, block->entry_speed/block->nominal_speed,
+    MINIMUM_PLANNER_SPEED/block->nominal_speed);
+    
+  // Move buffer head
+  block_buffer_head = next_buffer_head;
+  
+  // Update position
+  memcpy(position, target, sizeof(target)); // position[] = target[]
+
+  planner_recalculate();
+  #ifdef AUTOTEMP
+    getHighESpeed();
+  #endif
+  st_wake_up();
+}
+
+void plan_set_position(const float &x, const float &y, const float &z, const float &e)
+{
+  position[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
+  position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
+  position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
+  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  
+  previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
+  previous_speed[0] = 0.0;
+  previous_speed[1] = 0.0;
+  previous_speed[2] = 0.0;
+  previous_speed[3] = 0.0;
+}
+
diff --git a/Marlin/planner.h b/Marlin/planner.h
index c5bc5b8..f5c01ea 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -1,95 +1,98 @@
-/*
-  planner.h - buffers movement commands and manages the acceleration profile plan
-  Part of Grbl
-
-  Copyright (c) 2009-2011 Simen Svale Skogsrud
-
-  Grbl is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  Grbl is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-// This module is to be considered a sub-module of stepper.c. Please don't include 
-// this file from any other module.
-
-#ifndef planner_h
-#define planner_h
-
-#include "Configuration.h"
-
-// This struct is used when buffering the setup for each linear movement "nominal" values are as specified in 
-// the source g-code and may never actually be reached if acceleration management is active.
-typedef struct {
-  // Fields used by the bresenham algorithm for tracing the line
-  long steps_x, steps_y, steps_z, steps_e;  // Step count along each axis
-  long step_event_count;                    // The number of step events required to complete this block
-  volatile long accelerate_until;           // The index of the step event on which to stop acceleration
-  volatile long decelerate_after;           // The index of the step event on which to start decelerating
-  volatile long acceleration_rate;          // The acceleration rate used for acceleration calculation
-  unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
-  #ifdef ADVANCE
-    long advance_rate;
-    volatile long initial_advance;
-    volatile long final_advance;
-    float advance;
-  #endif
-
-  // Fields used by the motion planner to manage acceleration
-  float speed_x, speed_y, speed_z, speed_e;          // Nominal mm/minute for each axis
-  float nominal_speed;                               // The nominal speed for this block in mm/min  
-  float millimeters;                                 // The total travel of this block in mm
-  float entry_speed;
-  float acceleration;                                // acceleration mm/sec^2
-
-  // Settings for the trapezoid generator
-  long nominal_rate;                                 // The nominal step rate for this block in step_events/sec 
-  volatile long initial_rate;                        // The jerk-adjusted step rate at start of block  
-  volatile long final_rate;                          // The minimal rate at exit
-  long acceleration_st;                              // acceleration steps/sec^2
-  volatile char busy;
-} block_t;
-
-// Initialize the motion plan subsystem      
-void plan_init();
-
-// Add a new linear movement to the buffer. x, y and z is the signed, absolute target position in 
-// millimaters. Feed rate specifies the speed of the motion.
-void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate);
-
-// Set position. Used for G92 instructions.
-void plan_set_position(const float &x, const float &y, const float &z, const float &e);
-
-
-// Called when the current block is no longer needed. Discards the block and makes the memory
-// availible for new blocks.
-void plan_discard_current_block();
-
-// Gets the current block. Returns NULL if buffer empty
-block_t *plan_get_current_block();
-
-void check_axes_activity();
-
-extern unsigned long minsegmenttime;
-extern float max_feedrate[4]; // set the max speeds
-extern float axis_steps_per_unit[4];
-extern long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
-extern float minimumfeedrate;
-extern float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
-extern float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
-extern float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
-extern float max_z_jerk;
-extern float mintravelfeedrate;
-extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];
-#ifdef AUTOTEMP
-extern float high_e_speed;
-#endif
-#endif
+/*
+  planner.h - buffers movement commands and manages the acceleration profile plan
+  Part of Grbl
+
+  Copyright (c) 2009-2011 Simen Svale Skogsrud
+
+  Grbl is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  Grbl is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// This module is to be considered a sub-module of stepper.c. Please don't include 
+// this file from any other module.
+
+#ifndef planner_h
+#define planner_h
+
+#include "Configuration.h"
+
+// This struct is used when buffering the setup for each linear movement "nominal" values are as specified in 
+// the source g-code and may never actually be reached if acceleration management is active.
+typedef struct {
+  // Fields used by the bresenham algorithm for tracing the line
+  long steps_x, steps_y, steps_z, steps_e;  // Step count along each axis
+  long step_event_count;                    // The number of step events required to complete this block
+  volatile long accelerate_until;           // The index of the step event on which to stop acceleration
+  volatile long decelerate_after;           // The index of the step event on which to start decelerating
+  volatile long acceleration_rate;          // The acceleration rate used for acceleration calculation
+  unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
+  #ifdef ADVANCE
+//    long advance_rate;
+//    volatile long initial_advance;
+//    volatile long final_advance;
+//    float advance;
+  #endif
+
+  // Fields used by the motion planner to manage acceleration
+//  float speed_x, speed_y, speed_z, speed_e;        // Nominal mm/minute for each axis
+  float nominal_speed;                               // The nominal speed for this block in mm/min  
+  float entry_speed;                                 // Entry speed at previous-current junction in mm/min
+  float max_entry_speed;                             // Maximum allowable junction entry speed in mm/min
+  float millimeters;                                 // The total travel of this block in mm
+  float acceleration;                                // acceleration mm/sec^2
+  unsigned char recalculate_flag;                          // Planner flag to recalculate trapezoids on entry junction
+  unsigned char nominal_length_flag;                       // Planner flag for nominal speed always reached
+
+  // Settings for the trapezoid generator
+  long nominal_rate;                                 // The nominal step rate for this block in step_events/sec 
+  volatile long initial_rate;                        // The jerk-adjusted step rate at start of block  
+  volatile long final_rate;                          // The minimal rate at exit
+  long acceleration_st;                              // acceleration steps/sec^2
+  volatile char busy;
+} block_t;
+
+// Initialize the motion plan subsystem      
+void plan_init();
+
+// Add a new linear movement to the buffer. x, y and z is the signed, absolute target position in 
+// millimaters. Feed rate specifies the speed of the motion.
+void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate);
+
+// Set position. Used for G92 instructions.
+void plan_set_position(const float &x, const float &y, const float &z, const float &e);
+
+
+// Called when the current block is no longer needed. Discards the block and makes the memory
+// availible for new blocks.
+void plan_discard_current_block();
+
+// Gets the current block. Returns NULL if buffer empty
+block_t *plan_get_current_block();
+
+void check_axes_activity();
+
+extern unsigned long minsegmenttime;
+extern float max_feedrate[4]; // set the max speeds
+extern float axis_steps_per_unit[4];
+extern long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
+extern float minimumfeedrate;
+extern float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
+extern float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
+extern float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
+extern float max_z_jerk;
+extern float mintravelfeedrate;
+extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];
+#ifdef AUTOTEMP
+extern float high_e_speed;
+#endif
+#endif
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 23066ef..2f5f3a8 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -1,664 +1,669 @@
-/*
-  stepper.c - stepper motor driver: executes motion plans using stepper motors
-  Part of Grbl
-
-  Copyright (c) 2009-2011 Simen Svale Skogsrud
-
-  Grbl is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  Grbl is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
-   and Philipp Tiefenbacher. */
-
-#include "stepper.h"
-#include "Configuration.h"
-#include "Marlin.h"
-#include "planner.h"
-#include "pins.h"
-#include "fastio.h"
-#include "temperature.h"
-#include "ultralcd.h"
-
-#include "speed_lookuptable.h"
-
-
-
-//===========================================================================
-//=============================public variables  ============================
-//===========================================================================
-block_t *current_block;  // A pointer to the block currently being traced
-
-
-
-//===========================================================================
-//=============================private variables ============================
-//===========================================================================
-//static makes it inpossible to be called from outside of this file by extern.!
-
-// Variables used by The Stepper Driver Interrupt
-static unsigned char out_bits;        // The next stepping-bits to be output
-static long counter_x,       // Counter variables for the bresenham line tracer
-            counter_y, 
-            counter_z,       
-            counter_e;
-static unsigned long step_events_completed; // The number of step events executed in the current block
-#ifdef ADVANCE
-  static long advance_rate, advance, final_advance = 0;
-  static short old_advance = 0;
-  static short e_steps;
-#endif
-static unsigned char busy = false; // TRUE when SIG_OUTPUT_COMPARE1A is being serviced. Used to avoid retriggering that handler.
-static long acceleration_time, deceleration_time;
-//static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
-static unsigned short acc_step_rate; // needed for deccelaration start point
-static char step_loops;
-
-volatile long endstops_trigsteps[3]={0,0,0};
-volatile long endstops_stepsTotal,endstops_stepsDone;
-static volatile bool endstops_hit=false;
-
-// if DEBUG_STEPS is enabled, M114 can be used to compare two methods of determining the X,Y,Z position of the printer.
-// for debugging purposes only, should be disabled by default
-#ifdef DEBUG_STEPS
-  volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
-  volatile int count_direction[NUM_AXIS] = { 1, 1, 1, 1};
-#endif
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-  
-
-// intRes = intIn1 * intIn2 >> 16
-// uses:
-// r26 to store 0
-// r27 to store the byte 1 of the 24 bit result
-#define MultiU16X8toH16(intRes, charIn1, intIn2) \
-asm volatile ( \
-"clr r26 \n\t" \
-"mul %A1, %B2 \n\t" \
-"movw %A0, r0 \n\t" \
-"mul %A1, %A2 \n\t" \
-"add %A0, r1 \n\t" \
-"adc %B0, r26 \n\t" \
-"lsr r0 \n\t" \
-"adc %A0, r26 \n\t" \
-"adc %B0, r26 \n\t" \
-"clr r1 \n\t" \
-: \
-"=&r" (intRes) \
-: \
-"d" (charIn1), \
-"d" (intIn2) \
-: \
-"r26" \
-)
-
-// intRes = longIn1 * longIn2 >> 24
-// uses:
-// r26 to store 0
-// r27 to store the byte 1 of the 48bit result
-#define MultiU24X24toH16(intRes, longIn1, longIn2) \
-asm volatile ( \
-"clr r26 \n\t" \
-"mul %A1, %B2 \n\t" \
-"mov r27, r1 \n\t" \
-"mul %B1, %C2 \n\t" \
-"movw %A0, r0 \n\t" \
-"mul %C1, %C2 \n\t" \
-"add %B0, r0 \n\t" \
-"mul %C1, %B2 \n\t" \
-"add %A0, r0 \n\t" \
-"adc %B0, r1 \n\t" \
-"mul %A1, %C2 \n\t" \
-"add r27, r0 \n\t" \
-"adc %A0, r1 \n\t" \
-"adc %B0, r26 \n\t" \
-"mul %B1, %B2 \n\t" \
-"add r27, r0 \n\t" \
-"adc %A0, r1 \n\t" \
-"adc %B0, r26 \n\t" \
-"mul %C1, %A2 \n\t" \
-"add r27, r0 \n\t" \
-"adc %A0, r1 \n\t" \
-"adc %B0, r26 \n\t" \
-"mul %B1, %A2 \n\t" \
-"add r27, r1 \n\t" \
-"adc %A0, r26 \n\t" \
-"adc %B0, r26 \n\t" \
-"lsr r27 \n\t" \
-"adc %A0, r26 \n\t" \
-"adc %B0, r26 \n\t" \
-"clr r1 \n\t" \
-: \
-"=&r" (intRes) \
-: \
-"d" (longIn1), \
-"d" (longIn2) \
-: \
-"r26" , "r27" \
-)
-
-// Some useful constants
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT()  TIMSK1 |= (1<<OCIE1A)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1<<OCIE1A)
-
-
-void endstops_triggered(const unsigned long &stepstaken)  
-{
-  //this will only work if there is no bufferig
-  //however, if you perform a move at which the endstops should be triggered, and wait for it to complete, i.e. by blocking command, it should work
-  //yes, it uses floats, but: if endstops are triggered, thats hopefully not critical anymore anyways.
-  //endstops_triggerpos;
-  
-  if(endstops_hit) //hitting a second time while the first hit is not reported
-    return;
-  if(current_block == NULL)
-    return;
-  endstops_stepsTotal=current_block->step_event_count;
-  endstops_stepsDone=stepstaken;
-  endstops_trigsteps[0]=current_block->steps_x;
-  endstops_trigsteps[1]=current_block->steps_y;
-  endstops_trigsteps[2]=current_block->steps_z;
-
-  endstops_hit=true;
-}
-
-void checkHitEndstops()
-{
-  if( !endstops_hit)
-   return;
-  float endstops_triggerpos[3]={0,0,0};
-  float ratiodone=endstops_stepsDone/float(endstops_stepsTotal);  //ratio of current_block thas was performed
-  
-  endstops_triggerpos[0]=current_position[0]-(endstops_trigsteps[0]*ratiodone)/float(axis_steps_per_unit[0]);
-  endstops_triggerpos[1]=current_position[1]-(endstops_trigsteps[1]*ratiodone)/float(axis_steps_per_unit[1]);
-  endstops_triggerpos[2]=current_position[2]-(endstops_trigsteps[2]*ratiodone)/float(axis_steps_per_unit[2]);
- SERIAL_ECHO_START;
- SERIAL_ECHOPGM("endstops hit: ");
- SERIAL_ECHOPAIR(" X:",endstops_triggerpos[0]);
- SERIAL_ECHOPAIR(" Y:",endstops_triggerpos[1]);
- SERIAL_ECHOPAIR(" Z:",endstops_triggerpos[2]);
- SERIAL_ECHOLN("");
- endstops_hit=false;
-}
-
-void endstops_hit_on_purpose()
-{
-  endstops_hit=false;
-}
-
-//         __________________________
-//        /|                        |\     _________________         ^
-//       / |                        | \   /|               |\        |
-//      /  |                        |  \ / |               | \       s
-//     /   |                        |   |  |               |  \      p
-//    /    |                        |   |  |               |   \     e
-//   +-----+------------------------+---+--+---------------+----+    e
-//   |               BLOCK 1            |      BLOCK 2          |    d
-//
-//                           time ----->
-// 
-//  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates 
-//  first block->accelerate_until step_events_completed, then keeps going at constant speed until 
-//  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
-//  The slope of acceleration is calculated with the leib ramp alghorithm.
-
-void st_wake_up() {
-  //  TCNT1 = 0;
-  ENABLE_STEPPER_DRIVER_INTERRUPT();  
-}
-
-inline unsigned short calc_timer(unsigned short step_rate) {
-  unsigned short timer;
-  if(step_rate > MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;
-  
-  if(step_rate > 20000) { // If steprate > 20kHz >> step 4 times
-    step_rate = step_rate >> 2;
-    step_loops = 4;
-  }
-  else if(step_rate > 10000) { // If steprate > 10kHz >> step 2 times
-    step_rate = step_rate >> 1;
-    step_loops = 2;
-  }
-  else {
-    step_loops = 1;
-  } 
-  
-  if(step_rate < 32) step_rate = 32;
-  step_rate -= 32; // Correct for minimal speed
-  if(step_rate >= (8*256)){ // higher step rate 
-    unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate>>8)][0];
-    unsigned char tmp_step_rate = (step_rate & 0x00ff);
-    unsigned short gain = (unsigned short)pgm_read_word_near(table_address+2);
-    MultiU16X8toH16(timer, tmp_step_rate, gain);
-    timer = (unsigned short)pgm_read_word_near(table_address) - timer;
-  }
-  else { // lower step rates
-    unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
-    table_address += ((step_rate)>>1) & 0xfffc;
-    timer = (unsigned short)pgm_read_word_near(table_address);
-    timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))>>3);
-  }
-  if(timer < 100) timer = 100;
-  return timer;
-}
-
-// Initializes the trapezoid generator from the current block. Called whenever a new 
-// block begins.
-inline void trapezoid_generator_reset() {
-  #ifdef ADVANCE
-    advance = current_block->initial_advance;
-    final_advance = current_block->final_advance;
-  #endif
-  deceleration_time = 0;
-  // advance_rate = current_block->advance_rate;
-  // step_rate to timer interval
-  acc_step_rate = current_block->initial_rate;
-  acceleration_time = calc_timer(acc_step_rate);
-  OCR1A = acceleration_time;
-}
-
-// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.  
-// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately. 
-ISR(TIMER1_COMPA_vect)
-{        
-  if(busy){ 
-    SERIAL_ERROR_START
-    SERIAL_ERROR(*(unsigned short *)OCR1A);
-    SERIAL_ERRORLNPGM(" ISR overtaking itself.");
-    return; 
-  } // The busy-flag is used to avoid reentering this interrupt
-
-  busy = true;
-  sei(); // Re enable interrupts (normally disabled while inside an interrupt handler)
-
-  // If there is no current block, attempt to pop one from the buffer
-  if (current_block == NULL) {
-    // Anything in the buffer?
-    current_block = plan_get_current_block();
-    if (current_block != NULL) {
-      trapezoid_generator_reset();
-      counter_x = -(current_block->step_event_count >> 1);
-      counter_y = counter_x;
-      counter_z = counter_x;
-      counter_e = counter_x;
-      step_events_completed = 0;
-      #ifdef ADVANCE
-      e_steps = 0;
-      #endif
-    } 
-    else {
-//      DISABLE_STEPPER_DRIVER_INTERRUPT();
-    }    
-  } 
-
-  if (current_block != NULL) {
-    // Set directions TO DO This should be done once during init of trapezoid. Endstops -> interrupt
-    out_bits = current_block->direction_bits;
-
-    #ifdef ADVANCE
-        // Calculate E early.
-        counter_e += current_block->steps_e;
-        if (counter_e > 0) {
-          counter_e -= current_block->step_event_count;
-          if ((out_bits & (1<<E_AXIS)) != 0) { // - direction
-            CRITICAL_SECTION_START;
-            e_steps--;
-            CRITICAL_SECTION_END;
-          }
-          else {
-            CRITICAL_SECTION_START;
-            e_steps++;
-            CRITICAL_SECTION_END;
-          }
-        }    
-        // Do E steps + advance steps
-        CRITICAL_SECTION_START;
-        e_steps += ((advance >> 16) - old_advance);
-        CRITICAL_SECTION_END;
-        old_advance = advance >> 16;  
-    #endif //ADVANCE
-
-    // Set direction en check limit switches
-    if ((out_bits & (1<<X_AXIS)) != 0) {   // -direction
-      WRITE(X_DIR_PIN, INVERT_X_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[X_AXIS]=-1;
-      #endif
-      #if X_MIN_PIN > -1
-            if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
-              endstops_triggered(step_events_completed);
-              step_events_completed = current_block->step_event_count;
-            }
-      #endif
-    }
-    else { // +direction 
-      WRITE(X_DIR_PIN,!INVERT_X_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[X_AXIS]=1;
-      #endif
-      #if X_MAX_PIN > -1
-        if((READ(X_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_x >0)){
-          endstops_triggered(step_events_completed);
-          step_events_completed = current_block->step_event_count;
-        }
-        #endif
-    }
-
-    if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
-      WRITE(Y_DIR_PIN,INVERT_Y_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[Y_AXIS]=-1;
-      #endif
-      #if Y_MIN_PIN > -1
-        if(READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) {
-          endstops_triggered(step_events_completed);
-          step_events_completed = current_block->step_event_count;
-        }
-      #endif
-    }
-    else { // +direction
-    WRITE(Y_DIR_PIN,!INVERT_Y_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[Y_AXIS]=1;
-      #endif
-      #if Y_MAX_PIN > -1
-      if((READ(Y_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y >0)){
-          endstops_triggered(step_events_completed);
-          step_events_completed = current_block->step_event_count;
-        }
-      #endif
-    }
-
-    if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
-      WRITE(Z_DIR_PIN,INVERT_Z_DIR);
-      #ifdef DEBUG_STEPS
-      count_direction[Z_AXIS]=-1;
-      #endif
-      #if Z_MIN_PIN > -1
-        if(READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) {
-          endstops_triggered(step_events_completed);
-          step_events_completed = current_block->step_event_count;
-        }
-      #endif
-    }
-    else { // +direction
-      WRITE(Z_DIR_PIN,!INVERT_Z_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[Z_AXIS]=1;
-      #endif
-      #if Z_MAX_PIN > -1
-        if((READ(Z_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_z >0)){
-          endstops_triggered(step_events_completed);
-          step_events_completed = current_block->step_event_count;
-        }
-      #endif
-    }
-
-    #ifndef ADVANCE
-      if ((out_bits & (1<<E_AXIS)) != 0)   // -direction
-        WRITE(E_DIR_PIN,INVERT_E_DIR);
-      else // +direction
-        WRITE(E_DIR_PIN,!INVERT_E_DIR);
-    #endif //!ADVANCE
-
-    for(int8_t i=0; i < step_loops; i++) { // Take multiple steps per interrupt (For high speed moves) 
-      counter_x += current_block->steps_x;
-      if (counter_x > 0) {
-        WRITE(X_STEP_PIN, HIGH);
-        counter_x -= current_block->step_event_count;
-        WRITE(X_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[X_AXIS]+=count_direction[X_AXIS];   
-        #endif
-      }
-
-      counter_y += current_block->steps_y;
-      if (counter_y > 0) {
-        WRITE(Y_STEP_PIN, HIGH);
-        counter_y -= current_block->step_event_count;
-        WRITE(Y_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[Y_AXIS]+=count_direction[Y_AXIS];
-        #endif
-      }
-
-      counter_z += current_block->steps_z;
-      if (counter_z > 0) {
-        WRITE(Z_STEP_PIN, HIGH);
-        counter_z -= current_block->step_event_count;
-        WRITE(Z_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[Z_AXIS]+=count_direction[Z_AXIS];
-        #endif
-      }
-
-      #ifndef ADVANCE
-        counter_e += current_block->steps_e;
-        if (counter_e > 0) {
-          WRITE(E_STEP_PIN, HIGH);
-          counter_e -= current_block->step_event_count;
-          WRITE(E_STEP_PIN, LOW);
-        }
-      #endif //!ADVANCE
-      step_events_completed += 1;  
-      if(step_events_completed >= current_block->step_event_count) break;
-    }
-    // Calculare new timer value
-    unsigned short timer;
-    unsigned short step_rate;
-    if (step_events_completed <= current_block->accelerate_until) {
-      MultiU24X24toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-      acc_step_rate += current_block->initial_rate;
-      
-      // upper limit
-      if(acc_step_rate > current_block->nominal_rate)
-        acc_step_rate = current_block->nominal_rate;
-
-      // step_rate to timer interval
-      timer = calc_timer(acc_step_rate);
-      #ifdef ADVANCE
-        advance += advance_rate;
-      #endif
-      acceleration_time += timer;
-      OCR1A = timer;
-    } 
-    else if (step_events_completed > current_block->decelerate_after) {   
-      MultiU24X24toH16(step_rate, deceleration_time, current_block->acceleration_rate);
-      
-      if(step_rate > acc_step_rate) { // Check step_rate stays positive
-        step_rate = current_block->final_rate;
-      }
-      else {
-        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.
-      }
-
-      // lower limit
-      if(step_rate < current_block->final_rate)
-        step_rate = current_block->final_rate;
-
-      // step_rate to timer interval
-      timer = calc_timer(step_rate);
-      #ifdef ADVANCE
-        advance -= advance_rate;
-        if(advance < final_advance)
-          advance = final_advance;
-      #endif //ADVANCE
-      deceleration_time += timer;
-      OCR1A = timer;
-    }       
-    // If current block is finished, reset pointer 
-    if (step_events_completed >= current_block->step_event_count) {
-      current_block = NULL;
-      plan_discard_current_block();
-    }   
-  } 
-  cli(); // disable interrupts
-  busy=false;
-}
-
-#ifdef ADVANCE
-  unsigned char old_OCR0A;
-  // Timer interrupt for E. e_steps is set in the main routine;
-  // Timer 0 is shared with millies
-  ISR(TIMER0_COMPA_vect)
-  {
-    // Critical section needed because Timer 1 interrupt has higher priority. 
-    // The pin set functions are placed on trategic position to comply with the stepper driver timing.
-    WRITE(E_STEP_PIN, LOW);
-    // Set E direction (Depends on E direction + advance)
-    if (e_steps < 0) {
-      WRITE(E_DIR_PIN,INVERT_E_DIR);    
-      e_steps++;
-      WRITE(E_STEP_PIN, HIGH);
-    } 
-    if (e_steps > 0) {
-      WRITE(E_DIR_PIN,!INVERT_E_DIR);
-      e_steps--;
-      WRITE(E_STEP_PIN, HIGH);
-    }
-    old_OCR0A += 25; // 10kHz interrupt
-    OCR0A = old_OCR0A;
-  }
-#endif // ADVANCE
-
-void st_init()
-{
-    //Initialize Dir Pins
-  #if X_DIR_PIN > -1
-    SET_OUTPUT(X_DIR_PIN);
-  #endif
-  #if Y_DIR_PIN > -1 
-    SET_OUTPUT(Y_DIR_PIN);
-  #endif
-  #if Z_DIR_PIN > -1 
-    SET_OUTPUT(Z_DIR_PIN);
-  #endif
-  #if E_DIR_PIN > -1 
-    SET_OUTPUT(E_DIR_PIN);
-  #endif
-
-  //Initialize Enable Pins - steppers default to disabled.
-
-  #if (X_ENABLE_PIN > -1)
-    SET_OUTPUT(X_ENABLE_PIN);
-    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
-  #endif
-  #if (Y_ENABLE_PIN > -1)
-    SET_OUTPUT(Y_ENABLE_PIN);
-    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
-  #endif
-  #if (Z_ENABLE_PIN > -1)
-    SET_OUTPUT(Z_ENABLE_PIN);
-    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
-  #endif
-  #if (E_ENABLE_PIN > -1)
-    SET_OUTPUT(E_ENABLE_PIN);
-    if(!E_ENABLE_ON) WRITE(E_ENABLE_PIN,HIGH);
-  #endif
-
-  //endstops and pullups
-  #ifdef ENDSTOPPULLUPS
-    #if X_MIN_PIN > -1
-      SET_INPUT(X_MIN_PIN); 
-      WRITE(X_MIN_PIN,HIGH);
-    #endif
-    #if X_MAX_PIN > -1
-      SET_INPUT(X_MAX_PIN); 
-      WRITE(X_MAX_PIN,HIGH);
-    #endif
-    #if Y_MIN_PIN > -1
-      SET_INPUT(Y_MIN_PIN); 
-      WRITE(Y_MIN_PIN,HIGH);
-    #endif
-    #if Y_MAX_PIN > -1
-      SET_INPUT(Y_MAX_PIN); 
-      WRITE(Y_MAX_PIN,HIGH);
-    #endif
-    #if Z_MIN_PIN > -1
-      SET_INPUT(Z_MIN_PIN); 
-      WRITE(Z_MIN_PIN,HIGH);
-    #endif
-    #if Z_MAX_PIN > -1
-      SET_INPUT(Z_MAX_PIN); 
-      WRITE(Z_MAX_PIN,HIGH);
-    #endif
-  #else //ENDSTOPPULLUPS
-    #if X_MIN_PIN > -1
-      SET_INPUT(X_MIN_PIN); 
-    #endif
-    #if X_MAX_PIN > -1
-      SET_INPUT(X_MAX_PIN); 
-    #endif
-    #if Y_MIN_PIN > -1
-      SET_INPUT(Y_MIN_PIN); 
-    #endif
-    #if Y_MAX_PIN > -1
-      SET_INPUT(Y_MAX_PIN); 
-    #endif
-    #if Z_MIN_PIN > -1
-      SET_INPUT(Z_MIN_PIN); 
-    #endif
-    #if Z_MAX_PIN > -1
-      SET_INPUT(Z_MAX_PIN); 
-    #endif
-  #endif //ENDSTOPPULLUPS
- 
-
-  //Initialize Step Pins
-  #if (X_STEP_PIN > -1) 
-    SET_OUTPUT(X_STEP_PIN);
-  #endif  
-  #if (Y_STEP_PIN > -1) 
-    SET_OUTPUT(Y_STEP_PIN);
-  #endif  
-  #if (Z_STEP_PIN > -1) 
-    SET_OUTPUT(Z_STEP_PIN);
-  #endif  
-  #if (E_STEP_PIN > -1) 
-    SET_OUTPUT(E_STEP_PIN);
-  #endif  
-
-  // waveform generation = 0100 = CTC
-  TCCR1B &= ~(1<<WGM13);
-  TCCR1B |=  (1<<WGM12);
-  TCCR1A &= ~(1<<WGM11); 
-  TCCR1A &= ~(1<<WGM10);
-
-  // output mode = 00 (disconnected)
-  TCCR1A &= ~(3<<COM1A0); 
-  TCCR1A &= ~(3<<COM1B0); 
-  TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (2<<CS10); // 2MHz timer
-
-  OCR1A = 0x4000;
-  DISABLE_STEPPER_DRIVER_INTERRUPT();  
-
-  #ifdef ADVANCE
-    e_steps = 0;
-    TIMSK0 |= (1<<OCIE0A);
-  #endif //ADVANCE
-  sei();
-}
-
-// Block until all buffered steps are executed
-void st_synchronize()
-{
-  while(plan_get_current_block()) {
-    manage_heater();
-    manage_inactivity(1);
-    LCD_STATUS;
-  }   
-}
+/*
+  stepper.c - stepper motor driver: executes motion plans using stepper motors
+  Part of Grbl
+
+  Copyright (c) 2009-2011 Simen Svale Skogsrud
+
+  Grbl is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  Grbl is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
+   and Philipp Tiefenbacher. */
+
+#include "stepper.h"
+#include "Configuration.h"
+#include "Marlin.h"
+#include "planner.h"
+#include "pins.h"
+#include "fastio.h"
+#include "temperature.h"
+#include "ultralcd.h"
+
+#include "speed_lookuptable.h"
+
+
+
+//===========================================================================
+//=============================public variables  ============================
+//===========================================================================
+block_t *current_block;  // A pointer to the block currently being traced
+
+
+
+//===========================================================================
+//=============================private variables ============================
+//===========================================================================
+//static makes it inpossible to be called from outside of this file by extern.!
+
+// Variables used by The Stepper Driver Interrupt
+static unsigned char out_bits;        // The next stepping-bits to be output
+static long counter_x,       // Counter variables for the bresenham line tracer
+            counter_y, 
+            counter_z,       
+            counter_e;
+static unsigned long step_events_completed; // The number of step events executed in the current block
+#ifdef ADVANCE
+  static long advance_rate, advance, final_advance = 0;
+  static short old_advance = 0;
+  static short e_steps;
+#endif
+static unsigned char busy = false; // TRUE when SIG_OUTPUT_COMPARE1A is being serviced. Used to avoid retriggering that handler.
+static long acceleration_time, deceleration_time;
+//static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
+static unsigned short acc_step_rate; // needed for deccelaration start point
+static char step_loops;
+
+volatile long endstops_trigsteps[3]={0,0,0};
+volatile long endstops_stepsTotal,endstops_stepsDone;
+static volatile bool endstops_hit=false;
+
+// if DEBUG_STEPS is enabled, M114 can be used to compare two methods of determining the X,Y,Z position of the printer.
+// for debugging purposes only, should be disabled by default
+#ifdef DEBUG_STEPS
+  volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
+  volatile int count_direction[NUM_AXIS] = { 1, 1, 1, 1};
+#endif
+
+//===========================================================================
+//=============================functions         ============================
+//===========================================================================
+  
+
+// intRes = intIn1 * intIn2 >> 16
+// uses:
+// r26 to store 0
+// r27 to store the byte 1 of the 24 bit result
+#define MultiU16X8toH16(intRes, charIn1, intIn2) \
+asm volatile ( \
+"clr r26 \n\t" \
+"mul %A1, %B2 \n\t" \
+"movw %A0, r0 \n\t" \
+"mul %A1, %A2 \n\t" \
+"add %A0, r1 \n\t" \
+"adc %B0, r26 \n\t" \
+"lsr r0 \n\t" \
+"adc %A0, r26 \n\t" \
+"adc %B0, r26 \n\t" \
+"clr r1 \n\t" \
+: \
+"=&r" (intRes) \
+: \
+"d" (charIn1), \
+"d" (intIn2) \
+: \
+"r26" \
+)
+
+// intRes = longIn1 * longIn2 >> 24
+// uses:
+// r26 to store 0
+// r27 to store the byte 1 of the 48bit result
+#define MultiU24X24toH16(intRes, longIn1, longIn2) \
+asm volatile ( \
+"clr r26 \n\t" \
+"mul %A1, %B2 \n\t" \
+"mov r27, r1 \n\t" \
+"mul %B1, %C2 \n\t" \
+"movw %A0, r0 \n\t" \
+"mul %C1, %C2 \n\t" \
+"add %B0, r0 \n\t" \
+"mul %C1, %B2 \n\t" \
+"add %A0, r0 \n\t" \
+"adc %B0, r1 \n\t" \
+"mul %A1, %C2 \n\t" \
+"add r27, r0 \n\t" \
+"adc %A0, r1 \n\t" \
+"adc %B0, r26 \n\t" \
+"mul %B1, %B2 \n\t" \
+"add r27, r0 \n\t" \
+"adc %A0, r1 \n\t" \
+"adc %B0, r26 \n\t" \
+"mul %C1, %A2 \n\t" \
+"add r27, r0 \n\t" \
+"adc %A0, r1 \n\t" \
+"adc %B0, r26 \n\t" \
+"mul %B1, %A2 \n\t" \
+"add r27, r1 \n\t" \
+"adc %A0, r26 \n\t" \
+"adc %B0, r26 \n\t" \
+"lsr r27 \n\t" \
+"adc %A0, r26 \n\t" \
+"adc %B0, r26 \n\t" \
+"clr r1 \n\t" \
+: \
+"=&r" (intRes) \
+: \
+"d" (longIn1), \
+"d" (longIn2) \
+: \
+"r26" , "r27" \
+)
+
+// Some useful constants
+
+#define ENABLE_STEPPER_DRIVER_INTERRUPT()  TIMSK1 |= (1<<OCIE1A)
+#define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1<<OCIE1A)
+
+
+void endstops_triggered(const unsigned long &stepstaken)  
+{
+  //this will only work if there is no bufferig
+  //however, if you perform a move at which the endstops should be triggered, and wait for it to complete, i.e. by blocking command, it should work
+  //yes, it uses floats, but: if endstops are triggered, thats hopefully not critical anymore anyways.
+  //endstops_triggerpos;
+  
+  if(endstops_hit) //hitting a second time while the first hit is not reported
+    return;
+  if(current_block == NULL)
+    return;
+  endstops_stepsTotal=current_block->step_event_count;
+  endstops_stepsDone=stepstaken;
+  endstops_trigsteps[0]=current_block->steps_x;
+  endstops_trigsteps[1]=current_block->steps_y;
+  endstops_trigsteps[2]=current_block->steps_z;
+
+  endstops_hit=true;
+}
+
+void checkHitEndstops()
+{
+  if( !endstops_hit)
+   return;
+  float endstops_triggerpos[3]={0,0,0};
+  float ratiodone=endstops_stepsDone/float(endstops_stepsTotal);  //ratio of current_block thas was performed
+  
+  endstops_triggerpos[0]=current_position[0]-(endstops_trigsteps[0]*ratiodone)/float(axis_steps_per_unit[0]);
+  endstops_triggerpos[1]=current_position[1]-(endstops_trigsteps[1]*ratiodone)/float(axis_steps_per_unit[1]);
+  endstops_triggerpos[2]=current_position[2]-(endstops_trigsteps[2]*ratiodone)/float(axis_steps_per_unit[2]);
+ SERIAL_ECHO_START;
+ SERIAL_ECHOPGM("endstops hit: ");
+ SERIAL_ECHOPAIR(" X:",endstops_triggerpos[0]);
+ SERIAL_ECHOPAIR(" Y:",endstops_triggerpos[1]);
+ SERIAL_ECHOPAIR(" Z:",endstops_triggerpos[2]);
+ SERIAL_ECHOLN("");
+ endstops_hit=false;
+}
+
+void endstops_hit_on_purpose()
+{
+  endstops_hit=false;
+}
+
+//         __________________________
+//        /|                        |\     _________________         ^
+//       / |                        | \   /|               |\        |
+//      /  |                        |  \ / |               | \       s
+//     /   |                        |   |  |               |  \      p
+//    /    |                        |   |  |               |   \     e
+//   +-----+------------------------+---+--+---------------+----+    e
+//   |               BLOCK 1            |      BLOCK 2          |    d
+//
+//                           time ----->
+// 
+//  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates 
+//  first block->accelerate_until step_events_completed, then keeps going at constant speed until 
+//  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
+//  The slope of acceleration is calculated with the leib ramp alghorithm.
+
+void st_wake_up() {
+  //  TCNT1 = 0;
+  if(busy == false) 
+  ENABLE_STEPPER_DRIVER_INTERRUPT();  
+}
+
+inline unsigned short calc_timer(unsigned short step_rate) {
+  unsigned short timer;
+  if(step_rate > MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;
+  
+  if(step_rate > 20000) { // If steprate > 20kHz >> step 4 times
+    step_rate = step_rate >> 2;
+    step_loops = 4;
+  }
+  else if(step_rate > 10000) { // If steprate > 10kHz >> step 2 times
+    step_rate = step_rate >> 1;
+    step_loops = 2;
+  }
+  else {
+    step_loops = 1;
+  } 
+  
+  if(step_rate < 32) step_rate = 32;
+  step_rate -= 32; // Correct for minimal speed
+  if(step_rate >= (8*256)){ // higher step rate 
+    unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate>>8)][0];
+    unsigned char tmp_step_rate = (step_rate & 0x00ff);
+    unsigned short gain = (unsigned short)pgm_read_word_near(table_address+2);
+    MultiU16X8toH16(timer, tmp_step_rate, gain);
+    timer = (unsigned short)pgm_read_word_near(table_address) - timer;
+  }
+  else { // lower step rates
+    unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
+    table_address += ((step_rate)>>1) & 0xfffc;
+    timer = (unsigned short)pgm_read_word_near(table_address);
+    timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))>>3);
+  }
+  //if(timer < 100) timer = 100;
+  return timer;
+}
+
+// Initializes the trapezoid generator from the current block. Called whenever a new 
+// block begins.
+inline void trapezoid_generator_reset() {
+  #ifdef ADVANCE
+    advance = current_block->initial_advance;
+    final_advance = current_block->final_advance;
+  #endif
+  deceleration_time = 0;
+  // step_rate to timer interval
+  acc_step_rate = current_block->initial_rate;
+  acceleration_time = calc_timer(acc_step_rate);
+  OCR1A = acceleration_time;
+}
+
+// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.  
+// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately. 
+ISR(TIMER1_COMPA_vect)
+{        
+  if(busy){ 
+    SERIAL_ERROR_START
+    SERIAL_ERROR(*(unsigned short *)OCR1A);
+    SERIAL_ERRORLNPGM(" ISR overtaking itself.");
+    return; 
+  } // The busy-flag is used to avoid reentering this interrupt
+
+  busy = true;
+  sei(); // Re enable interrupts (normally disabled while inside an interrupt handler)
+
+  // If there is no current block, attempt to pop one from the buffer
+  if (current_block == NULL) {
+    // Anything in the buffer?
+    current_block = plan_get_current_block();
+    if (current_block != NULL) {
+      trapezoid_generator_reset();
+      counter_x = -(current_block->step_event_count >> 1);
+      counter_y = counter_x;
+      counter_z = counter_x;
+      counter_e = counter_x;
+      step_events_completed = 0;
+      #ifdef ADVANCE
+      e_steps = 0;
+      #endif
+    } 
+    else {
+//      DISABLE_STEPPER_DRIVER_INTERRUPT();
+    }    
+  } 
+
+  if (current_block != NULL) {
+    // Set directions TO DO This should be done once during init of trapezoid. Endstops -> interrupt
+    out_bits = current_block->direction_bits;
+
+    #ifdef ADVANCE
+        // Calculate E early.
+        counter_e += current_block->steps_e;
+        if (counter_e > 0) {
+          counter_e -= current_block->step_event_count;
+          if ((out_bits & (1<<E_AXIS)) != 0) { // - direction
+            CRITICAL_SECTION_START;
+            e_steps--;
+            CRITICAL_SECTION_END;
+          }
+          else {
+            CRITICAL_SECTION_START;
+            e_steps++;
+            CRITICAL_SECTION_END;
+          }
+        }    
+        // Do E steps + advance steps
+        CRITICAL_SECTION_START;
+        e_steps += ((advance >> 16) - old_advance);
+        CRITICAL_SECTION_END;
+        old_advance = advance >> 16;  
+    #endif //ADVANCE
+
+    // Set direction en check limit switches
+    if ((out_bits & (1<<X_AXIS)) != 0) {   // -direction
+      WRITE(X_DIR_PIN, INVERT_X_DIR);
+      #ifdef DEBUG_STEPS
+        count_direction[X_AXIS]=-1;
+      #endif
+      #if X_MIN_PIN > -1
+            if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
+              endstops_triggered(step_events_completed);
+              step_events_completed = current_block->step_event_count;
+            }
+      #endif
+    }
+    else { // +direction 
+      WRITE(X_DIR_PIN,!INVERT_X_DIR);
+      #ifdef DEBUG_STEPS
+        count_direction[X_AXIS]=1;
+      #endif
+      #if X_MAX_PIN > -1
+        if((READ(X_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_x >0)){
+          endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
+        #endif
+    }
+
+    if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
+      WRITE(Y_DIR_PIN,INVERT_Y_DIR);
+      #ifdef DEBUG_STEPS
+        count_direction[Y_AXIS]=-1;
+      #endif
+      #if Y_MIN_PIN > -1
+        if(READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) {
+          endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
+      #endif
+    }
+    else { // +direction
+    WRITE(Y_DIR_PIN,!INVERT_Y_DIR);
+      #ifdef DEBUG_STEPS
+        count_direction[Y_AXIS]=1;
+      #endif
+      #if Y_MAX_PIN > -1
+      if((READ(Y_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y >0)){
+          endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
+      #endif
+    }
+
+    if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
+      WRITE(Z_DIR_PIN,INVERT_Z_DIR);
+      #ifdef DEBUG_STEPS
+      count_direction[Z_AXIS]=-1;
+      #endif
+      #if Z_MIN_PIN > -1
+        if(READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) {
+          endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
+      #endif
+    }
+    else { // +direction
+      WRITE(Z_DIR_PIN,!INVERT_Z_DIR);
+      #ifdef DEBUG_STEPS
+        count_direction[Z_AXIS]=1;
+      #endif
+      #if Z_MAX_PIN > -1
+        if((READ(Z_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_z >0)){
+          endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
+      #endif
+    }
+
+    #ifndef ADVANCE
+      if ((out_bits & (1<<E_AXIS)) != 0)   // -direction
+        WRITE(E_DIR_PIN,INVERT_E_DIR);
+      else // +direction
+        WRITE(E_DIR_PIN,!INVERT_E_DIR);
+    #endif //!ADVANCE
+
+    for(int8_t i=0; i < step_loops; i++) { // Take multiple steps per interrupt (For high speed moves) 
+      counter_x += current_block->steps_x;
+      if (counter_x > 0) {
+        WRITE(X_STEP_PIN, HIGH);
+        counter_x -= current_block->step_event_count;
+        WRITE(X_STEP_PIN, LOW);
+        #ifdef DEBUG_STEPS
+          count_position[X_AXIS]+=count_direction[X_AXIS];   
+        #endif
+      }
+
+      counter_y += current_block->steps_y;
+      if (counter_y > 0) {
+        WRITE(Y_STEP_PIN, HIGH);
+        counter_y -= current_block->step_event_count;
+        WRITE(Y_STEP_PIN, LOW);
+        #ifdef DEBUG_STEPS
+          count_position[Y_AXIS]+=count_direction[Y_AXIS];
+        #endif
+      }
+
+      counter_z += current_block->steps_z;
+      if (counter_z > 0) {
+        WRITE(Z_STEP_PIN, HIGH);
+        counter_z -= current_block->step_event_count;
+        WRITE(Z_STEP_PIN, LOW);
+        #ifdef DEBUG_STEPS
+          count_position[Z_AXIS]+=count_direction[Z_AXIS];
+        #endif
+      }
+
+      #ifndef ADVANCE
+        counter_e += current_block->steps_e;
+        if (counter_e > 0) {
+          WRITE(E_STEP_PIN, HIGH);
+          counter_e -= current_block->step_event_count;
+          WRITE(E_STEP_PIN, LOW);
+        }
+      #endif //!ADVANCE
+      step_events_completed += 1;  
+      if(step_events_completed >= current_block->step_event_count) break;
+    }
+    // Calculare new timer value
+    unsigned short timer;
+    unsigned short step_rate;
+    if (step_events_completed <= current_block->accelerate_until) {
+      MultiU24X24toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+      acc_step_rate += current_block->initial_rate;
+      
+      // upper limit
+      if(acc_step_rate > current_block->nominal_rate)
+        acc_step_rate = current_block->nominal_rate;
+
+      // step_rate to timer interval
+      timer = calc_timer(acc_step_rate);
+      #ifdef ADVANCE
+        advance += advance_rate;
+      #endif
+      acceleration_time += timer;
+      OCR1A = timer;
+    } 
+    else if (step_events_completed > current_block->decelerate_after) {   
+      MultiU24X24toH16(step_rate, deceleration_time, current_block->acceleration_rate);
+      
+      if(step_rate > acc_step_rate) { // Check step_rate stays positive
+        step_rate = current_block->final_rate;
+      }
+      else {
+        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.
+      }
+
+      // lower limit
+      if(step_rate < current_block->final_rate)
+        step_rate = current_block->final_rate;
+
+      // step_rate to timer interval
+      timer = calc_timer(step_rate);
+      #ifdef ADVANCE
+        advance -= advance_rate;
+        if(advance < final_advance)
+          advance = final_advance;
+      #endif //ADVANCE
+      deceleration_time += timer;
+      OCR1A = timer;
+    }
+    else {
+      timer = calc_timer(current_block->nominal_rate);
+      OCR1A = timer;
+    }
+    
+    // If current block is finished, reset pointer 
+    if (step_events_completed >= current_block->step_event_count) {
+      current_block = NULL;
+      plan_discard_current_block();
+    }   
+  } 
+  cli(); // disable interrupts
+  busy=false;
+}
+
+#ifdef ADVANCE
+  unsigned char old_OCR0A;
+  // Timer interrupt for E. e_steps is set in the main routine;
+  // Timer 0 is shared with millies
+  ISR(TIMER0_COMPA_vect)
+  {
+    // Critical section needed because Timer 1 interrupt has higher priority. 
+    // The pin set functions are placed on trategic position to comply with the stepper driver timing.
+    WRITE(E_STEP_PIN, LOW);
+    // Set E direction (Depends on E direction + advance)
+    if (e_steps < 0) {
+      WRITE(E_DIR_PIN,INVERT_E_DIR);    
+      e_steps++;
+      WRITE(E_STEP_PIN, HIGH);
+    } 
+    if (e_steps > 0) {
+      WRITE(E_DIR_PIN,!INVERT_E_DIR);
+      e_steps--;
+      WRITE(E_STEP_PIN, HIGH);
+    }
+    old_OCR0A += 25; // 10kHz interrupt
+    OCR0A = old_OCR0A;
+  }
+#endif // ADVANCE
+
+void st_init()
+{
+    //Initialize Dir Pins
+  #if X_DIR_PIN > -1
+    SET_OUTPUT(X_DIR_PIN);
+  #endif
+  #if Y_DIR_PIN > -1 
+    SET_OUTPUT(Y_DIR_PIN);
+  #endif
+  #if Z_DIR_PIN > -1 
+    SET_OUTPUT(Z_DIR_PIN);
+  #endif
+  #if E_DIR_PIN > -1 
+    SET_OUTPUT(E_DIR_PIN);
+  #endif
+
+  //Initialize Enable Pins - steppers default to disabled.
+
+  #if (X_ENABLE_PIN > -1)
+    SET_OUTPUT(X_ENABLE_PIN);
+    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
+  #endif
+  #if (Y_ENABLE_PIN > -1)
+    SET_OUTPUT(Y_ENABLE_PIN);
+    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
+  #endif
+  #if (Z_ENABLE_PIN > -1)
+    SET_OUTPUT(Z_ENABLE_PIN);
+    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
+  #endif
+  #if (E_ENABLE_PIN > -1)
+    SET_OUTPUT(E_ENABLE_PIN);
+    if(!E_ENABLE_ON) WRITE(E_ENABLE_PIN,HIGH);
+  #endif
+
+  //endstops and pullups
+  #ifdef ENDSTOPPULLUPS
+    #if X_MIN_PIN > -1
+      SET_INPUT(X_MIN_PIN); 
+      WRITE(X_MIN_PIN,HIGH);
+    #endif
+    #if X_MAX_PIN > -1
+      SET_INPUT(X_MAX_PIN); 
+      WRITE(X_MAX_PIN,HIGH);
+    #endif
+    #if Y_MIN_PIN > -1
+      SET_INPUT(Y_MIN_PIN); 
+      WRITE(Y_MIN_PIN,HIGH);
+    #endif
+    #if Y_MAX_PIN > -1
+      SET_INPUT(Y_MAX_PIN); 
+      WRITE(Y_MAX_PIN,HIGH);
+    #endif
+    #if Z_MIN_PIN > -1
+      SET_INPUT(Z_MIN_PIN); 
+      WRITE(Z_MIN_PIN,HIGH);
+    #endif
+    #if Z_MAX_PIN > -1
+      SET_INPUT(Z_MAX_PIN); 
+      WRITE(Z_MAX_PIN,HIGH);
+    #endif
+  #else //ENDSTOPPULLUPS
+    #if X_MIN_PIN > -1
+      SET_INPUT(X_MIN_PIN); 
+    #endif
+    #if X_MAX_PIN > -1
+      SET_INPUT(X_MAX_PIN); 
+    #endif
+    #if Y_MIN_PIN > -1
+      SET_INPUT(Y_MIN_PIN); 
+    #endif
+    #if Y_MAX_PIN > -1
+      SET_INPUT(Y_MAX_PIN); 
+    #endif
+    #if Z_MIN_PIN > -1
+      SET_INPUT(Z_MIN_PIN); 
+    #endif
+    #if Z_MAX_PIN > -1
+      SET_INPUT(Z_MAX_PIN); 
+    #endif
+  #endif //ENDSTOPPULLUPS
+ 
+
+  //Initialize Step Pins
+  #if (X_STEP_PIN > -1) 
+    SET_OUTPUT(X_STEP_PIN);
+  #endif  
+  #if (Y_STEP_PIN > -1) 
+    SET_OUTPUT(Y_STEP_PIN);
+  #endif  
+  #if (Z_STEP_PIN > -1) 
+    SET_OUTPUT(Z_STEP_PIN);
+  #endif  
+  #if (E_STEP_PIN > -1) 
+    SET_OUTPUT(E_STEP_PIN);
+  #endif  
+
+  // waveform generation = 0100 = CTC
+  TCCR1B &= ~(1<<WGM13);
+  TCCR1B |=  (1<<WGM12);
+  TCCR1A &= ~(1<<WGM11); 
+  TCCR1A &= ~(1<<WGM10);
+
+  // output mode = 00 (disconnected)
+  TCCR1A &= ~(3<<COM1A0); 
+  TCCR1A &= ~(3<<COM1B0); 
+  TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (2<<CS10); // 2MHz timer
+
+  OCR1A = 0x4000;
+  DISABLE_STEPPER_DRIVER_INTERRUPT();  
+
+  #ifdef ADVANCE
+    e_steps = 0;
+    TIMSK0 |= (1<<OCIE0A);
+  #endif //ADVANCE
+  sei();
+}
+
+// Block until all buffered steps are executed
+void st_synchronize()
+{
+  while(plan_get_current_block()) {
+    manage_heater();
+    manage_inactivity(1);
+    LCD_STATUS;
+  }   
+}
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 8ea8ee0..3e6edee 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1,570 +1,572 @@
-/*
-  temperature.c - temperature control
-  Part of Marlin
-  
- Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/*
- This firmware is a mashup between Sprinter and grbl.
-  (https://github.com/kliment/Sprinter)
-  (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
-    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
-
- This firmware is optimized for gen6 electronics.
- */
-
-#include "fastio.h"
-#include "Configuration.h"
-#include "pins.h"
-#include "Marlin.h"
-#include "ultralcd.h"
-#include "temperature.h"
-#include "watchdog.h"
-
-//===========================================================================
-//=============================public variables============================
-//===========================================================================
-int target_raw[3] = {0, 0, 0};
-int current_raw[3] = {0, 0, 0};
-
-#ifdef PIDTEMP
-  
-  // probably used external
-  float HeaterPower;
-  float pid_setpoint = 0.0;
-
-  
-  float Kp=DEFAULT_Kp;
-  float Ki=DEFAULT_Ki;
-  float Kd=DEFAULT_Kd;
-  float Kc=DEFAULT_Kc;
-#endif //PIDTEMP
-  
-  
-//===========================================================================
-//=============================private variables============================
-//===========================================================================
-static bool temp_meas_ready = false;
-
-static unsigned long previous_millis_heater, previous_millis_bed_heater;
-
-#ifdef PIDTEMP
-  //static cannot be external:
-  static float temp_iState = 0;
-  static float temp_dState = 0;
-  static float pTerm;
-  static float iTerm;
-  static float dTerm;
-  //int output;
-  static float pid_error;
-  static float temp_iState_min;
-  static float temp_iState_max;
-  static float pid_input;
-  static float pid_output;
-  static bool pid_reset;
- 
-#endif //PIDTEMP
-  
-#ifdef WATCHPERIOD
-  static int watch_raw[3] = {-1000,-1000,-1000};
-  static unsigned long watchmillis = 0;
-#endif //WATCHPERIOD
-
-#ifdef HEATER_0_MINTEMP
-  static int minttemp_0 = temp2analog(HEATER_0_MINTEMP);
-#endif //MINTEMP
-#ifdef HEATER_0_MAXTEMP
-  static int maxttemp_0 = temp2analog(HEATER_0_MAXTEMP);
-#endif //MAXTEMP
-
-#ifdef HEATER_1_MINTEMP
-  static int minttemp_1 = temp2analog(HEATER_1_MINTEMP);
-#endif //MINTEMP
-#ifdef HEATER_1_MAXTEMP
-  static int maxttemp_1 = temp2analog(HEATER_1_MAXTEMP);
-#endif //MAXTEMP
-
-#ifdef BED_MINTEMP
-  static int bed_minttemp = temp2analog(BED_MINTEMP);
-#endif //BED_MINTEMP
-#ifdef BED_MAXTEMP
-  static int bed_maxttemp = temp2analog(BED_MAXTEMP);
-#endif //BED_MAXTEMP
-
-//===========================================================================
-//=============================functions         ============================
-//===========================================================================
-  
-void manage_heater()
-{
-  #ifdef USE_WATCHDOG
-    wd_reset();
-  #endif
-  
-  float pid_input;
-  float pid_output;
-  if(temp_meas_ready != true)   //better readability
-    return; 
-
-  CRITICAL_SECTION_START;
-    temp_meas_ready = false;
-  CRITICAL_SECTION_END;
-
-  #ifdef PIDTEMP
-    pid_input = analog2temp(current_raw[TEMPSENSOR_HOTEND_0]);
-
-    #ifndef PID_OPENLOOP
-        pid_error = pid_setpoint - pid_input;
-        if(pid_error > 10){
-          pid_output = PID_MAX;
-          pid_reset = true;
-        }
-        else if(pid_error < -10) {
-          pid_output = 0;
-          pid_reset = true;
-        }
-        else {
-          if(pid_reset == true) {
-            temp_iState = 0.0;
-            pid_reset = false;
-          }
-          pTerm = Kp * pid_error;
-          temp_iState += pid_error;
-          temp_iState = constrain(temp_iState, temp_iState_min, temp_iState_max);
-          iTerm = Ki * temp_iState;
-          //K1 defined in Configuration.h in the PID settings
-          #define K2 (1.0-K1)
-          dTerm = (Kd * (pid_input - temp_dState))*K2 + (K1 * dTerm);
-          temp_dState = pid_input;
-          #ifdef PID_ADD_EXTRUSION_RATE
-            pTerm+=Kc*current_block->speed_e; //additional heating if extrusion speed is high
-          #endif
-          pid_output = constrain(pTerm + iTerm - dTerm, 0, PID_MAX);
-          
-        }
-    #endif //PID_OPENLOOP
-    #ifdef PID_DEBUG
-     //SERIAL_ECHOLN(" PIDDEBUG Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm<<" iTerm "<<iTerm<<" dTerm "<<dTerm);  
-    #endif //PID_DEBUG
-    HeaterPower=pid_output;
-    analogWrite(HEATER_0_PIN, pid_output);
-  #endif //PIDTEMP
-
-  #ifndef PIDTEMP
-    if(current_raw[0] >= target_raw[0])
-    {
-      WRITE(HEATER_0_PIN,LOW);
-    }
-    else 
-    {
-      WRITE(HEATER_0_PIN,HIGH);
-    }
-  #endif
-    
-  if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
-    return;
-  previous_millis_bed_heater = millis();
-  
-  #if TEMP_1_PIN > -1
-    if(current_raw[TEMPSENSOR_BED] >= target_raw[TEMPSENSOR_BED])
-    {
-      WRITE(HEATER_1_PIN,LOW);
-    }
-    else 
-    {
-      WRITE(HEATER_1_PIN,HIGH);
-    }
-  #endif
-}
-
-// Takes hot end temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analog(int celsius) {
-  #ifdef HEATER_0_USES_THERMISTOR
-    int raw = 0;
-    byte i;
-    
-    for (i=1; i<NUMTEMPS_HEATER_0; i++)
-    {
-      if (heater_0_temptable[i][1] < celsius)
-      {
-        raw = heater_0_temptable[i-1][0] + 
-          (celsius - heater_0_temptable[i-1][1]) * 
-          (heater_0_temptable[i][0] - heater_0_temptable[i-1][0]) /
-          (heater_0_temptable[i][1] - heater_0_temptable[i-1][1]);  
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == NUMTEMPS_HEATER_0) raw = heater_0_temptable[i-1][0];
-
-    return (1023 * OVERSAMPLENR) - raw;
-  #elif defined HEATER_0_USES_AD595
-    return celsius * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
-  #endif
-}
-
-// Takes bed temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analogBed(int celsius) {
-  #ifdef BED_USES_THERMISTOR
-
-    int raw = 0;
-    byte i;
-    
-    for (i=1; i<BNUMTEMPS; i++)
-    {
-      if (bedtemptable[i][1] < celsius)
-      {
-        raw = bedtemptable[i-1][0] + 
-          (celsius - bedtemptable[i-1][1]) * 
-          (bedtemptable[i][0] - bedtemptable[i-1][0]) /
-          (bedtemptable[i][1] - bedtemptable[i-1][1]);
-      
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == BNUMTEMPS) raw = bedtemptable[i-1][0];
-
-    return (1023 * OVERSAMPLENR) - raw;
-  #elif defined BED_USES_AD595
-    return lround(celsius * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
-  #endif
-}
-
-// Derived from RepRap FiveD extruder::getTemperature()
-// For hot end temperature measurement.
-float analog2temp(int raw) {
-  #ifdef HEATER_0_USES_THERMISTOR
-    float celsius = 0;
-    byte i;  
-    raw = (1023 * OVERSAMPLENR) - raw;
-    for (i=1; i<NUMTEMPS_HEATER_0; i++)
-    {
-      if (heater_0_temptable[i][0] > raw)
-      {
-        celsius  = heater_0_temptable[i-1][1] + 
-          (raw - heater_0_temptable[i-1][0]) * 
-          (float)(heater_0_temptable[i][1] - heater_0_temptable[i-1][1]) /
-          (float)(heater_0_temptable[i][0] - heater_0_temptable[i-1][0]);
-
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == NUMTEMPS_HEATER_0) celsius = heater_0_temptable[i-1][1];
-
-    return celsius;
-  #elif defined HEATER_0_USES_AD595
-    return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
-  #endif
-}
-
-// Derived from RepRap FiveD extruder::getTemperature()
-// For bed temperature measurement.
-float analog2tempBed(int raw) {
-  #ifdef BED_USES_THERMISTOR
-    int celsius = 0;
-    byte i;
-
-    raw = (1023 * OVERSAMPLENR) - raw;
-
-    for (i=1; i<BNUMTEMPS; i++)
-    {
-      if (bedtemptable[i][0] > raw)
-      {
-        celsius  = bedtemptable[i-1][1] + 
-          (raw - bedtemptable[i-1][0]) * 
-          (bedtemptable[i][1] - bedtemptable[i-1][1]) /
-          (bedtemptable[i][0] - bedtemptable[i-1][0]);
-
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == BNUMTEMPS) celsius = bedtemptable[i-1][1];
-
-    return celsius;
-    
-  #elif defined BED_USES_AD595
-    return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
-  #endif
-}
-
-void tp_init()
-{
-  #if (HEATER_0_PIN > -1) 
-    SET_OUTPUT(HEATER_0_PIN);
-  #endif  
-  #if (HEATER_1_PIN > -1) 
-    SET_OUTPUT(HEATER_1_PIN);
-  #endif  
-  #if (HEATER_2_PIN > -1) 
-    SET_OUTPUT(HEATER_2_PIN);
-  #endif  
-
-  #ifdef PIDTEMP
-    temp_iState_min = 0.0;
-    temp_iState_max = PID_INTEGRAL_DRIVE_MAX / Ki;
-  #endif //PIDTEMP
-
-  // Set analog inputs
-  ADCSRA = 1<<ADEN | 1<<ADSC | 1<<ADIF | 0x07;
-  
-  // Use timer0 for temperature measurement
-  // Interleave temperature interrupt with millies interrupt
-  OCR0B = 128;
-  TIMSK0 |= (1<<OCIE0B);  
-}
-
-
-
-void setWatch() 
-{  
-#ifdef WATCHPERIOD
-  if(isHeatingHotend0())
-  {
-    watchmillis = max(1,millis());
-    watch_raw[TEMPSENSOR_HOTEND_0] = current_raw[TEMPSENSOR_HOTEND_0];
-  }
-  else
-  {
-    watchmillis = 0;
-  } 
-#endif 
-}
-
-
-void disable_heater()
-{
-  #if TEMP_0_PIN > -1
-  target_raw[0]=0;
-   #if HEATER_0_PIN > -1  
-     WRITE(HEATER_0_PIN,LOW);
-   #endif
-  #endif
-     
-  #if TEMP_1_PIN > -1
-    target_raw[1]=0;
-    #if HEATER_1_PIN > -1 
-      WRITE(HEATER_1_PIN,LOW);
-    #endif
-  #endif
-      
-  #if TEMP_2_PIN > -1
-    target_raw[2]=0;
-    #if HEATER_2_PIN > -1  
-      WRITE(HEATER_2_PIN,LOW);
-    #endif
-  #endif 
-}
-
-// Timer 0 is shared with millies
-ISR(TIMER0_COMPB_vect)
-{
-  //these variables are only accesible from the ISR, but static, so they don't loose their value
-  static unsigned char temp_count = 0;
-  static unsigned long raw_temp_0_value = 0;
-  static unsigned long raw_temp_1_value = 0;
-  static unsigned long raw_temp_2_value = 0;
-  static unsigned char temp_state = 0;
-  
-  switch(temp_state) {
-    case 0: // Prepare TEMP_0
-      #if (TEMP_0_PIN > -1)
-        #if TEMP_0_PIN < 8
-          DIDR0 = 1 << TEMP_0_PIN; 
-        #else
-          DIDR2 = 1<<(TEMP_0_PIN - 8); 
-          ADCSRB = 1<<MUX5;
-        #endif
-        ADMUX = ((1 << REFS0) | (TEMP_0_PIN & 0x07));
-        ADCSRA |= 1<<ADSC; // Start conversion
-      #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
-      temp_state = 1;
-      break;
-    case 1: // Measure TEMP_0
-      #if (TEMP_0_PIN > -1)
-        raw_temp_0_value += ADC;
-      #endif
-      temp_state = 2;
-      break;
-    case 2: // Prepare TEMP_1
-      #if (TEMP_1_PIN > -1)
-        #if TEMP_1_PIN < 7
-          DIDR0 = 1<<TEMP_1_PIN; 
-        #else
-          DIDR2 = 1<<(TEMP_1_PIN - 8); 
-          ADCSRB = 1<<MUX5;
-        #endif
-        ADMUX = ((1 << REFS0) | (TEMP_1_PIN & 0x07));
-        ADCSRA |= 1<<ADSC; // Start conversion
-      #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
-      temp_state = 3;
-      break;
-    case 3: // Measure TEMP_1
-      #if (TEMP_1_PIN > -1)
-        raw_temp_1_value += ADC;
-      #endif
-      temp_state = 4;
-      break;
-    case 4: // Prepare TEMP_2
-      #if (TEMP_2_PIN > -1)
-        #if TEMP_2_PIN < 7
-          DIDR0 = 1 << TEMP_2_PIN; 
-        #else
-          DIDR2 = 1<<(TEMP_2_PIN - 8); 
-          ADCSRB = 1<<MUX5;
-        #endif
-        ADMUX = ((1 << REFS0) | (TEMP_2_PIN & 0x07));
-        ADCSRA |= 1<<ADSC; // Start conversion
-      #endif
-      #ifdef ULTIPANEL
-        buttons_check();
-      #endif
-      temp_state = 5;
-      break;
-    case 5: // Measure TEMP_2
-      #if (TEMP_2_PIN > -1)
-        raw_temp_2_value += ADC;
-      #endif
-      temp_state = 0;
-      temp_count++;
-      break;
-    default:
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("Temp measurement error!");
-      break;
-  }
-    
-  if(temp_count >= 16) // 6 ms * 16 = 96ms.
-  {
-    #ifdef HEATER_0_USES_AD595
-      current_raw[0] = raw_temp_0_value;
-    #else
-      current_raw[0] = 16383 - raw_temp_0_value;
-    #endif
-    
-    #ifdef HEATER_1_USES_AD595
-      current_raw[2] = raw_temp_2_value;
-    #else
-      current_raw[2] = 16383 - raw_temp_2_value;
-    #endif
-    
-    #ifdef BED_USES_AD595
-      current_raw[1] = raw_temp_1_value;
-    #else
-      current_raw[1] = 16383 - raw_temp_1_value;
-    #endif
-    
-    temp_meas_ready = true;
-    temp_count = 0;
-    raw_temp_0_value = 0;
-    raw_temp_1_value = 0;
-    raw_temp_2_value = 0;
-    #ifdef HEATER_0_MAXTEMP
-      #if (HEATER_0_PIN > -1)
-        if(current_raw[TEMPSENSOR_HOTEND_0] >= maxttemp_0) {
-          target_raw[TEMPSENSOR_HOTEND_0] = 0;
-          analogWrite(HEATER_0_PIN, 0);
-          SERIAL_ERROR_START;
-          SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MAXTEMP triggered !!");
-          kill();
-        }
-      #endif
-    #endif
-  #ifdef HEATER_1_MAXTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_1] >= maxttemp_1) {
-        target_raw[TEMPSENSOR_HOTEND_1] = 0;
-      if(current_raw[2] >= maxttemp_1) {
-        analogWrite(HEATER_2_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MAXTEMP triggered !!");
-        kill()
-      }
-    #endif
-  #endif //MAXTEMP
-  
-  #ifdef HEATER_0_MINTEMP
-    #if (HEATER_0_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_0] <= minttemp_0) {
-        target_raw[TEMPSENSOR_HOTEND_0] = 0;
-        analogWrite(HEATER_0_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
-  
-  #ifdef HEATER_1_MINTEMP
-    #if (HEATER_2_PIN > -1)
-      if(current_raw[TEMPSENSOR_HOTEND_1] <= minttemp_1) {
-        target_raw[TEMPSENSOR_HOTEND_1] = 0;
-        analogWrite(HEATER_2_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif //MAXTEMP
-  
-  #ifdef BED_MINTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[1] <= bed_minttemp) {
-        target_raw[1] = 0;
-        WRITE(HEATER_1_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperatur heated bed switched off. MINTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
-  
-  #ifdef BED_MAXTEMP
-    #if (HEATER_1_PIN > -1)
-      if(current_raw[1] >= bed_maxttemp) {
-        target_raw[1] = 0;
-        WRITE(HEATER_1_PIN, 0);
-        SERIAL_ERROR_START;
-        SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
-        kill();
-      }
-    #endif
-  #endif
-  }
-}
-
-
+/*
+  temperature.c - temperature control
+  Part of Marlin
+  
+ Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ 
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ This firmware is a mashup between Sprinter and grbl.
+  (https://github.com/kliment/Sprinter)
+  (https://github.com/simen/grbl/tree)
+ 
+ It has preliminary support for Matthew Roberts advance algorithm 
+    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
+
+ This firmware is optimized for gen6 electronics.
+ */
+#include <avr/pgmspace.h>
+
+#include "fastio.h"
+#include "Configuration.h"
+#include "pins.h"
+#include "Marlin.h"
+#include "ultralcd.h"
+#include "temperature.h"
+#include "watchdog.h"
+
+//===========================================================================
+//=============================public variables============================
+//===========================================================================
+int target_raw[3] = {0, 0, 0};
+int current_raw[3] = {0, 0, 0};
+
+#ifdef PIDTEMP
+  
+  // probably used external
+  float HeaterPower;
+  float pid_setpoint = 0.0;
+
+  
+  float Kp=DEFAULT_Kp;
+  float Ki=DEFAULT_Ki;
+  float Kd=DEFAULT_Kd;
+  #ifdef PID_ADD_EXTRUSION_RATE
+    float Kc=DEFAULT_Kc;
+  #endif
+#endif //PIDTEMP
+  
+  
+//===========================================================================
+//=============================private variables============================
+//===========================================================================
+static bool temp_meas_ready = false;
+
+static unsigned long previous_millis_heater, previous_millis_bed_heater;
+
+#ifdef PIDTEMP
+  //static cannot be external:
+  static float temp_iState = 0;
+  static float temp_dState = 0;
+  static float pTerm;
+  static float iTerm;
+  static float dTerm;
+  //int output;
+  static float pid_error;
+  static float temp_iState_min;
+  static float temp_iState_max;
+  static float pid_input;
+  static float pid_output;
+  static bool pid_reset;
+ 
+#endif //PIDTEMP
+  
+#ifdef WATCHPERIOD
+  static int watch_raw[3] = {-1000,-1000,-1000};
+  static unsigned long watchmillis = 0;
+#endif //WATCHPERIOD
+
+#ifdef HEATER_0_MINTEMP
+  static int minttemp_0 = temp2analog(HEATER_0_MINTEMP);
+#endif //MINTEMP
+#ifdef HEATER_0_MAXTEMP
+  static int maxttemp_0 = temp2analog(HEATER_0_MAXTEMP);
+#endif //MAXTEMP
+
+#ifdef HEATER_1_MINTEMP
+  static int minttemp_1 = temp2analog(HEATER_1_MINTEMP);
+#endif //MINTEMP
+#ifdef HEATER_1_MAXTEMP
+  static int maxttemp_1 = temp2analog(HEATER_1_MAXTEMP);
+#endif //MAXTEMP
+
+#ifdef BED_MINTEMP
+  static int bed_minttemp = temp2analog(BED_MINTEMP);
+#endif //BED_MINTEMP
+#ifdef BED_MAXTEMP
+  static int bed_maxttemp = temp2analog(BED_MAXTEMP);
+#endif //BED_MAXTEMP
+
+//===========================================================================
+//=============================functions         ============================
+//===========================================================================
+  
+void manage_heater()
+{
+  #ifdef USE_WATCHDOG
+    wd_reset();
+  #endif
+  
+  float pid_input;
+  float pid_output;
+  if(temp_meas_ready != true)   //better readability
+    return; 
+
+  CRITICAL_SECTION_START;
+    temp_meas_ready = false;
+  CRITICAL_SECTION_END;
+
+  #ifdef PIDTEMP
+    pid_input = analog2temp(current_raw[TEMPSENSOR_HOTEND_0]);
+
+    #ifndef PID_OPENLOOP
+        pid_error = pid_setpoint - pid_input;
+        if(pid_error > 10){
+          pid_output = PID_MAX;
+          pid_reset = true;
+        }
+        else if(pid_error < -10) {
+          pid_output = 0;
+          pid_reset = true;
+        }
+        else {
+          if(pid_reset == true) {
+            temp_iState = 0.0;
+            pid_reset = false;
+          }
+          pTerm = Kp * pid_error;
+          temp_iState += pid_error;
+          temp_iState = constrain(temp_iState, temp_iState_min, temp_iState_max);
+          iTerm = Ki * temp_iState;
+          //K1 defined in Configuration.h in the PID settings
+          #define K2 (1.0-K1)
+          dTerm = (Kd * (pid_input - temp_dState))*K2 + (K1 * dTerm);
+          temp_dState = pid_input;
+//          #ifdef PID_ADD_EXTRUSION_RATE
+//            pTerm+=Kc*current_block->speed_e; //additional heating if extrusion speed is high
+//          #endif
+          pid_output = constrain(pTerm + iTerm - dTerm, 0, PID_MAX);
+          
+        }
+    #endif //PID_OPENLOOP
+    #ifdef PID_DEBUG
+     //SERIAL_ECHOLN(" PIDDEBUG Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm<<" iTerm "<<iTerm<<" dTerm "<<dTerm);  
+    #endif //PID_DEBUG
+    HeaterPower=pid_output;
+    analogWrite(HEATER_0_PIN, pid_output);
+  #endif //PIDTEMP
+
+  #ifndef PIDTEMP
+    if(current_raw[0] >= target_raw[0])
+    {
+      WRITE(HEATER_0_PIN,LOW);
+    }
+    else 
+    {
+      WRITE(HEATER_0_PIN,HIGH);
+    }
+  #endif
+    
+  if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
+    return;
+  previous_millis_bed_heater = millis();
+  
+  #if TEMP_1_PIN > -1
+    if(current_raw[TEMPSENSOR_BED] >= target_raw[TEMPSENSOR_BED])
+    {
+      WRITE(HEATER_1_PIN,LOW);
+    }
+    else 
+    {
+      WRITE(HEATER_1_PIN,HIGH);
+    }
+  #endif
+}
+
+// Takes hot end temperature value as input and returns corresponding raw value. 
+// For a thermistor, it uses the RepRap thermistor temp table.
+// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
+// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
+int temp2analog(int celsius) {
+  #ifdef HEATER_0_USES_THERMISTOR
+    int raw = 0;
+    byte i;
+
+    for (i=1; i<NUMTEMPS_HEATER_0; i++)
+    {
+      if (pgm_read_word(&(heater_0_temptable[i][1])) < celsius)
+      {
+        raw = pgm_read_word(&(heater_0_temptable[i-1][0])) + 
+          (celsius - pgm_read_word(&(heater_0_temptable[i-1][1]))) * 
+          (pgm_read_word(&(heater_0_temptable[i][0])) - pgm_read_word(&(heater_0_temptable[i-1][0]))) /
+          (pgm_read_word(&(heater_0_temptable[i][1])) - pgm_read_word(&(heater_0_temptable[i-1][1])));  
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == NUMTEMPS_HEATER_0) raw = pgm_read_word(&(heater_0_temptable[i-1][0]));
+
+    return (1023 * OVERSAMPLENR) - raw;
+  #elif defined HEATER_0_USES_AD595
+    return celsius * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
+  #endif
+}
+
+// Takes bed temperature value as input and returns corresponding raw value. 
+// For a thermistor, it uses the RepRap thermistor temp table.
+// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
+// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
+int temp2analogBed(int celsius) {
+  #ifdef BED_USES_THERMISTOR
+
+    int raw = 0;
+    byte i;
+    
+    for (i=1; i<BNUMTEMPS; i++)
+    {
+      if (pgm_read_word(&)bedtemptable[i][1])) < celsius)
+      {
+        raw = pgm_read_word(&(bedtemptable[i-1][0])) + 
+          (celsius - pgm_read_word(&(bedtemptable[i-1][1]))) * 
+          (pgm_read_word(&(bedtemptable[i][0])) - pgm_read_word(&(bedtemptable[i-1][0]))) /
+          (pgm_read_word(&(bedtemptable[i][1])) - pgm_read_word(&(bedtemptable[i-1][1])));
+      
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == BNUMTEMPS) raw = pgm_read_word(&(bedtemptable[i-1][0]));
+
+    return (1023 * OVERSAMPLENR) - raw;
+  #elif defined BED_USES_AD595
+    return lround(celsius * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
+  #endif
+}
+
+// Derived from RepRap FiveD extruder::getTemperature()
+// For hot end temperature measurement.
+float analog2temp(int raw) {
+  #ifdef HEATER_0_USES_THERMISTOR
+    float celsius = 0;
+    byte i;  
+    raw = (1023 * OVERSAMPLENR) - raw;
+    for (i=1; i<NUMTEMPS_HEATER_0; i++)
+    {
+      if ((short)pgm_read_word(&heater_0_temptable[i][0]) > raw)
+      {
+        celsius  = (short)pgm_read_word(&heater_0_temptable[i-1][1]) + 
+          (raw - (short)pgm_read_word(&heater_0_temptable[i-1][0])) * 
+          (float)((short)pgm_read_word(&heater_0_temptable[i][1]) - (short)pgm_read_word(&heater_0_temptable[i-1][1])) /
+          (float)((short)pgm_read_word(&heater_0_temptable[i][0]) - (short)pgm_read_word(&heater_0_temptable[i-1][0]));
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == NUMTEMPS_HEATER_0) celsius = (short)pgm_read_word(&(heater_0_temptable[i-1][1]));
+
+    return celsius;
+  #elif defined HEATER_0_USES_AD595
+    return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
+  #endif
+}
+
+// Derived from RepRap FiveD extruder::getTemperature()
+// For bed temperature measurement.
+float analog2tempBed(int raw) {
+  #ifdef BED_USES_THERMISTOR
+    int celsius = 0;
+    byte i;
+
+    raw = (1023 * OVERSAMPLENR) - raw;
+
+    for (i=1; i<BNUMTEMPS; i++)
+    {
+      if (pgm_read_word(&(bedtemptable[i][0])) > raw)
+      {
+        celsius  = pgm_read_word(&(bedtemptable[i-1][1])) + 
+          (raw - pgm_read_word(&(bedtemptable[i-1][0]))) * 
+          (pgm_read_word(&(bedtemptable[i][1])) - pgm_read_word(&(bedtemptable[i-1][1]))) /
+          (pgm_read_word(&(bedtemptable[i][0])) - pgm_read_word(&(bedtemptable[i-1][0])));
+
+        break;
+      }
+    }
+
+    // Overflow: Set to last value in the table
+    if (i == BNUMTEMPS) celsius = pgm_read_word(&(bedtemptable[i-1][1]));
+
+    return celsius;
+    
+  #elif defined BED_USES_AD595
+    return raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR;
+  #endif
+}
+
+void tp_init()
+{
+  #if (HEATER_0_PIN > -1) 
+    SET_OUTPUT(HEATER_0_PIN);
+  #endif  
+  #if (HEATER_1_PIN > -1) 
+    SET_OUTPUT(HEATER_1_PIN);
+  #endif  
+  #if (HEATER_2_PIN > -1) 
+    SET_OUTPUT(HEATER_2_PIN);
+  #endif  
+
+  #ifdef PIDTEMP
+    temp_iState_min = 0.0;
+    temp_iState_max = PID_INTEGRAL_DRIVE_MAX / Ki;
+  #endif //PIDTEMP
+
+  // Set analog inputs
+  ADCSRA = 1<<ADEN | 1<<ADSC | 1<<ADIF | 0x07;
+  
+  // Use timer0 for temperature measurement
+  // Interleave temperature interrupt with millies interrupt
+  OCR0B = 128;
+  TIMSK0 |= (1<<OCIE0B);  
+}
+
+
+
+void setWatch() 
+{  
+#ifdef WATCHPERIOD
+  if(isHeatingHotend0())
+  {
+    watchmillis = max(1,millis());
+    watch_raw[TEMPSENSOR_HOTEND_0] = current_raw[TEMPSENSOR_HOTEND_0];
+  }
+  else
+  {
+    watchmillis = 0;
+  } 
+#endif 
+}
+
+
+void disable_heater()
+{
+  #if TEMP_0_PIN > -1
+  target_raw[0]=0;
+   #if HEATER_0_PIN > -1  
+     WRITE(HEATER_0_PIN,LOW);
+   #endif
+  #endif
+     
+  #if TEMP_1_PIN > -1
+    target_raw[1]=0;
+    #if HEATER_1_PIN > -1 
+      WRITE(HEATER_1_PIN,LOW);
+    #endif
+  #endif
+      
+  #if TEMP_2_PIN > -1
+    target_raw[2]=0;
+    #if HEATER_2_PIN > -1  
+      WRITE(HEATER_2_PIN,LOW);
+    #endif
+  #endif 
+}
+
+// Timer 0 is shared with millies
+ISR(TIMER0_COMPB_vect)
+{
+  //these variables are only accesible from the ISR, but static, so they don't loose their value
+  static unsigned char temp_count = 0;
+  static unsigned long raw_temp_0_value = 0;
+  static unsigned long raw_temp_1_value = 0;
+  static unsigned long raw_temp_2_value = 0;
+  static unsigned char temp_state = 0;
+  
+  switch(temp_state) {
+    case 0: // Prepare TEMP_0
+      #if (TEMP_0_PIN > -1)
+        #if TEMP_0_PIN < 8
+          DIDR0 = 1 << TEMP_0_PIN; 
+        #else
+          DIDR2 = 1<<(TEMP_0_PIN - 8); 
+          ADCSRB = 1<<MUX5;
+        #endif
+        ADMUX = ((1 << REFS0) | (TEMP_0_PIN & 0x07));
+        ADCSRA |= 1<<ADSC; // Start conversion
+      #endif
+      #ifdef ULTIPANEL
+        buttons_check();
+      #endif
+      temp_state = 1;
+      break;
+    case 1: // Measure TEMP_0
+      #if (TEMP_0_PIN > -1)
+        raw_temp_0_value += ADC;
+      #endif
+      temp_state = 2;
+      break;
+    case 2: // Prepare TEMP_1
+      #if (TEMP_1_PIN > -1)
+        #if TEMP_1_PIN < 7
+          DIDR0 = 1<<TEMP_1_PIN; 
+        #else
+          DIDR2 = 1<<(TEMP_1_PIN - 8); 
+          ADCSRB = 1<<MUX5;
+        #endif
+        ADMUX = ((1 << REFS0) | (TEMP_1_PIN & 0x07));
+        ADCSRA |= 1<<ADSC; // Start conversion
+      #endif
+      #ifdef ULTIPANEL
+        buttons_check();
+      #endif
+      temp_state = 3;
+      break;
+    case 3: // Measure TEMP_1
+      #if (TEMP_1_PIN > -1)
+        raw_temp_1_value += ADC;
+      #endif
+      temp_state = 4;
+      break;
+    case 4: // Prepare TEMP_2
+      #if (TEMP_2_PIN > -1)
+        #if TEMP_2_PIN < 7
+          DIDR0 = 1 << TEMP_2_PIN; 
+        #else
+          DIDR2 = 1<<(TEMP_2_PIN - 8); 
+          ADCSRB = 1<<MUX5;
+        #endif
+        ADMUX = ((1 << REFS0) | (TEMP_2_PIN & 0x07));
+        ADCSRA |= 1<<ADSC; // Start conversion
+      #endif
+      #ifdef ULTIPANEL
+        buttons_check();
+      #endif
+      temp_state = 5;
+      break;
+    case 5: // Measure TEMP_2
+      #if (TEMP_2_PIN > -1)
+        raw_temp_2_value += ADC;
+      #endif
+      temp_state = 0;
+      temp_count++;
+      break;
+    default:
+      SERIAL_ERROR_START;
+      SERIAL_ERRORLNPGM("Temp measurement error!");
+      break;
+  }
+    
+  if(temp_count >= 16) // 6 ms * 16 = 96ms.
+  {
+    #ifdef HEATER_0_USES_AD595
+      current_raw[0] = raw_temp_0_value;
+    #else
+      current_raw[0] = 16383 - raw_temp_0_value;
+    #endif
+    
+    #ifdef HEATER_1_USES_AD595
+      current_raw[2] = raw_temp_2_value;
+    #else
+      current_raw[2] = 16383 - raw_temp_2_value;
+    #endif
+    
+    #ifdef BED_USES_AD595
+      current_raw[1] = raw_temp_1_value;
+    #else
+      current_raw[1] = 16383 - raw_temp_1_value;
+    #endif
+    
+    temp_meas_ready = true;
+    temp_count = 0;
+    raw_temp_0_value = 0;
+    raw_temp_1_value = 0;
+    raw_temp_2_value = 0;
+    #ifdef HEATER_0_MAXTEMP
+      #if (HEATER_0_PIN > -1)
+        if(current_raw[TEMPSENSOR_HOTEND_0] >= maxttemp_0) {
+          target_raw[TEMPSENSOR_HOTEND_0] = 0;
+          analogWrite(HEATER_0_PIN, 0);
+          SERIAL_ERROR_START;
+          SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MAXTEMP triggered !!");
+          kill();
+        }
+      #endif
+    #endif
+  #ifdef HEATER_1_MAXTEMP
+    #if (HEATER_1_PIN > -1)
+      if(current_raw[TEMPSENSOR_HOTEND_1] >= maxttemp_1) {
+        target_raw[TEMPSENSOR_HOTEND_1] = 0;
+      if(current_raw[2] >= maxttemp_1) {
+        analogWrite(HEATER_2_PIN, 0);
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MAXTEMP triggered !!");
+        kill()
+      }
+    #endif
+  #endif //MAXTEMP
+  
+  #ifdef HEATER_0_MINTEMP
+    #if (HEATER_0_PIN > -1)
+      if(current_raw[TEMPSENSOR_HOTEND_0] <= minttemp_0) {
+        target_raw[TEMPSENSOR_HOTEND_0] = 0;
+        analogWrite(HEATER_0_PIN, 0);
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 0 switched off. MINTEMP triggered !!");
+        kill();
+      }
+    #endif
+  #endif
+  
+  #ifdef HEATER_1_MINTEMP
+    #if (HEATER_2_PIN > -1)
+      if(current_raw[TEMPSENSOR_HOTEND_1] <= minttemp_1) {
+        target_raw[TEMPSENSOR_HOTEND_1] = 0;
+        analogWrite(HEATER_2_PIN, 0);
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature extruder 1 switched off. MINTEMP triggered !!");
+        kill();
+      }
+    #endif
+  #endif //MAXTEMP
+  
+  #ifdef BED_MINTEMP
+    #if (HEATER_1_PIN > -1)
+      if(current_raw[1] <= bed_minttemp) {
+        target_raw[1] = 0;
+        WRITE(HEATER_1_PIN, 0);
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperatur heated bed switched off. MINTEMP triggered !!");
+        kill();
+      }
+    #endif
+  #endif
+  
+  #ifdef BED_MAXTEMP
+    #if (HEATER_1_PIN > -1)
+      if(current_raw[1] >= bed_maxttemp) {
+        target_raw[1] = 0;
+        WRITE(HEATER_1_PIN, 0);
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
+        kill();
+      }
+    #endif
+  #endif
+  }
+}
+
+
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index fbd2ef1..22d9f02 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -1,12 +1,14 @@
 #ifndef THERMISTORTABLES_H_
 #define THERMISTORTABLES_H_
 
+#include <avr/pgmspace.h>
+
 #define OVERSAMPLENR 16
 
 #if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1) || (THERMISTORBED == 1) //100k bed thermistor
 
 #define NUMTEMPS_1 61
-const short temptable_1[NUMTEMPS_1][2] = {
+const short temptable_1[NUMTEMPS_1][2] PROGMEM = {
 {       23*OVERSAMPLENR ,       300     },
 {       25*OVERSAMPLENR ,       295     },
 {       27*OVERSAMPLENR ,       290     },
@@ -72,7 +74,7 @@ const short temptable_1[NUMTEMPS_1][2] = {
 #endif
 #if (THERMISTORHEATER_0 == 2) || (THERMISTORHEATER_1 == 2) || (THERMISTORBED == 2) //200k bed thermistor
 #define NUMTEMPS_2 21
-const short temptable_2[NUMTEMPS_2][2] = {
+const short temptable_2[NUMTEMPS_2][2] PROGMEM = {
    {1*OVERSAMPLENR, 848},
    {54*OVERSAMPLENR, 275},
    {107*OVERSAMPLENR, 228},
@@ -99,7 +101,7 @@ const short temptable_2[NUMTEMPS_2][2] = {
 #endif
 #if (THERMISTORHEATER_0 == 3) || (THERMISTORHEATER_1 == 3) || (THERMISTORBED == 3) //mendel-parts
 #define NUMTEMPS_3 28
-const short temptable_3[NUMTEMPS_3][2] = {
+const short temptable_3[NUMTEMPS_3][2] PROGMEM = {
                 {1*OVERSAMPLENR,864},
                 {21*OVERSAMPLENR,300},
                 {25*OVERSAMPLENR,290},
@@ -134,7 +136,7 @@ const short temptable_3[NUMTEMPS_3][2] = {
 #if (THERMISTORHEATER_0 == 4) || (THERMISTORHEATER_1 == 4) || (THERMISTORBED == 4) //10k thermistor
 
 #define NUMTEMPS_4 20
-short temptable_4[NUMTEMPS_4][2] = {
+const short temptable_4[NUMTEMPS_4][2] PROGMEM = {
    {1*OVERSAMPLENR, 430},
    {54*OVERSAMPLENR, 137},
    {107*OVERSAMPLENR, 107},
@@ -161,7 +163,7 @@ short temptable_4[NUMTEMPS_4][2] = {
 #if (THERMISTORHEATER_0 == 5) || (THERMISTORHEATER_1 == 5) || (THERMISTORBED == 5) //100k ParCan thermistor (104GT-2)
 
 #define NUMTEMPS_5 61
-const short temptable_5[NUMTEMPS_5][2] = {
+const short temptable_5[NUMTEMPS_5][2] PROGMEM = {
 {1*OVERSAMPLENR, 713},
 {18*OVERSAMPLENR, 316},
 {35*OVERSAMPLENR, 266},
@@ -228,7 +230,7 @@ const short temptable_5[NUMTEMPS_5][2] = {
 
 #if (THERMISTORHEATER_0 == 6) || (THERMISTORHEATER_1 == 6) || (THERMISTORBED == 6) // 100k Epcos thermistor
 #define NUMTEMPS_6 36
-const short temptable_6[NUMTEMPS_6][2] = {
+const short temptable_6[NUMTEMPS_6][2] PROGMEM = {
    {28*OVERSAMPLENR, 250},
    {31*OVERSAMPLENR, 245},
    {35*OVERSAMPLENR, 240},
@@ -270,7 +272,7 @@ const short temptable_6[NUMTEMPS_6][2] = {
 
 #if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01
 #define NUMTEMPS_7 54
-const short temptable_7[NUMTEMPS_7][2] = {
+const short temptable_7[NUMTEMPS_7][2] PROGMEM = {
    {46*OVERSAMPLENR, 270},
    {50*OVERSAMPLENR, 265},
    {54*OVERSAMPLENR, 260},

