commit 7d869ad98b894391371a73374e4fee466aa3e156 (from 824c6859e2504722b61849c00b4ef3f4c7b7a713)
Merge: 824c685 4226f56
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 21 18:18:15 2016 -0700

    Merge pull request #4365 from thinkyhead/rc_shrink_planner_accel
    
    Adjustments to planner acceleration limit

diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 0379610..f745525 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -946,31 +946,23 @@ void Planner::check_axes_activity() {
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   float steps_per_mm = block->step_event_count / block->millimeters;
-  long bsx = block->steps[X_AXIS], bsy = block->steps[Y_AXIS], bsz = block->steps[Z_AXIS], bse = block->steps[E_AXIS];
-  if (bsx == 0 && bsy == 0 && bsz == 0) {
+  if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
     block->acceleration_steps_per_s2 = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
   }
-  else if (bse == 0) {
-    block->acceleration_steps_per_s2 = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
-  }
   else {
-    block->acceleration_steps_per_s2 = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    // Limit acceleration per axis
+    block->acceleration_steps_per_s2 = ceil((block->steps[E_AXIS] ? acceleration : travel_acceleration) * steps_per_mm);
+    if (max_acceleration_steps_per_s2[X_AXIS] < (block->acceleration_steps_per_s2 * block->steps[X_AXIS]) / block->step_event_count)
+      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[X_AXIS] * block->step_event_count) / block->steps[X_AXIS];
+    if (max_acceleration_steps_per_s2[Y_AXIS] < (block->acceleration_steps_per_s2 * block->steps[Y_AXIS]) / block->step_event_count)
+      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[Y_AXIS] * block->step_event_count) / block->steps[Y_AXIS];
+    if (max_acceleration_steps_per_s2[Z_AXIS] < (block->acceleration_steps_per_s2 * block->steps[Z_AXIS]) / block->step_event_count)
+      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[Z_AXIS] * block->step_event_count) / block->steps[Z_AXIS];
+    if (max_acceleration_steps_per_s2[E_AXIS] < (block->acceleration_steps_per_s2 * block->steps[E_AXIS]) / block->step_event_count)
+      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[E_AXIS] * block->step_event_count) / block->steps[E_AXIS];
   }
-  // Limit acceleration per axis
-  unsigned long acc_st = block->acceleration_steps_per_s2,
-                x_acc_st = max_acceleration_steps_per_s2[X_AXIS],
-                y_acc_st = max_acceleration_steps_per_s2[Y_AXIS],
-                z_acc_st = max_acceleration_steps_per_s2[Z_AXIS],
-                e_acc_st = max_acceleration_steps_per_s2[E_AXIS],
-                allsteps = block->step_event_count;
-  if (x_acc_st < (acc_st * bsx) / allsteps) acc_st = (x_acc_st * allsteps) / bsx;
-  if (y_acc_st < (acc_st * bsy) / allsteps) acc_st = (y_acc_st * allsteps) / bsy;
-  if (z_acc_st < (acc_st * bsz) / allsteps) acc_st = (z_acc_st * allsteps) / bsz;
-  if (e_acc_st < (acc_st * bse) / allsteps) acc_st = (e_acc_st * allsteps) / bse;
-
-  block->acceleration_steps_per_s2 = acc_st;
-  block->acceleration = acc_st / steps_per_mm;
-  block->acceleration_rate = (long)(acc_st * 16777216.0 / (F_CPU / 8.0));
+  block->acceleration = block->acceleration_steps_per_s2 / steps_per_mm;
+  block->acceleration_rate = (long)(block->acceleration_steps_per_s2 * 16777216.0 / ((F_CPU) / 8.0));
 
   #if 0  // Use old jerk for now
 
@@ -1064,12 +1056,12 @@ void Planner::check_axes_activity() {
 
   #if ENABLED(LIN_ADVANCE)
 
-    // bse == allsteps: A problem occurs when there's a very tiny move before a retract.
+    // block->steps[E_AXIS] == block->step_event_count: A problem occurs when there's a very tiny move before a retract.
     // In this case, the retract and the move will be executed together.
     // This leads to an enormous number of advance steps due to a huge e_acceleration.
     // The math is correct, but you don't want a retract move done with advance!
     // So this situation is filtered out here.
-    if (!bse || (!bsx && !bsy && !bsz) || stepper.get_advance_k() == 0 || (uint32_t) bse == allsteps) {
+    if (!block->steps[E_AXIS] || (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) || stepper.get_advance_k() == 0 || (uint32_t) block->steps[E_AXIS] == block->step_event_count) {
       block->use_advance_lead = false;
     }
     else {
@@ -1080,7 +1072,7 @@ void Planner::check_axes_activity() {
   #elif ENABLED(ADVANCE)
 
     // Calculate advance rate
-    if (!bse || (!bsx && !bsy && !bsz)) {
+    if (!block->steps[E_AXIS] || (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS])) {
       block->advance_rate = 0;
       block->advance = 0;
     }

commit 7d869ad98b894391371a73374e4fee466aa3e156 (from 4226f56f53eb6b3947c79295920c411b097a9e10)
Merge: 824c685 4226f56
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 21 18:18:15 2016 -0700

    Merge pull request #4365 from thinkyhead/rc_shrink_planner_accel
    
    Adjustments to planner acceleration limit

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 3ad5512..4a07513 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -407,11 +407,11 @@ void calculate_volumetric_multipliers();
 /**
  * Blocking movement and shorthand functions
  */
-static void do_blocking_move_to(float x, float y, float z, float fr_mm_m=0.0);
-static void do_blocking_move_to_axis_pos(AxisEnum axis, float where, float fr_mm_m=0.0);
-static void do_blocking_move_to_x(float x, float fr_mm_m=0.0);
-static void do_blocking_move_to_y(float y);
-static void do_blocking_move_to_z(float z, float fr_mm_m=0.0);
-static void do_blocking_move_to_xy(float x, float y, float fr_mm_m=0.0);
+inline void do_blocking_move_to(float x, float y, float z, float fr_mm_m=0.0);
+inline void do_blocking_move_to_axis_pos(AxisEnum axis, float where, float fr_mm_m=0.0);
+inline void do_blocking_move_to_x(float x, float fr_mm_m=0.0);
+inline void do_blocking_move_to_y(float y);
+inline void do_blocking_move_to_z(float z, float fr_mm_m=0.0);
+inline void do_blocking_move_to_xy(float x, float y, float fr_mm_m=0.0);
 
 #endif //MARLIN_H
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index dc52989..35c31c2 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -579,6 +579,7 @@ void serial_echopair_P(const char* s_P, float v)         { serialprintPGM(s_P);
 void serial_echopair_P(const char* s_P, double v)        { serialprintPGM(s_P); SERIAL_ECHO(v); }
 void serial_echopair_P(const char* s_P, unsigned long v) { serialprintPGM(s_P); SERIAL_ECHO(v); }
 
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_m=0.0, bool no_move=false);
 static void report_current_position();
 
 #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -2063,6 +2064,12 @@ static void clean_up_after_endstop_or_probe_move() {
     return false;
   }
 
+  #if ENABLED(DELTA)
+    #define SET_CURRENT_FROM_STEPPERS() current_position[Z_AXIS] = z_before - stepper.get_axis_position_mm(Z_AXIS) + z_mm
+  #else
+    #define SET_CURRENT_FROM_STEPPERS() current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS)
+  #endif
+
   // Do a single Z probe and return with current_position[Z_AXIS]
   // at the height where the probe triggered.
   static float run_z_probe() {
@@ -2074,23 +2081,31 @@ static void clean_up_after_endstop_or_probe_move() {
       planner.bed_level_matrix.set_to_identity();
     #endif
 
+    #if ENABLED(DELTA)
+      float z_before = current_position[Z_AXIS];
+      float z_mm = stepper.get_axis_position_mm(Z_AXIS);
+    #endif
     current_position[Z_AXIS] = -(Z_MAX_LENGTH + 10);
     do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_FAST);
     endstops.hit_on_purpose(); // clear endstop hit flags
     // Get the current stepper position after bumping an endstop
-    current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
-    SYNC_PLAN_POSITION_KINEMATIC(); // tell the planner where we are      feedrate_mm_m = homing_feedrate_mm_m[Z_AXIS];
+    SET_CURRENT_FROM_STEPPERS();
+    SYNC_PLAN_POSITION_KINEMATIC(); // tell the planner where we are
 
     // move up the retract distance
     current_position[Z_AXIS] += home_bump_mm(Z_AXIS);
     do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_FAST);
 
+    #if ENABLED(DELTA)
+      z_before = current_position[Z_AXIS];
+      z_mm = stepper.get_axis_position_mm(Z_AXIS);
+    #endif
     // move back down slowly to find bed
     current_position[Z_AXIS] -= home_bump_mm(Z_AXIS) * 2;
     do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_SLOW);
     endstops.hit_on_purpose(); // clear endstop hit flags
     // Get the current stepper position after bumping an endstop
-    current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+    SET_CURRENT_FROM_STEPPERS();
     SYNC_PLAN_POSITION_KINEMATIC(); // tell the planner where we are
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -2838,6 +2853,12 @@ inline void gcode_G28() {
     #endif
   #endif
 
+  // Always home with tool 0 active
+  #if HOTENDS > 1
+    uint8_t old_tool_index = active_extruder;
+    tool_change(0, 0, true);
+  #endif
+
   /**
    * For mesh bed leveling deactivate the mesh calculations, will be turned
    * on again when homing all axis
@@ -3141,6 +3162,11 @@ inline void gcode_G28() {
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   #endif
 
+  // Restore the active tool after homing
+  #if HOTENDS > 1
+    tool_change(old_tool_index, 0, true);
+  #endif
+
   report_current_position();
 }
 
@@ -6622,13 +6648,7 @@ inline void invalid_extruder_error(const uint8_t &e) {
   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
 }
 
-/**
- * T0-T3: Switch tool, usually switching extruders
- *
- *   F[units/min] Set the movement feedrate
- *   S1           Don't move the tool in XY after change
- */
-inline void gcode_T(uint8_t tmp_extruder) {
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_m/*=0.0*/, bool no_move/*=false*/) {
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
@@ -6643,14 +6663,6 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
   #else //!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
-        SERIAL_ECHOLNPGM(")");
-        DEBUG_POS("BEFORE", current_position);
-      }
-    #endif
-
     #if HOTENDS > 1
 
       if (tmp_extruder >= EXTRUDERS) {
@@ -6660,16 +6672,9 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
       float old_feedrate_mm_m = feedrate_mm_m;
 
-      if (code_seen('F')) {
-        float next_feedrate_mm_m = code_value_axis_units(X_AXIS);
-        if (next_feedrate_mm_m > 0.0) old_feedrate_mm_m = feedrate_mm_m = next_feedrate_mm_m;
-      }
-      else
-        feedrate_mm_m = XY_PROBE_FEEDRATE_MM_M;
+      feedrate_mm_m = fr_mm_m > 0.0 ? (old_feedrate_mm_m = fr_mm_m) : XY_PROBE_FEEDRATE_MM_M;
 
       if (tmp_extruder != active_extruder) {
-        bool no_move = code_seen('S') && code_value_bool();
-
         if (!no_move && axis_unhomed_error(true, true, true)) {
           SERIAL_ECHOLNPGM("No move on toolchange");
           no_move = true;
@@ -6926,13 +6931,6 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
     #endif // HOTENDS <= 1
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_POS("AFTER", current_position);
-        SERIAL_ECHOLNPGM("<<< gcode_T");
-      }
-    #endif
-
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM(MSG_ACTIVE_EXTRUDER);
     SERIAL_PROTOCOLLN((int)active_extruder);
@@ -6941,6 +6939,44 @@ inline void gcode_T(uint8_t tmp_extruder) {
 }
 
 /**
+ * T0-T3: Switch tool, usually switching extruders
+ *
+ *   F[units/min] Set the movement feedrate
+ *   S1           Don't move the tool in XY after change
+ */
+inline void gcode_T(uint8_t tmp_extruder) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
+      SERIAL_ECHOLNPGM(")");
+      DEBUG_POS("BEFORE", current_position);
+    }
+  #endif
+
+  #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
+
+    tool_change(tmp_extruder);
+
+  #elif HOTENDS > 1
+
+    tool_change(
+      tmp_extruder,
+      code_seen('F') ? code_value_axis_units(X_AXIS) : 0.0,
+      (tmp_extruder == active_extruder) || (code_seen('S') && code_value_bool())
+    );
+
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_POS("AFTER", current_position);
+      SERIAL_ECHOLNPGM("<<< gcode_T");
+    }
+  #endif
+}
+
+/**
  * Process a single command and dispatch it to its handler
  * This is called from the main loop()
  */
diff --git a/Marlin/ultralcd_impl_DOGM.h b/Marlin/ultralcd_impl_DOGM.h
index 6290bb3..3ab0b17 100644
--- a/Marlin/ultralcd_impl_DOGM.h
+++ b/Marlin/ultralcd_impl_DOGM.h
@@ -33,8 +33,8 @@
  * License: http://opensource.org/licenses/BSD-3-Clause
  */
 
-#ifndef DOGM_LCD_IMPLEMENTATION_H
-#define DOGM_LCD_IMPLEMENTATION_H
+#ifndef ULTRALCD_IMPL_DOGM_H
+#define ULTRALCD_IMPL_DOGM_H
 
 /**
  * Implementation of the LCD display routines for a DOGM128 graphic display.
@@ -635,4 +635,4 @@ void lcd_implementation_drawedit(const char* pstr, const char* value=NULL) {
 #define lcd_implementation_drawmenu_gcode(sel, row, pstr, gcode) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
 #define lcd_implementation_drawmenu_function(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
 
-#endif //__DOGM_LCD_IMPLEMENTATION_H
+#endif //__ULTRALCD_IMPL_DOGM_H
diff --git a/Marlin/ultralcd_impl_HD44780.h b/Marlin/ultralcd_impl_HD44780.h
index d1d047f..16159b1 100644
--- a/Marlin/ultralcd_impl_HD44780.h
+++ b/Marlin/ultralcd_impl_HD44780.h
@@ -20,8 +20,8 @@
  *
  */
 
-#ifndef ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H
-#define ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H
+#ifndef ULTRALCD_IMPL_HD44780_H
+#define ULTRALCD_IMPL_HD44780_H
 
 /**
 * Implementation of the LCD display routines for a Hitachi HD44780 display. These are common LCD character displays.
@@ -1006,4 +1006,4 @@ void lcd_implementation_drawedit(const char* pstr, const char* value=NULL) {
 
 #endif // LCD_HAS_SLOW_BUTTONS
 
-#endif // ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H
+#endif // ULTRALCD_IMPL_HD44780_H

