commit f0b96f5caef0f2c50132a01e6926b004a0eabe4e (from 12c0bf952125a43692a5db3308986ef21d0368cb)
Merge: 12c0bf9 ce0a9d3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 29 18:30:18 2016 -0700

    Merge pull request #3276 from thinkyhead/rc_sdprint_and_lcd_sleuth
    
    Refinements, fixes, reduced stack usage in CardReader

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 32367ae..e0c5307 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -3704,7 +3704,7 @@ inline void gcode_M31() {
     bool call_procedure = code_seen('P') && (seen_pointer < namestartpos);
 
     if (card.cardOK) {
-      card.openFile(namestartpos, true, !call_procedure);
+      card.openFile(namestartpos, true, call_procedure);
 
       if (code_seen('S') && seen_pointer < namestartpos) // "S" (must occur _before_ the filename!)
         card.setIndex(code_value_short());
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index bb2d6e1..c122a45 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -266,10 +266,10 @@ void CardReader::release() {
 }
 
 void CardReader::openAndPrintFile(const char *name) {
-  char cmd[4 + (FILENAME_LENGTH + 1) * MAX_DIR_DEPTH + 2]; // Room for "M23 ", names with slashes, a null, and one extra
+  char cmd[4 + strlen(name) + 1]; // Room for "M23 ", filename, and null
   sprintf_P(cmd, PSTR("M23 %s"), name);
   for (char *c = &cmd[4]; *c; c++) *c = tolower(*c);
-  enqueue_and_echo_command_now(cmd);
+  enqueue_and_echo_command(cmd);
   enqueue_and_echo_commands_P(PSTR("M24"));
 }
 
@@ -300,10 +300,10 @@ void CardReader::getAbsFilename(char *t) {
     t[0] = 0;
 }
 
-void CardReader::openFile(char* name, bool read, bool replace_current/*=true*/) {
+void CardReader::openFile(char* name, bool read, bool push_current/*=false*/) {
   if (!cardOK) return;
   if (file.isOpen()) { //replacing current file by new file, or subfile call
-    if (!replace_current) {
+    if (push_current) {
       if (file_subcall_ctr > SD_PROCEDURE_DEPTH - 1) {
         SERIAL_ERROR_START;
         SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
@@ -318,20 +318,20 @@ void CardReader::openFile(char* name, bool read, bool replace_current/*=true*/)
       SERIAL_ECHOPGM("\" parent:\"");
 
       //store current filename and position
-      getAbsFilename(filenames[file_subcall_ctr]);
+      getAbsFilename(proc_filenames[file_subcall_ctr]);
 
-      SERIAL_ECHO(filenames[file_subcall_ctr]);
+      SERIAL_ECHO(proc_filenames[file_subcall_ctr]);
       SERIAL_ECHOPGM("\" pos");
       SERIAL_ECHOLN(sdpos);
       filespos[file_subcall_ctr] = sdpos;
       file_subcall_ctr++;
-     }
-     else {
-      SERIAL_ECHO_START;
-      SERIAL_ECHOPGM("Now doing file: ");
-      SERIAL_ECHOLN(name);
-     }
-     file.close();
+    }
+    else {
+     SERIAL_ECHO_START;
+     SERIAL_ECHOPGM("Now doing file: ");
+     SERIAL_ECHOLN(name);
+    }
+    file.close();
   }
   else { //opening fresh file
     file_subcall_ctr = 0; //resetting procedure depth in case user cancels print while in procedure
@@ -584,22 +584,15 @@ void CardReader::chdir(const char * relpath) {
     SERIAL_ECHOLN(relpath);
   }
   else {
-    if (workDirDepth < MAX_DIR_DEPTH) {
-      ++workDirDepth;
-      for (int d = workDirDepth; d--;) workDirParents[d + 1] = workDirParents[d];
-      workDirParents[0] = *parent;
-    }
+    if (workDirDepth < MAX_DIR_DEPTH)
+      workDirParents[workDirDepth++] = *parent;
     workDir = newfile;
   }
 }
 
 void CardReader::updir() {
-  if (workDirDepth > 0) {
-    --workDirDepth;
-    workDir = workDirParents[0];
-    for (uint16_t d = 0; d < workDirDepth; d++)
-      workDirParents[d] = workDirParents[d+1];
-  }
+  if (workDirDepth > 0)
+    workDir = workDirParents[--workDirDepth];
 }
 
 void CardReader::printingHasFinished() {
@@ -607,17 +600,15 @@ void CardReader::printingHasFinished() {
   if (file_subcall_ctr > 0) { // Heading up to a parent file that called current as a procedure.
     file.close();
     file_subcall_ctr--;
-    openFile(filenames[file_subcall_ctr], true, true);
+    openFile(proc_filenames[file_subcall_ctr], true, true);
     setIndex(filespos[file_subcall_ctr]);
     startFileprint();
   }
   else {
     file.close();
     sdprinting = false;
-    if (SD_FINISHED_STEPPERRELEASE) {
-      //finishAndDisableSteppers();
+    if (SD_FINISHED_STEPPERRELEASE)
       enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-    }
     autotempShutdown();
   }
 }
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 8bd53e5..a18b718 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -40,7 +40,7 @@ public:
   //this is to delay autostart and hence the initialisaiton of the sd card to some seconds after the normal init, so the device is available quick after a reset
 
   void checkautostart(bool x);
-  void openFile(char* name,bool read,bool replace_current=true);
+  void openFile(char* name, bool read, bool push_current=false);
   void openLogFile(char* name);
   void removeFile(char* name);
   void closefile(bool store_location=false);
@@ -65,7 +65,6 @@ public:
   void updir();
   void setroot();
 
-
   FORCE_INLINE bool isFileOpen() { return file.isOpen(); }
   FORCE_INLINE bool eof() { return sdpos >= filesize; }
   FORCE_INLINE int16_t get() { sdpos = file.curPosition(); return (int16_t)file.read(); }
@@ -79,19 +78,20 @@ public:
   int autostart_index;
 private:
   SdFile root, *curDir, workDir, workDirParents[MAX_DIR_DEPTH];
-  uint16_t workDirDepth;
+  uint8_t workDirDepth;
   Sd2Card card;
   SdVolume volume;
   SdFile file;
+
   #define SD_PROCEDURE_DEPTH 1
   #define MAXPATHNAMELENGTH (FILENAME_LENGTH*MAX_DIR_DEPTH + MAX_DIR_DEPTH + 1)
   uint8_t file_subcall_ctr;
   uint32_t filespos[SD_PROCEDURE_DEPTH];
-  char filenames[SD_PROCEDURE_DEPTH][MAXPATHNAMELENGTH];
+  char proc_filenames[SD_PROCEDURE_DEPTH][MAXPATHNAMELENGTH];
   uint32_t filesize;
-  millis_t next_autostart_ms;
   uint32_t sdpos;
 
+  millis_t next_autostart_ms;
   bool autostart_stilltocheck; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
 
   LsAction lsAction; //stored for recursion.
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index b3664fa..6a8bf58 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1114,7 +1114,7 @@ static void lcd_control_menu() {
         autotune_temp[e]
       #endif
     );
-    enqueue_and_echo_command_now(cmd);
+    enqueue_and_echo_command(cmd);
   }
 
 #endif //PID_AUTOTUNE_MENU

commit f0b96f5caef0f2c50132a01e6926b004a0eabe4e (from ce0a9d3dc64061bf9506cd97ebb6b41ffbca170a)
Merge: 12c0bf9 ce0a9d3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 29 18:30:18 2016 -0700

    Merge pull request #3276 from thinkyhead/rc_sdprint_and_lcd_sleuth
    
    Refinements, fixes, reduced stack usage in CardReader

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 1294b5e..06420d3 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -338,7 +338,7 @@ extern bool axis_homed[3]; // axis[n].is_homed
   extern float filament_width_nominal;  //holds the theoretical filament diameter i.e., 3.00 or 1.75
   extern bool filament_sensor;  //indicates that filament sensor readings should control extrusion
   extern float filament_width_meas; //holds the filament diameter as accurately measured
-  extern signed char measurement_delay[];  //ring buffer to delay measurement
+  extern int8_t measurement_delay[];  //ring buffer to delay measurement
   extern int delay_index1, delay_index2;  //ring buffer index. used by planner, temperature, and main code
   extern float delay_dist; //delay distance counter
   extern int meas_delay_cm; //delay distance
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 75448a8..e0c5307 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -410,7 +410,7 @@ static uint8_t target_extruder;
   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA;  //Set nominal filament width, can be changed with M404
   bool filament_sensor = false;  //M405 turns on filament_sensor control, M406 turns it off
   float filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA; //Stores the measured filament diameter
-  signed char measurement_delay[MAX_MEASUREMENT_DELAY + 1]; //ring buffer to delay measurement  store extruder factor after subtracting 100
+  int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1]; //ring buffer to delay measurement  store extruder factor after subtracting 100
   int delay_index1 = 0;  //index into ring buffer
   int delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized
   float delay_dist = 0; //delay distance counter
@@ -4320,7 +4320,7 @@ inline void gcode_M109() {
 
     cancel_heatup = false;
     millis_t now = millis(), next_temp_ms = now + 1000UL;
-    while (!cancel_heatup && degTargetBed() != degBed()) {
+    while (!cancel_heatup && fabs(degTargetBed() - degBed()) < 0.75f) {
       millis_t now = millis();
       if (now > next_temp_ms) { //Print Temp Reading every 1 second while heating up.
         next_temp_ms = now + 1000UL;
@@ -5464,7 +5464,7 @@ inline void gcode_M400() { st_synchronize(); }
     if (delay_index2 == -1) { //initialize the ring buffer if it has not been done since startup
       int temp_ratio = widthFil_to_size_ratio();
 
-      for (delay_index1 = 0; delay_index1 < MAX_MEASUREMENT_DELAY + 1; ++delay_index1)
+      for (delay_index1 = 0; delay_index1 < COUNT(measurement_delay); ++delay_index1)
         measurement_delay[delay_index1] = temp_ratio - 100;  //subtract 100 to scale within a signed byte
 
       delay_index1 = delay_index2 = 0;
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 146dcd8..ed553ec 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -304,9 +304,11 @@ static void _draw_heater_status(int x, int heater) {
 static void lcd_implementation_status_screen() {
   u8g.setColorIndex(1); // black on white
 
+  bool blink = lcd_blink();
+
   #if HAS_FAN0
     // Symbols menu graphics, animated fan
-    u8g.drawBitmapP(9, 1, STATUS_SCREENBYTEWIDTH, STATUS_SCREENHEIGHT, (blink % 2) && fanSpeeds[0] ? status_screen0_bmp : status_screen1_bmp);
+    u8g.drawBitmapP(9, 1, STATUS_SCREENBYTEWIDTH, STATUS_SCREENHEIGHT, blink && fanSpeeds[0] ? status_screen0_bmp : status_screen1_bmp);
   #endif
 
   #if ENABLED(SDSUPPORT)
@@ -375,18 +377,19 @@ static void lcd_implementation_status_screen() {
   #endif
   u8g.setColorIndex(0); // white on black
   u8g.setPrintPos(2, XYZ_BASELINE);
-  if (blink & 1)
+  if (blink)
     lcd_printPGM(PSTR("X"));
   else {
     if (!axis_homed[X_AXIS])
       lcd_printPGM(PSTR("?"));
-    else
+    else {
       #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
         if (!axis_known_position[X_AXIS])
           lcd_printPGM(PSTR(" "));
         else
       #endif
       lcd_printPGM(PSTR("X"));
+    }
   }
   u8g.drawPixel(8, XYZ_BASELINE - 5);
   u8g.drawPixel(8, XYZ_BASELINE - 3);
@@ -394,18 +397,19 @@ static void lcd_implementation_status_screen() {
   lcd_print(ftostr31ns(current_position[X_AXIS]));
 
   u8g.setPrintPos(43, XYZ_BASELINE);
-  if (blink & 1)
+  if (blink)
     lcd_printPGM(PSTR("Y"));
   else {
     if (!axis_homed[Y_AXIS])
       lcd_printPGM(PSTR("?"));
-    else
+    else {
       #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
         if (!axis_known_position[Y_AXIS])
           lcd_printPGM(PSTR(" "));
         else
       #endif
       lcd_printPGM(PSTR("Y"));
+    }
   }
   u8g.drawPixel(49, XYZ_BASELINE - 5);
   u8g.drawPixel(49, XYZ_BASELINE - 3);
@@ -413,18 +417,19 @@ static void lcd_implementation_status_screen() {
   lcd_print(ftostr31ns(current_position[Y_AXIS]));
 
   u8g.setPrintPos(83, XYZ_BASELINE);
-  if (blink & 1)
+  if (blink)
     lcd_printPGM(PSTR("Z"));
   else {
     if (!axis_homed[Z_AXIS])
       lcd_printPGM(PSTR("?"));
-    else
+    else {
       #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
         if (!axis_known_position[Z_AXIS])
           lcd_printPGM(PSTR(" "));
         else
       #endif
       lcd_printPGM(PSTR("Z"));
+    }
   }
   u8g.drawPixel(89, XYZ_BASELINE - 5);
   u8g.drawPixel(89, XYZ_BASELINE - 3);
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 6bc3562..fd756d4 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -147,10 +147,6 @@ uint8_t g_uc_extruder_last_move[EXTRUDERS] = { 0 };
   static long axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
 #endif
 
-#if ENABLED(FILAMENT_SENSOR)
-  static char meas_sample; //temporary variable to hold filament measurement sample
-#endif
-
 #if ENABLED(DUAL_X_CARRIAGE)
   extern bool extruder_duplication_enabled;
 #endif
@@ -857,7 +853,6 @@ float junction_deviation = 0.1;
 
   #if ENABLED(FILAMENT_SENSOR)
     //FMM update ring buffer used for delay with filament measurements
-
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && delay_index2 > -1) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       const int MMD = MAX_MEASUREMENT_DELAY + 1, MMD10 = MMD * 10;
@@ -870,7 +865,7 @@ float junction_deviation = 0.1;
       delay_index1 = constrain(delay_index1, 0, MAX_MEASUREMENT_DELAY); // (already constrained above)
 
       if (delay_index1 != delay_index2) { // moved index
-        meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char
+        int8_t meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char
         while (delay_index1 != delay_index2) {
           // Increment and loop around buffer
           if (++delay_index2 >= MMD) delay_index2 -= MMD;
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 18a1545..6a8bf58 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -48,8 +48,6 @@
   #define ENCODER_DIRECTION_MENUS() ;
 #endif
 
-uint8_t blink = 0; // Variable for animation
-
 int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update
 
 bool encoderRateMultiplierEnabled;
@@ -1807,6 +1805,16 @@ int lcd_strlen_P(const char* s) {
   return j;
 }
 
+bool lcd_blink() {
+  static uint8_t blink = 0;
+  static millis_t next_blink_ms = 0;
+  if (millis() >= next_blink_ms) {
+    blink ^= 0xFF;
+    next_blink_ms = millis() + LCD_UPDATE_INTERVAL - 50;
+  }
+  return blink != 0;
+}
+
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
@@ -1923,25 +1931,23 @@ void lcd_update() {
         lcd_status_update_delay--;
       }
     }
-    #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display
-        if (lcdDrawUpdate) {
-          blink++;     // Variable for animation and alive dot
-          u8g.firstPage();
-          do {
-            lcd_setFont(FONT_MENU);
-            u8g.setPrintPos(125, 0);
-            if (blink & 1) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot
-            u8g.drawPixel(127, 63); // draw alive dot
-            u8g.setColorIndex(1); // black on white
-            (*currentMenu)();
-          } while (u8g.nextPage());
-        }
-    #else
-      if (lcdDrawUpdate) {
-        blink++;     // Variable for animation
+
+    if (lcdDrawUpdate) {
+      #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display
+        bool blink = lcd_blink();
+        u8g.firstPage();
+        do {
+          lcd_setFont(FONT_MENU);
+          u8g.setPrintPos(125, 0);
+          u8g.setColorIndex(blink ? 1 : 0); // Set color for the alive dot
+          u8g.drawPixel(127, 63); // draw alive dot
+          u8g.setColorIndex(1); // black on white
+          (*currentMenu)();
+        } while (u8g.nextPage());
+      #else
         (*currentMenu)();
-      }
-    #endif
+      #endif
+    }
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       lcd_implementation_update_indicators();
@@ -1963,8 +1969,7 @@ void lcd_update() {
 
     #endif // ULTIPANEL
 
-    if (lcdDrawUpdate == 2) lcd_implementation_clear();
-    if (lcdDrawUpdate) lcdDrawUpdate--;
+    if (lcdDrawUpdate && --lcdDrawUpdate) lcd_implementation_clear();
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
   }
 }
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 3743101..f3b33b5 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -76,15 +76,13 @@
 
   extern bool cancel_heatup;
 
-  extern uint8_t blink; // Variable for animation
-
   #if ENABLED(FILAMENT_LCD_DISPLAY)
     extern millis_t previous_lcd_status_ms;
   #endif
   void lcd_quick_feedback(); // Audible feedback for a button click - could also be visual
   bool lcd_clicked();
-
   void lcd_ignore_click(bool b=true);
+  bool lcd_blink();
 
   #if ENABLED(NEWPANEL)
     #define EN_C (_BV(BLEN_C))
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 244b7a2..52a4926 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -626,6 +626,8 @@ static void lcd_implementation_status_screen() {
 
   #if LCD_HEIGHT > 2
 
+    bool blink = lcd_blink();
+
     #if LCD_WIDTH < 20
 
       #if ENABLED(SDSUPPORT)
@@ -654,7 +656,7 @@ static void lcd_implementation_status_screen() {
         // When axis is homed but axis_known_position is false the axis letters are blinking 'X' <-> ' '.
         // When everything is ok you see a constant 'X'.
 
-        if (blink & 1)
+        if (blink)
           lcd_printPGM(PSTR("X"));
         else {
           if (!axis_homed[X_AXIS])
@@ -671,7 +673,7 @@ static void lcd_implementation_status_screen() {
         lcd.print(ftostr4sign(current_position[X_AXIS]));
 
         lcd_printPGM(PSTR(" "));
-        if (blink & 1)
+        if (blink)
           lcd_printPGM(PSTR("Y"));
         else {
           if (!axis_homed[Y_AXIS])
@@ -691,7 +693,7 @@ static void lcd_implementation_status_screen() {
     #endif // LCD_WIDTH >= 20
 
     lcd.setCursor(LCD_WIDTH - 8, 1);
-    if (blink & 1)
+    if (blink)
       lcd_printPGM(PSTR("Z"));
     else {
       if (!axis_homed[Z_AXIS])

