commit d2a00b74e3736c87ed28b02eb3dcdba0c2bac5d8 (from 0ad26d0de8a00bba3ba788fc38cec90a04ce6fce)
Merge: 0ad26d0 0e2bfd0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 14 20:10:08 2016 -0700

    Merge pull request #4004 from thinkyhead/rc_feedrate_in_gcode_T
    
    Use linear feedrate in gcode_T, not volumetric

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ca11329..343a6a7 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -6626,7 +6626,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
   float stored_feedrate = feedrate;
 
   if (code_seen('F')) {
-    float next_feedrate = code_value_axis_units(E_AXIS);
+    float next_feedrate = code_value_axis_units(X_AXIS);
     if (next_feedrate > 0.0) stored_feedrate = feedrate = next_feedrate;
   }
   else {

commit d2a00b74e3736c87ed28b02eb3dcdba0c2bac5d8 (from 0e2bfd0769e2c5ffb8f47ad10b0ba6b00fb206d7)
Merge: 0ad26d0 0e2bfd0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 14 20:10:08 2016 -0700

    Merge pull request #4004 from thinkyhead/rc_feedrate_in_gcode_T
    
    Use linear feedrate in gcode_T, not volumetric

diff --git a/.travis.yml b/.travis.yml
index 2464091..496b616 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -17,10 +17,10 @@ before_install:
   #
 install:
   #
-  # Install arduino 1.6.8
-  - wget http://downloads-02.arduino.cc/arduino-1.6.8-linux64.tar.xz
-  - tar xf arduino-1.6.8-linux64.tar.xz
-  - sudo mv arduino-1.6.8 /usr/local/share/arduino
+  # Install arduino 1.6.9
+  - wget http://downloads-02.arduino.cc/arduino-1.6.9-linux64.tar.xz
+  - tar xf arduino-1.6.9-linux64.tar.xz
+  - sudo mv arduino-1.6.9 /usr/local/share/arduino
   - ln -s /usr/local/share/arduino/arduino ${TRAVIS_BUILD_DIR}/buildroot/bin/arduino
   #
   # Install: LiquidCrystal_I2C library
@@ -76,10 +76,12 @@ script:
   - build_marlin
   #
   # Test 3 extruders on RUMBA (can use any board with >=3 extruders defined)
+  # Include a test for LIN_ADVANCE here also
   #
   - opt_set MOTHERBOARD BOARD_RUMBA
   - opt_set EXTRUDERS 3
   - opt_set TEMP_SENSOR_2 1
+  - opt_enable_adv LIN_ADVANCE
   - build_marlin
   #
   # Test PIDTEMPBED
@@ -105,7 +107,8 @@ script:
   - opt_enable NUM_SERVOS Z_ENDSTOP_SERVO_NR SERVO_ENDSTOP_ANGLES DEACTIVATE_SERVOS_AFTER_MOVE
   - build_marlin
   #
-  # Test EEPROM_SETTINGS, EEPROM_CHITCHAT, M100_FREE_MEMORY_WATCHER, INCH_MODE_SUPPORT, TEMPERATURE_UNITS_SUPPORT
+  # Test EEPROM_SETTINGS, EEPROM_CHITCHAT, M100_FREE_MEMORY_WATCHER,
+  #   INCH_MODE_SUPPORT, TEMPERATURE_UNITS_SUPPORT
   #
   - restore_configs
   - opt_enable EEPROM_SETTINGS EEPROM_CHITCHAT M100_FREE_MEMORY_WATCHER INCH_MODE_SUPPORT TEMPERATURE_UNITS_SUPPORT
@@ -130,7 +133,58 @@ script:
   - opt_enable BQ_LCD_SMART_CONTROLLER SPEAKER
   - build_marlin
   #
-  ### LCDS ###
+  # Enable FILAMENTCHANGEENABLE
+  #
+  - restore_configs
+  - opt_enable ULTIMAKERCONTROLLER
+  - opt_enable_adv FILAMENTCHANGEENABLE
+  - build_marlin
+  #
+  # Enable filament sensor
+  #
+  - restore_configs
+  - opt_enable FILAMENT_WIDTH_SENSOR
+  - build_marlin
+  #
+  # Enable filament sensor with LCD display
+  #
+  - opt_enable ULTIMAKERCONTROLLER FILAMENT_LCD_DISPLAY
+  - build_marlin
+  #
+  # Enable BEZIER_CURVE_SUPPORT
+  #
+  - restore_configs
+  - opt_enable_adv BEZIER_CURVE_SUPPORT
+  - build_marlin
+  #
+  # Enable COREXY
+  #
+  - restore_configs
+  - opt_enable COREXY
+  - build_marlin
+  #
+  # Enable COREXZ
+  #
+  - restore_configs
+  - opt_enable COREXZ
+  - build_marlin
+  #
+  # Enable Z_DUAL_STEPPER_DRIVERS, Z_DUAL_ENDSTOPS
+  #
+  - restore_configs
+  - opt_enable_adv Z_DUAL_STEPPER_DRIVERS Z_DUAL_ENDSTOPS
+  - pins_set RAMPS_14 X_MAX_PIN -1
+  - opt_set_adv Z2_MAX_PIN 2
+  - build_marlin
+  #
+  # Test PRINTCOUNTER
+  #
+  - restore_configs
+  - opt_enable PRINTCOUNTER
+  - build_marlin
+  #
+  #
+  ######## STANDARD LCD/PANELS ##############
   #
   # ULTRA_LCD
   #
@@ -188,25 +242,29 @@ script:
   - opt_enable RA_CONTROL_PANEL
   - build_marlin
   #
-  ### I2C PANELS ###
+  ######## I2C LCD/PANELS ##############
+  #
+  # !!!ATTENTION!!!
+  # Most I2C configurations are failing at the moment because they require
+  # a different Liquid Crystal library "LiquidTWI2".
   #
   # LCD_I2C_SAINSMART_YWROBOT
-  # Failing at the moment needs different library
+  #
   #- restore_configs
   #- opt_enable LCD_I2C_SAINSMART_YWROBOT
   #- build_marlin
   #
   # LCD_I2C_PANELOLU2
   #
-  - restore_configs
-  - opt_enable LCD_I2C_PANELOLU2
-  - build_marlin
+  #- restore_configs
+  #- opt_enable LCD_I2C_PANELOLU2
+  #- build_marlin
   #
   # LCD_I2C_VIKI
   #
-  - restore_configs
-  - opt_enable LCD_I2C_VIKI
-  - build_marlin
+  #- restore_configs
+  #- opt_enable LCD_I2C_VIKI
+  #- build_marlin
   #
   # LCM1602
   #
@@ -214,55 +272,6 @@ script:
   - opt_enable LCM1602
   - build_marlin
   #
-  # Enable FILAMENTCHANGEENABLE
-  #
-  - restore_configs
-  - opt_enable FILAMENTCHANGEENABLE ULTIMAKERCONTROLLER
-  - build_marlin
-  #
-  # Enable filament sensor
-  #
-  - restore_configs
-  - opt_enable FILAMENT_WIDTH_SENSOR
-  - build_marlin
-  #
-  # Enable filament sensor with LCD display
-  #
-  - opt_enable ULTIMAKERCONTROLLER FILAMENT_LCD_DISPLAY
-  - build_marlin
-  #
-  # Enable BEZIER_CURVE_SUPPORT
-  #
-  - restore_configs
-  - opt_enable_adv BEZIER_CURVE_SUPPORT
-  - build_marlin
-  #
-  # Enable COREXY
-  #
-  - restore_configs
-  - opt_enable COREXY
-  - build_marlin
-  #
-  # Enable COREXZ
-  #
-  - restore_configs
-  - opt_enable COREXZ
-  - build_marlin
-  #
-  # Enable Z_DUAL_STEPPER_DRIVERS, Z_DUAL_ENDSTOPS
-  #
-  - restore_configs
-  - opt_enable_adv Z_DUAL_STEPPER_DRIVERS Z_DUAL_ENDSTOPS
-  - pins_set RAMPS_14 X_MAX_PIN -1
-  - opt_set_adv Z2_MAX_PIN 2
-  - build_marlin
-  #
-  # Test PRINTCOUNTER
-  #
-  - restore_configs
-  - opt_enable PRINTCOUNTER
-  - build_marlin
-  #
   #
   ######## Example Configurations ##############
   #
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 952da0f..43b5111 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 1a3a170..f7c51e2 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -227,7 +227,6 @@ void FlushSerialRequestResend();
 void ok_to_send();
 
 void reset_bed_level();
-void prepare_move();
 void kill(const char*);
 
 #if DISABLED(DELTA) && DISABLED(SCARA)
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index e8d6939..343a6a7 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -333,7 +333,7 @@ const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 
 static int serial_count = 0;
 
-// GCode parameter pointer used by code_seen(), code_value(), etc.
+// GCode parameter pointer used by code_seen(), code_value_float(), etc.
 static char* seen_pointer;
 
 // Next Immediate GCode Command pointer. NULL if none.
@@ -487,6 +487,11 @@ static bool send_ok[BUFSIZE];
 
 #if HAS_SERVOS
   Servo servo[NUM_SERVOS];
+  #define MOVE_SERVO(I, P) servo[I].move(P)
+  #define SERVO_ENDSTOP_EXISTS(I) (servo_endstop_id[I] >= 0)
+  #define MOVE_SERVO_ENDSTOP(I, J) MOVE_SERVO(servo_endstop_id[I], servo_endstop_angle[I][J])
+  #define DEPLOY_SERVO_ENDSTOP(I) MOVE_SERVO_ENDSTOP(I, 0)
+  #define STOW_SERVO_ENDSTOP(I) MOVE_SERVO_ENDSTOP(I, 1)
 #endif
 
 #ifdef CHDK
@@ -529,6 +534,7 @@ void stop();
 
 void get_available_commands();
 void process_next_command();
+void prepare_move_to_destination();
 
 #if ENABLED(ARC_SUPPORT)
   void plan_arc(float target[NUM_AXIS], float* offset, uint8_t clockwise);
@@ -759,8 +765,8 @@ void servo_init() {
      *
      */
     for (int i = 0; i < 3; i++)
-      if (servo_endstop_id[i] >= 0)
-        servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);
+      if (SERVO_ENDSTOP_EXISTS(i))
+        STOW_SERVO_ENDSTOP(i);
 
   #endif // HAS_SERVO_ENDSTOPS
 
@@ -851,8 +857,6 @@ void setup() {
   // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
   Config_RetrieveSettings();
 
-  lcd_init();
-
   thermalManager.init();    // Initialize temperature loop
 
   #if ENABLED(DELTA) || ENABLED(SCARA)
@@ -900,6 +904,18 @@ void setup() {
     pinMode(STAT_LED_BLUE, OUTPUT);
     digitalWrite(STAT_LED_BLUE, LOW); // turn it off
   #endif
+
+  lcd_init();
+  #if ENABLED(SHOW_BOOTSCREEN)
+    #if ENABLED(DOGLCD)
+      delay(1000);
+    #elif ENABLED(ULTRA_LCD)
+      bootscreen();
+      lcd_init();
+    #endif
+  #endif
+
+
 }
 
 /**
@@ -1568,9 +1584,9 @@ static void setup_for_endstop_move() {
     /**
      * Calculate delta, start a line, and set current_position to destination
      */
-    void prepare_move_raw() {
+    void prepare_move_to_destination_raw() {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_move_raw", destination);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_move_to_destination_raw", destination);
       #endif
       refresh_cmd_timeout();
       calculate_delta(destination);
@@ -1674,7 +1690,7 @@ static void setup_for_endstop_move() {
       // move down slowly until you find the bed
       feedrate = homing_feedrate[Z_AXIS] / 4;
       destination[Z_AXIS] = -10;
-      prepare_move_raw(); // this will also set_current_to_destination
+      prepare_move_to_destination_raw(); // this will also set_current_to_destination
       stepper.synchronize();
       endstops.hit_on_purpose(); // clear endstop hit flags
 
@@ -1754,9 +1770,9 @@ static void setup_for_endstop_move() {
       destination[Z_AXIS] = z;
 
       if (x == current_position[X_AXIS] && y == current_position[Y_AXIS])
-        prepare_move_raw(); // this will also set_current_to_destination
+        prepare_move_to_destination_raw(); // this will also set_current_to_destination
       else
-        prepare_move();     // this will also set_current_to_destination
+        prepare_move_to_destination();     // this will also set_current_to_destination
 
       stepper.synchronize();
 
@@ -1824,7 +1840,8 @@ static void setup_for_endstop_move() {
     #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Engage Z Servo endstop if enabled
-      if (servo_endstop_id[Z_AXIS] >= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);
+      if (SERVO_ENDSTOP_EXISTS(Z_AXIS)
+        DEPLOY_SERVO_ENDSTOP(Z_AXIS);
 
     #elif ENABLED(Z_PROBE_ALLEN_KEY)
       feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;
@@ -1843,7 +1860,7 @@ static void setup_for_endstop_move() {
           destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_X;
           destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Y;
           destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Z;
-          prepare_move_raw(); // this will also set_current_to_destination
+          prepare_move_to_destination_raw(); // this will also set_current_to_destination
 
           // Move to engage deployment
           if (Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE)
@@ -1854,7 +1871,7 @@ static void setup_for_endstop_move() {
             destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Y;
           if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Z != Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
             destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Z;
-          prepare_move_raw();
+          prepare_move_to_destination_raw();
 
           #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
             if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE)
@@ -1870,14 +1887,14 @@ static void setup_for_endstop_move() {
             if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Z != Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
               destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Z;
 
-            prepare_move_raw();
+            prepare_move_to_destination_raw();
           #endif
         }
 
       // Partially Home X,Y for safety
       destination[X_AXIS] = destination[X_AXIS] * 0.75;
       destination[Y_AXIS] = destination[Y_AXIS] * 0.75;
-      prepare_move_raw(); // this will also set_current_to_destination
+      prepare_move_to_destination_raw(); // this will also set_current_to_destination
 
       stepper.synchronize();
 
@@ -1920,7 +1937,7 @@ static void setup_for_endstop_move() {
     #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Retract Z Servo endstop if enabled
-      if (servo_endstop_id[Z_AXIS] >= 0) {
+      if (SERVO_ENDSTOP_EXISTS(Z_AXIS)) {
 
         #if Z_RAISE_AFTER_PROBING > 0
           if (doRaise) {
@@ -1930,7 +1947,7 @@ static void setup_for_endstop_move() {
         #endif
 
         // Change the Z servo angle
-        servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);
+        STOW_SERVO_ENDSTOP(Z_AXIS);
       }
 
     #elif ENABLED(Z_PROBE_ALLEN_KEY)
@@ -1940,14 +1957,14 @@ static void setup_for_endstop_move() {
 
       #if Z_RAISE_AFTER_PROBING > 0
         destination[Z_AXIS] = current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING;
-        prepare_move_raw(); // this will also set_current_to_destination
+        prepare_move_to_destination_raw(); // this will also set_current_to_destination
       #endif
 
       // Move to the start position to initiate retraction
       destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_X;
       destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Y;
       destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Z;
-      prepare_move_raw();
+      prepare_move_to_destination_raw();
 
       // Move the nozzle down to push the Z probe into retracted position
       if (Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE)
@@ -1957,7 +1974,7 @@ static void setup_for_endstop_move() {
       if (Z_PROBE_ALLEN_KEY_STOW_2_Y != Z_PROBE_ALLEN_KEY_STOW_1_Y)
         destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Y;
       destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Z;
-      prepare_move_raw();
+      prepare_move_to_destination_raw();
 
       // Move up for safety
       if (Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE)
@@ -1967,13 +1984,13 @@ static void setup_for_endstop_move() {
       if (Z_PROBE_ALLEN_KEY_STOW_3_Y != Z_PROBE_ALLEN_KEY_STOW_2_Y)
         destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Y;
       destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Z;
-      prepare_move_raw();
+      prepare_move_to_destination_raw();
 
       // Home XY for safety
       feedrate = homing_feedrate[X_AXIS] / 2;
       destination[X_AXIS] = 0;
       destination[Y_AXIS] = 0;
-      prepare_move_raw(); // this will also set_current_to_destination
+      prepare_move_to_destination_raw(); // this will also set_current_to_destination
 
       stepper.synchronize();
 
@@ -2287,8 +2304,8 @@ static void homeaxis(AxisEnum axis) {
 
     #if ENABLED(HAS_SERVO_ENDSTOPS)
       // Engage an X, Y (or Z) Servo endstop if enabled
-      if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
-        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);
+      if (_Z_SERVO_TEST && SERVO_ENDSTOP_EXISTS(axis)) {
+        DEPLOY_SERVO_ENDSTOP(axis);
         if (_Z_SERVO_SUBTEST) endstops.z_probe_enabled = true;
       }
     #endif
@@ -2418,7 +2435,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Retract X, Y (or Z) Servo endstop if enabled
     #if ENABLED(HAS_SERVO_ENDSTOPS)
-      if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
+      if (_Z_SERVO_TEST && SERVO_ENDSTOP_EXISTS(axis)) {
         // Raise the servo probe before stow outside ABL context.
         // This is a workaround to allow use of a Servo Probe without
         // ABL until more global probe handling is implemented.
@@ -2437,7 +2454,7 @@ static void homeaxis(AxisEnum axis) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
         #endif
-        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);
+        STOW_SERVO_ENDSTOP(axis);
         if (_Z_SERVO_SUBTEST) endstops.enable_z_probe(false);
       }
 
@@ -2468,7 +2485,7 @@ static void homeaxis(AxisEnum axis) {
       feedrate = retract_feedrate * 60;
       current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
       sync_plan_position_e();
-      prepare_move();
+      prepare_move_to_destination();
 
       if (retract_zlift > 0.01) {
         current_position[Z_AXIS] -= retract_zlift;
@@ -2477,7 +2494,7 @@ static void homeaxis(AxisEnum axis) {
         #else
           sync_plan_position();
         #endif
-        prepare_move();
+        prepare_move_to_destination();
       }
     }
     else {
@@ -2495,7 +2512,7 @@ static void homeaxis(AxisEnum axis) {
       float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
       current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
       sync_plan_position_e();
-      prepare_move();
+      prepare_move_to_destination();
     }
 
     feedrate = oldFeedrate;
@@ -2593,7 +2610,7 @@ inline void gcode_G0_G1() {
 
     #endif //FWRETRACT
 
-    prepare_move();
+    prepare_move_to_destination();
   }
 }
 
@@ -5672,7 +5689,7 @@ inline void gcode_M226() {
     if (code_seen('S')) {
       servo_position = code_value_int();
       if (servo_index >= 0 && servo_index < NUM_SERVOS)
-        servo[servo_index].move(servo_position);
+        MOVE_SERVO(servo_index, servo_position);
       else {
         SERIAL_ERROR_START;
         SERIAL_ERROR("Servo ");
@@ -5887,7 +5904,7 @@ inline void gcode_M303() {
       calculate_SCARA_forward_Transform(delta);
       destination[X_AXIS] = delta[X_AXIS] / axis_scaling[X_AXIS];
       destination[Y_AXIS] = delta[Y_AXIS] / axis_scaling[Y_AXIS];
-      prepare_move();
+      prepare_move_to_destination();
       //ok_to_send();
       return true;
     }
@@ -6468,6 +6485,16 @@ inline void gcode_M503() {
 
 #endif // DUAL_X_CARRIAGE
 
+#if ENABLED(LIN_ADVANCE)
+  /**
+   * M905: Set advance factor
+   */
+  inline void gcode_M905() {
+    stepper.synchronize();
+    stepper.advance_M905(code_seen('K') ? code_value_float() : -1.0);
+  }
+#endif
+
 /**
  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  */
@@ -6679,6 +6706,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
           offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
 
+          // Adjust the current position
           current_position[X_AXIS] += offset_vec.x;
           current_position[Y_AXIS] += offset_vec.y;
           current_position[Z_AXIS] += offset_vec.z;
@@ -6716,7 +6744,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
       #endif
 
       // Move to the "old position" (move the extruder into place)
-      if (IsRunning()) prepare_move();
+      if (IsRunning()) prepare_move_to_destination();
 
     } // (tmp_extruder != active_extruder)
 
@@ -7339,6 +7367,12 @@ void process_next_command() {
           gcode_M605();
           break;
       #endif // DUAL_X_CARRIAGE
+      
+      #if ENABLED(LIN_ADVANCE)
+        case 905: // M905 Set advance factor.
+          gcode_M905();
+          break;
+      #endif
 
       case 907: // M907 Set digital trimpot motor current using axis codes.
         gcode_M907();
@@ -7597,32 +7631,9 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
 }
 #endif  // MESH_BED_LEVELING
 
-#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
-
-  inline void prevent_dangerous_extrude(float& curr_e, float& dest_e) {
-    if (DEBUGGING(DRYRUN)) return;
-    float de = dest_e - curr_e;
-    if (de) {
-      if (thermalManager.tooColdToExtrude(active_extruder)) {
-        curr_e = dest_e; // Behave as if the move really took place, but ignore E part
-        SERIAL_ECHO_START;
-        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
-      }
-      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (labs(de) > EXTRUDE_MAXLENGTH) {
-          curr_e = dest_e; // Behave as if the move really took place, but ignore E part
-          SERIAL_ECHO_START;
-          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
-        }
-      #endif
-    }
-  }
-
-#endif // PREVENT_DANGEROUS_EXTRUDE
-
 #if ENABLED(DELTA) || ENABLED(SCARA)
 
-  inline bool prepare_move_delta(float target[NUM_AXIS]) {
+  inline bool prepare_delta_move_to(float target[NUM_AXIS]) {
     float difference[NUM_AXIS];
     for (int8_t i = 0; i < NUM_AXIS; i++) difference[i] = target[i] - current_position[i];
 
@@ -7651,8 +7662,8 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
         if (!bed_leveling_in_progress) adjust_delta(target);
       #endif
 
-      //DEBUG_POS("prepare_move_delta", target);
-      //DEBUG_POS("prepare_move_delta", delta);
+      //DEBUG_POS("prepare_delta_move_to", target);
+      //DEBUG_POS("prepare_delta_move_to", delta);
 
       planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], _feedrate, active_extruder);
     }
@@ -7662,7 +7673,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
 #endif // DELTA || SCARA
 
 #if ENABLED(SCARA)
-  inline bool prepare_move_scara(float target[NUM_AXIS]) { return prepare_move_delta(target); }
+  inline bool prepare_scara_move_to(float target[NUM_AXIS]) { return prepare_delta_move_to(target); }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
@@ -7706,7 +7717,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
 
 #if DISABLED(DELTA) && DISABLED(SCARA)
 
-  inline bool prepare_move_cartesian() {
+  inline bool prepare_cartesian_move_to_destination() {
     // Do not use feedrate_multiplier for E or Z only moves
     if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) {
       line_to_destination();
@@ -7724,13 +7735,36 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
 
 #endif // !DELTA && !SCARA
 
+#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
+
+  inline void prevent_dangerous_extrude(float& curr_e, float& dest_e) {
+    if (DEBUGGING(DRYRUN)) return;
+    float de = dest_e - curr_e;
+    if (de) {
+      if (thermalManager.tooColdToExtrude(active_extruder)) {
+        curr_e = dest_e; // Behave as if the move really took place, but ignore E part
+        SERIAL_ECHO_START;
+        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+      }
+      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+        if (labs(de) > EXTRUDE_MAXLENGTH) {
+          curr_e = dest_e; // Behave as if the move really took place, but ignore E part
+          SERIAL_ECHO_START;
+          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+        }
+      #endif
+    }
+  }
+
+#endif // PREVENT_DANGEROUS_EXTRUDE
+
 /**
  * Prepare a single move and get ready for the next one
  *
  * (This may call planner.buffer_line several times to put
  *  smaller moves into the planner for DELTA or SCARA.)
  */
-void prepare_move() {
+void prepare_move_to_destination() {
   clamp_to_software_endstops(destination);
   refresh_cmd_timeout();
 
@@ -7739,14 +7773,14 @@ void prepare_move() {
   #endif
 
   #if ENABLED(SCARA)
-    if (!prepare_move_scara(destination)) return;
+    if (!prepare_scara_move_to(destination)) return;
   #elif ENABLED(DELTA)
-    if (!prepare_move_delta(destination)) return;
+    if (!prepare_delta_move_to(destination)) return;
   #else
     #if ENABLED(DUAL_X_CARRIAGE)
       if (!prepare_move_dual_x_carriage()) return;
     #endif
-    if (!prepare_move_cartesian()) return;
+    if (!prepare_cartesian_move_to_destination()) return;
   #endif
 
   set_current_to_destination();
@@ -8262,7 +8296,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       set_destination_to_current();
-      prepare_move();
+      prepare_move_to_destination();
     }
   #endif
 
@@ -8275,6 +8309,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
 void kill(const char* lcd_msg) {
   #if ENABLED(ULTRA_LCD)
+    lcd_init();
     lcd_setalertstatuspgm(lcd_msg);
   #else
     UNUSED(lcd_msg);
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index a913cb1..4110d67 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -352,13 +352,19 @@
 #endif // AUTO_BED_LEVELING_FEATURE
 
 /**
+ * Advance Extrusion
+ */
+#if ENABLED(ADVANCE) && ENABLED(LIN_ADVANCE)
+  #error You can enable ADVANCE or LIN_ADVANCE, but not both.
+#endif
+
+/**
  * Filament Width Sensor
  */
 #if ENABLED(FILAMENT_WIDTH_SENSOR) && !HAS_FILAMENT_WIDTH_SENSOR
   #error "FILAMENT_WIDTH_SENSOR requires a FILWIDTH_PIN to be defined."
 #endif
 
-
 /**
  * ULTIPANEL encoder
  */
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index 2e43625..c87fe84 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -24,8 +24,8 @@
 #define __BUZZER_H__
 
 #include "fastio.h"
-#include "watchdog.h"
 #include "circularqueue.h"
+#include "temperature.h"
 
 #define TONE_QUEUE_LENGTH 4
 
@@ -106,9 +106,7 @@ class Buzzer {
       while (buffer.isFull()) {
         delay(5);
         this->tick();
-        #if ENABLED(USE_WATCHDOG)
-          watchdog_reset();
-        #endif
+        thermalManager.manage_heater();
       }
       this->buffer.enqueue((tone_t) { duration, frequency });
     }
diff --git a/Marlin/dogm_custom_bitmaps.h b/Marlin/dogm_custom_bitmaps.h
new file mode 100644
index 0000000..4f30305
--- /dev/null
+++ b/Marlin/dogm_custom_bitmaps.h
@@ -0,0 +1,77 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * BitMap for custom splashscreen
+ * Generated with: http://www.digole.com/tools/PicturetoC_Hex_converter.php
+ */
+
+//#define CUSTOM_START_BMP
+
+#if ENABLED(CUSTOM_START_BMP)
+  
+  #define CUSTOM_START_BMP_DELAY     2000
+  #define CUSTOM_START_BMPWIDTH      112
+  #define CUSTOM_START_BMPHEIGHT      38
+  #define CUSTOM_START_BMPBYTEWIDTH   14
+  #define CUSTOM_START_BMPBYTES      532 // CUSTOM_START_BMPWIDTH * CUSTOM_START_BMPHEIGHT / 8
+
+  const unsigned char custom_start_bmp[CUSTOM_START_BMPBYTES] PROGMEM = {
+    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
+    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF,
+    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
+    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x3F, 0xFF,
+    0xC0, 0x0F, 0xC0, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x1F, 0xFF,
+    0xC0, 0x3F, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x0F, 0xFF,
+    0xC0, 0x7F, 0xF3, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x07, 0xFF,
+    0xC0, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x03, 0xFF,
+    0xC1, 0xF8, 0x7F, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x01, 0xFF,
+    0xC1, 0xF0, 0x3F, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFF,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x1F, 0x00, 0x03, 0xE0, 0x78, 0x3C, 0x03, 0xF0, 0x7F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0xC0, 0x0F, 0xF8, 0x78, 0x3C, 0x07, 0xFC, 0x3F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0xE0, 0x1F, 0xFC, 0x78, 0x3C, 0x0F, 0xFE, 0x1F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0xF0, 0x3F, 0xFE, 0x78, 0x3C, 0x1F, 0xFE, 0x0F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xF3, 0xF8, 0x3F, 0x3E, 0x78, 0x3C, 0x3F, 0x3F, 0x07,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xE0, 0xFC, 0x7C, 0x1F, 0x78, 0x3C, 0x3E, 0x1F, 0x07,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x7C, 0x7C, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x7C, 0x78, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xE0, 0x3C, 0x78, 0x00, 0x7C, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0x3F, 0xF8, 0x00, 0x7F, 0xBC, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0x3F, 0xF8, 0x00, 0x3F, 0xBF, 0xFC, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0xFF, 0x3F, 0xF8, 0x00, 0x1F, 0xBF, 0xFC, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0x3F, 0xF8, 0x00, 0x0F, 0xBF, 0xFC, 0x0F, 0x03,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
+    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
+    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
+    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
+    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80 };
+#endif
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 51ee6e4..08518b6 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -53,6 +53,8 @@
 
 #include <U8glib.h>
 #include "dogm_bitmaps.h"
+#include "dogm_custom_bitmaps.h"
+
 
 #include "ultralcd.h"
 #include "ultralcd_st7920_u8glib_rrd.h"
@@ -247,6 +249,15 @@ static void lcd_implementation_init() {
   #endif
 
   #if ENABLED(SHOW_BOOTSCREEN)
+    #if ENABLED(CUSTOM_START_BMP)
+      if (show_bootscreen) {
+        u8g.firstPage();
+        do {
+            u8g.drawBitmapP((128-(CUSTOM_START_BMPWIDTH))/2, (64 - (CUSTOM_START_BMPHEIGHT))/2, CUSTOM_START_BMPBYTEWIDTH, CUSTOM_START_BMPHEIGHT, custom_start_bmp);
+        } while (u8g.nextPage());
+        delay(CUSTOM_START_BMP_DELAY);
+      }
+    #endif
     int offx = (u8g.getWidth() - (START_BMPWIDTH)) / 2;
     #if ENABLED(START_BMPHIGH)
       int offy = 0;
@@ -271,10 +282,8 @@ static void lcd_implementation_init() {
       }
     } while (u8g.nextPage());
 
-    if (show_bootscreen) {
-      delay(1000);
-      show_bootscreen = false;
-    }
+    show_bootscreen = false;
+
   #endif
 }
 
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index b22bf95..5925466 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 9a89097..bf7e007 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
index bebd94b..37d00e4 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index c5e9249..17a88f0 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -451,6 +451,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/RigidBot/Configuration_adv.h b/Marlin/example_configurations/RigidBot/Configuration_adv.h
index 50d8cb5..1ab7d61 100644
--- a/Marlin/example_configurations/RigidBot/Configuration_adv.h
+++ b/Marlin/example_configurations/RigidBot/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index f3ba728..18afdbe 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/TAZ4/Configuration_adv.h b/Marlin/example_configurations/TAZ4/Configuration_adv.h
index 5aa9487..58b64c6 100644
--- a/Marlin/example_configurations/TAZ4/Configuration_adv.h
+++ b/Marlin/example_configurations/TAZ4/Configuration_adv.h
@@ -453,6 +453,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 9a89097..bf7e007 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
index 627188d..2d0ec24 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index d64dfd5..b965251 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index f99318e..73d4229 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -446,6 +446,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index 3250e88..c917954 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -451,6 +451,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index f0ccba6..0fd30c1 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index d8ef5d3..2cca1a4 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index af2d22f..589fc19 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index 7fb0bdc..a0f78ad 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -38,12 +38,17 @@
 #define WELCOME_MSG                         MACHINE_NAME " pronto."
 #define MSG_SD_INSERTED                     "SD Card inserita"
 #define MSG_SD_REMOVED                      "SD Card rimossa"
+#define MSG_LCD_ENDSTOPS                    "Endstop"
 #define MSG_MAIN                            "Menu principale"
 #define MSG_AUTOSTART                       "Autostart"
 #define MSG_DISABLE_STEPPERS                "Disabilita Motori"
 #define MSG_AUTO_HOME                       "Auto Home"
+#define MSG_AUTO_HOME_X                     "Home asse X"
+#define MSG_AUTO_HOME_Y                     "Home asse Y"
+#define MSG_AUTO_HOME_Z                     "Home asse Z"
 #define MSG_LEVEL_BED_HOMING                "Home assi XYZ"
 #define MSG_LEVEL_BED_WAITING               "Premi per Iniziare"
+#define MSG_LEVEL_BED_NEXT_POINT            "Punto successivo"
 #define MSG_LEVEL_BED_DONE                  "Livel. terminato!"
 #define MSG_LEVEL_BED_CANCEL                "Annulla"
 #define MSG_SET_HOME_OFFSETS                "Imp. offset home"
@@ -146,6 +151,7 @@
 #define MSG_CNG_SDCARD                      "Cambia SD-Card"
 #define MSG_ZPROBE_OUT                      "Z probe out. bed"
 #define MSG_YX_UNHOMED                      "Home X/Y prima di Z"
+#define MSG_XYZ_UNHOMED                     "Home XYZ prima"
 #define MSG_ZPROBE_ZOFFSET                  "Z Offset"
 #define MSG_BABYSTEP_X                      "Babystep X"
 #define MSG_BABYSTEP_Y                      "Babystep Y"
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index bd60d75..699987f 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -1050,7 +1050,23 @@ void Planner::check_axes_activity() {
   for (int i = 0; i < NUM_AXIS; i++) previous_speed[i] = current_speed[i];
   previous_nominal_speed = block->nominal_speed;
 
-  #if ENABLED(ADVANCE)
+  #if ENABLED(LIN_ADVANCE)
+
+    // bse == allsteps: A problem occurs when there's a very tiny move before a retract.
+    // In this case, the retract and the move will be executed together.
+    // This leads to an enormous number of advance steps due to a huge e_acceleration.
+    // The math is correct, but you don't want a retract move done with advance!
+    // So this situation is filtered out here.
+    if (!bse || (!bsx && !bsy && !bsz) || stepper.get_advance_k() == 0 || bse == allsteps) {
+      block->use_advance_lead = false;
+    }
+    else {
+      block->use_advance_lead = true;
+      block->e_speed_multiplier8 = (block->steps[E_AXIS] << 8) / block->step_event_count;
+    }
+
+  #elif ENABLED(ADVANCE)
+
     // Calculate advance rate
     if (!bse || (!bsx && !bsy && !bsz)) {
       block->advance_rate = 0;
@@ -1069,7 +1085,8 @@ void Planner::check_axes_activity() {
      SERIAL_ECHOPGM("advance rate :");
      SERIAL_ECHOLN(block->advance_rate/256.0);
      */
-  #endif // ADVANCE
+
+  #endif // ADVANCE or LIN_ADVANCE
 
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 07de371..5121974 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -64,7 +64,11 @@ typedef struct {
 
   unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
-  #if ENABLED(ADVANCE)
+  // Advance extrusion
+  #if ENABLED(LIN_ADVANCE)
+    bool use_advance_lead;
+    int e_speed_multiplier8; // Factorised by 2^8 to avoid float
+  #elif ENABLED(ADVANCE)
     long advance_rate;
     volatile long initial_advance;
     volatile long final_advance;
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index f8e8a85..8d1fe03 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -89,13 +89,24 @@ long  Stepper::counter_X = 0,
 
 volatile unsigned long Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
-#if ENABLED(ADVANCE)
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
   unsigned char Stepper::old_OCR0A;
-  long  Stepper::final_advance = 0,
-        Stepper::old_advance = 0,
-        Stepper::e_steps[EXTRUDERS],
-        Stepper::advance_rate,
-        Stepper::advance;
+  volatile unsigned char Stepper::eISR_Rate = 200; // Keep the ISR at a low rate until needed
+
+  #if ENABLED(LIN_ADVANCE)
+    volatile int Stepper::e_steps[EXTRUDERS];
+    int Stepper::extruder_advance_k = LIN_ADVANCE_K,
+        Stepper::final_estep_rate,
+        Stepper::current_estep_rate[EXTRUDERS],
+        Stepper::current_adv_steps[EXTRUDERS];
+  #else
+    long  Stepper::e_steps[EXTRUDERS],
+          Stepper::final_advance = 0,
+          Stepper::old_advance = 0,
+          Stepper::advance_rate,
+          Stepper::advance;
+  #endif
 #endif
 
 long Stepper::acceleration_time, Stepper::deceleration_time;
@@ -344,14 +355,32 @@ void Stepper::isr() {
         customizedSerial.checkRx(); // Check for serial chars.
       #endif
 
-      #if ENABLED(ADVANCE)
+      #if ENABLED(LIN_ADVANCE)
+
+        counter_E += current_block->steps[E_AXIS];
+        if (counter_E > 0) {
+          counter_E -= current_block->step_event_count;
+          count_position[E_AXIS] += count_direction[E_AXIS];
+          e_steps[current_block->active_extruder] += motor_direction(E_AXIS) ? -1 : 1;
+        }
+
+        if (current_block->use_advance_lead) {
+          int delta_adv_steps; //Maybe a char would be enough?
+          delta_adv_steps = (((long)extruder_advance_k * current_estep_rate[current_block->active_extruder]) >> 9) - current_adv_steps[current_block->active_extruder];
+          e_steps[current_block->active_extruder] += delta_adv_steps;
+          current_adv_steps[current_block->active_extruder] += delta_adv_steps;
+        }
+
+      #elif ENABLED(ADVANCE)
+
         counter_E += current_block->steps[E_AXIS];
         if (counter_E > 0) {
           counter_E -= current_block->step_event_count;
           e_steps[current_block->active_extruder] += motor_direction(E_AXIS) ? -1 : 1;
         }
-      #endif //ADVANCE
 
+      #endif // ADVANCE or LIN_ADVANCE
+      
       #define _COUNTER(AXIS) counter_## AXIS
       #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
       #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
@@ -363,7 +392,7 @@ void Stepper::isr() {
       STEP_ADD(X);
       STEP_ADD(Y);
       STEP_ADD(Z);
-      #if DISABLED(ADVANCE)
+      #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
         STEP_ADD(E);
       #endif
 
@@ -377,13 +406,19 @@ void Stepper::isr() {
       STEP_IF_COUNTER(X);
       STEP_IF_COUNTER(Y);
       STEP_IF_COUNTER(Z);
-      #if DISABLED(ADVANCE)
+      #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
         STEP_IF_COUNTER(E);
       #endif
 
       step_events_completed++;
       if (step_events_completed >= current_block->step_event_count) break;
     }
+
+    #if ENABLED(LIN_ADVANCE)
+      // If we have esteps to execute, fire the next ISR "now"
+      if (e_steps[current_block->active_extruder]) OCR0A = TCNT0 + 2;
+    #endif
+
     // Calculate new timer value
     unsigned short timer, step_rate;
     if (step_events_completed <= (unsigned long)current_block->accelerate_until) {
@@ -399,7 +434,12 @@ void Stepper::isr() {
       OCR1A = timer;
       acceleration_time += timer;
 
-      #if ENABLED(ADVANCE)
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
+
+      #elif ENABLED(ADVANCE)
 
         advance += advance_rate * step_loops;
         //NOLESS(advance, current_block->advance);
@@ -408,7 +448,11 @@ void Stepper::isr() {
         e_steps[current_block->active_extruder] += ((advance >> 8) - old_advance);
         old_advance = advance >> 8;
 
-      #endif //ADVANCE
+      #endif // ADVANCE or LIN_ADVANCE
+
+      #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+        eISR_Rate = (timer >> 2) / abs(e_steps[current_block->active_extruder]);
+      #endif
     }
     else if (step_events_completed > (unsigned long)current_block->decelerate_after) {
       MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
@@ -424,8 +468,14 @@ void Stepper::isr() {
       timer = calc_timer(step_rate);
       OCR1A = timer;
       deceleration_time += timer;
+      
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)step_rate * current_block->e_speed_multiplier8) >> 8;
+
+      #elif ENABLED(ADVANCE)
 
-      #if ENABLED(ADVANCE)
         advance -= advance_rate * step_loops;
         NOLESS(advance, final_advance);
 
@@ -433,9 +483,24 @@ void Stepper::isr() {
         uint32_t advance_whole = advance >> 8;
         e_steps[current_block->active_extruder] += advance_whole - old_advance;
         old_advance = advance_whole;
-      #endif //ADVANCE
+
+      #endif // ADVANCE or LIN_ADVANCE
+
+      #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+        eISR_Rate = (timer >> 2) / abs(e_steps[current_block->active_extruder]);
+      #endif
     }
     else {
+
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = final_estep_rate;
+
+        eISR_Rate = (OCR1A_nominal >> 2) / abs(e_steps[current_block->active_extruder]);
+
+      #endif
+
       OCR1A = OCR1A_nominal;
       // ensure we're running at the correct step rate, even if we just came off an acceleration
       step_loops = step_loops_nominal;
@@ -451,13 +516,15 @@ void Stepper::isr() {
   }
 }
 
-#if ENABLED(ADVANCE)
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
   // Timer interrupt for E. e_steps is set in the main routine;
   // Timer 0 is shared with millies
   ISR(TIMER0_COMPA_vect) { Stepper::advance_isr(); }
 
   void Stepper::advance_isr() {
-    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
+
+    old_OCR0A += eISR_Rate;
     OCR0A = old_OCR0A;
 
     #define STEP_E_ONCE(INDEX) \
@@ -474,22 +541,21 @@ void Stepper::isr() {
         E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); \
       }
 
-    // Step all E steppers that have steps, up to 4 steps per interrupt
-    for (unsigned char i = 0; i < 4; i++) {
-      STEP_E_ONCE(0);
-      #if EXTRUDERS > 1
-        STEP_E_ONCE(1);
-        #if EXTRUDERS > 2
-          STEP_E_ONCE(2);
-          #if EXTRUDERS > 3
-            STEP_E_ONCE(3);
-          #endif
+    // Step all E steppers that have steps
+    STEP_E_ONCE(0);
+    #if EXTRUDERS > 1
+      STEP_E_ONCE(1);
+      #if EXTRUDERS > 2
+        STEP_E_ONCE(2);
+        #if EXTRUDERS > 3
+          STEP_E_ONCE(3);
         #endif
       #endif
-    }
+    #endif
+
   }
 
-#endif // ADVANCE
+#endif // ADVANCE or LIN_ADVANCE
 
 void Stepper::init() {
 
@@ -656,14 +722,28 @@ void Stepper::init() {
   TCNT1 = 0;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  #if ENABLED(ADVANCE)
+  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
+    #if ENABLED(LIN_ADVANCE)
+
+      for (int i = 0; i < EXTRUDERS; i++) {
+        e_steps[i] = 0;
+        current_adv_steps[i] = 0;
+      }
+
+    #elif ENABLED(ADVANCE)
+
+      for (uint8_t i = 0; i < EXTRUDERS; i++) e_steps[i] = 0;
+
+    #endif
+
     #if defined(TCCR0A) && defined(WGM01)
       CBI(TCCR0A, WGM01);
       CBI(TCCR0A, WGM00);
     #endif
-    for (uint8_t i = 0; i < EXTRUDERS; i++) e_steps[i] = 0;
     SBI(TIMSK0, OCIE0A);
-  #endif //ADVANCE
+
+  #endif // ADVANCE or LIN_ADVANCE
 
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
@@ -1040,3 +1120,14 @@ void Stepper::microstep_readings() {
     SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));
   #endif
 }
+
+#if ENABLED(LIN_ADVANCE)
+
+  void Stepper::advance_M905(const float &k) {
+    if (k >= 0) extruder_advance_k = k;
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("Advance factor: ", extruder_advance_k);
+    SERIAL_EOL;
+  }
+
+#endif // LIN_ADVANCE
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 1aebe36..7612e60 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -22,7 +22,7 @@
 
 /**
  * stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
- * Part of Grbl
+ * Derived from Grbl
  *
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  *
@@ -90,10 +90,6 @@ class Stepper {
       static bool performing_homing;
     #endif
 
-    #if ENABLED(ADVANCE)
-      static long e_steps[EXTRUDERS];
-    #endif
-
   private:
 
     static unsigned char last_direction_bits;        // The next stepping-bits to be output
@@ -107,10 +103,23 @@ class Stepper {
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile unsigned long step_events_completed; // The number of step events executed in the current block
 
-    #if ENABLED(ADVANCE)
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
       static unsigned char old_OCR0A;
-      static long advance_rate, advance, old_advance, final_advance;
-    #endif
+      static volatile unsigned char eISR_Rate;
+      #if ENABLED(LIN_ADVANCE)
+        static volatile int e_steps[EXTRUDERS];
+        static int extruder_advance_k;
+        static int final_estep_rate;
+        static int current_estep_rate[EXTRUDERS]; // Actual extruder speed [steps/s]
+        static int current_adv_steps[EXTRUDERS];  // The amount of current added esteps due to advance.
+                                                  // i.e., the current amount of pressure applied
+                                                  // to the spring (=filament).
+      #else
+        static long e_steps[EXTRUDERS];
+        static long advance_rate, advance, final_advance;
+        static long old_advance;
+      #endif
+    #endif // ADVANCE or LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
@@ -156,7 +165,7 @@ class Stepper {
 
     static void isr();
 
-    #if ENABLED(ADVANCE)
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
       static void advance_isr();
     #endif
 
@@ -246,6 +255,11 @@ class Stepper {
       return endstops_trigsteps[axis] / planner.axis_steps_per_mm[axis];
     }
 
+    #if ENABLED(LIN_ADVANCE)
+      void advance_M905(const float &k);
+      FORCE_INLINE int get_advance_k() { return extruder_advance_k; }
+    #endif
+
   private:
 
     static FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
@@ -315,6 +329,13 @@ class Stepper {
       acc_step_rate = current_block->initial_rate;
       acceleration_time = calc_timer(acc_step_rate);
       OCR1A = acceleration_time;
+      
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->use_advance_lead) {
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
+          final_estep_rate = (current_block->nominal_rate * current_block->e_speed_multiplier8) >> 8;
+        }
+      #endif
 
       // SERIAL_ECHO_START;
       // SERIAL_ECHOPGM("advance :");
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 1d6db5c..b80950f 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1228,7 +1228,7 @@ void Temperature::disable_all_heaters() {
   print_job_timer.stop();
 
   #define DISABLE_HEATER(NR) { \
-    setTargetHotend(NR, 0); \
+    setTargetHotend(0, NR); \
     soft_pwm[NR] = 0; \
     WRITE_HEATER_ ## NR (LOW); \
   }
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 6f19ce5..0c8ccc0 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -29,33 +29,6 @@
 #include "stepper.h"
 #include "configuration_store.h"
 
-/**
- * REVERSE_MENU_DIRECTION
- *
- * To reverse the menu direction we need a general way to reverse
- * the direction of the encoder everywhere. So encoderDirection is
- * added to allow the encoder to go the other way.
- *
- * This behavior is limited to scrolling Menus and SD card listings,
- * and is disabled in other contexts.
- */
-#if ENABLED(REVERSE_MENU_DIRECTION)
-  int8_t encoderDirection = 1;
-  #define ENCODER_DIRECTION_NORMAL() (encoderDirection = 1)
-  #define ENCODER_DIRECTION_MENUS() (encoderDirection = -1)
-#else
-  #define ENCODER_DIRECTION_NORMAL() ;
-  #define ENCODER_DIRECTION_MENUS() ;
-#endif
-
-int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update
-
-int8_t manual_move_axis = (int8_t)NO_AXIS;
-millis_t manual_move_start_time = 0;
-
-bool encoderRateMultiplierEnabled;
-int32_t lastEncoderMovementMillis;
-
 int plaPreheatHotendTemp;
 int plaPreheatHPBTemp;
 int plaPreheatFanSpeed;
@@ -68,9 +41,6 @@ int absPreheatFanSpeed;
   millis_t previous_lcd_status_ms = 0;
 #endif
 
-// Function pointer to menu functions.
-typedef void (*menuFunc_t)();
-
 uint8_t lcd_status_message_level;
 char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
 
@@ -83,8 +53,55 @@ char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kan
 // The main status screen
 static void lcd_status_screen();
 
+millis_t next_lcd_update_ms;
+
+enum LCDViewAction {
+  LCDVIEW_NONE,
+  LCDVIEW_REDRAW_NOW,
+  LCDVIEW_CALL_REDRAW_NEXT,
+  LCDVIEW_CLEAR_CALL_REDRAW,
+  LCDVIEW_CALL_NO_REDRAW
+};
+
+uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
+
 #if ENABLED(ULTIPANEL)
 
+  // place-holders for Ki and Kd edits
+  float raw_Ki, raw_Kd;
+
+  /**
+   * REVERSE_MENU_DIRECTION
+   *
+   * To reverse the menu direction we need a general way to reverse
+   * the direction of the encoder everywhere. So encoderDirection is
+   * added to allow the encoder to go the other way.
+   *
+   * This behavior is limited to scrolling Menus and SD card listings,
+   * and is disabled in other contexts.
+   */
+  #if ENABLED(REVERSE_MENU_DIRECTION)
+    int8_t encoderDirection = 1;
+    #define ENCODER_DIRECTION_NORMAL() (encoderDirection = 1)
+    #define ENCODER_DIRECTION_MENUS() (encoderDirection = -1)
+  #else
+    #define ENCODER_DIRECTION_NORMAL() ;
+    #define ENCODER_DIRECTION_MENUS() ;
+  #endif
+
+  int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update
+
+  millis_t manual_move_start_time = 0;
+  int8_t manual_move_axis = (int8_t)NO_AXIS;
+  #if EXTRUDERS > 1
+    int8_t manual_move_e_index = 0;
+  #else
+    #define manual_move_e_index 0
+  #endif
+
+  bool encoderRateMultiplierEnabled;
+  int32_t lastEncoderMovementMillis;
+
   #if HAS_POWER_SWITCH
     extern bool powersupply;
   #endif
@@ -116,11 +133,14 @@ static void lcd_status_screen();
     #include "mesh_bed_leveling.h"
   #endif
 
-  /* Different types of actions that can be used in menu items. */
+  // Function pointer to menu functions.
+  typedef void (*screenFunc_t)();
+
+  // Different types of actions that can be used in menu items.
   static void menu_action_back();
-  static void menu_action_submenu(menuFunc_t data);
+  static void menu_action_submenu(screenFunc_t data);
   static void menu_action_gcode(const char* pgcode);
-  static void menu_action_function(menuFunc_t data);
+  static void menu_action_function(screenFunc_t data);
   static void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
   static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
   static void menu_action_setting_edit_float3(const char* pstr, float* ptr, float minValue, float maxValue);
@@ -130,15 +150,15 @@ static void lcd_status_screen();
   static void menu_action_setting_edit_float51(const char* pstr, float* ptr, float minValue, float maxValue);
   static void menu_action_setting_edit_float52(const char* pstr, float* ptr, float minValue, float maxValue);
   static void menu_action_setting_edit_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue);
-  static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float3(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float32(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float43(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float5(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float51(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
-  static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, menuFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float3(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float32(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float43(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float5(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float51(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, screenFunc_t callbackFunc);
+  static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, screenFunc_t callbackFunc);
 
   #if ENABLED(SDSUPPORT)
     static void lcd_sdcard_menu();
@@ -270,91 +290,80 @@ static void lcd_status_screen();
     uint8_t lcd_sd_status;
   #endif
 
-#endif // ULTIPANEL
-
-typedef struct {
-  menuFunc_t menu_function;
-  #if ENABLED(ULTIPANEL)
+  typedef struct {
+    screenFunc_t menu_function;
     uint32_t encoder_position;
-  #endif
-} menuPosition;
+  } menuPosition;
 
-menuFunc_t currentMenu = lcd_status_screen; // pointer to the currently active menu handler
+  screenFunc_t currentScreen = lcd_status_screen; // pointer to the currently active menu handler
 
-menuPosition menu_history[10];
-uint8_t menu_history_depth = 0;
-
-millis_t next_lcd_update_ms;
-bool ignore_click = false;
-bool wait_for_unclick;
-bool defer_return_to_status = false;
+  menuPosition screen_history[10];
+  uint8_t screen_history_depth = 0;
 
-enum LCDViewAction {
-  LCDVIEW_NONE,
-  LCDVIEW_REDRAW_NOW,
-  LCDVIEW_CALL_REDRAW_NEXT,
-  LCDVIEW_CLEAR_CALL_REDRAW,
-  LCDVIEW_CALL_NO_REDRAW
-};
+  bool ignore_click = false;
+  bool wait_for_unclick;
+  bool defer_return_to_status = false;
 
-uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
+  // Variables used when editing values.
+  const char* editLabel;
+  void* editValue;
+  int32_t minEditValue, maxEditValue;
+  screenFunc_t callbackFunc;              // call this after editing
 
-// Variables used when editing values.
-const char* editLabel;
-void* editValue;
-int32_t minEditValue, maxEditValue;
-menuFunc_t callbackFunc;              // call this after editing
+  /**
+   * General function to go directly to a menu
+   * Remembers the previous position
+   */
+  static void lcd_goto_screen(screenFunc_t screen, const bool feedback = false, const uint32_t encoder = 0) {
+    if (currentScreen != screen) {
+      currentScreen = screen;
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+      #if ENABLED(NEWPANEL)
+        encoderPosition = encoder;
+        if (feedback) lcd_quick_feedback();
+      #endif
+      if (screen == lcd_status_screen) {
+        defer_return_to_status = false;
+        screen_history_depth = 0;
+      }
+      #if ENABLED(LCD_PROGRESS_BAR)
+        // For LCD_PROGRESS_BAR re-initialize custom characters
+        lcd_set_custom_characters(screen == lcd_status_screen);
+      #endif
+    }
+  }
 
-// place-holders for Ki and Kd edits
-float raw_Ki, raw_Kd;
+  static void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
 
-/**
- * General function to go directly to a menu
- * Remembers the previous position
- */
-static void lcd_goto_menu(menuFunc_t menu, const bool feedback = false, const uint32_t encoder = 0) {
-  if (currentMenu != menu) {
-    currentMenu = menu;
-    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-    #if ENABLED(NEWPANEL)
-      encoderPosition = encoder;
-      if (feedback) lcd_quick_feedback();
-    #endif
-    if (menu == lcd_status_screen) {
-      defer_return_to_status = false;
-      menu_history_depth = 0;
+  inline void lcd_save_previous_menu() {
+    if (screen_history_depth < COUNT(screen_history)) {
+      screen_history[screen_history_depth].menu_function = currentScreen;
+      #if ENABLED(ULTIPANEL)
+        screen_history[screen_history_depth].encoder_position = encoderPosition;
+      #endif
+      ++screen_history_depth;
     }
-    #if ENABLED(LCD_PROGRESS_BAR)
-      // For LCD_PROGRESS_BAR re-initialize custom characters
-      lcd_set_custom_characters(menu == lcd_status_screen);
-    #endif
   }
-}
-
-static void lcd_return_to_status() { lcd_goto_menu(lcd_status_screen); }
 
-inline void lcd_save_previous_menu() {
-  if (menu_history_depth < COUNT(menu_history)) {
-    menu_history[menu_history_depth].menu_function = currentMenu;
-    #if ENABLED(ULTIPANEL)
-      menu_history[menu_history_depth].encoder_position = encoderPosition;
-    #endif
-    ++menu_history_depth;
+  static void lcd_goto_previous_menu(bool feedback=false) {
+    if (screen_history_depth > 0) {
+      --screen_history_depth;
+      lcd_goto_screen(screen_history[screen_history_depth].menu_function, feedback
+        #if ENABLED(ULTIPANEL)
+          , screen_history[screen_history_depth].encoder_position
+        #endif
+      );
+    }
+    else
+      lcd_return_to_status();
   }
-}
 
-static void lcd_goto_previous_menu(bool feedback=false) {
-  if (menu_history_depth > 0) {
-    --menu_history_depth;
-    lcd_goto_menu(menu_history[menu_history_depth].menu_function, feedback
-      #if ENABLED(ULTIPANEL)
-        , menu_history[menu_history_depth].encoder_position
-      #endif
-    );
+  void lcd_ignore_click(bool b) {
+    ignore_click = b;
+    wait_for_unclick = false;
   }
-  else
-    lcd_return_to_status();
-}
+
+#endif // ULTIPANEL
 
 /**
  *
@@ -364,8 +373,11 @@ static void lcd_goto_previous_menu(bool feedback=false) {
  */
 
 static void lcd_status_screen() {
-  ENCODER_DIRECTION_NORMAL();
-  encoderRateMultiplierEnabled = false;
+
+  #if ENABLED(ULTIPANEL)
+    ENCODER_DIRECTION_NORMAL();
+    encoderRateMultiplierEnabled = false;
+  #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
     millis_t ms = millis();
@@ -421,10 +433,10 @@ static void lcd_status_screen() {
     }
 
     if (current_click) {
-      lcd_goto_menu(lcd_main_menu, true);
+      lcd_goto_screen(lcd_main_menu, true);
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
-        #if ENABLED(LCD_PROGRESS_BAR)
-          currentMenu == lcd_status_screen
+        #if ENABLED(LCD_PROGRESS_BAR) && ENABLED(ULTIPANEL)
+          currentScreen == lcd_status_screen
         #endif
       );
       #if ENABLED(FILAMENT_LCD_DISPLAY)
@@ -462,1561 +474,1565 @@ static void lcd_status_screen() {
 
 #if ENABLED(ULTIPANEL)
 
-inline void line_to_current(AxisEnum axis) {
-  #if ENABLED(DELTA)
-    calculate_delta(current_position);
-    planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
-  #else
-    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
-  #endif
-}
-
-#if ENABLED(SDSUPPORT)
-
-  static void lcd_sdcard_pause() {
-    card.pauseSDPrint();
-    print_job_timer.pause();
+  inline void line_to_current(AxisEnum axis) {
+    #if ENABLED(DELTA)
+      calculate_delta(current_position);
+      planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
+    #else // !DELTA
+      planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
+    #endif // !DELTA
   }
 
-  static void lcd_sdcard_resume() {
-    card.startFileprint();
-    print_job_timer.start();
-  }
+  #if ENABLED(SDSUPPORT)
 
-  static void lcd_sdcard_stop() {
-    stepper.quick_stop();
-    #if DISABLED(DELTA) && DISABLED(SCARA)
-      set_current_position_from_planner();
-    #endif
-    clear_command_queue();
-    card.sdprinting = false;
-    card.closefile();
-    print_job_timer.stop();
-    thermalManager.autotempShutdown();
-    cancel_heatup = true;
-    lcd_setstatus(MSG_PRINT_ABORTED, true);
-  }
+    static void lcd_sdcard_pause() {
+      card.pauseSDPrint();
+      print_job_timer.pause();
+    }
 
-#endif //SDSUPPORT
+    static void lcd_sdcard_resume() {
+      card.startFileprint();
+      print_job_timer.start();
+    }
 
-/**
- *
- * "Main" menu
- *
- */
+    static void lcd_sdcard_stop() {
+      stepper.quick_stop();
+      #if DISABLED(DELTA) && DISABLED(SCARA)
+        set_current_position_from_planner();
+      #endif // !DELTA && !SCARA
+      clear_command_queue();
+      card.sdprinting = false;
+      card.closefile();
+      print_job_timer.stop();
+      thermalManager.autotempShutdown();
+      cancel_heatup = true;
+      lcd_setstatus(MSG_PRINT_ABORTED, true);
+    }
 
-static void lcd_main_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_WATCH);
-  if (planner.movesplanned() || IS_SD_PRINTING) {
-    MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
-  }
-  else {
-    MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
-    #if ENABLED(DELTA_CALIBRATION_MENU)
-      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
-    #endif
-  }
-  MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
+  #endif //SDSUPPORT
 
-  #if ENABLED(SDSUPPORT)
-    if (card.cardOK) {
-      if (card.isFileOpen()) {
-        if (card.sdprinting)
-          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
-        else
-          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
-        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+  /**
+   *
+   * "Main" menu
+   *
+   */
+
+  static void lcd_main_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_WATCH);
+    if (planner.movesplanned() || IS_SD_PRINTING) {
+      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+    }
+    else {
+      MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
+      #if ENABLED(DELTA_CALIBRATION_MENU)
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
+      #endif
+    }
+    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
+
+    #if ENABLED(SDSUPPORT)
+      if (card.cardOK) {
+        if (card.isFileOpen()) {
+          if (card.sdprinting)
+            MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
+          else
+            MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
+          MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+        }
+        else {
+          MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
+          #if !PIN_EXISTS(SD_DETECT)
+            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+          #endif
+        }
       }
       else {
-        MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
+        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
         #if !PIN_EXISTS(SD_DETECT)
-          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+          MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
-    }
-    else {
-      MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
-      #if !PIN_EXISTS(SD_DETECT)
-        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
-      #endif
-    }
-  #endif //SDSUPPORT
-
-  END_MENU();
-}
-
-/**
- *
- * "Tune" submenu items
- *
- */
-
-/**
- * Set the home offset based on the current_position
- */
-void lcd_set_home_offsets() {
-  // M428 Command
-  enqueue_and_echo_commands_P(PSTR("M428"));
-  lcd_return_to_status();
-}
+    #endif //SDSUPPORT
 
-#if ENABLED(BABYSTEPPING)
-
-  int babysteps_done = 0;
-
-  static void _lcd_babystep(const AxisEnum axis, const char* msg) {
-    ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition) {
-      int distance = (int32_t)encoderPosition * BABYSTEP_MULTIPLICATOR;
-      encoderPosition = 0;
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      thermalManager.babystep_axis(axis, distance);
-      babysteps_done += distance;
-    }
-    if (lcdDrawUpdate) lcd_implementation_drawedit(msg, itostr3sign(babysteps_done));
-    if (LCD_CLICKED) lcd_goto_previous_menu(true);
+    END_MENU();
   }
 
-  #if ENABLED(BABYSTEP_XY)
-    static void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
-    static void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
-    static void lcd_babystep_x() { babysteps_done = 0; lcd_goto_menu(_lcd_babystep_x); }
-    static void lcd_babystep_y() { babysteps_done = 0; lcd_goto_menu(_lcd_babystep_y); }
-  #endif
-  static void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }
-  static void lcd_babystep_z() { babysteps_done = 0; lcd_goto_menu(_lcd_babystep_z); }
-
-#endif //BABYSTEPPING
+  /**
+   *
+   * "Tune" submenu items
+   *
+   */
 
-/**
- * Watch temperature callbacks
- */
-#if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
-  #if TEMP_SENSOR_0 != 0
-    void watch_temp_callback_E0() { thermalManager.start_watching_heater(0); }
-  #endif
-  #if HOTENDS > 1 && TEMP_SENSOR_1 != 0
-    void watch_temp_callback_E1() { thermalManager.start_watching_heater(1); }
-  #endif // HOTENDS > 1
-  #if HOTENDS > 2 && TEMP_SENSOR_2 != 0
-    void watch_temp_callback_E2() { thermalManager.start_watching_heater(2); }
-  #endif // HOTENDS > 2
-  #if HOTENDS > 3 && TEMP_SENSOR_3 != 0
-    void watch_temp_callback_E3() { thermalManager.start_watching_heater(3); }
-  #endif // HOTENDS > 3
-#else
-  #if TEMP_SENSOR_0 != 0
-    void watch_temp_callback_E0() {}
-  #endif
-  #if HOTENDS > 1 && TEMP_SENSOR_1 != 0
-    void watch_temp_callback_E1() {}
-  #endif // HOTENDS > 1
-  #if HOTENDS > 2 && TEMP_SENSOR_2 != 0
-    void watch_temp_callback_E2() {}
-  #endif // HOTENDS > 2
-  #if HOTENDS > 3 && TEMP_SENSOR_3 != 0
-    void watch_temp_callback_E3() {}
-  #endif // HOTENDS > 3
-#endif
+  /**
+   * Set the home offset based on the current_position
+   */
+  void lcd_set_home_offsets() {
+    // M428 Command
+    enqueue_and_echo_commands_P(PSTR("M428"));
+    lcd_return_to_status();
+  }
 
-#if ENABLED(THERMAL_PROTECTION_BED) && WATCH_BED_TEMP_PERIOD > 0
-  #if TEMP_SENSOR_BED != 0
-    void watch_temp_callback_bed() { thermalManager.start_watching_bed(); }
-  #endif
-#else
-  #if TEMP_SENSOR_BED != 0
-    void watch_temp_callback_bed() {}
-  #endif
-#endif
+  #if ENABLED(BABYSTEPPING)
 
-/**
- *
- * "Tune" submenu
- *
- */
-static void lcd_tune_menu() {
-  START_MENU();
+    int babysteps_done = 0;
 
-  //
-  // ^ Main
-  //
-  MENU_ITEM(back, MSG_MAIN);
+    static void _lcd_babystep(const AxisEnum axis, const char* msg) {
+      ENCODER_DIRECTION_NORMAL();
+      if (encoderPosition) {
+        int distance = (int32_t)encoderPosition * BABYSTEP_MULTIPLICATOR;
+        encoderPosition = 0;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        thermalManager.babystep_axis(axis, distance);
+        babysteps_done += distance;
+      }
+      if (lcdDrawUpdate) lcd_implementation_drawedit(msg, itostr3sign(babysteps_done));
+      if (LCD_CLICKED) lcd_goto_previous_menu(true);
+    }
 
-  //
-  // Speed:
-  //
-  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999);
+    #if ENABLED(BABYSTEP_XY)
+      static void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
+      static void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
+      static void lcd_babystep_x() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_x); }
+      static void lcd_babystep_y() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_y); }
+    #endif
+    static void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }
+    static void lcd_babystep_z() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_z); }
 
-  // Manual bed leveling, Bed Z:
-  #if ENABLED(MANUAL_BED_LEVELING)
-    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-  #endif
+  #endif //BABYSTEPPING
 
-  //
-  // Nozzle:
-  // Nozzle [1-4]:
-  //
-  #if HOTENDS == 1
+  /**
+   * Watch temperature callbacks
+   */
+  #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
     #if TEMP_SENSOR_0 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      void watch_temp_callback_E0() { thermalManager.start_watching_heater(0); }
     #endif
-  #else //HOTENDS > 1
+    #if HOTENDS > 1 && TEMP_SENSOR_1 != 0
+      void watch_temp_callback_E1() { thermalManager.start_watching_heater(1); }
+    #endif // HOTENDS > 1
+    #if HOTENDS > 2 && TEMP_SENSOR_2 != 0
+      void watch_temp_callback_E2() { thermalManager.start_watching_heater(2); }
+    #endif // HOTENDS > 2
+    #if HOTENDS > 3 && TEMP_SENSOR_3 != 0
+      void watch_temp_callback_E3() { thermalManager.start_watching_heater(3); }
+    #endif // HOTENDS > 3
+  #else
     #if TEMP_SENSOR_0 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      void watch_temp_callback_E0() {}
     #endif
-    #if TEMP_SENSOR_1 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
-    #endif
-    #if HOTENDS > 2
-      #if TEMP_SENSOR_2 != 0
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-      #endif
-      #if HOTENDS > 3
-        #if TEMP_SENSOR_3 != 0
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-        #endif
-      #endif // HOTENDS > 3
+    #if HOTENDS > 1 && TEMP_SENSOR_1 != 0
+      void watch_temp_callback_E1() {}
+    #endif // HOTENDS > 1
+    #if HOTENDS > 2 && TEMP_SENSOR_2 != 0
+      void watch_temp_callback_E2() {}
     #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
-
-  //
-  // Bed:
-  //
-  #if TEMP_SENSOR_BED != 0
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+    #if HOTENDS > 3 && TEMP_SENSOR_3 != 0
+      void watch_temp_callback_E3() {}
+    #endif // HOTENDS > 3
   #endif
 
-  //
-  // Fan Speed:
-  //
-  #if FAN_COUNT > 0
-    #if HAS_FAN0
-      #if FAN_COUNT > 1
-        #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
-      #else
-        #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
-      #endif
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
-    #endif
-    #if HAS_FAN1
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+  #if ENABLED(THERMAL_PROTECTION_BED) && WATCH_BED_TEMP_PERIOD > 0
+    #if TEMP_SENSOR_BED != 0
+      void watch_temp_callback_bed() { thermalManager.start_watching_bed(); }
     #endif
-    #if HAS_FAN2
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+  #else
+    #if TEMP_SENSOR_BED != 0
+      void watch_temp_callback_bed() {}
     #endif
-  #endif // FAN_COUNT > 0
-
-  //
-  // Flow:
-  // Flow 1:
-  // Flow 2:
-  // Flow 3:
-  // Flow 4:
-  //
-  #if EXTRUDERS == 1
-    MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[0], 10, 999);
-  #else // EXTRUDERS > 1
-    MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[active_extruder], 10, 999);
-    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &extruder_multiplier[0], 10, 999);
-    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &extruder_multiplier[1], 10, 999);
-    #if EXTRUDERS > 2
-      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &extruder_multiplier[2], 10, 999);
-      #if EXTRUDERS > 3
-        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &extruder_multiplier[3], 10, 999);
-      #endif //EXTRUDERS > 3
-    #endif //EXTRUDERS > 2
-  #endif //EXTRUDERS > 1
-
-  //
-  // Babystep X:
-  // Babystep Y:
-  // Babystep Z:
-  //
-  #if ENABLED(BABYSTEPPING)
-    #if ENABLED(BABYSTEP_XY)
-      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
-      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
-    #endif //BABYSTEP_XY
-    MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
-  #endif
-
-  //
-  // Change filament
-  //
-  #if ENABLED(FILAMENTCHANGEENABLE)
-     MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));
   #endif
 
-  END_MENU();
-}
+  /**
+   *
+   * "Tune" submenu
+   *
+   */
+  static void lcd_tune_menu() {
+    START_MENU();
 
-/**
- *
- * "Prepare" submenu items
- *
- */
-void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {
-  if (temph > 0) thermalManager.setTargetHotend(temph, endnum);
-  #if TEMP_SENSOR_BED != 0
-    thermalManager.setTargetBed(tempb);
-  #else
-    UNUSED(tempb);
-  #endif
-  #if FAN_COUNT > 0
-    #if FAN_COUNT > 1
-      fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
-    #else
-      fanSpeeds[0] = fan;
-    #endif
-  #else
-    UNUSED(fan);
-  #endif
-  lcd_return_to_status();
-}
+    //
+    // ^ Main
+    //
+    MENU_ITEM(back, MSG_MAIN);
 
-#if TEMP_SENSOR_0 != 0
-  void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-  void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
-#endif
+    //
+    // Speed:
+    //
+    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999);
 
-#if HOTENDS > 1
-  void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-  void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
-  #if HOTENDS > 2
-    void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-    void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
-    #if HOTENDS > 3
-      void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-      void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+    // Manual bed leveling, Bed Z:
+    #if ENABLED(MANUAL_BED_LEVELING)
+      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
-  #endif
 
-  void lcd_preheat_pla0123() {
-    #if HOTENDS > 1
-      thermalManager.setTargetHotend(plaPreheatHotendTemp, 1);
-      #if HOTENDS > 2
-        thermalManager.setTargetHotend(plaPreheatHotendTemp, 2);
-        #if HOTENDS > 3
-          thermalManager.setTargetHotend(plaPreheatHotendTemp, 3);
-        #endif
+    //
+    // Nozzle:
+    // Nozzle [1-4]:
+    //
+    #if HOTENDS == 1
+      #if TEMP_SENSOR_0 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      #endif
+    #else //HOTENDS > 1
+      #if TEMP_SENSOR_0 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      #endif
+      #if TEMP_SENSOR_1 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #endif
-    #endif
-    lcd_preheat_pla0();
-  }
-  void lcd_preheat_abs0123() {
-    #if HOTENDS > 1
-      thermalManager.setTargetHotend(absPreheatHotendTemp, 1);
       #if HOTENDS > 2
-        thermalManager.setTargetHotend(absPreheatHotendTemp, 2);
-        #if HOTENDS > 3
-          thermalManager.setTargetHotend(absPreheatHotendTemp, 3);
+        #if TEMP_SENSOR_2 != 0
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
         #endif
-      #endif
-    #endif
-    lcd_preheat_abs0();
-  }
-
-#endif // HOTENDS > 1
+        #if HOTENDS > 3
+          #if TEMP_SENSOR_3 != 0
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+          #endif
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
 
-#if TEMP_SENSOR_BED != 0
-  void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-  void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }
-#endif
+    //
+    // Bed:
+    //
+    #if TEMP_SENSOR_BED != 0
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+    #endif
 
-#if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)
-
-  static void lcd_preheat_pla_menu() {
-    START_MENU();
-    MENU_ITEM(back, MSG_PREPARE);
-    #if HOTENDS == 1
-      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
-    #else
-      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);
-      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);
-      #if HOTENDS > 2
-        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);
-        #if HOTENDS > 3
-          MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);
+    //
+    // Fan Speed:
+    //
+    #if FAN_COUNT > 0
+      #if HAS_FAN0
+        #if FAN_COUNT > 1
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
+        #else
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
         #endif
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
+      #endif
+      #if HAS_FAN1
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
       #endif
-      MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
+      #if HAS_FAN2
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+      #endif
+    #endif // FAN_COUNT > 0
+
+    //
+    // Flow:
+    // Flow 1:
+    // Flow 2:
+    // Flow 3:
+    // Flow 4:
+    //
+    #if EXTRUDERS == 1
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[0], 10, 999);
+    #else // EXTRUDERS > 1
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[active_extruder], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &extruder_multiplier[0], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &extruder_multiplier[1], 10, 999);
+      #if EXTRUDERS > 2
+        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &extruder_multiplier[2], 10, 999);
+        #if EXTRUDERS > 3
+          MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &extruder_multiplier[3], 10, 999);
+        #endif //EXTRUDERS > 3
+      #endif //EXTRUDERS > 2
+    #endif //EXTRUDERS > 1
+
+    //
+    // Babystep X:
+    // Babystep Y:
+    // Babystep Z:
+    //
+    #if ENABLED(BABYSTEPPING)
+      #if ENABLED(BABYSTEP_XY)
+        MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
+        MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
+      #endif //BABYSTEP_XY
+      MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
     #endif
-    #if TEMP_SENSOR_BED != 0
-      MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);
+
+    //
+    // Change filament
+    //
+    #if ENABLED(FILAMENTCHANGEENABLE)
+       MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));
     #endif
+
     END_MENU();
   }
 
-  static void lcd_preheat_abs_menu() {
-    START_MENU();
-    MENU_ITEM(back, MSG_PREPARE);
-    #if HOTENDS == 1
-      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+  /**
+   *
+   * "Prepare" submenu items
+   *
+   */
+  void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {
+    if (temph > 0) thermalManager.setTargetHotend(temph, endnum);
+    #if TEMP_SENSOR_BED != 0
+      thermalManager.setTargetBed(tempb);
     #else
-      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);
-      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);
-      #if HOTENDS > 2
-        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);
-        #if HOTENDS > 3
-          MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);
-        #endif
-      #endif
-      MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
+      UNUSED(tempb);
     #endif
-    #if TEMP_SENSOR_BED != 0
-      MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);
+    #if FAN_COUNT > 0
+      #if FAN_COUNT > 1
+        fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
+      #else
+        fanSpeeds[0] = fan;
+      #endif
+    #else
+      UNUSED(fan);
     #endif
-    END_MENU();
+    lcd_return_to_status();
   }
 
-#endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_BED)
-
-void lcd_cooldown() {
-  #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+  #if TEMP_SENSOR_0 != 0
+    void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+    void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
   #endif
-  thermalManager.disable_all_heaters();
-  lcd_return_to_status();
-}
 
-#if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+  #if HOTENDS > 1
+    void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+    void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+    #if HOTENDS > 2
+      void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+      void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+      #if HOTENDS > 3
+        void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+        void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+      #endif
+    #endif
 
-  static void lcd_autostart_sd() {
-    card.autostart_index = 0;
-    card.setroot();
-    card.checkautostart(true);
-  }
+    void lcd_preheat_pla0123() {
+      #if HOTENDS > 1
+        thermalManager.setTargetHotend(plaPreheatHotendTemp, 1);
+        #if HOTENDS > 2
+          thermalManager.setTargetHotend(plaPreheatHotendTemp, 2);
+          #if HOTENDS > 3
+            thermalManager.setTargetHotend(plaPreheatHotendTemp, 3);
+          #endif
+        #endif
+      #endif
+      lcd_preheat_pla0();
+    }
+    void lcd_preheat_abs0123() {
+      #if HOTENDS > 1
+        thermalManager.setTargetHotend(absPreheatHotendTemp, 1);
+        #if HOTENDS > 2
+          thermalManager.setTargetHotend(absPreheatHotendTemp, 2);
+          #if HOTENDS > 3
+            thermalManager.setTargetHotend(absPreheatHotendTemp, 3);
+          #endif
+        #endif
+      #endif
+      lcd_preheat_abs0();
+    }
 
-#endif
+  #endif // HOTENDS > 1
 
-#if ENABLED(MANUAL_BED_LEVELING)
+  #if TEMP_SENSOR_BED != 0
+    void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+    void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }
+  #endif
 
-  /**
-   *
-   * "Prepare" > "Bed Leveling" handlers
-   *
-   */
+  #if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)
 
-  static uint8_t _lcd_level_bed_position;
+    static void lcd_preheat_pla_menu() {
+      START_MENU();
+      MENU_ITEM(back, MSG_PREPARE);
+      #if HOTENDS == 1
+        MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);
+        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);
+        #if HOTENDS > 2
+          MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);
+          #if HOTENDS > 3
+            MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);
+          #endif
+        #endif
+        MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
+      #endif
+      #if TEMP_SENSOR_BED != 0
+        MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);
+      #endif
+      END_MENU();
+    }
 
-  // Utility to go to the next mesh point
-  // A raise is added between points if MIN_Z_HEIGHT_FOR_HOMING is in use
-  // Note: During Manual Bed Leveling the homed Z position is MESH_HOME_SEARCH_Z
-  // Z position will be restored with the final action, a G28
-  inline void _mbl_goto_xy(float x, float y) {
-    current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
-      #if MIN_Z_HEIGHT_FOR_HOMING > 0
-        + MIN_Z_HEIGHT_FOR_HOMING
+    static void lcd_preheat_abs_menu() {
+      START_MENU();
+      MENU_ITEM(back, MSG_PREPARE);
+      #if HOTENDS == 1
+        MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);
+        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);
+        #if HOTENDS > 2
+          MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);
+          #if HOTENDS > 3
+            MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);
+          #endif
+        #endif
+        MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
       #endif
-    ;
-    line_to_current(Z_AXIS);
-    current_position[X_AXIS] = x + home_offset[X_AXIS];
-    current_position[Y_AXIS] = y + home_offset[Y_AXIS];
-    line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
-    #if MIN_Z_HEIGHT_FOR_HOMING > 0
-      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-      line_to_current(Z_AXIS);
+      #if TEMP_SENSOR_BED != 0
+        MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);
+      #endif
+      END_MENU();
+    }
+
+  #endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_BED)
+
+  void lcd_cooldown() {
+    #if FAN_COUNT > 0
+      for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
     #endif
-    stepper.synchronize();
+    thermalManager.disable_all_heaters();
+    lcd_return_to_status();
   }
 
-  static void _lcd_level_goto_next_point();
+  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
-  static void _lcd_level_bed_done() {
-    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_DONE));
-    lcdDrawUpdate =
-      #if ENABLED(DOGLCD)
-        LCDVIEW_CALL_REDRAW_NEXT
-      #else
-        LCDVIEW_CALL_NO_REDRAW
-      #endif
-    ;
-  }
+    static void lcd_autostart_sd() {
+      card.autostart_index = 0;
+      card.setroot();
+      card.checkautostart(true);
+    }
 
-  /**
-   * Step 7: Get the Z coordinate, then goto next point or exit
-   */
-  static void _lcd_level_bed_get_z() {
-    ENCODER_DIRECTION_NORMAL();
+  #endif
 
-    // Encoder wheel adjusts the Z position
-    if (encoderPosition) {
-      refresh_cmd_timeout();
-      current_position[Z_AXIS] += float((int32_t)encoderPosition) * (MBL_Z_STEP);
-      NOLESS(current_position[Z_AXIS], 0);
-      NOMORE(current_position[Z_AXIS], MESH_HOME_SEARCH_Z * 2);
+  #if ENABLED(MANUAL_BED_LEVELING)
+
+    /**
+     *
+     * "Prepare" > "Bed Leveling" handlers
+     *
+     */
+
+    static uint8_t _lcd_level_bed_position;
+
+    // Utility to go to the next mesh point
+    // A raise is added between points if MIN_Z_HEIGHT_FOR_HOMING is in use
+    // Note: During Manual Bed Leveling the homed Z position is MESH_HOME_SEARCH_Z
+    // Z position will be restored with the final action, a G28
+    inline void _mbl_goto_xy(float x, float y) {
+      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
+        #if MIN_Z_HEIGHT_FOR_HOMING > 0
+          + MIN_Z_HEIGHT_FOR_HOMING
+        #endif
+      ;
       line_to_current(Z_AXIS);
+      current_position[X_AXIS] = x + home_offset[X_AXIS];
+      current_position[Y_AXIS] = y + home_offset[Y_AXIS];
+      line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
+      #if MIN_Z_HEIGHT_FOR_HOMING > 0
+        current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
+        line_to_current(Z_AXIS);
+      #endif
+      stepper.synchronize();
+    }
+
+    static void _lcd_level_goto_next_point();
+
+    static void _lcd_level_bed_done() {
+      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_DONE));
       lcdDrawUpdate =
         #if ENABLED(DOGLCD)
           LCDVIEW_CALL_REDRAW_NEXT
         #else
-          LCDVIEW_REDRAW_NOW
+          LCDVIEW_CALL_NO_REDRAW
         #endif
       ;
-      encoderPosition = 0;
     }
 
-    static bool debounce_click = false;
-    if (LCD_CLICKED) {
-      if (!debounce_click) {
-        debounce_click = true; // ignore multiple "clicks" in a row
-        mbl.set_zigzag_z(_lcd_level_bed_position++, current_position[Z_AXIS]);
-        if (_lcd_level_bed_position == (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
-          lcd_goto_menu(_lcd_level_bed_done, true);
-
-          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
-            #if MIN_Z_HEIGHT_FOR_HOMING > 0
-              + MIN_Z_HEIGHT_FOR_HOMING
-            #endif
-          ;
-          line_to_current(Z_AXIS);
-          stepper.synchronize();
-
-          mbl.set_has_mesh(true);
-          enqueue_and_echo_commands_P(PSTR("G28"));
-          lcd_return_to_status();
-          //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
-          #if HAS_BUZZER
-            buzzer.tone(200, 659);
-            buzzer.tone(200, 698);
+    /**
+     * Step 7: Get the Z coordinate, then goto next point or exit
+     */
+    static void _lcd_level_bed_get_z() {
+      ENCODER_DIRECTION_NORMAL();
+
+      // Encoder wheel adjusts the Z position
+      if (encoderPosition) {
+        refresh_cmd_timeout();
+        current_position[Z_AXIS] += float((int32_t)encoderPosition) * (MBL_Z_STEP);
+        NOLESS(current_position[Z_AXIS], 0);
+        NOMORE(current_position[Z_AXIS], MESH_HOME_SEARCH_Z * 2);
+        line_to_current(Z_AXIS);
+        lcdDrawUpdate =
+          #if ENABLED(DOGLCD)
+            LCDVIEW_CALL_REDRAW_NEXT
+          #else
+            LCDVIEW_REDRAW_NOW
           #endif
-        }
-        else {
-          lcd_goto_menu(_lcd_level_goto_next_point, true);
+        ;
+        encoderPosition = 0;
+      }
+
+      static bool debounce_click = false;
+      if (LCD_CLICKED) {
+        if (!debounce_click) {
+          debounce_click = true; // ignore multiple "clicks" in a row
+          mbl.set_zigzag_z(_lcd_level_bed_position++, current_position[Z_AXIS]);
+          if (_lcd_level_bed_position == (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
+            lcd_goto_screen(_lcd_level_bed_done, true);
+
+            current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
+              #if MIN_Z_HEIGHT_FOR_HOMING > 0
+                + MIN_Z_HEIGHT_FOR_HOMING
+              #endif
+            ;
+            line_to_current(Z_AXIS);
+            stepper.synchronize();
+
+            mbl.set_has_mesh(true);
+            enqueue_and_echo_commands_P(PSTR("G28"));
+            lcd_return_to_status();
+            //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
+            #if HAS_BUZZER
+              buzzer.tone(200, 659);
+              buzzer.tone(200, 698);
+            #endif
+          }
+          else {
+            lcd_goto_screen(_lcd_level_goto_next_point, true);
+          }
         }
       }
-    }
-    else {
-      debounce_click = false;
-    }
+      else {
+        debounce_click = false;
+      }
+
+      // Update on first display, then only on updates to Z position
+      // Show message above on clicks instead
+      if (lcdDrawUpdate) {
+        float v = current_position[Z_AXIS] - MESH_HOME_SEARCH_Z;
+        lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001 : 0.0001), '+'));
+      }
 
-    // Update on first display, then only on updates to Z position
-    // Show message above on clicks instead
-    if (lcdDrawUpdate) {
-      float v = current_position[Z_AXIS] - MESH_HOME_SEARCH_Z;
-      lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001 : 0.0001), '+'));
     }
 
-  }
+    /**
+     * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
+     */
+    static void _lcd_level_bed_moving() {
+      if (lcdDrawUpdate) {
+        char msg[10];
+        sprintf_P(msg, PSTR("%i / %u"), (int)(_lcd_level_bed_position + 1), (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS));
+        lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+      }
 
-  /**
-   * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
-   */
-  static void _lcd_level_bed_moving() {
-    if (lcdDrawUpdate) {
-      char msg[10];
-      sprintf_P(msg, PSTR("%i / %u"), (int)(_lcd_level_bed_position + 1), (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS));
-      lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+      lcdDrawUpdate =
+        #if ENABLED(DOGLCD)
+          LCDVIEW_CALL_REDRAW_NEXT
+        #else
+          LCDVIEW_CALL_NO_REDRAW
+        #endif
+      ;
     }
 
-    lcdDrawUpdate =
-      #if ENABLED(DOGLCD)
-        LCDVIEW_CALL_REDRAW_NEXT
-      #else
-        LCDVIEW_CALL_NO_REDRAW
-      #endif
-    ;
-  }
+    /**
+     * Step 5: Initiate a move to the next point
+     */
+    static void _lcd_level_goto_next_point() {
+      // Set the menu to display ahead of blocking call
+      lcd_goto_screen(_lcd_level_bed_moving);
 
-  /**
-   * Step 5: Initiate a move to the next point
-   */
-  static void _lcd_level_goto_next_point() {
-    // Set the menu to display ahead of blocking call
-    lcd_goto_menu(_lcd_level_bed_moving);
+      // _mbl_goto_xy runs the menu loop until the move is done
+      int8_t px, py;
+      mbl.zigzag(_lcd_level_bed_position, px, py);
+      _mbl_goto_xy(mbl.get_probe_x(px), mbl.get_probe_y(py));
 
-    // _mbl_goto_xy runs the menu loop until the move is done
-    int8_t px, py;
-    mbl.zigzag(_lcd_level_bed_position, px, py);
-    _mbl_goto_xy(mbl.get_probe_x(px), mbl.get_probe_y(py));
+      // After the blocking function returns, change menus
+      lcd_goto_screen(_lcd_level_bed_get_z);
+    }
 
-    // After the blocking function returns, change menus
-    lcd_goto_menu(_lcd_level_bed_get_z);
-  }
+    /**
+     * Step 4: Display "Click to Begin", wait for click
+     *         Move to the first probe position
+     */
+    static void _lcd_level_bed_homing_done() {
+      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
+      if (LCD_CLICKED) {
+        _lcd_level_bed_position = 0;
+        current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
+        planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        lcd_goto_screen(_lcd_level_goto_next_point, true);
+      }
+    }
 
-  /**
-   * Step 4: Display "Click to Begin", wait for click
-   *         Move to the first probe position
-   */
-  static void _lcd_level_bed_homing_done() {
-    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-    if (LCD_CLICKED) {
-      _lcd_level_bed_position = 0;
-      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-      planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      lcd_goto_menu(_lcd_level_goto_next_point, true);
+    /**
+     * Step 3: Display "Homing XYZ" - Wait for homing to finish
+     */
+    static void _lcd_level_bed_homing() {
+      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
+      lcdDrawUpdate =
+        #if ENABLED(DOGLCD)
+          LCDVIEW_CALL_REDRAW_NEXT
+        #else
+          LCDVIEW_CALL_NO_REDRAW
+        #endif
+      ;
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        lcd_goto_screen(_lcd_level_bed_homing_done);
     }
-  }
 
-  /**
-   * Step 3: Display "Homing XYZ" - Wait for homing to finish
-   */
-  static void _lcd_level_bed_homing() {
-    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
-    lcdDrawUpdate =
-      #if ENABLED(DOGLCD)
-        LCDVIEW_CALL_REDRAW_NEXT
-      #else
-        LCDVIEW_CALL_NO_REDRAW
-      #endif
-    ;
-    if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-      lcd_goto_menu(_lcd_level_bed_homing_done);
-  }
+    /**
+     * Step 2: Continue Bed Leveling...
+     */
+    static void _lcd_level_bed_continue() {
+      defer_return_to_status = true;
+      axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
+      mbl.reset();
+      enqueue_and_echo_commands_P(PSTR("G28"));
+      lcd_goto_screen(_lcd_level_bed_homing);
+    }
 
-  /**
-   * Step 2: Continue Bed Leveling...
-   */
-  static void _lcd_level_bed_continue() {
-    defer_return_to_status = true;
-    axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
-    mbl.reset();
-    enqueue_and_echo_commands_P(PSTR("G28"));
-    lcd_goto_menu(_lcd_level_bed_homing);
-  }
+    /**
+     * Step 1: MBL entry-point: "Cancel" or "Level Bed"
+     */
+    static void lcd_level_bed() {
+      START_MENU();
+      MENU_ITEM(back, MSG_LEVEL_BED_CANCEL);
+      MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+      END_MENU();
+    }
+
+  #endif  // MANUAL_BED_LEVELING
 
   /**
-   * Step 1: MBL entry-point: "Cancel" or "Level Bed"
+   *
+   * "Prepare" submenu
+   *
    */
-  static void lcd_level_bed() {
+
+  static void lcd_prepare_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_LEVEL_BED_CANCEL);
-    MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
-    END_MENU();
-  }
 
-#endif  // MANUAL_BED_LEVELING
+    //
+    // ^ Main
+    //
+    MENU_ITEM(back, MSG_MAIN);
 
-/**
- *
- * "Prepare" submenu
- *
- */
+    //
+    // Auto Home
+    //
+    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
+      MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
+      MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
+      MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
+    #endif
 
-static void lcd_prepare_menu() {
-  START_MENU();
-
-  //
-  // ^ Main
-  //
-  MENU_ITEM(back, MSG_MAIN);
-
-  //
-  // Auto Home
-  //
-  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-  #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
-    MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
-    MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
-    MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
-  #endif
+    //
+    // Set Home Offsets
+    //
+    MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
+    //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
+
+    //
+    // Level Bed
+    //
+    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+      MENU_ITEM(gcode, MSG_LEVEL_BED,
+        axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
+      );
+    #elif ENABLED(MANUAL_BED_LEVELING)
+      MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
+    #endif
 
-  //
-  // Set Home Offsets
-  //
-  MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-  //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
-
-  //
-  // Level Bed
-  //
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    MENU_ITEM(gcode, MSG_LEVEL_BED,
-      axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
-    );
-  #elif ENABLED(MANUAL_BED_LEVELING)
-    MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
-  #endif
+    //
+    // Move Axis
+    //
+    MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
 
-  //
-  // Move Axis
-  //
-  MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
+    //
+    // Disable Steppers
+    //
+    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
-  //
-  // Disable Steppers
-  //
-  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
+    //
+    // Preheat PLA
+    // Preheat ABS
+    //
+    #if TEMP_SENSOR_0 != 0
+      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0
+        MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
+        MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
+        MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+      #endif
+    #endif
 
-  //
-  // Preheat PLA
-  // Preheat ABS
-  //
-  #if TEMP_SENSOR_0 != 0
-    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0
-      MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
-      MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
-    #else
-      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
-      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+    //
+    // Cooldown
+    //
+    MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+
+    //
+    // Switch power on/off
+    //
+    #if HAS_POWER_SWITCH
+      if (powersupply)
+        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
+      else
+        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
     #endif
-  #endif
 
-  //
-  // Cooldown
-  //
-  MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+    //
+    // Autostart
+    //
+    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+    #endif
 
-  //
-  // Switch power on/off
-  //
-  #if HAS_POWER_SWITCH
-    if (powersupply)
-      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
-    else
-      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
-  #endif
+    END_MENU();
+  }
 
-  //
-  // Autostart
-  //
-  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-    MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
-  #endif
+  #if ENABLED(DELTA_CALIBRATION_MENU)
 
-  END_MENU();
-}
+    static void lcd_delta_calibrate_menu() {
+      START_MENU();
+      MENU_ITEM(back, MSG_MAIN);
+      MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+      MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));
+      MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));
+      MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));
+      MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));
+      END_MENU();
+    }
 
-#if ENABLED(DELTA_CALIBRATION_MENU)
+  #endif // DELTA_CALIBRATION_MENU
 
-  static void lcd_delta_calibrate_menu() {
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN);
-    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));
-    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));
-    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));
-    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));
-    END_MENU();
+  /**
+   * If the most recent manual move hasn't been fed to the planner yet,
+   * and the planner can accept one, send immediately
+   */
+  inline void manage_manual_move() {
+    if (manual_move_axis != (int8_t)NO_AXIS && millis() >= manual_move_start_time && !planner.is_full()) {
+      #if ENABLED(DELTA)
+        calculate_delta(current_position);
+        planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, manual_move_e_index);
+      #else
+        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, manual_move_e_index);
+      #endif
+      manual_move_axis = (int8_t)NO_AXIS;
+    }
   }
 
-#endif // DELTA_CALIBRATION_MENU
-
-/**
- * If the most recent manual move hasn't been fed to the planner yet,
- * and the planner can accept one, send immediately
- */
-inline void manage_manual_move() {
-  if (manual_move_axis != (int8_t)NO_AXIS && millis() >= manual_move_start_time && !planner.is_full()) {
-    #if ENABLED(DELTA)
-      calculate_delta(current_position);
-      planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, active_extruder);
-    #else
-      planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, active_extruder);
+  /**
+   * Set a flag that lcd_update() should start a move
+   * to "current_position" after a short delay.
+   */
+  inline void manual_move_to_current(AxisEnum axis
+    #if EXTRUDERS > 1
+      , int8_t eindex=-1
+    #endif
+  ) {
+    #if EXTRUDERS > 1
+      if (axis == E_AXIS) manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
-    manual_move_axis = (int8_t)NO_AXIS;
+    manual_move_start_time = millis() + 500UL; // 1/2 second delay
+    manual_move_axis = (int8_t)axis;
   }
-}
 
-/**
- * Set a flag that lcd_update() should start a move
- * to "current_position" after a short delay.
- */
-inline void manual_move_to_current(AxisEnum axis) {
-  manual_move_start_time = millis() + 500UL; // 1/2 second delay
-  manual_move_axis = (int8_t)axis;
-}
+  /**
+   *
+   * "Prepare" > "Move Axis" submenu
+   *
+   */
 
-/**
- *
- * "Prepare" > "Move Axis" submenu
- *
- */
+  float move_menu_scale;
 
-float move_menu_scale;
-
-static void _lcd_move(const char* name, AxisEnum axis, float min, float max) {
-  ENCODER_DIRECTION_NORMAL();
-  if (encoderPosition) {
-    refresh_cmd_timeout();
-    current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
-    if (min_software_endstops) NOLESS(current_position[axis], min);
-    if (max_software_endstops) NOMORE(current_position[axis], max);
-    encoderPosition = 0;
-    manual_move_to_current(axis);
-    lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+  static void _lcd_move_xyz(const char* name, AxisEnum axis, float min, float max) {
+    ENCODER_DIRECTION_NORMAL();
+    if (encoderPosition) {
+      refresh_cmd_timeout();
+      current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
+      if (min_software_endstops) NOLESS(current_position[axis], min);
+      if (max_software_endstops) NOMORE(current_position[axis], max);
+      encoderPosition = 0;
+      manual_move_to_current(axis);
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+    if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr41sign(current_position[axis]));
+    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
-  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr41sign(current_position[axis]));
-  if (LCD_CLICKED) lcd_goto_previous_menu(true);
-}
-#if ENABLED(DELTA)
-  static float delta_clip_radius_2 =  (DELTA_PRINTABLE_RADIUS) * (DELTA_PRINTABLE_RADIUS);
-  static int delta_clip( float a ) { return sqrt(delta_clip_radius_2 - a*a); }
-  static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, max(sw_endstop_min[X_AXIS], -clip), min(sw_endstop_max[X_AXIS], clip)); }
-  static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, max(sw_endstop_min[Y_AXIS], -clip), min(sw_endstop_max[Y_AXIS], clip)); }
-#else
-  static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, sw_endstop_min[X_AXIS], sw_endstop_max[X_AXIS]); }
-  static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, sw_endstop_min[Y_AXIS], sw_endstop_max[Y_AXIS]); }
-#endif
-static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); }
-static void lcd_move_e(
-  #if EXTRUDERS > 1
-    uint8_t e
-  #endif
-) {
-  ENCODER_DIRECTION_NORMAL();
-  #if EXTRUDERS > 1
-    unsigned short original_active_extruder = active_extruder;
-    active_extruder = e;
+  #if ENABLED(DELTA)
+    static float delta_clip_radius_2 =  (DELTA_PRINTABLE_RADIUS) * (DELTA_PRINTABLE_RADIUS);
+    static int delta_clip( float a ) { return sqrt(delta_clip_radius_2 - a*a); }
+    static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS, max(sw_endstop_min[X_AXIS], -clip), min(sw_endstop_max[X_AXIS], clip)); }
+    static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS, max(sw_endstop_min[Y_AXIS], -clip), min(sw_endstop_max[Y_AXIS], clip)); }
+  #else
+    static void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS, sw_endstop_min[X_AXIS], sw_endstop_max[X_AXIS]); }
+    static void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS, sw_endstop_min[Y_AXIS], sw_endstop_max[Y_AXIS]); }
   #endif
-  if (encoderPosition) {
-    current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
-    encoderPosition = 0;
-    manual_move_to_current(E_AXIS);
-    lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-  }
-  if (lcdDrawUpdate) {
-    PGM_P pos_label;
-    #if EXTRUDERS == 1
-      pos_label = PSTR(MSG_MOVE_E);
-    #else
-      switch (e) {
-        case 0: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
-        case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
-        #if EXTRUDERS > 2
-          case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
-          #if EXTRUDERS > 3
-            case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
-          #endif //EXTRUDERS > 3
-        #endif //EXTRUDERS > 2
-      }
-    #endif //EXTRUDERS > 1
-    lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
+  static void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); }
+  static void lcd_move_e(
+    #if EXTRUDERS > 1
+      int8_t eindex = -1
+    #endif
+  ) {
+    ENCODER_DIRECTION_NORMAL();
+    if (encoderPosition) {
+      current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
+      encoderPosition = 0;
+      manual_move_to_current(E_AXIS
+        #if EXTRUDERS > 1
+          , eindex
+        #endif
+      );
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+    if (lcdDrawUpdate) {
+      PGM_P pos_label;
+      #if EXTRUDERS == 1
+        pos_label = PSTR(MSG_MOVE_E);
+      #else
+        switch (e) {
+          case 0: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
+          case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
+          #if EXTRUDERS > 2
+            case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
+            #if EXTRUDERS > 3
+              case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
+            #endif //EXTRUDERS > 3
+          #endif //EXTRUDERS > 2
+        }
+      #endif //EXTRUDERS > 1
+      lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
+    }
+    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
-  if (LCD_CLICKED) lcd_goto_previous_menu(true);
-  #if EXTRUDERS > 1
-    active_extruder = original_active_extruder;
-  #endif
-}
 
-#if EXTRUDERS > 1
-  static void lcd_move_e0() { lcd_move_e(0); }
-  static void lcd_move_e1() { lcd_move_e(1); }
-  #if EXTRUDERS > 2
-    static void lcd_move_e2() { lcd_move_e(2); }
-    #if EXTRUDERS > 3
-      static void lcd_move_e3() { lcd_move_e(3); }
+  #if EXTRUDERS > 1
+    static void lcd_move_e0() { lcd_move_e(0); }
+    static void lcd_move_e1() { lcd_move_e(1); }
+    #if EXTRUDERS > 2
+      static void lcd_move_e2() { lcd_move_e(2); }
+      #if EXTRUDERS > 3
+        static void lcd_move_e3() { lcd_move_e(3); }
+      #endif
     #endif
-  #endif
-#endif // EXTRUDERS > 1
+  #endif // EXTRUDERS > 1
 
-/**
- *
- * "Prepare" > "Move Xmm" > "Move XYZ" submenu
- *
- */
+  /**
+   *
+   * "Prepare" > "Move Xmm" > "Move XYZ" submenu
+   *
+   */
 
-#if ENABLED(DELTA) || ENABLED(SCARA)
-  #define _MOVE_XYZ_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-#else
-  #define _MOVE_XYZ_ALLOWED true
-#endif
+  #if ENABLED(DELTA) || ENABLED(SCARA)
+    #define _MOVE_XYZ_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+  #else
+    #define _MOVE_XYZ_ALLOWED true
+  #endif
 
-static void _lcd_move_menu_axis() {
-  START_MENU();
-  MENU_ITEM(back, MSG_MOVE_AXIS);
+  static void _lcd_move_menu_axis() {
+    START_MENU();
+    MENU_ITEM(back, MSG_MOVE_AXIS);
 
-  if (_MOVE_XYZ_ALLOWED) {
-    MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
-    MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
-  }
-  if (move_menu_scale < 10.0) {
-    if (_MOVE_XYZ_ALLOWED) MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
-    #if EXTRUDERS == 1
-      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
-    #else
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_e0);
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_e1);
-      #if EXTRUDERS > 2
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_e2);
-        #if EXTRUDERS > 3
-          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_e3);
+    if (_MOVE_XYZ_ALLOWED) {
+      MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
+      MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
+    }
+    if (move_menu_scale < 10.0) {
+      if (_MOVE_XYZ_ALLOWED) MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
+      #if EXTRUDERS == 1
+        MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
+      #else
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_e0);
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_e1);
+        #if EXTRUDERS > 2
+          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_e2);
+          #if EXTRUDERS > 3
+            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_e3);
+          #endif
         #endif
-      #endif
-    #endif // EXTRUDERS > 1
+      #endif // EXTRUDERS > 1
+    }
+    END_MENU();
   }
-  END_MENU();
-}
-
-static void lcd_move_menu_10mm() {
-  move_menu_scale = 10.0;
-  _lcd_move_menu_axis();
-}
-static void lcd_move_menu_1mm() {
-  move_menu_scale = 1.0;
-  _lcd_move_menu_axis();
-}
-static void lcd_move_menu_01mm() {
-  move_menu_scale = 0.1;
-  _lcd_move_menu_axis();
-}
-
-/**
- *
- * "Prepare" > "Move Axis" submenu
- *
- */
-
-static void lcd_move_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_PREPARE);
-
-  if (_MOVE_XYZ_ALLOWED)
-    MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
-
-  MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
-  MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
-  //TODO:X,Y,Z,E
-  END_MENU();
-}
 
-/**
- *
- * "Control" submenu
- *
- */
-
-static void lcd_control_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_MAIN);
-  MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
-  MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
-  MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
-
-  #if HAS_LCD_CONTRAST
-    //MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
-    MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);
-  #endif
-  #if ENABLED(FWRETRACT)
-    MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
-  #endif
-  #if ENABLED(EEPROM_SETTINGS)
-    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-    MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);
-  #endif
-  MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);
-  END_MENU();
-}
-
-/**
- *
- * "Temperature" submenu
- *
- */
+  static void lcd_move_menu_10mm() {
+    move_menu_scale = 10.0;
+    _lcd_move_menu_axis();
+  }
+  static void lcd_move_menu_1mm() {
+    move_menu_scale = 1.0;
+    _lcd_move_menu_axis();
+  }
+  static void lcd_move_menu_01mm() {
+    move_menu_scale = 0.1;
+    _lcd_move_menu_axis();
+  }
 
-#if ENABLED(PID_AUTOTUNE_MENU)
+  /**
+   *
+   * "Prepare" > "Move Axis" submenu
+   *
+   */
 
-  #if ENABLED(PIDTEMP)
-    int autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
-    const int heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP);
-  #endif
+  static void lcd_move_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_PREPARE);
 
-  #if ENABLED(PIDTEMPBED)
-    int autotune_temp_bed = 70;
-  #endif
+    if (_MOVE_XYZ_ALLOWED)
+      MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
 
-  static void _lcd_autotune(int e) {
-    char cmd[30];
-    sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
-      #if HAS_PID_FOR_BOTH
-        e < 0 ? autotune_temp_bed : autotune_temp[e]
-      #elif ENABLED(PIDTEMPBED)
-        autotune_temp_bed
-      #else
-        autotune_temp[e]
-      #endif
-    );
-    enqueue_and_echo_command(cmd);
+    MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
+    MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
+    //TODO:X,Y,Z,E
+    END_MENU();
   }
 
-#endif //PID_AUTOTUNE_MENU
+  /**
+   *
+   * "Control" submenu
+   *
+   */
 
-#if ENABLED(PIDTEMP)
+  static void lcd_control_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_MAIN);
+    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
+    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
+    MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
 
-  // Helpers for editing PID Ki & Kd values
-  // grab the PID value out of the temp variable; scale it; then update the PID driver
-  void copy_and_scalePID_i(int e) {
-    #if DISABLED(PID_PARAMS_PER_HOTEND)
-      UNUSED(e);
+    #if HAS_LCD_CONTRAST
+      //MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
+      MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);
     #endif
-    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
-    thermalManager.updatePID();
-  }
-  void copy_and_scalePID_d(int e) {
-    #if DISABLED(PID_PARAMS_PER_HOTEND)
-      UNUSED(e);
+    #if ENABLED(FWRETRACT)
+      MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
-    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
-    thermalManager.updatePID();
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+      MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);
+    #endif
+    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);
+    END_MENU();
   }
-  #define _PIDTEMP_BASE_FUNCTIONS(eindex) \
-    void copy_and_scalePID_i_E ## eindex() { copy_and_scalePID_i(eindex); } \
-    void copy_and_scalePID_d_E ## eindex() { copy_and_scalePID_d(eindex); }
-
-  #if ENABLED(PID_AUTOTUNE_MENU)
-    #define _PIDTEMP_FUNCTIONS(eindex) \
-      _PIDTEMP_BASE_FUNCTIONS(eindex); \
-      void lcd_autotune_callback_E ## eindex() { _lcd_autotune(eindex); }
-  #else
-    #define _PIDTEMP_FUNCTIONS(eindex) _PIDTEMP_BASE_FUNCTIONS(eindex)
-  #endif
 
-  _PIDTEMP_FUNCTIONS(0);
-  #if ENABLED(PID_PARAMS_PER_HOTEND)
-    #if HOTENDS > 1
-      _PIDTEMP_FUNCTIONS(1);
-      #if HOTENDS > 2
-        _PIDTEMP_FUNCTIONS(2);
-        #if HOTENDS > 3
-          _PIDTEMP_FUNCTIONS(3);
-        #endif //HOTENDS > 3
-      #endif //HOTENDS > 2
-    #endif //HOTENDS > 1
-  #endif //PID_PARAMS_PER_HOTEND
+  /**
+   *
+   * "Temperature" submenu
+   *
+   */
 
-#endif //PIDTEMP
+  #if ENABLED(PID_AUTOTUNE_MENU)
 
-/**
- *
- * "Control" > "Temperature" submenu
- *
- */
-static void lcd_control_temperature_menu() {
-  START_MENU();
-
-  //
-  // ^ Control
-  //
-  MENU_ITEM(back, MSG_CONTROL);
-
-  //
-  // Nozzle:
-  // Nozzle [1-4]:
-  //
-  #if HOTENDS == 1
-    #if TEMP_SENSOR_0 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-    #endif
-  #else //HOTENDS > 1
-    #if TEMP_SENSOR_0 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+    #if ENABLED(PIDTEMP)
+      int autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
+      const int heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP);
     #endif
-    #if TEMP_SENSOR_1 != 0
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+
+    #if ENABLED(PIDTEMPBED)
+      int autotune_temp_bed = 70;
     #endif
-    #if HOTENDS > 2
-      #if TEMP_SENSOR_2 != 0
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-      #endif
-      #if HOTENDS > 3
-        #if TEMP_SENSOR_3 != 0
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-        #endif
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
 
-  //
-  // Bed:
-  //
-  #if TEMP_SENSOR_BED != 0
-    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15);
-  #endif
+    static void _lcd_autotune(int e) {
+      char cmd[30];
+      sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
+        #if HAS_PID_FOR_BOTH
+          e < 0 ? autotune_temp_bed : autotune_temp[e]
+        #elif ENABLED(PIDTEMPBED)
+          autotune_temp_bed
+        #else
+          autotune_temp[e]
+        #endif
+      );
+      enqueue_and_echo_command(cmd);
+    }
 
-  //
-  // Fan Speed:
-  //
-  #if FAN_COUNT > 0
-    #if HAS_FAN0
-      #if FAN_COUNT > 1
-        #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
-      #else
-        #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
-      #endif
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
-    #endif
-    #if HAS_FAN1
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
-    #endif
-    #if HAS_FAN2
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
-    #endif
-  #endif // FAN_COUNT > 0
-
-  //
-  // Autotemp, Min, Max, Fact
-  //
-  #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
-    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
-    MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
-    MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
-    MENU_ITEM_EDIT(float32, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
-  #endif
+  #endif //PID_AUTOTUNE_MENU
 
-  //
-  // PID-P, PID-I, PID-D, PID-C, PID Autotune
-  // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
-  // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
-  // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
-  // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
-  //
   #if ENABLED(PIDTEMP)
 
-    #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
-      raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
-      raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
-      MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
-
-    #if ENABLED(PID_ADD_EXTRUSION_RATE)
-      #define _PID_MENU_ITEMS(ELABEL, eindex) \
-        _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
-        MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
-    #else
-      #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
-    #endif
+    // Helpers for editing PID Ki & Kd values
+    // grab the PID value out of the temp variable; scale it; then update the PID driver
+    void copy_and_scalePID_i(int e) {
+      #if DISABLED(PID_PARAMS_PER_HOTEND)
+        UNUSED(e);
+      #endif
+      PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
+      thermalManager.updatePID();
+    }
+    void copy_and_scalePID_d(int e) {
+      #if DISABLED(PID_PARAMS_PER_HOTEND)
+        UNUSED(e);
+      #endif
+      PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
+      thermalManager.updatePID();
+    }
+    #define _PIDTEMP_BASE_FUNCTIONS(eindex) \
+      void copy_and_scalePID_i_E ## eindex() { copy_and_scalePID_i(eindex); } \
+      void copy_and_scalePID_d_E ## eindex() { copy_and_scalePID_d(eindex); }
 
     #if ENABLED(PID_AUTOTUNE_MENU)
-      #define PID_MENU_ITEMS(ELABEL, eindex) \
-        _PID_MENU_ITEMS(ELABEL, eindex); \
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
+      #define _PIDTEMP_FUNCTIONS(eindex) \
+        _PIDTEMP_BASE_FUNCTIONS(eindex); \
+        void lcd_autotune_callback_E ## eindex() { _lcd_autotune(eindex); }
     #else
-      #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
+      #define _PIDTEMP_FUNCTIONS(eindex) _PIDTEMP_BASE_FUNCTIONS(eindex)
     #endif
 
-    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-      PID_MENU_ITEMS(MSG_E1, 0);
-      PID_MENU_ITEMS(MSG_E2, 1);
-      #if HOTENDS > 2
-        PID_MENU_ITEMS(MSG_E3, 2);
-        #if HOTENDS > 3
-          PID_MENU_ITEMS(MSG_E4, 3);
-        #endif //HOTENDS > 3
-      #endif //HOTENDS > 2
-    #else //!PID_PARAMS_PER_HOTEND || HOTENDS == 1
-      PID_MENU_ITEMS("", 0);
-    #endif //!PID_PARAMS_PER_HOTEND || HOTENDS == 1
+    _PIDTEMP_FUNCTIONS(0);
+    #if ENABLED(PID_PARAMS_PER_HOTEND)
+      #if HOTENDS > 1
+        _PIDTEMP_FUNCTIONS(1);
+        #if HOTENDS > 2
+          _PIDTEMP_FUNCTIONS(2);
+          #if HOTENDS > 3
+            _PIDTEMP_FUNCTIONS(3);
+          #endif //HOTENDS > 3
+        #endif //HOTENDS > 2
+      #endif //HOTENDS > 1
+    #endif //PID_PARAMS_PER_HOTEND
 
   #endif //PIDTEMP
 
-  //
-  // Preheat PLA conf
-  //
-  MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
-
-  //
-  // Preheat ABS conf
-  //
-  MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
-  END_MENU();
-}
+  /**
+   *
+   * "Control" > "Temperature" submenu
+   *
+   */
+  static void lcd_control_temperature_menu() {
+    START_MENU();
 
-/**
- *
- * "Temperature" > "Preheat PLA conf" submenu
- *
- */
-static void lcd_control_temperature_preheat_pla_settings_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_TEMPERATURE);
-  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
-  #if TEMP_SENSOR_0 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
-  #endif
-  #if TEMP_SENSOR_BED != 0
-    MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
-  #endif
-  #if ENABLED(EEPROM_SETTINGS)
-    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-  #endif
-  END_MENU();
-}
+    //
+    // ^ Control
+    //
+    MENU_ITEM(back, MSG_CONTROL);
 
-/**
- *
- * "Temperature" > "Preheat ABS conf" submenu
- *
- */
-static void lcd_control_temperature_preheat_abs_settings_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_TEMPERATURE);
-  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
-  #if TEMP_SENSOR_0 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
-  #endif
-  #if TEMP_SENSOR_BED != 0
-    MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
-  #endif
-  #if ENABLED(EEPROM_SETTINGS)
-    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-  #endif
-  END_MENU();
-}
+    //
+    // Nozzle:
+    // Nozzle [1-4]:
+    //
+    #if HOTENDS == 1
+      #if TEMP_SENSOR_0 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      #endif
+    #else //HOTENDS > 1
+      #if TEMP_SENSOR_0 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      #endif
+      #if TEMP_SENSOR_1 != 0
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+      #endif
+      #if HOTENDS > 2
+        #if TEMP_SENSOR_2 != 0
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
+        #endif
+        #if HOTENDS > 3
+          #if TEMP_SENSOR_3 != 0
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+          #endif
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
 
-static void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
+    //
+    // Bed:
+    //
+    #if TEMP_SENSOR_BED != 0
+      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15);
+    #endif
 
-/**
- *
- * "Control" > "Motion" submenu
- *
- */
-static void lcd_control_motion_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_CONTROL);
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-  #endif
-  // Manual bed leveling, Bed Z:
-  #if ENABLED(MANUAL_BED_LEVELING)
-    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-  #endif
-  MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
-  MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &planner.max_xy_jerk, 1, 990);
-  #if ENABLED(DELTA)
-    MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_z_jerk, 1, 990);
-  #else
-    MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_z_jerk, 0.1, 990);
-  #endif
-  MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_e_jerk, 1, 990);
-  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate[X_AXIS], 1, 999);
-  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate[Y_AXIS], 1, 999);
-  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate[Z_AXIS], 1, 999);
-  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate[E_AXIS], 1, 999);
-  MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate, 0, 999);
-  MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate, 0, 999);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
-  MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
-  MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
-  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999);
-  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999);
-  #if ENABLED(DELTA)
-    MENU_ITEM_EDIT(float52, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
-  #else
-    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
-  #endif
-  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999);
-  #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
-  #endif
-  #if ENABLED(SCARA)
-    MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS], 0.5, 2);
-    MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS], 0.5, 2);
-  #endif
-  END_MENU();
-}
+    //
+    // Fan Speed:
+    //
+    #if FAN_COUNT > 0
+      #if HAS_FAN0
+        #if FAN_COUNT > 1
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
+        #else
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
+        #endif
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
+      #endif
+      #if HAS_FAN1
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+      #endif
+      #if HAS_FAN2
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+      #endif
+    #endif // FAN_COUNT > 0
+
+    //
+    // Autotemp, Min, Max, Fact
+    //
+    #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
+      MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
+      MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(float32, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
+    #endif
 
-/**
- *
- * "Control" > "Filament" submenu
- *
- */
-static void lcd_control_volumetric_menu() {
-  START_MENU();
-  MENU_ITEM(back, MSG_CONTROL);
+    //
+    // PID-P, PID-I, PID-D, PID-C, PID Autotune
+    // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
+    // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
+    // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
+    // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
+    //
+    #if ENABLED(PIDTEMP)
+
+      #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
+        raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
+        raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
+        MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
+
+      #if ENABLED(PID_ADD_EXTRUSION_RATE)
+        #define _PID_MENU_ITEMS(ELABEL, eindex) \
+          _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
+          MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
+      #else
+        #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
+      #endif
 
-  MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
+      #if ENABLED(PID_AUTOTUNE_MENU)
+        #define PID_MENU_ITEMS(ELABEL, eindex) \
+          _PID_MENU_ITEMS(ELABEL, eindex); \
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
+      #else
+        #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
+      #endif
 
-  if (volumetric_enabled) {
-    #if EXTRUDERS == 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
-    #else //EXTRUDERS > 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
-      #if EXTRUDERS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
-        #if EXTRUDERS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
-        #endif //EXTRUDERS > 3
-      #endif //EXTRUDERS > 2
-    #endif //EXTRUDERS > 1
+      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+        PID_MENU_ITEMS(MSG_E1, 0);
+        PID_MENU_ITEMS(MSG_E2, 1);
+        #if HOTENDS > 2
+          PID_MENU_ITEMS(MSG_E3, 2);
+          #if HOTENDS > 3
+            PID_MENU_ITEMS(MSG_E4, 3);
+          #endif //HOTENDS > 3
+        #endif //HOTENDS > 2
+      #else //!PID_PARAMS_PER_HOTEND || HOTENDS == 1
+        PID_MENU_ITEMS("", 0);
+      #endif //!PID_PARAMS_PER_HOTEND || HOTENDS == 1
+
+    #endif //PIDTEMP
+
+    //
+    // Preheat PLA conf
+    //
+    MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
+
+    //
+    // Preheat ABS conf
+    //
+    MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
+    END_MENU();
   }
 
-  END_MENU();
-}
+  /**
+   *
+   * "Temperature" > "Preheat PLA conf" submenu
+   *
+   */
+  static void lcd_control_temperature_preheat_pla_settings_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_TEMPERATURE);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
+    #if TEMP_SENSOR_0 != 0
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
+    #endif
+    #if TEMP_SENSOR_BED != 0
+      MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
+    #endif
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+    #endif
+    END_MENU();
+  }
 
-/**
- *
- * "Control" > "Contrast" submenu
- *
- */
-#if HAS_LCD_CONTRAST
-  static void lcd_set_contrast() {
-    ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition) {
-      set_lcd_contrast(lcd_contrast + encoderPosition);
-      encoderPosition = 0;
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-    }
-    if (lcdDrawUpdate) {
-      lcd_implementation_drawedit(PSTR(MSG_CONTRAST),
-        #if LCD_CONTRAST_MAX >= 100
-          itostr3(lcd_contrast)
-        #else
-          itostr2(lcd_contrast)
-        #endif
-      );
-    }
-    if (LCD_CLICKED) lcd_goto_previous_menu(true);
+  /**
+   *
+   * "Temperature" > "Preheat ABS conf" submenu
+   *
+   */
+  static void lcd_control_temperature_preheat_abs_settings_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_TEMPERATURE);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
+    #if TEMP_SENSOR_0 != 0
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
+    #endif
+    #if TEMP_SENSOR_BED != 0
+      MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
+    #endif
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
+    #endif
+    END_MENU();
   }
-#endif // HAS_LCD_CONTRAST
 
-/**
- *
- * "Control" > "Retract" submenu
- *
- */
-#if ENABLED(FWRETRACT)
-  static void lcd_control_retract_menu() {
+  static void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
+
+  /**
+   *
+   * "Control" > "Motion" submenu
+   *
+   */
+  static void lcd_control_motion_menu() {
     START_MENU();
     MENU_ITEM(back, MSG_CONTROL);
-    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
+    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+      MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
+    // Manual bed leveling, Bed Z:
+    #if ENABLED(MANUAL_BED_LEVELING)
+      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+    #endif
+    MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
+    MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &planner.max_xy_jerk, 1, 990);
+    #if ENABLED(DELTA)
+      MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_z_jerk, 1, 990);
+    #else
+      MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_z_jerk, 0.1, 990);
+    #endif
+    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_e_jerk, 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate[X_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate[Y_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate[Z_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate[E_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate, 0, 999);
+    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate, 0, 999);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
+    MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
+    MENU_ITEM_EDIT(float52, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999);
+    MENU_ITEM_EDIT(float52, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999);
+    #if ENABLED(DELTA)
+      MENU_ITEM_EDIT(float52, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
+    #else
+      MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999);
+    #endif
+    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999);
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+      MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
+    #endif
+    #if ENABLED(SCARA)
+      MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS], 0.5, 2);
+      MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS], 0.5, 2);
     #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
     END_MENU();
   }
-#endif // FWRETRACT
 
-#if ENABLED(SDSUPPORT)
+  /**
+   *
+   * "Control" > "Filament" submenu
+   *
+   */
+  static void lcd_control_volumetric_menu() {
+    START_MENU();
+    MENU_ITEM(back, MSG_CONTROL);
+
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
 
-  #if !PIN_EXISTS(SD_DETECT)
-    static void lcd_sd_refresh() {
-      card.initsd();
-      currentMenuViewOffset = 0;
+    if (volumetric_enabled) {
+      #if EXTRUDERS == 1
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+      #else //EXTRUDERS > 1
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
+        #if EXTRUDERS > 2
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
+          #endif //EXTRUDERS > 3
+        #endif //EXTRUDERS > 2
+      #endif //EXTRUDERS > 1
     }
-  #endif
 
-  static void lcd_sd_updir() {
-    card.updir();
-    currentMenuViewOffset = 0;
+    END_MENU();
   }
 
   /**
    *
-   * "Print from SD" submenu
+   * "Control" > "Contrast" submenu
    *
    */
-  void lcd_sdcard_menu() {
-    ENCODER_DIRECTION_MENUS();
-    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return; // nothing to do (so don't thrash the SD card)
-    uint16_t fileCnt = card.getnrfilenames();
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN);
-    card.getWorkDirName();
-    if (card.filename[0] == '/') {
-      #if !PIN_EXISTS(SD_DETECT)
-        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
-      #endif
+  #if HAS_LCD_CONTRAST
+    static void lcd_set_contrast() {
+      ENCODER_DIRECTION_NORMAL();
+      if (encoderPosition) {
+        set_lcd_contrast(lcd_contrast + encoderPosition);
+        encoderPosition = 0;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      }
+      if (lcdDrawUpdate) {
+        lcd_implementation_drawedit(PSTR(MSG_CONTRAST),
+          #if LCD_CONTRAST_MAX >= 100
+            itostr3(lcd_contrast)
+          #else
+            itostr2(lcd_contrast)
+          #endif
+        );
+      }
+      if (LCD_CLICKED) lcd_goto_previous_menu(true);
     }
-    else {
-      MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+  #endif // HAS_LCD_CONTRAST
+
+  /**
+   *
+   * "Control" > "Retract" submenu
+   *
+   */
+  #if ENABLED(FWRETRACT)
+    static void lcd_control_retract_menu() {
+      START_MENU();
+      MENU_ITEM(back, MSG_CONTROL);
+      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+      #if EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
+      #if EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
+      END_MENU();
     }
+  #endif // FWRETRACT
 
-    for (uint16_t i = 0; i < fileCnt; i++) {
-      if (_menuItemNr == _lineNr) {
-        card.getfilename(
-           #if ENABLED(SDCARD_RATHERRECENTFIRST)
-             fileCnt-1 -
-           #endif
-           i
-        );
+  #if ENABLED(SDSUPPORT)
 
-        if (card.filenameIsDir)
-          MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
-        else
-          MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+    #if !PIN_EXISTS(SD_DETECT)
+      static void lcd_sd_refresh() {
+        card.initsd();
+        currentMenuViewOffset = 0;
+      }
+    #endif
+
+    static void lcd_sd_updir() {
+      card.updir();
+      currentMenuViewOffset = 0;
+    }
+
+    /**
+     *
+     * "Print from SD" submenu
+     *
+     */
+    void lcd_sdcard_menu() {
+      ENCODER_DIRECTION_MENUS();
+      if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return; // nothing to do (so don't thrash the SD card)
+      uint16_t fileCnt = card.getnrfilenames();
+      START_MENU();
+      MENU_ITEM(back, MSG_MAIN);
+      card.getWorkDirName();
+      if (card.filename[0] == '/') {
+        #if !PIN_EXISTS(SD_DETECT)
+          MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
+        #endif
       }
       else {
-        MENU_ITEM_DUMMY();
+        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+      }
+
+      for (uint16_t i = 0; i < fileCnt; i++) {
+        if (_menuItemNr == _lineNr) {
+          card.getfilename(
+             #if ENABLED(SDCARD_RATHERRECENTFIRST)
+               fileCnt-1 -
+             #endif
+             i
+          );
+
+          if (card.filenameIsDir)
+            MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+          else
+            MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+        }
+        else {
+          MENU_ITEM_DUMMY();
+        }
       }
+      END_MENU();
     }
-    END_MENU();
-  }
 
-#endif //SDSUPPORT
+  #endif //SDSUPPORT
 
-/**
- *
- * Functions for editing single values
- *
- * The "menu_edit_type" macro generates the functions needed to edit a numerical value.
- *
- * For example, menu_edit_type(int, int3, itostr3, 1) expands into these functions:
- *
- *   bool _menu_edit_int3();
- *   void menu_edit_int3(); // edit int (interactively)
- *   void menu_edit_callback_int3(); // edit int (interactively) with callback on completion
- *   static void _menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
- *   static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
- *   static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, menuFunc_t callback); // edit int with callback
- *
- * You can then use one of the menu macros to present the edit interface:
- *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999)
- *
- * This expands into a more primitive menu item:
- *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
- *
- *
- * Also: MENU_MULTIPLIER_ITEM_EDIT, MENU_ITEM_EDIT_CALLBACK, and MENU_MULTIPLIER_ITEM_EDIT_CALLBACK
- *
- *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
- */
-#define menu_edit_type(_type, _name, _strFunc, scale) \
-  bool _menu_edit_ ## _name () { \
-    ENCODER_DIRECTION_NORMAL(); \
-    bool isClicked = LCD_CLICKED; \
-    if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
-    if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
-    if (lcdDrawUpdate) \
-      lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
-    if (isClicked) { \
-      *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
-      lcd_goto_previous_menu(true); \
+  /**
+   *
+   * Functions for editing single values
+   *
+   * The "menu_edit_type" macro generates the functions needed to edit a numerical value.
+   *
+   * For example, menu_edit_type(int, int3, itostr3, 1) expands into these functions:
+   *
+   *   bool _menu_edit_int3();
+   *   void menu_edit_int3(); // edit int (interactively)
+   *   void menu_edit_callback_int3(); // edit int (interactively) with callback on completion
+   *   static void _menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
+   *   static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);
+   *   static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, screenFunc_t callback); // edit int with callback
+   *
+   * You can then use one of the menu macros to present the edit interface:
+   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999)
+   *
+   * This expands into a more primitive menu item:
+   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
+   *
+   *
+   * Also: MENU_MULTIPLIER_ITEM_EDIT, MENU_ITEM_EDIT_CALLBACK, and MENU_MULTIPLIER_ITEM_EDIT_CALLBACK
+   *
+   *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
+   */
+  #define menu_edit_type(_type, _name, _strFunc, scale) \
+    bool _menu_edit_ ## _name () { \
+      ENCODER_DIRECTION_NORMAL(); \
+      bool isClicked = LCD_CLICKED; \
+      if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
+      if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
+      if (lcdDrawUpdate) \
+        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
+      if (isClicked) { \
+        *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
+        lcd_goto_previous_menu(true); \
+      } \
+      return isClicked; \
     } \
-    return isClicked; \
-  } \
-  void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \
-  void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \
-  static void _menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
-    lcd_save_previous_menu(); \
-    \
-    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
-    \
-    editLabel = pstr; \
-    editValue = ptr; \
-    minEditValue = minValue * scale; \
-    maxEditValue = maxValue * scale - minEditValue; \
-    encoderPosition = (*ptr) * scale - minEditValue; \
-  } \
-  static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
-    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
-    currentMenu = menu_edit_ ## _name; \
-  }\
-  static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) { \
-    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
-    currentMenu = menu_edit_callback_ ## _name; \
-    callbackFunc = callback; \
-  }
-menu_edit_type(int, int3, itostr3, 1);
-menu_edit_type(float, float3, ftostr3, 1);
-menu_edit_type(float, float32, ftostr32, 100);
-menu_edit_type(float, float43, ftostr43sign, 1000);
-menu_edit_type(float, float5, ftostr5rj, 0.01);
-menu_edit_type(float, float51, ftostr51sign, 10);
-menu_edit_type(float, float52, ftostr52sign, 100);
-menu_edit_type(unsigned long, long5, ftostr5rj, 0.01);
-
-/**
- *
- * Handlers for RepRap World Keypad input
- *
- */
-#if ENABLED(REPRAPWORLD_KEYPAD)
-  static void reprapworld_keypad_move_z_up() {
-    encoderPosition = 1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_z();
-  }
-  static void reprapworld_keypad_move_z_down() {
-    encoderPosition = -1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_z();
-  }
-  static void reprapworld_keypad_move_x_left() {
-    encoderPosition = -1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_x();
-  }
-  static void reprapworld_keypad_move_x_right() {
-    encoderPosition = 1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_x();
-  }
-  static void reprapworld_keypad_move_y_down() {
-    encoderPosition = 1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_y();
-  }
-  static void reprapworld_keypad_move_y_up() {
-    encoderPosition = -1;
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    lcd_move_y();
-  }
-  static void reprapworld_keypad_move_home() {
-    enqueue_and_echo_commands_P(PSTR("G28")); // move all axes home
-  }
-#endif // REPRAPWORLD_KEYPAD
-
+    void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \
+    void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \
+    static void _menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
+      lcd_save_previous_menu(); \
+      \
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
+      \
+      editLabel = pstr; \
+      editValue = ptr; \
+      minEditValue = minValue * scale; \
+      maxEditValue = maxValue * scale - minEditValue; \
+      encoderPosition = (*ptr) * scale - minEditValue; \
+    } \
+    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
+      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+      currentScreen = menu_edit_ ## _name; \
+    }\
+    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, screenFunc_t callback) { \
+      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+      currentScreen = menu_edit_callback_ ## _name; \
+      callbackFunc = callback; \
+    }
+  menu_edit_type(int, int3, itostr3, 1);
+  menu_edit_type(float, float3, ftostr3, 1);
+  menu_edit_type(float, float32, ftostr32, 100);
+  menu_edit_type(float, float43, ftostr43sign, 1000);
+  menu_edit_type(float, float5, ftostr5rj, 0.01);
+  menu_edit_type(float, float51, ftostr51sign, 10);
+  menu_edit_type(float, float52, ftostr52sign, 100);
+  menu_edit_type(unsigned long, long5, ftostr5rj, 0.01);
 
-/**
- *
- * Audio feedback for controller clicks
- *
- */
+  /**
+   *
+   * Handlers for RepRap World Keypad input
+   *
+   */
+  #if ENABLED(REPRAPWORLD_KEYPAD)
+    static void reprapworld_keypad_move_z_up() {
+      encoderPosition = 1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_z();
+    }
+    static void reprapworld_keypad_move_z_down() {
+      encoderPosition = -1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_z();
+    }
+    static void reprapworld_keypad_move_x_left() {
+      encoderPosition = -1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_x();
+    }
+    static void reprapworld_keypad_move_x_right() {
+      encoderPosition = 1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_x();
+    }
+    static void reprapworld_keypad_move_y_down() {
+      encoderPosition = 1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_y();
+    }
+    static void reprapworld_keypad_move_y_up() {
+      encoderPosition = -1;
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      lcd_move_y();
+    }
+    static void reprapworld_keypad_move_home() {
+      enqueue_and_echo_commands_P(PSTR("G28")); // move all axes home
+    }
+  #endif // REPRAPWORLD_KEYPAD
 
-#if ENABLED(LCD_USE_I2C_BUZZER)
-  void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown
-    lcd.buzz(duration, freq);
-  }
-#endif
 
-void lcd_quick_feedback() {
-  lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-  next_button_update_ms = millis() + 500;
+  /**
+   *
+   * Audio feedback for controller clicks
+   *
+   */
 
   #if ENABLED(LCD_USE_I2C_BUZZER)
-    lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-  #elif PIN_EXISTS(BEEPER)
-    buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-  #else
-    delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);
+    void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown
+      lcd.buzz(duration, freq);
+    }
   #endif
-}
-
-/**
- *
- * Menu actions
- *
- */
-static void menu_action_back() { lcd_goto_previous_menu(); }
-static void menu_action_submenu(menuFunc_t func) { lcd_save_previous_menu(); lcd_goto_menu(func); }
-static void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
-static void menu_action_function(menuFunc_t func) { (*func)(); }
 
-#if ENABLED(SDSUPPORT)
+  void lcd_quick_feedback() {
+    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+    next_button_update_ms = millis() + 500;
 
-  static void menu_action_sdfile(const char* filename, char* longFilename) {
-    UNUSED(longFilename);
-    card.openAndPrintFile(filename);
-    lcd_return_to_status();
+    #if ENABLED(LCD_USE_I2C_BUZZER)
+      lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+    #elif PIN_EXISTS(BEEPER)
+      buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+    #else
+      delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);
+    #endif
   }
 
-  static void menu_action_sddirectory(const char* filename, char* longFilename) {
-    UNUSED(longFilename);
-    card.chdir(filename);
-    encoderPosition = 0;
-  }
+  /**
+   *
+   * Menu actions
+   *
+   */
+  static void menu_action_back() { lcd_goto_previous_menu(); }
+  static void menu_action_submenu(screenFunc_t func) { lcd_save_previous_menu(); lcd_goto_screen(func); }
+  static void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
+  static void menu_action_function(screenFunc_t func) { (*func)(); }
 
-#endif //SDSUPPORT
+  #if ENABLED(SDSUPPORT)
 
-static void menu_action_setting_edit_bool(const char* pstr, bool* ptr) {UNUSED(pstr); *ptr = !(*ptr); }
-static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback) {
-  menu_action_setting_edit_bool(pstr, ptr);
-  (*callback)();
-}
+    static void menu_action_sdfile(const char* filename, char* longFilename) {
+      UNUSED(longFilename);
+      card.openAndPrintFile(filename);
+      lcd_return_to_status();
+    }
+
+    static void menu_action_sddirectory(const char* filename, char* longFilename) {
+      UNUSED(longFilename);
+      card.chdir(filename);
+      encoderPosition = 0;
+    }
+
+  #endif //SDSUPPORT
+
+  static void menu_action_setting_edit_bool(const char* pstr, bool* ptr) {UNUSED(pstr); *ptr = !(*ptr); }
+  static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
+    menu_action_setting_edit_bool(pstr, ptr);
+    (*callback)();
+  }
 
 #endif //ULTIPANEL
 
@@ -2158,12 +2174,12 @@ bool lcd_blink() {
  * No worries. This function is only called from the main thread.
  */
 void lcd_update() {
+
   #if ENABLED(ULTIPANEL)
     static millis_t return_to_status_ms = 0;
+    manage_manual_move();
   #endif
 
-  manage_manual_move();
-
   lcd_buttons_update();
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
@@ -2172,8 +2188,8 @@ void lcd_update() {
     if (sd_status != lcd_sd_status && lcd_detected()) {
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
-        #if ENABLED(LCD_PROGRESS_BAR)
-          currentMenu == lcd_status_screen
+        #if ENABLED(LCD_PROGRESS_BAR) && ENABLED(ULTIPANEL)
+          currentScreen == lcd_status_screen
         #endif
       );
 
@@ -2271,7 +2287,11 @@ void lcd_update() {
     // We arrive here every ~100ms when idling often enough.
     // Instead of tracking the changes simply redraw the Info Screen ~1 time a second.
     static int8_t lcd_status_update_delay = 1; // first update one loop delayed
-    if (currentMenu == lcd_status_screen && !lcd_status_update_delay--) {
+    if (
+      #if ENABLED(ULTIPANEL)
+        currentScreen == lcd_status_screen &&
+      #endif
+        !lcd_status_update_delay--) {
       lcd_status_update_delay = 9;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
@@ -2300,17 +2320,19 @@ void lcd_update() {
           u8g.setColorIndex(dot_color); // Set color for the alive dot
           u8g.drawPixel(127, 63); // draw alive dot
           u8g.setColorIndex(1); // black on white
-          (*currentMenu)();
+          (*currentScreen)();
         } while (u8g.nextPage());
+      #elif ENABLED(ULTIPANEL)
+        (*currentScreen)();
       #else
-        (*currentMenu)();
+        lcd_status_screen();
       #endif
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
-      if (currentMenu == lcd_status_screen || defer_return_to_status)
+      if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
@@ -2333,11 +2355,6 @@ void lcd_update() {
   }
 }
 
-void lcd_ignore_click(bool b) {
-  ignore_click = b;
-  wait_for_unclick = false;
-}
-
 void lcd_finishstatus(bool persist=false) {
   #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
     UNUSED(persist);
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 5cb1ecc..8e7e2ee 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -27,8 +27,6 @@
 
 #if ENABLED(ULTRA_LCD)
 
-  #include "buzzer.h"
-
   #define BUTTON_EXISTS(BN) (defined(BTN_## BN) && BTN_## BN >= 0)
   #define BUTTON_PRESSED(BN) !READ(BTN_## BN)
 
@@ -54,8 +52,11 @@
   #if ENABLED(DOGLCD)
     extern int lcd_contrast;
     void set_lcd_contrast(int value);
+  #elif ENABLED(SHOW_BOOTSCREEN)
+    void bootscreen();
   #endif
 
+
   #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))
   #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))
 
@@ -63,8 +64,11 @@
   #define LCD_TIMEOUT_TO_STATUS 15000
 
   #if ENABLED(ULTIPANEL)
-    void lcd_buttons_update();
     extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
+    void lcd_buttons_update();
+    void lcd_quick_feedback(); // Audible feedback for a button click - could also be visual
+    bool lcd_clicked();
+    void lcd_ignore_click(bool b=true);
   #else
     FORCE_INLINE void lcd_buttons_update() {}
   #endif
@@ -81,12 +85,10 @@
   #if ENABLED(FILAMENT_LCD_DISPLAY)
     extern millis_t previous_lcd_status_ms;
   #endif
-  void lcd_quick_feedback(); // Audible feedback for a button click - could also be visual
-  bool lcd_clicked();
-  void lcd_ignore_click(bool b=true);
+
   bool lcd_blink();
 
-  #if ENABLED(ULTIPANEL) && ENABLED(REPRAPWORLD_KEYPAD)
+  #if ENABLED(REPRAPWORLD_KEYPAD)
 
     #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
 
@@ -116,7 +118,7 @@
     #define REPRAPWORLD_KEYPAD_MOVE_Y_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)
     #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)
 
-  #endif //ULTIPANEL && REPRAPWORLD_KEYPAD
+  #endif // REPRAPWORLD_KEYPAD
 
   #if ENABLED(NEWPANEL)
 
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index d682bfa..9ca7573 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -201,11 +201,6 @@ extern volatile uint8_t buttons;  //an extended version of the last checked butt
 
 #include "utf_mapper.h"
 
-#if ENABLED(SHOW_BOOTSCREEN)
-  static void bootscreen();
-  static bool show_bootscreen = true;
-#endif
-
 #if ENABLED(LCD_PROGRESS_BAR)
   static millis_t progress_bar_ms = 0;
   #if PROGRESS_MSG_EXPIRE > 0
@@ -394,10 +389,6 @@ static void lcd_implementation_init(
     lcd.begin(LCD_WIDTH, LCD_HEIGHT);
   #endif
 
-  #if ENABLED(SHOW_BOOTSCREEN)
-    if (show_bootscreen) bootscreen();
-  #endif
-
   lcd_set_custom_characters(
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_set
@@ -452,8 +443,7 @@ unsigned lcd_print(char c) { return charset_mapper(c); }
     lcd.setCursor(indent, 2); lcd.print('\x02'); lcd_printPGM(PSTR( "------" ));  lcd.print('\x03');
   }
 
-  static void bootscreen() {
-    show_bootscreen = false;
+  void bootscreen() {
     byte top_left[8] = {
       B00000,
       B00000,
diff --git a/buildroot/bin/opt_disable b/buildroot/bin/opt_disable
index 4e2d853..35ad1aa 100755
--- a/buildroot/bin/opt_disable
+++ b/buildroot/bin/opt_disable
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
 
 for opt in "$@" ; do
-  eval "sed -i 's/\(\/\/ *\)*\(\#define +$opt[^a-zA-Z0-9_]\)/\/\/\2/g' Marlin/Configuration.h"
+  eval "sed -i 's/\([[:blank:]]*\)\(#define \b${opt}\b\)/\1\/\/\2/g' Marlin/Configuration.h"
 done
diff --git a/buildroot/bin/opt_disable_adv b/buildroot/bin/opt_disable_adv
new file mode 100644
index 0000000..80d8318
--- /dev/null
+++ b/buildroot/bin/opt_disable_adv
@@ -0,0 +1,5 @@
+#!/usr/bin/env bash
+
+for opt in "$@" ; do
+  eval "sed -i 's/\([[:blank:]]*\)\(#define \b${opt}\b\)/\1\/\/\2/g' Marlin/Configuration_adv.h"
+done
diff --git a/buildroot/bin/opt_enable b/buildroot/bin/opt_enable
index cc9a3e0..7b119fa 100755
--- a/buildroot/bin/opt_enable
+++ b/buildroot/bin/opt_enable
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
 
 for opt in "$@" ; do
-  eval "sed -i 's/\/\/ *\(#define +$opt[^a-zA-Z0-9_]\)/\1/g' Marlin/Configuration.h"
+  eval "sed -i 's/\/\/[[:blank:]]*\(#define \b${opt}\b\)/\1/g' Marlin/Configuration.h"
 done
diff --git a/buildroot/bin/opt_enable_adv b/buildroot/bin/opt_enable_adv
index a557dc3..a34e56f 100755
--- a/buildroot/bin/opt_enable_adv
+++ b/buildroot/bin/opt_enable_adv
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
 
 for opt in "$@" ; do
-  eval "sed -i 's/\/\/ *\(#define +$opt[^a-zA-Z0-9_]\)/\1/g' Marlin/Configuration_adv.h"
+  eval "sed -i 's/\/\/[[:blank:]]*\(#define \b${opt}\b\)/\1/g' Marlin/Configuration_adv.h"
 done
diff --git a/buildroot/bin/opt_set b/buildroot/bin/opt_set
index 2646bc1..cf8c0d8 100755
--- a/buildroot/bin/opt_set
+++ b/buildroot/bin/opt_set
@@ -1,3 +1,3 @@
 #!/usr/bin/env bash
 
-eval "sed -i 's/\(#define +$1 +\)[^ ]*$/\1 $2/g' Marlin/Configuration.h"
+eval "sed -i 's/\(#define \b${1}\b\).*$/\1 ${2}/g' Marlin/Configuration.h"
diff --git a/buildroot/bin/opt_set_adv b/buildroot/bin/opt_set_adv
index 63a18d4..54076a0 100755
--- a/buildroot/bin/opt_set_adv
+++ b/buildroot/bin/opt_set_adv
@@ -1,3 +1,3 @@
 #!/usr/bin/env bash
 
-eval "sed -i 's/\(#define +$1 +\)[^ ]*$/\1 $2/g' Marlin/Configuration_adv.h"
+eval "sed -i 's/\(#define \b${1}\b\).*$/\1 ${2}/g' Marlin/Configuration_adv.h"
diff --git a/buildroot/bin/pins_set b/buildroot/bin/pins_set
index bd14586..ae6549f 100755
--- a/buildroot/bin/pins_set
+++ b/buildroot/bin/pins_set
@@ -1,3 +1,3 @@
 #!/usr/bin/env bash
 
-eval "sed -i 's/\(#define +$2 +\)[^ ]*$/\1 $3/g' Marlin/pins_$1.h"
+eval "sed -i 's/\(#define \b${2}\b\).*$/\1 ${3}/g' Marlin/pins_${1}.h"

