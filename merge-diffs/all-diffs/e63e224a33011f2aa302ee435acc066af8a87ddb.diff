commit e63e224a33011f2aa302ee435acc066af8a87ddb (from e7dca8614be5cac516c0d7989a28abdf21d412d8)
Merge: e7dca86 46f80e8
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Fri Nov 18 19:04:09 2011 +0100

    Merge remote-tracking branch 'origin/Marlin_v1' into Marlin_v1
    
    Conflicts:
    	Marlin/Configuration.h
    	Marlin/Marlin.pde

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 7cbb66c..cf38cea 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -58,7 +58,6 @@
 //#define BED_USES_THERMISTOR
 //#define BED_USES_AD595
 
-#define HEATER_CHECK_INTERVAL 50 //ms
 #define BED_CHECK_INTERVAL 5000 //ms
 
 //// Experimental watchdog and minimal temp
@@ -243,10 +242,12 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 // The watchdog waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
 // this enables the watchdog interrupt.
 //#define USE_WATCHDOG
-// you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
+#ifdef USE_WATCHDOG
+  // you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
 //#define RESET_MANUAL
 //#define WATCHDOG_TIMEOUT 4  //seconds
 
+
 // extruder advance constant (s2/mm3)
 //
 // advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 440a44a..acfc3c2 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -100,7 +100,7 @@ void prepare_move();
 void kill();
 
 void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.
-
+void prepare_arc_move(char isclockwise);
 
 #ifndef CRITICAL_SECTION_START
   #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 3a6d4e6..128f697 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -37,6 +37,7 @@
 #include "temperature.h"
 #include "motion_control.h"
 #include "cardreader.h"
+#include "watchdog.h"
 
 
 #define VERSION_STRING  "1.0.0 Alpha 1"
@@ -193,6 +194,12 @@ extern "C"{
 }
 
 
+
+
+
+
+
+
 //adds an command to the main command buffer
 //thats really done in a non-safe way.
 //needs overworking someday
@@ -235,6 +242,7 @@ void setup()
   tp_init();    // Initialize temperature loop 
   plan_init();  // Initialize planner;
   st_init();    // Initialize stepper;
+  wd_init();
 }
 
 
@@ -659,7 +667,8 @@ inline void process_commands()
       break;
     case 105: // M105
       //SERIAL_ECHOLN(freeMemory());
-          
+       //test watchdog:
+       //delay(20000);
       #if (TEMP_0_PIN > -1) || defined (HEATER_USES_AD595)
         SERIAL_PROTOCOLPGM("ok T:");
         SERIAL_PROTOCOL( degHotend0()); 
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index b3f514f..d75f93a 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -33,6 +33,7 @@ public:
   inline bool eof() { return sdpos>=filesize ;};
   inline int16_t get() {  sdpos = file.curPosition();return (int16_t)file.read();};
   inline void setIndex(long index) {sdpos = index;file.seekSet(index);};
+  inline uint8_t percentDone(){if(!sdprinting) return 0; if(filesize) return sdpos*100/filesize; else return 0;};
 
 public:
   bool saving;
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index bc07c25..6bae43d 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -97,7 +97,7 @@
   #define BLOCK ;
 #endif 
   
-  
+void lcd_statuspgm(const char* message);
   
 #endif //ULTRALCD
-
+
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index d951671..c4ea234 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -374,6 +374,17 @@ void MainMenu::showStatus()
     lcd.print(fillto(LCD_WIDTH,messagetext));
     messagetext[0]='\0';
   }
+  
+  static uint8_t oldpercent=101;
+  uint8_t percent=card.percentDone();
+  if(oldpercent!=percent ||force_lcd_update)
+  {
+     lcd.setCursor(7,2);
+    lcd.print(itostr3((int)percent));
+    lcdprintPGM("%SD");
+    
+  }
+  
 #else //smaller LCDS----------------------------------
   static int olddegHotEnd0=-1;
   static int oldtargetHotEnd0=-1;
@@ -686,7 +697,7 @@ void MainMenu::showControl()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk/60));
+          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
         }
         
         if((activeline==line) )
@@ -696,11 +707,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)max_xy_jerk/60;
+               encoderpos=(int)max_xy_jerk;
             }
             else
             {
-              max_xy_jerk= encoderpos*60;
+              max_xy_jerk= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -866,7 +877,7 @@ void MainMenu::showControl()
           if(i==ItemC_vmaxy)lcdprintPGM("y:");
           if(i==ItemC_vmaxz)lcdprintPGM("z:");
           if(i==ItemC_vmaxe)lcdprintPGM("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemC_vmaxx]/60));
+          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemC_vmaxx]));
         }
         
         if((activeline==line) )
@@ -876,11 +887,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)max_feedrate[i-ItemC_vmaxx]/60;
+               encoderpos=(int)max_feedrate[i-ItemC_vmaxx];
             }
             else
             {
-              max_feedrate[i-ItemC_vmaxx]= encoderpos*60;
+              max_feedrate[i-ItemC_vmaxx]= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -901,7 +912,7 @@ void MainMenu::showControl()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" Vmin:");
-          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate/60));
+          lcd.setCursor(13,line);lcd.print(itostr3(minimumfeedrate));
         }
         
         if((activeline==line) )
@@ -911,11 +922,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)(minimumfeedrate/60.);
+               encoderpos=(int)(minimumfeedrate);
             }
             else
             {
-              minimumfeedrate= encoderpos*60;
+              minimumfeedrate= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -935,7 +946,7 @@ void MainMenu::showControl()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" VTrav min:");
-          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate/60));
+          lcd.setCursor(13,line);lcd.print(itostr3(mintravelfeedrate));
         }
         
         if((activeline==line) )
@@ -945,11 +956,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)mintravelfeedrate/60;
+               encoderpos=(int)mintravelfeedrate;
             }
             else
             {
-              mintravelfeedrate= encoderpos*60;
+              mintravelfeedrate= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
diff --git a/Marlin/watchdog.pde b/Marlin/watchdog.pde
index be10f58..7af540c 100644
--- a/Marlin/watchdog.pde
+++ b/Marlin/watchdog.pde
@@ -42,10 +42,12 @@ ISR(WDT_vect)
  
     #ifdef RESET_MANUAL
       LCD_MESSAGEPGM("Please Reset!");
+      LCD_STATUS;
       SERIAL_ERROR_START;
       SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");
     #else
       LCD_MESSAGEPGM("Timeout, resetting!");
+      LCD_STATUS;
     #endif 
     //disable watchdog, it will survife reboot.
     WDTCSR |= (1<<WDCE) | (1<<WDE);

commit e63e224a33011f2aa302ee435acc066af8a87ddb (from 46f80e82d947dcb928abdfe96ee1e2f48ea82de5)
Merge: e7dca86 46f80e8
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Fri Nov 18 19:04:09 2011 +0100

    Merge remote-tracking branch 'origin/Marlin_v1' into Marlin_v1
    
    Conflicts:
    	Marlin/Configuration.h
    	Marlin/Marlin.pde

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 1e12d4e..cf38cea 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -11,7 +11,7 @@
 
 // Frequency limit
 // See nophead's blog for more info
-// Not working OK
+// Not working O
 //#define XY_FREQUENCY_LIMIT  15
 
 // Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end
@@ -31,7 +31,7 @@
 // Sanguinololu 1.2 and above = 62
 // Ultimaker = 7,
 // Teensylu = 8
-#define MOTHERBOARD 7
+#define MOTHERBOARD 5
 
 //===========================================================================
 //=============================Thermal Settings  ============================
@@ -45,9 +45,9 @@
 // 5 is ParCan supplied 104GT-2 100K
 // 6 is EPCOS 100k
 // 7 is 100k Honeywell thermistor 135-104LAG-J01
-#define THERMISTORHEATER_0 3
-#define THERMISTORHEATER_1 3
-#define THERMISTORBED 3
+//#define THERMISTORHEATER_0 3
+//#define THERMISTORHEATER_1 3
+//#define THERMISTORBED 3
 
 //#define HEATER_0_USES_THERMISTOR
 //#define HEATER_1_USES_THERMISTOR
@@ -119,9 +119,15 @@
 //    #define  DEFAULT_Ki (2*Kp/PID_SWING_AT_CRITIAL*PID_dT)  
 //    #define  DEFAULT_Kd (PID_SWING_AT_CRITIAL/8./PID_dT)  
 
+// Ultitmaker
     #define  DEFAULT_Kp  22.2
     #define  DEFAULT_Ki (1.25*PID_dT)  
     #define  DEFAULT_Kd (99/PID_dT)  
+
+// Mendel Parts V9 on 12V    
+//    #define  DEFAULT_Kp  63.0
+//    #define  DEFAULT_Ki (2.25*PID_dT)  
+//    #define  DEFAULT_Kd (440/PID_dT)  
   #endif
    
   #ifdef PID_PI
@@ -140,13 +146,6 @@
 #endif // PIDTEMP
 
 
-
-
-
-
-
-
-
 //===========================================================================
 //=============================Mechanical Settings===========================
 //===========================================================================
@@ -177,10 +176,10 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 //#define INVERT_Z_DIR false    // for Mendel set to false, for Orca set to true
 //#define INVERT_E_DIR true   // for direct drive extruder v9 set to true, for geared extruder set to false
 
-#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
-#define INVERT_Y_DIR false   // for Mendel set to true, for Orca set to false
-#define INVERT_Z_DIR true    // for Mendel set to false, for Orca set to true
-#define INVERT_E_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+//#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true
+//#define INVERT_Y_DIR false   // for Mendel set to true, for Orca set to false
+//#define INVERT_Z_DIR true    // for Mendel set to false, for Orca set to true
+//#define INVERT_E_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
 
 //// ENDSTOP SETTINGS:
 // Sets direction of endstops when homing; 1=MAX, -1=MIN
@@ -245,10 +244,8 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 //#define USE_WATCHDOG
 #ifdef USE_WATCHDOG
   // you cannot reboot on a mega2560 due to a bug in he bootloader. Hence, you have to reset manually, and this is done hereby:
-  #define RESET_MANUAL
-  #define WATCHDOG_TIMEOUT 4  //seconds
-#endif
-
+//#define RESET_MANUAL
+//#define WATCHDOG_TIMEOUT 4  //seconds
 
 
 // extruder advance constant (s2/mm3)
@@ -275,7 +272,7 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 //#define ULTRA_LCD  //general lcd support, also 16x2
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 
-#define ULTIPANEL
+//#define ULTIPANEL
 #ifdef ULTIPANEL
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
@@ -307,8 +304,7 @@ const bool ENDSTOPS_INVERTING = true; // set to true to invert the logic of the
 #define AUTOTEMP_FACTOR 1000.  //current target temperature= min+largest buffered espeeds)*FACTOR
 
 
-
-const int dropsegments=0; //everything with less than this number of steps  will be ignored as move and joined with the next movement
+const int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
 
 //===========================================================================
 //=============================Buffers           ============================
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index f808742..128f697 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -239,10 +239,9 @@ void setup()
     axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
   }
 
-  
+  tp_init();    // Initialize temperature loop 
   plan_init();  // Initialize planner;
   st_init();    // Initialize stepper;
-  tp_init();    // Initialize temperature loop
   wd_init();
 }
 
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 2e23220..b08e61a 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -56,8 +56,8 @@ static unsigned long step_events_completed; // The number of step events execute
 #ifdef ADVANCE
   static long advance_rate, advance, final_advance = 0;
   static short old_advance = 0;
-  static short e_steps;
 #endif
+static short e_steps;
 static unsigned char busy = false; // TRUE when SIG_OUTPUT_COMPARE1A is being serviced. Used to avoid retriggering that handler.
 static long acceleration_time, deceleration_time;
 //static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
@@ -156,7 +156,7 @@ asm volatile ( \
 #define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1<<OCIE1A)
 
 
-void endstops_triggered(const unsigned long &stepstaken)  
+inline void endstops_triggered(const unsigned long &stepstaken)  
 {
   //this will only work if there is no bufferig
   //however, if you perform a move at which the endstops should be triggered, and wait for it to complete, i.e. by blocking command, it should work
@@ -296,9 +296,9 @@ ISR(TIMER1_COMPA_vect)
       counter_z = counter_x;
       counter_e = counter_x;
       step_events_completed = 0;
-      #ifdef ADVANCE
+ //     #ifdef ADVANCE
       e_steps = 0;
-      #endif
+//      #endif
     } 
     else {
 //      DISABLE_STEPPER_DRIVER_INTERRUPT();
@@ -309,29 +309,6 @@ ISR(TIMER1_COMPA_vect)
     // Set directions TO DO This should be done once during init of trapezoid. Endstops -> interrupt
     out_bits = current_block->direction_bits;
 
-    #ifdef ADVANCE
-        // Calculate E early.
-        counter_e += current_block->steps_e;
-        if (counter_e > 0) {
-          counter_e -= current_block->step_event_count;
-          if ((out_bits & (1<<E_AXIS)) != 0) { // - direction
-            CRITICAL_SECTION_START;
-            e_steps--;
-            CRITICAL_SECTION_END;
-          }
-          else {
-            CRITICAL_SECTION_START;
-            e_steps++;
-            CRITICAL_SECTION_END;
-          }
-        }    
-        // Do E steps + advance steps
-        CRITICAL_SECTION_START;
-        e_steps += ((advance >> 16) - old_advance);
-        CRITICAL_SECTION_END;
-        old_advance = advance >> 16;  
-    #endif //ADVANCE
-
     // Set direction en check limit switches
     if ((out_bits & (1<<X_AXIS)) != 0) {   // -direction
       WRITE(X_DIR_PIN, INVERT_X_DIR);
@@ -339,10 +316,10 @@ ISR(TIMER1_COMPA_vect)
         count_direction[X_AXIS]=-1;
       #endif
       #if X_MIN_PIN > -1
-            if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
- //             endstops_triggered(step_events_completed);
-              step_events_completed = current_block->step_event_count;
-            }
+        if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
+ //         endstops_triggered(step_events_completed);
+          step_events_completed = current_block->step_event_count;
+        }
       #endif
     }
     else { // +direction 
@@ -355,7 +332,7 @@ ISR(TIMER1_COMPA_vect)
  //         endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
-        #endif
+      #endif
     }
 
     if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
@@ -365,7 +342,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Y_MIN_PIN > -1
         if(READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) {
- //         endstops_triggered(step_events_completed);
+//          endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -390,7 +367,7 @@ ISR(TIMER1_COMPA_vect)
       #endif
       #if Z_MIN_PIN > -1
         if(READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) {
-          endstops_triggered(step_events_completed);
+ //         endstops_triggered(step_events_completed);
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -416,6 +393,30 @@ ISR(TIMER1_COMPA_vect)
     #endif //!ADVANCE
 
     for(int8_t i=0; i < step_loops; i++) { // Take multiple steps per interrupt (For high speed moves) 
+    /*
+      counter_e += current_block->steps_e;
+      if (counter_e > 0) {
+        counter_e -= current_block->step_event_count;
+        if ((out_bits & (1<<E_AXIS)) != 0) { // - direction
+          CRITICAL_SECTION_START;
+          e_steps--;
+          CRITICAL_SECTION_END;
+        }
+        else {
+          CRITICAL_SECTION_START;
+          e_steps++;
+          CRITICAL_SECTION_END;
+        }
+      }    
+      */
+      /*
+      // Do E steps + advance steps
+      CRITICAL_SECTION_START;
+      e_steps += ((advance >> 16) - old_advance);
+      CRITICAL_SECTION_END;
+      old_advance = advance >> 16;  
+      */
+        
       counter_x += current_block->steps_x;
       if (counter_x > 0) {
         WRITE(X_STEP_PIN, HIGH);
@@ -649,7 +650,8 @@ void st_init()
   TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (2<<CS10); // 2MHz timer
 
   OCR1A = 0x4000;
-  DISABLE_STEPPER_DRIVER_INTERRUPT();  
+  TCNT1 = 0;
+  ENABLE_STEPPER_DRIVER_INTERRUPT();  
 
   #ifdef ADVANCE
     e_steps = 0;
diff --git a/Marlin/watchdog.pde b/Marlin/watchdog.pde
index 6c883c9..7af540c 100644
--- a/Marlin/watchdog.pde
+++ b/Marlin/watchdog.pde
@@ -19,15 +19,15 @@ void(* ctrlaltdelete) (void) = 0; //does not work on my atmega2560
 /// intialise watch dog with a 1 sec interrupt time
 void wd_init() 
 {
-  WDTCSR = (1<<WDCE )|(1<<WDE ); //allow changes
-  WDTCSR = (1<<WDIF)|(1<<WDIE)| (1<<WDCE )|(1<<WDE )|  (1<<WDP2 )|(1<<WDP1)|(0<<WDP0);
+  WDTCSR |= (1<<WDCE )|(1<<WDE ); //allow changes
+  WDTCSR = (1<<WDCE )|(1<<WDE )|(1<<WDP3 )|(1<<WDP0); // Reset after 8 sec.
+//  WDTCSR = (1<<WDIF)|(1<<WDIE)| (1<<WDCE )|(1<<WDE )|  (1<<WDP3) | (1<<WDP0);
 }
 
 /// reset watchdog. MUST be called every 1s after init or avr will reset.
 void wd_reset() 
 {
   wdt_reset();
-  timeout_seconds=0; //reset counter for resets
 }
 
 //===========================================================================

