commit a97c006bbff8482cf4a6f7d3404eb32a90ee6745 (from f062794a0dd6825564dd64597f802446532596f4)
Merge: f062794 603a5e2
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sat Aug 11 01:45:30 2012 -0700

    Merge pull request #195 from kobaan/Marlin_v1
    
    Updated german translations in language.h

diff --git a/Marlin/language.h b/Marlin/language.h
index 1a99e18..7671d2d 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -5,7 +5,7 @@
 // 1  Custom (For you to add your own messages)
 // 2  English 
 // 3  French	(Waiting translation)
-// 4  German	(Waiting translation)
+// 4  German
 // 5  Etc
 
 #define LANGUAGE_CHOICE 1  // Pick your language from the list above
@@ -96,15 +96,13 @@
 	#define MSG_PART_RELEASE "Partial Release"
 	#define MSG_KILLED "KILLED. "
 	#define MSG_STOPPED "STOPPED. "
-	#define MSG_PREHEAT_PLA " Preheat PLA"
-	#define MSG_PREHEAT_ABS " Preheat ABS"
 	#define MSG_STEPPER_RELEASED "Released."
-  #define MSG_CONTROL_RETRACT  " Retract mm:"
-  #define MSG_CONTROL_RETRACTF " Retract  F:"
-  #define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
-  #define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
-  #define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
-  #define MSG_AUTORETRACT " AutoRetr.:"
+	#define MSG_CONTROL_RETRACT  " Retract mm:"
+	#define MSG_CONTROL_RETRACTF " Retract  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " UnRet  F:"
+	#define MSG_AUTORETRACT " AutoRetr.:"
 
 // Serial Console Messages
 
@@ -176,30 +174,25 @@
 #if LANGUAGE_CHOICE == 4
 
 // LCD Menu Messages
-
-	#define WELCOME_MSG MACHINE_NAME " Ready."
-
-	#define MSG_SD_INSERTED "Card inserted"
-	#define MSG_SD_REMOVED "Card removed"
-	#define MSG_MAIN " Main \003"
+	#define WELCOME_MSG MACHINE_NAME " Bereit."
+	#define MSG_SD_INSERTED "Karte eingelegt"
+	#define MSG_SD_REMOVED "Karte entfernt"
+	#define MSG_MAIN " Haupt \003"
 	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS " Stepper abschalten"
+	#define MSG_DISABLE_STEPPERS " Motoren abschalten"
 	#define MSG_AUTO_HOME " Auto Heim"
 	#define MSG_SET_ORIGIN " Position setzen"
+	#define MSG_COOLDOWN " Abkuehlen"
+	#define MSG_EXTRUDE " Druck"
 	#define MSG_PREHEAT_PLA " Aufheizen PLA"
 	#define MSG_PREHEAT_ABS " Aufheizen ABS"
-	#define MSG_COOLDOWN " Abkuehlen"
-	#define MSG_EXTRUDE " Extrude"
-	#define MSG_PREHEAT_PLA " Preheat PLA"
-	#define MSG_PREHEAT_ABS " Preheat ABS"
-	#define MSG_MOVE_AXIS " Move Axis      \x7E"
-	#define MSG_MOVE_AXIS " Achsen verfahren   \x7E"
+	#define MSG_MOVE_AXIS " Achse bewegen   \x7E"
 	#define MSG_SPEED " Geschw:"
 	#define MSG_NOZZLE " \002Duese:"
 	#define MSG_NOZZLE1 " \002Duese2:"
 	#define MSG_NOZZLE2 " \002Duese3:"
 	#define MSG_BED " \002Bett:"
-	#define MSG_FAN_SPEED " Luefter geschw.:"
+	#define MSG_FAN_SPEED " Luefter Geschw.:"
 	#define MSG_FLOW " Fluss:"
 	#define MSG_CONTROL " Kontrolle \003"
 	#define MSG_MIN " \002 Min:"
@@ -222,38 +215,42 @@
 	#define MSG_VMIN " Vmin:"
 	#define MSG_VTRAV_MIN " VTrav min:"
 	#define MSG_AMAX " Amax "
-	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_A_RETRACT " A-Rueckzug:"
 	#define MSG_XSTEPS " Xsteps/mm:"
 	#define MSG_YSTEPS " Ysteps/mm:"
 	#define MSG_ZSTEPS " Zsteps/mm:"
 	#define MSG_ESTEPS " Esteps/mm:"
-	#define MSG_MAIN_WIDE " Main        \003"
+	#define MSG_MAIN_WIDE " Hauptmenue  \003"
+	#define MSG_RECTRACT_WIDE " Rueckzug    \x7E"
 	#define MSG_TEMPERATURE_WIDE " Temperatur \x7E"
-	#define MSG_MOTION_WIDE " Motion      \x7E"
+	#define MSG_MOTION_WIDE " Bewegung    \x7E"
 	#define MSG_STORE_EPROM " EPROM speichern"
 	#define MSG_LOAD_EPROM "  EPROM laden"
 	#define MSG_RESTORE_FAILSAFE " Standard Konfig."
-	#define MSG_REFRESH "\004Refresh"
+	#define MSG_REFRESH "\004Aktualisieren"
 	#define MSG_WATCH " Beobachten   \003"
-	#define MSG_PREPARE " Prepare \x7E"
-	#define MSG_PREPARE_ALT " Prepare \003"
-	#define MSG_CONTROL_ARROW " Control \x7E"
-	
+	#define MSG_PREPARE " Vorbereiten \x7E"
+	#define MSG_PREPARE_ALT " Vorbereiten \003"
+	#define MSG_CONTROL_ARROW " Kontrolle \x7E"
+	#define MSG_RETRACT_ARROW " Control \x7E"
 	#define MSG_TUNE " Tune    \x7E"
 	#define MSG_STOP_PRINT " Druck stoppen   \x7E"
 	#define MSG_CARD_MENU " SDKarten Menue    \x7E"
 	#define MSG_NO_CARD " Keine SDKarte"
 	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Fehler in der  Menuestruktur."
-	#define MSG_DWELL "DWELL..."		
-	#define MSG_NO_MOVE "No move."
-	#define MSG_PART_RELEASE "Partial Release"
-	#define MSG_KILLED "KILLED. "
-	#define MSG_STOPPED "STOPPED. "
-	#define MSG_PREHEAT_PLA " Preheat PLA"
-	#define MSG_PREHEAT_ABS " Preheat ABS"
-	#define MSG_STEPPER_RELEASED "Released."
-	
-
+	#define MSG_DWELL "verweilen..."
+	#define MSG_USERWAIT "Warten auf Nutzer..."
+	#define MSG_NO_MOVE "Keine Bewegung."
+	#define MSG_PART_RELEASE "Teil loesen"
+	#define MSG_KILLED "GEKILLT. "
+	#define MSG_STOPPED "GESTOPPT. "
+	#define MSG_STEPPER_RELEASED "Freigegeben."
+	#define MSG_CONTROL_RETRACT  " Rueckzug mm:"
+	#define MSG_CONTROL_RETRACTF " Rueckzug  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Z Sprung mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " Vorschub +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " Vorschub  F:"
+	#define MSG_AUTORETRACT " AutoRueckzug.:"
 
 // Serial Console Messages
 
@@ -300,26 +297,26 @@
 	#define MSG_Z_MIN "z_min:"
 	#define MSG_Z_MAX "z_max:"
 
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
+	#define MSG_SD_CANT_OPEN_SUBDIR "Verz. kein Zugriff"
+	#define MSG_SD_INIT_FAIL "SD init Fehler"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init Fehler"
+	#define MSG_SD_OPENROOT_FAIL "openRoot Fehler"
+	#define MSG_SD_CARD_OK "SDKarte ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir Oeffnen Fehler"
+	#define MSG_SD_OPEN_FILE_FAIL "Fehler: Oeffnen Datei: "
+	#define MSG_SD_FILE_OPENED "Datei geoeffnet:"
+	#define MSG_SD_SIZE " Groesse:"
+	#define MSG_SD_FILE_SELECTED "Datei selektiert"
+	#define MSG_SD_WRITE_TO_FILE "Schreibe in Datei: "
+	#define MSG_SD_PRINTING_BYTE "SD druckt byte "
+	#define MSG_SD_NOT_PRINTING "Druckt nicht von SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Datei Schreibfehler"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Kann Verz. nicht wechseln:"
 
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+	#define MSG_STEPPER_TO_HIGH "Steprate zu hoch : "
+	#define MSG_ENDSTOPS_HIT "Endstop erreicht: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " kalter Druck unterbunden"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " langer Druckweg unterbunden"
 
 #endif
-#endif // ifndef LANGUAGE_H
+#endif // ifndef LANGUAGE_H
\ No newline at end of file

commit a97c006bbff8482cf4a6f7d3404eb32a90ee6745 (from 603a5e25b32d1fc36ada3461f9110ba50dbc37fe)
Merge: f062794 603a5e2
Author: ErikZalm <erik@vdzalm.eu>
Date:   Sat Aug 11 01:45:30 2012 -0700

    Merge pull request #195 from kobaan/Marlin_v1
    
    Updated german translations in language.h

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..0a12acf
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,5 @@
+*.o
+applet/
+*~
+*.orig
+*.rej
diff --git a/Marlin/.gitignore b/Marlin/.gitignore
deleted file mode 100644
index 37a3c9b..0000000
--- a/Marlin/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*.o
-applet/
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 1248029..3668db4 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -87,6 +87,10 @@
 #define HEATER_2_MAXTEMP 275
 #define BED_MAXTEMP 150
 
+// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
+// average current. The value should be an integer and the heat bed will be turned on for 1 interval of
+// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
+//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
 
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 297c9df..0182c93 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -78,6 +78,18 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// A single Z stepper driver is usually used to drive 2 stepper motors.
+// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
+// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
+// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
+// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+//#define Z_DUAL_STEPPER_DRIVERS
+
+#ifdef Z_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
 #define X_HOME_RETRACT_MM 5 
 #define Y_HOME_RETRACT_MM 5 
diff --git a/Marlin/EEPROMwrite.h b/Marlin/EEPROMwrite.h
index 96e2ec9..f077160 100644
--- a/Marlin/EEPROMwrite.h
+++ b/Marlin/EEPROMwrite.h
@@ -38,7 +38,7 @@ template <class T> int EEPROM_readAnything(int &ee, T& value)
 // the default values are used whenever there is a change to the data, to prevent
 // wrong data being written to the variables.
 // ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#define EEPROM_VERSION "V05"  
+#define EEPROM_VERSION "V06"
 
 inline void EEPROM_StoreSettings() 
 {
@@ -57,6 +57,7 @@ inline void EEPROM_StoreSettings()
   EEPROM_writeAnything(i,max_xy_jerk);
   EEPROM_writeAnything(i,max_z_jerk);
   EEPROM_writeAnything(i,max_e_jerk);
+  EEPROM_writeAnything(i,add_homeing);
   #ifdef PIDTEMP
     EEPROM_writeAnything(i,Kp);
     EEPROM_writeAnything(i,Ki);
@@ -119,6 +120,13 @@ inline void EEPROM_printSettings()
       SERIAL_ECHOPAIR(" Z" ,max_z_jerk);
       SERIAL_ECHOPAIR(" E" ,max_e_jerk);
       SERIAL_ECHOLN(""); 
+    SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM("Home offset (mm):");
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
+      SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
+      SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
+      SERIAL_ECHOLN("");
     #ifdef PIDTEMP
       SERIAL_ECHO_START;
       SERIAL_ECHOLNPGM("PID settings:");
@@ -153,6 +161,7 @@ inline void EEPROM_RetrieveSettings(bool def=false)
       EEPROM_readAnything(i,max_xy_jerk);
       EEPROM_readAnything(i,max_z_jerk);
       EEPROM_readAnything(i,max_e_jerk);
+      EEPROM_readAnything(i,add_homeing);
       #ifndef PIDTEMP
         float Kp,Ki,Kd;
       #endif
@@ -183,6 +192,7 @@ inline void EEPROM_RetrieveSettings(bool def=false)
       max_xy_jerk=DEFAULT_XYJERK;
       max_z_jerk=DEFAULT_ZJERK;
       max_e_jerk=DEFAULT_EJERK;
+      add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
       SERIAL_ECHO_START;
       SERIAL_ECHOLN("Using Default settings:");
     }
diff --git a/Marlin/Makefile b/Marlin/Makefile
index fe77a2a..940bb16 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -170,6 +170,14 @@ ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
 ALL_CXXFLAGS = -mmcu=$(MCU) $(CXXFLAGS)
 ALL_ASFLAGS = -mmcu=$(MCU) -x assembler-with-cpp $(ASFLAGS)
 
+# set V=1 (eg, "make V=1") to print the full commands etc.
+ifneq ($V,1)
+ Pecho=@echo
+ P=@
+else
+ Pecho=@:
+ P=
+endif
 
 # Default target.
 all: sizeafter
@@ -178,7 +186,7 @@ build: applet elf hex
 
 # Creates the object directory
 applet: 
-	@mkdir -p applet
+	$P mkdir -p applet
 
 # the .cpp for Marlin depends on the .pde
 #applet/$(TARGET).cpp: $(TARGET).pde
@@ -189,10 +197,10 @@ applet/%.cpp: %.pde $(MAKEFILE)
 # Here is the "preprocessing".
 # It creates a .cpp file based with the same name as the .pde file.
 # On top of the new .cpp file comes the WProgram.h header.
-	@echo "  WR    $@"
-	@echo '#include "WProgram.h"' > $@
-	@echo '#include "$<"' >>$@
-	@echo '#include "$(ARDUINO)/main.cpp"' >> $@
+	$(Pecho) "  WR    $@"
+	$P echo '#include "WProgram.h"' > $@
+	$P echo '#include "$<"' >>$@
+	$P echo '#include "$(ARDUINO)/main.cpp"' >> $@
 
 elf: applet/$(TARGET).elf
 hex: applet/$(TARGET).hex
@@ -213,12 +221,13 @@ endif
 
 	# Display size of file.
 HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
-ELFSIZE = $(SIZE)  applet/$(TARGET).elf
+ELFSIZE = $(SIZE) --mcu=$(MCU) -C applet/$(TARGET).elf; \
+          $(SIZE)  applet/$(TARGET).elf
 sizebefore:
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
 
 sizeafter: build
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
+	$P if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(ELFSIZE); echo; fi
 
 
 # Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
@@ -241,8 +250,8 @@ extcoff: $(TARGET).elf
 .PRECIOUS: .o
 
 .elf.hex:
-	@echo "  COPY  $@"
-	@$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
+	$(Pecho) "  COPY  $@"
+	$P $(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
 
 .elf.eep:
 	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
@@ -258,29 +267,29 @@ extcoff: $(TARGET).elf
 
 	# Link: create ELF output file from library.
 applet/$(TARGET).elf: applet/$(TARGET).cpp applet/core.a Configuration.h
-	@echo "  CXX   $@"
-	@$(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
+	$(Pecho) "  CXX   $@"
+	$P $(CC) $(ALL_CXXFLAGS) -Wl,--gc-sections -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
 
 applet/core.a: $(OBJ)
-	@for i in $(OBJ); do echo "  AR    $$i"; $(AR) rcs applet/core.a $$i; done
+	$P for i in $(OBJ); do echo "  AR    $$i"; $(AR) rcs applet/core.a $$i; done
 
 applet/%.o: %.c Configuration.h Configuration_adv.h $(MAKEFILE)
-	@echo "  CC    $@"
-	@$(CC) -MMD -c $(ALL_CFLAGS) $< -o $@
+	$(Pecho) "  CC    $@"
+	$P $(CC) -MMD -c $(ALL_CFLAGS) $< -o $@
 
 applet/%.o: %.cpp Configuration.h Configuration_adv.h $(MAKEFILE)
-	@echo "  CXX   $@"
-	@$(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
+	$(Pecho) "  CXX   $@"
+	$P $(CXX) -MMD -c $(ALL_CXXFLAGS) $< -o $@
 
 
 # Target: clean project.
 clean:
-	@echo "  RM    applet/*"
-	@$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
+	$(Pecho) "  RM    applet/*"
+	$P $(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
 		applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/$(TARGET).cpp applet/core.a \
 		$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
-	@echo "  RMDIR applet/"
-	@rm -rf applet
+	$(Pecho) "  RMDIR applet/"
+	$P rm -rf applet
 
 
 .PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 4123634..937fabb 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -84,7 +84,11 @@ const char echomagic[] PROGMEM ="echo:";
 #define SERIAL_ECHOLN(x) SERIAL_PROTOCOLLN(x)
 #define SERIAL_ECHOLNPGM(x) SERIAL_PROTOCOLLNPGM(x)
 
-#define SERIAL_ECHOPAIR(name,value) {SERIAL_ECHOPGM(name);SERIAL_ECHO(value);}
+#define SERIAL_ECHOPAIR(name,value) (serial_echopair_P(PSTR(name),(value)))
+
+void serial_echopair_P(const char *s_P, float v);
+void serial_echopair_P(const char *s_P, double v);
+void serial_echopair_P(const char *s_P, unsigned long v);
 
 
 //things to write to serial from Programmemory. saves 400 to 2k of RAM.
@@ -122,8 +126,13 @@ void manage_inactivity(byte debug);
 #endif
 
 #if Z_ENABLE_PIN > -1
-  #define  enable_z() WRITE(Z_ENABLE_PIN, Z_ENABLE_ON)
-  #define disable_z() WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON)
+  #ifdef Z_DUAL_STEPPER_DRIVERS
+    #define  enable_z() { WRITE(Z_ENABLE_PIN, Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN, Z_ENABLE_ON); }
+    #define disable_z() { WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN,!Z_ENABLE_ON); }
+  #else
+    #define  enable_z() WRITE(Z_ENABLE_PIN, Z_ENABLE_ON)
+    #define disable_z() WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON)
+  #endif
 #else
   #define enable_z() ;
   #define disable_z() ;
@@ -169,6 +178,7 @@ bool IsStopped();
 
 void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.
 void prepare_arc_move(char isclockwise);
+void clamp_to_software_endstops(float target[3]);
 
 #ifdef FAST_PWM_FAN
 void setPwmFrequency(uint8_t pin, int val);
@@ -183,6 +193,8 @@ extern float homing_feedrate[];
 extern bool axis_relative_modes[];
 extern float current_position[NUM_AXIS] ;
 extern float add_homeing[3];
+extern float min_pos[3];
+extern float max_pos[3];
 extern unsigned char FanSpeed;
 
 // Handling multiple extruders pins
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 73f1f41..8ed36a5 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -1,3 +1,5 @@
+/* -*- c++ -*- */
+
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
@@ -141,6 +143,8 @@ volatile bool feedmultiplychanged=false;
 volatile int extrudemultiply=100; //100->1 200->2
 float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
 float add_homeing[3]={0,0,0};
+float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
+float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
 uint8_t active_extruder = 0;
 unsigned char FanSpeed=0;
 
@@ -199,6 +203,13 @@ bool Stopped=false;
 
 void get_arc_coordinates();
 
+void serial_echopair_P(const char *s_P, float v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, double v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+void serial_echopair_P(const char *s_P, unsigned long v)
+    { serialprintPGM(s_P); SERIAL_ECHO(v); }
+
 extern "C"{
   extern unsigned int __bss_end;
   extern unsigned int __heap_start;
@@ -541,32 +552,65 @@ bool code_seen(char code)
   return (strchr_pointer != NULL);  //Return True if a character was found
 }
 
-#define HOMEAXIS(LETTER) \
-  if ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))\
-    { \
-    current_position[LETTER##_AXIS] = 0; \
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); \
-    destination[LETTER##_AXIS] = 1.5 * LETTER##_MAX_LENGTH * LETTER##_HOME_DIR; \
-    feedrate = homing_feedrate[LETTER##_AXIS]; \
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
-    st_synchronize();\
-    \
-    current_position[LETTER##_AXIS] = 0;\
-    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
-    destination[LETTER##_AXIS] = -LETTER##_HOME_RETRACT_MM * LETTER##_HOME_DIR;\
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
-    st_synchronize();\
-    \
-    destination[LETTER##_AXIS] = 2*LETTER##_HOME_RETRACT_MM * LETTER##_HOME_DIR;\
-    feedrate = homing_feedrate[LETTER##_AXIS]/2 ;  \
-    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder); \
-    st_synchronize();\
-    \
-    current_position[LETTER##_AXIS] = LETTER##_HOME_POS;\
-    destination[LETTER##_AXIS] = current_position[LETTER##_AXIS];\
-    feedrate = 0.0;\
-    endstops_hit_on_purpose();\
+#define DEFINE_PGM_READ_ANY(type, reader)		\
+    static inline type pgm_read_any(const type *p)	\
+	{ return pgm_read_##reader##_near(p); }
+
+DEFINE_PGM_READ_ANY(float,       float);
+DEFINE_PGM_READ_ANY(signed char, byte);
+
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
+static const PROGMEM type array##_P[3] =		\
+    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
+static inline type array(int axis)			\
+    { return pgm_read_any(&array##_P[axis]); }
+
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
+XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
+XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
+
+static void axis_is_at_home(int axis) {
+  current_position[axis] = base_home_pos(axis) + add_homeing[axis];
+  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
+  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
+}
+
+static void homeaxis(int axis) {
+#define HOMEAXIS_DO(LETTER) \
+  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
+
+  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
+      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
+      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
+      0) {
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis];
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    current_position[axis] = 0;
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
+    feedrate = homing_feedrate[axis]/2 ; 
+    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+    st_synchronize();
+   
+    axis_is_at_home(axis);					
+    destination[axis] = current_position[axis];
+    feedrate = 0.0;
+    endstops_hit_on_purpose();
   }
+}
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
 void process_commands()
 {
@@ -676,8 +720,8 @@ void process_commands()
         plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
         st_synchronize();
     
-        current_position[X_AXIS] = X_HOME_POS;
-        current_position[Y_AXIS] = Y_HOME_POS;
+        axis_is_at_home(X_AXIS);
+        axis_is_at_home(Y_AXIS);
         plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         destination[X_AXIS] = current_position[X_AXIS];
         destination[Y_AXIS] = current_position[Y_AXIS];
@@ -1539,19 +1583,25 @@ void get_arc_coordinates()
    }
 }
 
-void prepare_move()
+void clamp_to_software_endstops(float target[3])
 {
   if (min_software_endstops) {
-    if (destination[X_AXIS] < X_MIN_POS) destination[X_AXIS] = X_MIN_POS;
-    if (destination[Y_AXIS] < Y_MIN_POS) destination[Y_AXIS] = Y_MIN_POS;
-    if (destination[Z_AXIS] < Z_MIN_POS) destination[Z_AXIS] = Z_MIN_POS;
+    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
+    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
+    if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
   }
 
   if (max_software_endstops) {
-    if (destination[X_AXIS] > X_MAX_POS) destination[X_AXIS] = X_MAX_POS;
-    if (destination[Y_AXIS] > Y_MAX_POS) destination[Y_AXIS] = Y_MAX_POS;
-    if (destination[Z_AXIS] > Z_MAX_POS) destination[Z_AXIS] = Z_MAX_POS;
+    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
+    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
+    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
   }
+}
+
+void prepare_move()
+{
+  clamp_to_software_endstops(destination);
+
   previous_millis_cmd = millis();  
   plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
   for(int8_t i=0; i < NUM_AXIS; i++) {
diff --git a/Marlin/motion_control.cpp b/Marlin/motion_control.cpp
index f11d8c8..7660905 100644
--- a/Marlin/motion_control.cpp
+++ b/Marlin/motion_control.cpp
@@ -125,17 +125,7 @@ void mc_arc(float *position, float *target, float *offset, uint8_t axis_0, uint8
     arc_target[axis_linear] += linear_per_segment;
     arc_target[E_AXIS] += extruder_per_segment;
 
-    if (min_software_endstops) {
-      if (arc_target[X_AXIS] < X_HOME_POS) arc_target[X_AXIS] = X_HOME_POS;
-      if (arc_target[Y_AXIS] < Y_HOME_POS) arc_target[Y_AXIS] = Y_HOME_POS;
-      if (arc_target[Z_AXIS] < Z_HOME_POS) arc_target[Z_AXIS] = Z_HOME_POS;
-    }
-
-    if (max_software_endstops) {
-      if (arc_target[X_AXIS] > X_MAX_LENGTH) arc_target[X_AXIS] = X_MAX_LENGTH;
-      if (arc_target[Y_AXIS] > Y_MAX_LENGTH) arc_target[Y_AXIS] = Y_MAX_LENGTH;
-      if (arc_target[Z_AXIS] > Z_MAX_LENGTH) arc_target[Z_AXIS] = Z_MAX_LENGTH;
-    }
+    clamp_to_software_endstops(arc_target);
     plan_buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], feed_rate, extruder);
     
   }
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 419ddb6..8d71937 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -267,6 +267,10 @@
 #define Z_MIN_PIN          18
 #define Z_MAX_PIN          19
 
+#define Z2_STEP_PIN        36
+#define Z2_DIR_PIN         34
+#define Z2_ENABLE_PIN      30
+
 #define E0_STEP_PIN        26
 #define E0_DIR_PIN         28
 #define E0_ENABLE_PIN      24
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index aba44e8..a222f15 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -421,6 +421,11 @@ ISR(TIMER1_COMPA_vect)
     
     if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
       WRITE(Z_DIR_PIN,INVERT_Z_DIR);
+      
+	  #ifdef Z_DUAL_STEPPER_DRIVERS
+        WRITE(Z2_DIR_PIN,INVERT_Z_DIR);
+      #endif
+      
       count_direction[Z_AXIS]=-1;
       CHECK_ENDSTOPS
       {
@@ -437,6 +442,11 @@ ISR(TIMER1_COMPA_vect)
     }
     else { // +direction
       WRITE(Z_DIR_PIN,!INVERT_Z_DIR);
+
+	  #ifdef Z_DUAL_STEPPER_DRIVERS
+        WRITE(Z2_DIR_PIN,!INVERT_Z_DIR);
+      #endif
+
       count_direction[Z_AXIS]=1;
       CHECK_ENDSTOPS
       {
@@ -552,9 +562,18 @@ ISR(TIMER1_COMPA_vect)
       counter_z += current_block->steps_z;
       if (counter_z > 0) {
         WRITE(Z_STEP_PIN, !INVERT_Z_STEP_PIN);
+        
+		#ifdef Z_DUAL_STEPPER_DRIVERS
+          WRITE(Z2_STEP_PIN, !INVERT_Z_STEP_PIN);
+        #endif
+        
         counter_z -= current_block->step_event_count;
         count_position[Z_AXIS]+=count_direction[Z_AXIS];
         WRITE(Z_STEP_PIN, INVERT_Z_STEP_PIN);
+        
+		#ifdef Z_DUAL_STEPPER_DRIVERS
+          WRITE(Z2_STEP_PIN, INVERT_Z_STEP_PIN);
+        #endif
       }
 
       #ifndef ADVANCE
@@ -704,6 +723,10 @@ void st_init()
   #endif
   #if Z_DIR_PIN > -1 
     SET_OUTPUT(Z_DIR_PIN);
+
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_DIR_PIN > -1)
+      SET_OUTPUT(Z2_DIR_PIN);
+    #endif
   #endif
   #if E0_DIR_PIN > -1 
     SET_OUTPUT(E0_DIR_PIN);
@@ -728,6 +751,11 @@ void st_init()
   #if (Z_ENABLE_PIN > -1)
     SET_OUTPUT(Z_ENABLE_PIN);
     if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
+    
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_ENABLE_PIN > -1)
+      SET_OUTPUT(Z2_ENABLE_PIN);
+      if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);
+    #endif
   #endif
   #if (E0_ENABLE_PIN > -1)
     SET_OUTPUT(E0_ENABLE_PIN);
@@ -802,6 +830,12 @@ void st_init()
     SET_OUTPUT(Z_STEP_PIN);
     WRITE(Z_STEP_PIN,INVERT_Z_STEP_PIN);
     if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
+    
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_STEP_PIN > -1)
+      SET_OUTPUT(Z2_STEP_PIN);
+      WRITE(Z2_STEP_PIN,INVERT_Z_STEP_PIN);
+      if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);
+    #endif
   #endif  
   #if (E0_STEP_PIN > -1) 
     SET_OUTPUT(E0_STEP_PIN);
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 395061c..7307b24 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -254,6 +254,11 @@ int getHeaterPower(int heater) {
 
 void manage_heater()
 {
+#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
+  static int bed_needs_heating=0;
+  static int bed_is_on=0;
+#endif
+
   #ifdef USE_WATCHDOG
     wd_reset();
   #endif
@@ -333,12 +338,26 @@ void manage_heater()
     }
   #endif
   
+#ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
+  if (bed_needs_heating){
+    if (bed_is_on==0)
+        WRITE(HEATER_BED_PIN,HIGH);
+    if (bed_is_on==1)
+        WRITE(HEATER_BED_PIN,LOW);
+    bed_is_on=(bed_is_on+1) % HEATER_BED_DUTY_CYCLE_DIVIDER;
+  }
+#endif
+
   if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
     return;
   previous_millis_bed_heater = millis();
   
   #if TEMP_BED_PIN > -1
   
+    #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
+    bed_needs_heating=0;
+    #endif
+
     #ifndef BED_LIMIT_SWITCHING
       // Check if temperature is within the correct range
       if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
@@ -348,6 +367,9 @@ void manage_heater()
         }
         else 
         {
+          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
+          bed_needs_heating=1;
+          #endif
           WRITE(HEATER_BED_PIN,HIGH);
         }
       }
@@ -364,6 +386,9 @@ void manage_heater()
         else 
           if(current_raw_bed <= target_bed_low_temp)
         {
+          #ifdef HEATER_BED_DUTY_CYCLE_DIVIDER
+          bed_needs_heating=1;
+          #endif
           WRITE(HEATER_BED_PIN,HIGH);
         }
       }
diff --git a/README.md b/README.md
index 86dd93d..fb2c189 100644
--- a/README.md
+++ b/README.md
@@ -152,6 +152,7 @@ Movement variables:
 *   M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 *   M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 *   M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+*   M206 - set home offsets.  This sets the X,Y,Z coordinates of the endstops (and is added to the {X,Y,Z}_HOME_POS configuration options (and is also added to the coordinates, if any, provided to G82, as with earlier firmware)
 *   M220 - set build speed mulitplying S:factor in percent ; aka "realtime tuneing in the gcode". So you can slow down if you have islands in one height-range, and speed up otherwise.
 *   M221 - set the extrude multiplying S:factor in percent
 *   M400 - Finish all buffered moves.

