commit d7cbb2eec964ba03d6910e6caf58c58e8f133732 (from f834bcd43a8d8a1050aa66536015faf9ab0c0efb)
Merge: f834bcd 7c7e30f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 7 19:18:03 2016 -0700

    Merge pull request #3403 from jbrazio/feature/stopwatch
    
    Print job timer rework

diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index feda4bb..8fb742e 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -65,6 +65,8 @@ typedef unsigned long millis_t;
 
 #include "WString.h"
 
+#include "stopwatch.h"
+
 #ifdef USBCON
   #if ENABLED(BLUETOOTH)
     #define MYSERIAL bluetoothSerial
@@ -356,8 +358,8 @@ extern bool axis_homed[3]; // axis[n].is_homed
   extern float retract_recover_length, retract_recover_length_swap, retract_recover_feedrate;
 #endif
 
-extern millis_t print_job_start_ms;
-extern millis_t print_job_stop_ms;
+// Print job timer
+extern Stopwatch print_job_timer;
 
 // Handling multiple extruders pins
 extern uint8_t active_extruder;
@@ -373,9 +375,4 @@ extern uint8_t active_extruder;
 
 extern void calculate_volumetric_multipliers();
 
-// Print job timer related functions
-millis_t print_job_timer();
-bool print_job_start(millis_t t = 0);
-bool print_job_stop(bool force = false);
-
 #endif //MARLIN_H
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 863b651..e59c8d4 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -298,8 +298,7 @@ const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
 millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000L;
-millis_t print_job_start_ms = 0; ///< Print job start time
-millis_t print_job_stop_ms = 0;  ///< Print job stop time
+Stopwatch print_job_timer = Stopwatch();
 static uint8_t target_extruder;
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
@@ -1011,9 +1010,9 @@ inline void get_serial_commands() {
       ) {
         if (card_eof) {
           SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-          print_job_stop(true);
+          print_job_timer.stop();
           char time[30];
-          millis_t t = print_job_timer();
+          millis_t t = print_job_timer.duration();
           int hours = t / 60 / 60, minutes = (t / 60) % 60;
           sprintf_P(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);
           SERIAL_ECHO_START;
@@ -3571,7 +3570,7 @@ inline void gcode_M17() {
    */
   inline void gcode_M24() {
     card.startFileprint();
-    print_job_start();
+    print_job_timer.start();
   }
 
   /**
@@ -3627,7 +3626,7 @@ inline void gcode_M17() {
  * M31: Get the time since the start of SD Print (or last M109)
  */
 inline void gcode_M31() {
-  millis_t t = print_job_timer();
+  millis_t t = print_job_timer.duration();
   int min = t / 60, sec = t % 60;
   char time[30];
   sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
@@ -3663,7 +3662,7 @@ inline void gcode_M31() {
       card.startFileprint();
 
       // Procedure calls count as normal print time.
-      if (!call_procedure) print_job_start();
+      if (!call_procedure) print_job_timer.start();
     }
   }
 
@@ -4031,15 +4030,33 @@ inline void gcode_M42() {
 #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST
 
 /**
+ * M75: Start print timer
+ */
+inline void gcode_M75() {
+  print_job_timer.start();
+}
+
+/**
+ * M76: Pause print timer
+ */
+inline void gcode_M76() {
+  print_job_timer.pause();
+}
+
+/**
+ * M77: Stop print timer
+ */
+inline void gcode_M77() {
+  print_job_timer.stop();
+}
+
+/**
  * M104: Set hot end temperature
  */
 inline void gcode_M104() {
   if (setTargetedHotend(104)) return;
   if (DEBUGGING(DRYRUN)) return;
 
-  // Start hook must happen before setTargetHotend()
-  print_job_start();
-
   if (code_seen('S')) {
     float temp = code_value();
     setTargetHotend(temp, target_extruder);
@@ -4048,10 +4065,24 @@ inline void gcode_M104() {
         setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);
     #endif
 
+    /**
+     * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
+     * stand by mode, for instance in a dual extruder setup, without affecting
+     * the running print timer.
+     */
+    if (temp <= (EXTRUDE_MINTEMP)/2) {
+      print_job_timer.stop();
+      LCD_MESSAGEPGM(WELCOME_MSG);
+    }
+    /**
+     * We do not check if the timer is already running because this check will
+     * be done for us inside the Stopwatch::start() method thus a running timer
+     * will not restart.
+     */
+    else print_job_timer.start();
+
     if (temp > degHotend(target_extruder)) LCD_MESSAGEPGM(MSG_HEATING);
   }
-
-  if (print_job_stop()) LCD_MESSAGEPGM(WELCOME_MSG);
 }
 
 #if HAS_TEMP_HOTEND || HAS_TEMP_BED
@@ -4179,9 +4210,6 @@ inline void gcode_M109() {
   if (setTargetedHotend(109)) return;
   if (DEBUGGING(DRYRUN)) return;
 
-  // Start hook must happen before setTargetHotend()
-  print_job_start();
-
   no_wait_for_cooling = code_seen('S');
   if (no_wait_for_cooling || code_seen('R')) {
     float temp = code_value();
@@ -4191,11 +4219,25 @@ inline void gcode_M109() {
         setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);
     #endif
 
+    /**
+     * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
+     * stand by mode, for instance in a dual extruder setup, without affecting
+     * the running print timer.
+     */
+    if (temp <= (EXTRUDE_MINTEMP)/2) {
+      print_job_timer.stop();
+      LCD_MESSAGEPGM(WELCOME_MSG);
+    }
+    /**
+     * We do not check if the timer is already running because this check will
+     * be done for us inside the Stopwatch::start() method thus a running timer
+     * will not restart.
+     */
+    else print_job_timer.start();
+
     if (temp > degHotend(target_extruder)) LCD_MESSAGEPGM(MSG_HEATING);
   }
 
-  if (print_job_stop()) LCD_MESSAGEPGM(WELCOME_MSG);
-
   #if ENABLED(AUTOTEMP)
     autotemp_enabled = code_seen('F');
     if (autotemp_enabled) autotemp_factor = code_value();
@@ -6223,6 +6265,18 @@ void process_next_command() {
           break;
       #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST
 
+      case 75: // Start print timer
+        gcode_M75();
+        break;
+
+      case 76: // Pause print timer
+        gcode_M76();
+        break;
+
+      case 77: // Stop print timer
+        gcode_M77();
+        break;
+
       #if ENABLED(M100_FREE_MEMORY_WATCHER)
         case 100:
           gcode_M100();
@@ -7639,50 +7693,3 @@ void calculate_volumetric_multipliers() {
   for (int i = 0; i < EXTRUDERS; i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
-
-/**
- * Start the print job timer
- *
- * The print job is only started if all extruders have their target temp at zero
- * otherwise the print job timew would be reset everytime a M109 is received.
- *
- * @param t start timer timestamp
- *
- * @return true if the timer was started at function call
- */
-bool print_job_start(millis_t t /* = 0 */) {
-  for (int i = 0; i < EXTRUDERS; i++) if (degTargetHotend(i) > 0) return false;
-  print_job_start_ms = (t) ? t : millis();
-  print_job_stop_ms = 0;
-  return true;
-}
-
-/**
- * Check if the running print job has finished and stop the timer
- *
- * When the target temperature for all extruders is zero then we assume that the
- * print job has finished printing. There are some special conditions under which
- * this assumption may not be valid: If during a print job for some reason the
- * user decides to bring a nozzle temp down and only then heat the other afterwards.
- *
- * @param force stops the timer ignoring all pre-checks
- *
- * @return boolean true if the print job has finished printing
- */
-bool print_job_stop(bool force /* = false */) {
-  if (!print_job_start_ms) return false;
-  if (!force) for (int i = 0; i < EXTRUDERS; i++) if (degTargetHotend(i) > 0) return false;
-  print_job_stop_ms = millis();
-  return true;
-}
-
-/**
- * Output the print job timer in seconds
- *
- * @return the number of seconds
- */
-millis_t print_job_timer() {
-  if (!print_job_start_ms) return 0;
-  return (((print_job_stop_ms > print_job_start_ms)
-    ? print_job_stop_ms : millis()) - print_job_start_ms) / 1000;
-}
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 4807fff..4da13cd 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -334,9 +334,8 @@ static void lcd_implementation_status_screen() {
     }
 
     u8g.setPrintPos(80,48);
-    if (print_job_start_ms != 0) {
-      uint16_t time = (((print_job_stop_ms > print_job_start_ms)
-                       ? print_job_stop_ms : millis()) - print_job_start_ms) / 60000;
+    uint16_t time = print_job_timer.duration() / 60;
+    if (time != 0) {
       lcd_print(itostr2(time/60));
       lcd_print(':');
       lcd_print(itostr2(time%60));
diff --git a/Marlin/stopwatch.cpp b/Marlin/stopwatch.cpp
new file mode 100644
index 0000000..5bc0a28
--- /dev/null
+++ b/Marlin/stopwatch.cpp
@@ -0,0 +1,77 @@
+/*
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Marlin.h"
+#include "stopwatch.h"
+
+Stopwatch::Stopwatch() {
+   this->reset();
+ }
+
+void Stopwatch::stop() {
+  if (DEBUGGING(INFO)) SERIAL_ECHOLNPGM("Stopwatch::stop()");
+  if (!this->isRunning()) return;
+
+  this->status = STPWTCH_STOPPED;
+  this->stopTimestamp = millis();
+}
+
+void Stopwatch::pause() {
+  if (DEBUGGING(INFO)) SERIAL_ECHOLNPGM("Stopwatch::pause()");
+  if (!this->isRunning()) return;
+
+  this->status = STPWTCH_PAUSED;
+  this->stopTimestamp = millis();
+}
+
+void Stopwatch::start() {
+  if (DEBUGGING(INFO)) SERIAL_ECHOLNPGM("Stopwatch::start()");
+  if (this->isRunning()) return;
+
+  if (this->isPaused()) this->accumulator = this->duration();
+  else this->reset();
+
+  this->status = STPWTCH_RUNNING;
+  this->startTimestamp = millis();
+}
+
+void Stopwatch::reset() {
+  if (DEBUGGING(INFO)) SERIAL_ECHOLNPGM("Stopwatch::reset()");
+
+  this->status = STPWTCH_STOPPED;
+  this->startTimestamp = 0;
+  this->stopTimestamp = 0;
+  this->accumulator = 0;
+}
+
+bool Stopwatch::isRunning() {
+  return (this->status == STPWTCH_RUNNING) ? true : false;
+}
+
+bool Stopwatch::isPaused() {
+  return (this->status == STPWTCH_PAUSED) ? true : false;
+}
+
+uint16_t Stopwatch::duration() {
+  return (((this->isRunning()) ? millis() : this->stopTimestamp)
+          - this->startTimestamp) / 1000 + this->accumulator;
+}
diff --git a/Marlin/stopwatch.h b/Marlin/stopwatch.h
new file mode 100644
index 0000000..d6ef8a7
--- /dev/null
+++ b/Marlin/stopwatch.h
@@ -0,0 +1,99 @@
+/*
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef STOPWATCH_H
+#define STOPWATCH_H
+
+enum StopwatchStatus {
+  STPWTCH_STOPPED = 0x0,
+  STPWTCH_RUNNING = 0x1,
+  STPWTCH_PAUSED  = 0x2
+};
+
+/**
+ * @brief Stopwatch class
+ * @details This class acts as a timer proving stopwatch functionality including
+ * the ability to pause the running time counter.
+ */
+class Stopwatch {
+  private:
+    StopwatchStatus status;
+    uint16_t accumulator;
+    uint32_t startTimestamp;
+    uint32_t stopTimestamp;
+
+  public:
+    /**
+     * @brief Class constructor
+     */
+    Stopwatch();
+
+    /**
+     * @brief Stops the stopwatch
+     * @details Stops the running timer, it will silently ignore the request if
+     * no timer is currently running.
+     */
+    void stop();
+
+    /**
+     * @brief Pauses the stopwatch
+     * @details Pauses the running timer, it will silently ignore the request if
+     * no timer is currently running.
+     */
+    void pause();
+
+    /**
+     * @brief Starts the stopwatch
+     * @details Starts the timer, it will silently ignore the request if the
+     * timer is already running.
+     */
+    void start();
+
+    /**
+     * @brief Resets the stopwatch
+     * @details Resets all settings to their default values.
+     */
+    void reset();
+
+    /**
+     * @brief Checks if the timer is running
+     * @details Returns true if the timer is currently running, false otherwise.
+     * @return bool
+     */
+    bool isRunning();
+
+    /**
+     * @brief Checks if the timer is paused
+     * @details Returns true if the timer is currently paused, false otherwise.
+     * @return bool
+     */
+    bool isPaused();
+
+    /**
+     * @brief Gets the running time
+     * @details Returns the total number of seconds the timer has been running.
+     * @return uint16_t
+     */
+    uint16_t duration();
+};
+
+#endif //STOPWATCH_H
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index a689836..d9a5895 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1175,7 +1175,7 @@ void disable_all_heaters() {
   setTargetBed(0);
 
   // If all heaters go down then for sure our print job has stopped
-  print_job_stop(true);
+  print_job_timer.stop();
 
   #define DISABLE_HEATER(NR) { \
     setTargetHotend(NR, 0); \
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 5fc0316..26399fb 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -716,9 +716,9 @@ static void lcd_implementation_status_screen() {
 
     lcd.setCursor(LCD_WIDTH - 6, 2);
     lcd.print(LCD_STR_CLOCK[0]);
-    if (print_job_start_ms != 0) {
-      uint16_t time = (((print_job_stop_ms > print_job_start_ms)
-                       ? print_job_stop_ms : millis()) - print_job_start_ms) / 60000;
+
+    uint16_t time = print_job_timer.duration() / 60;
+    if (time != 0) {
       lcd.print(itostr2(time / 60));
       lcd.print(':');
       lcd.print(itostr2(time % 60));

commit d7cbb2eec964ba03d6910e6caf58c58e8f133732 (from 7c7e30f4cc8088b3c54347e656f7e433fb3b61af)
Merge: f834bcd 7c7e30f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 7 19:18:03 2016 -0700

    Merge pull request #3403 from jbrazio/feature/stopwatch
    
    Print job timer rework

diff --git a/.travis.yml b/.travis.yml
index a7c220d..a2e58f2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,12 +1,13 @@
 ---
 language: c
-
+  #
 before_install:
   # Travis runs a detached head. We need to find the current branch
   - git checkout `git branch --contains HEAD | grep -v '*'`
   # Also tags for the root(s) of the minor version(s)
   - git fetch origin --tags
   - mkdir ~/bin
+  #
 install:
   # Install arduino 1.6.4
   - wget http://downloads-02.arduino.cc/arduino-1.6.4-linux64.tar.xz
@@ -26,144 +27,215 @@ install:
   - mv LiquidCrystal_I2C/LiquidCrystal_I2C /usr/local/share/arduino/libraries/LiquidCrystal_I2C
   - git clone https://github.com/lincomatic/LiquidTWI2.git
   - mv LiquidTWI2 /usr/local/share/arduino/libraries/LiquidTWI2
+  #
 before_script:
   # arduino requires an X server even with command line
   # https://github.com/arduino/Arduino/issues/1981
   - Xvfb :1 -screen 0 1024x768x16 &> xvfb.log &
   # change back to home directory for compiling
   - cd $TRAVIS_BUILD_DIR
+  #
 script:
-  # build default config
-  - build_marlin
+  #
   # Backup Configuration.h, Configuration_adv.h, and pins_RAMPS_14.h
+  #
   - cp Marlin/Configuration.h Marlin/Configuration.h.backup
   - cp Marlin/Configuration_adv.h Marlin/Configuration_adv.h.backup
   - cp Marlin/pins_RAMPS_14.h Marlin/pins_RAMPS_14.h.backup
-  # add sensor for bed
+  #
+  # Build with the default configurations
+  #
+  - build_marlin
+  #
+  # Test heated bed temperature sensor
+  #
   - opt_set TEMP_SENSOR_BED 1
   - build_marlin
-  # change extruder numbers from 1 to 2
+  #
+  # Test 2 extruders on basic RAMPS 1.4
+  #
   - opt_set MOTHERBOARD BOARD_RAMPS_14_EEB
   - opt_set EXTRUDERS 2
   - opt_set TEMP_SENSOR_1 1
-  #- cat Marlin/Configuration.h
   - build_marlin
-  # change extruder numbers from 2 to 3, needs to be a board with 3 extruders defined in pins.h 
+  #
+  # Test 3 extruders on RUMBA (can use any board with >=3 extruders defined)
+  #
   - opt_set MOTHERBOARD BOARD_RUMBA
   - opt_set EXTRUDERS 3
   - opt_set TEMP_SENSOR_2 1
   - build_marlin
-  # enable PIDTEMPBED 
+  #
+  # Test PIDTEMPBED
+  #
   - restore_configs
   - opt_enable PIDTEMPBED
   - build_marlin
-  # enable AUTO_BED_LEVELING
+  #
+  # Test AUTO_BED_LEVELING & DEBUG_LEVELING_FEATURE
+  #
   - restore_configs
-  - opt_enable ENABLE_AUTO_BED_LEVELING
+  - opt_enable ENABLE_AUTO_BED_LEVELING DEBUG_LEVELING_FEATURE
   - build_marlin
-  # enable AUTO_BED_LEVELING with servos
-  - restore_configs
-  - opt_enable ENABLE_AUTO_BED_LEVELING NUM_SERVOS Z_ENDSTOP_SERVO_NR SERVO_ENDSTOP_ANGLES DEACTIVATE_SERVOS_AFTER_MOVE
+  #
+  # Test AUTO_BED_LEVELING & DEBUG_LEVELING_FEATURE with Servos
+  #
+  - opt_enable NUM_SERVOS Z_ENDSTOP_SERVO_NR SERVO_ENDSTOP_ANGLES DEACTIVATE_SERVOS_AFTER_MOVE
   - build_marlin
-  # enable EEPROM_SETTINGS & EEPROM_CHITCHAT
+  #
+  # Test EEPROM_SETTINGS & EEPROM_CHITCHAT
+  #
   - restore_configs
   - opt_enable EEPROM_SETTINGS EEPROM_CHITCHAT
   - build_marlin
+  #
   ### LCDS ###
+  #
+  #
   # ULTIMAKERCONTROLLER
+  #
   - restore_configs
   - opt_enable ULTIMAKERCONTROLLER
   - build_marlin
+  #
   # MAKRPANEL
-  # Needs to use melzi and sanguino hardware
+  # Needs to use Melzi and Sanguino hardware
+  #
   #- restore_configs
   #- opt_enable MAKRPANEL
   #- build_marlin
+  #
   # REPRAP_DISCOUNT_SMART_CONTROLLER
+  #
   - restore_configs
   - opt_enable REPRAP_DISCOUNT_SMART_CONTROLLER SDSUPPORT
   - build_marlin
+  #
   # G3D_PANEL
+  #
   - restore_configs
   - opt_enable G3D_PANEL SDSUPPORT
   - build_marlin
+  #
   # REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+  #
   - restore_configs
-  - opt_enable REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+  - opt_enable REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER SDSUPPORT
   - build_marlin
+  #
   # REPRAPWORLD_KEYPAD
+  #
   # Cant find configuration details to get it to compile
   #- restore_configs
   #- opt_enable ULTRA_LCD REPRAPWORLD_KEYPAD REPRAPWORLD_KEYPAD_MOVE_STEP
   #- build_marlin
+  #
   # RA_CONTROL_PANEL
+  #
   - restore_configs
   - opt_enable RA_CONTROL_PANEL
   - build_marlin
+  #
   ### I2C PANELS ###
+  #
   # LCD_I2C_SAINSMART_YWROBOT
   # Failing at the moment needs different library 
   #- restore_configs
   #- opt_enable LCD_I2C_SAINSMART_YWROBOT
   #- build_marlin
+  #
   # LCD_I2C_PANELOLU2
+  #
   - restore_configs
   - opt_enable LCD_I2C_PANELOLU2
   - build_marlin
+  #
   # LCD_I2C_VIKI
+  #
   - restore_configs
   - opt_enable LCD_I2C_VIKI
   - build_marlin
+  #
   # LCM1602
+  #
   - restore_configs
   - opt_enable LCM1602
   - build_marlin
+  #
   # Enable FILAMENTCHANGEENABLE
+  #
   - restore_configs
-  - opt_enable FILAMENTCHANGEENABLE
+  - opt_enable FILAMENTCHANGEENABLE ULTIMAKERCONTROLLER
   - build_marlin
+  #
   # Enable filament sensor
+  #
   - restore_configs
   - opt_enable FILAMENT_WIDTH_SENSOR
   - build_marlin
+  #
   # Enable filament sensor with LCD display
-  - restore_configs
-  - opt_enable ULTIMAKERCONTROLLER FILAMENT_WIDTH_SENSOR FILAMENT_LCD_DISPLAY
+  #
+  - opt_enable ULTIMAKERCONTROLLER FILAMENT_LCD_DISPLAY
   - build_marlin
+  #
   # Enable COREXY
+  #
   - restore_configs
   - opt_enable COREXY
   - build_marlin
+  #
   # Enable COREXZ
+  #
   - restore_configs
   - opt_enable COREXZ
   - build_marlin
+  #
   # Enable Z_DUAL_STEPPER_DRIVERS, Z_DUAL_ENDSTOPS
+  #
   - restore_configs
   - opt_enable_adv Z_DUAL_STEPPER_DRIVERS Z_DUAL_ENDSTOPS
   - pins_set RAMPS_14 X_MAX_PIN -1
   - opt_set_adv Z2_MAX_PIN 2
   - build_marlin
-  - restore_configs
+  #
+  #
   ######## Example Configurations ##############
+  #
   # Delta Config (generic)
+  - restore_configs
   - use_example_configs delta/generic
   - build_marlin
+  #
   # Delta Config (generic) + ABL + ALLEN_KEY
+  #
   - use_example_configs delta/generic
   - opt_disable DISABLE_MIN_ENDSTOPS
   - opt_enable AUTO_BED_LEVELING_FEATURE Z_PROBE_ALLEN_KEY
   - build_marlin
+  #
   # Delta Config (Mini Kossel)
+  #
   - use_example_configs delta/kossel_mini
   - build_marlin
+  #
   # Makibox Config  need to check board type for Teensy++ 2.0
+  #
   #- use_example_configs makibox
   #- build_marlin
+  #
   # SCARA Config
+  #
   - use_example_configs SCARA
   - build_marlin
+  #
   # tvrrug Config need to check board type for sanguino atmega644p
+  #
   #- use_example_configs tvrrug/Round2
   #- build_marlin
+  #
+  #
   ######## Board Types #############
+  #
+  # To be added in nightly test branch
+  #
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 1e77b3c..8fb742e 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -343,8 +343,7 @@ extern bool axis_homed[3]; // axis[n].is_homed
   extern bool filament_sensor;  //indicates that filament sensor readings should control extrusion
   extern float filament_width_meas; //holds the filament diameter as accurately measured
   extern int8_t measurement_delay[];  //ring buffer to delay measurement
-  extern int delay_index1, delay_index2;  //ring buffer index. used by planner, temperature, and main code
-  extern float delay_dist; //delay distance counter
+  extern int filwidth_delay_index1, filwidth_delay_index2;  //ring buffer index. used by planner, temperature, and main code
   extern int meas_delay_cm; //delay distance
 #endif
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 85cfd02..e59c8d4 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -410,9 +410,8 @@ static uint8_t target_extruder;
   bool filament_sensor = false;  //M405 turns on filament_sensor control, M406 turns it off
   float filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA; //Stores the measured filament diameter
   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1]; //ring buffer to delay measurement  store extruder factor after subtracting 100
-  int delay_index1 = 0;  //index into ring buffer
-  int delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized
-  float delay_dist = 0; //delay distance counter
+  int filwidth_delay_index1 = 0;  //index into ring buffer
+  int filwidth_delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized
   int meas_delay_cm = MEASUREMENT_DELAY_CM;  //distance delay setting
 #endif
 
@@ -1163,9 +1162,16 @@ XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   void print_xyz(const char* prefix, const float xyz[]) {
     print_xyz(prefix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
   }
+  #define DEBUG_POS(PREFIX,VAR) do{ SERIAL_ECHOPGM(PREFIX); print_xyz(" > " STRINGIFY(VAR), VAR); }while(0)
 #endif
 
 static void set_axis_is_at_home(AxisEnum axis) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("set_axis_is_at_home(", (unsigned long)axis);
+      SERIAL_ECHOLNPGM(") >>>");
+    }
+  #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS) {
@@ -1233,17 +1239,27 @@ static void set_axis_is_at_home(AxisEnum axis) {
     max_pos[axis] = base_max_pos(axis) + home_offset[axis];
 
     #if ENABLED(AUTO_BED_LEVELING_FEATURE) && Z_HOME_DIR < 0
-      if (axis == Z_AXIS) current_position[Z_AXIS] -= zprobe_zoffset;
+      if (axis == Z_AXIS) {
+        current_position[Z_AXIS] -= zprobe_zoffset;
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("> zprobe_zoffset==", zprobe_zoffset);
+        #endif
+      }
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("set_axis_is_at_home ", (unsigned long)axis);
-        SERIAL_ECHOPAIR(" > (home_offset[axis]==", home_offset[axis]);
-        print_xyz(") > current_position", current_position);
+        SERIAL_ECHOPAIR("> home_offset[axis]==", home_offset[axis]);
+        DEBUG_POS("", current_position);
       }
     #endif
   }
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", (unsigned long)axis);
+      SERIAL_ECHOLNPGM(")");
+    }
+  #endif
 }
 
 /**
@@ -1289,9 +1305,7 @@ static void setup_for_endstop_move() {
   feedrate_multiplier = 100;
   refresh_cmd_timeout();
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM("setup_for_endstop_move > enable_endstops(true)");
-    }
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("setup_for_endstop_move > enable_endstops(true)");
   #endif
   enable_endstops(true);
 }
@@ -1304,9 +1318,7 @@ static void setup_for_endstop_move() {
      */
     void prepare_move_raw() {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("prepare_move_raw > destination", destination);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_move_raw", destination);
       #endif
       refresh_cmd_timeout();
       calculate_delta(destination);
@@ -1336,9 +1348,7 @@ static void setup_for_endstop_move() {
         current_position[Z_AXIS] = corrected_position.z;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("set_bed_level_equation_lsq > current_position", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("set_bed_level_equation_lsq", current_position);
         #endif
 
         sync_plan_position();
@@ -1371,9 +1381,7 @@ static void setup_for_endstop_move() {
       current_position[Z_AXIS] = corrected_position.z;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("set_bed_level_equation_3pts > current_position", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("set_bed_level_equation_3pts", current_position);
       #endif
 
       sync_plan_position();
@@ -1395,9 +1403,7 @@ static void setup_for_endstop_move() {
       long start_steps = st_get_position(Z_AXIS);
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("run_z_probe (DELTA) 1");
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("run_z_probe (DELTA) 1");
       #endif
 
       // move down slowly until you find the bed
@@ -1416,9 +1422,7 @@ static void setup_for_endstop_move() {
       current_position[Z_AXIS] = mm;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("run_z_probe (DELTA) 2 > current_position", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe (DELTA) 2", current_position);
       #endif
 
       sync_plan_position_delta();
@@ -1459,9 +1463,7 @@ static void setup_for_endstop_move() {
       sync_plan_position();
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("run_z_probe > current_position", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe", current_position);
       #endif
 
     #endif // !DELTA
@@ -1475,9 +1477,7 @@ static void setup_for_endstop_move() {
     float oldFeedRate = feedrate;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("do_blocking_move_to", x, y, z);
-      }
+      if (DEBUGGING(LEVELING)) print_xyz("do_blocking_move_to", x, y, z);
     #endif
 
     #if ENABLED(DELTA)
@@ -1528,9 +1528,7 @@ static void setup_for_endstop_move() {
 
   static void clean_up_after_endstop_move() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("clean_up_after_endstop_move > ENDSTOPS_ONLY_FOR_HOMING > endstops_not_homing()");
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("clean_up_after_endstop_move > ENDSTOPS_ONLY_FOR_HOMING > endstops_not_homing()");
     #endif
     endstops_not_homing();
     feedrate = saved_feedrate;
@@ -1543,9 +1541,7 @@ static void setup_for_endstop_move() {
   static void deploy_z_probe() {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("deploy_z_probe > current_position", current_position);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_POS("deploy_z_probe", current_position);
     #endif
 
     if (z_probe_is_active) return;
@@ -1641,9 +1637,7 @@ static void setup_for_endstop_move() {
       UNUSED(doRaise);
     #endif
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("stow_z_probe > current_position", current_position);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_POS("stow_z_probe", current_position);
     #endif
 
     if (!z_probe_is_active) return;
@@ -1755,7 +1749,7 @@ static void setup_for_endstop_move() {
         SERIAL_ECHOLNPGM("probe_pt >>>");
         SERIAL_ECHOPAIR("> ProbeAction:", (unsigned long)probe_action);
         SERIAL_EOL;
-        print_xyz("> current_position", current_position);
+        DEBUG_POS("", current_position);
       }
     #endif
 
@@ -1785,9 +1779,7 @@ static void setup_for_endstop_move() {
     #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
       if (probe_action & ProbeDeploy) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> ProbeDeploy");
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeDeploy");
         #endif
         deploy_z_probe();
       }
@@ -1799,9 +1791,7 @@ static void setup_for_endstop_move() {
     #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
       if (probe_action & ProbeStow) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
         #endif
         stow_z_probe();
       }
@@ -1818,9 +1808,7 @@ static void setup_for_endstop_move() {
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("<<< probe_pt");
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
     #endif
 
     return measured_z;
@@ -1885,9 +1873,7 @@ static void setup_for_endstop_move() {
      */
     void reset_bed_level() {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("reset_bed_level");
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
       #endif
       for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
         for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
@@ -1937,8 +1923,8 @@ static void setup_for_endstop_move() {
   static void dock_sled(bool dock, int offset = 0) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("dock_sled", dock);
-        SERIAL_EOL;
+        SERIAL_ECHOPAIR("dock_sled(", dock);
+        SERIAL_ECHOLNPGM(")");
       }
     #endif
 
@@ -1983,8 +1969,7 @@ static void homeaxis(AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> homeaxis(", (unsigned long)axis);
-      SERIAL_CHAR(')');
-      SERIAL_EOL;
+      SERIAL_ECHOLNPGM(")");
     }
   #endif
   #define HOMEAXIS_DO(LETTER) \
@@ -2049,9 +2034,7 @@ static void homeaxis(AxisEnum axis) {
     sync_plan_position();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("> enable_endstops(false)");
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> enable_endstops(false)");
     #endif
     enable_endstops(false); // Disable endstops while moving away
 
@@ -2061,9 +2044,7 @@ static void homeaxis(AxisEnum axis) {
     st_synchronize();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("> enable_endstops(true)");
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> enable_endstops(true)");
     #endif
     enable_endstops(true); // Enable endstops for next homing move
 
@@ -2076,9 +2057,7 @@ static void homeaxis(AxisEnum axis) {
     st_synchronize();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("> TRIGGER ENDSTOP > current_position", current_position);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> TRIGGER ENDSTOP", current_position);
     #endif
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
@@ -2110,9 +2089,7 @@ static void homeaxis(AxisEnum axis) {
       // retrace by the amount specified in endstop_adj
       if (endstop_adj[axis] * axis_home_dir < 0) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> enable_endstops(false)");
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> enable_endstops(false)");
         #endif
         enable_endstops(false); // Disable endstops while moving away
         sync_plan_position();
@@ -2120,15 +2097,13 @@ static void homeaxis(AxisEnum axis) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOPAIR("> endstop_adj = ", endstop_adj[axis]);
-            print_xyz(" > destination", destination);
+            DEBUG_POS("", destination);
           }
         #endif
         line_to_destination();
         st_synchronize();
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> enable_endstops(true)");
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> enable_endstops(true)");
         #endif
         enable_endstops(true); // Enable endstops for next homing move
       }
@@ -2147,9 +2122,7 @@ static void homeaxis(AxisEnum axis) {
     sync_plan_position();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("> AFTER set_axis_is_at_home > current_position", current_position);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
     destination[axis] = current_position[axis];
@@ -2162,9 +2135,7 @@ static void homeaxis(AxisEnum axis) {
     #if ENABLED(Z_PROBE_SLED) || SERVO_LEVELING || ENABLED(FIX_MOUNTED_PROBE)
       if (axis == Z_AXIS && axis_home_dir < 0) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> SERVO_LEVELING > " STRINGIFY(_Z_STOW));
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_LEVELING > " STRINGIFY(_Z_STOW));
         #endif
         _Z_STOW;
       }
@@ -2174,9 +2145,7 @@ static void homeaxis(AxisEnum axis) {
     #if HAS_SERVO_ENDSTOPS
       if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
-          }
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
         #endif
         servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);
         if (_Z_PROBE_SUBTEST) z_probe_is_active = false;
@@ -2188,8 +2157,7 @@ static void homeaxis(AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", (unsigned long)axis);
-      SERIAL_CHAR(')');
-      SERIAL_EOL;
+      SERIAL_ECHOLNPGM(")");
     }
   #endif
 }
@@ -2427,9 +2395,7 @@ inline void gcode_G4() {
 inline void gcode_G28() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM("gcode_G28 >>>");
-    }
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("gcode_G28 >>>");
   #endif
 
   // Wait for planner moves to finish!
@@ -2490,9 +2456,7 @@ inline void gcode_G28() {
     sync_plan_position_delta();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        print_xyz("(DELTA) > current_position", current_position);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(DELTA)", current_position);
     #endif
 
   #else // NOT DELTA
@@ -2508,9 +2472,7 @@ inline void gcode_G28() {
       if (home_all_axis || homeZ) {
         HOMEAXIS(Z);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> HOMEAXIS(Z) > current_position", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
         #endif
       }
 
@@ -2524,8 +2486,8 @@ inline void gcode_G28() {
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOPAIR("Raise Z (before homing) to ", (float)(MIN_Z_HEIGHT_FOR_HOMING));
             SERIAL_EOL;
-            print_xyz("> (home_all_axis || homeZ) > current_position", current_position);
-            print_xyz("> (home_all_axis || homeZ) > destination", destination);
+            DEBUG_POS("> (home_all_axis || homeZ)", current_position);
+            DEBUG_POS("> (home_all_axis || homeZ)", destination);
           }
         #endif
         line_to_destination();
@@ -2569,9 +2531,7 @@ inline void gcode_G28() {
         sync_plan_position();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> QUICK_HOME > current_position 1", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> QUICK_HOME 1", current_position);
         #endif
 
         destination[X_AXIS] = current_position[X_AXIS];
@@ -2588,9 +2548,7 @@ inline void gcode_G28() {
         #endif
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> QUICK_HOME > current_position 2", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> QUICK_HOME 2", current_position);
         #endif
       }
 
@@ -2619,9 +2577,7 @@ inline void gcode_G28() {
         HOMEAXIS(X);
       #endif
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("> homeX", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
       #endif
     }
 
@@ -2630,9 +2586,7 @@ inline void gcode_G28() {
       if (home_all_axis || homeY) {
         HOMEAXIS(Y);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> homeY", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
         #endif
       }
     #endif
@@ -2671,8 +2625,8 @@ inline void gcode_G28() {
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
-                print_xyz("> Z_SAFE_HOMING > home_all_axis > current_position", current_position);
-                print_xyz("> Z_SAFE_HOMING > home_all_axis > destination", destination);
+                DEBUG_POS("> Z_SAFE_HOMING > home_all_axis", current_position);
+                DEBUG_POS("> Z_SAFE_HOMING > home_all_axis", destination);
               }
             #endif
 
@@ -2735,9 +2689,7 @@ inline void gcode_G28() {
         #endif // !Z_SAFE_HOMING
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> (home_all_axis || homeZ) > final", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all_axis || homeZ) > final", current_position);
         #endif
 
       } // home_all_axis || homeZ
@@ -2753,12 +2705,12 @@ inline void gcode_G28() {
   #endif
 
   #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
+    enable_endstops(false);
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING enable_endstops(false)");
       }
     #endif
-    enable_endstops(false);
   #endif
 
   // For mesh leveling move back to Z=0
@@ -2773,9 +2725,7 @@ inline void gcode_G28() {
       line_to_destination();
       st_synchronize();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("mbl_was_active > current_position", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("mbl_was_active", current_position);
       #endif
     }
   #endif
@@ -2998,6 +2948,7 @@ inline void gcode_G28() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("gcode_G29 >>>");
+        DEBUG_POS("", current_position);
       }
     #endif
 
@@ -3216,9 +3167,7 @@ inline void gcode_G28() {
       } //yProbe
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          print_xyz("> probing complete > current_position", current_position);
-        }
+        if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
       #endif
 
       clean_up_after_endstop_move();
@@ -3415,9 +3364,7 @@ inline void gcode_G28() {
         sync_plan_position();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            print_xyz("> corrected Z in G29", current_position);
-          }
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> corrected Z in G29", current_position);
         #endif
       }
 
@@ -4421,7 +4368,7 @@ inline void gcode_M111() {
     uint8_t comma = 0;
     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
       if (TEST(marlin_debug_flags, i)) {
-        if (comma++) SERIAL_CHAR('|');
+        if (comma++) SERIAL_CHAR(',');
         serialprintPGM((char*)pgm_read_word(&(debug_strings[i])));
       }
     }
@@ -5522,13 +5469,13 @@ inline void gcode_M400() { st_synchronize(); }
     if (code_seen('D')) meas_delay_cm = code_value();
     NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
 
-    if (delay_index2 == -1) { //initialize the ring buffer if it has not been done since startup
+    if (filwidth_delay_index2 == -1) { // Initialize the ring buffer if not done since startup
       int temp_ratio = widthFil_to_size_ratio();
 
-      for (delay_index1 = 0; delay_index1 < (int)COUNT(measurement_delay); ++delay_index1)
-        measurement_delay[delay_index1] = temp_ratio - 100;  //subtract 100 to scale within a signed byte
+      for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
+        measurement_delay[i] = temp_ratio - 100;  // Subtract 100 to scale within a signed byte
 
-      delay_index1 = delay_index2 = 0;
+      filwidth_delay_index1 = filwidth_delay_index2 = 0;
     }
 
     filament_sensor = true;
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 75bb489..b1a9c7b 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -368,27 +368,29 @@
  * Test Heater, Temp Sensor, and Extruder Pins; Sensor Type must also be set.
  */
 #if EXTRUDERS > 3
-  #if !HAS_HEATER_3
+  #if TEMP_SENSOR_3 == 0
+    #error TEMP_SENSOR_3 is required with 4 EXTRUDERS.
+  #elif !HAS_HEATER_3
     #error HEATER_3_PIN not defined for this board.
   #elif !PIN_EXISTS(TEMP_3)
     #error TEMP_3_PIN not defined for this board.
   #elif !PIN_EXISTS(E3_STEP) || !PIN_EXISTS(E3_DIR) || !PIN_EXISTS(E3_ENABLE)
     #error E3_STEP_PIN, E3_DIR_PIN, or E3_ENABLE_PIN not defined for this board.
-  #elif TEMP_SENSOR_3 == 0
-    #error TEMP_SENSOR_3 is required with 4 EXTRUDERS.
   #endif
 #elif EXTRUDERS > 2
-  #if !HAS_HEATER_2
+  #if TEMP_SENSOR_2 == 0
+    #error TEMP_SENSOR_2 is required with 3 or more EXTRUDERS.
+  #elif !HAS_HEATER_2
     #error HEATER_2_PIN not defined for this board.
   #elif !PIN_EXISTS(TEMP_2)
     #error TEMP_2_PIN not defined for this board.
   #elif !PIN_EXISTS(E2_STEP) || !PIN_EXISTS(E2_DIR) || !PIN_EXISTS(E2_ENABLE)
     #error E2_STEP_PIN, E2_DIR_PIN, or E2_ENABLE_PIN not defined for this board.
-  #elif TEMP_SENSOR_2 == 0
-    #error TEMP_SENSOR_2 is required with 3 or more EXTRUDERS.
   #endif
 #elif EXTRUDERS > 1
-  #if !PIN_EXISTS(TEMP_1)
+  #if TEMP_SENSOR_1 == 0
+    #error TEMP_SENSOR_1 is required with 2 or more EXTRUDERS.
+  #elif !PIN_EXISTS(TEMP_1)
     #error TEMP_1_PIN not defined for this board.
   #elif !PIN_EXISTS(E1_STEP) || !PIN_EXISTS(E1_DIR) || !PIN_EXISTS(E1_ENABLE)
     #error E1_STEP_PIN, E1_DIR_PIN, or E1_ENABLE_PIN not defined for this board.
@@ -401,12 +403,8 @@
   #endif
 #endif
 
-#if TEMP_SENSOR_1 == 0
-  #if EXTRUDERS > 1
-    #error TEMP_SENSOR_1 is required with 2 or more EXTRUDERS.
-  #elif ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-    #error TEMP_SENSOR_1 is required with TEMP_SENSOR_1_AS_REDUNDANT.
-  #endif
+#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT) && TEMP_SENSOR_1 == 0
+  #error TEMP_SENSOR_1 is required with TEMP_SENSOR_1_AS_REDUNDANT.
 #endif
 
 #if !HAS_HEATER_0
diff --git a/Marlin/fonts/README.fonts b/Marlin/fonts/README.fonts
index 1d1cda4..971275d 100644
--- a/Marlin/fonts/README.fonts
+++ b/Marlin/fonts/README.fonts
@@ -21,6 +21,3 @@ For the second half of the font we now support up to 11x11 pixel.
     #else // fall-back
  * Add your font to the list of permitted fonts in 'language_en.h'
     ... || ENABLED(DISPLAY_CHARSET_YOUR_NEW_FONT) ... )
-
-
-Especially the Kana font should be revised by someone who knows what he/she does. I am only a west-European with very little knowledge about this script.
diff --git a/Marlin/language.h b/Marlin/language.h
index 5d8033e..9085a6a 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -82,6 +82,12 @@
 #endif
 
 #ifndef DEFAULT_SOURCE_URL
+  /**
+   * The SOURCE_CODE_URL is the location where users will find the Marlin Source
+   * Code which is installed on the device. In most cases —unless the manufacturer
+   * has a distinct Github fork— the Source Code URL should just be the main
+   * Marlin repository.
+   */
   #define DEFAULT_SOURCE_URL "https://github.com/MarlinFirmware/Marlin"
 #endif
 
@@ -225,7 +231,7 @@
 #define MSG_T_MINTEMP                       "MINTEMP triggered"
 
 // Debug
-#define MSG_DEBUG_PREFIX                    "DEBUG: "
+#define MSG_DEBUG_PREFIX                    "DEBUG:"
 #define MSG_DEBUG_OFF                       "off"
 #define MSG_DEBUG_ECHO                      "ECHO"
 #define MSG_DEBUG_INFO                      "INFO"
diff --git a/Marlin/language_fr.h b/Marlin/language_fr.h
index f3dc84b..3145f78 100644
--- a/Marlin/language_fr.h
+++ b/Marlin/language_fr.h
@@ -42,9 +42,13 @@
 #define MSG_MAIN                            "Menu principal"
 #define MSG_AUTOSTART                       "Demarrage auto"
 #define MSG_DISABLE_STEPPERS                "Arreter moteurs"
-#define MSG_AUTO_HOME                       "Home auto."
-#define MSG_LEVEL_BED_HOMING                "Homing XYZ"
-#define MSG_SET_HOME_OFFSETS                "Set home offsets"
+#define MSG_AUTO_HOME                       "Origine auto."
+#define MSG_LEVEL_BED_HOMING                "Origine XYZ"
+#define MSG_LEVEL_BED_WAITING               "Cliquer pour commencer"
+#define MSG_LEVEL_BED_DONE                  "Mise a niveau OK!"
+#define MSG_LEVEL_BED_CANCEL                "Annuler"
+#define MSG_SET_HOME_OFFSETS                "Regler decal. origine"
+#define MSG_HOME_OFFSETS_APPLIED            "Decalages appliques"
 #define MSG_SET_ORIGIN                      "Regler origine"
 #define MSG_PREHEAT_PLA                     "Prechauffage PLA"
 #define MSG_PREHEAT_PLA_N                   "Prechauff. PLA "
@@ -106,8 +110,8 @@
 #define MSG_TEMPERATURE                     "Temperature"
 #define MSG_MOTION                          "Mouvement"
 #define MSG_VOLUMETRIC                      "Filament"
-#define MSG_VOLUMETRIC_ENABLED              "E in mm3"
-#define MSG_FILAMENT_DIAM                   "Fil. Dia."
+#define MSG_VOLUMETRIC_ENABLED              "E en mm3"
+#define MSG_FILAMENT_DIAM                   "Diam. Fil."
 #define MSG_CONTRAST                        "Contraste LCD"
 #define MSG_STORE_EPROM                     "Sauver config"
 #define MSG_LOAD_EPROM                      "Lire config"
@@ -141,7 +145,7 @@
 #define MSG_CNG_SDCARD                      "Changer de carte"
 #define MSG_ZPROBE_OUT                      "Z sonde exte. lit"
 #define MSG_YX_UNHOMED                      "Rev. dans XY av.Z"
-#define MSG_ZPROBE_ZOFFSET                  "Offset Z"
+#define MSG_ZPROBE_ZOFFSET                  "Decalage Z"
 #define MSG_BABYSTEP_X                      "Babystep X"
 #define MSG_BABYSTEP_Y                      "Babystep Y"
 #define MSG_BABYSTEP_Z                      "Babystep Z"
@@ -164,11 +168,11 @@
 
 
 #if ENABLED(DELTA_CALIBRATION_MENU)
-  #define MSG_DELTA_CALIBRATE               "Delta Calibration"
-  #define MSG_DELTA_CALIBRATE_X             "Calibrate X"
-  #define MSG_DELTA_CALIBRATE_Y             "Calibrate Y"
-  #define MSG_DELTA_CALIBRATE_Z             "Calibrate Z"
-  #define MSG_DELTA_CALIBRATE_CENTER        "Calibrate Center"
+  #define MSG_DELTA_CALIBRATE               "Calibration Delta"
+  #define MSG_DELTA_CALIBRATE_X             "Calibrer X"
+  #define MSG_DELTA_CALIBRATE_Y             "Calibrer Y"
+  #define MSG_DELTA_CALIBRATE_Z             "Calibrer Z"
+  #define MSG_DELTA_CALIBRATE_CENTER        "Calibrer centre"
 #endif // DELTA_CALIBRATION_MENU
 
 #endif // LANGUAGE_FR_H
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index f711fc5..3757fba 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -42,23 +42,23 @@
 #define MSG_AUTOSTART                       "Autostart"
 #define MSG_DISABLE_STEPPERS                "Disabilita Motori"
 #define MSG_AUTO_HOME                       "Auto Home"
-#define MSG_LEVEL_BED_HOMING                "Homing XYZ"
-#define MSG_LEVEL_BED_WAITING               "Click to Begin"
-#define MSG_LEVEL_BED_DONE                  "Leveling Done!"
-#define MSG_LEVEL_BED_CANCEL                "Cancel"
-#define MSG_SET_HOME_OFFSETS                "Setta offset home"
-#define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
+#define MSG_LEVEL_BED_HOMING                "Home assi XYZ"
+#define MSG_LEVEL_BED_WAITING               "Premi per Iniziare"
+#define MSG_LEVEL_BED_DONE                  "Livel. terminato!"
+#define MSG_LEVEL_BED_CANCEL                "Annulla"
+#define MSG_SET_HOME_OFFSETS                "Imposta offset home"
+#define MSG_HOME_OFFSETS_APPLIED            "Offset applicato"
 #define MSG_SET_ORIGIN                      "Imposta Origine"
 #define MSG_PREHEAT_PLA                     "Preriscalda PLA"
-#define MSG_PREHEAT_PLA_N                   "Preriscalda PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Prer. PLA Tutto"
-#define MSG_PREHEAT_PLA_BEDONLY             "Prer. PLA Piatto"
-#define MSG_PREHEAT_PLA_SETTINGS            "Config. prer. PLA"
+#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
+#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " Tutto"
+#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Piatto"
+#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " conf"
 #define MSG_PREHEAT_ABS                     "Preriscalda ABS"
-#define MSG_PREHEAT_ABS_N                   "Preriscalda ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Prer. ABS Tutto"
-#define MSG_PREHEAT_ABS_BEDONLY             "Prer. ABS Piatto"
-#define MSG_PREHEAT_ABS_SETTINGS            "Config. prer. ABS"
+#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
+#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " Tutto"
+#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Piatto"
+#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"
 #define MSG_COOLDOWN                        "Raffredda"
 #define MSG_SWITCH_PS_ON                    "Accendi aliment."
 #define MSG_SWITCH_PS_OFF                   "Spegni aliment."
@@ -73,34 +73,34 @@
 #define MSG_MOVE_01MM                       "Muovi di 0.1mm"
 #define MSG_MOVE_1MM                        "Muovi di   1mm"
 #define MSG_MOVE_10MM                       "Muovi di  10mm"
-#define MSG_SPEED                           "Velcità"
+#define MSG_SPEED                           "Velocità"
 #define MSG_NOZZLE                          "Ugello"
 #define MSG_BED                             "Piatto"
-#define MSG_FAN_SPEED                       "Ventola"
+#define MSG_FAN_SPEED                       "Velocità ventola"
 #define MSG_FLOW                            "Flusso"
 #define MSG_CONTROL                         "Controllo"
 #define MSG_MIN                             LCD_STR_THERMOMETER " Min"
 #define MSG_MAX                             LCD_STR_THERMOMETER " Max"
 #define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"
 #define MSG_AUTOTEMP                        "Autotemp"
-#define MSG_ON                              "ON "
-#define MSG_OFF                             "OFF"
+#define MSG_ON                              "On "
+#define MSG_OFF                             "Off"
 #define MSG_PID_P                           "PID-P"
 #define MSG_PID_I                           "PID-I"
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
-#define MSG_ACC                             "Accel."
+#define MSG_ACC                             "Accel"
 #define MSG_VXY_JERK                        "Vxy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
-#define MSG_VMAX                            "Vmax"
+#define MSG_VMAX                            "Vmax "
 #define MSG_X                               "x"
 #define MSG_Y                               "y"
 #define MSG_Z                               "z"
 #define MSG_E                               "e"
 #define MSG_VMIN                            "Vmin"
 #define MSG_VTRAV_MIN                       "VTrav min"
-#define MSG_AMAX                            "Amax"
+#define MSG_AMAX                            "Amax "
 #define MSG_A_RETRACT                       "A-retract"
 #define MSG_XSTEPS                          "Xpassi/mm"
 #define MSG_YSTEPS                          "Ypassi/mm"
@@ -108,42 +108,42 @@
 #define MSG_ESTEPS                          "Epassi/mm"
 #define MSG_TEMPERATURE                     "Temperatura"
 #define MSG_MOTION                          "Movimento"
-#define MSG_VOLUMETRIC                      "Filament"
-#define MSG_VOLUMETRIC_ENABLED              "E in mm³"
+#define MSG_VOLUMETRIC                      "Filamento"
+#define MSG_VOLUMETRIC_ENABLED              "E in mm3"
 #define MSG_FILAMENT_DIAM                   "Diam. filo"
 #define MSG_CONTRAST                        "Contrasto LCD"
-#define MSG_STORE_EPROM                     "Salva in EEPROM"
-#define MSG_LOAD_EPROM                      "Carica da EEPROM"
-#define MSG_RESTORE_FAILSAFE                "Impostaz. default"
+#define MSG_STORE_EPROM                     "Salva in memoria"
+#define MSG_LOAD_EPROM                      "Carica da memoria"
+#define MSG_RESTORE_FAILSAFE                "Ripristina impostaz."
 #define MSG_REFRESH                         "Aggiorna"
 #define MSG_WATCH                           "Guarda"
 #define MSG_PREPARE                         "Prepara"
-#define MSG_TUNE                            "Adatta"
+#define MSG_TUNE                            "Regola"
 #define MSG_PAUSE_PRINT                     "Pausa"
 #define MSG_RESUME_PRINT                    "Riprendi stampa"
 #define MSG_STOP_PRINT                      "Arresta stampa"
-#define MSG_CARD_MENU                       "SD Card Menu"
-#define MSG_NO_CARD                         "No SD Card"
+#define MSG_CARD_MENU                       "Stampa da SD"
+#define MSG_NO_CARD                         "SD non presente"
 #define MSG_DWELL                           "Sospensione..."
 #define MSG_USERWAIT                        "Attendi Utente..."
 #define MSG_RESUMING                        "Riprendi Stampa"
-#define MSG_PRINT_ABORTED                   "Stampa abortita"
-#define MSG_NO_MOVE                         "Nessun Movimento"
-#define MSG_KILLED                          "UCCISO "
-#define MSG_STOPPED                         "ARRESTATO "
+#define MSG_PRINT_ABORTED                   "Stampa annullata"
+#define MSG_NO_MOVE                         "Nessun Movimento."
+#define MSG_KILLED                          "UCCISO. "
+#define MSG_STOPPED                         "ARRESTATO. "
 #define MSG_CONTROL_RETRACT                 "Ritrai mm"
 #define MSG_CONTROL_RETRACT_SWAP            "Scamb. Ritrai mm"
 #define MSG_CONTROL_RETRACTF                "Ritrai  V"
 #define MSG_CONTROL_RETRACT_ZLIFT           "Salta mm"
 #define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"
-#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Scamb. UnRet +mm"
+#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Scamb. UnRet+mm"
 #define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"
-#define MSG_AUTORETRACT                     "AutoArretramento"
+#define MSG_AUTORETRACT                     "AutoRitrai"
 #define MSG_FILAMENTCHANGE                  "Cambia filamento"
 #define MSG_INIT_SDCARD                     "Iniz. SD-Card"
 #define MSG_CNG_SDCARD                      "Cambia SD-Card"
 #define MSG_ZPROBE_OUT                      "Z probe out. bed"
-#define MSG_YX_UNHOMED                      "Home X/Y before Z"
+#define MSG_YX_UNHOMED                      "Home X/Y prima di Z"
 #define MSG_ZPROBE_ZOFFSET                  "Z Offset"
 #define MSG_BABYSTEP_X                      "Babystep X"
 #define MSG_BABYSTEP_Y                      "Babystep Y"
@@ -154,16 +154,17 @@
 #define MSG_BED_Z                           "piatto Z"
 #define MSG_A_TRAVEL                        "A-Spostamento"
 #define MSG_HEATING_FAILED_LCD              "Riscald. Fallito"
-#define MSG_ERR_REDUNDANT_TEMP              "Err: TERM RINDONDANTI"
-#define MSG_THERMAL_RUNAWAY                 "SURRISCALDAMENTO"
-#define MSG_ERR_MAXTEMP                     "Err: TEMP MAX"
-#define MSG_ERR_MINTEMP                     "Err: TEMP MIN"
-#define MSG_ERR_MAXTEMP_BED                 "Err: TMAX PIATTO"
-#define MSG_ERR_MINTEMP_BED                 "Err: TMIN PIATTO"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: ERRORE TEMP RIDONDANTI"
+#define MSG_THERMAL_RUNAWAY                 "TEMP. FUORI CONTROLLO"
+#define MSG_ERR_MAXTEMP                     "Err: TEMP MASSIMA"
+#define MSG_ERR_MINTEMP                     "Err: TEMP MINIMA"
+#define MSG_ERR_MAXTEMP_BED                 "Err: TEMP MASSIMA PIATTO"
+#define MSG_ERR_MINTEMP_BED                 "Err: TEMP MINIMA PIATTO"
 #define MSG_HEATING                         "Riscaldamento.."
-#define MSG_HEATING_COMPLETE                "Riscald completo"
+#define MSG_HEATING_COMPLETE                "Riscald completato"
 #define MSG_BED_HEATING                     "Risc. Piatto.."
-#define MSG_BED_DONE                        "Risc. Piatto Completo"
+#define MSG_BED_DONE                        "Risc. Piatto Completato"
+
 
 #if ENABLED(DELTA_CALIBRATION_MENU)
   #define MSG_DELTA_CALIBRATE               "Calibraz. Delta"
diff --git a/Marlin/language_nl.h b/Marlin/language_nl.h
index ec1d7dc..4ccc7f0 100644
--- a/Marlin/language_nl.h
+++ b/Marlin/language_nl.h
@@ -38,7 +38,7 @@
 #define WELCOME_MSG                         MACHINE_NAME " gereed."
 #define MSG_SD_INSERTED                     "Kaart ingestoken"
 #define MSG_SD_REMOVED                      "Kaart verwijderd"
-#define MSG_MAIN                            "Main"
+#define MSG_MAIN                            "Hoofdmenu"
 #define MSG_AUTOSTART                       "Autostart"
 #define MSG_DISABLE_STEPPERS                "Motoren uit"
 #define MSG_AUTO_HOME                       "Auto home"
@@ -153,16 +153,21 @@
 #define MSG_BED_Z                           "Bed Z"
 #define MSG_A_TRAVEL                        "A-travel"
 #define MSG_HEATING_FAILED_LCD              "voorverw. fout"
-#define MSG_ERR_REDUNDANT_TEMP              "Fout: Redundant temp fout"
-#define MSG_THERMAL_RUNAWAY                 "Thermische wegloop"
-#define MSG_ERR_MAXTEMP                     "Fout: Max. temp"
-#define MSG_ERR_MINTEMP                     "Fout: Min. temp"
-#define MSG_ERR_MAXTEMP_BED                 "Fout: Max. temp bed"
-#define MSG_ERR_MINTEMP_BED                 "Fout: Min. temp bed"
+#define MSG_ERR_REDUNDANT_TEMP              "Redun. temp fout"
+#define MSG_THERMAL_RUNAWAY                 "Therm. wegloop"
+#define MSG_ERR_MAXTEMP                     "Err: Max. temp"
+#define MSG_ERR_MINTEMP                     "Err: Min. temp"
+#define MSG_ERR_MAXTEMP_BED                 "Err: Max.tmp bed"
+#define MSG_ERR_MINTEMP_BED                 "Err: Min.tmp bed"
 #define MSG_HEATING                         "Voorwarmen..."
-#define MSG_HEATING_COMPLETE                "voorverw. kompleet"
-#define MSG_BED_HEATING                     "Bed voorverwarmen"
+#define MSG_HEATING_COMPLETE                "Voorverw. kompl."
+#define MSG_BED_HEATING                     "Bed voorverw."
 #define MSG_BED_DONE                        "Bed is voorverw."
+#define MSG_LEVEL_BED_HOMING                "Homing XYZ"
+#define MSG_LEVEL_BED_WAITING               "Klik voor begin"
+#define MSG_LEVEL_BED_DONE                  "Bed level kompl."
+#define MSG_LEVEL_BED_CANCEL                "Bed level afbr."
+#define MSG_HOME_OFFSETS_APPLIED            "H offset toegep."
 
 #if ENABLED(DELTA_CALIBRATION_MENU)
   #define MSG_DELTA_CALIBRATE               "Delta Calibratie"
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index ed3aa78..318b5bd 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -852,25 +852,34 @@ float junction_deviation = 0.1;
   block->nominal_rate = ceil(block->step_event_count * inverse_second); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    static float filwidth_e_count = 0, filwidth_delay_dist = 0;
+
     //FMM update ring buffer used for delay with filament measurements
-    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && delay_index2 > -1) {  //only for extruder with filament sensor and if ring buffer is initialized
+    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index2 >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
+
+      const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
+
+      // increment counters with next move in e axis
+      filwidth_e_count += delta_mm[E_AXIS];
+      filwidth_delay_dist += delta_mm[E_AXIS];
 
-      const int MMD = MAX_MEASUREMENT_DELAY + 1, MMD10 = MMD * 10;
+      // Only get new measurements on forward E movement
+      if (filwidth_e_count > 0.0001) {
 
-      delay_dist += delta_mm[E_AXIS];  // increment counter with next move in e axis
-      while (delay_dist >= MMD10) delay_dist -= MMD10; // loop around the buffer
-      while (delay_dist < 0) delay_dist += MMD10;
+        // Loop the delay distance counter (modulus by the mm length)
+        while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
-      delay_index1 = delay_dist / 10.0;  // calculate index
-      delay_index1 = constrain(delay_index1, 0, MAX_MEASUREMENT_DELAY); // (already constrained above)
+        // Convert into an index into the measurement array
+        filwidth_delay_index1 = (int)(filwidth_delay_dist / 10.0 + 0.0001);
 
-      if (delay_index1 != delay_index2) { // moved index
-        int8_t meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char
-        while (delay_index1 != delay_index2) {
-          // Increment and loop around buffer
-          if (++delay_index2 >= MMD) delay_index2 -= MMD;
-          delay_index2 = constrain(delay_index2, 0, MAX_MEASUREMENT_DELAY);
-          measurement_delay[delay_index2] = meas_sample;
+        // If the index has changed (must have gone forward)...
+        if (filwidth_delay_index1 != filwidth_delay_index2) {
+          filwidth_e_count = 0; // Reset the E movement counter
+          int8_t meas_sample = widthFil_to_size_ratio() - 100; // Subtract 100 to reduce magnitude - to store in a signed char
+          do {
+            filwidth_delay_index2 = (filwidth_delay_index2 + 1) % MMD_CM; // The next unused slot
+            measurement_delay[filwidth_delay_index2] = meas_sample;       // Store the measurement
+          } while (filwidth_delay_index1 != filwidth_delay_index2);       // More slots to fill?
         }
       }
     }
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 68873f5..d9a5895 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -705,7 +705,7 @@ void manage_heater() {
   // Control the extruder rate based on the width sensor
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (filament_sensor) {
-      meas_shift_index = delay_index1 - meas_delay_cm;
+      meas_shift_index = filwidth_delay_index1 - meas_delay_cm;
       if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
 
       // Get the delayed info and add 100 to reconstitute to a percent of
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 483d021..1e474bc 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -319,7 +319,10 @@ static void lcd_goto_menu(menuFunc_t menu, const bool feedback = false, const ui
       encoderPosition = encoder;
       if (feedback) lcd_quick_feedback();
     #endif
-    if (menu == lcd_status_screen) menu_history_depth = 0;
+    if (menu == lcd_status_screen) {
+      defer_return_to_status = false;
+      menu_history_depth = 0;
+    }
     #if ENABLED(LCD_PROGRESS_BAR)
       // For LCD_PROGRESS_BAR re-initialize custom characters
       lcd_set_custom_characters(menu == lcd_status_screen);
@@ -327,10 +330,7 @@ static void lcd_goto_menu(menuFunc_t menu, const bool feedback = false, const ui
   }
 }
 
-static void lcd_return_to_status() {
-  defer_return_to_status = false;
-  lcd_goto_menu(lcd_status_screen);
-}
+static void lcd_return_to_status() { lcd_goto_menu(lcd_status_screen); }
 
 inline void lcd_save_previous_menu() {
   if (menu_history_depth < COUNT(menu_history)) {
@@ -432,13 +432,13 @@ static void lcd_status_screen() {
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+      int new_frm = feedrate_multiplier + int(encoderPosition);
       // Dead zone at 100% feedrate
-      if ((feedrate_multiplier < 100 && (feedrate_multiplier + int(encoderPosition)) > 100) ||
-          (feedrate_multiplier > 100 && (feedrate_multiplier + int(encoderPosition)) < 100)) {
-        encoderPosition = 0;
+      if ((feedrate_multiplier < 100 && new_frm > 100) || (feedrate_multiplier > 100 && new_frm < 100)) {
         feedrate_multiplier = 100;
+        encoderPosition = 0;
       }
-      if (feedrate_multiplier == 100) {
+      else if (feedrate_multiplier == 100) {
         if (int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE) {
           feedrate_multiplier += int(encoderPosition) - (ENCODER_FEEDRATE_DEADZONE);
           encoderPosition = 0;
@@ -449,7 +449,7 @@ static void lcd_status_screen() {
         }
       }
       else {
-        feedrate_multiplier += int(encoderPosition);
+        feedrate_multiplier = new_frm;
         encoderPosition = 0;
       }
     #endif // ULTIPANEL_FEEDMULTIPLY
@@ -583,7 +583,7 @@ void lcd_set_home_offsets() {
       #endif
     }
     if (lcdDrawUpdate) lcd_implementation_drawedit(msg, NULL);
-    if (LCD_CLICKED) lcd_goto_previous_menu();
+    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
 
   #if ENABLED(BABYSTEP_XY)
@@ -901,7 +901,7 @@ void lcd_cooldown() {
     ENCODER_DIRECTION_NORMAL();
 
     // Encoder wheel adjusts the Z position
-    if (encoderPosition != 0 && movesplanned() <= 3) {
+    if (encoderPosition && movesplanned() <= 3) {
       refresh_cmd_timeout();
       current_position[Z_AXIS] += float((int)encoderPosition) * (MBL_Z_STEP);
       if (min_software_endstops) NOLESS(current_position[Z_AXIS], Z_MIN_POS);
@@ -978,7 +978,7 @@ void lcd_cooldown() {
       current_position[Y_AXIS] = MESH_MIN_Y;
       line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
       _lcd_level_bed_position = 0;
-      lcd_goto_menu(_lcd_level_bed_procedure);
+      lcd_goto_menu(_lcd_level_bed_procedure, true);
     }
   }
 
@@ -1121,9 +1121,8 @@ static void lcd_prepare_menu() {
  */
 
 float move_menu_scale;
-static void lcd_move_menu_axis();
 
-static void _lcd_move(const char* name, AxisEnum axis, int min, int max) {
+static void _lcd_move(const char* name, AxisEnum axis, float min, float max) {
   ENCODER_DIRECTION_NORMAL();
   if ((encoderPosition != 0) && (movesplanned() <= 3)) {
     refresh_cmd_timeout();
@@ -1135,18 +1134,18 @@ static void _lcd_move(const char* name, AxisEnum axis, int min, int max) {
     lcdDrawUpdate = LCD_DRAW_UPDATE_CALL_REDRAW;
   }
   if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
-  if (LCD_CLICKED) lcd_goto_previous_menu();
+  if (LCD_CLICKED) lcd_goto_previous_menu(true);
 }
 #if ENABLED(DELTA)
   static float delta_clip_radius_2 =  (DELTA_PRINTABLE_RADIUS) * (DELTA_PRINTABLE_RADIUS);
   static int delta_clip( float a ) { return sqrt(delta_clip_radius_2 - a*a); }
-  static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, max(X_MIN_POS, -clip), min(X_MAX_POS, clip)); }
-  static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, max(Y_MIN_POS, -clip), min(Y_MAX_POS, clip)); }
+  static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, max(min_pos[X_AXIS], -clip), min(max_pos[X_AXIS], clip)); }
+  static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, max(min_pos[Y_AXIS], -clip), min(max_pos[Y_AXIS], clip)); }
 #else
-  static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, X_MIN_POS, X_MAX_POS); }
-  static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, Y_MIN_POS, Y_MAX_POS); }
+  static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, min_pos[X_AXIS], max_pos[X_AXIS]); }
+  static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, min_pos[Y_AXIS], max_pos[Y_AXIS]); }
 #endif
-static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, Z_MIN_POS, Z_MAX_POS); }
+static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, min_pos[Z_AXIS], max_pos[Z_AXIS]); }
 static void lcd_move_e(
   #if EXTRUDERS > 1
     uint8_t e
@@ -1181,7 +1180,7 @@ static void lcd_move_e(
     #endif //EXTRUDERS > 1
     lcd_implementation_drawedit(pos_label, ftostr31(current_position[E_AXIS]));
   }
-  if (LCD_CLICKED) lcd_goto_previous_menu();
+  if (LCD_CLICKED) lcd_goto_previous_menu(true);
   #if EXTRUDERS > 1
     active_extruder = original_active_extruder;
   #endif
@@ -1204,7 +1203,7 @@ static void lcd_move_e(
  *
  */
 
-static void lcd_move_menu_axis() {
+static void _lcd_move_menu_axis() {
   START_MENU();
   MENU_ITEM(back, MSG_MOVE_AXIS);
   MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
@@ -1229,15 +1228,15 @@ static void lcd_move_menu_axis() {
 
 static void lcd_move_menu_10mm() {
   move_menu_scale = 10.0;
-  lcd_move_menu_axis();
+  _lcd_move_menu_axis();
 }
 static void lcd_move_menu_1mm() {
   move_menu_scale = 1.0;
-  lcd_move_menu_axis();
+  _lcd_move_menu_axis();
 }
 static void lcd_move_menu_01mm() {
   move_menu_scale = 0.1;
-  lcd_move_menu_axis();
+  _lcd_move_menu_axis();
 }
 
 /**
@@ -1649,7 +1648,7 @@ static void lcd_control_volumetric_menu() {
         lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
       #endif
     }
-    if (LCD_CLICKED) lcd_goto_previous_menu();
+    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
 #endif // HAS_LCD_CONTRAST
 
@@ -1781,7 +1780,6 @@ static void lcd_control_volumetric_menu() {
     lcd_save_previous_menu(); \
     \
     lcdDrawUpdate = LCD_DRAW_UPDATE_CLEAR_CALL_REDRAW; \
-    currentMenu = menu_edit_ ## _name; \
     \
     editLabel = pstr; \
     editValue = ptr; \
@@ -1798,14 +1796,14 @@ static void lcd_control_volumetric_menu() {
     currentMenu = menu_edit_callback_ ## _name; \
     callbackFunc = callback; \
   }
-menu_edit_type(int, int3, itostr3, 1)
-menu_edit_type(float, float3, ftostr3, 1)
-menu_edit_type(float, float32, ftostr32, 100)
-menu_edit_type(float, float43, ftostr43, 1000)
-menu_edit_type(float, float5, ftostr5, 0.01)
-menu_edit_type(float, float51, ftostr51, 10)
-menu_edit_type(float, float52, ftostr52, 100)
-menu_edit_type(unsigned long, long5, ftostr5, 0.01)
+menu_edit_type(int, int3, itostr3, 1);
+menu_edit_type(float, float3, ftostr3, 1);
+menu_edit_type(float, float32, ftostr32, 100);
+menu_edit_type(float, float43, ftostr43, 1000);
+menu_edit_type(float, float5, ftostr5, 0.01);
+menu_edit_type(float, float51, ftostr51, 10);
+menu_edit_type(float, float52, ftostr52, 100);
+menu_edit_type(unsigned long, long5, ftostr5, 0.01);
 
 /**
  *
@@ -1844,7 +1842,7 @@ menu_edit_type(unsigned long, long5, ftostr5, 0.01)
     lcd_move_y();
   }
   static void reprapworld_keypad_move_home() {
-    enqueue_and_echo_commands_P((PSTR("G28"))); // move all axis home
+    enqueue_and_echo_commands_P(PSTR("G28")); // move all axes home
   }
 #endif // REPRAPWORLD_KEYPAD
 
@@ -2093,13 +2091,22 @@ void lcd_update() {
     #if ENABLED(ULTIPANEL)
 
       #if ENABLED(REPRAPWORLD_KEYPAD)
-        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
-        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
-        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
-        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
-        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
-        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
-        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
+
+        #if ENABLED(DELTA) || ENABLED(SCARA)
+          #define _KEYPAD_MOVE_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        #else
+          #define _KEYPAD_MOVE_ALLOWED true
+        #endif
+
+        if (REPRAPWORLD_KEYPAD_MOVE_HOME)       reprapworld_keypad_move_home();
+        if (_KEYPAD_MOVE_ALLOWED) {
+          if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
+          if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
+          if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
+          if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
+          if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
+          if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
+        }
       #endif
 
       bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
@@ -2184,7 +2191,7 @@ void lcd_update() {
       // Return to Status Screen after a timeout
       if (defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-      else if (currentMenu != lcd_status_screen && millis() > return_to_status_ms) {
+      else if (currentMenu != lcd_status_screen && ms > return_to_status_ms) {
         lcd_return_to_status();
       }
 
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index cbc5e05..61abf9c 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -65,9 +65,6 @@
   #if ENABLED(ULTIPANEL)
     void lcd_buttons_update();
     extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
-    #if ENABLED(REPRAPWORLD_KEYPAD)
-      extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shift register values
-    #endif
   #else
     FORCE_INLINE void lcd_buttons_update() {}
   #endif
@@ -89,33 +86,52 @@
   void lcd_ignore_click(bool b=true);
   bool lcd_blink();
 
+  #if ENABLED(ULTIPANEL) && ENABLED(REPRAPWORLD_KEYPAD)
+
+    #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
+
+    #define BLEN_REPRAPWORLD_KEYPAD_F3     0
+    #define BLEN_REPRAPWORLD_KEYPAD_F2     1
+    #define BLEN_REPRAPWORLD_KEYPAD_F1     2
+    #define BLEN_REPRAPWORLD_KEYPAD_DOWN   3
+    #define BLEN_REPRAPWORLD_KEYPAD_RIGHT  4
+    #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
+    #define BLEN_REPRAPWORLD_KEYPAD_UP     6
+    #define BLEN_REPRAPWORLD_KEYPAD_LEFT   7
+
+    #define EN_REPRAPWORLD_KEYPAD_F3      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F3))
+    #define EN_REPRAPWORLD_KEYPAD_F2      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F2))
+    #define EN_REPRAPWORLD_KEYPAD_F1      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F1))
+    #define EN_REPRAPWORLD_KEYPAD_DOWN    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_DOWN))
+    #define EN_REPRAPWORLD_KEYPAD_RIGHT   (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_RIGHT))
+    #define EN_REPRAPWORLD_KEYPAD_MIDDLE  (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
+    #define EN_REPRAPWORLD_KEYPAD_UP      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_UP))
+    #define EN_REPRAPWORLD_KEYPAD_LEFT    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_LEFT))
+
+    #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F3)
+    #define REPRAPWORLD_KEYPAD_MOVE_Z_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F2)
+    #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)
+    #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT)
+    #define REPRAPWORLD_KEYPAD_MOVE_HOME    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_MIDDLE)
+    #define REPRAPWORLD_KEYPAD_MOVE_Y_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)
+    #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)
+
+  #endif //ULTIPANEL && REPRAPWORLD_KEYPAD
+
   #if ENABLED(NEWPANEL)
+
     #define EN_C (_BV(BLEN_C))
     #define EN_B (_BV(BLEN_B))
     #define EN_A (_BV(BLEN_A))
 
     #if ENABLED(REPRAPWORLD_KEYPAD)
-      #define EN_REPRAPWORLD_KEYPAD_F3 (_BV(BLEN_REPRAPWORLD_KEYPAD_F3))
-      #define EN_REPRAPWORLD_KEYPAD_F2 (_BV(BLEN_REPRAPWORLD_KEYPAD_F2))
-      #define EN_REPRAPWORLD_KEYPAD_F1 (_BV(BLEN_REPRAPWORLD_KEYPAD_F1))
-      #define EN_REPRAPWORLD_KEYPAD_UP (_BV(BLEN_REPRAPWORLD_KEYPAD_UP))
-      #define EN_REPRAPWORLD_KEYPAD_RIGHT (_BV(BLEN_REPRAPWORLD_KEYPAD_RIGHT))
-      #define EN_REPRAPWORLD_KEYPAD_MIDDLE (_BV(BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
-      #define EN_REPRAPWORLD_KEYPAD_DOWN (_BV(BLEN_REPRAPWORLD_KEYPAD_DOWN))
-      #define EN_REPRAPWORLD_KEYPAD_LEFT (_BV(BLEN_REPRAPWORLD_KEYPAD_LEFT))
-
       #define LCD_CLICKED ((buttons&EN_C) || (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F1))
-      #define REPRAPWORLD_KEYPAD_MOVE_Z_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F2)
-      #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F3)
-      #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_LEFT)
-      #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_RIGHT)
-      #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_DOWN)
-      #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_UP)
-      #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_MIDDLE)
     #else
       #define LCD_CLICKED (buttons&EN_C)
-    #endif //REPRAPWORLD_KEYPAD
-  #else
+    #endif
+
+  #else //!NEWPANEL
+
     //atomic, do not change
     #define B_LE (_BV(BL_LE))
     #define B_UP (_BV(BL_UP))
@@ -127,7 +143,8 @@
     #define EN_A (_BV(BLEN_A))
 
     #define LCD_CLICKED ((buttons&B_MI)||(buttons&B_ST))
-  #endif//NEWPANEL
+
+  #endif //!NEWPANEL
 
 #else //no LCD
   FORCE_INLINE void lcd_update() {}
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 325bd12..26399fb 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -98,31 +98,8 @@ extern volatile uint8_t buttons;  //an extended version of the last checked butt
     #endif
 
   #elif ENABLED(REPRAPWORLD_KEYPAD)
-    // define register bit values, don't change it
-    #define BLEN_REPRAPWORLD_KEYPAD_F3 0
-    #define BLEN_REPRAPWORLD_KEYPAD_F2 1
-    #define BLEN_REPRAPWORLD_KEYPAD_F1 2
-    #define BLEN_REPRAPWORLD_KEYPAD_UP 6
-    #define BLEN_REPRAPWORLD_KEYPAD_RIGHT 4
-    #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
-    #define BLEN_REPRAPWORLD_KEYPAD_DOWN 3
-    #define BLEN_REPRAPWORLD_KEYPAD_LEFT 7
-
-    #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
-
-    #define EN_REPRAPWORLD_KEYPAD_F3 (_BV(BLEN_REPRAPWORLD_KEYPAD_F3+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_F2 (_BV(BLEN_REPRAPWORLD_KEYPAD_F2+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_F1 (_BV(BLEN_REPRAPWORLD_KEYPAD_F1+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_UP (_BV(BLEN_REPRAPWORLD_KEYPAD_UP+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_RIGHT (_BV(BLEN_REPRAPWORLD_KEYPAD_RIGHT+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_MIDDLE (_BV(BLEN_REPRAPWORLD_KEYPAD_MIDDLE+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_DOWN (_BV(BLEN_REPRAPWORLD_KEYPAD_DOWN+REPRAPWORLD_BTN_OFFSET))
-    #define EN_REPRAPWORLD_KEYPAD_LEFT (_BV(BLEN_REPRAPWORLD_KEYPAD_LEFT+REPRAPWORLD_BTN_OFFSET))
-
-    //#define LCD_CLICKED ((buttons&EN_C) || (buttons&EN_REPRAPWORLD_KEYPAD_F1))
-    //#define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons&EN_REPRAPWORLD_KEYPAD_DOWN)
-    //#define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons&EN_REPRAPWORLD_KEYPAD_UP)
-    //#define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons&EN_REPRAPWORLD_KEYPAD_MIDDLE)
+
+    // REPRAPWORLD_KEYPAD defined in ultralcd.h
 
   #elif ENABLED(NEWPANEL)
     #define LCD_CLICKED (buttons&EN_C)

