commit 3c97fa6e29de6effb3ee8ed91cefbfc682cd4a7f (from 48e63c47300107c9a102f2b3055a9bb5fa252b93)
Merge: 48e63c4 f8df88f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 7 00:33:42 2016 -0500

    Merge pull request #4963 from esenapaj/Fix-for-advance-algorithm
    
    Move routine of direction signal of ADVANCE and LIN_ADVANCE from Stepper::isr() to Stepper::advance_isr()

diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 7674bd2..f2800eb 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -91,7 +91,7 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
 
-  unsigned char Stepper::old_OCR0A;
+  unsigned char Stepper::old_OCR0A = 0;
   volatile unsigned char Stepper::eISR_Rate = 200; // Keep the ISR at a low rate until needed
 
   #if ENABLED(LIN_ADVANCE)
@@ -299,14 +299,16 @@ void Stepper::set_directions() {
     SET_STEP_DIR(Z); // C
   #endif
 
-  if (motor_direction(E_AXIS)) {
-    REV_E_DIR();
-    count_direction[E_AXIS] = -1;
-  }
-  else {
-    NORM_E_DIR();
-    count_direction[E_AXIS] = 1;
-  }
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    if (motor_direction(E_AXIS)) {
+      REV_E_DIR();
+      count_direction[E_AXIS] = -1;
+    }
+    else {
+      NORM_E_DIR();
+      count_direction[E_AXIS] = 1;
+    }
+  #endif // !ADVANCE && !LIN_ADVANCE
 }
 
 // "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.
@@ -680,15 +682,29 @@ void Stepper::isr() {
     old_OCR0A += eISR_Rate;
     OCR0A = old_OCR0A;
 
+    #define SET_E_STEP_DIR(INDEX) \
+      if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
+
     #define START_E_PULSE(INDEX) \
       if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
 
     #define STOP_E_PULSE(INDEX) \
       if (e_steps[INDEX]) { \
-        e_steps[INDEX] <= 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
+        e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
         E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
       }
 
+    SET_E_STEP_DIR(0);
+    #if E_STEPPERS > 1
+      SET_E_STEP_DIR(1);
+      #if E_STEPPERS > 2
+        SET_E_STEP_DIR(2);
+        #if E_STEPPERS > 3
+          SET_E_STEP_DIR(3);
+        #endif
+      #endif
+    #endif
+
     #define CYCLES_EATEN_BY_E 60
 
     // Step all E steppers that have steps

commit 3c97fa6e29de6effb3ee8ed91cefbfc682cd4a7f (from f8df88f27120f3a20cf775e0f8051dc6e0702119)
Merge: 48e63c4 f8df88f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 7 00:33:42 2016 -0500

    Merge pull request #4963 from esenapaj/Fix-for-advance-algorithm
    
    Move routine of direction signal of ADVANCE and LIN_ADVANCE from Stepper::isr() to Stepper::advance_isr()

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index e8fcb35..b9e8f35 100755
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -402,8 +402,10 @@ uint8_t active_extruder = 0;
 // Relative Mode. Enable with G91, disable with G90.
 static bool relative_mode = false;
 
+// For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
+// For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if ENABLED(EMERGENCY_PARSER) && DISABLED(ULTIPANEL)
   volatile bool wait_for_user = false;
 #endif
@@ -412,6 +414,7 @@ const char errormagic[] PROGMEM = "Error:";
 const char echomagic[] PROGMEM = "echo:";
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 
+// Number of characters read in the current line of serial input
 static int serial_count = 0;
 
 const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
@@ -2267,7 +2270,7 @@ static void clean_up_after_endstop_or_probe_move() {
         if (y < 10) SERIAL_CHAR(' ');
         SERIAL_ECHO((int)y);
         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
-        SERIAL_ECHOLN(']');
+        SERIAL_CHAR(']');
       }
     #endif
     if (bed_level_grid[x][y] < 999.0) {
@@ -2276,6 +2279,7 @@ static void clean_up_after_endstop_or_probe_move() {
       #endif
       return;  // Don't overwrite good values.
     }
+    SERIAL_EOL;
 
     // Get X neighbors, Y neighbors, and XY neighbors
     float a1 = bed_level_grid[x + xdir][y], a2 = bed_level_grid[x + xdir * 2][y],
@@ -2362,7 +2366,7 @@ static void clean_up_after_endstop_or_probe_move() {
     SERIAL_EOL;
     for (uint8_t y = 0; y < ABL_GRID_POINTS_Y; y++) {
       if (y < 9) SERIAL_PROTOCOLCHAR(' ');
-      SERIAL_PROTOCOL(y);
+      SERIAL_PROTOCOL((int)y);
       for (uint8_t x = 0; x < ABL_GRID_POINTS_X; x++) {
         SERIAL_PROTOCOLCHAR(' ');
         float offset = bed_level_grid[x][y];
@@ -3826,6 +3830,7 @@ inline void gcode_G28() {
           || left_probe_bed_position != bilinear_start[X_AXIS]
           || front_probe_bed_position != bilinear_start[Y_AXIS]
         ) {
+          reset_bed_level();
           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
           bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);

