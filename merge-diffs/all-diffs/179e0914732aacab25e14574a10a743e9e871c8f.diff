commit 179e0914732aacab25e14574a10a743e9e871c8f (from 0b2c608d2f642126f1ee03c4fb9981a7ff830610)
Merge: 0b2c608 23043a1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 22 16:08:10 2016 -0700

    Merge pull request #4374 from thinkyhead/rc_jbrazio_timestamp_t
    
    Implements timestamp_t structure

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 3e2c641..f880434 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -60,6 +60,7 @@
 #include "pins_arduino.h"
 #include "math.h"
 #include "nozzle.h"
+#include "timestamp_t.h"
 
 #if ENABLED(USE_WATCHDOG)
   #include "watchdog.h"
@@ -4052,22 +4053,15 @@ inline void gcode_M17() {
  * M31: Get the time since the start of SD Print (or last M109)
  */
 inline void gcode_M31() {
-  millis_t t = print_job_timer.duration();
-  int d = int(t / 60 / 60 / 24),
-      h = int(t / 60 / 60) % 60,
-      m = int(t / 60) % 60,
-      s = int(t % 60);
-  char time[18];                                          // 123456789012345678
-  if (d)
-    sprintf_P(time, PSTR("%id %ih %im %is"), d, h, m, s); // 99d 23h 59m 59s
-  else
-    sprintf_P(time, PSTR("%ih %im %is"), h, m, s);        // 23h 59m 59s
+  char buffer[21];
+  timestamp_t time(print_job_timer.duration());
+  time.toString(buffer);
 
-  lcd_setstatus(time);
+  lcd_setstatus(buffer);
 
   SERIAL_ECHO_START;
   SERIAL_ECHOPGM(MSG_PRINT_TIME " ");
-  SERIAL_ECHOLN(time);
+  SERIAL_ECHOLN(buffer);
 
   thermalManager.autotempShutdown();
 }
diff --git a/Marlin/point_t.h b/Marlin/point_t.h
index dbad668..360abce 100644
--- a/Marlin/point_t.h
+++ b/Marlin/point_t.h
@@ -23,18 +23,49 @@
 #ifndef __POINT_T__
 #define __POINT_T__
 
+/**
+ * @brief Cartesian Point
+ * @details Represents a three dimensional point on Cartesian coordinate system,
+ *          using an additional fourth dimension for the extrusion length.
+ *
+ * @param x The x-coordinate of the point.
+ * @param y The y-coordinate of the point.
+ * @param z The z-coordinate of the point.
+ * @param e The e-coordinate of the point.
+ */
 struct point_t {
   float x;
   float y;
   float z;
   float e;
 
+  /**
+   * @brief Two dimensional point constructor
+   *
+   * @param x The x-coordinate of the point.
+   * @param y The y-coordinate of the point.
+   */
   point_t(float const x, float const y)
     : point_t(x, y, NAN, NAN) {}
 
+  /**
+   * @brief Three dimensional point constructor
+   *
+   * @param x The x-coordinate of the point.
+   * @param y The y-coordinate of the point.
+   * @param z The z-coordinate of the point.
+   */
   point_t(float const x, float const y, float const z)
     : point_t(x, y, z, NAN) {}
 
+  /**
+   * @brief Tree dimensional point constructor with extrusion length
+   *
+   * @param x The x-coordinate of the point.
+   * @param y The y-coordinate of the point.
+   * @param z The z-coordinate of the point.
+   * @param e The e-coordinate of the point.
+   */
   point_t(float const x, float const y, float const z, float const e) {
     this->x = x;
     this->y = y;
@@ -43,4 +74,4 @@ struct point_t {
   }
 };
 
-#endif
+#endif // __POINT_T__
diff --git a/Marlin/printcounter.cpp b/Marlin/printcounter.cpp
index 489503c..9bfb0f7 100644
--- a/Marlin/printcounter.cpp
+++ b/Marlin/printcounter.cpp
@@ -22,6 +22,7 @@
 
 #include "Marlin.h"
 #include "printcounter.h"
+#include "timestamp_t.h"
 
 PrintCounter::PrintCounter(): super() {
   this->loadStats();
@@ -92,6 +93,9 @@ void PrintCounter::saveStats() {
 }
 
 void PrintCounter::showStats() {
+  char buffer[21];
+  timestamp_t time;
+
   SERIAL_PROTOCOLPGM(MSG_STATS);
 
   SERIAL_ECHOPGM("Prints: ");
@@ -107,17 +111,11 @@ void PrintCounter::showStats() {
   SERIAL_EOL;
   SERIAL_PROTOCOLPGM(MSG_STATS);
 
-  uint32_t t = this->data.printTime / 60;
-  SERIAL_ECHOPGM("Total time: ");
-
-  SERIAL_ECHO(t / 60 / 24);
-  SERIAL_ECHOPGM("d ");
+  time.timestamp = this->data.printTime;
+  time.toString(buffer);
 
-  SERIAL_ECHO((t / 60) % 24);
-  SERIAL_ECHOPGM("h ");
-
-  SERIAL_ECHO(t % 60);
-  SERIAL_ECHOPGM("min");
+  SERIAL_ECHOPGM("Total time: ");
+  SERIAL_ECHO(buffer);
 
   #if ENABLED(DEBUG_PRINTCOUNTER)
     SERIAL_ECHOPGM(" (");
@@ -125,17 +123,11 @@ void PrintCounter::showStats() {
     SERIAL_ECHOPGM(")");
   #endif
 
-  uint32_t l = this->data.longestPrint / 60;
-  SERIAL_ECHOPGM(", Longest job: ");
-
-  SERIAL_ECHO(l / 60 / 24);
-  SERIAL_ECHOPGM("d ");
+  time.timestamp = this->data.longestPrint;
+  time.toString(buffer);
 
-  SERIAL_ECHO((l / 60) % 24);
-  SERIAL_ECHOPGM("h ");
-
-  SERIAL_ECHO(l % 60);
-  SERIAL_ECHOPGM("min");
+  SERIAL_ECHOPGM(", Longest job: ");
+  SERIAL_ECHO(buffer);
 
   #if ENABLED(DEBUG_PRINTCOUNTER)
     SERIAL_ECHOPGM(" (");
diff --git a/Marlin/timestamp_t.h b/Marlin/timestamp_t.h
new file mode 100644
index 0000000..2a18eb0
--- /dev/null
+++ b/Marlin/timestamp_t.h
@@ -0,0 +1,118 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __TIMESTAMP_T__
+#define __TIMESTAMP_T__
+
+struct timestamp_t {
+  /**
+   * @brief Number of seconds
+   */
+  uint32_t timestamp;
+
+  /**
+   * @brief Date time blank constructor
+   */
+  timestamp_t()
+    : timestamp_t(0) {};
+
+  /**
+   * @brief Date time constructor
+   * @details Initializes the timestamp_t structure based on a number of seconds
+   *
+   * @param seconds The number of seconds
+   */
+  timestamp_t(uint32_t const &seconds) {
+    this->timestamp = seconds;
+  }
+
+  /**
+   * @brief Formats the date as number of years
+   * @return The number of years
+   */
+  inline uint8_t year() const {
+    return this->day() / 365;
+  }
+
+  /**
+   * @brief Formats the date as number of days
+   * @return The number of days
+   */
+  inline uint16_t day() const {
+    return this->hour() / 24;
+  }
+
+  /**
+   * @brief Formats the date as number of hours
+   * @return The number of hours
+   */
+  inline uint32_t hour() const {
+    return this->minute() / 60;
+  }
+
+  /**
+   * @brief Formats the date as number of minutes
+   * @return The number of minutes
+   */
+  inline uint32_t minute() const {
+    return this->second() / 60;
+  }
+
+  /**
+   * @brief Formats the date as number of seconds
+   * @return The number of seconds
+   */
+  inline uint32_t second() const {
+    return this->timestamp;
+  }
+
+  /**
+   * @brief Formats the date as a string
+   * @details Returns the timestamp formated as a string
+   *
+   * @param buffer The array pointed to must be able to accommodate 21 bytes
+   *
+   * String output examples:
+   *  123456789012345678901 (strlen)
+   *  135y 364d 23h 59m 59s
+   *  364d 23h 59m 59s
+   *  23h 59m 59s
+   *  59m 59s
+   *  59s
+   *
+   */
+  void toString(char *buffer) const {
+    int y = this->year(),
+        d = this->day() % 365,
+        h = this->hour() % 24,
+        m = this->minute() % 60,
+        s = this->second() % 60;
+
+    if (y) sprintf_P(buffer, PSTR("%iy %id %ih %im %is"), y, d, h, m, s);
+    else if (d) sprintf_P(buffer, PSTR("%id %ih %im %is"), d, h, m, s);
+    else if (h) sprintf_P(buffer, PSTR("%ih %im %is"), h, m, s);
+    else if (m) sprintf_P(buffer, PSTR("%im %is"), m, s);
+    else sprintf_P(buffer, PSTR("%is"), s);
+  }
+};
+
+#endif // __TIMESTAMP_T__

commit 179e0914732aacab25e14574a10a743e9e871c8f (from 23043a1e057df3831f369452956a43efa3fdaab4)
Merge: 0b2c608 23043a1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 22 16:08:10 2016 -0700

    Merge pull request #4374 from thinkyhead/rc_jbrazio_timestamp_t
    
    Implements timestamp_t structure

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ad85923..f880434 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1680,35 +1680,35 @@ void do_blocking_move_to(float x, float y, float z, float fr_mm_m /*=0.0*/) {
 
     feedrate_mm_m = (fr_mm_m != 0.0) ? fr_mm_m : XY_PROBE_FEEDRATE_MM_M;
 
+    set_destination_to_current();          // sync destination at the start
+
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
-      if (delta_clip_start_height < z) { // staying in the danger zone
-        destination[X_AXIS] = x;         // move directly
+      if (z > delta_clip_start_height) {   // staying in the danger zone
+        destination[X_AXIS] = x;           // move directly (uninterpolated)
         destination[Y_AXIS] = y;
         destination[Z_AXIS] = z;
-        prepare_move_to_destination_raw(); // this will also set_current_to_destination
+        prepare_move_to_destination_raw(); // set_current_to_destination
         return;
-      } else {                           // leave the danger zone
-        destination[X_AXIS] = current_position[X_AXIS];
-        destination[Y_AXIS] = current_position[Y_AXIS];
+      }
+      else {
         destination[Z_AXIS] = delta_clip_start_height;
-        prepare_move_to_destination_raw(); // this will also set_current_to_destination
+        prepare_move_to_destination_raw(); // set_current_to_destination
       }
     }
-    if (current_position[Z_AXIS] < z) {  // raise
-      destination[X_AXIS] = current_position[X_AXIS];
-      destination[Y_AXIS] = current_position[Y_AXIS];
+
+    if (z > current_position[Z_AXIS]) {    // raising?
       destination[Z_AXIS] = z;
-      prepare_move_to_destination_raw(); // this will also set_current_to_destination
+      prepare_move_to_destination_raw();   // set_current_to_destination
     }
+
     destination[X_AXIS] = x;
     destination[Y_AXIS] = y;
-    destination[Z_AXIS] = current_position[Z_AXIS];
-    prepare_move_to_destination(); // this will also set_current_to_destination
+    prepare_move_to_destination();         // set_current_to_destination
 
-    if (current_position[Z_AXIS] > z) { // lower
+    if (z < current_position[Z_AXIS]) {    // lowering?
       destination[Z_AXIS] = z;
-      prepare_move_to_destination_raw(); // this will also set_current_to_destination
+      prepare_move_to_destination_raw();   // set_current_to_destination
     }
 
   #else
@@ -2088,9 +2088,9 @@ static void clean_up_after_endstop_or_probe_move() {
   }
 
   #if ENABLED(DELTA)
-    #define SET_CURRENT_FROM_STEPPERS() current_position[Z_AXIS] = z_before - stepper.get_axis_position_mm(Z_AXIS) + z_mm
+    #define Z_FROM_STEPPERS() z_before + stepper.get_axis_position_mm(Z_AXIS) - z_mm
   #else
-    #define SET_CURRENT_FROM_STEPPERS() current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS)
+    #define Z_FROM_STEPPERS() stepper.get_axis_position_mm(Z_AXIS)
   #endif
 
   // Do a single Z probe and return with current_position[Z_AXIS]
@@ -2105,31 +2105,28 @@ static void clean_up_after_endstop_or_probe_move() {
     #endif
 
     #if ENABLED(DELTA)
-      float z_before = current_position[Z_AXIS];
-      float z_mm = stepper.get_axis_position_mm(Z_AXIS);
+      float z_before = current_position[Z_AXIS],         // Current Z
+            z_mm = stepper.get_axis_position_mm(Z_AXIS); // Some tower's current position
     #endif
-    current_position[Z_AXIS] = -(Z_MAX_LENGTH + 10);
-    do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_FAST);
-    endstops.hit_on_purpose(); // clear endstop hit flags
-    // Get the current stepper position after bumping an endstop
-    SET_CURRENT_FROM_STEPPERS();
-    SYNC_PLAN_POSITION_KINEMATIC(); // tell the planner where we are
+
+    do_blocking_move_to_z(-(Z_MAX_LENGTH + 10), Z_PROBE_SPEED_FAST);
+    endstops.hit_on_purpose();
+    current_position[Z_AXIS] = Z_FROM_STEPPERS();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     // move up the retract distance
-    current_position[Z_AXIS] += home_bump_mm(Z_AXIS);
-    do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_FAST);
+    do_blocking_move_to_z(current_position[Z_AXIS] + home_bump_mm(Z_AXIS), Z_PROBE_SPEED_FAST);
 
     #if ENABLED(DELTA)
       z_before = current_position[Z_AXIS];
       z_mm = stepper.get_axis_position_mm(Z_AXIS);
     #endif
+
     // move back down slowly to find bed
-    current_position[Z_AXIS] -= home_bump_mm(Z_AXIS) * 2;
-    do_blocking_move_to_z(current_position[Z_AXIS], Z_PROBE_SPEED_SLOW);
-    endstops.hit_on_purpose(); // clear endstop hit flags
-    // Get the current stepper position after bumping an endstop
-    SET_CURRENT_FROM_STEPPERS();
-    SYNC_PLAN_POSITION_KINEMATIC(); // tell the planner where we are
+    do_blocking_move_to_z(current_position[Z_AXIS] - home_bump_mm(Z_AXIS) * 2, Z_PROBE_SPEED_SLOW);
+    endstops.hit_on_purpose();
+    current_position[Z_AXIS] = Z_FROM_STEPPERS();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe", current_position);
@@ -6665,7 +6662,6 @@ inline void invalid_extruder_error(const uint8_t &e) {
 }
 
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_m/*=0.0*/, bool no_move/*=false*/) {
-
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS) {
@@ -6945,6 +6941,9 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_m/*=0.0*/, bool n
       // Set the new active extruder
       active_extruder = tmp_extruder;
 
+      UNUSED(fr_mm_m);
+      UNUSED(no_move);
+
     #endif // HOTENDS <= 1
 
     SERIAL_ECHO_START;

