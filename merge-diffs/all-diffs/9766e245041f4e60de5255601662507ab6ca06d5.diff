commit 9766e245041f4e60de5255601662507ab6ca06d5 (from 02285662f5afc29b08d5c6e32155f157a5532b53)
Merge: 0228566 10ebf28
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 16 23:49:33 2016 -0700

    Merge pull request #4277 from thinkyhead/rc_mks_13_viki2
    
    Support for VIKI2 with MKS 1.3 / 1.4

diff --git a/Marlin/pins_MKS_13.h b/Marlin/pins_MKS_13.h
index 1b25653..00da206 100644
--- a/Marlin/pins_MKS_13.h
+++ b/Marlin/pins_MKS_13.h
@@ -37,6 +37,88 @@
 #define HEATER_1_PIN        7 // EXTRUDER 2 (-1 on RAMPS 1.4)
 
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
-  //#undef SD_DETECT_PIN
-  //#define SD_DETECT_PIN 49  // For easy adapter board
+  /**
+   * VIKI2 Has two groups of wires with...
+   *
+   * +Vin     + Input supply, requires 120ma for LCD and mSD card
+   * GND      Ground Pin
+   * MOSI     Data input for LCD and SD
+   * MISO     Data output for SD
+   * SCK      Clock for LCD and SD
+   * AO       Reg. Sel for LCD
+   * LCS      Chip Select for LCD
+   * SDCS     Chip Select for SD
+   * SDCD     Card Detect pin for SD
+   * ENCA     Encoder output A
+   * ENCB     Encoder output B
+   * ENCBTN   Encoder button switch
+   *
+   * BTN      Panel mounted button switch
+   * BUZZER   Piezo buzzer
+   * BLUE-LED Blue LED ring pin (3 to 5v, mosfet buffered)
+   * RED-LED  Red LED ring pin (3 to 5v, mosfet buffered)
+   *
+   * This configuration uses the following arrangement:
+   *
+   * EXP1 D37 = EN2   D35 = EN1     EXP2 D50 = MISO  D52 = SCK
+   *      D17 = BLUE  D16 = RED          D31 = ENC   D53 = SDCS
+   *      D23 = KILL  D25 = BUZZ         D33 = ---   D51 = MOSI
+   *      D27 = A0    D29 = LCS          D49 = SDCD  RST = ---
+   *      GND = GND   5V  = 5V           GND = ---   D41 = ---
+   */
+
+  #undef BTN_EN1
+  #undef BTN_EN2
+  #undef BTN_ENC
+  #undef DOGLCD_A0
+  #undef DOGLCD_CS
+  #undef SD_DETECT_PIN
+  #undef BEEPER_PIN
+  #undef KILL_PIN
+
+  //
+  // VIKI2 12-wire lead
+  //
+
+  // orange/white         SDCD
+  #define SD_DETECT_PIN   49
+
+  // white                ENCA
+  #define BTN_EN1         35
+
+  // green                ENCB
+  #define BTN_EN2         37
+
+  // purple               ENCBTN
+  #define BTN_ENC         31
+
+  // brown                A0
+  #define DOGLCD_A0       27
+
+  // green/white          LCS
+  #define DOGLCD_CS       29
+
+                       // 50    gray   MISO
+                       // 51    yellow MOSI
+                       // 52    orange SCK
+
+  // blue                 SDCS
+  //#define SDSS            53
+
+  //
+  // VIKI2 4-wire lead
+  //
+
+  // blue                 BTN
+  #define KILL_PIN        23
+
+  // green                BUZZER
+  #define BEEPER_PIN      25
+
+  // yellow               RED-LED
+  #define STAT_LED_RED    16
+
+  // white                BLUE-LED
+  #define STAT_LED_BLUE   17
+
 #endif
diff --git a/Marlin/pins_RAMPS_14.h b/Marlin/pins_RAMPS_14.h
index 0a63c24..8731845 100644
--- a/Marlin/pins_RAMPS_14.h
+++ b/Marlin/pins_RAMPS_14.h
@@ -141,22 +141,30 @@
 
 #if ENABLED(ULTRA_LCD)
 
+  #if ENABLED(NEWPANEL) && ENABLED(PANEL_ONE)
+    #define LCD_PINS_RS 40
+    #define LCD_PINS_ENABLE 42
+    #define LCD_PINS_D4 65
+    #define LCD_PINS_D5 66
+    #define LCD_PINS_D6 44
+    #define LCD_PINS_D7 64
+  #else
+    #define BEEPER_PIN 33
+    #define LCD_PINS_RS 16
+    #define LCD_PINS_ENABLE 17
+    #define LCD_PINS_D4 23
+    #define LCD_PINS_D5 25
+    #define LCD_PINS_D6 27
+    #define LCD_PINS_D7 29
+    // Buttons are attached to a shift register
+    // Not wired yet
+    //#define SHIFT_CLK 38
+    //#define SHIFT_LD 42
+    //#define SHIFT_OUT 40
+    //#define SHIFT_EN 17
+  #endif
+
   #if ENABLED(NEWPANEL)
-    #if ENABLED(PANEL_ONE)
-      #define LCD_PINS_RS 40
-      #define LCD_PINS_ENABLE 42
-      #define LCD_PINS_D4 65
-      #define LCD_PINS_D5 66
-      #define LCD_PINS_D6 44
-      #define LCD_PINS_D7 64
-    #else
-      #define LCD_PINS_RS 16
-      #define LCD_PINS_ENABLE 17
-      #define LCD_PINS_D4 23
-      #define LCD_PINS_D5 25
-      #define LCD_PINS_D6 27
-      #define LCD_PINS_D7 29
-    #endif
 
     #if ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER)
       #define BEEPER_PIN 37
@@ -272,26 +280,7 @@
       #endif
 
     #endif
-  #else // !NEWPANEL (Old-style panel with shift register)
-
-    // No Beeper added
-    #define BEEPER_PIN 33
-
-    // Buttons are attached to a shift register
-    // Not wired yet
-    //#define SHIFT_CLK 38
-    //#define SHIFT_LD 42
-    //#define SHIFT_OUT 40
-    //#define SHIFT_EN 17
-
-    #define LCD_PINS_RS 16
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25
-    #define LCD_PINS_D6 27
-    #define LCD_PINS_D7 29
-
-  #endif // !NEWPANEL
+  #endif // NEWPANEL
 
 #endif // ULTRA_LCD
 
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 3003bfd..5437248 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -184,9 +184,10 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
     static void menu_action_sddirectory(const char* filename, char* longFilename);
   #endif
 
-  #define ENCODER_FEEDRATE_DEADZONE 10
-
   #if DISABLED(LCD_I2C_VIKI)
+    #ifndef ENCODER_FEEDRATE_DEADZONE
+      #define ENCODER_FEEDRATE_DEADZONE 10
+    #endif
     #ifndef ENCODER_STEPS_PER_MENU_ITEM
       #define ENCODER_STEPS_PER_MENU_ITEM 5
     #endif
@@ -194,6 +195,9 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       #define ENCODER_PULSES_PER_STEP 1
     #endif
   #else
+    #ifndef ENCODER_FEEDRATE_DEADZONE
+      #define ENCODER_FEEDRATE_DEADZONE 4
+    #endif
     #ifndef ENCODER_STEPS_PER_MENU_ITEM
       #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation
     #endif

commit 9766e245041f4e60de5255601662507ab6ca06d5 (from 10ebf28ee3ca3fb6aea07d9a3edf0bf17cabad5a)
Merge: 0228566 10ebf28
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 16 23:49:33 2016 -0700

    Merge pull request #4277 from thinkyhead/rc_mks_13_viki2
    
    Support for VIKI2 with MKS 1.3 / 1.4

diff --git a/.travis.yml b/.travis.yml
index eb471fd..5d7b7b6 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -211,6 +211,18 @@ script:
   - opt_enable PRINTCOUNTER
   - build_marlin
   #
+  # Test NOZZLE_PARK_FEATURE
+  #
+  - restore_configs
+  - opt_enable NOZZLE_PARK_FEATURE
+  - build_marlin
+  #
+  # Test NOZZLE_CLEAN_FEATURE
+  #
+  - restore_configs
+  - opt_enable AUTO_BED_LEVELING_FEATURE NOZZLE_CLEAN_FEATURE FIX_MOUNTED_PROBE
+  - build_marlin
+  #
   #
   ######## STANDARD LCD/PANELS ##############
   #
diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index 4108014..bfd485f 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -55,7 +55,7 @@
     #define LCD_CONTRAST_MIN 60
     #define LCD_CONTRAST_MAX 140
   #endif
-  
+
   #if ENABLED(MAKRPANEL) || ENABLED(MINIPANEL)
     #define DOGLCD
     #define ULTIPANEL
@@ -118,12 +118,7 @@
     #define REPRAP_DISCOUNT_SMART_CONTROLLER
   #endif
 
-  #if ENABLED(ULTIMAKERCONTROLLER) || ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER) || ENABLED(G3D_PANEL) || ENABLED(RIGIDBOT_PANEL)
-    #define ULTIPANEL
-    #define NEWPANEL
-  #endif
-
-  #if ENABLED(REPRAPWORLD_KEYPAD)
+  #if ENABLED(ULTIMAKERCONTROLLER) || ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER) || ENABLED(G3D_PANEL) || ENABLED(RIGIDBOT_PANEL) || ENABLED(REPRAPWORLD_KEYPAD)
     #define ULTIPANEL
     #define NEWPANEL
   #endif
@@ -274,6 +269,10 @@
     #endif
   #endif
 
+  #ifndef BOOTSCREEN_TIMEOUT
+    #define BOOTSCREEN_TIMEOUT 2500
+  #endif
+
 #else // CONFIGURATION_LCD
 
   #define CONDITIONALS_H
@@ -818,6 +817,16 @@
     #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_3
       #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
     #endif
+    #if ENABLED(AUTO_BED_LEVELING_GRID)
+      #define DELTA_BED_LEVELING_GRID
+    #endif
+  #endif
+
+  /**
+   * When not using other bed leveling...
+   */
+  #if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(AUTO_BED_LEVELING_GRID) && DISABLED(DELTA_BED_LEVELING_GRID)
+    #define AUTO_BED_LEVELING_3POINT
   #endif
 
   /**
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index a7e77c2..d55bbe9 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -98,7 +98,23 @@
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
 #define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_Bootscreen.h"
+#endif
 
 // @section machine
 
@@ -779,13 +795,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -827,10 +915,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 82b19de..027132d 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/M100_Free_Mem_Chk.cpp b/Marlin/M100_Free_Mem_Chk.cpp
index 8804bab..8268946 100644
--- a/Marlin/M100_Free_Mem_Chk.cpp
+++ b/Marlin/M100_Free_Mem_Chk.cpp
@@ -43,23 +43,23 @@
 #include "Marlin.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
-extern void* __brkval;
+extern char* __brkval;
 extern size_t  __heap_start, __heap_end, __flp;
-
+extern char __bss_end;
 
 //
 // Utility functions used by M100 to get its work done.
 //
 
-unsigned char* top_of_stack();
+char* top_of_stack();
 void prt_hex_nibble(unsigned int);
 void prt_hex_byte(unsigned int);
 void prt_hex_word(unsigned int);
-int how_many_E5s_are_here(unsigned char*);
+int how_many_E5s_are_here(char*);
 
 void gcode_M100() {
-  static int m100_not_initialized = 1;
-  unsigned char* sp, *ptr;
+  static bool m100_not_initialized = true;
+  char* sp, *ptr;
   int i, j, n;
   //
   // M100 D dumps the free memory block from __brkval to the stack pointer.
@@ -72,19 +72,19 @@ void gcode_M100() {
   //
   #if ENABLED(M100_FREE_MEMORY_DUMPER) // Disable to remove Dump sub-command
     if (code_seen('D')) {
-      ptr = (unsigned char*) __brkval;
+      ptr = __brkval ? __brkval : &__bss_end;
       //
       // We want to start and end the dump on a nice 16 byte boundry even though
       // the values we are using are not 16 byte aligned.
       //
-      SERIAL_ECHOPGM("\n__brkval : ");
+      SERIAL_ECHOPGM("\nbss_end : ");
       prt_hex_word((unsigned int) ptr);
-      ptr = (unsigned char*)((unsigned long) ptr & 0xfff0);
+      ptr = (char*)((unsigned long) ptr & 0xfff0);
       sp = top_of_stack();
       SERIAL_ECHOPGM("\nStack Pointer : ");
       prt_hex_word((unsigned int) sp);
       SERIAL_EOL;
-      sp = (unsigned char*)((unsigned long) sp | 0x000f);
+      sp = (char*)((unsigned long) sp | 0x000f);
       n = sp - ptr;
       //
       // This is the main loop of the Dump command.
@@ -95,21 +95,17 @@ void gcode_M100() {
         for (i = 0; i < 16; i++) {      // and 16 data bytes
           prt_hex_byte(*(ptr + i));
           SERIAL_CHAR(' ');
-          delay(2);
         }
         SERIAL_CHAR('|');         // now show where non 0xE5's are
         for (i = 0; i < 16; i++) {
-          delay(2);
-          if (*(ptr + i) == 0xe5)
+          if (*(ptr + i) == (char)0xe5)
             SERIAL_CHAR(' ');
           else
             SERIAL_CHAR('?');
         }
         SERIAL_EOL;
         ptr += 16;
-        delay(2);
       }
-      SERIAL_ECHOLNPGM("Done.");
       return;
     }
   #endif
@@ -119,17 +115,17 @@ void gcode_M100() {
   //
   if (code_seen('F')) {
     #if 0
-      int max_addr = (int) __brkval;
+      int max_addr = (int)  __brkval ? __brkval : &__bss_end;
       int max_cnt = 0;
     #endif
     int block_cnt = 0;
-    ptr = (unsigned char*) __brkval;
+    ptr =  __brkval ? __brkval : &__bss_end;
     sp = top_of_stack();
     n = sp - ptr;
     // Scan through the range looking for the biggest block of 0xE5's we can find
     for (i = 0; i < n; i++) {
-      if (*(ptr + i) == (unsigned char) 0xe5) {
-        j = how_many_E5s_are_here((unsigned char*) ptr + i);
+      if (*(ptr + i) == (char)0xe5) {
+        j = how_many_E5s_are_here(ptr + i);
         if (j > 8) {
           SERIAL_ECHOPAIR("Found ", j);
           SERIAL_ECHOPGM(" bytes free at 0x");
@@ -148,7 +144,6 @@ void gcode_M100() {
     }
     if (block_cnt > 1)
       SERIAL_ECHOLNPGM("\nMemory Corruption detected in free memory area.");
-    SERIAL_ECHOLNPGM("\nDone.");
     return;
   }
   //
@@ -159,8 +154,8 @@ void gcode_M100() {
     if (code_seen('C')) {
       int x = code_value_int(); // x gets the # of locations to corrupt within the memory pool
       SERIAL_ECHOLNPGM("Corrupting free memory block.\n");
-      ptr = (unsigned char*) __brkval;
-      SERIAL_ECHOPAIR("\n__brkval : ", ptr);
+      ptr = __brkval ? __brkval : &__bss_end;
+      SERIAL_ECHOPAIR("\nbss_end : ", ptr);
       ptr += 8;
       sp = top_of_stack();
       SERIAL_ECHOPAIR("\nStack Pointer : ", sp);
@@ -181,10 +176,10 @@ void gcode_M100() {
   // M100 I    Initializes the free memory pool so it can be watched and prints vital
   // statistics that define the free memory pool.
   //
-  if (m100_not_initialized || code_seen('I')) {       // If no sub-command is specified, the first time
-    SERIAL_ECHOLNPGM("Initializing free memory block.\n");    // this happens, it will Initialize.
-    ptr = (unsigned char*) __brkval;        // Repeated M100 with no sub-command will not destroy the
-    SERIAL_ECHOPAIR("\n__brkval : ", ptr);     // state of the initialized free memory pool.
+  if (m100_not_initialized || code_seen('I')) {            // If no sub-command is specified, the first time
+    SERIAL_ECHOLNPGM("Initializing free memory block.\n"); // this happens, it will Initialize.
+    ptr = __brkval ? __brkval : &__bss_end;                // Repeated M100 with no sub-command will not destroy the
+    SERIAL_ECHOPAIR("\nbss_end : ", ptr);                  // state of the initialized free memory pool.
     ptr += 8;
     sp = top_of_stack();
     SERIAL_ECHOPAIR("\nStack Pointer : ", sp);
@@ -194,16 +189,15 @@ void gcode_M100() {
     SERIAL_ECHO(n);
     SERIAL_ECHOLNPGM(" bytes of memory initialized.\n");
     for (i = 0; i < n; i++)
-      *(ptr + i) = (unsigned char) 0xe5;
+      *(ptr + i) = (char)0xe5;
     for (i = 0; i < n; i++) {
-      if (*(ptr + i) != (unsigned char) 0xe5) {
+      if (*(ptr + i) != (char)0xe5) {
         SERIAL_ECHOPAIR("? address : ", ptr + i);
         SERIAL_ECHOPAIR("=", *(ptr + i));
         SERIAL_ECHOLNPGM("\n");
       }
     }
-    m100_not_initialized = 0;
-    SERIAL_ECHOLNPGM("Done.\n");
+    m100_not_initialized = false;
     return;
   }
   return;
@@ -212,8 +206,8 @@ void gcode_M100() {
 // top_of_stack() returns the location of a variable on its stack frame.  The value returned is above
 // the stack once the function returns to the caller.
 
-unsigned char* top_of_stack() {
-  unsigned char x;
+char* top_of_stack() {
+  char x;
   return &x + 1; // x is pulled on return;
 }
 
@@ -226,7 +220,6 @@ void prt_hex_nibble(unsigned int n) {
     SERIAL_ECHO(n);
   else
     SERIAL_ECHO((char)('A' + n - 10));
-  delay(2);
 }
 
 void prt_hex_byte(unsigned int b) {
@@ -242,10 +235,10 @@ void prt_hex_word(unsigned int w) {
 // how_many_E5s_are_here() is a utility function to easily find out how many 0xE5's are
 // at the specified location.  Having this logic as a function simplifies the search code.
 //
-int how_many_E5s_are_here(unsigned char* p) {
+int how_many_E5s_are_here(char* p) {
   int n;
   for (n = 0; n < 32000; n++) {
-    if (*(p + n) != (unsigned char) 0xe5)
+    if (*(p + n) != (char)0xe5)
       return n - 1;
   }
   return -1;
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 5c69883..d7c14d2 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -134,73 +134,69 @@ void manage_inactivity(bool ignore_stepper_queue = false);
   extern bool extruder_duplication_enabled;
 #endif
 
-#if ENABLED(DUAL_X_CARRIAGE) && HAS_X_ENABLE && HAS_X2_ENABLE
-  #define  enable_x() do { X_ENABLE_WRITE( X_ENABLE_ON); X2_ENABLE_WRITE( X_ENABLE_ON); } while (0)
-  #define disable_x() do { X_ENABLE_WRITE(!X_ENABLE_ON); X2_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; } while (0)
+#if HAS_X2_ENABLE
+  #define  enable_x() do{ X_ENABLE_WRITE( X_ENABLE_ON); X2_ENABLE_WRITE( X_ENABLE_ON); }while(0)
+  #define disable_x() do{ X_ENABLE_WRITE(!X_ENABLE_ON); X2_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; }while(0)
 #elif HAS_X_ENABLE
   #define  enable_x() X_ENABLE_WRITE( X_ENABLE_ON)
-  #define disable_x() { X_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; }
+  #define disable_x() do{ X_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; }while(0)
 #else
-  #define enable_x() ;
-  #define disable_x() ;
+  #define  enable_x() NOOP
+  #define disable_x() NOOP
 #endif
 
-#if HAS_Y_ENABLE
-  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-    #define  enable_y() { Y_ENABLE_WRITE( Y_ENABLE_ON); Y2_ENABLE_WRITE(Y_ENABLE_ON); }
-    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); Y2_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }
-  #else
-    #define  enable_y() Y_ENABLE_WRITE( Y_ENABLE_ON)
-    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }
-  #endif
+#if HAS_Y2_ENABLE
+  #define  enable_y() do{ Y_ENABLE_WRITE( Y_ENABLE_ON); Y2_ENABLE_WRITE(Y_ENABLE_ON); }while(0)
+  #define disable_y() do{ Y_ENABLE_WRITE(!Y_ENABLE_ON); Y2_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }while(0)
+#elif HAS_Y_ENABLE
+  #define  enable_y() Y_ENABLE_WRITE( Y_ENABLE_ON)
+  #define disable_y() do{ Y_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }while(0)
 #else
-  #define enable_y() ;
-  #define disable_y() ;
+  #define  enable_y() NOOP
+  #define disable_y() NOOP
 #endif
 
-#if HAS_Z_ENABLE
-  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
-    #define  enable_z() { Z_ENABLE_WRITE( Z_ENABLE_ON); Z2_ENABLE_WRITE(Z_ENABLE_ON); }
-    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); Z2_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }
-  #else
-    #define  enable_z() Z_ENABLE_WRITE( Z_ENABLE_ON)
-    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }
-  #endif
+#if HAS_Z2_ENABLE
+  #define  enable_z() do{ Z_ENABLE_WRITE( Z_ENABLE_ON); Z2_ENABLE_WRITE(Z_ENABLE_ON); }while(0)
+  #define disable_z() do{ Z_ENABLE_WRITE(!Z_ENABLE_ON); Z2_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }while(0)
+#elif HAS_Z_ENABLE
+  #define  enable_z() Z_ENABLE_WRITE( Z_ENABLE_ON)
+  #define disable_z() do{ Z_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }while(0)
 #else
-  #define enable_z() ;
-  #define disable_z() ;
+  #define  enable_z() NOOP
+  #define disable_z() NOOP
 #endif
 
 #if HAS_E0_ENABLE
-  #define enable_e0()  E0_ENABLE_WRITE( E_ENABLE_ON)
+  #define  enable_e0() E0_ENABLE_WRITE( E_ENABLE_ON)
   #define disable_e0() E0_ENABLE_WRITE(!E_ENABLE_ON)
 #else
-  #define enable_e0()  /* nothing */
-  #define disable_e0() /* nothing */
+  #define  enable_e0() NOOP
+  #define disable_e0() NOOP
 #endif
 
 #if (EXTRUDERS > 1) && HAS_E1_ENABLE
-  #define enable_e1()  E1_ENABLE_WRITE( E_ENABLE_ON)
+  #define  enable_e1() E1_ENABLE_WRITE( E_ENABLE_ON)
   #define disable_e1() E1_ENABLE_WRITE(!E_ENABLE_ON)
 #else
-  #define enable_e1()  /* nothing */
-  #define disable_e1() /* nothing */
+  #define  enable_e1() NOOP
+  #define disable_e1() NOOP
 #endif
 
 #if (EXTRUDERS > 2) && HAS_E2_ENABLE
-  #define enable_e2()  E2_ENABLE_WRITE( E_ENABLE_ON)
+  #define  enable_e2() E2_ENABLE_WRITE( E_ENABLE_ON)
   #define disable_e2() E2_ENABLE_WRITE(!E_ENABLE_ON)
 #else
-  #define enable_e2()  /* nothing */
-  #define disable_e2() /* nothing */
+  #define  enable_e2() NOOP
+  #define disable_e2() NOOP
 #endif
 
 #if (EXTRUDERS > 3) && HAS_E3_ENABLE
-  #define enable_e3()  E3_ENABLE_WRITE( E_ENABLE_ON)
+  #define  enable_e3() E3_ENABLE_WRITE( E_ENABLE_ON)
   #define disable_e3() E3_ENABLE_WRITE(!E_ENABLE_ON)
 #else
-  #define enable_e3()  /* nothing */
-  #define disable_e3() /* nothing */
+  #define  enable_e3() NOOP
+  #define disable_e3() NOOP
 #endif
 
 /**
@@ -305,6 +301,7 @@ float code_value_temp_diff();
   extern float delta_diagonal_rod_trim_tower_3;
   void calculate_delta(float cartesian[3]);
   void recalc_delta_settings(float radius, float diagonal_rod);
+  float delta_safe_distance_from_top();
   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
     extern int delta_grid_spacing[2];
     void adjust_delta(float cartesian[3]);
@@ -392,4 +389,6 @@ void calculate_volumetric_multipliers();
   #endif
 #endif
 
+void safe_delay(uint16_t del);
+
 #endif //MARLIN_H
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index bf76754..d0921f4 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -542,6 +542,8 @@ MarlinSerial customizedSerial;
             case state_M410:
               quickstop_stepper();
               break;
+            default:
+              break;
           }
           state = state_RESET;
         }
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 89ab461..14c427b 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -106,8 +106,9 @@
  * G3  - CCW ARC
  * G4  - Dwell S<seconds> or P<milliseconds>
  * G5  - Cubic B-spline with XYZE destination and IJPQ offsets
- * G10 - retract filament according to settings of M207
- * G11 - retract recover filament according to settings of M208
+ * G10 - Retract filament according to settings of M207
+ * G11 - Retract recover filament according to settings of M208
+ * G12 - Clean tool
  * G20 - Set input units to inches
  * G21 - Set input units to millimeters
  * G28 - Home one or more axes
@@ -321,6 +322,9 @@ float home_offset[3] = { 0 };
 // Software Endstops. Default to configured limits.
 float sw_endstop_min[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
 float sw_endstop_max[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+#if ENABLED(DELTA)
+  float delta_clip_start_height = Z_MAX_POS;
+#endif
 
 #if FAN_COUNT > 0
   int fanSpeeds[FAN_COUNT] = { 0 };
@@ -573,22 +577,29 @@ void serial_echopair_P(const char* s_P, unsigned long v) { serialprintPGM(s_P);
 static void report_current_position();
 
 #if ENABLED(DEBUG_LEVELING_FEATURE)
-  void print_xyz(const char* suffix, const float x, const float y, const float z) {
+  void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
+    serialprintPGM(prefix);
     SERIAL_ECHOPAIR("(", x);
     SERIAL_ECHOPAIR(", ", y);
     SERIAL_ECHOPAIR(", ", z);
-    SERIAL_ECHOLNPGM(") ");
-    SERIAL_ECHO(suffix);
+    SERIAL_ECHOPGM(")");
+
+    if (suffix) serialprintPGM(suffix);
+    else SERIAL_EOL;
   }
-  void print_xyz(const char* suffix, const float xyz[]) {
-    print_xyz(suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
+
+  void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
+    print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
   }
+
   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    void print_xyz(const char* suffix, const vector_3 &xyz) {
-      print_xyz(suffix, xyz.x, xyz.y, xyz.z);
+    void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
+      print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
     }
   #endif
-  #define DEBUG_POS(PREFIX,VAR) do{ SERIAL_ECHOPGM(PREFIX); print_xyz(" > " STRINGIFY(VAR), VAR); }while(0)
+
+  #define DEBUG_POS(SUFFIX,VAR) do { \
+    print_xyz(PSTR(STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
 #endif
 
 #if ENABLED(DELTA) || ENABLED(SCARA)
@@ -935,7 +946,7 @@ void setup() {
   lcd_init();
   #if ENABLED(SHOW_BOOTSCREEN)
     #if ENABLED(DOGLCD)
-      delay(1000);
+      safe_delay(BOOTSCREEN_TIMEOUT);
     #elif ENABLED(ULTRA_LCD)
       bootscreen();
       lcd_init();
@@ -1168,14 +1179,6 @@ inline void get_serial_commands() {
       ) {
         if (card_eof) {
           SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-          print_job_timer.stop();
-          char time[30];
-          millis_t t = print_job_timer.duration();
-          int hours = t / 60 / 60, minutes = (t / 60) % 60;
-          sprintf_P(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);
-          SERIAL_ECHO_START;
-          SERIAL_ECHOLN(time);
-          lcd_setstatus(time, true);
           card.printingHasFinished();
           card.checkautostart(true);
         }
@@ -1442,6 +1445,23 @@ static void update_software_endstops(AxisEnum axis) {
     sw_endstop_max[axis] = base_max_pos(axis) + offs;
   }
 
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("For ", axis_codes[axis]);
+      SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
+      SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
+      SERIAL_ECHOPAIR("\n sw_endstop_min = ", sw_endstop_min[axis]);
+      SERIAL_ECHOPAIR("\n sw_endstop_max = ", sw_endstop_max[axis]);
+      SERIAL_EOL;
+    }
+  #endif
+
+  #if ENABLED(DELTA)
+    if (axis == Z_AXIS) {
+      delta_clip_start_height = sw_endstop_max[axis] - delta_safe_distance_from_top();
+    }
+  #endif
+
 }
 
 /**
@@ -1525,12 +1545,12 @@ static void set_axis_is_at_home(AxisEnum axis) {
     current_position[axis] = base_home_pos(axis) + home_offset[axis];
     update_software_endstops(axis);
 
-    #if HAS_BED_PROBE && Z_HOME_DIR < 0
+    #if HAS_BED_PROBE && Z_HOME_DIR < 0 && DISABLED(Z_MIN_PROBE_ENDSTOP)
       if (axis == Z_AXIS) {
         current_position[Z_AXIS] -= zprobe_zoffset;
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPAIR("> zprobe_zoffset==", zprobe_zoffset);
+            SERIAL_ECHOPAIR("> zprobe_zoffset = ", zprobe_zoffset);
             SERIAL_EOL;
           }
         #endif
@@ -1539,7 +1559,9 @@ static void set_axis_is_at_home(AxisEnum axis) {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("> home_offset[axis]==", home_offset[axis]);
+        SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
+        SERIAL_ECHOPAIR("] = ", home_offset[axis]);
+        SERIAL_EOL;
         DEBUG_POS("", current_position);
       }
     #endif
@@ -1601,6 +1623,89 @@ inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[
 inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }
 inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }
 
+#if ENABLED(DELTA)
+  /**
+   * Calculate delta, start a line, and set current_position to destination
+   */
+  void prepare_move_to_destination_raw() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_move_to_destination_raw", destination);
+    #endif
+    refresh_cmd_timeout();
+    calculate_delta(destination);
+    planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], (feedrate / 60) * (feedrate_multiplier / 100.0), active_extruder);
+    set_current_to_destination();
+  }
+#endif
+
+/**
+ *  Plan a move to (X, Y, Z) and set the current_position
+ *  The final current_position may not be the one that was requested
+ */
+static void do_blocking_move_to(float x, float y, float z, float feed_rate = 0.0) {
+  float old_feedrate = feedrate;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) print_xyz(PSTR("do_blocking_move_to"), NULL, x, y, z);
+  #endif
+
+  #if ENABLED(DELTA)
+
+    feedrate = (feed_rate != 0.0) ? feed_rate : XY_PROBE_FEEDRATE;
+
+    destination[X_AXIS] = x;
+    destination[Y_AXIS] = y;
+    destination[Z_AXIS] = z;
+
+    if (x == current_position[X_AXIS] && y == current_position[Y_AXIS])
+      prepare_move_to_destination_raw(); // this will also set_current_to_destination
+    else
+      prepare_move_to_destination();     // this will also set_current_to_destination
+
+  #else
+
+    // If Z needs to raise, do it before moving XY
+    if (current_position[Z_AXIS] < z) {
+      feedrate = (feed_rate != 0.0) ? feed_rate : homing_feedrate[Z_AXIS];
+      current_position[Z_AXIS] = z;
+      line_to_current_position();
+    }
+
+    feedrate = (feed_rate != 0.0) ? feed_rate : XY_PROBE_FEEDRATE;
+    current_position[X_AXIS] = x;
+    current_position[Y_AXIS] = y;
+    line_to_current_position();
+
+    // If Z needs to lower, do it after moving XY
+    if (current_position[Z_AXIS] > z) {
+      feedrate = (feed_rate != 0.0) ? feed_rate : homing_feedrate[Z_AXIS];
+      current_position[Z_AXIS] = z;
+      line_to_current_position();
+    }
+
+  #endif
+
+  stepper.synchronize();
+
+  feedrate = old_feedrate;
+}
+
+inline void do_blocking_move_to_x(float x, float feed_rate = 0.0) {
+  do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS], feed_rate);
+}
+
+inline void do_blocking_move_to_y(float y) {
+  do_blocking_move_to(current_position[X_AXIS], y, current_position[Z_AXIS]);
+}
+
+inline void do_blocking_move_to_xy(float x, float y, float feed_rate = 0.0) {
+  do_blocking_move_to(x, y, current_position[Z_AXIS], feed_rate);
+}
+
+inline void do_blocking_move_to_z(float z, float feed_rate = 0.0) {
+  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z, feed_rate);
+}
+
 //
 // Prepare to do endstop or probe moves
 // with custom feedrates.
@@ -1630,89 +1735,8 @@ static void clean_up_after_endstop_or_probe_move() {
 }
 
 #if HAS_BED_PROBE
-  #if ENABLED(DELTA)
-    /**
-     * Calculate delta, start a line, and set current_position to destination
-     */
-    void prepare_move_to_destination_raw() {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_move_to_destination_raw", destination);
-      #endif
-      refresh_cmd_timeout();
-      calculate_delta(destination);
-      planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], (feedrate / 60) * (feedrate_multiplier / 100.0), active_extruder);
-      set_current_to_destination();
-    }
-  #endif
-
-  /**
-   *  Plan a move to (X, Y, Z) and set the current_position
-   *  The final current_position may not be the one that was requested
-   */
-  static void do_blocking_move_to(float x, float y, float z, float feed_rate = 0.0) {
-    float old_feedrate = feedrate;
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) print_xyz("do_blocking_move_to", x, y, z);
-    #endif
-
-    #if ENABLED(DELTA)
-
-      feedrate = (feed_rate != 0.0) ? feed_rate : XY_PROBE_FEEDRATE;
-
-      destination[X_AXIS] = x;
-      destination[Y_AXIS] = y;
-      destination[Z_AXIS] = z;
-
-      if (x == current_position[X_AXIS] && y == current_position[Y_AXIS])
-        prepare_move_to_destination_raw(); // this will also set_current_to_destination
-      else
-        prepare_move_to_destination();     // this will also set_current_to_destination
-
-    #else
-
-      // If Z needs to raise, do it before moving XY
-      if (current_position[Z_AXIS] < z) {
-        feedrate = (feed_rate != 0.0) ? feed_rate : homing_feedrate[Z_AXIS];
-        current_position[Z_AXIS] = z;
-        line_to_current_position();
-      }
-
-      feedrate = (feed_rate != 0.0) ? feed_rate : XY_PROBE_FEEDRATE;
-      current_position[X_AXIS] = x;
-      current_position[Y_AXIS] = y;
-      line_to_current_position();
-
-      // If Z needs to lower, do it after moving XY
-      if (current_position[Z_AXIS] > z) {
-        feedrate = (feed_rate != 0.0) ? feed_rate : homing_feedrate[Z_AXIS];
-        current_position[Z_AXIS] = z;
-        line_to_current_position();
-      }
-
-    #endif
-
-    stepper.synchronize();
-
-    feedrate = old_feedrate;
-  }
-
-  inline void do_blocking_move_to_x(float x, float feed_rate = 0.0) {
-    do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS], feed_rate);
-  }
-
-  inline void do_blocking_move_to_z(float z, float feed_rate = 0.0) {
-    do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z, feed_rate);
-  }
-
   /**
    * Raise Z to a minimum height to make room for a probe to move
-   *
-   * zprobe_zoffset: Negative of the Z height where the probe engages
-   *        z_raise: The probing raise distance
-   *
-   * The zprobe_zoffset is negative for a switch below the nozzle, so
-   * multiply by Z_HOME_DIR (-1) to move enough away from the bed.
    */
   inline void do_probe_raise(float z_raise) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -1723,7 +1747,7 @@ static void clean_up_after_endstop_or_probe_move() {
     #endif
     float z_dest = home_offset[Z_AXIS] + z_raise;
 
-    if ((Z_HOME_DIR) < 0 && zprobe_zoffset < 0)
+    if (zprobe_zoffset < 0)
       z_dest -= zprobe_zoffset;
 
     if (z_dest > current_position[Z_AXIS])
@@ -1732,7 +1756,7 @@ static void clean_up_after_endstop_or_probe_move() {
 
 #endif //HAS_BED_PROBE
 
-#if ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || HAS_PROBING_PROCEDURE
+#if ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE)
   static bool axis_unhomed_error(const bool x, const bool y, const bool z) {
     const bool xx = x && !axis_homed[X_AXIS],
                yy = y && !axis_homed[Y_AXIS],
@@ -2107,10 +2131,6 @@ static void clean_up_after_endstop_or_probe_move() {
     return current_position[Z_AXIS];
   }
 
-  inline void do_blocking_move_to_xy(float x, float y, float feed_rate = 0.0) {
-    do_blocking_move_to(x, y, current_position[Z_AXIS], feed_rate);
-  }
-
   //
   // - Move to the given XY
   // - Deploy the probe, if not already deployed
@@ -2362,7 +2382,7 @@ static void homeaxis(AxisEnum axis) {
     home_dir(axis);
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
-  #if HAS_BED_PROBE
+  #if HAS_BED_PROBE && DISABLED(Z_MIN_PROBE_ENDSTOP)
     if (axis == Z_AXIS && axis_home_dir < 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOPGM("> ");
@@ -2463,7 +2483,7 @@ static void homeaxis(AxisEnum axis) {
   axis_homed[axis] = true;
 
   // Put away the Z probe
-  #if HAS_BED_PROBE
+  #if HAS_BED_PROBE && DISABLED(Z_MIN_PROBE_ENDSTOP)
     if (axis == Z_AXIS && axis_home_dir < 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOPGM("> ");
@@ -2544,8 +2564,14 @@ void gcode_get_destination() {
     else
       destination[i] = current_position[i];
   }
+
   if (code_seen('F') && code_value_linear_units() > 0.0)
     feedrate = code_value_linear_units();
+
+  #if ENABLED(PRINTCOUNTER)
+    if(!DEBUGGING(DRYRUN))
+      print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
+  #endif
 }
 
 void unknown_command_error() {
@@ -2716,6 +2742,24 @@ inline void gcode_G4() {
 
 #endif //FWRETRACT
 
+#if ENABLED(NOZZLE_CLEAN_FEATURE) && HAS_BED_PROBE
+  #include "nozzle.h"
+
+  /**
+   * G12: Clean the nozzle
+   */
+  inline void gcode_G12() {
+    // Don't allow nozzle cleaning without homing first
+    if (axis_unhomed_error(true, true, true)) { return; }
+
+    uint8_t const pattern = code_seen('P') ? code_value_ushort() : 0;
+    uint8_t const strokes = code_seen('S') ? code_value_ushort() : NOZZLE_CLEAN_STROKES;
+    uint8_t const objects = code_seen('T') ? code_value_ushort() : 3;
+
+    Nozzle::clean(pattern, strokes, objects);
+  }
+#endif
+
 #if ENABLED(INCH_MODE_SUPPORT)
   /**
    * G20: Set input mode to inches
@@ -2760,6 +2804,20 @@ inline void gcode_G4() {
 
 #endif // QUICK_HOME
 
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  #include "nozzle.h"
+
+  /**
+   * G27: Park the nozzle
+   */
+  inline void gcode_G27() {
+    // Don't allow nozzle parking without homing first
+    if (axis_unhomed_error(true, true, true)) { return; }
+    uint8_t const z_action = code_seen('P') ? code_value_ushort() : 0;
+    Nozzle::park(z_action);
+  }
+#endif // NOZZLE_PARK_FEATURE
+
 /**
  * G28: Home all axes according to settings
  *
@@ -2867,20 +2925,17 @@ inline void gcode_G28() {
 
       if (home_all_axis || homeX || homeY) {
         // Raise Z before homing any other axes and z is not already high enough (never lower z)
-        float z_dest = home_offset[Z_AXIS] + MIN_Z_HEIGHT_FOR_HOMING;
-        if (z_dest > current_position[Z_AXIS]) {
+        destination[Z_AXIS] = home_offset[Z_AXIS] + MIN_Z_HEIGHT_FOR_HOMING;
+        if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR("Raise Z (before homing) to ", z_dest);
+              SERIAL_ECHOPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
               SERIAL_EOL;
             }
           #endif
 
-          feedrate = homing_feedrate[Z_AXIS];
-          line_to_z(z_dest);
-          stepper.synchronize();
-          destination[Z_AXIS] = current_position[Z_AXIS] = z_dest;
+          do_blocking_move_to_z(destination[Z_AXIS]);
         }
       }
 
@@ -2967,8 +3022,6 @@ inline void gcode_G28() {
             destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - (Y_PROBE_OFFSET_FROM_EXTRUDER));
             destination[Z_AXIS] = current_position[Z_AXIS]; //z is already at the right height
 
-            feedrate = XY_PROBE_FEEDRATE;
-
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 DEBUG_POS("> Z_SAFE_HOMING > home_all_axis", current_position);
@@ -2977,15 +3030,7 @@ inline void gcode_G28() {
             #endif
 
             // Move in the XY plane
-            line_to_destination();
-            stepper.synchronize();
-
-            /**
-             * Update the current positions for XY, Z is still at least at
-             * MIN_Z_HEIGHT_FOR_HOMING height, no changes there.
-             */
-            current_position[X_AXIS] = destination[X_AXIS];
-            current_position[Y_AXIS] = destination[Y_AXIS];
+            do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
           }
 
           // Let's see if X and Y are homed
@@ -3077,6 +3122,11 @@ inline void gcode_G28() {
     }
   #endif
 
+  #if ENABLED(DELTA)
+    // move to a height where we can use the full xy-area
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+
   clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3953,12 +4003,22 @@ inline void gcode_M17() {
  */
 inline void gcode_M31() {
   millis_t t = print_job_timer.duration();
-  int min = t / 60, sec = t % 60;
-  char time[30];
-  sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
+  int d = int(t / 60 / 60 / 24),
+      h = int(t / 60 / 60) % 60,
+      m = int(t / 60) % 60,
+      s = int(t % 60);
+  char time[18];                                          // 123456789012345678
+  if (d)
+    sprintf_P(time, PSTR("%id %ih %im %is"), d, h, m, s); // 99d 23h 59m 59s
+  else
+    sprintf_P(time, PSTR("%ih %im %is"), h, m, s);        // 23h 59m 59s
+
+  lcd_setstatus(time);
+
   SERIAL_ECHO_START;
+  SERIAL_ECHOPGM(MSG_PRINT_TIME " ");
   SERIAL_ECHOLN(time);
-  lcd_setstatus(time);
+
   thermalManager.autotempShutdown();
 }
 
@@ -4333,7 +4393,7 @@ inline void gcode_M104() {
 
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
-       * Stop the timer at the end of print, starting is managed by 
+       * Stop the timer at the end of print, starting is managed by
        * 'heat and wait' M109.
        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
        * stand by mode, for instance in a dual extruder setup, without affecting
@@ -4488,6 +4548,13 @@ inline void gcode_M105() {
 
 #endif
 
+  #ifndef MIN_COOLING_SLOPE_DEG
+    #define MIN_COOLING_SLOPE_DEG 1.50
+  #endif
+  #ifndef MIN_COOLING_SLOPE_TIME
+    #define MIN_COOLING_SLOPE_TIME 60
+  #endif
+
 /**
  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
@@ -4600,11 +4667,11 @@ inline void gcode_M109() {
 
     // Prevent a wait-forever situation if R is misused i.e. M109 R0
     if (wants_to_cool) {
-      if (temp < (EXTRUDE_MINTEMP) / 2) break; // always break at (default) 85°
-      // break after 20 seconds if cooling stalls
+      // break after MIN_COOLING_SLOPE_TIME seconds
+      // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
-        if (old_temp - temp < 1.0) break;
-        next_cool_check_ms = now + 20000;
+        if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
+        next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
         old_temp = temp;
       }
     }
@@ -4617,6 +4684,13 @@ inline void gcode_M109() {
 
 #if HAS_TEMP_BED
 
+  #ifndef MIN_COOLING_SLOPE_DEG_BED
+    #define MIN_COOLING_SLOPE_DEG_BED 1.50
+  #endif
+  #ifndef MIN_COOLING_SLOPE_TIME_BED
+    #define MIN_COOLING_SLOPE_TIME_BED 60
+  #endif
+
   /**
    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
@@ -4631,7 +4705,7 @@ inline void gcode_M109() {
       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
         if (code_value_temp_abs() > BED_MINTEMP) {
           /**
-          * We start the timer when 'heating and waiting' command arrives, LCD 
+          * We start the timer when 'heating and waiting' command arrives, LCD
           * functions never wait. Cooling down managed by extruders.
           *
           * We do not check if the timer is already running because this check will
@@ -4709,11 +4783,11 @@ inline void gcode_M109() {
 
       // Prevent a wait-forever situation if R is misused i.e. M190 R0
       if (wants_to_cool) {
-        if (temp < 30.0) break; // always break at 30°
-        // break after 20 seconds if cooling stalls
+        // break after MIN_COOLING_SLOPE_TIME_BED seconds
+        // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
-          if (old_temp - temp < 1.0) break;
-          next_cool_check_ms = now + 20000;
+          if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
+          next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
           old_temp = temp;
         }
       }
@@ -4848,32 +4922,32 @@ inline void gcode_M140() {
         case 0:
           if (code_seen('H')) {
             v = code_value_int();
-            plaPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
+            preheatHotendTemp1 = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
           }
           if (code_seen('F')) {
             v = code_value_int();
-            plaPreheatFanSpeed = constrain(v, 0, 255);
+            preheatFanSpeed1 = constrain(v, 0, 255);
           }
           #if TEMP_SENSOR_BED != 0
             if (code_seen('B')) {
               v = code_value_int();
-              plaPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
+              preheatBedTemp1 = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
             }
           #endif
           break;
         case 1:
           if (code_seen('H')) {
             v = code_value_int();
-            absPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
+            preheatHotendTemp2 = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
           }
           if (code_seen('F')) {
             v = code_value_int();
-            absPreheatFanSpeed = constrain(v, 0, 255);
+            preheatFanSpeed2 = constrain(v, 0, 255);
           }
           #if TEMP_SENSOR_BED != 0
             if (code_seen('B')) {
               v = code_value_int();
-              absPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
+              preheatBedTemp2 = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
             }
           #endif
           break;
@@ -5689,10 +5763,36 @@ inline void gcode_M226() {
 #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
 
   /**
-   * M302: Allow cold extrudes, or set the minimum extrude S<temperature>.
+   * M302: Allow cold extrudes, or set the minimum extrude temperature
+   *
+   *       S<temperature> sets the minimum extrude temperature
+   *       P<bool> enables (1) or disables (0) cold extrusion
+   *
+   *  Examples:
+   *
+   *       M302         ; report current cold extrusion state
+   *       M302 P0      ; enable cold extrusion checking
+   *       M302 P1      ; disables cold extrusion checking
+   *       M302 S0      ; always allow extrusion (disables checking)
+   *       M302 S170    ; only allow extrusion above 170
+   *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
    */
   inline void gcode_M302() {
-    thermalManager.extrude_min_temp = code_seen('S') ? code_value_temp_abs() : 0;
+    bool seen_S = code_seen('S');
+    if (seen_S) {
+      thermalManager.extrude_min_temp = code_value_temp_abs();
+      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
+    }
+
+    if (code_seen('P'))
+      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || code_value_bool();
+    else if (!seen_S) {
+      // Report current state
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
+      SERIAL_ECHOPAIR("abled (min temp ", int(thermalManager.extrude_min_temp + 0.5));
+      SERIAL_ECHOLNPGM("C)");
+    }
   }
 
 #endif // PREVENT_DANGEROUS_EXTRUDE
@@ -5951,7 +6051,7 @@ void quickstop_stepper() {
    * Use either 'M421 X<linear> Y<linear> Z<linear>' or 'M421 I<xindex> J<yindex> Z<linear>'
    */
   inline void gcode_M421() {
-    int8_t px, py;
+    int8_t px = 0, py = 0;
     float z = 0;
     bool hasX, hasY, hasZ, hasI, hasJ;
     if ((hasX = code_seen('X'))) px = mbl.probe_index_x(code_value_axis_units(X_AXIS));
@@ -6196,7 +6296,9 @@ inline void gcode_M503() {
     disable_e3();
     delay(100);
 
-    millis_t next_tick = 0;
+    #if HAS_BUZZER
+      millis_t next_tick = 0;
+    #endif
 
     // Wait for filament insert by user and press button
     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
@@ -6481,11 +6583,37 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
     if (tmp_extruder != active_extruder) {
       bool no_move = code_seen('S') && code_value_bool();
-      // Save current position to return to after applying extruder offset
-      if (!no_move) set_destination_to_current();
+      if (!no_move && axis_unhomed_error(true, true, true)) {
+        SERIAL_ECHOLNPGM("No move on toolchange");
+        no_move = true;
+      }
+
+      // Save current position to destination, for use later
+      set_destination_to_current();
+
       #if ENABLED(DUAL_X_CARRIAGE)
-        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&
-            (delayed_move_time || current_position[X_AXIS] != x_home_pos(active_extruder))) {
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("Dual X Carriage Mode ");
+            switch (dual_x_carriage_mode) {
+              case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+              case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+              case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
+            }
+          }
+        #endif
+
+        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning()
+             && (delayed_move_time || current_position[X_AXIS] != x_home_pos(active_extruder))
+           ) {
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPAIR("Raise to ", current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT); SERIAL_EOL;
+              SERIAL_ECHOPAIR("MoveX to ", x_home_pos(active_extruder)); SERIAL_EOL;
+              SERIAL_ECHOPAIR("Lower to ", current_position[Z_AXIS]); SERIAL_EOL;
+            }
+          #endif
           // Park old head: 1) raise 2) move to park position 3) lower
           planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                            current_position[E_AXIS], planner.max_feedrate[Z_AXIS], active_extruder);
@@ -6504,52 +6632,67 @@ inline void gcode_T(uint8_t tmp_extruder) {
         // This function resets the max/min values - the current position may be overwritten below.
         set_axis_is_at_home(X_AXIS);
 
-        if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE) {
-          current_position[X_AXIS] = inactive_extruder_x_pos;
-          inactive_extruder_x_pos = destination[X_AXIS];
-        }
-        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
-          active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
-          if (active_extruder_parked)
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
+        #endif
+
+        switch (dual_x_carriage_mode) {
+          case DXC_FULL_CONTROL_MODE:
             current_position[X_AXIS] = inactive_extruder_x_pos;
-          else
-            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
-          inactive_extruder_x_pos = destination[X_AXIS];
-          extruder_duplication_enabled = false;
-        }
-        else {
-          // record raised toolhead position for use by unpark
-          memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
-          raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
-          active_extruder_parked = true;
-          delayed_move_time = 0;
+            inactive_extruder_x_pos = destination[X_AXIS];
+            break;
+          case DXC_DUPLICATION_MODE:
+            active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
+            if (active_extruder_parked)
+              current_position[X_AXIS] = inactive_extruder_x_pos;
+            else
+              current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
+            inactive_extruder_x_pos = destination[X_AXIS];
+            extruder_duplication_enabled = false;
+            break;
+          default:
+            // record raised toolhead position for use by unpark
+            memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
+            raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
+            active_extruder_parked = true;
+            delayed_move_time = 0;
+            break;
         }
-        // No extra case for AUTO_BED_LEVELING_FEATURE in DUAL_X_CARRIAGE. Does that mean they don't work together?
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+            SERIAL_EOL;
+            DEBUG_POS("New extruder (parked)", current_position);
+          }
+        #endif
+
+       // No extra case for AUTO_BED_LEVELING_FEATURE in DUAL_X_CARRIAGE. Does that mean they don't work together?
       #else // !DUAL_X_CARRIAGE
 
-        //
-        // Set current_position to the position of the new nozzle.
-        // Offsets are based on linear distance, so we need to get
-        // the resulting position in coordinate space.
-        //
-        // - With grid or 3-point leveling, offset XYZ by a tilted vector
-        // - With mesh leveling, update Z for the new position
-        // - Otherwise, just use the raw linear distance
-        //
-        // Software endstops are altered here too. Consider a case where:
-        //   E0 at X=0 ... E1 at X=10
-        // When we switch to E1 now X=10, but E1 can't move left.
-        // To express this we apply the change in XY to the software endstops.
-        // E1 can move farther right than E0, so the right limit is extended.
-        //
-        // Note that we don't adjust the Z software endstops. Why not?
-        // Consider a case where Z=0 (here) and switching to E1 makes Z=1
-        // because the bed is 1mm lower at the new position. As long as
-        // the first nozzle is out of the way, the carriage should be
-        // allowed to move 1mm lower. This technically "breaks" the
-        // Z software endstop. But this is technically correct (and
-        // there is no viable alternative).
-        //
+        /**
+         * Set current_position to the position of the new nozzle.
+         * Offsets are based on linear distance, so we need to get
+         * the resulting position in coordinate space.
+         *
+         * - With grid or 3-point leveling, offset XYZ by a tilted vector
+         * - With mesh leveling, update Z for the new position
+         * - Otherwise, just use the raw linear distance
+         *
+         * Software endstops are altered here too. Consider a case where:
+         *   E0 at X=0 ... E1 at X=10
+         * When we switch to E1 now X=10, but E1 can't move left.
+         * To express this we apply the change in XY to the software endstops.
+         * E1 can move farther right than E0, so the right limit is extended.
+         *
+         * Note that we don't adjust the Z software endstops. Why not?
+         * Consider a case where Z=0 (here) and switching to E1 makes Z=1
+         * because the bed is 1mm lower at the new position. As long as
+         * the first nozzle is out of the way, the carriage should be
+         * allowed to move 1mm lower. This technically "breaks" the
+         * Z software endstop. But this is technically correct (and
+         * there is no viable alternative).
+         */
         #if ENABLED(AUTO_BED_LEVELING_FEATURE)
           // Offset extruder, make sure to apply the bed level rotation matrix
           vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
@@ -6588,15 +6731,32 @@ inline void gcode_T(uint8_t tmp_extruder) {
           #if ENABLED(MESH_BED_LEVELING)
 
             if (mbl.active()) {
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
+              #endif
               float xpos = RAW_CURRENT_POSITION(X_AXIS),
                     ypos = RAW_CURRENT_POSITION(Y_AXIS);
               current_position[Z_AXIS] += mbl.get_z(xpos + xydiff[X_AXIS], ypos + xydiff[Y_AXIS]) - mbl.get_z(xpos, ypos);
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  SERIAL_ECHOPAIR(" after: ", current_position[Z_AXIS]);
+                  SERIAL_EOL;
+                }
+              #endif
             }
 
           #endif // MESH_BED_LEVELING
 
         #endif // !AUTO_BED_LEVELING_FEATURE
 
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
+            SERIAL_ECHOPAIR(", ", xydiff[X_AXIS]);
+            SERIAL_ECHOLNPGM(" }");
+          }
+        #endif
+
         // The newly-selected extruder XY is actually at...
         current_position[X_AXIS] += xydiff[X_AXIS];
         current_position[Y_AXIS] += xydiff[Y_AXIS];
@@ -6610,16 +6770,26 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
       #endif // !DUAL_X_CARRIAGE
 
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
+      #endif
+
       // Tell the planner the new "current position"
       SYNC_PLAN_POSITION_KINEMATIC();
 
       // Move to the "old position" (move the extruder into place)
-      if (!no_move && IsRunning()) prepare_move_to_destination();
+      if (!no_move && IsRunning()) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+        #endif
+        prepare_move_to_destination();
+      }
 
     } // (tmp_extruder != active_extruder)
 
+    stepper.synchronize();
+
     #if ENABLED(EXT_SOLENOID)
-      stepper.synchronize();
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif // EXT_SOLENOID
@@ -6710,12 +6880,10 @@ void process_next_command() {
 
       // G2, G3
       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
-
         case 2: // G2  - CW ARC
         case 3: // G3  - CCW ARC
           gcode_G2_G3(codenum == 2);
           break;
-
       #endif
 
       // G4 Dwell
@@ -6724,23 +6892,25 @@ void process_next_command() {
         break;
 
       #if ENABLED(BEZIER_CURVE_SUPPORT)
-
         // G5
         case 5: // G5  - Cubic B_spline
           gcode_G5();
           break;
-
       #endif // BEZIER_CURVE_SUPPORT
 
       #if ENABLED(FWRETRACT)
-
         case 10: // G10: retract
         case 11: // G11: retract_recover
           gcode_G10_G11(codenum == 10);
           break;
-
       #endif // FWRETRACT
 
+      #if ENABLED(NOZZLE_CLEAN_FEATURE) && HAS_BED_PROBE
+        case 12:
+          gcode_G12(); // G12: Nozzle Clean
+          break;
+      #endif // NOZZLE_CLEAN_FEATURE
+
       #if ENABLED(INCH_MODE_SUPPORT)
         case 20: //G20: Inch Mode
           gcode_G20();
@@ -6749,7 +6919,13 @@ void process_next_command() {
         case 21: //G21: MM Mode
           gcode_G21();
           break;
-      #endif
+      #endif // INCH_MODE_SUPPORT
+
+      #if ENABLED(NOZZLE_PARK_FEATURE)
+        case 27: // G27: Nozzle Park
+          gcode_G27();
+          break;
+      #endif // NOZZLE_PARK_FEATURE
 
       case 28: // G28: Home all axes, one at a time
         gcode_G28();
@@ -6759,7 +6935,7 @@ void process_next_command() {
         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points.
           gcode_G29();
           break;
-      #endif
+      #endif // AUTO_BED_LEVELING_FEATURE
 
       #if HAS_BED_PROBE
 
@@ -6778,7 +6954,6 @@ void process_next_command() {
               break;
 
         #endif // Z_PROBE_SLED
-
       #endif // HAS_BED_PROBE
 
       case 90: // G90
@@ -6807,7 +6982,6 @@ void process_next_command() {
         break;
 
       #if ENABLED(SDSUPPORT)
-
         case 20: // M20 - list SD card
           gcode_M20(); break;
         case 21: // M21 - init SD card
@@ -6840,7 +7014,6 @@ void process_next_command() {
 
         case 928: //M928 - Start SD write
           gcode_M928(); break;
-
       #endif //SDSUPPORT
 
       case 31: //M31 take time since the start of the SD print or an M109 command
@@ -6910,11 +7083,9 @@ void process_next_command() {
       #endif
 
       #if ENABLED(HOST_KEEPALIVE_FEATURE)
-
         case 113: // M113: Set Host Keepalive interval
           gcode_M113();
           break;
-
       #endif
 
       case 140: // M140: Set bed temp
@@ -7402,6 +7573,15 @@ void clamp_to_software_endstops(float target[3]) {
     */
   }
 
+  float delta_safe_distance_from_top() {
+    float cartesian[3] = { 0 };
+    calculate_delta(cartesian);
+    float distance = delta[TOWER_3];
+    cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
+    calculate_delta(cartesian);
+    return abs(distance - delta[TOWER_3]);
+  }
+
   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
 
     // Adjust print surface height by linear interpolation over the bed_level array.
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 17d6cff..8334b12 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -76,8 +76,14 @@
 /**
  * Dual Stepper Drivers
  */
-#if ENABLED(Z_DUAL_STEPPER_DRIVERS) && ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  #error "You cannot have dual stepper drivers for both Y and Z."
+#if ENABLED(X_DUAL_STEPPER_DRIVERS) && ENABLED(DUAL_X_CARRIAGE)
+  #error "DUAL_X_CARRIAGE is not compatible with X_DUAL_STEPPER_DRIVERS."
+#elif ENABLED(X_DUAL_STEPPER_DRIVERS) && (!HAS_X2_ENABLE || !HAS_X2_STEP || !HAS_X2_DIR)
+  #error "X_DUAL_STEPPER_DRIVERS requires X2 pins (and an extra E plug)."
+#elif ENABLED(Y_DUAL_STEPPER_DRIVERS) && (!HAS_Y2_ENABLE || !HAS_Y2_STEP || !HAS_Y2_DIR)
+  #error "Y_DUAL_STEPPER_DRIVERS requires Y2 pins (and an extra E plug)."
+#elif ENABLED(Z_DUAL_STEPPER_DRIVERS) && (!HAS_Z2_ENABLE || !HAS_Z2_STEP || !HAS_Z2_DIR)
+  #error "Z_DUAL_STEPPER_DRIVERS requires Z2 pins (and an extra E plug)."
 #endif
 
 /**
@@ -152,14 +158,6 @@
     #error "EXTRUDERS must be 1 with HEATERS_PARALLEL."
   #endif
 
-  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-    #error "EXTRUDERS must be 1 with Y_DUAL_STEPPER_DRIVERS."
-  #endif
-
-  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
-    #error "EXTRUDERS must be 1 with Z_DUAL_STEPPER_DRIVERS."
-  #endif
-
 #elif ENABLED(SINGLENOZZLE)
   #error "SINGLENOZZLE requires 2 or more EXTRUDERS."
 #endif
@@ -202,11 +200,9 @@
 #if ENABLED(MESH_BED_LEVELING)
   #if ENABLED(DELTA)
     #error "MESH_BED_LEVELING does not yet support DELTA printers."
-  #endif
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
     #error "Select AUTO_BED_LEVELING_FEATURE or MESH_BED_LEVELING, not both."
-  #endif
-  #if MESH_NUM_X_POINTS > 7 || MESH_NUM_Y_POINTS > 7
+  #elif MESH_NUM_X_POINTS > 7 || MESH_NUM_Y_POINTS > 7
     #error "MESH_NUM_X_POINTS and MESH_NUM_Y_POINTS need to be less than 8."
   #endif
 #elif ENABLED(MANUAL_BED_LEVELING)
@@ -219,6 +215,10 @@
 
 #if PROBE_SELECTED
 
+  #if ENABLED(Z_PROBE_SLED) && ENABLED(DELTA)
+    #error "You cannot use Z_PROBE_SLED with DELTA."
+  #endif
+
   /**
    * NUM_SERVOS is required for a Z servo probe
    */
@@ -327,6 +327,13 @@
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
 
   /**
+   * Delta has limited bed leveling options
+   */
+  #if ENABLED(DELTA) && DISABLED(AUTO_BED_LEVELING_GRID)
+    #error "You must use AUTO_BED_LEVELING_GRID for DELTA bed leveling."
+  #endif
+
+  /**
    * Require a Z min pin
    */
   #if !PIN_EXISTS(Z_MIN)
@@ -411,25 +418,6 @@
 #endif
 
 /**
- * Delta has limited bed leveling options
- */
-#if ENABLED(DELTA)
-
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-    #if DISABLED(AUTO_BED_LEVELING_GRID)
-      #error "Only AUTO_BED_LEVELING_GRID is supported with DELTA."
-    #endif
-
-    #if ENABLED(Z_PROBE_SLED)
-      #error "You cannot use Z_PROBE_SLED with DELTA."
-    #endif
-
-  #endif
-
-#endif
-
-/**
  * Don't set more than one kinematic type
  */
 #if (ENABLED(DELTA) && (ENABLED(SCARA) || ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ))) \
@@ -644,6 +632,25 @@
   #error "SERVO_DEACTIVATION_DELAY is deprecated. Use SERVO_DELAY instead."
 #elif ENABLED(FILAMENTCHANGEENABLE)
   #error "FILAMENTCHANGEENABLE is now FILAMENT_CHANGE_FEATURE. Please update your configuration."
+#elif defined(PLA_PREHEAT_HOTEND_TEMP)
+  #error "PLA_PREHEAT_HOTEND_TEMP is now PREHEAT_1_TEMP_HOTEND. Please update your configuration."
+#elif defined(PLA_PREHEAT_HPB_TEMP)
+  #error "PLA_PREHEAT_HPB_TEMP is now PREHEAT_1_TEMP_BED. Please update your configuration."
+#elif defined(PLA_PREHEAT_FAN_SPEED)
+  #error "PLA_PREHEAT_FAN_SPEED is now PREHEAT_1_FAN_SPEED. Please update your configuration."
+#elif defined(ABS_PREHEAT_HOTEND_TEMP)
+  #error "ABS_PREHEAT_HOTEND_TEMP is now PREHEAT_2_TEMP_HOTEND. Please update your configuration."
+#elif defined(ABS_PREHEAT_HPB_TEMP)
+  #error "ABS_PREHEAT_HPB_TEMP is now PREHEAT_2_TEMP_BED. Please update your configuration."
+#elif defined(ABS_PREHEAT_FAN_SPEED)
+  #error "ABS_PREHEAT_FAN_SPEED is now PREHEAT_2_FAN_SPEED. Please update your configuration."
+#endif
+
+/**
+ * Nozzle cleaning
+ */
+#if ENABLED(NOZZLE_CLEAN_FEATURE) && !HAS_BED_PROBE
+  #error Due to internal dependencies you must have a bed probe for NOZZLE_CLEAN_FEATURE to work
 #endif
 
 #endif //SANITYCHECK_H
diff --git a/Marlin/boards.h b/Marlin/boards.h
index 07ee68a..bf7be0e 100644
--- a/Marlin/boards.h
+++ b/Marlin/boards.h
@@ -29,6 +29,7 @@
 #define BOARD_GEN7_12           11   // Gen7 v1.1, v1.2
 #define BOARD_GEN7_13           12   // Gen7 v1.3
 #define BOARD_GEN7_14           13   // Gen7 v1.4
+#define BOARD_CNCONTROLS_11     111  // Cartesio CN Controls V11
 #define BOARD_CNCONTROLS_12     112  // Cartesio CN Controls V12
 #define BOARD_CHEAPTRONIC       2    // Cheaptronic v1.0
 #define BOARD_SETHI             20   // Sethi 3D_1
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index c87fe84..e967284 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -46,7 +46,7 @@ class Buzzer {
   private:
     struct state_t {
       tone_t   tone;
-      uint32_t timestamp;
+      uint32_t endtime;
     } state;
 
   protected:
@@ -82,7 +82,7 @@ class Buzzer {
      */
     void reset() {
       this->off();
-      this->state.timestamp = 0;
+      this->state.endtime = 0;
     }
 
   public:
@@ -97,7 +97,7 @@ class Buzzer {
     /**
      * @brief Add a tone to the queue
      * @details Adds a tone_t structure to the ring buffer, will block IO if the
-     * queue is full waiting for one slot to get available.
+     *          queue is full waiting for one slot to get available.
      *
      * @param duration Duration of the tone in milliseconds
      * @param frequency Frequency of the tone in hertz
@@ -114,17 +114,17 @@ class Buzzer {
     /**
      * @brief Loop function
      * @details This function should be called at loop, it will take care of
-     * playing the tones in the queue.
+     *          playing the tones in the queue.
      */
     virtual void tick() {
-      if (!this->state.timestamp) {
+      if (!this->state.endtime) {
         if (this->buffer.isEmpty()) return;
 
         this->state.tone = this->buffer.dequeue();
-        this->state.timestamp = millis() + this->state.tone.duration;
+        this->state.endtime = millis() + this->state.tone.duration;
         if (this->state.tone.frequency > 0) this->on();
       }
-      else if (millis() >= this->state.timestamp) this->reset();
+      else if (ELAPSED(millis(), this->state.endtime)) this->reset();
     }
 };
 
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 4b7aaf6..dd6ff9f 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -416,6 +416,7 @@ void CardReader::openFile(char* name, bool read, bool push_current/*=false*/) {
     else {
       saving = true;
       SERIAL_PROTOCOLPAIR(MSG_SD_WRITE_TO_FILE, name);
+      SERIAL_EOL;
       lcd_setstatus(fname);
     }
   }
@@ -601,19 +602,19 @@ void CardReader::updir() {
 
 void CardReader::printingHasFinished() {
   stepper.synchronize();
+  file.close();
   if (file_subcall_ctr > 0) { // Heading up to a parent file that called current as a procedure.
-    file.close();
     file_subcall_ctr--;
     openFile(proc_filenames[file_subcall_ctr], true, true);
     setIndex(filespos[file_subcall_ctr]);
     startFileprint();
   }
   else {
-    file.close();
     sdprinting = false;
     if (SD_FINISHED_STEPPERRELEASE)
       enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-    thermalManager.autotempShutdown();
+    print_job_timer.stop();
+    enqueue_and_echo_commands_P(PSTR("M31"));
   }
 }
 
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index c14e957..54c96b6 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -85,12 +85,12 @@
  *  285  M666 Z    z_endstop_adj (float)
  *
  * ULTIPANEL:
- *  289  M145 S0 H plaPreheatHotendTemp (int)
- *  291  M145 S0 B plaPreheatHPBTemp (int)
- *  293  M145 S0 F plaPreheatFanSpeed (int)
- *  295  M145 S1 H absPreheatHotendTemp (int)
- *  297  M145 S1 B absPreheatHPBTemp (int)
- *  299  M145 S1 F absPreheatFanSpeed (int)
+ *  289  M145 S0 H preheatHotendTemp1 (int)
+ *  291  M145 S0 B preheatBedTemp1 (int)
+ *  293  M145 S0 F preheatFanSpeed1 (int)
+ *  295  M145 S1 H preheatHotendTemp2 (int)
+ *  297  M145 S1 B preheatBedTemp2 (int)
+ *  299  M145 S1 F preheatFanSpeed2 (int)
  *
  * PIDTEMP:
  *  301  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0] (float x4)
@@ -262,16 +262,16 @@ void Config_StoreSettings()  {
   #endif
 
   #if DISABLED(ULTIPANEL)
-    int plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP, plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP, plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED,
-        absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP, absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP, absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+    int preheatHotendTemp1 = PREHEAT_1_TEMP_HOTEND, preheatBedTemp1 = PREHEAT_1_TEMP_BED, preheatFanSpeed1 = PREHEAT_1_FAN_SPEED,
+        preheatHotendTemp2 = PREHEAT_2_TEMP_HOTEND, preheatBedTemp2 = PREHEAT_2_TEMP_BED, preheatFanSpeed2 = PREHEAT_2_FAN_SPEED;
   #endif // !ULTIPANEL
 
-  EEPROM_WRITE_VAR(i, plaPreheatHotendTemp);
-  EEPROM_WRITE_VAR(i, plaPreheatHPBTemp);
-  EEPROM_WRITE_VAR(i, plaPreheatFanSpeed);
-  EEPROM_WRITE_VAR(i, absPreheatHotendTemp);
-  EEPROM_WRITE_VAR(i, absPreheatHPBTemp);
-  EEPROM_WRITE_VAR(i, absPreheatFanSpeed);
+  EEPROM_WRITE_VAR(i, preheatHotendTemp1);
+  EEPROM_WRITE_VAR(i, preheatBedTemp1);
+  EEPROM_WRITE_VAR(i, preheatFanSpeed1);
+  EEPROM_WRITE_VAR(i, preheatHotendTemp2);
+  EEPROM_WRITE_VAR(i, preheatBedTemp2);
+  EEPROM_WRITE_VAR(i, preheatFanSpeed2);
 
   for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
 
@@ -447,16 +447,16 @@ void Config_RetrieveSettings() {
     #endif
 
     #if DISABLED(ULTIPANEL)
-      int plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed,
-          absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed;
+      int preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1,
+          preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2;
     #endif
 
-    EEPROM_READ_VAR(i, plaPreheatHotendTemp);
-    EEPROM_READ_VAR(i, plaPreheatHPBTemp);
-    EEPROM_READ_VAR(i, plaPreheatFanSpeed);
-    EEPROM_READ_VAR(i, absPreheatHotendTemp);
-    EEPROM_READ_VAR(i, absPreheatHPBTemp);
-    EEPROM_READ_VAR(i, absPreheatFanSpeed);
+    EEPROM_READ_VAR(i, preheatHotendTemp1);
+    EEPROM_READ_VAR(i, preheatBedTemp1);
+    EEPROM_READ_VAR(i, preheatFanSpeed1);
+    EEPROM_READ_VAR(i, preheatHotendTemp2);
+    EEPROM_READ_VAR(i, preheatBedTemp2);
+    EEPROM_READ_VAR(i, preheatFanSpeed2);
 
     #if ENABLED(PIDTEMP)
       for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
@@ -604,12 +604,12 @@ void Config_ResetDefault() {
   #endif
 
   #if ENABLED(ULTIPANEL)
-    plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;
-    plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;
-    plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;
-    absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;
-    absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
-    absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
+    preheatHotendTemp1 = PREHEAT_1_TEMP_HOTEND;
+    preheatBedTemp1 = PREHEAT_1_TEMP_BED;
+    preheatFanSpeed1 = PREHEAT_1_FAN_SPEED;
+    preheatHotendTemp2 = PREHEAT_2_TEMP_HOTEND;
+    preheatBedTemp2 = PREHEAT_2_TEMP_BED;
+    preheatFanSpeed2 = PREHEAT_2_FAN_SPEED;
   #endif
 
   #if HAS_LCD_CONTRAST
@@ -617,8 +617,8 @@ void Config_ResetDefault() {
   #endif
 
   #if ENABLED(PIDTEMP)
-    #if ENABLED(PID_PARAMS_PER_HOTEND)
-      HOTEND_LOOP
+    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+      HOTEND_LOOP()
     #else
       int e = 0; UNUSED(e); // only need to write once
     #endif
@@ -814,14 +814,14 @@ void Config_PrintSettings(bool forReplay) {
       SERIAL_ECHOLNPGM("Material heatup parameters:");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M145 S0 H", plaPreheatHotendTemp);
-    SERIAL_ECHOPAIR(" B", plaPreheatHPBTemp);
-    SERIAL_ECHOPAIR(" F", plaPreheatFanSpeed);
+    SERIAL_ECHOPAIR("  M145 S0 H", preheatHotendTemp1);
+    SERIAL_ECHOPAIR(" B", preheatBedTemp1);
+    SERIAL_ECHOPAIR(" F", preheatFanSpeed1);
     SERIAL_EOL;
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M145 S1 H", absPreheatHotendTemp);
-    SERIAL_ECHOPAIR(" B", absPreheatHPBTemp);
-    SERIAL_ECHOPAIR(" F", absPreheatFanSpeed);
+    SERIAL_ECHOPAIR("  M145 S1 H", preheatHotendTemp2);
+    SERIAL_ECHOPAIR(" B", preheatBedTemp2);
+    SERIAL_ECHOPAIR(" F", preheatFanSpeed2);
     SERIAL_EOL;
   #endif // ULTIPANEL
 
diff --git a/Marlin/dac_mcp4728.h b/Marlin/dac_mcp4728.h
index 18d22f2..26c5484 100644
--- a/Marlin/dac_mcp4728.h
+++ b/Marlin/dac_mcp4728.h
@@ -33,19 +33,19 @@
 #if ENABLED(DAC_STEPPER_CURRENT)
 #include "Wire.h"
 
-#define defaultVDD 5000
-#define BASE_ADDR 0x60
-#define RESET 0B00000110
-#define WAKE 0B00001001
-#define UPDATE 0B00001000
-#define MULTIWRITE 0B01000000
-#define SINGLEWRITE 0B01011000
-#define SEQWRITE 0B01010000
-#define VREFWRITE 0B10000000
-#define GAINWRITE 0B11000000
+#define defaultVDD     5000
+#define BASE_ADDR      0x60
+#define RESET          0B00000110
+#define WAKE           0B00001001
+#define UPDATE         0B00001000
+#define MULTIWRITE     0B01000000
+#define SINGLEWRITE    0B01011000
+#define SEQWRITE       0B01010000
+#define VREFWRITE      0B10000000
+#define GAINWRITE      0B11000000
 #define POWERDOWNWRITE 0B10100000
-#define GENERALCALL 0B0000000
-#define GAINWRITE 0B11000000
+#define GENERALCALL    0B00000000
+#define GAINWRITE      0B11000000
 
 // This is taken from the original lib, makes it easy to edit if needed
 // DAC_OR_ADDRESS defined in pins_BOARD.h  file
diff --git a/Marlin/dogm_custom_bitmaps.h b/Marlin/dogm_custom_bitmaps.h
deleted file mode 100644
index 4f30305..0000000
--- a/Marlin/dogm_custom_bitmaps.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * BitMap for custom splashscreen
- * Generated with: http://www.digole.com/tools/PicturetoC_Hex_converter.php
- */
-
-//#define CUSTOM_START_BMP
-
-#if ENABLED(CUSTOM_START_BMP)
-  
-  #define CUSTOM_START_BMP_DELAY     2000
-  #define CUSTOM_START_BMPWIDTH      112
-  #define CUSTOM_START_BMPHEIGHT      38
-  #define CUSTOM_START_BMPBYTEWIDTH   14
-  #define CUSTOM_START_BMPBYTES      532 // CUSTOM_START_BMPWIDTH * CUSTOM_START_BMPHEIGHT / 8
-
-  const unsigned char custom_start_bmp[CUSTOM_START_BMPBYTES] PROGMEM = {
-    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
-    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF,
-    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
-    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x3F, 0xFF,
-    0xC0, 0x0F, 0xC0, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x1F, 0xFF,
-    0xC0, 0x3F, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x0F, 0xFF,
-    0xC0, 0x7F, 0xF3, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x07, 0xFF,
-    0xC0, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x03, 0xFF,
-    0xC1, 0xF8, 0x7F, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x01, 0xFF,
-    0xC1, 0xF0, 0x3F, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFF,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x1F, 0x00, 0x03, 0xE0, 0x78, 0x3C, 0x03, 0xF0, 0x7F,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0xC0, 0x0F, 0xF8, 0x78, 0x3C, 0x07, 0xFC, 0x3F,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0xE0, 0x1F, 0xFC, 0x78, 0x3C, 0x0F, 0xFE, 0x1F,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0xF0, 0x3F, 0xFE, 0x78, 0x3C, 0x1F, 0xFE, 0x0F,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xF3, 0xF8, 0x3F, 0x3E, 0x78, 0x3C, 0x3F, 0x3F, 0x07,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xE0, 0xFC, 0x7C, 0x1F, 0x78, 0x3C, 0x3E, 0x1F, 0x07,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x7C, 0x7C, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x7C, 0x78, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xE0, 0x3C, 0x78, 0x00, 0x7C, 0x3C, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0x3F, 0xF8, 0x00, 0x7F, 0xBC, 0x3C, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0x3F, 0xF8, 0x00, 0x3F, 0xBF, 0xFC, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0xFF, 0x3F, 0xF8, 0x00, 0x1F, 0xBF, 0xFC, 0x0F, 0x03,
-    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0x3F, 0xF8, 0x00, 0x0F, 0xBF, 0xFC, 0x0F, 0x03,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
-    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
-    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
-    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
-    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
-    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
-    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80 };
-#endif
diff --git a/Marlin/dogm_font_data_ISO10646_Greek.h b/Marlin/dogm_font_data_ISO10646_Greek.h
new file mode 100644
index 0000000..0abb08d
--- /dev/null
+++ b/Marlin/dogm_font_data_ISO10646_Greek.h
@@ -0,0 +1,206 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+  Fontname: ISO10646_4_Greek
+  Copyright: A. Hardtung, public domain
+  Capital A Height: 7, '1' Height: 7
+  Calculated Max Values w= 5 h=10 x= 2 y= 6 dx= 6 dy= 0 ascent= 8 len=10
+  Font Bounding box     w= 6 h= 9 x= 0 y=-2
+  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0
+  Pure Font   ascent = 7 descent=-1
+  X Font      ascent = 7 descent=-1
+  Max Font    ascent = 8 descent=-2
+*/
+#include <U8glib.h>
+const u8g_fntpgm_uint8_t ISO10646_Greek_5x7[2728] U8G_SECTION(".progmem.ISO10646_Greek_5x7") = {
+  0,6,9,0,254,7,1,145,3,32,32,255,255,8,254,7,
+  255,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,
+  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,
+  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,
+  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,
+  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,
+  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,
+  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,
+  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,
+  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,
+  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,
+  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,
+  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,
+  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,
+  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,
+  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,
+  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,
+  48,64,128,240,136,136,112,5,7,7,6,0,0,248,8,16,
+  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,
+  112,5,7,7,6,0,0,112,136,136,120,8,16,96,2,5,
+  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,
+  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,
+  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,
+  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,
+  8,16,32,0,32,5,6,6,6,0,0,112,136,8,104,168,
+  112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,7,
+  7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,
+  0,112,136,128,128,128,136,112,5,7,7,6,0,0,224,144,
+  136,136,136,144,224,5,7,7,6,0,0,248,128,128,240,128,
+  128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,5,
+  7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,6,
+  0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,128,
+  128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,16,
+  16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,136,
+  5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,7,
+  6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,0,
+  136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,136,
+  136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,128,
+  128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,7,
+  7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,0,
+  0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,32,
+  32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,136,
+  136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,5,
+  7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,6,
+  0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,136,
+  136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,32,
+  64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,224,
+  5,5,5,6,0,1,128,64,32,16,8,3,7,7,6,1,
+  0,224,32,32,32,32,32,224,5,3,3,6,0,4,32,80,
+  136,5,1,1,6,0,0,248,2,2,2,6,2,5,128,64,
+  5,5,5,6,0,0,112,8,120,136,120,5,7,7,6,0,
+  0,128,128,176,200,136,136,240,5,5,5,6,0,0,112,128,
+  128,136,112,5,7,7,6,0,0,8,8,104,152,136,136,120,
+  5,5,5,6,0,0,112,136,248,128,112,5,7,7,6,0,
+  0,48,72,224,64,64,64,64,5,6,6,6,0,255,112,136,
+  136,120,8,112,5,7,7,6,0,0,128,128,176,200,136,136,
+  136,1,7,7,6,2,0,128,0,128,128,128,128,128,3,8,
+  8,6,1,255,32,0,32,32,32,32,160,64,4,7,7,6,
+  0,0,128,128,144,160,192,160,144,3,7,7,6,1,0,192,
+  64,64,64,64,64,224,5,5,5,6,0,0,208,168,168,168,
+  168,5,5,5,6,0,0,176,200,136,136,136,5,5,5,6,
+  0,0,112,136,136,136,112,5,6,6,6,0,255,240,136,136,
+  240,128,128,5,6,6,6,0,255,120,136,136,120,8,8,5,
+  5,5,6,0,0,176,200,128,128,128,5,5,5,6,0,0,
+  112,128,112,8,240,5,7,7,6,0,0,64,64,224,64,64,
+  72,48,5,5,5,6,0,0,136,136,136,152,104,5,5,5,
+  6,0,0,136,136,136,80,32,5,5,5,6,0,0,136,136,
+  168,168,80,5,5,5,6,0,0,136,80,32,80,136,5,6,
+  6,6,0,255,136,136,136,120,8,112,5,5,5,6,0,0,
+  248,16,32,64,248,3,7,7,6,1,0,32,64,64,128,64,
+  64,32,1,7,7,6,2,0,128,128,128,128,128,128,128,3,
+  7,7,6,1,0,128,64,64,32,64,64,128,5,2,2,6,
+  0,3,104,144,0,0,0,6,0,0,0,0,0,6,0,0,
+  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,
+  0,0,2,2,2,6,1,6,64,128,3,3,3,6,1,5,
+  32,64,160,5,8,8,6,0,0,64,160,80,80,136,248,136,
+  136,2,2,2,6,1,2,192,192,5,8,8,6,0,0,64,
+  128,248,128,240,128,128,248,5,8,8,6,0,0,64,128,136,
+  136,248,136,136,136,4,8,8,6,0,0,64,128,112,32,32,
+  32,32,112,0,0,0,6,0,0,5,8,8,6,0,0,64,
+  128,112,136,136,136,136,112,0,0,0,6,0,0,5,8,8,
+  6,0,0,64,128,8,136,112,32,32,32,5,8,8,6,0,
+  0,64,128,112,136,136,136,80,216,3,8,8,6,1,0,32,
+  64,160,0,64,64,64,32,5,7,7,6,0,0,32,80,136,
+  136,248,136,136,5,7,7,6,0,0,240,72,72,112,72,72,
+  240,5,7,7,6,0,0,248,128,128,128,128,128,128,5,6,
+  6,6,0,0,32,80,80,136,136,248,5,7,7,6,0,0,
+  248,128,128,240,128,128,248,5,7,7,6,0,0,248,8,16,
+  32,64,128,248,5,7,7,6,0,0,136,136,136,248,136,136,
+  136,5,7,7,6,0,0,112,136,136,168,136,136,112,3,7,
+  7,6,1,0,224,64,64,64,64,64,224,5,7,7,6,0,
+  0,136,144,160,192,160,144,136,5,7,7,6,0,0,32,80,
+  136,136,136,136,136,5,7,7,6,0,0,136,216,168,168,136,
+  136,136,5,7,7,6,0,0,136,200,200,168,152,152,136,5,
+  7,7,6,0,0,248,0,0,112,0,0,248,5,7,7,6,
+  0,0,112,136,136,136,136,136,112,5,7,7,6,0,0,248,
+  80,80,80,80,80,80,5,7,7,6,0,0,240,136,136,240,
+  128,128,128,0,0,0,6,0,0,5,7,7,6,0,0,248,
+  128,64,32,64,128,248,5,7,7,6,0,0,248,32,32,32,
+  32,32,32,5,7,7,6,0,0,136,136,80,32,32,32,32,
+  5,7,7,6,0,0,112,32,112,168,112,32,112,5,7,7,
+  6,0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,
+  168,168,168,168,112,32,32,5,6,6,6,0,0,112,136,136,
+  80,80,216,3,8,8,6,1,0,160,0,224,64,64,64,64,
+  224,5,8,8,6,0,0,80,0,136,136,136,80,32,32,5,
+  8,8,6,0,0,32,64,8,104,152,144,144,104,5,8,8,
+  6,0,0,32,64,0,112,136,224,136,112,5,10,10,6,0,
+  254,32,64,0,112,136,136,136,136,8,8,2,8,8,6,1,
+  0,64,128,0,128,128,128,128,64,5,8,8,6,0,0,16,
+  32,80,0,136,136,136,112,5,6,6,6,0,0,8,104,152,
+  144,144,104,4,7,7,6,0,254,96,144,240,144,224,128,128,
+  5,6,6,6,0,255,136,72,80,32,32,64,5,6,6,6,
+  0,0,48,64,112,136,136,112,5,5,5,6,0,0,112,136,
+  224,136,112,5,9,9,6,0,254,128,112,64,128,128,128,112,
+  8,112,5,7,7,6,0,254,184,200,136,136,136,8,8,5,
+  5,5,6,0,0,112,136,248,136,112,3,5,5,6,1,0,
+  128,128,128,128,96,4,5,5,6,0,0,144,160,192,160,144,
+  5,6,6,6,0,0,64,32,32,80,80,136,5,7,7,6,
+  0,254,136,136,136,216,168,128,128,5,5,5,6,0,0,136,
+  136,80,96,32,5,10,10,6,0,254,128,224,128,112,32,64,
+  128,112,8,112,5,5,5,6,0,0,112,136,136,136,112,5,
+  5,5,6,0,0,248,80,80,80,80,5,7,7,6,0,254,
+  112,136,136,200,176,128,128,5,7,7,6,0,254,48,64,128,
+  64,48,8,112,5,5,5,6,0,0,104,144,144,144,96,4,
+  5,5,6,0,0,240,64,64,64,48,5,5,5,6,0,0,
+  136,136,144,144,224,5,8,8,6,0,254,48,168,168,168,168,
+  112,32,32,5,6,6,6,0,255,136,80,32,32,80,136,5,
+  7,7,6,0,254,168,168,168,168,112,32,32,5,5,5,6,
+  0,0,80,136,136,168,112,4,7,7,6,0,0,160,0,64,
+  64,64,64,48,5,7,7,6,0,0,80,0,136,136,144,144,
+  224,4,8,8,6,0,0,32,64,0,96,144,144,144,96,5,
+  8,8,6,0,0,32,64,0,136,136,144,144,96,5,8,8,
+  6,0,0,32,64,0,80,136,136,168,112,5,7,7,6,0,
+  255,144,160,192,160,144,136,16,5,8,8,6,0,0,96,144,
+  160,128,240,136,136,112,5,7,7,6,0,0,112,80,56,144,
+  144,144,96,5,6,6,6,0,0,152,80,32,32,32,32,5,
+  8,8,6,0,0,64,128,152,80,32,32,32,32,5,8,8,
+  6,0,0,80,0,152,80,32,32,32,32,5,7,7,6,0,
+  255,48,168,168,168,168,112,32,5,5,5,6,0,0,248,80,
+  80,80,88,5,6,6,6,0,255,136,80,112,80,136,16,5,
+  7,7,6,0,255,112,136,136,136,112,32,112,5,6,6,6,
+  0,255,112,136,136,112,32,112,5,6,6,6,0,0,112,136,
+  128,112,32,112,5,7,7,6,0,254,8,112,128,128,112,16,
+  96,5,6,6,6,0,0,248,128,128,240,128,128,4,5,5,
+  6,0,0,240,128,224,128,128,5,6,6,6,0,0,248,0,
+  0,112,0,248,4,5,5,6,0,0,64,128,240,16,32,5,
+  7,7,6,0,0,224,80,40,40,8,8,16,5,7,7,6,
+  0,0,192,32,80,40,8,8,8,5,8,8,6,0,254,168,
+  168,168,168,168,88,8,112,5,7,7,6,0,254,168,168,168,
+  168,88,8,112,5,6,6,6,0,0,104,136,136,120,8,8,
+  5,6,6,6,0,255,104,136,136,120,8,8,4,8,8,6,
+  0,254,128,224,144,144,144,144,32,192,5,5,5,6,0,0,
+  104,144,112,16,224,5,6,6,6,0,0,96,144,16,96,136,
+  112,4,6,6,6,0,0,96,144,16,96,128,112,5,6,6,
+  6,0,0,136,80,32,80,136,248,5,5,5,6,0,0,136,
+  80,32,80,112,5,6,6,6,0,0,120,128,240,136,136,112,
+  4,5,5,6,0,0,240,128,224,144,96,3,6,6,6,1,
+  0,64,224,64,64,64,64,3,6,6,6,1,255,64,224,64,
+  64,64,128,5,5,5,6,0,0,136,80,112,80,136,5,7,
+  7,6,0,254,112,136,136,136,240,128,112,4,5,5,6,0,
+  0,112,128,128,128,112,2,8,8,6,1,255,64,0,192,64,
+  64,64,64,128,5,7,7,6,0,0,112,136,136,248,136,136,
+  112,4,5,5,6,0,0,112,128,224,128,112,4,5,5,6,
+  0,0,224,16,112,16,224,5,7,7,6,0,0,128,240,136,
+  136,136,240,128,4,7,7,6,0,255,128,224,144,144,144,224,
+  128,5,6,6,6,0,0,112,136,128,128,136,112,5,6,6,
+  6,0,0,136,216,168,136,136,136,5,7,7,6,0,254,136,
+  216,168,136,136,128,128,5,8,8,6,0,254,112,136,136,136,
+  112,64,224,64,5,6,6,6,0,0,112,136,8,8,136,112,
+  5,6,6,6,0,0,112,136,160,128,136,112,5,6,6,6,
+  0,0,112,136,40,8,136,112};
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 16c48e7..b1dd403 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -53,8 +53,6 @@
 
 #include <U8glib.h>
 #include "dogm_bitmaps.h"
-#include "dogm_custom_bitmaps.h"
-
 
 #include "ultralcd.h"
 #include "ultralcd_st7920_u8glib_rrd.h"
@@ -85,6 +83,9 @@
   #elif ENABLED(DISPLAY_CHARSET_ISO10646_KANA)
     #include "dogm_font_data_ISO10646_Kana.h"
     #define FONT_MENU_NAME ISO10646_Kana_5x7
+  #elif ENABLED(DISPLAY_CHARSET_ISO10646_GREEK)
+    #include "dogm_font_data_ISO10646_Greek.h"
+    #define FONT_MENU_NAME ISO10646_Greek_5x7
   #elif ENABLED(DISPLAY_CHARSET_ISO10646_CN)
     #include "dogm_font_data_ISO10646_CN.h"
     #define FONT_MENU_NAME ISO10646_CN
@@ -135,15 +136,20 @@
   #define TALL_FONT_CORRECTION 0
 #endif
 
-#define START_ROW              0
+#define START_COL              0
 
 // LCD selection
 #if ENABLED(U8GLIB_ST7920)
   //U8GLIB_ST7920_128X64_RRD u8g(0,0,0);
   U8GLIB_ST7920_128X64_RRD u8g(0);
 #elif defined(CARTESIO_UI)
-  // The CartesioUI display with SW-SPI
-  U8GLIB_DOGM128 u8g(DOGLCD_SCK, DOGLCD_MOSI, DOGLCD_CS, DOGLCD_A0);
+  // The CartesioUI display
+  #if DOGLCD_MOSI != -1 && DOGLCD_SCK != -1
+    // using SW-SPI
+    U8GLIB_DOGM128 u8g(DOGLCD_SCK, DOGLCD_MOSI, DOGLCD_CS, DOGLCD_A0);
+  #else
+    U8GLIB_DOGM128 u8g(DOGLCD_CS, DOGLCD_A0);
+  #endif
 #elif ENABLED(U8GLIB_LM6059_AF)
   // Based on the Adafruit ST7565 (http://www.adafruit.com/products/250)
   U8GLIB_LM6059 u8g(DOGLCD_CS, DOGLCD_A0);
@@ -217,10 +223,6 @@ char lcd_printPGM(const char* str) {
   return n;
 }
 
-#if ENABLED(SHOW_BOOTSCREEN)
-  static bool show_bootscreen = true;
-#endif
-
 /* Warning: This function is called from interrupt context */
 static void lcd_implementation_init() {
 
@@ -238,11 +240,6 @@ static void lcd_implementation_init() {
     u8g.setContrast(lcd_contrast);
   #endif
 
-  // FIXME: remove this workaround
-  // Uncomment this if you have the first generation (V1.10) of STBs board
-  // pinMode(17, OUTPUT); // Enable LCD backlight
-  // digitalWrite(17, HIGH);
-
   #if ENABLED(LCD_SCREEN_ROT_90)
     u8g.setRot90();   // Rotate screen by 90°
   #elif ENABLED(LCD_SCREEN_ROT_180)
@@ -252,16 +249,23 @@ static void lcd_implementation_init() {
   #endif
 
   #if ENABLED(SHOW_BOOTSCREEN)
-    #if ENABLED(CUSTOM_START_BMP)
+    static bool show_bootscreen = true;
+
+    #if ENABLED(SHOW_CUSTOM_BOOTSCREEN)
       if (show_bootscreen) {
         u8g.firstPage();
         do {
-            u8g.drawBitmapP((128-(CUSTOM_START_BMPWIDTH))/2, (64 - (CUSTOM_START_BMPHEIGHT))/2, CUSTOM_START_BMPBYTEWIDTH, CUSTOM_START_BMPHEIGHT, custom_start_bmp);
+          u8g.drawBitmapP(
+            (128 - (CUSTOM_BOOTSCREEN_BMPWIDTH))  /2,
+            ( 64 - (CUSTOM_BOOTSCREEN_BMPHEIGHT)) /2,
+            CEILING(CUSTOM_BOOTSCREEN_BMPWIDTH, 8), CUSTOM_BOOTSCREEN_BMPHEIGHT, custom_start_bmp);
         } while (u8g.nextPage());
-        delay(CUSTOM_START_BMP_DELAY);
+        safe_delay(CUSTOM_BOOTSCREEN_TIMEOUT);
       }
-    #endif
+    #endif // SHOW_CUSTOM_BOOTSCREEN
+
     int offx = (u8g.getWidth() - (START_BMPWIDTH)) / 2;
+
     #if ENABLED(START_BMPHIGH)
       int offy = 0;
     #else
@@ -270,9 +274,9 @@ static void lcd_implementation_init() {
 
     int txt1X = (u8g.getWidth() - (sizeof(STRING_SPLASH_LINE1) - 1) * (DOG_CHAR_WIDTH)) / 2;
 
-    u8g.firstPage();
-    do {
-      if (show_bootscreen) {
+    if (show_bootscreen) {
+      u8g.firstPage();
+      do {
         u8g.drawBitmapP(offx, offy, START_BMPBYTEWIDTH, START_BMPHEIGHT, start_bmp);
         lcd_setFont(FONT_MENU);
         #ifndef STRING_SPLASH_LINE2
@@ -282,12 +286,12 @@ static void lcd_implementation_init() {
           u8g.drawStr(txt1X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 3 / 2, STRING_SPLASH_LINE1);
           u8g.drawStr(txt2X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 1 / 2, STRING_SPLASH_LINE2);
         #endif
-      }
-    } while (u8g.nextPage());
+      } while (u8g.nextPage());
+    }
 
     show_bootscreen = false;
 
-  #endif
+  #endif // SHOW_BOOTSCREEN
 }
 
 void lcd_kill_screen() {
@@ -383,7 +387,7 @@ static void lcd_implementation_status_screen() {
     }
 
     u8g.setPrintPos(80,48);
-    uint16_t time = print_job_timer.duration() / 60;
+    millis_t time = print_job_timer.duration() / 60;
     if (time != 0) {
       lcd_print(itostr2(time/60));
       lcd_print(':');
@@ -480,27 +484,29 @@ static void lcd_implementation_mark_as_selected(uint8_t row, bool isSelected) {
   else {
     u8g.setColorIndex(1); // unmarked text is black on white
   }
-  u8g.setPrintPos((START_ROW) * (DOG_CHAR_WIDTH), (row + 1) * (DOG_CHAR_HEIGHT));
+  u8g.setPrintPos((START_COL) * (DOG_CHAR_WIDTH), (row + 1) * (DOG_CHAR_HEIGHT));
 }
 
 #if ENABLED(LCD_INFO_MENU) || ENABLED(FILAMENT_CHANGE_FEATURE)
 
-  static void lcd_implementation_drawmenu_static(uint8_t row, const char* pstr, const char* valstr=NULL, bool center=true) {
+  static void lcd_implementation_drawmenu_static(uint8_t row, const char* pstr, bool center=true, bool invert=false, const char* valstr=NULL) {
+
+    lcd_implementation_mark_as_selected(row, invert);
+
     char c;
-    int8_t n = LCD_WIDTH;
-    u8g.setPrintPos(0, (row + 1) * (DOG_CHAR_HEIGHT));
-    u8g.setColorIndex(1); // normal text
+    int8_t n = LCD_WIDTH - (START_COL);
+
     if (center && !valstr) {
       int8_t pad = (LCD_WIDTH - lcd_strlen_P(pstr)) / 2;
       while (--pad >= 0) { lcd_print(' '); n--; }
     }
-    while (c = pgm_read_byte(pstr)) {
+    while (n > 0 && (c = pgm_read_byte(pstr))) {
       n -= lcd_print(c);
       pstr++;
     }
-    if (valstr) {
-      lcd_print(valstr);
-      n -= lcd_strlen(valstr);
+    if (valstr) while (n > 0 && (c = *valstr)) {
+      n -= lcd_print(c);
+      valstr++;
     }
     while (n-- > 0) lcd_print(' ');
   }
@@ -511,7 +517,7 @@ static void lcd_implementation_drawmenu_generic(bool isSelected, uint8_t row, co
   UNUSED(pre_char);
 
   char c;
-  uint8_t n = LCD_WIDTH - 2;
+  uint8_t n = LCD_WIDTH - (START_COL) - 2;
 
   lcd_implementation_mark_as_selected(row, isSelected);
 
@@ -528,7 +534,7 @@ static void lcd_implementation_drawmenu_generic(bool isSelected, uint8_t row, co
 static void _drawmenu_setting_edit_generic(bool isSelected, uint8_t row, const char* pstr, const char* data, bool pgm) {
   char c;
   uint8_t vallen = (pgm ? lcd_strlen_P(data) : (lcd_strlen((char*)data)));
-  uint8_t n = LCD_WIDTH - 2 - vallen;
+  uint8_t n = LCD_WIDTH - (START_COL) - 2 - vallen;
 
   lcd_implementation_mark_as_selected(row, isSelected);
 
@@ -568,7 +574,7 @@ static void _drawmenu_setting_edit_generic(bool isSelected, uint8_t row, const c
 
 void lcd_implementation_drawedit(const char* pstr, const char* value=NULL) {
   uint8_t rows = 1;
-  uint8_t lcd_width = LCD_WIDTH, char_width = DOG_CHAR_WIDTH;
+  uint8_t lcd_width = LCD_WIDTH - (START_COL), char_width = DOG_CHAR_WIDTH;
   uint8_t vallen = lcd_strlen(value);
 
   #if ENABLED(USE_BIG_EDIT_FONT)
@@ -602,7 +608,7 @@ void lcd_implementation_drawedit(const char* pstr, const char* value=NULL) {
   static void _drawmenu_sd(bool isSelected, uint8_t row, const char* pstr, const char* filename, char* const longFilename, bool isDir) {
     UNUSED(pstr);
     char c;
-    uint8_t n = LCD_WIDTH - 1;
+    uint8_t n = LCD_WIDTH - (START_COL) - 1;
 
     if (longFilename[0]) {
       filename = longFilename;
diff --git a/Marlin/example_configurations/Cartesio/Configuration.h b/Marlin/example_configurations/Cartesio/Configuration.h
index 78c2f26..e0df707 100644
--- a/Marlin/example_configurations/Cartesio/Configuration.h
+++ b/Marlin/example_configurations/Cartesio/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(MaukCC, CartesioE)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 "Cartesio" // will be shown during bootup in line1
-#define STRING_SPLASH_LINE2 "Marlin " SHORT_BUILD_VERSION // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_Bootscreen.h"
+#endif
 
 // @section machine
 
@@ -118,6 +134,7 @@
 // The following define selects which electronics board you have.
 // Please choose the name from boards.h that matches your setup
 #ifndef MOTHERBOARD
+  //#define MOTHERBOARD BOARD_CNCONTROLS_11
   #define MOTHERBOARD BOARD_CNCONTROLS_12
 #endif
 
@@ -268,12 +285,12 @@
     #define  DEFAULT_Kp 18
     #define  DEFAULT_Ki 1
     #define  DEFAULT_Kd 100
-    
+
     // Cartesio extruderV6 40W Volcano
     //#define  DEFAULT_Kp 50
     //#define  DEFAULT_Ki 9
     //#define  DEFAULT_Kd 70
-    
+
     // Cartesio extruderV6 40W Cyclops
     //#define  DEFAULT_Kp 18
     //#define  DEFAULT_Ki 1
@@ -313,7 +330,7 @@
     #define  DEFAULT_bedKp 390
     #define  DEFAULT_bedKi 70
     #define  DEFAULT_bedKd 546
-   
+
     //24V 250W silicone heater on to 4mm glass CartesioM
     //#define  DEFAULT_bedKp 303
     //#define  DEFAULT_bedKi 42
@@ -778,13 +795,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 190
-#define PLA_PREHEAT_HPB_TEMP 50
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 190
+#define PREHEAT_1_TEMP_BED     50
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
+
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -826,10 +915,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/Cartesio/Configuration_adv.h b/Marlin/example_configurations/Cartesio/Configuration_adv.h
index 53ee090..5fb71ef 100644
--- a/Marlin/example_configurations/Cartesio/Configuration_adv.h
+++ b/Marlin/example_configurations/Cartesio/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/Cartesio/_Bootscreen.h b/Marlin/example_configurations/Cartesio/_Bootscreen.h
new file mode 100644
index 0000000..254fbdf
--- /dev/null
+++ b/Marlin/example_configurations/Cartesio/_Bootscreen.h
@@ -0,0 +1,95 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <avr/pgmspace.h>
+
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #define CUSTOM_BOOTSCREEN_TIMEOUT   2500
+  #define CUSTOM_BOOTSCREEN_BMPWIDTH  63
+  #define CUSTOM_BOOTSCREEN_BMPHEIGHT 64
+
+  const unsigned char 81x0i84fkcmoqbu7vte29[512] PROGMEM = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00,
+    0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x00, 0x7f, 0xff, 0xff, 0xfc, 0x00, 0x00,
+    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00,
+    0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00,
+    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x0f, 0x07, 0x87, 0xff, 0xff, 0xe0, 0x00,
+    0x00, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0x00,
+    0x01, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0x80,
+    0x03, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0x80,
+    0x07, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xe1, 0xc0,
+    0x07, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xe0,
+    0x0f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xe0,
+    0x0f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xf0,
+    0x1f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xf0,
+    0x1f, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xe1, 0xf0,
+    0x3f, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0xf8,
+    0x3f, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0xf8,
+    0x3f, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xf1, 0xf8,
+    0x3f, 0x1f, 0x8f, 0xc7, 0xff, 0xff, 0xe1, 0xf8,
+    0x7f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xfc,
+    0x7f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xfc,
+    0x7f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xfc,
+    0x7f, 0x1f, 0x8f, 0xc7, 0xc0, 0x00, 0x01, 0xfc,
+    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
+    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
+    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
+    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
+    0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
+    0x7f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xfc,
+    0x7f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xfc,
+    0x7f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xfc,
+    0x3f, 0x0f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf8,
+    0x3f, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf8,
+    0x3f, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf8,
+    0x3f, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf8,
+    0x1f, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf0,
+    0x1f, 0x0f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xf0,
+    0x1f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xe0,
+    0x0f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xe0,
+    0x0f, 0x00, 0x00, 0x07, 0xc7, 0xe3, 0xf1, 0xc0,
+    0x07, 0x0f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0xc0,
+    0x03, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0x80,
+    0x03, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf1, 0x00,
+    0x01, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf0, 0x00,
+    0x00, 0x1f, 0xff, 0xff, 0xc7, 0xe3, 0xf0, 0x00,
+    0x00, 0x0f, 0xff, 0xff, 0xc3, 0xc1, 0xe0, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00,
+    0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00,
+    0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00,
+    0x00, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00,
+    0x00, 0x00, 0x7f, 0xff, 0xff, 0xfc, 0x00, 0x00,
+    0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00,
+    0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  };
+#endif
diff --git a/Marlin/example_configurations/Felix/Configuration.h b/Marlin/example_configurations/Felix/Configuration.h
index 166266b..3915da6 100644
--- a/Marlin/example_configurations/Felix/Configuration.h
+++ b/Marlin/example_configurations/Felix/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -762,13 +778,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -810,10 +898,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index 77148dc..05189ec 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/Felix/DUAL/Configuration.h b/Marlin/example_configurations/Felix/DUAL/Configuration.h
index 888341f..066aca3 100644
--- a/Marlin/example_configurations/Felix/DUAL/Configuration.h
+++ b/Marlin/example_configurations/Felix/DUAL/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -760,13 +776,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -808,10 +896,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/Hephestos/Configuration.h b/Marlin/example_configurations/Hephestos/Configuration.h
index 9d7bff2..f09190f 100644
--- a/Marlin/example_configurations/Hephestos/Configuration.h
+++ b/Marlin/example_configurations/Hephestos/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -771,13 +787,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 200
-#define PLA_PREHEAT_HPB_TEMP 0
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 200
+#define PREHEAT_1_TEMP_BED      0
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 220
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 220
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -819,10 +907,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index e1e6666..1aa7c21 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration.h b/Marlin/example_configurations/Hephestos_2/Configuration.h
index 1a5887a..2e0fcfd 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "@jbrazio" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_Bootscreen.h"
+#endif
 
 // @section machine
 
@@ -711,16 +727,16 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
 // default settings
 
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {160, 160, 8000, 203} // default steps per unit for Ultimaker
-#define DEFAULT_MAX_FEEDRATE          {250, 250, 2, 200}      // (mm/sec)
-#define DEFAULT_MAX_ACCELERATION      {1000, 1000, 20, 1000}   // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {160, 160, 8000, 210.02}  // Steps per unit
+#define DEFAULT_MAX_FEEDRATE          {250, 250, 2, 200}        // mm/sec
+#define DEFAULT_MAX_ACCELERATION      {1000, 1000, 20, 1000}    // X, Y, Z, E max start speed for accelerated moves
 
 #define DEFAULT_ACCELERATION          1000    // X, Y, Z and E acceleration in mm/s^2 for printing moves
 #define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration in mm/s^2 for retracts
 #define DEFAULT_TRAVEL_ACCELERATION   1000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves
 
 // The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
-#define DEFAULT_XYJERK                10.0    // (mm/sec)
+#define DEFAULT_XYJERK                20.0    // (mm/sec)
 #define DEFAULT_ZJERK                  0.4    // (mm/sec)
 #define DEFAULT_EJERK                  2.0    // (mm/sec)
 
@@ -773,13 +789,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 210
-#define PLA_PREHEAT_HPB_TEMP    70
-#define PLA_PREHEAT_FAN_SPEED   0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 210
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP    110
-#define ABS_PREHEAT_FAN_SPEED   0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -821,10 +909,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
index e08dd26..95b8c89 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/Hephestos_2/README.md b/Marlin/example_configurations/Hephestos_2/README.md
index 447022c..8fcb53c 100644
--- a/Marlin/example_configurations/Hephestos_2/README.md
+++ b/Marlin/example_configurations/Hephestos_2/README.md
@@ -10,3 +10,5 @@ NOTE: The look and feel of the Hephestos 2 while navigating the LCD menu will ch
  * 2016/06/21 - Disabled hot bed related options
                 Activated software endstops
                 SD printing now disables the heater when finished
+ * 2016/07/13 - Update the `DEFAULT_AXIS_STEPS_PER_UNIT` for the Z axis
+                Increased the `DEFAULT_XYJERK`
diff --git a/Marlin/example_configurations/Hephestos_2/_Bootscreen.h b/Marlin/example_configurations/Hephestos_2/_Bootscreen.h
new file mode 100644
index 0000000..7e7f8f4
--- /dev/null
+++ b/Marlin/example_configurations/Hephestos_2/_Bootscreen.h
@@ -0,0 +1,95 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <avr/pgmspace.h>
+
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #define CUSTOM_BOOTSCREEN_TIMEOUT   2500
+  #define CUSTOM_BOOTSCREEN_BMPWIDTH  62
+  #define CUSTOM_BOOTSCREEN_BMPHEIGHT 64
+
+  const unsigned char custom_start_bmp[512] PROGMEM = {
+    0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 0x00, 0x00,
+    0x00, 0x03, 0xc0, 0x0f, 0xf0, 0x07, 0x80, 0x00,
+    0x00, 0x07, 0xe0, 0x07, 0xe0, 0x0f, 0xc0, 0x00,
+    0x00, 0x0f, 0xf0, 0x03, 0xc0, 0x1f, 0xe0, 0x00,
+    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf0, 0x00,
+    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf0, 0x00,
+    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf0, 0x00,
+    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf0, 0x00,
+    0x00, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xf0, 0x00,
+    0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0xe0, 0x00,
+    0x00, 0x07, 0xe0, 0x00, 0x00, 0x0f, 0xc0, 0x00,
+    0x00, 0x03, 0xc0, 0x00, 0x00, 0x07, 0x80, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x1e, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0x3f, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0x7f, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0xff, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0xff, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0xff, 0xc0, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
+    0xff, 0xc0, 0x00, 0x00, 0xf7, 0xc0, 0x1f, 0x80,
+    0xff, 0xc0, 0x00, 0x00, 0xff, 0xf0, 0x7f, 0xc0,
+    0x7f, 0x80, 0x00, 0x00, 0xff, 0xf8, 0xff, 0xe0,
+    0x3f, 0x00, 0x00, 0x00, 0xfc, 0xf8, 0xf0, 0xf8,
+    0x1e, 0x00, 0x00, 0x00, 0xf8, 0x7d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf0, 0x3d, 0xe0, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0xf8, 0x79, 0xf0, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0xff, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x7f, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x3f, 0xf8,
+    0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x0e, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+  };
+#endif
diff --git a/Marlin/example_configurations/K8200/Configuration.h b/Marlin/example_configurations/K8200/Configuration.h
index d53607e..3a330d6 100644
--- a/Marlin/example_configurations/K8200/Configuration.h
+++ b/Marlin/example_configurations/K8200/Configuration.h
@@ -104,8 +104,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(K8200, @CONSULitAS)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -796,13 +812,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 190
-#define PLA_PREHEAT_HPB_TEMP 50 // K8200: set back to 70 if you have an upgraded heatbed power supply
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 190
+#define PREHEAT_1_TEMP_BED     50 // K8200: set back to 70 if you have an upgraded heatbed power supply
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED     60 // K8200: set back to 110 if you have an upgraded heatbed power supply
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 60 // K8200: set back to 110 if you have an upgraded heatbed power supply
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -844,10 +932,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index b3b7b26..2d0afdf 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -235,11 +235,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -261,14 +278,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/K8400/Configuration.h b/Marlin/example_configurations/K8400/Configuration.h
index c8c0971..3addb54 100644
--- a/Marlin/example_configurations/K8400/Configuration.h
+++ b/Marlin/example_configurations/K8400/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(Anthony Birkett, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -779,13 +795,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 210
-#define PLA_PREHEAT_HPB_TEMP 0
-#define PLA_PREHEAT_FAN_SPEED 165   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 210
+#define PREHEAT_1_TEMP_BED      0
+#define PREHEAT_1_FAN_SPEED   165 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 245
+#define PREHEAT_2_TEMP_BED      0
+#define PREHEAT_2_FAN_SPEED   165 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 245
-#define ABS_PREHEAT_HPB_TEMP 0
-#define ABS_PREHEAT_FAN_SPEED 165   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -827,10 +915,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/K8400/Configuration_adv.h b/Marlin/example_configurations/K8400/Configuration_adv.h
index 12a924d..ba78a15 100644
--- a/Marlin/example_configurations/K8400/Configuration_adv.h
+++ b/Marlin/example_configurations/K8400/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/K8400/Dual Heads/Configuration.h b/Marlin/example_configurations/K8400/Dual Heads/Configuration.h
deleted file mode 100644
index 1a9b724..0000000
--- a/Marlin/example_configurations/K8400/Dual Heads/Configuration.h	
+++ /dev/null
@@ -1,1220 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * Configuration.h
- *
- * Basic settings such as:
- *
- * - Type of electronics
- * - Type of temperature sensor
- * - Printer geometry
- * - Endstop configuration
- * - LCD controller
- * - Extra features
- *
- * Advanced settings can be found in Configuration_adv.h
- *
- */
-#ifndef CONFIGURATION_H
-#define CONFIGURATION_H
-
-/**
- *
- *  ***********************************
- *  **  ATTENTION TO ALL DEVELOPERS  **
- *  ***********************************
- *
- * You must increment this version number for every significant change such as,
- * but not limited to: ADD, DELETE RENAME OR REPURPOSE any directive/option.
- *
- * Note: Update also Version.h !
- */
-#define CONFIGURATION_H_VERSION 010100
-
-#include "boards.h"
-#include "macros.h"
-
-//===========================================================================
-//============================= Getting Started =============================
-//===========================================================================
-
-/**
- * Here are some standard links for getting your machine calibrated:
- *
- * http://reprap.org/wiki/Calibration
- * http://youtu.be/wAL9d7FgInk
- * http://calculator.josefprusa.cz
- * http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide
- * http://www.thingiverse.com/thing:5573
- * https://sites.google.com/site/repraplogphase/calibration-of-your-reprap
- * http://www.thingiverse.com/thing:298812
- */
-
-//===========================================================================
-//============================= DELTA Printer ===============================
-//===========================================================================
-// For a Delta printer replace the configuration files with the files in the
-// example_configurations/delta directory.
-//
-
-//===========================================================================
-//============================= SCARA Printer ===============================
-//===========================================================================
-// For a Scara printer replace the configuration files with the files in the
-// example_configurations/SCARA directory.
-//
-
-// @section info
-
-#if ENABLED(USE_AUTOMATIC_VERSIONING)
-  #include "_Version.h"
-#else
-  #include "Version.h"
-#endif
-
-// User-specified version info of this build to display in [Pronterface, etc] terminal window during
-// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
-// build by the user have been successfully uploaded into firmware.
-#define STRING_CONFIG_H_AUTHOR "(Anthony Birkett, default config)" // Who made the changes.
-#define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
-
-// @section machine
-
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
-#define SERIAL_PORT 0
-
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
-#define BAUDRATE 250000
-
-// Enable the Bluetooth serial interface on AT90USB devices
-//#define BLUETOOTH
-
-// The following define selects which electronics board you have.
-// Please choose the name from boards.h that matches your setup
-#ifndef MOTHERBOARD
-  #define MOTHERBOARD BOARD_K8400
-#endif
-
-// Optional custom name for your RepStrap or other custom machine
-// Displayed in the LCD "Ready" message
-//#define CUSTOM_MACHINE_NAME "3D Printer"
-
-// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
-// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
-//#define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
-
-// This defines the number of extruders
-// :[1,2,3,4]
-#define EXTRUDERS 2
-
-// For Cyclops or any "multi-extruder" that shares a single nozzle.
-//#define SINGLENOZZLE
-
-// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
-// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
-// For the other hotends it is their distance from the extruder 0 hotend.
-//#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
-//#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
-
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
-
-#define POWER_SUPPLY 1
-
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
-
-// @section temperature
-
-//===========================================================================
-//============================= Thermal Settings ============================
-//===========================================================================
-//
-//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table
-//
-//// Temperature sensor settings:
-// -3 is thermocouple with MAX31855 (only for sensor 0)
-// -2 is thermocouple with MAX6675 (only for sensor 0)
-// -1 is thermocouple with AD595
-// 0 is not used
-// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
-// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
-// 3 is Mendel-parts thermistor (4.7k pullup)
-// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
-// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
-// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
-// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
-// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)
-// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
-// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
-// 10 is 100k RS thermistor 198-961 (4.7k pullup)
-// 11 is 100k beta 3950 1% thermistor (4.7k pullup)
-// 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)
-// 13 is 100k Hisens 3950  1% up to 300°C for hotend "Simple ONE " & "Hotend "All In ONE"
-// 20 is the PT100 circuit found in the Ultimainboard V2.x
-// 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950
-// 66 is 4.7M High Temperature thermistor from Dyze Design
-// 70 is the 100K thermistor found in the bq Hephestos 2
-//
-//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
-//                          (but gives greater accuracy and more stable PID)
-// 51 is 100k thermistor - EPCOS (1k pullup)
-// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
-// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
-//
-// 1047 is Pt1000 with 4k7 pullup
-// 1010 is Pt1000 with 1k pullup (non standard)
-// 147 is Pt100 with 4k7 pullup
-// 110 is Pt100 with 1k pullup (non standard)
-// 998 and 999 are Dummy Tables. They will ALWAYS read 25°C or the temperature defined below.
-//     Use it for Testing or Development purposes. NEVER for production machine.
-//#define DUMMY_THERMISTOR_998_VALUE 25
-//#define DUMMY_THERMISTOR_999_VALUE 100
-// :{ '0': "Not used",'1':"100k / 4.7k - EPCOS",'2':"200k / 4.7k - ATC Semitec 204GT-2",'3':"Mendel-parts / 4.7k",'4':"10k !! do not use for a hotend. Bad resolution at high temp. !!",'5':"100K / 4.7k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'6':"100k / 4.7k EPCOS - Not as accurate as Table 1",'7':"100k / 4.7k Honeywell 135-104LAG-J01",'8':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT",'9':"100k / 4.7k GE Sensing AL03006-58.2K-97-G1",'10':"100k / 4.7k RS 198-961",'11':"100k / 4.7k beta 3950 1%",'12':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT (calibrated for Makibox hot bed)",'13':"100k Hisens 3950  1% up to 300°C for hotend 'Simple ONE ' & hotend 'All In ONE'",'20':"PT100 (Ultimainboard V2.x)",'51':"100k / 1k - EPCOS",'52':"200k / 1k - ATC Semitec 204GT-2",'55':"100k / 1k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'60':"100k Maker's Tool Works Kapton Bed Thermistor beta=3950",'66':"Dyze Design 4.7M High Temperature thermistor",'70':"the 100K thermistor found in the bq Hephestos 2",'71':"100k / 4.7k Honeywell 135-104LAF-J01",'147':"Pt100 / 4.7k",'1047':"Pt1000 / 4.7k",'110':"Pt100 / 1k (non-standard)",'1010':"Pt1000 / 1k (non standard)",'-3':"Thermocouple + MAX31855 (only for sensor 0)",'-2':"Thermocouple + MAX6675 (only for sensor 0)",'-1':"Thermocouple + AD595",'998':"Dummy 1",'999':"Dummy 2" }
-#define TEMP_SENSOR_0 5
-#define TEMP_SENSOR_1 5
-#define TEMP_SENSOR_2 0
-#define TEMP_SENSOR_3 0
-#define TEMP_SENSOR_BED 0
-
-// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
-//#define TEMP_SENSOR_1_AS_REDUNDANT
-#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
-
-// Extruder temperature must be close to target for this long before M109 returns success
-#define TEMP_RESIDENCY_TIME 2   // (seconds)
-#define TEMP_HYSTERESIS 5       // (degC) range of +/- temperatures considered "close" to the target one
-#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
-
-// Bed temperature must be close to target for this long before M190 returns success
-#define TEMP_BED_RESIDENCY_TIME 10  // (seconds)
-#define TEMP_BED_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
-#define TEMP_BED_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
-
-// The minimal temperature defines the temperature below which the heater will not be enabled It is used
-// to check that the wiring to the thermistor is not broken.
-// Otherwise this would lead to the heater being powered on all the time.
-#define HEATER_0_MINTEMP 5
-#define HEATER_1_MINTEMP 5
-#define HEATER_2_MINTEMP 5
-#define HEATER_3_MINTEMP 5
-#define BED_MINTEMP 5
-
-// When temperature exceeds max temp, your heater will be switched off.
-// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
-// You should use MINTEMP for thermistor short/failure protection.
-#define HEATER_0_MAXTEMP 275
-#define HEATER_1_MAXTEMP 275
-#define HEATER_2_MAXTEMP 275
-#define HEATER_3_MAXTEMP 275
-#define BED_MAXTEMP 150
-
-// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
-//#define HOTEND_WATTS (12.0*12.0/6.7) // P=U^2/R
-//#define BED_WATTS (12.0*12.0/1.1)    // P=U^2/R
-
-//===========================================================================
-//============================= PID Settings ================================
-//===========================================================================
-// PID Tuning Guide here: http://reprap.org/wiki/PID_Tuning
-
-// Comment the following line to disable PID and enable bang-bang.
-#define PIDTEMP
-#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
-#define PID_MAX BANG_MAX // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
-#if ENABLED(PIDTEMP)
-  //#define PID_AUTOTUNE_MENU // Add PID Autotune to the LCD "Temperature" menu to run M303 and apply the result.
-  //#define PID_DEBUG // Sends debug data to the serial port.
-  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
-  //#define SLOW_PWM_HEATERS // PWM with very low frequency (roughly 0.125Hz=8s) and minimum state time of approximately 1s useful for heaters driven by a relay
-  //#define PID_PARAMS_PER_HOTEND // Uses separate PID parameters for each extruder (useful for mismatched extruders)
-                                  // Set/get with gcode: M301 E[extruder number, 0-2]
-  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
-                                  // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
-  #define K1 0.95 //smoothing factor within the PID
-
-  // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
-  // Ultimaker
-  //#define  DEFAULT_Kp 22.2
-  //#define  DEFAULT_Ki 1.08
-  //#define  DEFAULT_Kd 114
-
-  // MakerGear
-  //#define  DEFAULT_Kp 7.0
-  //#define  DEFAULT_Ki 0.1
-  //#define  DEFAULT_Kd 12
-
-  // Mendel Parts V9 on 12V
-  #define  DEFAULT_Kp 63.0
-  #define  DEFAULT_Ki 2.25
-  #define  DEFAULT_Kd 440
-
-#endif // PIDTEMP
-
-//===========================================================================
-//============================= PID > Bed Temperature Control ===============
-//===========================================================================
-// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
-//
-// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
-// If your PID_dT is the default, and correct for your hardware/configuration, that means 7.689Hz,
-// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
-// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
-// If your configuration is significantly different than this and you don't understand the issues involved, you probably
-// shouldn't use bed PID until someone else verifies your hardware works.
-// If this is enabled, find your own PID constants below.
-//#define PIDTEMPBED
-
-//#define BED_LIMIT_SWITCHING
-
-// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
-// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
-// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
-// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
-#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
-
-#if ENABLED(PIDTEMPBED)
-
-  //#define PID_BED_DEBUG // Sends debug data to the serial port.
-
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
-  //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-  //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
-  #define  DEFAULT_bedKp 10.00
-  #define  DEFAULT_bedKi .023
-  #define  DEFAULT_bedKd 305.4
-
-  //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-  //from pidautotune
-  //#define  DEFAULT_bedKp 97.1
-  //#define  DEFAULT_bedKi 1.41
-  //#define  DEFAULT_bedKd 1675.16
-
-  // FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
-#endif // PIDTEMPBED
-
-// @section extruder
-
-//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
-//can be software-disabled for whatever purposes by
-#define PREVENT_DANGEROUS_EXTRUDE
-//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
-#define PREVENT_LENGTHY_EXTRUDE
-
-#define EXTRUDE_MINTEMP 160
-#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
-
-//===========================================================================
-//======================== Thermal Runaway Protection =======================
-//===========================================================================
-
-/**
- * Thermal Protection protects your printer from damage and fire if a
- * thermistor falls out or temperature sensors fail in any way.
- *
- * The issue: If a thermistor falls out or a temperature sensor fails,
- * Marlin can no longer sense the actual temperature. Since a disconnected
- * thermistor reads as a low temperature, the firmware will keep the heater on.
- *
- * If you get "Thermal Runaway" or "Heating failed" errors the
- * details can be tuned in Configuration_adv.h
- */
-
-#define THERMAL_PROTECTION_HOTENDS // Enable thermal protection for all extruders
-#define THERMAL_PROTECTION_BED     // Enable thermal protection for the heated bed
-
-//===========================================================================
-//============================= Mechanical Settings =========================
-//===========================================================================
-
-// @section machine
-
-// Uncomment one of these options to enable CoreXY, CoreXZ, or CoreYZ kinematics
-//#define COREXY
-//#define COREXZ
-//#define COREYZ
-
-// Enable this option for Toshiba steppers
-//#define CONFIG_STEPPERS_TOSHIBA
-
-//===========================================================================
-//============================== Endstop Settings ===========================
-//===========================================================================
-
-// @section homing
-
-// Specify here all the endstop connectors that are connected to any endstop or probe.
-// Almost all printers will be using one per axis. Probes will use one or more of the
-// extra connectors. Leave undefined any used for non-endstop and non-probe purposes.
-#define USE_XMIN_PLUG
-#define USE_YMIN_PLUG
-#define USE_ZMIN_PLUG
-//#define USE_XMAX_PLUG
-//#define USE_YMAX_PLUG
-//#define USE_ZMAX_PLUG
-
-// coarse Endstop Settings
-#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
-
-#if DISABLED(ENDSTOPPULLUPS)
-  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
-  //#define ENDSTOPPULLUP_XMAX
-  //#define ENDSTOPPULLUP_YMAX
-  //#define ENDSTOPPULLUP_ZMAX
-  //#define ENDSTOPPULLUP_XMIN
-  //#define ENDSTOPPULLUP_YMIN
-  //#define ENDSTOPPULLUP_ZMIN
-  //#define ENDSTOPPULLUP_ZMIN_PROBE
-#endif
-
-// Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).
-const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
-
-//===========================================================================
-//============================= Z Probe Options =============================
-//===========================================================================
-
-//
-// Probe Type
-// Probes are sensors/switches that are activated / deactivated before/after use.
-//
-// Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
-//
-// Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
-//
-
-// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
-// For example an inductive probe, or a setup that uses the nozzle to probe.
-// An inductive probe must be deactivated to go below
-// its trigger-point if hardware endstops are active.
-//#define FIX_MOUNTED_PROBE
-
-// Z Servo Probe, such as an endstop switch on a rotating arm.
-//#define Z_ENDSTOP_SERVO_NR 0
-//#define Z_SERVO_ANGLES {70,0} // Z Servo Deploy and Stow angles
-
-// Enable if you have a Z probe mounted on a sled like those designed by Charles Bell.
-//#define Z_PROBE_SLED
-//#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
-
-// Z Probe to nozzle (X,Y) offset, relative to (0, 0).
-// X and Y offsets must be integers.
-//
-// In the following example the X and Y offsets are both positive:
-// #define X_PROBE_OFFSET_FROM_EXTRUDER 10
-// #define Y_PROBE_OFFSET_FROM_EXTRUDER 10
-//
-//    +-- BACK ---+
-//    |           |
-//  L |    (+) P  | R <-- probe (20,20)
-//  E |           | I
-//  F | (-) N (+) | G <-- nozzle (10,10)
-//  T |           | H
-//    |    (-)    | T
-//    |           |
-//    O-- FRONT --+
-//  (0,0)
-#define X_PROBE_OFFSET_FROM_EXTRUDER 10  // X offset: -left  +right  [of the nozzle]
-#define Y_PROBE_OFFSET_FROM_EXTRUDER 10  // Y offset: -front +behind [the nozzle]
-#define Z_PROBE_OFFSET_FROM_EXTRUDER 0   // Z offset: -below +above  [the nozzle]
-
-// X and Y axis travel speed (mm/m) between probes
-#define XY_PROBE_SPEED 8000
-
-//
-// Allen Key Probe is defined in the Delta example configurations.
-//
-
-// Enable Z_MIN_PROBE_ENDSTOP to use _both_ a Z Probe and a Z-min-endstop on the same machine.
-// With this option the Z_MIN_PROBE_PIN will only be used for probing, never for homing.
-//
-// *** PLEASE READ ALL INSTRUCTIONS BELOW FOR SAFETY! ***
-//
-// To continue using the Z-min-endstop for homing, be sure to disable Z_SAFE_HOMING.
-// Example: To park the head outside the bed area when homing with G28.
-//
-// To use a separate Z probe, your board must define a Z_MIN_PROBE_PIN.
-//
-// For a servo-based Z probe, you must set up servo support below, including
-// NUM_SERVOS, Z_ENDSTOP_SERVO_NR and Z_SERVO_ANGLES.
-//
-// - RAMPS 1.3/1.4 boards may be able to use the 5V, GND, and Aux4->D32 pin.
-// - Use 5V for powered (usu. inductive) sensors.
-// - Otherwise connect:
-//   - normally-closed switches to GND and D32.
-//   - normally-open switches to 5V and D32.
-//
-// Normally-closed switches are advised and are the default.
-//
-// The Z_MIN_PROBE_PIN sets the Arduino pin to use. (See your board's pins file.)
-// Since the RAMPS Aux4->D32 pin maps directly to the Arduino D32 pin, D32 is the
-// default pin for all RAMPS-based boards. Some other boards map differently.
-// To set or change the pin for your board, edit the appropriate pins_XXXXX.h file.
-//
-// WARNING:
-// Setting the wrong pin may have unexpected and potentially disastrous consequences.
-// Use with caution and do your homework.
-//
-//#define Z_MIN_PROBE_ENDSTOP
-
-// Enable Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN to use the Z_MIN_PIN for your Z_MIN_PROBE.
-// The Z_MIN_PIN will then be used for both Z-homing and probing.
-#define Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN
-
-// To use a probe you must enable one of the two options above!
-
-// This option disables the use of the Z_MIN_PROBE_PIN
-// To enable the Z probe pin but disable its use, uncomment the line below. This only affects a
-// Z probe switch if you have a separate Z min endstop also and have activated Z_MIN_PROBE_ENDSTOP above.
-// If you're using the Z MIN endstop connector for your Z probe, this has no effect.
-//#define DISABLE_Z_MIN_PROBE_ENDSTOP
-
-// Enable Z Probe Repeatability test to see how accurate your probe is
-//#define Z_MIN_PROBE_REPEATABILITY_TEST
-
-//
-// Probe Raise options provide clearance for the probe to deploy, stow, and travel.
-//
-#define Z_RAISE_PROBE_DEPLOY_STOW 15 // Raise to make room for the probe to deploy / stow
-#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
-
-//
-// For M851 give a range for adjusting the Z probe offset
-//
-#define Z_PROBE_OFFSET_RANGE_MIN -20
-#define Z_PROBE_OFFSET_RANGE_MAX 20
-
-// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
-// :{0:'Low',1:'High'}
-#define X_ENABLE_ON 0
-#define Y_ENABLE_ON 0
-#define Z_ENABLE_ON 0
-#define E_ENABLE_ON 0 // For all extruders
-
-// Disables axis stepper immediately when it's not being used.
-// WARNING: When motors turn off there is a chance of losing position accuracy!
-#define DISABLE_X false
-#define DISABLE_Y false
-#define DISABLE_Z false
-// Warn on display about possibly reduced accuracy
-//#define DISABLE_REDUCED_ACCURACY_WARNING
-
-// @section extruder
-
-#define DISABLE_E false // For all extruders
-#define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled
-
-// @section machine
-
-// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
-#define INVERT_X_DIR false
-#define INVERT_Y_DIR true
-#define INVERT_Z_DIR true
-
-// @section extruder
-
-// For direct drive extruder v9 set to true, for geared extruder set to false.
-#define INVERT_E0_DIR false
-#define INVERT_E1_DIR true
-#define INVERT_E2_DIR false
-#define INVERT_E3_DIR false
-
-// @section homing
-//#define MIN_Z_HEIGHT_FOR_HOMING 4 // (in mm) Minimal z height before homing (G28) for Z clearance above the bed, clamps, ...
-                                    // Be sure you have this distance over your Z_MAX_POS in case.
-
-// ENDSTOP SETTINGS:
-// Sets direction of endstops when homing; 1=MAX, -1=MIN
-// :[-1,1]
-#define X_HOME_DIR -1
-#define Y_HOME_DIR -1
-#define Z_HOME_DIR -1
-
-#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
-#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
-
-// @section machine
-
-// Travel limits after homing (units are in mm)
-#define X_MIN_POS 0
-#define Y_MIN_POS 20
-#define Z_MIN_POS 0
-#define X_MAX_POS 200
-#define Y_MAX_POS 200
-#define Z_MAX_POS 190
-
-//===========================================================================
-//========================= Filament Runout Sensor ==========================
-//===========================================================================
-//#define FILAMENT_RUNOUT_SENSOR // Uncomment for defining a filament runout sensor such as a mechanical or opto endstop to check the existence of filament
-                                 // In RAMPS uses servo pin 2. Can be changed in pins file. For other boards pin definition should be made.
-                                 // It is assumed that when logic high = filament available
-                                 //                    when logic  low = filament ran out
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  const bool FIL_RUNOUT_INVERTING = false; // set to true to invert the logic of the sensor.
-  #define ENDSTOPPULLUP_FIL_RUNOUT // Uncomment to use internal pullup for filament runout pins if the sensor is defined.
-  #define FILAMENT_RUNOUT_SCRIPT "M600"
-#endif
-
-//===========================================================================
-//============================ Mesh Bed Leveling ============================
-//===========================================================================
-
-//#define MESH_BED_LEVELING    // Enable mesh bed leveling.
-
-#if ENABLED(MESH_BED_LEVELING)
-  #define MESH_INSET 10        // Mesh inset margin on print area
-  #define MESH_NUM_X_POINTS 3  // Don't use more than 7 points per axis, implementation limited.
-  #define MESH_NUM_Y_POINTS 3
-  #define MESH_HOME_SEARCH_Z 4  // Z after Home, bed somewhere below but above 0.0.
-
-  //#define MESH_G28_REST_ORIGIN // After homing all axes ('G28' or 'G28 XYZ') rest at origin [0,0,0]
-
-  //#define MANUAL_BED_LEVELING  // Add display menu option for bed leveling.
-
-  #if ENABLED(MANUAL_BED_LEVELING)
-    #define MBL_Z_STEP 0.025  // Step size while manually probing Z axis.
-  #endif  // MANUAL_BED_LEVELING
-
-#endif  // MESH_BED_LEVELING
-
-//===========================================================================
-//============================ Bed Auto Leveling ============================
-//===========================================================================
-
-// @section bedlevel
-
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
-//#define DEBUG_LEVELING_FEATURE
-
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
-
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
-
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
-
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
-
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
-
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define AUTO_BED_LEVELING_GRID_POINTS 2
-
-  #else  // !AUTO_BED_LEVELING_GRID
-
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
-
-#endif // AUTO_BED_LEVELING_FEATURE
-
-
-// @section homing
-
-// The position of the homing switches
-//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
-//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
-
-// Manual homing switch locations:
-// For deltabots this means top and center of the Cartesian print volume.
-#if ENABLED(MANUAL_HOME_POSITIONS)
-  #define MANUAL_X_HOME_POS 0
-  #define MANUAL_Y_HOME_POS 0
-  #define MANUAL_Z_HOME_POS 0
-  //#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.
-#endif
-
-// Use "Z Safe Homing" to avoid homing with a Z probe outside the bed area.
-//
-// With this feature enabled:
-//
-// - Allow Z homing only after X and Y homing AND stepper drivers still enabled.
-// - If stepper drivers time out, it will need X and Y homing again before Z homing.
-// - Position the Z probe in a defined XY point before Z Homing when homing all axes (G28).
-// - Prevent Z homing when the Z probe is outside bed area.
-//#define Z_SAFE_HOMING
-
-#if ENABLED(Z_SAFE_HOMING)
-  #define Z_SAFE_HOMING_X_POINT ((X_MIN_POS + X_MAX_POS) / 2)    // X point for Z homing when homing all axis (G28).
-  #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
-#endif
-
-
-// @section motion
-
-/**
- * MOVEMENT SETTINGS
- */
-
-#define HOMING_FEEDRATE {50*60, 50*60, 8*60, 0}  // set the homing speeds (mm/min)
-
-// default settings
-
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {134.74,134.74,4266.66,148.7}  // default steps per unit for Ultimaker
-#define DEFAULT_MAX_FEEDRATE          {160, 160, 10, 10000}    // (mm/sec)
-#define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
-
-#define DEFAULT_ACCELERATION          6000    // X, Y, Z and E acceleration in mm/s^2 for printing moves
-#define DEFAULT_RETRACT_ACCELERATION  6000    // E acceleration in mm/s^2 for retracts
-#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves
-
-// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
-#define DEFAULT_XYJERK                10.0    // (mm/sec)
-#define DEFAULT_ZJERK                 0.5     // (mm/sec)
-#define DEFAULT_EJERK                 20.0    // (mm/sec)
-
-
-//=============================================================================
-//============================= Additional Features ===========================
-//=============================================================================
-
-// @section extras
-
-//
-// EEPROM
-//
-// The microcontroller can store settings in the EEPROM, e.g. max velocity...
-// M500 - stores parameters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
-// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-//define this to enable EEPROM support
-#define EEPROM_SETTINGS
-
-#if ENABLED(EEPROM_SETTINGS)
-  // To disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
-  #define EEPROM_CHITCHAT // Please keep turned on if you can.
-#endif
-
-//
-// Host Keepalive
-//
-// When enabled Marlin will send a busy status message to the host
-// every couple of seconds when it can't accept commands.
-//
-#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
-
-//
-// M100 Free Memory Watcher
-//
-//#define M100_FREE_MEMORY_WATCHER // uncomment to add the M100 Free Memory Watcher for debug purpose
-
-//
-// G20/G21 Inch mode support
-//
-//#define INCH_MODE_SUPPORT
-
-//
-// M149 Set temperature units support
-//
-//#define TEMPERATURE_UNITS_SUPPORT
-
-// @section temperature
-
-// Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 210
-#define PLA_PREHEAT_HPB_TEMP 0
-#define PLA_PREHEAT_FAN_SPEED 165   // Insert Value between 0 and 255
-
-#define ABS_PREHEAT_HOTEND_TEMP 245
-#define ABS_PREHEAT_HPB_TEMP 0
-#define ABS_PREHEAT_FAN_SPEED 165   // Insert Value between 0 and 255
-
-//
-// Print job timer
-//
-// Enable this option to automatically start and stop the
-// print job timer when M104/M109/M190 commands are received.
-// M104 (extruder without wait) - high temp = none, low temp = stop timer
-// M109 (extruder with wait) - high temp = start timer, low temp = stop timer
-// M190 (bed with wait) - high temp = start timer, low temp = none
-//
-// In all cases the timer can be started and stopped using
-// the following commands:
-//
-// - M75  - Start the print job timer
-// - M76  - Pause the print job timer
-// - M77  - Stop the print job timer
-#define PRINTJOB_TIMER_AUTOSTART
-
-//
-// Print Counter
-//
-// When enabled Marlin will keep track of some print statistical data such as:
-//  - Total print jobs
-//  - Total successful print jobs
-//  - Total failed print jobs
-//  - Total time printing
-//
-// This information can be viewed by the M78 command.
-//#define PRINTCOUNTER
-
-//=============================================================================
-//============================= LCD and SD support ============================
-//=============================================================================
-
-// @section lcd
-
-//
-// LCD LANGUAGE
-//
-// Here you may choose the language used by Marlin on the LCD menus, the following
-// list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
-//
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
-//
-#define LCD_LANGUAGE en
-
-//
-// LCD Character Set
-//
-// Note: This option is NOT applicable to Graphical Displays.
-//
-// All character-based LCD's provide ASCII plus one of these
-// language extensions:
-//
-//  - JAPANESE ... the most common
-//  - WESTERN  ... with more accented characters
-//  - CYRILLIC ... for the Russian language
-//
-// To determine the language extension installed on your controller:
-//
-//  - Compile and upload with LCD_LANGUAGE set to 'test'
-//  - Click the controller to view the LCD menu
-//  - The LCD will display Japanese, Western, or Cyrillic text
-//
-// See https://github.com/MarlinFirmware/Marlin/wiki/LCD-Language
-//
-// :['JAPANESE','WESTERN','CYRILLIC']
-//
-#define DISPLAY_CHARSET_HD44780 JAPANESE
-
-//
-// LCD TYPE
-//
-// You may choose ULTRA_LCD if you have character based LCD with 16x2, 16x4, 20x2,
-// 20x4 char/lines or DOGLCD for the full graphics display with 128x64 pixels
-// (ST7565R family). (This option will be set automatically for certain displays.)
-//
-// IMPORTANT NOTE: The U8glib library is required for Full Graphic Display!
-//                 https://github.com/olikraus/U8glib_Arduino
-//
-#define ULTRA_LCD   // Character based
-//#define DOGLCD      // Full graphics display
-
-//
-// SD CARD
-//
-// SD Card support is disabled by default. If your controller has an SD slot,
-// you must uncomment the following option or it won't work.
-//
-#define SDSUPPORT
-
-//
-// SD CARD: SPI SPEED
-//
-// Uncomment ONE of the following items to use a slower SPI transfer
-// speed. This is usually required if you're getting volume init errors.
-//
-//#define SPI_SPEED SPI_HALF_SPEED
-//#define SPI_SPEED SPI_QUARTER_SPEED
-//#define SPI_SPEED SPI_EIGHTH_SPEED
-
-//
-// SD CARD: ENABLE CRC
-//
-// Use CRC checks and retries on the SD communication.
-//
-//#define SD_CHECK_AND_RETRY
-
-//
-// ENCODER SETTINGS
-//
-// This option overrides the default number of encoder pulses needed to
-// produce one step. Should be increased for high-resolution encoders.
-//
-#define ENCODER_PULSES_PER_STEP 4
-
-//
-// Use this option to override the number of step signals required to
-// move between next/prev menu items.
-//
-#define ENCODER_STEPS_PER_MENU_ITEM 1
-
-/**
- * Encoder Direction Options
- *
- * Test your encoder's behavior first with both options disabled.
- *
- *  Reversed Value Edit and Menu Nav? Enable REVERSE_ENCODER_DIRECTION.
- *  Reversed Menu Navigation only?    Enable REVERSE_MENU_DIRECTION.
- *  Reversed Value Editing only?      Enable BOTH options.
- */
-
-//
-// This option reverses the encoder direction everywhere
-//
-//  Set this option if CLOCKWISE causes values to DECREASE
-//
-//#define REVERSE_ENCODER_DIRECTION
-
-//
-// This option reverses the encoder direction for navigating LCD menus.
-//
-//  If CLOCKWISE normally moves DOWN this makes it go UP.
-//  If CLOCKWISE normally moves UP this makes it go DOWN.
-//
-#define REVERSE_MENU_DIRECTION
-
-//
-// Individual Axis Homing
-//
-// Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.
-//
-//#define INDIVIDUAL_AXIS_HOMING_MENU
-
-//
-// SPEAKER/BUZZER
-//
-// If you have a speaker that can produce tones, enable it here.
-// By default Marlin assumes you have a buzzer with a fixed frequency.
-//
-//#define SPEAKER
-
-//
-// The duration and frequency for the UI feedback sound.
-// Set these to 0 to disable audio feedback in the LCD menus.
-//
-// Note: Test audio output with the G-Code:
-//  M300 S<frequency Hz> P<duration ms>
-//
-//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
-//#define LCD_FEEDBACK_FREQUENCY_HZ 1000
-
-//
-// CONTROLLER TYPE: Standard
-//
-// Marlin supports a wide variety of controllers.
-// Enable one of the following options to specify your controller.
-//
-
-//
-// ULTIMAKER Controller.
-//
-#define ULTIMAKERCONTROLLER
-
-//
-// ULTIPANEL as seen on Thingiverse.
-//
-//#define ULTIPANEL
-
-//
-// Cartesio UI
-// http://mauk.cc/webshop/cartesio-shop/electronics/user-interface
-//
-//#define CARTESIO_UI
-
-//
-// PanelOne from T3P3 (via RAMPS 1.4 AUX2/AUX3)
-// http://reprap.org/wiki/PanelOne
-//
-//#define PANEL_ONE
-
-//
-// MaKr3d Makr-Panel with graphic controller and SD support.
-// http://reprap.org/wiki/MaKr3d_MaKrPanel
-//
-//#define MAKRPANEL
-
-//
-// Activate one of these if you have a Panucatt Devices
-// Viki 2.0 or mini Viki with Graphic LCD
-// http://panucatt.com
-//
-//#define VIKI2
-//#define miniVIKI
-
-//
-// Adafruit ST7565 Full Graphic Controller.
-// https://github.com/eboston/Adafruit-ST7565-Full-Graphic-Controller/
-//
-//#define ELB_FULL_GRAPHIC_CONTROLLER
-
-//
-// RepRapDiscount Smart Controller.
-// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
-//
-// Note: Usually sold with a white PCB.
-//
-//#define REPRAP_DISCOUNT_SMART_CONTROLLER
-
-//
-// GADGETS3D G3D LCD/SD Controller
-// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
-//
-// Note: Usually sold with a blue PCB.
-//
-//#define G3D_PANEL
-
-//
-// RepRapDiscount FULL GRAPHIC Smart Controller
-// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
-//
-//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
-
-//
-// MakerLab Mini Panel with graphic
-// controller and SD support - http://reprap.org/wiki/Mini_panel
-//
-//#define MINIPANEL
-
-//
-// RepRapWorld REPRAPWORLD_KEYPAD v1.1
-// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
-//
-// REPRAPWORLD_KEYPAD_MOVE_STEP sets how much should the robot move when a key
-// is pressed, a value of 10.0 means 10mm per click.
-//
-//#define REPRAPWORLD_KEYPAD
-//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0
-
-//
-// RigidBot Panel V1.0
-// http://www.inventapart.com/
-//
-//#define RIGIDBOT_PANEL
-
-//
-// BQ LCD Smart Controller shipped by
-// default with the BQ Hephestos 2 and Witbox 2.
-//
-//#define BQ_LCD_SMART_CONTROLLER
-
-//
-// CONTROLLER TYPE: I2C
-//
-// Note: These controllers require the installation of Arduino's LiquidCrystal_I2C
-// library. For more info: https://github.com/kiyoshigawa/LiquidCrystal_I2C
-//
-
-//
-// Elefu RA Board Control Panel
-// http://www.elefu.com/index.php?route=product/product&product_id=53
-//
-//#define RA_CONTROL_PANEL
-
-//
-// Sainsmart YW Robot (LCM1602) LCD Display
-//
-//#define LCD_I2C_SAINSMART_YWROBOT
-
-//
-// Generic LCM1602 LCD adapter
-//
-//#define LCM1602
-
-//
-// PANELOLU2 LCD with status LEDs,
-// separate encoder and click inputs.
-//
-// Note: This controller requires Arduino's LiquidTWI2 library v1.2.3 or later.
-// For more info: https://github.com/lincomatic/LiquidTWI2
-//
-// Note: The PANELOLU2 encoder click input can either be directly connected to
-// a pin (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).
-//
-//#define LCD_I2C_PANELOLU2
-
-//
-// Panucatt VIKI LCD with status LEDs,
-// integrated click & L/R/U/D buttons, separate encoder inputs.
-//
-//#define LCD_I2C_VIKI
-
-//
-// SSD1306 OLED full graphics generic display
-//
-//#define U8GLIB_SSD1306
-
-//
-// SAV OLEd LCD module support using either SSD1306 or SH1106 based LCD modules
-//
-//#define SAV_3DGLCD
-#if ENABLED(SAV_3DGLCD)
-  //#define U8GLIB_SSD1306
-  #define U8GLIB_SH1106
-#endif
-
-//
-// CONTROLLER TYPE: Shift register panels
-//
-// 2 wire Non-latching LCD SR from https://goo.gl/aJJ4sH
-// LCD configuration: http://reprap.org/wiki/SAV_3D_LCD
-//
-//#define SAV_3DLCD
-
-//=============================================================================
-//=============================== Extra Features ==============================
-//=============================================================================
-
-// @section extras
-
-// Increase the FAN PWM frequency. Removes the PWM noise but increases heating in the FET/Arduino
-//#define FAST_PWM_FAN
-
-// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
-// which is not as annoying as with the hardware PWM. On the other hand, if this frequency
-// is too low, you should also increment SOFT_PWM_SCALE.
-//#define FAN_SOFT_PWM
-
-// Incrementing this by 1 will double the software PWM frequency,
-// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
-// However, control resolution will be halved for each increment;
-// at zero value, there are 128 effective control positions.
-#define SOFT_PWM_SCALE 0
-
-// Temperature status LEDs that display the hotend and bed temperature.
-// If all hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
-// Otherwise the RED led is on. There is 1C hysteresis.
-//#define TEMP_STAT_LEDS
-
-// M240  Triggers a camera by emulating a Canon RC-1 Remote
-// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
-//#define PHOTOGRAPH_PIN     23
-
-// SkeinForge sends the wrong arc g-codes when using Arc Point as fillet procedure
-//#define SF_ARC_FIX
-
-// Support for the BariCUDA Paste Extruder.
-//#define BARICUDA
-
-//define BlinkM/CyzRgb Support
-//#define BLINKM
-
-/*********************************************************************\
-* R/C SERVO support
-* Sponsored by TrinityLabs, Reworked by codexmas
-**********************************************************************/
-
-// Number of servos
-//
-// If you select a configuration below, this will receive a default value and does not need to be set manually
-// set it manually if you have more servos than extruders and wish to manually control some
-// leaving it undefined or defining as 0 will disable the servo subsystem
-// If unsure, leave commented / disabled
-//
-//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
-
-// Delay (in microseconds) before the next move will start, to give the servo time to reach its target angle.
-// 300ms is a good value but you can try less delay.
-// If the servo can't reach the requested position, increase it.
-#define SERVO_DELAY 300
-
-// Servo deactivation
-//
-// With this option servos are powered only during movement, then turned off to prevent jitter.
-//#define DEACTIVATE_SERVOS_AFTER_MOVE
-
-/**********************************************************************\
- * Support for a filament diameter sensor
- * Also allows adjustment of diameter at print time (vs  at slicing)
- * Single extruder only at this point (extruder 0)
- *
- * Motherboards
- * 34 - RAMPS1.4 - uses Analog input 5 on the AUX2 connector
- * 81 - Printrboard - Uses Analog input 2 on the Exp1 connector (version B,C,D,E)
- * 301 - Rambo  - uses Analog input 3
- * Note may require analog pins to be defined for different motherboards
- **********************************************************************/
-// Uncomment below to enable
-//#define FILAMENT_WIDTH_SENSOR
-
-#define DEFAULT_NOMINAL_FILAMENT_DIA 3.00  //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation
-
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  #define FILAMENT_SENSOR_EXTRUDER_NUM 0   //The number of the extruder that has the filament sensor (0,1,2)
-  #define MEASUREMENT_DELAY_CM        14   //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
-
-  #define MEASURED_UPPER_LIMIT         3.30  //upper limit factor used for sensor reading validation in mm
-  #define MEASURED_LOWER_LIMIT         1.90  //lower limit factor for sensor reading validation in mm
-  #define MAX_MEASUREMENT_DELAY       20     //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)
-
-  #define DEFAULT_MEASURED_FILAMENT_DIA  DEFAULT_NOMINAL_FILAMENT_DIA  //set measured to nominal initially
-
-  //When using an LCD, uncomment the line below to display the Filament sensor data on the last line instead of status.  Status will appear for 5 sec.
-  //#define FILAMENT_LCD_DISPLAY
-#endif
-
-#include "Configuration_adv.h"
-#include "thermistortables.h"
-
-#endif //CONFIGURATION_H
diff --git a/Marlin/example_configurations/K8400/Dual-head/Configuration.h b/Marlin/example_configurations/K8400/Dual-head/Configuration.h
new file mode 100644
index 0000000..992912e
--- /dev/null
+++ b/Marlin/example_configurations/K8400/Dual-head/Configuration.h
@@ -0,0 +1,1308 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Configuration.h
+ *
+ * Basic settings such as:
+ *
+ * - Type of electronics
+ * - Type of temperature sensor
+ * - Printer geometry
+ * - Endstop configuration
+ * - LCD controller
+ * - Extra features
+ *
+ * Advanced settings can be found in Configuration_adv.h
+ *
+ */
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+/**
+ *
+ *  ***********************************
+ *  **  ATTENTION TO ALL DEVELOPERS  **
+ *  ***********************************
+ *
+ * You must increment this version number for every significant change such as,
+ * but not limited to: ADD, DELETE RENAME OR REPURPOSE any directive/option.
+ *
+ * Note: Update also Version.h !
+ */
+#define CONFIGURATION_H_VERSION 010100
+
+#include "boards.h"
+#include "macros.h"
+
+//===========================================================================
+//============================= Getting Started =============================
+//===========================================================================
+
+/**
+ * Here are some standard links for getting your machine calibrated:
+ *
+ * http://reprap.org/wiki/Calibration
+ * http://youtu.be/wAL9d7FgInk
+ * http://calculator.josefprusa.cz
+ * http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide
+ * http://www.thingiverse.com/thing:5573
+ * https://sites.google.com/site/repraplogphase/calibration-of-your-reprap
+ * http://www.thingiverse.com/thing:298812
+ */
+
+//===========================================================================
+//============================= DELTA Printer ===============================
+//===========================================================================
+// For a Delta printer replace the configuration files with the files in the
+// example_configurations/delta directory.
+//
+
+//===========================================================================
+//============================= SCARA Printer ===============================
+//===========================================================================
+// For a Scara printer replace the configuration files with the files in the
+// example_configurations/SCARA directory.
+//
+
+// @section info
+
+#if ENABLED(USE_AUTOMATIC_VERSIONING)
+  #include "_Version.h"
+#else
+  #include "Version.h"
+#endif
+
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
+#define STRING_CONFIG_H_AUTHOR "(Anthony Birkett, default config)" // Who made the changes.
+#define SHOW_BOOTSCREEN
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
+
+// @section machine
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+// :[0,1,2,3,4,5,6,7]
+#define SERIAL_PORT 0
+
+// This determines the communication speed of the printer
+// :[2400,9600,19200,38400,57600,115200,250000]
+#define BAUDRATE 250000
+
+// Enable the Bluetooth serial interface on AT90USB devices
+//#define BLUETOOTH
+
+// The following define selects which electronics board you have.
+// Please choose the name from boards.h that matches your setup
+#ifndef MOTHERBOARD
+  #define MOTHERBOARD BOARD_K8400
+#endif
+
+// Optional custom name for your RepStrap or other custom machine
+// Displayed in the LCD "Ready" message
+//#define CUSTOM_MACHINE_NAME "3D Printer"
+
+// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
+// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
+//#define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
+
+// This defines the number of extruders
+// :[1,2,3,4]
+#define EXTRUDERS 2
+
+// For Cyclops or any "multi-extruder" that shares a single nozzle.
+//#define SINGLENOZZLE
+
+// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
+// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
+// For the other hotends it is their distance from the extruder 0 hotend.
+//#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
+//#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
+
+//// The following define selects which power supply you have. Please choose the one that matches your setup
+// 1 = ATX
+// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+// :{1:'ATX',2:'X-Box 360'}
+
+#define POWER_SUPPLY 1
+
+// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
+//#define PS_DEFAULT_OFF
+
+// @section temperature
+
+//===========================================================================
+//============================= Thermal Settings ============================
+//===========================================================================
+//
+//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table
+//
+//// Temperature sensor settings:
+// -3 is thermocouple with MAX31855 (only for sensor 0)
+// -2 is thermocouple with MAX6675 (only for sensor 0)
+// -1 is thermocouple with AD595
+// 0 is not used
+// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
+// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
+// 3 is Mendel-parts thermistor (4.7k pullup)
+// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
+// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
+// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
+// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
+// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)
+// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
+// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
+// 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 11 is 100k beta 3950 1% thermistor (4.7k pullup)
+// 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)
+// 13 is 100k Hisens 3950  1% up to 300°C for hotend "Simple ONE " & "Hotend "All In ONE"
+// 20 is the PT100 circuit found in the Ultimainboard V2.x
+// 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950
+// 66 is 4.7M High Temperature thermistor from Dyze Design
+// 70 is the 100K thermistor found in the bq Hephestos 2
+//
+//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
+//                          (but gives greater accuracy and more stable PID)
+// 51 is 100k thermistor - EPCOS (1k pullup)
+// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
+// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
+//
+// 1047 is Pt1000 with 4k7 pullup
+// 1010 is Pt1000 with 1k pullup (non standard)
+// 147 is Pt100 with 4k7 pullup
+// 110 is Pt100 with 1k pullup (non standard)
+// 998 and 999 are Dummy Tables. They will ALWAYS read 25°C or the temperature defined below.
+//     Use it for Testing or Development purposes. NEVER for production machine.
+//#define DUMMY_THERMISTOR_998_VALUE 25
+//#define DUMMY_THERMISTOR_999_VALUE 100
+// :{ '0': "Not used",'1':"100k / 4.7k - EPCOS",'2':"200k / 4.7k - ATC Semitec 204GT-2",'3':"Mendel-parts / 4.7k",'4':"10k !! do not use for a hotend. Bad resolution at high temp. !!",'5':"100K / 4.7k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'6':"100k / 4.7k EPCOS - Not as accurate as Table 1",'7':"100k / 4.7k Honeywell 135-104LAG-J01",'8':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT",'9':"100k / 4.7k GE Sensing AL03006-58.2K-97-G1",'10':"100k / 4.7k RS 198-961",'11':"100k / 4.7k beta 3950 1%",'12':"100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT (calibrated for Makibox hot bed)",'13':"100k Hisens 3950  1% up to 300°C for hotend 'Simple ONE ' & hotend 'All In ONE'",'20':"PT100 (Ultimainboard V2.x)",'51':"100k / 1k - EPCOS",'52':"200k / 1k - ATC Semitec 204GT-2",'55':"100k / 1k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)",'60':"100k Maker's Tool Works Kapton Bed Thermistor beta=3950",'66':"Dyze Design 4.7M High Temperature thermistor",'70':"the 100K thermistor found in the bq Hephestos 2",'71':"100k / 4.7k Honeywell 135-104LAF-J01",'147':"Pt100 / 4.7k",'1047':"Pt1000 / 4.7k",'110':"Pt100 / 1k (non-standard)",'1010':"Pt1000 / 1k (non standard)",'-3':"Thermocouple + MAX31855 (only for sensor 0)",'-2':"Thermocouple + MAX6675 (only for sensor 0)",'-1':"Thermocouple + AD595",'998':"Dummy 1",'999':"Dummy 2" }
+#define TEMP_SENSOR_0 5
+#define TEMP_SENSOR_1 5
+#define TEMP_SENSOR_2 0
+#define TEMP_SENSOR_3 0
+#define TEMP_SENSOR_BED 0
+
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
+// Extruder temperature must be close to target for this long before M109 returns success
+#define TEMP_RESIDENCY_TIME 2   // (seconds)
+#define TEMP_HYSTERESIS 5       // (degC) range of +/- temperatures considered "close" to the target one
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
+
+// Bed temperature must be close to target for this long before M190 returns success
+#define TEMP_BED_RESIDENCY_TIME 10  // (seconds)
+#define TEMP_BED_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
+#define TEMP_BED_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
+
+// The minimal temperature defines the temperature below which the heater will not be enabled It is used
+// to check that the wiring to the thermistor is not broken.
+// Otherwise this would lead to the heater being powered on all the time.
+#define HEATER_0_MINTEMP 5
+#define HEATER_1_MINTEMP 5
+#define HEATER_2_MINTEMP 5
+#define HEATER_3_MINTEMP 5
+#define BED_MINTEMP 5
+
+// When temperature exceeds max temp, your heater will be switched off.
+// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
+// You should use MINTEMP for thermistor short/failure protection.
+#define HEATER_0_MAXTEMP 275
+#define HEATER_1_MAXTEMP 275
+#define HEATER_2_MAXTEMP 275
+#define HEATER_3_MAXTEMP 275
+#define BED_MAXTEMP 150
+
+// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS
+//#define HOTEND_WATTS (12.0*12.0/6.7) // P=U^2/R
+//#define BED_WATTS (12.0*12.0/1.1)    // P=U^2/R
+
+//===========================================================================
+//============================= PID Settings ================================
+//===========================================================================
+// PID Tuning Guide here: http://reprap.org/wiki/PID_Tuning
+
+// Comment the following line to disable PID and enable bang-bang.
+#define PIDTEMP
+#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX BANG_MAX // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#if ENABLED(PIDTEMP)
+  //#define PID_AUTOTUNE_MENU // Add PID Autotune to the LCD "Temperature" menu to run M303 and apply the result.
+  //#define PID_DEBUG // Sends debug data to the serial port.
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
+  //#define SLOW_PWM_HEATERS // PWM with very low frequency (roughly 0.125Hz=8s) and minimum state time of approximately 1s useful for heaters driven by a relay
+  //#define PID_PARAMS_PER_HOTEND // Uses separate PID parameters for each extruder (useful for mismatched extruders)
+                                  // Set/get with gcode: M301 E[extruder number, 0-2]
+  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
+                                  // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
+  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
+  #define K1 0.95 //smoothing factor within the PID
+
+  // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
+  // Ultimaker
+  //#define  DEFAULT_Kp 22.2
+  //#define  DEFAULT_Ki 1.08
+  //#define  DEFAULT_Kd 114
+
+  // MakerGear
+  //#define  DEFAULT_Kp 7.0
+  //#define  DEFAULT_Ki 0.1
+  //#define  DEFAULT_Kd 12
+
+  // Mendel Parts V9 on 12V
+  #define  DEFAULT_Kp 63.0
+  #define  DEFAULT_Ki 2.25
+  #define  DEFAULT_Kd 440
+
+#endif // PIDTEMP
+
+//===========================================================================
+//============================= PID > Bed Temperature Control ===============
+//===========================================================================
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
+// If your PID_dT is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+//#define PIDTEMPBED
+
+//#define BED_LIMIT_SWITCHING
+
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
+
+#if ENABLED(PIDTEMPBED)
+
+  //#define PID_BED_DEBUG // Sends debug data to the serial port.
+
+  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
+
+  //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+  //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
+  #define  DEFAULT_bedKp 10.00
+  #define  DEFAULT_bedKi .023
+  #define  DEFAULT_bedKd 305.4
+
+  //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+  //from pidautotune
+  //#define  DEFAULT_bedKp 97.1
+  //#define  DEFAULT_bedKi 1.41
+  //#define  DEFAULT_bedKd 1675.16
+
+  // FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+// @section extruder
+
+//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
+//can be software-disabled for whatever purposes by
+#define PREVENT_DANGEROUS_EXTRUDE
+//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
+#define PREVENT_LENGTHY_EXTRUDE
+
+#define EXTRUDE_MINTEMP 160
+#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
+
+//===========================================================================
+//======================== Thermal Runaway Protection =======================
+//===========================================================================
+
+/**
+ * Thermal Protection protects your printer from damage and fire if a
+ * thermistor falls out or temperature sensors fail in any way.
+ *
+ * The issue: If a thermistor falls out or a temperature sensor fails,
+ * Marlin can no longer sense the actual temperature. Since a disconnected
+ * thermistor reads as a low temperature, the firmware will keep the heater on.
+ *
+ * If you get "Thermal Runaway" or "Heating failed" errors the
+ * details can be tuned in Configuration_adv.h
+ */
+
+#define THERMAL_PROTECTION_HOTENDS // Enable thermal protection for all extruders
+#define THERMAL_PROTECTION_BED     // Enable thermal protection for the heated bed
+
+//===========================================================================
+//============================= Mechanical Settings =========================
+//===========================================================================
+
+// @section machine
+
+// Uncomment one of these options to enable CoreXY, CoreXZ, or CoreYZ kinematics
+//#define COREXY
+//#define COREXZ
+//#define COREYZ
+
+// Enable this option for Toshiba steppers
+//#define CONFIG_STEPPERS_TOSHIBA
+
+//===========================================================================
+//============================== Endstop Settings ===========================
+//===========================================================================
+
+// @section homing
+
+// Specify here all the endstop connectors that are connected to any endstop or probe.
+// Almost all printers will be using one per axis. Probes will use one or more of the
+// extra connectors. Leave undefined any used for non-endstop and non-probe purposes.
+#define USE_XMIN_PLUG
+#define USE_YMIN_PLUG
+#define USE_ZMIN_PLUG
+//#define USE_XMAX_PLUG
+//#define USE_YMAX_PLUG
+//#define USE_ZMAX_PLUG
+
+// coarse Endstop Settings
+#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+
+#if DISABLED(ENDSTOPPULLUPS)
+  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined
+  //#define ENDSTOPPULLUP_XMAX
+  //#define ENDSTOPPULLUP_YMAX
+  //#define ENDSTOPPULLUP_ZMAX
+  //#define ENDSTOPPULLUP_XMIN
+  //#define ENDSTOPPULLUP_YMIN
+  //#define ENDSTOPPULLUP_ZMIN
+  //#define ENDSTOPPULLUP_ZMIN_PROBE
+#endif
+
+// Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).
+const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+
+//===========================================================================
+//============================= Z Probe Options =============================
+//===========================================================================
+
+//
+// Probe Type
+// Probes are sensors/switches that are activated / deactivated before/after use.
+//
+// Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
+// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+//
+// Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
+//
+
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
+//#define FIX_MOUNTED_PROBE
+
+// Z Servo Probe, such as an endstop switch on a rotating arm.
+//#define Z_ENDSTOP_SERVO_NR 0
+//#define Z_SERVO_ANGLES {70,0} // Z Servo Deploy and Stow angles
+
+// Enable if you have a Z probe mounted on a sled like those designed by Charles Bell.
+//#define Z_PROBE_SLED
+//#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
+
+// Z Probe to nozzle (X,Y) offset, relative to (0, 0).
+// X and Y offsets must be integers.
+//
+// In the following example the X and Y offsets are both positive:
+// #define X_PROBE_OFFSET_FROM_EXTRUDER 10
+// #define Y_PROBE_OFFSET_FROM_EXTRUDER 10
+//
+//    +-- BACK ---+
+//    |           |
+//  L |    (+) P  | R <-- probe (20,20)
+//  E |           | I
+//  F | (-) N (+) | G <-- nozzle (10,10)
+//  T |           | H
+//    |    (-)    | T
+//    |           |
+//    O-- FRONT --+
+//  (0,0)
+#define X_PROBE_OFFSET_FROM_EXTRUDER 10  // X offset: -left  +right  [of the nozzle]
+#define Y_PROBE_OFFSET_FROM_EXTRUDER 10  // Y offset: -front +behind [the nozzle]
+#define Z_PROBE_OFFSET_FROM_EXTRUDER 0   // Z offset: -below +above  [the nozzle]
+
+// X and Y axis travel speed (mm/m) between probes
+#define XY_PROBE_SPEED 8000
+
+//
+// Allen Key Probe is defined in the Delta example configurations.
+//
+
+// Enable Z_MIN_PROBE_ENDSTOP to use _both_ a Z Probe and a Z-min-endstop on the same machine.
+// With this option the Z_MIN_PROBE_PIN will only be used for probing, never for homing.
+//
+// *** PLEASE READ ALL INSTRUCTIONS BELOW FOR SAFETY! ***
+//
+// To continue using the Z-min-endstop for homing, be sure to disable Z_SAFE_HOMING.
+// Example: To park the head outside the bed area when homing with G28.
+//
+// To use a separate Z probe, your board must define a Z_MIN_PROBE_PIN.
+//
+// For a servo-based Z probe, you must set up servo support below, including
+// NUM_SERVOS, Z_ENDSTOP_SERVO_NR and Z_SERVO_ANGLES.
+//
+// - RAMPS 1.3/1.4 boards may be able to use the 5V, GND, and Aux4->D32 pin.
+// - Use 5V for powered (usu. inductive) sensors.
+// - Otherwise connect:
+//   - normally-closed switches to GND and D32.
+//   - normally-open switches to 5V and D32.
+//
+// Normally-closed switches are advised and are the default.
+//
+// The Z_MIN_PROBE_PIN sets the Arduino pin to use. (See your board's pins file.)
+// Since the RAMPS Aux4->D32 pin maps directly to the Arduino D32 pin, D32 is the
+// default pin for all RAMPS-based boards. Some other boards map differently.
+// To set or change the pin for your board, edit the appropriate pins_XXXXX.h file.
+//
+// WARNING:
+// Setting the wrong pin may have unexpected and potentially disastrous consequences.
+// Use with caution and do your homework.
+//
+//#define Z_MIN_PROBE_ENDSTOP
+
+// Enable Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN to use the Z_MIN_PIN for your Z_MIN_PROBE.
+// The Z_MIN_PIN will then be used for both Z-homing and probing.
+#define Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN
+
+// To use a probe you must enable one of the two options above!
+
+// This option disables the use of the Z_MIN_PROBE_PIN
+// To enable the Z probe pin but disable its use, uncomment the line below. This only affects a
+// Z probe switch if you have a separate Z min endstop also and have activated Z_MIN_PROBE_ENDSTOP above.
+// If you're using the Z MIN endstop connector for your Z probe, this has no effect.
+//#define DISABLE_Z_MIN_PROBE_ENDSTOP
+
+// Enable Z Probe Repeatability test to see how accurate your probe is
+//#define Z_MIN_PROBE_REPEATABILITY_TEST
+
+//
+// Probe Raise options provide clearance for the probe to deploy, stow, and travel.
+//
+#define Z_RAISE_PROBE_DEPLOY_STOW 15 // Raise to make room for the probe to deploy / stow
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
+
+//
+// For M851 give a range for adjusting the Z probe offset
+//
+#define Z_PROBE_OFFSET_RANGE_MIN -20
+#define Z_PROBE_OFFSET_RANGE_MAX 20
+
+// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
+// :{0:'Low',1:'High'}
+#define X_ENABLE_ON 0
+#define Y_ENABLE_ON 0
+#define Z_ENABLE_ON 0
+#define E_ENABLE_ON 0 // For all extruders
+
+// Disables axis stepper immediately when it's not being used.
+// WARNING: When motors turn off there is a chance of losing position accuracy!
+#define DISABLE_X false
+#define DISABLE_Y false
+#define DISABLE_Z false
+// Warn on display about possibly reduced accuracy
+//#define DISABLE_REDUCED_ACCURACY_WARNING
+
+// @section extruder
+
+#define DISABLE_E false // For all extruders
+#define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled
+
+// @section machine
+
+// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
+#define INVERT_X_DIR false
+#define INVERT_Y_DIR true
+#define INVERT_Z_DIR true
+
+// @section extruder
+
+// For direct drive extruder v9 set to true, for geared extruder set to false.
+#define INVERT_E0_DIR false
+#define INVERT_E1_DIR true
+#define INVERT_E2_DIR false
+#define INVERT_E3_DIR false
+
+// @section homing
+//#define MIN_Z_HEIGHT_FOR_HOMING 4 // (in mm) Minimal z height before homing (G28) for Z clearance above the bed, clamps, ...
+                                    // Be sure you have this distance over your Z_MAX_POS in case.
+
+// ENDSTOP SETTINGS:
+// Sets direction of endstops when homing; 1=MAX, -1=MIN
+// :[-1,1]
+#define X_HOME_DIR -1
+#define Y_HOME_DIR -1
+#define Z_HOME_DIR -1
+
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
+
+// @section machine
+
+// Travel limits after homing (units are in mm)
+#define X_MIN_POS 0
+#define Y_MIN_POS 20
+#define Z_MIN_POS 0
+#define X_MAX_POS 200
+#define Y_MAX_POS 200
+#define Z_MAX_POS 190
+
+//===========================================================================
+//========================= Filament Runout Sensor ==========================
+//===========================================================================
+//#define FILAMENT_RUNOUT_SENSOR // Uncomment for defining a filament runout sensor such as a mechanical or opto endstop to check the existence of filament
+                                 // In RAMPS uses servo pin 2. Can be changed in pins file. For other boards pin definition should be made.
+                                 // It is assumed that when logic high = filament available
+                                 //                    when logic  low = filament ran out
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  const bool FIL_RUNOUT_INVERTING = false; // set to true to invert the logic of the sensor.
+  #define ENDSTOPPULLUP_FIL_RUNOUT // Uncomment to use internal pullup for filament runout pins if the sensor is defined.
+  #define FILAMENT_RUNOUT_SCRIPT "M600"
+#endif
+
+//===========================================================================
+//============================ Mesh Bed Leveling ============================
+//===========================================================================
+
+//#define MESH_BED_LEVELING    // Enable mesh bed leveling.
+
+#if ENABLED(MESH_BED_LEVELING)
+  #define MESH_INSET 10        // Mesh inset margin on print area
+  #define MESH_NUM_X_POINTS 3  // Don't use more than 7 points per axis, implementation limited.
+  #define MESH_NUM_Y_POINTS 3
+  #define MESH_HOME_SEARCH_Z 4  // Z after Home, bed somewhere below but above 0.0.
+
+  //#define MESH_G28_REST_ORIGIN // After homing all axes ('G28' or 'G28 XYZ') rest at origin [0,0,0]
+
+  //#define MANUAL_BED_LEVELING  // Add display menu option for bed leveling.
+
+  #if ENABLED(MANUAL_BED_LEVELING)
+    #define MBL_Z_STEP 0.025  // Step size while manually probing Z axis.
+  #endif  // MANUAL_BED_LEVELING
+
+#endif  // MESH_BED_LEVELING
+
+//===========================================================================
+//============================ Bed Auto Leveling ============================
+//===========================================================================
+
+// @section bedlevel
+
+//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+//#define DEBUG_LEVELING_FEATURE
+
+#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+
+  // There are 2 different ways to specify probing locations:
+  //
+  // - "grid" mode
+  //   Probe several points in a rectangular grid.
+  //   You specify the rectangle and the density of sample points.
+  //   This mode is preferred because there are more measurements.
+  //
+  // - "3-point" mode
+  //   Probe 3 arbitrary points on the bed (that aren't collinear)
+  //   You specify the XY coordinates of all 3 points.
+
+  // Enable this to sample the bed in a grid (least squares solution).
+  // Note: this feature generates 10KB extra code size.
+  #define AUTO_BED_LEVELING_GRID
+
+  #if ENABLED(AUTO_BED_LEVELING_GRID)
+
+    #define LEFT_PROBE_BED_POSITION 15
+    #define RIGHT_PROBE_BED_POSITION 170
+    #define FRONT_PROBE_BED_POSITION 20
+    #define BACK_PROBE_BED_POSITION 170
+
+    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+
+    // Set the number of grid points per dimension.
+    // You probably don't need more than 3 (squared=9).
+    #define AUTO_BED_LEVELING_GRID_POINTS 2
+
+  #else  // !AUTO_BED_LEVELING_GRID
+
+    // Arbitrary points to probe.
+    // A simple cross-product is used to estimate the plane of the bed.
+    #define ABL_PROBE_PT_1_X 15
+    #define ABL_PROBE_PT_1_Y 180
+    #define ABL_PROBE_PT_2_X 15
+    #define ABL_PROBE_PT_2_Y 20
+    #define ABL_PROBE_PT_3_X 170
+    #define ABL_PROBE_PT_3_Y 20
+
+  #endif // !AUTO_BED_LEVELING_GRID
+
+  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
+                                                                             // Useful to retract a deployable Z probe.
+
+  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
+  // it is highly recommended you also enable Z_SAFE_HOMING below!
+
+#endif // AUTO_BED_LEVELING_FEATURE
+
+
+// @section homing
+
+// The position of the homing switches
+//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
+
+// Manual homing switch locations:
+// For deltabots this means top and center of the Cartesian print volume.
+#if ENABLED(MANUAL_HOME_POSITIONS)
+  #define MANUAL_X_HOME_POS 0
+  #define MANUAL_Y_HOME_POS 0
+  #define MANUAL_Z_HOME_POS 0
+  //#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.
+#endif
+
+// Use "Z Safe Homing" to avoid homing with a Z probe outside the bed area.
+//
+// With this feature enabled:
+//
+// - Allow Z homing only after X and Y homing AND stepper drivers still enabled.
+// - If stepper drivers time out, it will need X and Y homing again before Z homing.
+// - Position the Z probe in a defined XY point before Z Homing when homing all axes (G28).
+// - Prevent Z homing when the Z probe is outside bed area.
+//#define Z_SAFE_HOMING
+
+#if ENABLED(Z_SAFE_HOMING)
+  #define Z_SAFE_HOMING_X_POINT ((X_MIN_POS + X_MAX_POS) / 2)    // X point for Z homing when homing all axis (G28).
+  #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
+#endif
+
+
+// @section motion
+
+/**
+ * MOVEMENT SETTINGS
+ */
+
+#define HOMING_FEEDRATE {50*60, 50*60, 8*60, 0}  // set the homing speeds (mm/min)
+
+// default settings
+
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {134.74,134.74,4266.66,148.7}  // default steps per unit for Ultimaker
+#define DEFAULT_MAX_FEEDRATE          {160, 160, 10, 10000}    // (mm/sec)
+#define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
+
+#define DEFAULT_ACCELERATION          6000    // X, Y, Z and E acceleration in mm/s^2 for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  6000    // E acceleration in mm/s^2 for retracts
+#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves
+
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
+#define DEFAULT_XYJERK                10.0    // (mm/sec)
+#define DEFAULT_ZJERK                 0.5     // (mm/sec)
+#define DEFAULT_EJERK                 20.0    // (mm/sec)
+
+
+//=============================================================================
+//============================= Additional Features ===========================
+//=============================================================================
+
+// @section extras
+
+//
+// EEPROM
+//
+// The microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores parameters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+//define this to enable EEPROM support
+#define EEPROM_SETTINGS
+
+#if ENABLED(EEPROM_SETTINGS)
+  // To disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
+  #define EEPROM_CHITCHAT // Please keep turned on if you can.
+#endif
+
+//
+// Host Keepalive
+//
+// When enabled Marlin will send a busy status message to the host
+// every couple of seconds when it can't accept commands.
+//
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
+
+//
+// M100 Free Memory Watcher
+//
+//#define M100_FREE_MEMORY_WATCHER // uncomment to add the M100 Free Memory Watcher for debug purpose
+
+//
+// G20/G21 Inch mode support
+//
+//#define INCH_MODE_SUPPORT
+
+//
+// M149 Set temperature units support
+//
+//#define TEMPERATURE_UNITS_SUPPORT
+
+// @section temperature
+
+// Preheat Constants
+#define PREHEAT_1_TEMP_HOTEND 210
+#define PREHEAT_1_TEMP_BED      0
+#define PREHEAT_1_FAN_SPEED   165 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 245
+#define PREHEAT_2_TEMP_BED      0
+#define PREHEAT_2_FAN_SPEED   165 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
+
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
+
+//
+// Print job timer
+//
+// Enable this option to automatically start and stop the
+// print job timer when M104/M109/M190 commands are received.
+// M104 (extruder without wait) - high temp = none, low temp = stop timer
+// M109 (extruder with wait) - high temp = start timer, low temp = stop timer
+// M190 (bed with wait) - high temp = start timer, low temp = none
+//
+// In all cases the timer can be started and stopped using
+// the following commands:
+//
+// - M75  - Start the print job timer
+// - M76  - Pause the print job timer
+// - M77  - Stop the print job timer
+#define PRINTJOB_TIMER_AUTOSTART
+
+//
+// Print Counter
+//
+// When enabled Marlin will keep track of some print statistical data such as:
+//  - Total print jobs
+//  - Total successful print jobs
+//  - Total failed print jobs
+//  - Total time printing
+//
+// This information can be viewed by the M78 command.
+//#define PRINTCOUNTER
+
+//=============================================================================
+//============================= LCD and SD support ============================
+//=============================================================================
+
+// @section lcd
+
+//
+// LCD LANGUAGE
+//
+// Here you may choose the language used by Marlin on the LCD menus, the following
+// list of languages are available:
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+//
+#define LCD_LANGUAGE en
+
+//
+// LCD Character Set
+//
+// Note: This option is NOT applicable to Graphical Displays.
+//
+// All character-based LCD's provide ASCII plus one of these
+// language extensions:
+//
+//  - JAPANESE ... the most common
+//  - WESTERN  ... with more accented characters
+//  - CYRILLIC ... for the Russian language
+//
+// To determine the language extension installed on your controller:
+//
+//  - Compile and upload with LCD_LANGUAGE set to 'test'
+//  - Click the controller to view the LCD menu
+//  - The LCD will display Japanese, Western, or Cyrillic text
+//
+// See https://github.com/MarlinFirmware/Marlin/wiki/LCD-Language
+//
+// :['JAPANESE','WESTERN','CYRILLIC']
+//
+#define DISPLAY_CHARSET_HD44780 JAPANESE
+
+//
+// LCD TYPE
+//
+// You may choose ULTRA_LCD if you have character based LCD with 16x2, 16x4, 20x2,
+// 20x4 char/lines or DOGLCD for the full graphics display with 128x64 pixels
+// (ST7565R family). (This option will be set automatically for certain displays.)
+//
+// IMPORTANT NOTE: The U8glib library is required for Full Graphic Display!
+//                 https://github.com/olikraus/U8glib_Arduino
+//
+#define ULTRA_LCD   // Character based
+//#define DOGLCD      // Full graphics display
+
+//
+// SD CARD
+//
+// SD Card support is disabled by default. If your controller has an SD slot,
+// you must uncomment the following option or it won't work.
+//
+#define SDSUPPORT
+
+//
+// SD CARD: SPI SPEED
+//
+// Uncomment ONE of the following items to use a slower SPI transfer
+// speed. This is usually required if you're getting volume init errors.
+//
+//#define SPI_SPEED SPI_HALF_SPEED
+//#define SPI_SPEED SPI_QUARTER_SPEED
+//#define SPI_SPEED SPI_EIGHTH_SPEED
+
+//
+// SD CARD: ENABLE CRC
+//
+// Use CRC checks and retries on the SD communication.
+//
+//#define SD_CHECK_AND_RETRY
+
+//
+// ENCODER SETTINGS
+//
+// This option overrides the default number of encoder pulses needed to
+// produce one step. Should be increased for high-resolution encoders.
+//
+#define ENCODER_PULSES_PER_STEP 4
+
+//
+// Use this option to override the number of step signals required to
+// move between next/prev menu items.
+//
+#define ENCODER_STEPS_PER_MENU_ITEM 1
+
+/**
+ * Encoder Direction Options
+ *
+ * Test your encoder's behavior first with both options disabled.
+ *
+ *  Reversed Value Edit and Menu Nav? Enable REVERSE_ENCODER_DIRECTION.
+ *  Reversed Menu Navigation only?    Enable REVERSE_MENU_DIRECTION.
+ *  Reversed Value Editing only?      Enable BOTH options.
+ */
+
+//
+// This option reverses the encoder direction everywhere
+//
+//  Set this option if CLOCKWISE causes values to DECREASE
+//
+//#define REVERSE_ENCODER_DIRECTION
+
+//
+// This option reverses the encoder direction for navigating LCD menus.
+//
+//  If CLOCKWISE normally moves DOWN this makes it go UP.
+//  If CLOCKWISE normally moves UP this makes it go DOWN.
+//
+#define REVERSE_MENU_DIRECTION
+
+//
+// Individual Axis Homing
+//
+// Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.
+//
+//#define INDIVIDUAL_AXIS_HOMING_MENU
+
+//
+// SPEAKER/BUZZER
+//
+// If you have a speaker that can produce tones, enable it here.
+// By default Marlin assumes you have a buzzer with a fixed frequency.
+//
+//#define SPEAKER
+
+//
+// The duration and frequency for the UI feedback sound.
+// Set these to 0 to disable audio feedback in the LCD menus.
+//
+// Note: Test audio output with the G-Code:
+//  M300 S<frequency Hz> P<duration ms>
+//
+//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100
+//#define LCD_FEEDBACK_FREQUENCY_HZ 1000
+
+//
+// CONTROLLER TYPE: Standard
+//
+// Marlin supports a wide variety of controllers.
+// Enable one of the following options to specify your controller.
+//
+
+//
+// ULTIMAKER Controller.
+//
+#define ULTIMAKERCONTROLLER
+
+//
+// ULTIPANEL as seen on Thingiverse.
+//
+//#define ULTIPANEL
+
+//
+// Cartesio UI
+// http://mauk.cc/webshop/cartesio-shop/electronics/user-interface
+//
+//#define CARTESIO_UI
+
+//
+// PanelOne from T3P3 (via RAMPS 1.4 AUX2/AUX3)
+// http://reprap.org/wiki/PanelOne
+//
+//#define PANEL_ONE
+
+//
+// MaKr3d Makr-Panel with graphic controller and SD support.
+// http://reprap.org/wiki/MaKr3d_MaKrPanel
+//
+//#define MAKRPANEL
+
+//
+// Activate one of these if you have a Panucatt Devices
+// Viki 2.0 or mini Viki with Graphic LCD
+// http://panucatt.com
+//
+//#define VIKI2
+//#define miniVIKI
+
+//
+// Adafruit ST7565 Full Graphic Controller.
+// https://github.com/eboston/Adafruit-ST7565-Full-Graphic-Controller/
+//
+//#define ELB_FULL_GRAPHIC_CONTROLLER
+
+//
+// RepRapDiscount Smart Controller.
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//
+// Note: Usually sold with a white PCB.
+//
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
+//
+// GADGETS3D G3D LCD/SD Controller
+// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
+//
+// Note: Usually sold with a blue PCB.
+//
+//#define G3D_PANEL
+
+//
+// RepRapDiscount FULL GRAPHIC Smart Controller
+// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
+//
+//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+
+//
+// MakerLab Mini Panel with graphic
+// controller and SD support - http://reprap.org/wiki/Mini_panel
+//
+//#define MINIPANEL
+
+//
+// RepRapWorld REPRAPWORLD_KEYPAD v1.1
+// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
+//
+// REPRAPWORLD_KEYPAD_MOVE_STEP sets how much should the robot move when a key
+// is pressed, a value of 10.0 means 10mm per click.
+//
+//#define REPRAPWORLD_KEYPAD
+//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0
+
+//
+// RigidBot Panel V1.0
+// http://www.inventapart.com/
+//
+//#define RIGIDBOT_PANEL
+
+//
+// BQ LCD Smart Controller shipped by
+// default with the BQ Hephestos 2 and Witbox 2.
+//
+//#define BQ_LCD_SMART_CONTROLLER
+
+//
+// CONTROLLER TYPE: I2C
+//
+// Note: These controllers require the installation of Arduino's LiquidCrystal_I2C
+// library. For more info: https://github.com/kiyoshigawa/LiquidCrystal_I2C
+//
+
+//
+// Elefu RA Board Control Panel
+// http://www.elefu.com/index.php?route=product/product&product_id=53
+//
+//#define RA_CONTROL_PANEL
+
+//
+// Sainsmart YW Robot (LCM1602) LCD Display
+//
+//#define LCD_I2C_SAINSMART_YWROBOT
+
+//
+// Generic LCM1602 LCD adapter
+//
+//#define LCM1602
+
+//
+// PANELOLU2 LCD with status LEDs,
+// separate encoder and click inputs.
+//
+// Note: This controller requires Arduino's LiquidTWI2 library v1.2.3 or later.
+// For more info: https://github.com/lincomatic/LiquidTWI2
+//
+// Note: The PANELOLU2 encoder click input can either be directly connected to
+// a pin (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).
+//
+//#define LCD_I2C_PANELOLU2
+
+//
+// Panucatt VIKI LCD with status LEDs,
+// integrated click & L/R/U/D buttons, separate encoder inputs.
+//
+//#define LCD_I2C_VIKI
+
+//
+// SSD1306 OLED full graphics generic display
+//
+//#define U8GLIB_SSD1306
+
+//
+// SAV OLEd LCD module support using either SSD1306 or SH1106 based LCD modules
+//
+//#define SAV_3DGLCD
+#if ENABLED(SAV_3DGLCD)
+  //#define U8GLIB_SSD1306
+  #define U8GLIB_SH1106
+#endif
+
+//
+// CONTROLLER TYPE: Shift register panels
+//
+// 2 wire Non-latching LCD SR from https://goo.gl/aJJ4sH
+// LCD configuration: http://reprap.org/wiki/SAV_3D_LCD
+//
+//#define SAV_3DLCD
+
+//=============================================================================
+//=============================== Extra Features ==============================
+//=============================================================================
+
+// @section extras
+
+// Increase the FAN PWM frequency. Removes the PWM noise but increases heating in the FET/Arduino
+//#define FAST_PWM_FAN
+
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not as annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
+// Temperature status LEDs that display the hotend and bed temperature.
+// If all hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
+// Otherwise the RED led is on. There is 1C hysteresis.
+//#define TEMP_STAT_LEDS
+
+// M240  Triggers a camera by emulating a Canon RC-1 Remote
+// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
+//#define PHOTOGRAPH_PIN     23
+
+// SkeinForge sends the wrong arc g-codes when using Arc Point as fillet procedure
+//#define SF_ARC_FIX
+
+// Support for the BariCUDA Paste Extruder.
+//#define BARICUDA
+
+//define BlinkM/CyzRgb Support
+//#define BLINKM
+
+/*********************************************************************\
+* R/C SERVO support
+* Sponsored by TrinityLabs, Reworked by codexmas
+**********************************************************************/
+
+// Number of servos
+//
+// If you select a configuration below, this will receive a default value and does not need to be set manually
+// set it manually if you have more servos than extruders and wish to manually control some
+// leaving it undefined or defining as 0 will disable the servo subsystem
+// If unsure, leave commented / disabled
+//
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
+
+// Delay (in microseconds) before the next move will start, to give the servo time to reach its target angle.
+// 300ms is a good value but you can try less delay.
+// If the servo can't reach the requested position, increase it.
+#define SERVO_DELAY 300
+
+// Servo deactivation
+//
+// With this option servos are powered only during movement, then turned off to prevent jitter.
+//#define DEACTIVATE_SERVOS_AFTER_MOVE
+
+/**********************************************************************\
+ * Support for a filament diameter sensor
+ * Also allows adjustment of diameter at print time (vs  at slicing)
+ * Single extruder only at this point (extruder 0)
+ *
+ * Motherboards
+ * 34 - RAMPS1.4 - uses Analog input 5 on the AUX2 connector
+ * 81 - Printrboard - Uses Analog input 2 on the Exp1 connector (version B,C,D,E)
+ * 301 - Rambo  - uses Analog input 3
+ * Note may require analog pins to be defined for different motherboards
+ **********************************************************************/
+// Uncomment below to enable
+//#define FILAMENT_WIDTH_SENSOR
+
+#define DEFAULT_NOMINAL_FILAMENT_DIA 3.00  //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  #define FILAMENT_SENSOR_EXTRUDER_NUM 0   //The number of the extruder that has the filament sensor (0,1,2)
+  #define MEASUREMENT_DELAY_CM        14   //measurement delay in cm.  This is the distance from filament sensor to middle of barrel
+
+  #define MEASURED_UPPER_LIMIT         3.30  //upper limit factor used for sensor reading validation in mm
+  #define MEASURED_LOWER_LIMIT         1.90  //lower limit factor for sensor reading validation in mm
+  #define MAX_MEASUREMENT_DELAY       20     //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)
+
+  #define DEFAULT_MEASURED_FILAMENT_DIA  DEFAULT_NOMINAL_FILAMENT_DIA  //set measured to nominal initially
+
+  //When using an LCD, uncomment the line below to display the Filament sensor data on the last line instead of status.  Status will appear for 5 sec.
+  //#define FILAMENT_LCD_DISPLAY
+#endif
+
+#include "Configuration_adv.h"
+#include "thermistortables.h"
+
+#endif //CONFIGURATION_H
diff --git a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
index 103814f..36ddde3 100644
--- a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
+++ b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "RepRapWorld.com" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -779,13 +795,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -827,10 +915,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/RigidBot/Configuration.h b/Marlin/example_configurations/RigidBot/Configuration.h
index 7bbed23..944384d 100644
--- a/Marlin/example_configurations/RigidBot/Configuration.h
+++ b/Marlin/example_configurations/RigidBot/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -777,13 +793,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -825,10 +913,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/RigidBot/Configuration_adv.h b/Marlin/example_configurations/RigidBot/Configuration_adv.h
index 70debac..e3af83b 100644
--- a/Marlin/example_configurations/RigidBot/Configuration_adv.h
+++ b/Marlin/example_configurations/RigidBot/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/SCARA/Configuration.h b/Marlin/example_configurations/SCARA/Configuration.h
index 488f43b..dccb892 100644
--- a/Marlin/example_configurations/SCARA/Configuration.h
+++ b/Marlin/example_configurations/SCARA/Configuration.h
@@ -122,8 +122,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -787,13 +803,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -835,10 +923,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index 81b83c1..a7285ff 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/TAZ4/Configuration.h b/Marlin/example_configurations/TAZ4/Configuration.h
index 8465b65..864c37b 100644
--- a/Marlin/example_configurations/TAZ4/Configuration.h
+++ b/Marlin/example_configurations/TAZ4/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(Aleph Objects, Inc, TAZ  config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -800,13 +816,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 230
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 230
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -848,10 +936,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/TAZ4/Configuration_adv.h b/Marlin/example_configurations/TAZ4/Configuration_adv.h
index 20e7ac1..116c99a 100644
--- a/Marlin/example_configurations/TAZ4/Configuration_adv.h
+++ b/Marlin/example_configurations/TAZ4/Configuration_adv.h
@@ -237,11 +237,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -263,14 +280,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/WITBOX/Configuration.h b/Marlin/example_configurations/WITBOX/Configuration.h
index 88c11f7..21b765b 100644
--- a/Marlin/example_configurations/WITBOX/Configuration.h
+++ b/Marlin/example_configurations/WITBOX/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(bq Witbox)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_Bootscreen.h"
+#endif
 
 // @section machine
 
@@ -771,13 +787,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 200
-#define PLA_PREHEAT_HPB_TEMP 0
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 200
+#define PREHEAT_1_TEMP_BED      0
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 220
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 220
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -819,10 +907,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index e1e6666..1aa7c21 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/adafruit/ST7565/Configuration.h b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
index 782e907..fff7140 100644
--- a/Marlin/example_configurations/adafruit/ST7565/Configuration.h
+++ b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -779,13 +795,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    110
+#define PREHEAT_2_FAN_SPEED     0 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 110
-#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -827,10 +915,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration.h b/Marlin/example_configurations/delta/biv2.5/Configuration.h
index 3b9d7f9..208bd58 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -874,13 +890,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -922,10 +1010,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
index 8464cc7..3e9fd86 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index 3305dea..bead6d4 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -868,13 +884,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -916,10 +1004,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index 874031a..1dfeb8c 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
index 4863383..a2bf738 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -871,13 +887,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -919,10 +1007,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index 1f13008..e2bb764 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
index edb6237..c04ffa1 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -103,8 +103,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -871,13 +887,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -919,10 +1007,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index db1a8e3..3baf693 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -234,11 +234,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -260,14 +277,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration.h b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
index 71bd862..17fdbfd 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
@@ -90,8 +90,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(oxivanisher)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -873,13 +889,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -921,10 +1009,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 #define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index fc30928..3b82e06 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/makibox/Configuration.h b/Marlin/example_configurations/makibox/Configuration.h
index 74d8fc5..02ec298 100644
--- a/Marlin/example_configurations/makibox/Configuration.h
+++ b/Marlin/example_configurations/makibox/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_bootscreen.h"
+#endif
 
 // @section machine
 
@@ -782,13 +798,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -830,10 +918,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index 960d186..bdf8209 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration.h b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
index 32023a3..37ae010 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
@@ -97,8 +97,24 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
-//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+
+//
+// *** VENDORS PLEASE READ *****************************************************
+//
+// Marlin now allow you to have a vendor boot image to be displayed on machine
+// start. When SHOW_CUSTOM_BOOTSCREEN is defined Marlin will first show your
+// custom boot image and them the default Marlin boot image is shown.
+//
+// We suggest for you to take advantage of this new feature and keep the Marlin
+// boot image unmodified. For an example have a look at the bq Hephestos 2
+// example configuration folder.
+//
+//#define SHOW_CUSTOM_BOOTSCREEN
+#if ENABLED(SHOW_BOOTSCREEN) && ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+  #include "_Bootscreen.h"
+#endif
 
 // @section machine
 
@@ -773,13 +789,85 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // @section temperature
 
 // Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#define PREHEAT_1_TEMP_HOTEND 180
+#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_FAN_SPEED   255 // Value from 0 to 255
+
+#define PREHEAT_2_TEMP_HOTEND 240
+#define PREHEAT_2_TEMP_BED    100
+#define PREHEAT_2_FAN_SPEED   255 // Value from 0 to 255
+
+//
+// Nozzle Park -- EXPERIMENTAL
+//
+// When enabled allows the user to define a special XYZ position, inside the
+// machine's topology, to park the nozzle when idle or when receiving the G27
+// command.
+//
+// The "P" paramenter controls what is the action applied to the Z axis:
+//    P0: (Default) If current Z-pos is lower than Z-park then the nozzle will
+//        be raised to reach Z-park height.
+//
+//    P1: No matter the current Z-pos, the nozzle will be raised/lowered to
+//        reach Z-park height.
+//
+//    P2: The nozzle height will be raised by Z-park amount but never going over
+//        the machine's limit of Z_MAX_POS.
+//
+//#define NOZZLE_PARK_FEATURE
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  // Specify a park position as { X, Y, Z }
+  #define NOZZLE_PARK_POINT { (X_MIN_POS + 10), (Y_MAX_POS - 10), 20 }
+#endif
+
+//
+// Clean Nozzle Feature -- EXPERIMENTAL
+//
+// When enabled allows the user to send G12 to start the nozzle cleaning
+// process, the G-Code accepts two parameters:
+//   "P" for pattern selection
+//   "S" for defining the number of strokes/repetitions
+//
+// Available list of patterns:
+//   P0: This is the default pattern, this process requires a sponge type
+//       material at a fixed bed location, the cleaning process is based on
+//       "strokes" i.e. back-and-forth movements between the starting and end
+//       points.
+//
+//   P1: This starts a zig-zag pattern between (X0, Y0) and (X1, Y1), "T"
+//       defines the number of zig-zag triangles to be done. "S" defines the
+//       number of strokes aka one back-and-forth movement. As an example
+//       sending "G12 P1 S1 T3" will execute:
+//
+//          --
+//         |  (X0, Y1) |     /\        /\        /\     | (X1, Y1)
+//         |           |    /  \      /  \      /  \    |
+//       A |           |   /    \    /    \    /    \   |
+//         |           |  /      \  /      \  /      \  |
+//         |  (X0, Y0) | /        \/        \/        \ | (X1, Y0)
+//          --         +--------------------------------+
+//                       |________|_________|_________|
+//                           T1        T2        T3
+//
+// Caveats: End point Z should use the same value as Start point Z.
+//
+// Attention: This is an EXPERIMENTAL feature, in the future the G-code arguments
+// may change to add new functionality like different wipe patterns.
+//
+//#define NOZZLE_CLEAN_FEATURE
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  // Number of pattern repetitions
+  #define NOZZLE_CLEAN_STROKES  12
+
+  //                            {  X,  Y,               Z}
+  #define NOZZLE_CLEAN_START_PT { 30, 30, (Z_MIN_POS + 5)}
+  #define NOZZLE_CLEAN_END_PT   {100, 60, (Z_MIN_POS + 5)}
+
+  // Moves the nozzle to the parked position
+  #define NOZZLE_CLEAN_PARK
+#endif
 
 //
 // Print job timer
@@ -821,10 +909,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //
 // Here you may choose the language used by Marlin on the LCD menus, the following
 // list of languages are available:
-//    en, an, bg, ca, cn, cz, de, es, eu, fi, fr, gl, hr, it, kana,
-//    kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
+//    en, an, bg, ca, cn, cz, de, el, el-gr, es, eu, fi, fr, gl, hr, it,
+//    kana, kana_utf8, nl, pl, pt, pt_utf8, pt-br, pt-br_utf8, ru, test
 //
-// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
+// :{'en':'English','an':'Aragonese','bg':'Bulgarian','ca':'Catalan','cn':'Chinese','cz':'Czech','de':'German','el':'Greek','el-gr':'Greek (Greece)','es':'Spanish','eu':'Basque-Euskera','fi':'Finnish','fr':'French','gl':'Galician','hr':'Croatian','it':'Italian','kana':'Japanese','kana_utf8':'Japanese (UTF8)','nl':'Dutch','pl':'Polish','pt':'Portuguese','pt-br':'Portuguese (Brazilian)','pt-br_utf8':'Portuguese (Brazilian UTF8)','pt_utf8':'Portuguese (UTF8)','ru':'Russian','test':'TEST'}
 //
 //#define LCD_LANGUAGE en
 
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index b044402..9c04c46 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
diff --git a/Marlin/fonts/ISO10646-4_Greek.fon b/Marlin/fonts/ISO10646-4_Greek.fon
new file mode 100644
index 0000000..021078e
Binary files /dev/null and b/Marlin/fonts/ISO10646-4_Greek.fon differ
diff --git a/Marlin/fonts/make_fonts.bat b/Marlin/fonts/make_fonts.bat
index 5ab975b..c4df633 100644
--- a/Marlin/fonts/make_fonts.bat
+++ b/Marlin/fonts/make_fonts.bat
@@ -6,3 +6,4 @@
 .\bdf2u8g.exe -b 32 -e 255 ISO10646_5_Cyrillic.bdf ISO10646_5_Cyrillic_5x7 dogm_font_data_ISO10646_5_Cyrillic.h
 .\bdf2u8g.exe -b 32 -e 255 ISO10646_Kana.bdf ISO10646_Kana_5x7 dogm_font_data_ISO10646_Kana.h
 .\bdf2u8g.exe -b 32 -e 255 ISO10646_CN.bdf ISO10646_CN dogm_font_data_ISO10646_CN.h
+.\bdf2u8g.exe -b 32 -e 255 ISO10646_4_Greek.bdf ISO10646_Greek_5x7 dogm_font_data_ISO10646_Greek.h
diff --git a/Marlin/language.h b/Marlin/language.h
index 03c063d..0933683 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -48,6 +48,8 @@
 // cn         Chinese
 // cz         Czech
 // de         German
+// el         Greek
+// el-gr      Greek (Greece)
 // en         English
 // es         Spanish
 // eu         Basque-Euskera
@@ -117,6 +119,7 @@
 #define MSG_PLANNER_BUFFER_BYTES            "  PlannerBufferBytes: "
 #define MSG_OK                              "ok"
 #define MSG_WAIT                            "wait"
+#define MSG_STATS                           "Stats: "
 #define MSG_FILE_SAVED                      "Done saving file."
 #define MSG_ERR_LINE_NO                     "Line Number is not Last Line Number+1, Last Line: "
 #define MSG_ERR_CHECKSUM_MISMATCH           "checksum mismatch, Last Line: "
diff --git a/Marlin/language_an.h b/Marlin/language_an.h
index 968fa51..bfabc0a 100644
--- a/Marlin/language_an.h
+++ b/Marlin/language_an.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_AN_H
 #define LANGUAGE_AN_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Set home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Establir zero"
-#define MSG_PREHEAT_PLA                     "Precalentar PLA"
-#define MSG_PREHEAT_PLA_N                   "Precalentar PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Precalentar PLA a"
-#define MSG_PREHEAT_PLA_BEDONLY             "Prec. PLA Base"
-#define MSG_PREHEAT_PLA_SETTINGS            "Achustar tem. PLA"
-#define MSG_PREHEAT_ABS                     "Precalentar ABS"
-#define MSG_PREHEAT_ABS_N                   "Precalentar ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Precalentar ABS a"
-#define MSG_PREHEAT_ABS_BEDONLY             "Prec. ABS Base"
-#define MSG_PREHEAT_ABS_SETTINGS            "Achustar tem. ABS"
+#define MSG_PREHEAT_1                       "Precalentar PLA"
+#define MSG_PREHEAT_1_N                     "Precalentar PLA "
+#define MSG_PREHEAT_1_ALL                   "Precalentar PLA a"
+#define MSG_PREHEAT_1_BEDONLY               "Prec. PLA Base"
+#define MSG_PREHEAT_1_SETTINGS              "Achustar tem. PLA"
+#define MSG_PREHEAT_2                       "Precalentar ABS"
+#define MSG_PREHEAT_2_N                     "Precalentar ABS "
+#define MSG_PREHEAT_2_ALL                   "Precalentar ABS a"
+#define MSG_PREHEAT_2_BEDONLY               "Prec. ABS Base"
+#define MSG_PREHEAT_2_SETTINGS              "Achustar tem. ABS"
 #define MSG_COOLDOWN                        "Enfriar"
 #define MSG_SWITCH_PS_ON                    "Enchegar Fuent"
 #define MSG_SWITCH_PS_OFF                   "Desenchegar Fuent"
@@ -149,8 +148,6 @@
 #define MSG_BABYSTEP_Y                      "Babystep Y"
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
-#define MSG_END_HOUR                        "hours"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_DELTA_CALIBRATE                 "Delta Calibration"
 #define MSG_DELTA_CALIBRATE_X               "Calibrate X"
 #define MSG_DELTA_CALIBRATE_Y               "Calibrate Y"
diff --git a/Marlin/language_bg.h b/Marlin/language_bg.h
index 3fc7a5b..5160694 100644
--- a/Marlin/language_bg.h
+++ b/Marlin/language_bg.h
@@ -49,16 +49,16 @@
 #define MSG_SET_HOME_OFFSETS                "Задай Начало"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Изходна точка"
-#define MSG_PREHEAT_PLA                     "Подгряване PLA"
-#define MSG_PREHEAT_PLA_N                   "Подгряване PLA"
-#define MSG_PREHEAT_PLA_ALL                 "Подгр. PLA Всички"
-#define MSG_PREHEAT_PLA_BEDONLY             "Подгр. PLA Легло"
-#define MSG_PREHEAT_PLA_SETTINGS            "Настройки PLA"
-#define MSG_PREHEAT_ABS                     "Подгряване ABS"
-#define MSG_PREHEAT_ABS_N                   "Подгряване ABS"
-#define MSG_PREHEAT_ABS_ALL                 "Подгр. ABS Всички"
-#define MSG_PREHEAT_ABS_BEDONLY             "Подгр. ABS Легло"
-#define MSG_PREHEAT_ABS_SETTINGS            "Настройки ABS"
+#define MSG_PREHEAT_1                       "Подгряване PLA"
+#define MSG_PREHEAT_1_N                     "Подгряване PLA"
+#define MSG_PREHEAT_1_ALL                   "Подгр. PLA Всички"
+#define MSG_PREHEAT_1_BEDONLY               "Подгр. PLA Легло"
+#define MSG_PREHEAT_1_SETTINGS              "Настройки PLA"
+#define MSG_PREHEAT_2                       "Подгряване ABS"
+#define MSG_PREHEAT_2_N                     "Подгряване ABS"
+#define MSG_PREHEAT_2_ALL                   "Подгр. ABS Всички"
+#define MSG_PREHEAT_2_BEDONLY               "Подгр. ABS Легло"
+#define MSG_PREHEAT_2_SETTINGS              "Настройки ABS"
 #define MSG_COOLDOWN                        "Охлаждане"
 #define MSG_SWITCH_PS_ON                    "Вкл. захранване"
 #define MSG_SWITCH_PS_OFF                   "Изкл. захранване"
@@ -150,8 +150,6 @@
 #define MSG_BABYSTEP_Y                      "Министъпка Y"
 #define MSG_BABYSTEP_Z                      "Министъпка Z"
 #define MSG_ENDSTOP_ABORT                   "Стоп Кр.Изключватели"
-#define MSG_END_HOUR                        "часа"
-#define MSG_END_MINUTE                      "минути"
 #define MSG_DELTA_CALIBRATE                 "Делта Калибровка"
 #define MSG_DELTA_CALIBRATE_X               "Калибровка X"
 #define MSG_DELTA_CALIBRATE_Y               "Калибровка Y"
diff --git a/Marlin/language_ca.h b/Marlin/language_ca.h
index 9c2ba49..b90f1c3 100644
--- a/Marlin/language_ca.h
+++ b/Marlin/language_ca.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_CA_H
 #define LANGUAGE_CA_H
 
-//#define MAPPER_NON
 #define MAPPER_C2C3  // because of "ó"
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
@@ -50,16 +49,16 @@
 #define MSG_SET_HOME_OFFSETS                "Set home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Establir origen"
-#define MSG_PREHEAT_PLA                     "Preescalfar PLA"
-#define MSG_PREHEAT_PLA_N                   "Preescalfar PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Preesc. tot PLA"
-#define MSG_PREHEAT_PLA_BEDONLY             "Preesc. llit PLA"
-#define MSG_PREHEAT_PLA_SETTINGS            "Configuració PLA"
-#define MSG_PREHEAT_ABS                     "Preescalfar ABS"
-#define MSG_PREHEAT_ABS_N                   "Preescalfar ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Preesc. tot ABS"
-#define MSG_PREHEAT_ABS_BEDONLY             "Preesc. llit ABS"
-#define MSG_PREHEAT_ABS_SETTINGS            "Configuració ABS"
+#define MSG_PREHEAT_1                       "Preescalfar PLA"
+#define MSG_PREHEAT_1_N                     "Preescalfar PLA "
+#define MSG_PREHEAT_1_ALL                   "Preesc. tot PLA"
+#define MSG_PREHEAT_1_BEDONLY               "Preesc. llit PLA"
+#define MSG_PREHEAT_1_SETTINGS              "Configuració PLA"
+#define MSG_PREHEAT_2                       "Preescalfar ABS"
+#define MSG_PREHEAT_2_N                     "Preescalfar ABS "
+#define MSG_PREHEAT_2_ALL                   "Preesc. tot ABS"
+#define MSG_PREHEAT_2_BEDONLY               "Preesc. llit ABS"
+#define MSG_PREHEAT_2_SETTINGS              "Configuració ABS"
 #define MSG_COOLDOWN                        "Refredar"
 #define MSG_SWITCH_PS_ON                    "Switch power on"
 #define MSG_SWITCH_PS_OFF                   "Switch power off"
@@ -150,8 +149,6 @@
 #define MSG_BABYSTEP_Y                      "Babystep Y"
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
-#define MSG_END_HOUR                        "hours"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_DELTA_CALIBRATE                 "Delta Calibration"
 #define MSG_DELTA_CALIBRATE_X               "Calibrate X"
 #define MSG_DELTA_CALIBRATE_Y               "Calibrate Y"
diff --git a/Marlin/language_cn.h b/Marlin/language_cn.h
index e2306a4..86c639d 100644
--- a/Marlin/language_cn.h
+++ b/Marlin/language_cn.h
@@ -29,8 +29,6 @@
  */
 #ifndef LANGUAGE_CN_H
 #define LANGUAGE_CN_H
-
-#define MAPPER_NON         // For direct ascii codes
 #define DISPLAY_CHARSET_ISO10646_CN
 
 #define WELCOME_MSG                         "\xa4\xa5\xa6\xa7"
@@ -47,16 +45,16 @@
 #define MSG_SET_HOME_OFFSETS                "\xbe\xbf\xbb\xbc\xbd\xc0\xc1"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "\xbe\xbf\xbc\xbd"
-#define MSG_PREHEAT_PLA                     "\xc3\xc4 PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " \xc5\xc6"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " \xc4\xc7"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " \xbe\xbf"
-#define MSG_PREHEAT_ABS                     "\xc3\xc4 ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " \xc5\xc6"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " \xbe\xc6"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " \xbe\xbf"
+#define MSG_PREHEAT_1                       "\xc3\xc4 PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " \xc5\xc6"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " \xc4\xc7"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " \xbe\xbf"
+#define MSG_PREHEAT_2                       "\xc3\xc4 ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " \xc5\xc6"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " \xbe\xc6"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " \xbe\xbf"
 #define MSG_COOLDOWN                        "\xc8\xc9"
 #define MSG_SWITCH_PS_ON                    "\xb9\xcb\xca\xb3"
 #define MSG_SWITCH_PS_OFF                   "\xb9\xcb\xb5\xb6"
@@ -155,8 +153,6 @@
 #define MSG_ERR_MAXTEMP                     "Err: MAXTEMP"
 #define MSG_ERR_MINTEMP                     "Err: MINTEMP"
 #define MSG_ERR_MAXTEMP_BED                 "Err: MAXTEMP BED"
-#define MSG_END_HOUR                        "hours"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_DELTA_CALIBRATE                 "Delta Calibration"
 #define MSG_DELTA_CALIBRATE_X               "Calibrate X"
 #define MSG_DELTA_CALIBRATE_Y               "Calibrate Y"
diff --git a/Marlin/language_cz.h b/Marlin/language_cz.h
index fabaf0e..3b53d90 100644
--- a/Marlin/language_cz.h
+++ b/Marlin/language_cz.h
@@ -34,7 +34,6 @@
 #ifndef LANGUAGE_CZ_H
 #define LANGUAGE_CZ_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -58,16 +57,16 @@
 #define MSG_SET_HOME_OFFSETS                "Nastavit ofsety"
 #define MSG_HOME_OFFSETS_APPLIED            "Ofsety nastaveny"
 #define MSG_SET_ORIGIN                      "Nastavit pocatek"
-#define MSG_PREHEAT_PLA                     "Zahrat PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " Vse"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Podloz"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " Nast"
-#define MSG_PREHEAT_ABS                     "Zahrat ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " Vse"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Podloz"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " Nast"
+#define MSG_PREHEAT_1                       "Zahrat PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " Vse"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " Podloz"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " Nast"
+#define MSG_PREHEAT_2                       "Zahrat ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " Vse"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " Podloz"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " Nast"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -182,14 +181,17 @@
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
 #define MSG_HEATING_FAILED_LCD              "Chyba zahrivani"
-#define MSG_ERR_REDUNDANT_TEMP              "Chyba: REDUNDANTNI TEPLOTA"
+#define MSG_ERR_REDUNDANT_TEMP              "REDUND. TEPLOTA"
 #define MSG_THERMAL_RUNAWAY                 "TEPLOTNI SKOK"
-#define MSG_ERR_MAXTEMP                     "Chyba: VYSOKA TEPLOTA"
-#define MSG_ERR_MINTEMP                     "Chyba: NIZKA TEPLOTA"
-#define MSG_ERR_MAXTEMP_BED                 "Chyba: VYSOKA TEPLOTA PODL."
-#define MSG_ERR_MINTEMP_BED                 "Chyba: NIZKA TEPLOTA PODL."
-#define MSG_END_HOUR                        "hod"
-#define MSG_END_MINUTE                      "min"
+#define MSG_ERR_MAXTEMP                     "VYSOKA TEPLOTA"
+#define MSG_ERR_MINTEMP                     "NIZKA TEPLOTA"
+#define MSG_ERR_MAXTEMP_BED                 "VYS. TEPL. PODL."
+#define MSG_ERR_MINTEMP_BED                 "NIZ. TEPL. PODL."
+#define MSG_HALTED                          "TISK. ZASTAVENA"
+#define MSG_PLEASE_RESET                    "Provedte reset"
+#define MSG_SHORT_DAY                       "d"
+#define MSG_SHORT_HOUR                      "h"
+#define MSG_SHORT_MINUTE                    "m"
 #define MSG_HEATING                         "Zahrivani..."
 #define MSG_HEATING_COMPLETE                "Zahrati hotovo."
 #define MSG_BED_HEATING                     "Zahrivani podl."
@@ -208,13 +210,13 @@
 #define MSG_INFO_BAUDRATE                   "Rychlost"
 #define MSG_INFO_PROTOCOL                   "Protokol"
 #if LCD_WIDTH > 19
-  #define MSG_INFO_PRINT_COUNT              "Pocet tisku "
-  #define MSG_INFO_FINISHED_PRINTS          "Dokonceno   "
-  #define MSG_INFO_PRINT_TIME               "Celkovy cas "
+  #define MSG_INFO_PRINT_COUNT              "Pocet tisku"
+  #define MSG_INFO_COMPLETED_PRINTS         "Dokonceno  "
+  #define MSG_INFO_PRINT_TIME               "Celkovy cas"
 #else
-  #define MSG_INFO_PRINT_COUNT              "Tisky    "
-  #define MSG_INFO_FINISHED_PRINTS          "Hotovo   "
-  #define MSG_INFO_PRINT_TIME               "Cas      "
+  #define MSG_INFO_PRINT_COUNT              "Tisky "
+  #define MSG_INFO_COMPLETED_PRINTS         "Hotovo"
+  #define MSG_INFO_PRINT_TIME               "Cas   "
 #endif
 #define MSG_INFO_MIN_TEMP                   "Teplota min"
 #define MSG_INFO_MAX_TEMP                   "Teplota max"
diff --git a/Marlin/language_da.h b/Marlin/language_da.h
index 55c9fd4..b107ca0 100644
--- a/Marlin/language_da.h
+++ b/Marlin/language_da.h
@@ -54,16 +54,16 @@
 #define MSG_SET_HOME_OFFSETS                "Sæt forskyding af home"
 #define MSG_HOME_OFFSETS_APPLIED            "Forskydninger af home pos. er tilføjet"
 #define MSG_SET_ORIGIN                      "Sæt origin"
-#define MSG_PREHEAT_PLA                     "Forvarm PLA"
-#define MSG_PREHEAT_PLA_N                   "Forvarm PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Forvarm PLA Alle"
-#define MSG_PREHEAT_PLA_BEDONLY             "Forvarm PLA Bed"
-#define MSG_PREHEAT_PLA_SETTINGS            "Forvarm PLA conf"
-#define MSG_PREHEAT_ABS                     "Forvarm ABS"
-#define MSG_PREHEAT_ABS_N                   "Forvarm ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Forvarm ABS Alle"
-#define MSG_PREHEAT_ABS_BEDONLY             "Forvarm ABS Bed"
-#define MSG_PREHEAT_ABS_SETTINGS            "Forvarm ABS conf"
+#define MSG_PREHEAT_1                       "Forvarm PLA"
+#define MSG_PREHEAT_1_N                     "Forvarm PLA "
+#define MSG_PREHEAT_1_ALL                   "Forvarm PLA Alle"
+#define MSG_PREHEAT_1_BEDONLY               "Forvarm PLA Bed"
+#define MSG_PREHEAT_1_SETTINGS              "Forvarm PLA conf"
+#define MSG_PREHEAT_2                       "Forvarm ABS"
+#define MSG_PREHEAT_2_N                     "Forvarm ABS "
+#define MSG_PREHEAT_2_ALL                   "Forvarm ABS Alle"
+#define MSG_PREHEAT_2_BEDONLY               "Forvarm ABS Bed"
+#define MSG_PREHEAT_2_SETTINGS              "Forvarm ABS conf"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -184,8 +184,6 @@
 #define MSG_ERR_MINTEMP                     "Fejl: Min temp"
 #define MSG_ERR_MAXTEMP_BED                 "Fejl: Maks Plsde temp"
 #define MSG_ERR_MINTEMP_BED                 "Fejl: Min Plade temp"
-#define MSG_END_HOUR                        "Timer"
-#define MSG_END_MINUTE                      "Minutter"
 #define MSG_HEATING                         "Opvarmer..."
 #define MSG_HEATING_COMPLETE                "Opvarmet"
 #define MSG_BED_HEATING                     "Opvarmer plade"
diff --git a/Marlin/language_de.h b/Marlin/language_de.h
index 58acd95..9744378 100644
--- a/Marlin/language_de.h
+++ b/Marlin/language_de.h
@@ -49,16 +49,16 @@
 #define MSG_SET_HOME_OFFSETS                "Setze Homeoffsets"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets aktiv"
 #define MSG_SET_ORIGIN                      "Setze Nullpunkt" //"G92 X0 Y0 Z0" commented out in ultralcd.cpp
-#define MSG_PREHEAT_PLA                     "Vorwärmen PLA"
-#define MSG_PREHEAT_PLA_N                   "Vorwärmen PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Vorw. PLA Alle"
-#define MSG_PREHEAT_PLA_BEDONLY             "Vorw. PLA Bett"
-#define MSG_PREHEAT_PLA_SETTINGS            "Vorw. PLA Einst."
-#define MSG_PREHEAT_ABS                     "Vorwärmen ABS"
-#define MSG_PREHEAT_ABS_N                   "Vorwärmen ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Vorw. ABS Alle"
-#define MSG_PREHEAT_ABS_BEDONLY             "Vorw. ABS Bett"
-#define MSG_PREHEAT_ABS_SETTINGS            "Vorw. ABS Einst."
+#define MSG_PREHEAT_1                       "Vorwärmen PLA"
+#define MSG_PREHEAT_1_N                     "Vorwärmen PLA "
+#define MSG_PREHEAT_1_ALL                   "Vorw. PLA Alle"
+#define MSG_PREHEAT_1_BEDONLY               "Vorw. PLA Bett"
+#define MSG_PREHEAT_1_SETTINGS              "Vorw. PLA Einst."
+#define MSG_PREHEAT_2                       "Vorwärmen ABS"
+#define MSG_PREHEAT_2_N                     "Vorwärmen ABS "
+#define MSG_PREHEAT_2_ALL                   "Vorw. ABS Alle"
+#define MSG_PREHEAT_2_BEDONLY               "Vorw. ABS Bett"
+#define MSG_PREHEAT_2_SETTINGS              "Vorw. ABS Einst."
 #define MSG_COOLDOWN                        "Abkühlen"
 #define MSG_SWITCH_PS_ON                    "Netzteil ein"
 #define MSG_SWITCH_PS_OFF                   "Netzteil aus"
@@ -159,8 +159,6 @@
 #define MSG_ERR_MINTEMP                     LCD_STR_THERMOMETER " UNTERSCHRITTEN"
 #define MSG_ERR_MAXTEMP_BED                 "BETT " LCD_STR_THERMOMETER " ÜBERSCHRITTEN"
 #define MSG_ERR_MINTEMP_BED                 "BETT " LCD_STR_THERMOMETER " UNTERSCHRITTEN"
-#define MSG_END_HOUR                        "Stunden"
-#define MSG_END_MINUTE                      "Minuten"
 #define MSG_HEATING                         "Aufheizen..."
 #define MSG_HEATING_COMPLETE                "Aufgeheizt"
 #define MSG_BED_HEATING                     "Bett aufheizen"
@@ -171,4 +169,59 @@
 #define MSG_DELTA_CALIBRATE_Z               "Kalibriere Z"
 #define MSG_DELTA_CALIBRATE_CENTER          "Kalibriere Mitte"
 
+#define MSG_INFO_MENU                       "Über den Drucker"
+#define MSG_INFO_PRINTER_MENU               "Drucker Info"
+#define MSG_INFO_STATS_MENU                 "Drucker Stats"
+#define MSG_INFO_BOARD_MENU                 "Board Info"
+#define MSG_INFO_THERMISTOR_MENU            "Thermistors"
+#define MSG_INFO_EXTRUDERS                  "Extruders"
+#define MSG_INFO_BAUDRATE                   "Baud"
+#define MSG_INFO_PROTOCOL                   "Protokol"
+
+#if LCD_WIDTH > 19
+  #define MSG_INFO_PRINT_COUNT              "Gesamte Drucke   "
+  #define MSG_INFO_COMPLETED_PRINTS         "Beendete Drucke  "
+  #define MSG_INFO_PRINT_TIME               "Gesamte Druckzeit"
+#else
+  #define MSG_INFO_PRINT_COUNT              "Prints   "
+  #define MSG_INFO_COMPLETED_PRINTS         "Completed"
+  #define MSG_INFO_PRINT_TIME               "Duration "
+#endif
+#define MSG_INFO_MIN_TEMP                   "Min Temp"
+#define MSG_INFO_MAX_TEMP                   "Max Temp"
+#define MSG_INFO_PSU                        "Stromversorgung"
+
+#define MSG_FILAMENT_CHANGE_HEADER          "ÄNDERE FILAMENT"
+#define MSG_FILAMENT_CHANGE_OPTION_HEADER   "ÄNDERE OPTIONEN:"
+#define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "Extrude mehr"
+#define MSG_FILAMENT_CHANGE_OPTION_RESUME   "Drucke weiter"
+
+#if LCD_HEIGHT >= 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          "Warte auf den"
+  #define MSG_FILAMENT_CHANGE_INIT_2          "Start zum "
+  #define MSG_FILAMENT_CHANGE_INIT_3          "Filament wechsel"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        "Warte auf das"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_2        "herrausnehmen"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_3        "des Filaments"
+  #define MSG_FILAMENT_CHANGE_INSERT_1        "Fädel Filament"
+  #define MSG_FILAMENT_CHANGE_INSERT_2        "ein und drücke"
+  #define MSG_FILAMENT_CHANGE_INSERT_3        "den Knopf..."
+  #define MSG_FILAMENT_CHANGE_LOAD_1          "Warte auf das"
+  #define MSG_FILAMENT_CHANGE_LOAD_2          "laden des"
+  #define MSG_FILAMENT_CHANGE_LOAD_3          "Filaments"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       "Warte auf das"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_2       "Extruden des"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_3       "Filaments"
+  #define MSG_FILAMENT_CHANGE_RESUME_1        "Warte auf das"
+  #define MSG_FILAMENT_CHANGE_RESUME_2        "fortfahren des"
+  #define MSG_FILAMENT_CHANGE_RESUME_3        "Druckes"
+#else // LCD_HEIGHT < 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          "Bitte warten..."
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        "Auswerfen..."
+  #define MSG_FILAMENT_CHANGE_INSERT_1        "Laden und Klick"
+  #define MSG_FILAMENT_CHANGE_LOAD_1          "Laden..."
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       "Extruden..."
+  #define MSG_FILAMENT_CHANGE_RESUME_1        "Weitermachen..."
+#endif // LCD_HEIGHT < 4
+
 #endif // LANGUAGE_DE_H
diff --git a/Marlin/language_el-gr.h b/Marlin/language_el-gr.h
new file mode 100644
index 0000000..510e8aa
--- /dev/null
+++ b/Marlin/language_el-gr.h
@@ -0,0 +1,198 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Greek (Greece)
+ *
+ * LCD Menu Messages
+ * See also https://github.com/MarlinFirmware/Marlin/wiki/LCD-Language
+ *
+ */
+#ifndef LANGUAGE_EL_GR_H
+#define LANGUAGE_EL_GR_H
+
+// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
+//#define SIMULATE_ROMFONT
+
+//#define MAPPER_CECF
+//#define DISPLAY_CHARSET_ISO10646_GREEK
+
+#define WELCOME_MSG                         MACHINE_NAME " έτοιμο."
+#define MSG_SD_INSERTED                     "Εισαγωγή κάρτας"
+#define MSG_SD_REMOVED                      "Αφαίρεση κάρτας"
+#define MSG_LCD_ENDSTOPS                    "Endstops" // Max length 8 characters
+#define MSG_MAIN                            "Βασική Οθόνη"
+#define MSG_AUTOSTART                       "Αυτόματη εκκίνηση"
+#define MSG_DISABLE_STEPPERS                "Απενεργοποίηση βηματιστή"
+#define MSG_AUTO_HOME                       "Αυτομ. επαναφορά στο αρχικό σημείο"
+#define MSG_AUTO_HOME_X                     "Αρχικό σημείο X"
+#define MSG_AUTO_HOME_Y                     "Αρχικό σημείο Y"
+#define MSG_AUTO_HOME_Z                     "Αρχικό σημείο Z"
+#define MSG_LEVEL_BED_HOMING                "Επαναφορά στο αρχικό σημείο ΧΥΖ"
+#define MSG_LEVEL_BED_WAITING               "Κάντε κλικ για να ξεκινήσετε"
+#define MSG_LEVEL_BED_NEXT_POINT            "Επόμενο σημείο"
+#define MSG_LEVEL_BED_DONE                  "Ολοκλήρωση επιπεδοποίησης!"
+#define MSG_LEVEL_BED_CANCEL                "Ακύρωση"
+#define MSG_SET_HOME_OFFSETS                "Ορισμός βασικών μετατοπίσεων"
+#define MSG_HOME_OFFSETS_APPLIED            "Εφαρμόστηκαν οι μετατοπίσεις"
+#define MSG_SET_ORIGIN                      "Ορισμός προέλευσης"
+#define MSG_PREHEAT_1                       "Προθέρμανση PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " όλα"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " κλίνη"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " επιβεβαίωση"
+#define MSG_PREHEAT_2                       "Προθέρμανση ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " όλα"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " Bed"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " επιβεβαίωση"
+#define MSG_H1                              "1"
+#define MSG_H2                              "2"
+#define MSG_H3                              "3"
+#define MSG_H4                              "4"
+#define MSG_COOLDOWN                        "Μειωση θερμοκρασιας"
+#define MSG_SWITCH_PS_ON                    "Ενεργοποίηση"
+#define MSG_SWITCH_PS_OFF                   "Απενεργοποίηση"
+#define MSG_EXTRUDE                         "Εξώθηση"
+#define MSG_RETRACT                         "Ανάσυρση"
+#define MSG_MOVE_AXIS                       "Μετακίνηση άξονα"
+#define MSG_LEVEL_BED                       "Επιπεδοποίηση κλίνης"
+#define MSG_MOVE_X                          "Μετακίνηση X"
+#define MSG_MOVE_Y                          "Μετακίνηση Y"
+#define MSG_MOVE_Z                          "Μετακίνηση Z"
+#define MSG_MOVE_E                          "Εξωθητήρας"
+#define MSG_MOVE_E1                         "1"
+#define MSG_MOVE_E2                         "2"
+#define MSG_MOVE_E3                         "3"
+#define MSG_MOVE_E4                         "4"
+#define MSG_MOVE_01MM                       "Μετακίνηση 0,1 μμ"
+#define MSG_MOVE_1MM                        "Μετακίνηση 1 μμ"
+#define MSG_MOVE_10MM                       "Μετακίνηση 10 μμ"
+#define MSG_SPEED                           "Ταχύτητα"
+#define MSG_BED_Z                           "Κλίνη Z"
+#define MSG_NOZZLE                          "Ακροφύσιο"
+#define MSG_N1                              " 1"
+#define MSG_N2                              " 2"
+#define MSG_N3                              " 3"
+#define MSG_N4                              " 4"
+#define MSG_BED                             "Κλίνη"
+#define MSG_FAN_SPEED                       "Ταχύτητα ανεμιστήρα"
+#define MSG_FLOW                            "Ροή"
+#define MSG_CONTROL                         "Έλεγχος"
+#define MSG_MIN                             " " LCD_STR_THERMOMETER " Min"
+#define MSG_MAX                             " " LCD_STR_THERMOMETER " Max"
+#define MSG_FACTOR                          " " LCD_STR_THERMOMETER " Fact"
+#define MSG_AUTOTEMP                        "Αυτομ. ρύθμιση θερμοκρασίας"
+#define MSG_ON                              "Ενεργοποιημένο"
+#define MSG_OFF                             "Απενεργοποιημένο"
+#define MSG_PID_P                           "PID-P"
+#define MSG_PID_I                           "PID-I"
+#define MSG_PID_D                           "PID-D"
+#define MSG_PID_C                           "PID-C"
+#define MSG_E1                              " E1"
+#define MSG_E2                              " E2"
+#define MSG_E3                              " E3"
+#define MSG_E4                              " E4"
+#define MSG_ACC                             "Επιτάχυνση"
+#define MSG_VXY_JERK                        "Vαντίδραση xy"
+#define MSG_VZ_JERK                         "Vαντίδραση z"
+#define MSG_VE_JERK                         "Vαντίδραση e"
+#define MSG_VMAX                            "Vμεγ "
+#define MSG_X                               "X"
+#define MSG_Y                               "Y"
+#define MSG_Z                               "Z"
+#define MSG_E                               "E"
+#define MSG_VMIN                            "Vελαχ"
+#define MSG_VTRAV_MIN                       "Vελάχ. μετατόπιση"
+#define MSG_AMAX                            "Aμεγ "
+#define MSG_A_RETRACT                       "Α-ανάσυρση"
+#define MSG_A_TRAVEL                        "Α-μετατόπιση"
+#define MSG_XSTEPS                          "Bήματα X ανά μμ"
+#define MSG_YSTEPS                          "Bήματα Υ ανά μμ"
+#define MSG_ZSTEPS                          "Bήματα Ζ ανά μμ"
+#define MSG_ESTEPS                          "Bήματα Ε ανά μμ"
+#define MSG_TEMPERATURE                     "Θερμοκρασία"
+#define MSG_MOTION                          "Κίνηση"
+#define MSG_VOLUMETRIC                      "Νήμα"
+#define MSG_VOLUMETRIC_ENABLED              "Ε σε μμ3"
+#define MSG_FILAMENT_DIAM                   "Διάμετρος νήματος"
+#define MSG_DIAM_E1                         " 1"
+#define MSG_DIAM_E2                         " 2"
+#define MSG_DIAM_E3                         " 3"
+#define MSG_DIAM_E4                         " 4"
+#define MSG_CONTRAST                        "Κοντράστ LCD"
+#define MSG_STORE_EPROM                     "Αποθήκευση"
+#define MSG_LOAD_EPROM                      "Φόρτωση"
+#define MSG_RESTORE_FAILSAFE                "Επαναφορά ασφαλούς αντιγράφου"
+#define MSG_REFRESH                         "Ανανέωση"
+#define MSG_WATCH                           "Οθόνη πληροφόρησης"
+#define MSG_PREPARE                         "Προετοιμασία"
+#define MSG_TUNE                            "Συντονισμός"
+#define MSG_PAUSE_PRINT                     "Παύση εκτύπωσης"
+#define MSG_RESUME_PRINT                    "Συνέχιση εκτύπωσης"
+#define MSG_STOP_PRINT                      "Διακοπή εκτύπωσης"
+#define MSG_CARD_MENU                       "Εκτύπωση από SD"
+#define MSG_NO_CARD                         "Δεν βρέθηκε SD"
+#define MSG_DWELL                           "Αναστολή λειτουργίας..."
+#define MSG_USERWAIT                        "Αναμονή για χρήστη…"
+#define MSG_RESUMING                        "Συνεχίζεται η εκτύπωση"
+#define MSG_PRINT_ABORTED                   "Διακόπτεται η εκτύπωση"
+#define MSG_NO_MOVE                         "Καμία κίνηση."
+#define MSG_KILLED                          "ΤΕΡΜΑΤΙΣΜΟΣ. "
+#define MSG_STOPPED                         "ΔΙΑΚΟΠΗ. "
+#define MSG_CONTROL_RETRACT                 "Ανάσυρση μμ"
+#define MSG_CONTROL_RETRACT_SWAP            "Εναλλαγή ανάσυρσης μμ"
+#define MSG_CONTROL_RETRACTF                "Ανάσυρση V"
+#define MSG_CONTROL_RETRACT_ZLIFT           "Μεταπήδηση μμ"
+#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"
+#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"
+#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"
+#define MSG_AUTORETRACT                     "Αυτόματη ανάσυρση"
+#define MSG_FILAMENTCHANGE                  "Αλλαγή νήματος"
+#define MSG_INIT_SDCARD                     "Προετοιμασία κάρτας SD"
+#define MSG_CNG_SDCARD                      "Αλλαγή κάρτας SD"
+#define MSG_ZPROBE_OUT                      "Διερεύνηση Z εκτός κλίνης"
+#define MSG_YX_UNHOMED                      "Επαναφορά Χ/Υ πριν από Ζ"
+#define MSG_XYZ_UNHOMED                     "Επαναφορά ΧΥΖ πρώτα"
+#define MSG_ZPROBE_ZOFFSET                  "Μετατόπιση Ζ"
+#define MSG_BABYSTEP_X                      "Μικρό βήμα Χ"
+#define MSG_BABYSTEP_Y                      "Μικρό βήμα Υ"
+#define MSG_BABYSTEP_Z                      "Μικρό βήμα Ζ"
+#define MSG_ENDSTOP_ABORT                   "Ματαίωση endstop "
+#define MSG_HEATING_FAILED_LCD              "Ανεπιτυχής θέρμανση"
+#define MSG_ERR_REDUNDANT_TEMP              "Λάθος: ΠΛΕΟΝΑΖΟΥΣΑ ΘΕΡΜΟΤΗΤΑ"
+#define MSG_THERMAL_RUNAWAY                 "ΔΙΑΦΥΓΗ ΘΕΡΜΟΤΗΤΑΣ"
+#define MSG_ERR_MAXTEMP                     "Λάθος: ΜΕΓΙΣΤΗ ΘΕΡΜΟΤΗΤΑ"
+#define MSG_ERR_MINTEMP                     "Λάθος: ΕΛΑΧΙΣΤΗ ΘΕΡΜΟΤΗΤΑ"
+#define MSG_ERR_MAXTEMP_BED                 "Λάθος: ΜΕΓΙΣΤΗ ΘΕΡΜΟΤΗΤΑ ΚΛΙΝΗΣ"
+#define MSG_ERR_MINTEMP_BED                 "Λάθος: ΕΛΑΧΙΣΤΗ ΘΕΡΜΟΤΗΤΑ ΚΛΙΝΗΣ"
+#define MSG_HEATING                         "Θερμαίνεται…"
+#define MSG_HEATING_COMPLETE                "Η θέρμανση ολοκληρώθηκε."
+#define MSG_BED_HEATING                     "Θέρμανση κλίνης."
+#define MSG_BED_DONE                        "Η κλίνη ολοκληρώθηκε."
+#define MSG_DELTA_CALIBRATE                 "Βαθμονόμηση Delta"
+#define MSG_DELTA_CALIBRATE_X               "Βαθμονόμηση X"
+#define MSG_DELTA_CALIBRATE_Y               "Βαθμονόμηση Y"
+#define MSG_DELTA_CALIBRATE_Z               "Βαθμονόμηση Z"
+#define MSG_DELTA_CALIBRATE_CENTER          "Βαθμονόμηση κέντρου"
+
+#endif // LANGUAGE_EL_GR_H
diff --git a/Marlin/language_el.h b/Marlin/language_el.h
new file mode 100644
index 0000000..9d1c855
--- /dev/null
+++ b/Marlin/language_el.h
@@ -0,0 +1,254 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Greek
+ *
+ * LCD Menu Messages
+ * See also https://github.com/MarlinFirmware/Marlin/wiki/LCD-Language
+ *
+ */
+#ifndef LANGUAGE_EL_H
+#define LANGUAGE_EL_H
+
+// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
+//#define SIMULATE_ROMFONT
+
+#define MAPPER_CECF
+#define DISPLAY_CHARSET_ISO10646_GREEK
+
+#define WELCOME_MSG                         MACHINE_NAME " έτοιμο."
+#define MSG_SD_INSERTED                     "Εισαγωγή κάρτας"
+#define MSG_SD_REMOVED                      "Αφαίρεση κάρτας"
+#define MSG_LCD_ENDSTOPS                    "Endstops" // Max length 8 characters
+#define MSG_MAIN                            "Βασική Οθόνη"
+#define MSG_AUTOSTART                       "Αυτόματη εκκίνηση"
+#define MSG_DISABLE_STEPPERS                "Απενεργοποίηση Μοτέρ"
+#define MSG_AUTO_HOME                       "Αυτομ. επαναφορά στο αρχικό σημείο" //SHORTEN
+#define MSG_AUTO_HOME_X                     "Αρχικό σημείο X"
+#define MSG_AUTO_HOME_Y                     "Αρχικό σημείο Y"
+#define MSG_AUTO_HOME_Z                     "Αρχικό σημείο Z"
+#define MSG_LEVEL_BED_HOMING                "Επαναφορά Επ. Εκτύπωσης" //SHORTEN
+#define MSG_LEVEL_BED_WAITING               "Επιπεδοποίηση επ. Εκτύπωσης περιμενει" //SHORTEN
+#define MSG_LEVEL_BED_NEXT_POINT            "Επόμενο σημείο"
+#define MSG_LEVEL_BED_DONE                  "Ολοκλήρωση επιπεδοποίησης!" //SHORTEN
+#define MSG_LEVEL_BED_CANCEL                "Ακύρωση"
+#define MSG_SET_HOME_OFFSETS                "Ορισμός βασικών μετατοπίσεων" //SHORTEN
+#define MSG_HOME_OFFSETS_APPLIED            "Εφαρμόστηκαν οι μετατοπίσεις" //SHORTEN
+#define MSG_SET_ORIGIN                      "Ορισμός προέλευσης"
+#define MSG_PREHEAT_1                       "Προθέρμανση PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " όλα"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " bed" //SHORTEN
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " επιβεβαίωση" //SHORTEN
+#define MSG_PREHEAT_2                       "Προθέρμανση ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " όλα"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " bed" //SHORTEN
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " επιβεβαίωση" //SHORTEN
+#define MSG_H1                              "1"
+#define MSG_H2                              "2"
+#define MSG_H3                              "3"
+#define MSG_H4                              "4"
+#define MSG_COOLDOWN                        "Μειωση θερμοκρασιας"
+#define MSG_SWITCH_PS_ON                    "Ενεργοποίηση"
+#define MSG_SWITCH_PS_OFF                   "Απενεργοποίηση"
+#define MSG_EXTRUDE                         "Εξώθηση"
+#define MSG_RETRACT                         "Ανάσυρση"
+#define MSG_MOVE_AXIS                       "Μετακίνηση άξονα"
+#define MSG_LEVEL_BED                       "Επιπεδοποίηση Επ. Εκτύπωσης" //SHORTEN
+#define MSG_MOVE_X                          "Μετακίνηση X"
+#define MSG_MOVE_Y                          "Μετακίνηση Y"
+#define MSG_MOVE_Z                          "Μετακίνηση Z"
+#define MSG_MOVE_E                          "Εξωθητήρας"
+#define MSG_MOVE_E1                         "1"
+#define MSG_MOVE_E2                         "2"
+#define MSG_MOVE_E3                         "3"
+#define MSG_MOVE_E4                         "4"
+#define MSG_MOVE_01MM                       "Μετακίνηση 0,1μμ"
+#define MSG_MOVE_1MM                        "Μετακίνηση 1μμ"
+#define MSG_MOVE_10MM                       "Μετακίνηση 10μμ"
+#define MSG_SPEED                           "Ταχύτητα"
+#define MSG_BED_Z                           "Επ. Εκτύπωσης Z"
+#define MSG_NOZZLE                          "Ακροφύσιο"
+#define MSG_N1                              " 1"
+#define MSG_N2                              " 2"
+#define MSG_N3                              " 3"
+#define MSG_N4                              " 4"
+#define MSG_BED                             "Κλίνη"
+#define MSG_FAN_SPEED                       "Ταχύτητα ανεμιστήρα"
+#define MSG_FLOW                            "Ροή"
+#define MSG_CONTROL                         "Έλεγχος"
+#define MSG_MIN                             " " LCD_STR_THERMOMETER " Min"
+#define MSG_MAX                             " " LCD_STR_THERMOMETER " Max"
+#define MSG_FACTOR                          " " LCD_STR_THERMOMETER " Fact"
+#define MSG_AUTOTEMP                        "Αυτομ ρύθμιση θερ/σίας" //SHORTEN
+#define MSG_ON                              "Ενεργοποιημένο"
+#define MSG_OFF                             "Απενεργοποιημένο"
+#define MSG_PID_P                           "PID-P"
+#define MSG_PID_I                           "PID-I"
+#define MSG_PID_D                           "PID-D"
+#define MSG_PID_C                           "PID-C"
+#define MSG_E1                              " E1"
+#define MSG_E2                              " E2"
+#define MSG_E3                              " E3"
+#define MSG_E4                              " E4"
+#define MSG_ACC                             "Επιτάχυνση"
+#define MSG_VXY_JERK                        "Vαντίδραση xy"
+#define MSG_VZ_JERK                         "Vαντίδραση z"
+#define MSG_VE_JERK                         "Vαντίδραση e"
+#define MSG_VMAX                            "V Μέγιστο"
+#define MSG_X                               "X"
+#define MSG_Y                               "Y"
+#define MSG_Z                               "Z"
+#define MSG_E                               "E"
+#define MSG_VMIN                            "V Ελάχιστο"
+#define MSG_VTRAV_MIN                       "Vελάχ. μετατόπιση"
+#define MSG_AMAX                            "Aμεγ "
+#define MSG_A_RETRACT                       "Α-ανάσυρση"
+#define MSG_A_TRAVEL                        "Α-μετατόπιση"
+#define MSG_XSTEPS                          "Bήματα X ανά μμ"
+#define MSG_YSTEPS                          "Bήματα Υ ανά μμ"
+#define MSG_ZSTEPS                          "Bήματα Ζ ανά μμ"
+#define MSG_ESTEPS                          "Bήματα Ε ανά μμ"
+#define MSG_TEMPERATURE                     "Θερμοκρασία"
+#define MSG_MOTION                          "Κίνηση"
+#define MSG_VOLUMETRIC                      "Νήμα"
+#define MSG_VOLUMETRIC_ENABLED              "Ε σε μμ3"
+#define MSG_FILAMENT_DIAM                   "Διάμετρος νήματος"
+#define MSG_DIAM_E1                         " 1"
+#define MSG_DIAM_E2                         " 2"
+#define MSG_DIAM_E3                         " 3"
+#define MSG_DIAM_E4                         " 4"
+#define MSG_CONTRAST                        "Κοντράστ LCD"
+#define MSG_STORE_EPROM                     "Αποθήκευση"
+#define MSG_LOAD_EPROM                      "Φόρτωση"
+#define MSG_RESTORE_FAILSAFE                "Επαναφορά ασφαλούς αντιγράφου" //SHORTEN
+#define MSG_REFRESH                         "Ανανέωση"
+#define MSG_WATCH                           "Οθόνη πληροφόρησης"
+#define MSG_PREPARE                         "Προετοιμασία"
+#define MSG_TUNE                            "Συντονισμός"
+#define MSG_PAUSE_PRINT                     "Παύση εκτύπωσης"
+#define MSG_RESUME_PRINT                    "Συνέχιση εκτύπωσης"
+#define MSG_STOP_PRINT                      "Διακοπή εκτύπωσης"
+#define MSG_CARD_MENU                       "Εκτύπωση από SD"
+#define MSG_NO_CARD                         "Δεν βρέθηκε SD"
+#define MSG_DWELL                           "Αναστολή λειτουργίας"
+#define MSG_USERWAIT                        "Αναμονή για χρήστη"
+#define MSG_RESUMING                        "Συνεχίζεται η εκτύπωση" //SHORTEN
+#define MSG_PRINT_ABORTED                   "Διακόπτεται η εκτύπωση" //SHORTEN
+#define MSG_NO_MOVE                         "Καμία κίνηση."
+#define MSG_KILLED                          "ΤΕΡΜΑΤΙΣΜΟΣ. "
+#define MSG_STOPPED                         "ΔΙΑΚΟΠΗ. "
+#define MSG_CONTROL_RETRACT                 "Ανάσυρση μμ"
+#define MSG_CONTROL_RETRACT_SWAP            "Εναλλαγή ανάσυρσης μμ"  //SHORTEN
+#define MSG_CONTROL_RETRACTF                "Ανάσυρση V"
+#define MSG_CONTROL_RETRACT_ZLIFT           "Μεταπήδηση μμ"
+#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"
+#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"
+#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"
+#define MSG_AUTORETRACT                     "Αυτόματη ανάσυρση"
+#define MSG_FILAMENTCHANGE                  "Αλλαγή νήματος"
+#define MSG_INIT_SDCARD                     "Προετοιμασία κάρτας SD"  //SHORTEN
+#define MSG_CNG_SDCARD                      "Αλλαγή κάρτας SD"
+#define MSG_ZPROBE_OUT                      "Διερεύνηση Z εκτός Επ.Εκτύπωσης" //SHORTEN
+#define MSG_YX_UNHOMED                      "Επαναφορά Χ/Υ πριν από Ζ" //SHORTEN
+#define MSG_XYZ_UNHOMED                     "Επαναφορά ΧΥΖ πρώτα"
+#define MSG_ZPROBE_ZOFFSET                  "Μετατόπιση Ζ"
+#define MSG_BABYSTEP_X                      "Μικρό βήμα Χ"
+#define MSG_BABYSTEP_Y                      "Μικρό βήμα Υ"
+#define MSG_BABYSTEP_Z                      "Μικρό βήμα Ζ"
+#define MSG_ENDSTOP_ABORT                   "Ακύρωση endstop "
+#define MSG_HEATING_FAILED_LCD              "Ανεπιτυχής θέρμανση"
+#define MSG_ERR_REDUNDANT_TEMP              "ΠΛΕΟΝΑΖΟΥΣΑ ΘΕΡΜΟΤΗΤΑ"
+#define MSG_THERMAL_RUNAWAY                 "ΔΙΑΦΥΓΗ ΘΕΡΜΟΚΡΑΣΙΑΣ"
+#define MSG_ERR_MAXTEMP                     "ΠΕΡΙΤΗ ΘΕΡΜΟΚΡΑΣΙΑ"
+#define MSG_ERR_MINTEMP                     "ΜΗ ΕΠΑΡΚΗΣ ΘΕΡΜΟΚΡΑΣΙΑΣ" //SHORTEN
+#define MSG_ERR_MAXTEMP_BED                 "ΜΕΓΙΣΤΗ ΘΕΡΜΟΚΡΑΣΙΑΣ ΕΠ. ΕΚΤΥΠΩΣΗΣ" //SHORTEN
+#define MSG_ERR_MINTEMP_BED                 "ΕΛΑΧΙΣΤΗ ΘΕΡΜΟΚΡΑΣΙΑΣ ΕΠ. ΕΚΤΥΠΩΣΗΣ" //SHORTEN
+#define MSG_HALTED                          "H εκτύπωση διακόπηκε"
+#define MSG_PLEASE_RESET                    "PLEASE RESET" //TRANSLATE
+#define MSG_HEATING                         "Θερμαίνεται…"
+#define MSG_HEATING_COMPLETE                "Η θέρμανση ολοκληρώθηκε." //SHORTEN
+#define MSG_BED_HEATING                     "Θέρμανση ΕΠ. Εκτύπωσης" //SHORTEN
+#define MSG_BED_DONE                        "Η Επ. Εκτύπωσης ολοκληρώθηκε" //SHORTEN
+#define MSG_DELTA_CALIBRATE                 "Βαθμονόμηση Delta"
+#define MSG_DELTA_CALIBRATE_X               "Βαθμονόμηση X"
+#define MSG_DELTA_CALIBRATE_Y               "Βαθμονόμηση Y"
+#define MSG_DELTA_CALIBRATE_Z               "Βαθμονόμηση Z"
+#define MSG_DELTA_CALIBRATE_CENTER          "Βαθμονόμηση κέντρου"
+
+#define MSG_INFO_MENU                       "About Printer"
+#define MSG_INFO_PRINTER_MENU               "Printer Info"
+#define MSG_INFO_STATS_MENU                 "Printer Stats"
+#define MSG_INFO_BOARD_MENU                 "Board Info"
+#define MSG_INFO_THERMISTOR_MENU            "Thermistors"
+#define MSG_INFO_EXTRUDERS                  "Extruders"
+#define MSG_INFO_BAUDRATE                   "Baud"
+#define MSG_INFO_PROTOCOL                   "Protocol"
+
+#if LCD_WIDTH > 19
+  #define MSG_INFO_PRINT_COUNT              "Print Count"
+  #define MSG_INFO_COMPLETED_PRINTS         "Completed  "
+  #define MSG_INFO_PRINT_TIME               "Total Time "
+#else
+  #define MSG_INFO_PRINT_COUNT              "Prints   "
+  #define MSG_INFO_COMPLETED_PRINTS         "Completed"
+  #define MSG_INFO_PRINT_TIME               "Duration "
+#endif
+#define MSG_INFO_MIN_TEMP                   "Min Temp"
+#define MSG_INFO_MAX_TEMP                   "Max Temp"
+#define MSG_INFO_PSU                        "Power Supply"
+
+#define MSG_FILAMENT_CHANGE_HEADER          "CHANGE FILAMENT"
+#define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "Extrude more"
+#define MSG_FILAMENT_CHANGE_OPTION_RESUME   "Resume print"
+
+#if LCD_HEIGHT >= 4
+  #define MSG_FILAMENT_CHANGE_INIT_1        "Wait for start"
+  #define MSG_FILAMENT_CHANGE_INIT_2        "of the filament"
+  #define MSG_FILAMENT_CHANGE_INIT_3        "change"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1      "Wait for"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_2      "filament unload"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_3      ""
+  #define MSG_FILAMENT_CHANGE_INSERT_1      "Insert filament"
+  #define MSG_FILAMENT_CHANGE_INSERT_2      "and press button"
+  #define MSG_FILAMENT_CHANGE_INSERT_3      "to continue..."
+  #define MSG_FILAMENT_CHANGE_LOAD_1        "Wait for"
+  #define MSG_FILAMENT_CHANGE_LOAD_2        "filament load"
+  #define MSG_FILAMENT_CHANGE_LOAD_3        ""
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1     "Wait for"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_2     "filament extrude"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_3     ""
+  #define MSG_FILAMENT_CHANGE_RESUME_1      "Wait for print"
+  #define MSG_FILAMENT_CHANGE_RESUME_2      "to resume"
+  #define MSG_FILAMENT_CHANGE_RESUME_3      ""
+#else // LCD_HEIGHT < 4
+  #define MSG_FILAMENT_CHANGE_INIT_1        "Please wait..."
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1      "Ejecting..."
+  #define MSG_FILAMENT_CHANGE_INSERT_1      "Insert and Click"
+  #define MSG_FILAMENT_CHANGE_LOAD_1        "Loading..."
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1     "Extruding..."
+  #define MSG_FILAMENT_CHANGE_RESUME_1      "Resuming..."
+#endif
+
+#endif // LANGUAGE_EL_H
diff --git a/Marlin/language_en.h b/Marlin/language_en.h
index a82da89..efb48f5 100644
--- a/Marlin/language_en.h
+++ b/Marlin/language_en.h
@@ -30,16 +30,11 @@
 #ifndef LANGUAGE_EN_H
 #define LANGUAGE_EN_H
 
-#if DISABLED(MAPPER_NON) && DISABLED(MAPPER_C2C3) && DISABLED(MAPPER_D0D1) && DISABLED(MAPPER_D0D1_MOD) && DISABLED(MAPPER_E382E383)
-  #define MAPPER_NON         // For direct ascii codes
-#endif
-
 //#define SIMULATE_ROMFONT //Comment in to see what is seen on the character based displays
-#if DISABLED(SIMULATE_ROMFONT) && DISABLED(DISPLAY_CHARSET_ISO10646_1) && DISABLED(DISPLAY_CHARSET_ISO10646_5) && DISABLED(DISPLAY_CHARSET_ISO10646_KANA) && DISABLED(DISPLAY_CHARSET_ISO10646_CN)
+#if DISABLED(SIMULATE_ROMFONT) && DISABLED(DISPLAY_CHARSET_ISO10646_1) && DISABLED(DISPLAY_CHARSET_ISO10646_5) && DISABLED(DISPLAY_CHARSET_ISO10646_KANA) && DISABLED(DISPLAY_CHARSET_ISO10646_GREEK) && DISABLED(DISPLAY_CHARSET_ISO10646_CN)
   #define DISPLAY_CHARSET_ISO10646_1 // use the better font on full graphic displays.
 #endif
 
-
 #ifndef WELCOME_MSG
   #define WELCOME_MSG                         MACHINE_NAME " ready."
 #endif
@@ -97,35 +92,35 @@
 #ifndef MSG_SET_ORIGIN
   #define MSG_SET_ORIGIN                      "Set origin"
 #endif
-#ifndef MSG_PREHEAT_PLA
-  #define MSG_PREHEAT_PLA                     "Preheat PLA"
+#ifndef MSG_PREHEAT_1
+  #define MSG_PREHEAT_1                       "Preheat PLA"
 #endif
-#ifndef MSG_PREHEAT_PLA_N
-  #define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
+#ifndef MSG_PREHEAT_1_N
+  #define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
 #endif
-#ifndef MSG_PREHEAT_PLA_ALL
-  #define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " All"
+#ifndef MSG_PREHEAT_1_ALL
+  #define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " All"
 #endif
-#ifndef MSG_PREHEAT_PLA_BEDONLY
-  #define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Bed"
+#ifndef MSG_PREHEAT_1_BEDONLY
+  #define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " Bed"
 #endif
-#ifndef MSG_PREHEAT_PLA_SETTINGS
-  #define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " conf"
+#ifndef MSG_PREHEAT_1_SETTINGS
+  #define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " conf"
 #endif
-#ifndef MSG_PREHEAT_ABS
-  #define MSG_PREHEAT_ABS                     "Preheat ABS"
+#ifndef MSG_PREHEAT_2
+  #define MSG_PREHEAT_2                       "Preheat ABS"
 #endif
-#ifndef MSG_PREHEAT_ABS_N
-  #define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
+#ifndef MSG_PREHEAT_2_N
+  #define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
 #endif
-#ifndef MSG_PREHEAT_ABS_ALL
-  #define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " All"
+#ifndef MSG_PREHEAT_2_ALL
+  #define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " All"
 #endif
-#ifndef MSG_PREHEAT_ABS_BEDONLY
-  #define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Bed"
+#ifndef MSG_PREHEAT_2_BEDONLY
+  #define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " Bed"
 #endif
-#ifndef MSG_PREHEAT_ABS_SETTINGS
-  #define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"
+#ifndef MSG_PREHEAT_2_SETTINGS
+  #define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " conf"
 #endif
 #ifndef MSG_H1
   #define MSG_H1                              "1"
@@ -493,11 +488,17 @@
 #ifndef MSG_PLEASE_RESET
   #define MSG_PLEASE_RESET                    "Please reset"
 #endif
-#ifndef MSG_END_HOUR
-  #define MSG_END_HOUR                        "hours"
+#ifndef MSG_SHORT_DAY
+  #define MSG_SHORT_DAY                       "d" // One character only
 #endif
-#ifndef MSG_END_MINUTE
-  #define MSG_END_MINUTE                      "minutes"
+#ifndef MSG_SHORT_HOUR
+  #define MSG_SHORT_HOUR                      "h" // One character only
+#endif
+#ifndef MSG_SHORT_MINUTE
+  #define MSG_SHORT_MINUTE                    "m" // One character only
+#endif
+#ifndef MSG_PRINT_TIME
+  #define MSG_PRINT_TIME                      "Print time"
 #endif
 #ifndef MSG_HEATING
   #define MSG_HEATING                         "Heating..."
@@ -526,6 +527,7 @@
 #ifndef MSG_DELTA_CALIBRATE_CENTER
   #define MSG_DELTA_CALIBRATE_CENTER          "Calibrate Center"
 #endif
+
 #ifndef MSG_INFO_MENU
   #define MSG_INFO_MENU                       "About Printer"
 #endif
@@ -553,20 +555,20 @@
 
 #if LCD_WIDTH > 19
   #ifndef MSG_INFO_PRINT_COUNT
-    #define MSG_INFO_PRINT_COUNT              "Print Count "
+    #define MSG_INFO_PRINT_COUNT              "Print Count"
   #endif
-  #ifndef MSG_INFO_FINISHED_PRINTS
-    #define MSG_INFO_FINISHED_PRINTS          "Finished    "
+  #ifndef MSG_INFO_COMPLETED_PRINTS
+    #define MSG_INFO_COMPLETED_PRINTS         "Completed  "
   #endif
   #ifndef MSG_INFO_PRINT_TIME
-    #define MSG_INFO_PRINT_TIME               "Total Time  "
+    #define MSG_INFO_PRINT_TIME               "Total Time "
   #endif
 #else
   #ifndef MSG_INFO_PRINT_COUNT
     #define MSG_INFO_PRINT_COUNT              "Prints   "
   #endif
-  #ifndef MSG_INFO_FINISHED_PRINTS
-    #define MSG_INFO_FINISHED_PRINTS          "Finished "
+  #ifndef MSG_INFO_COMPLETED_PRINTS
+    #define MSG_INFO_COMPLETED_PRINTS         "Completed"
   #endif
   #ifndef MSG_INFO_PRINT_TIME
     #define MSG_INFO_PRINT_TIME               "Duration "
diff --git a/Marlin/language_es.h b/Marlin/language_es.h
index 9722ccd..2943fcf 100644
--- a/Marlin/language_es.h
+++ b/Marlin/language_es.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_ES_H
 #define LANGUAGE_ES_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -53,16 +52,16 @@
 #define MSG_SET_HOME_OFFSETS                "Ajustar desfases"
 #define MSG_HOME_OFFSETS_APPLIED            "Desfase aplicado"
 #define MSG_SET_ORIGIN                      "Establecer origen"
-#define MSG_PREHEAT_PLA                     "Precalentar PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA "Todo"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA"Plataforma"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA "Config"
-#define MSG_PREHEAT_ABS                     "Precalentar ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS "Todo"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS "Plataforma"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS "Config"
+#define MSG_PREHEAT_1                       "Precalentar PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 "Todo"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1"Plataforma"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 "Config"
+#define MSG_PREHEAT_2                       "Precalentar ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 "Todo"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 "Plataforma"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 "Config"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -183,8 +182,6 @@
 #define MSG_ERR_MINTEMP                     "Error: Temp Minima"
 #define MSG_ERR_MAXTEMP_BED                 "Error: Temp Max Plataforma"
 #define MSG_ERR_MINTEMP_BED                 "Error: Temp Min Plataforma"
-#define MSG_END_HOUR                        "horas"
-#define MSG_END_MINUTE                      "minutos"
 #define MSG_HEATING                         "Calentando..."
 #define MSG_HEATING_COMPLETE                "Calentamiento Completo"
 #define MSG_BED_HEATING                     "Calentando plataforma ..."
diff --git a/Marlin/language_eu.h b/Marlin/language_eu.h
index f87ac2f..909d6c8 100644
--- a/Marlin/language_eu.h
+++ b/Marlin/language_eu.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_EU_H
 #define LANGUAGE_EU_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Set home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Hasiera ipini"
-#define MSG_PREHEAT_PLA                     "Aurreberotu PLA"
-#define MSG_PREHEAT_PLA_N                   "Aurreberotu PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Berotu PLA Guztia"
-#define MSG_PREHEAT_PLA_BEDONLY             "Berotu PLA Ohea"
-#define MSG_PREHEAT_PLA_SETTINGS            "Berotu PLA Konfig"
-#define MSG_PREHEAT_ABS                     "Aurreberotu ABS"
-#define MSG_PREHEAT_ABS_N                   "Aurreberotu ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Berotu ABS Guztia"
-#define MSG_PREHEAT_ABS_BEDONLY             "Berotu ABS Ohea"
-#define MSG_PREHEAT_ABS_SETTINGS            "Berotu ABS Konfig"
+#define MSG_PREHEAT_1                       "Aurreberotu PLA"
+#define MSG_PREHEAT_1_N                     "Aurreberotu PLA "
+#define MSG_PREHEAT_1_ALL                   "Berotu PLA Guztia"
+#define MSG_PREHEAT_1_BEDONLY               "Berotu PLA Ohea"
+#define MSG_PREHEAT_1_SETTINGS              "Berotu PLA Konfig"
+#define MSG_PREHEAT_2                       "Aurreberotu ABS"
+#define MSG_PREHEAT_2_N                     "Aurreberotu ABS "
+#define MSG_PREHEAT_2_ALL                   "Berotu ABS Guztia"
+#define MSG_PREHEAT_2_BEDONLY               "Berotu ABS Ohea"
+#define MSG_PREHEAT_2_SETTINGS              "Berotu ABS Konfig"
 #define MSG_COOLDOWN                        "Hoztu"
 #define MSG_SWITCH_PS_ON                    "Energia piztu"
 #define MSG_SWITCH_PS_OFF                   "Energia itzali"
@@ -149,8 +148,6 @@
 #define MSG_BABYSTEP_Y                      "Babystep Y"
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop deuseztat"
-#define MSG_END_HOUR                        "hours"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_DELTA_CALIBRATE                 "Delta Calibration"
 #define MSG_DELTA_CALIBRATE_X               "Calibrate X"
 #define MSG_DELTA_CALIBRATE_Y               "Calibrate Y"
diff --git a/Marlin/language_fi.h b/Marlin/language_fi.h
index be3db64..b73a207 100644
--- a/Marlin/language_fi.h
+++ b/Marlin/language_fi.h
@@ -49,16 +49,16 @@
 #define MSG_SET_HOME_OFFSETS                "Set home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Aseta origo"
-#define MSG_PREHEAT_PLA                     "Esilämmitä PLA"
-#define MSG_PREHEAT_PLA_N                   "Esilämmitä PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Esilä. PLA Kaikki"
-#define MSG_PREHEAT_PLA_BEDONLY             "Esilä. PLA Alusta"
-#define MSG_PREHEAT_PLA_SETTINGS            "Esilämm. PLA konf"
-#define MSG_PREHEAT_ABS                     "Esilämmitä ABS"
-#define MSG_PREHEAT_ABS_N                   "Esilämmitä ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Esilä. ABS Kaikki"
-#define MSG_PREHEAT_ABS_BEDONLY             "Esilä. ABS Alusta"
-#define MSG_PREHEAT_ABS_SETTINGS            "Esilämm. ABS konf"
+#define MSG_PREHEAT_1                       "Esilämmitä PLA"
+#define MSG_PREHEAT_1_N                     "Esilämmitä PLA "
+#define MSG_PREHEAT_1_ALL                   "Esilä. PLA Kaikki"
+#define MSG_PREHEAT_1_BEDONLY               "Esilä. PLA Alusta"
+#define MSG_PREHEAT_1_SETTINGS              "Esilämm. PLA konf"
+#define MSG_PREHEAT_2                       "Esilämmitä ABS"
+#define MSG_PREHEAT_2_N                     "Esilämmitä ABS "
+#define MSG_PREHEAT_2_ALL                   "Esilä. ABS Kaikki"
+#define MSG_PREHEAT_2_BEDONLY               "Esilä. ABS Alusta"
+#define MSG_PREHEAT_2_SETTINGS              "Esilämm. ABS konf"
 #define MSG_COOLDOWN                        "Jäähdytä"
 #define MSG_SWITCH_PS_ON                    "Virta päälle"
 #define MSG_SWITCH_PS_OFF                   "Virta pois"
@@ -149,8 +149,6 @@
 #define MSG_BABYSTEP_Y                      "Babystep Y"
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
-#define MSG_END_HOUR                        "hours"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_DELTA_CALIBRATE                 "Delta Kalibrointi"
 #define MSG_DELTA_CALIBRATE_X               "Kalibroi X"
 #define MSG_DELTA_CALIBRATE_Y               "Kalibroi Y"
diff --git a/Marlin/language_fr.h b/Marlin/language_fr.h
index f22abce..52adbcb 100644
--- a/Marlin/language_fr.h
+++ b/Marlin/language_fr.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_FR_H
 #define LANGUAGE_FR_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Regler decal. origine"
 #define MSG_HOME_OFFSETS_APPLIED            "Decalages appliques"
 #define MSG_SET_ORIGIN                      "Regler origine"
-#define MSG_PREHEAT_PLA                     "Prechauffage PLA"
-#define MSG_PREHEAT_PLA_N                   "Prechauff. PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Prech. PLA Tout"
-#define MSG_PREHEAT_PLA_BEDONLY             "Prech. PLA Plateau"
-#define MSG_PREHEAT_PLA_SETTINGS            "Regl. prech. PLA"
-#define MSG_PREHEAT_ABS                     "Prechauffage ABS"
-#define MSG_PREHEAT_ABS_N                   "Prechauff. ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Prech. ABS Tout"
-#define MSG_PREHEAT_ABS_BEDONLY             "Prech. ABS Plateau"
-#define MSG_PREHEAT_ABS_SETTINGS            "Regl. prech. ABS"
+#define MSG_PREHEAT_1                       "Prechauffage PLA"
+#define MSG_PREHEAT_1_N                     "Prechauff. PLA "
+#define MSG_PREHEAT_1_ALL                   "Prech. PLA Tout"
+#define MSG_PREHEAT_1_BEDONLY               "Prech. PLA Plateau"
+#define MSG_PREHEAT_1_SETTINGS              "Regl. prech. PLA"
+#define MSG_PREHEAT_2                       "Prechauffage ABS"
+#define MSG_PREHEAT_2_N                     "Prechauff. ABS "
+#define MSG_PREHEAT_2_ALL                   "Prech. ABS Tout"
+#define MSG_PREHEAT_2_BEDONLY               "Prech. ABS Plateau"
+#define MSG_PREHEAT_2_SETTINGS              "Regl. prech. ABS"
 #define MSG_COOLDOWN                        "Refroidir"
 #define MSG_SWITCH_PS_ON                    "Allumer alim."
 #define MSG_SWITCH_PS_OFF                   "Eteindre alim."
@@ -159,8 +158,6 @@
 #define MSG_ERR_MINTEMP                     "Err: TEMP. MIN"
 #define MSG_ERR_MAXTEMP_BED                 "Err: TEMP. MAX PLATEAU"
 #define MSG_ERR_MINTEMP_BED                 "Err: TEMP. MIN PLATEAU"
-#define MSG_END_HOUR                        "heures"
-#define MSG_END_MINUTE                      "minutes"
 #define MSG_HEATING                         "En chauffe..."
 #define MSG_HEATING_COMPLETE                "Chauffe terminee"
 #define MSG_BED_HEATING                     "Plateau en chauffe..."
diff --git a/Marlin/language_gl.h b/Marlin/language_gl.h
index f4e4639..c899c63 100644
--- a/Marlin/language_gl.h
+++ b/Marlin/language_gl.h
@@ -54,16 +54,16 @@
 #define MSG_SET_HOME_OFFSETS                "Offsets na orixe"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets fixados"
 #define MSG_SET_ORIGIN                      "Fixar orixe"
-#define MSG_PREHEAT_PLA                     "Prequentar PLA"
-#define MSG_PREHEAT_PLA_N                   "Prequentar PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Preque. PLA Todo"
-#define MSG_PREHEAT_PLA_BEDONLY             "Preque. PLA Cama"
-#define MSG_PREHEAT_PLA_SETTINGS            "Preque. PLA conf"
-#define MSG_PREHEAT_ABS                     "Prequentar ABS"
-#define MSG_PREHEAT_ABS_N                   "Prequentar ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Preque. ABS Todo"
-#define MSG_PREHEAT_ABS_BEDONLY             "Preque. ABS Cama"
-#define MSG_PREHEAT_ABS_SETTINGS            "Preque. ABS conf"
+#define MSG_PREHEAT_1                       "Prequentar PLA"
+#define MSG_PREHEAT_1_N                     "Prequentar PLA "
+#define MSG_PREHEAT_1_ALL                   "Preque. PLA Todo"
+#define MSG_PREHEAT_1_BEDONLY               "Preque. PLA Cama"
+#define MSG_PREHEAT_1_SETTINGS              "Preque. PLA conf"
+#define MSG_PREHEAT_2                       "Prequentar ABS"
+#define MSG_PREHEAT_2_N                     "Prequentar ABS "
+#define MSG_PREHEAT_2_ALL                   "Preque. ABS Todo"
+#define MSG_PREHEAT_2_BEDONLY               "Preque. ABS Cama"
+#define MSG_PREHEAT_2_SETTINGS              "Preque. ABS conf"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -184,8 +184,6 @@
 #define MSG_ERR_MINTEMP                     "Err: temp. min."
 #define MSG_ERR_MAXTEMP_BED                 "Err: MAXTEMP BED"
 #define MSG_ERR_MINTEMP_BED                 "Err: MINTEMP BED"
-#define MSG_END_HOUR                        "horas"
-#define MSG_END_MINUTE                      "minutos"
 #define MSG_HEATING                         "Quentando..."
 #define MSG_HEATING_COMPLETE                "Xa esta quente"
 #define MSG_BED_HEATING                     "Quentando cama"
diff --git a/Marlin/language_hr.h b/Marlin/language_hr.h
index d48e58c..6035215 100644
--- a/Marlin/language_hr.h
+++ b/Marlin/language_hr.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_HR_H
 #define LANGUAGE_HR_H
 
-#define MAPPER_NON
 
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
@@ -55,16 +54,16 @@
 #define MSG_SET_HOME_OFFSETS                "Postavi home offsete"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets postavljeni"
 #define MSG_SET_ORIGIN                      "Postavi ishodište"
-#define MSG_PREHEAT_PLA                     "Predgrij PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " Sve"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Bed"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " conf"
-#define MSG_PREHEAT_ABS                     "Predgrij ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " Sve"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Bed"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"
+#define MSG_PREHEAT_1                       "Predgrij PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " Sve"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " Bed"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " conf"
+#define MSG_PREHEAT_2                       "Predgrij ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " Sve"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " Bed"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " conf"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -185,8 +184,6 @@
 #define MSG_ERR_MINTEMP                     "Err: MINTEMP"
 #define MSG_ERR_MAXTEMP_BED                 "Err: MAXTEMP BED"
 #define MSG_ERR_MINTEMP_BED                 "Err: MINTEMP BED"
-#define MSG_END_HOUR                        "sati"
-#define MSG_END_MINUTE                      "minuta"
 #define MSG_HEATING                         "Grijanje..."
 #define MSG_HEATING_COMPLETE                "Grijanje gotovo."
 #define MSG_BED_HEATING                     "Grijanje Bed-a."
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index 481b725..acb4e8a 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_IT_H
 #define LANGUAGE_IT_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -54,16 +53,16 @@
 #define MSG_SET_HOME_OFFSETS                "Imp. offset home"
 #define MSG_HOME_OFFSETS_APPLIED            "Offset applicato"
 #define MSG_SET_ORIGIN                      "Imposta Origine"
-#define MSG_PREHEAT_PLA                     "Preriscalda PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " Tutto"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Piatto"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " conf"
-#define MSG_PREHEAT_ABS                     "Preriscalda ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " Tutto"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Piatto"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"
+#define MSG_PREHEAT_1                       "Preriscalda PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " Tutto"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " Piatto"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " conf"
+#define MSG_PREHEAT_2                       "Preriscalda ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " Tutto"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " Piatto"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " conf"
 #define MSG_COOLDOWN                        "Raffredda"
 #define MSG_SWITCH_PS_ON                    "Accendi aliment."
 #define MSG_SWITCH_PS_OFF                   "Spegni aliment."
@@ -164,8 +163,8 @@
 #define MSG_ERR_MINTEMP                     "Err: TEMP MINIMA"
 #define MSG_ERR_MAXTEMP_BED                 "Err: TEMP MASSIMA PIATTO"
 #define MSG_ERR_MINTEMP_BED                 "Err: TEMP MINIMA PIATTO"
-#define MSG_END_HOUR                        "ore"
-#define MSG_END_MINUTE                      "minuti"
+#define MSG_HALTED                          "STAMPANTE FERMATA"
+#define MSG_PLEASE_RESET                    "Riavviare prego"
 #define MSG_HEATING                         "Riscaldamento.."
 #define MSG_HEATING_COMPLETE                "Risc. completato"
 #define MSG_BED_HEATING                     "Risc. Piatto.."
@@ -175,5 +174,57 @@
 #define MSG_DELTA_CALIBRATE_Y               "Calibra Y"
 #define MSG_DELTA_CALIBRATE_Z               "Calibra Z"
 #define MSG_DELTA_CALIBRATE_CENTER          "Calibra Center"
+#define MSG_INFO_MENU                       "Riguardo stampante"
+#define MSG_INFO_PRINTER_MENU               "Info. stampante"
+#define MSG_INFO_STATS_MENU                 "Statistiche"
+#define MSG_INFO_BOARD_MENU                 "Info. scheda"
+#define MSG_INFO_THERMISTOR_MENU            "Termistori"
+#define MSG_INFO_EXTRUDERS                  "Estrusori"
+#define MSG_INFO_BAUDRATE                   "Baud"
+#define MSG_INFO_PROTOCOL                   "Protocollo"
+#if LCD_WIDTH > 19
+  #define MSG_INFO_PRINT_COUNT              "Contat. stampa"
+  #define MSG_INFO_FINISHED_PRINTS          "Finiti        "
+  #define MSG_INFO_PRINT_TIME               "Tempo totale  "
+#else
+  #define MSG_INFO_PRINT_COUNT              "Stampe   "
+  #define MSG_INFO_FINISHED_PRINTS          "Finiti   "
+  #define MSG_INFO_PRINT_TIME               "Durata   "
+#endif
+#define MSG_INFO_MIN_TEMP                   "Temp min"
+#define MSG_INFO_MAX_TEMP                   "Temp max"
+#define MSG_INFO_PSU                        "Alimentatore"
+
+#define MSG_FILAMENT_CHANGE_HEADER          "CAMBIA FILAMENTO"
+#define MSG_FILAMENT_CHANGE_OPTION_HEADER   "CAMBIA OPZIONI:"
+#define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "Estrusione"
+#define MSG_FILAMENT_CHANGE_OPTION_RESUME   "Riprendi stampa"
+#if LCD_HEIGHT >= 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          "Attendere avvio"
+  #define MSG_FILAMENT_CHANGE_INIT_2          "del cambio"
+  #define MSG_FILAMENT_CHANGE_INIT_3          "di filamento"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        "Attendere"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_2        "l'espulsione"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_3        "del filamento"
+  #define MSG_FILAMENT_CHANGE_INSERT_1        "Inserisci il"
+  #define MSG_FILAMENT_CHANGE_INSERT_2        "filamento e"
+  #define MSG_FILAMENT_CHANGE_INSERT_3        "premi per cont"
+  #define MSG_FILAMENT_CHANGE_LOAD_1          "Attendere"
+  #define MSG_FILAMENT_CHANGE_LOAD_2          "il caricamento"
+  #define MSG_FILAMENT_CHANGE_LOAD_3          "del filamento"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       "Attendere"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_2       "l'estrusione"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_3       "del filamento"
+  #define MSG_FILAMENT_CHANGE_RESUME_1        "Attendere"
+  #define MSG_FILAMENT_CHANGE_RESUME_2        "la ripresa"
+  #define MSG_FILAMENT_CHANGE_RESUME_3        "della stampa"
+#else // LCD_HEIGHT < 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          "Attendere..."
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        "Espulsione..."
+  #define MSG_FILAMENT_CHANGE_INSERT_1        "Inserisci e premi"
+  #define MSG_FILAMENT_CHANGE_LOAD_1          "Caricamento..."
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       "Estrusione..."
+  #define MSG_FILAMENT_CHANGE_RESUME_1        "Ripresa..."
+#endif // LCD_HEIGHT < 4
 
 #endif // LANGUAGE_IT_H
diff --git a/Marlin/language_kana.h b/Marlin/language_kana.h
index 7eb6f59..81c020a 100644
--- a/Marlin/language_kana.h
+++ b/Marlin/language_kana.h
@@ -31,7 +31,6 @@
 #ifndef LANGUAGE_KANA_H
 #define LANGUAGE_KANA_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 #define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_KANA
@@ -56,16 +55,16 @@
 #define MSG_SET_HOME_OFFSETS                "\xb7\xbc\xde\xad\xdd\xb5\xcc\xbe\xaf\xc4\xbe\xaf\xc3\xb2"         // "ｷｼﾞｭﾝｵﾌｾｯﾄｾｯﾃｲ" ("Set home offsets")
 #define MSG_HOME_OFFSETS_APPLIED            "\xb5\xcc\xbe\xaf\xc4\xb6\xde\xc3\xb7\xd6\xb3\xbb\xda\xcf\xbc\xc0" // "ｵﾌｾｯﾄｶﾞﾃｷﾖｳｻﾚﾏｼﾀ" ("Offsets applied")
 #define MSG_SET_ORIGIN                      "\xb7\xbc\xde\xad\xdd\xbe\xaf\xc4"                                 // "ｷｼﾞｭﾝｾｯﾄ" ("Set origin")
-#define MSG_PREHEAT_PLA                     "PLA \xd6\xc8\xc2"                                                 // "PLA ﾖﾈﾂ" ("Preheat PLA")
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " \xbd\xcd\xde\xc3"                                // " ｽﾍﾞﾃ" (" All")
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " \xcd\xde\xaf\xc4\xde"                            // " ﾍﾞｯﾄﾞ" (" Bed")
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " \xbe\xaf\xc3\xb2"                                // " ｾｯﾃｲ" (" conf")
-#define MSG_PREHEAT_ABS                     "ABS \xd6\xc8\xc2"                                                 // "ABS ﾖﾈﾂ" ("Preheat ABS")
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " \xbd\xcd\xde\xc3"                                // " ｽﾍﾞﾃ" (" All")
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " \xcd\xde\xaf\xc4\xde"                            // " ﾍﾞｯﾄﾞ" (" Bed")
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " \xbe\xaf\xc3\xb2"                                // " ｾｯﾃｲ" (" conf")
+#define MSG_PREHEAT_1                       "PLA \xd6\xc8\xc2"                                                 // "PLA ﾖﾈﾂ" ("Preheat PLA")
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " \xbd\xcd\xde\xc3"                                // " ｽﾍﾞﾃ" (" All")
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " \xcd\xde\xaf\xc4\xde"                            // " ﾍﾞｯﾄﾞ" (" Bed")
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " \xbe\xaf\xc3\xb2"                                // " ｾｯﾃｲ" (" conf")
+#define MSG_PREHEAT_2                       "ABS \xd6\xc8\xc2"                                                 // "ABS ﾖﾈﾂ" ("Preheat ABS")
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " \xbd\xcd\xde\xc3"                                // " ｽﾍﾞﾃ" (" All")
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " \xcd\xde\xaf\xc4\xde"                            // " ﾍﾞｯﾄﾞ" (" Bed")
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " \xbe\xaf\xc3\xb2"                                // " ｾｯﾃｲ" (" conf")
 #define MSG_COOLDOWN                        "\xb6\xc8\xc2\xc3\xb2\xbc"                                         // "ｶﾈﾂﾃｲｼ" ("Cooldown")
 #define MSG_SWITCH_PS_ON                    "\xc3\xde\xdd\xb9\xde\xdd\x20\xb5\xdd"                             // "ﾃﾞﾝｹﾞﾝ ｵﾝ" ("Switch power on")
 #define MSG_SWITCH_PS_OFF                   "\xc3\xde\xdd\xb9\xde\xdd\x20\xb5\xcc"                             // "ﾃﾞﾝｹﾞﾝ ｵﾌ" ("Switch power off")
@@ -221,8 +220,6 @@
   #define MSG_ERR_MAXTEMP_BED               "\xb4\xd7\xb0:\xcd\xde\xaf\xc4\xde\x20\xbb\xb2\xba\xb3\xb5\xdd\xc1\xae\xb3\xb6" // "ｴﾗｰ:ﾍﾞｯﾄﾞ ｻｲｺｳｵﾝﾁｮｳｶ" ("Err: MAXTEMP BED")
   #define MSG_ERR_MINTEMP_BED               "\xb4\xd7\xb0:\xcd\xde\xaf\xc4\xde\x20\xbb\xb2\xc3\xb2\xb5\xdd\xd0\xcf\xdd"     // "ｴﾗｰ:ﾍﾞｯﾄﾞ ｻｲﾃｲｵﾝﾐﾏﾝ" ("Err: MINTEMP BED")
 #endif
-#define MSG_END_HOUR                        "\xbc\xde\xb6\xdd"                                                 // "ｼﾞｶﾝ" ("hours")
-#define MSG_END_MINUTE                      "\xcc\xdd"                                                         // "ﾌﾝ" ("minutes")
 #define MSG_HEATING                         "\xb6\xc8\xc2\xc1\xad\xb3"                                         // "ｶﾈﾂﾁｭｳ" ("Heating...")
 #define MSG_HEATING_COMPLETE                "\xb6\xc8\xc2\xb6\xdd\xd8\xae\xb3"                                 // "ｶﾈﾂｶﾝﾘｮｳ" ("Heating done.")
 #define MSG_BED_HEATING                     "\xcd\xde\xaf\xc4\xde\x20\xb6\xc8\xc2\xc1\xad\xb3"                 // "ﾍﾞｯﾄﾞ ｶﾈﾂﾁｭｳ" ("Bed Heating.")
diff --git a/Marlin/language_kana_utf8.h b/Marlin/language_kana_utf8.h
index 8a35e7c..46aba87 100644
--- a/Marlin/language_kana_utf8.h
+++ b/Marlin/language_kana_utf8.h
@@ -59,16 +59,16 @@
 #define MSG_SET_HOME_OFFSETS                "キジュンオフセットセッテイ"         // "Set home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "オフセットガテキヨウサレマシタ"       // "Offsets applied"
 #define MSG_SET_ORIGIN                      "キジュンセット"                 // "Set origin"
-#define MSG_PREHEAT_PLA                     "PLA ヨネツ"                   // "Preheat PLA"
-#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "
-#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " スベテ"     // " All"
-#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " ベッド"     // " Bed"
-#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " セッテイ"    // " conf"
-#define MSG_PREHEAT_ABS                     "ABS ヨネツ"                  // "Preheat ABS"
-#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "
-#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " スベテ"     // " All"
-#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " ベッド"     // " Bed"
-#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " セッテイ"    // " conf"
+#define MSG_PREHEAT_1                       "PLA ヨネツ"                   // "Preheat PLA"
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 " "
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 " スベテ"     // " All"
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 " ベッド"     // " Bed"
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 " セッテイ"    // " conf"
+#define MSG_PREHEAT_2                       "ABS ヨネツ"                  // "Preheat ABS"
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 " "
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 " スベテ"     // " All"
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 " ベッド"     // " Bed"
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 " セッテイ"    // " conf"
 #define MSG_COOLDOWN                        "カネツテイシ"                  // "Cooldown"
 #define MSG_SWITCH_PS_ON                    "デンゲン オン"                 // "Switch power on"
 #define MSG_SWITCH_PS_OFF                   "デンゲン オフ"                 // "Switch power off"
@@ -169,8 +169,6 @@
 #define MSG_ERR_MINTEMP                     "エラー:サイテイオンミマン"          // "Err: MINTEMP"
 #define MSG_ERR_MAXTEMP_BED                 "エラー:ベッド サイコウオンチョウカ"    // "Err: MAXTEMP BED"
 #define MSG_ERR_MINTEMP_BED                 "エラー:ベッド サイテイオンミマン"     // "Err: MINTEMP BED"
-#define MSG_END_HOUR                        "ジカン"                       // "hours"
-#define MSG_END_MINUTE                      "フン"                         // "minutes"
 #define MSG_HEATING                         "カネツチュウ"                   // "Heating..."
 #define MSG_HEATING_COMPLETE                "カネツカンリョウ"                 // "Heating done."
 #define MSG_BED_HEATING                     "ベッド カネツチュウ"              // "Bed Heating."
diff --git a/Marlin/language_nl.h b/Marlin/language_nl.h
index c74ad8f..5f682bd 100644
--- a/Marlin/language_nl.h
+++ b/Marlin/language_nl.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_NL_H
 #define LANGUAGE_NL_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Zet home offsets"
 #define MSG_HOME_OFFSETS_APPLIED            "H offset toegep."
 #define MSG_SET_ORIGIN                      "Nulpunt instellen"
-#define MSG_PREHEAT_PLA                     "PLA voorverwarmen"
-#define MSG_PREHEAT_PLA_N                   "PLA voorverw. "
-#define MSG_PREHEAT_PLA_ALL                 "PLA voorverw. aan"
-#define MSG_PREHEAT_PLA_BEDONLY             "PLA voorverw. Bed"
-#define MSG_PREHEAT_PLA_SETTINGS            "PLA verw. conf"
-#define MSG_PREHEAT_ABS                     "ABS voorverwarmen"
-#define MSG_PREHEAT_ABS_N                   "ABS voorverw. "
-#define MSG_PREHEAT_ABS_ALL                 "ABS voorverw. aan"
-#define MSG_PREHEAT_ABS_BEDONLY             "ABS voorverw. Bed"
-#define MSG_PREHEAT_ABS_SETTINGS            "ABS verw. conf"
+#define MSG_PREHEAT_1                       "PLA voorverwarmen"
+#define MSG_PREHEAT_1_N                     "PLA voorverw. "
+#define MSG_PREHEAT_1_ALL                   "PLA voorverw. aan"
+#define MSG_PREHEAT_1_BEDONLY               "PLA voorverw. Bed"
+#define MSG_PREHEAT_1_SETTINGS              "PLA verw. conf"
+#define MSG_PREHEAT_2                       "ABS voorverwarmen"
+#define MSG_PREHEAT_2_N                     "ABS voorverw. "
+#define MSG_PREHEAT_2_ALL                   "ABS voorverw. aan"
+#define MSG_PREHEAT_2_BEDONLY               "ABS voorverw. Bed"
+#define MSG_PREHEAT_2_SETTINGS              "ABS verw. conf"
 #define MSG_COOLDOWN                        "Afkoelen"
 #define MSG_SWITCH_PS_ON                    "Stroom aan"
 #define MSG_SWITCH_PS_OFF                   "Stroom uit"
@@ -158,8 +157,6 @@
 #define MSG_ERR_MINTEMP                     "Err: Min. temp"
 #define MSG_ERR_MAXTEMP_BED                 "Err: Max.tmp bed"
 #define MSG_ERR_MINTEMP_BED                 "Err: Min.tmp bed"
-#define MSG_END_HOUR                        "uur"
-#define MSG_END_MINUTE                      "minuten"
 #define MSG_HEATING                         "Voorwarmen..."
 #define MSG_HEATING_COMPLETE                "Voorverw. kompl."
 #define MSG_BED_HEATING                     "Bed voorverw."
diff --git a/Marlin/language_pl.h b/Marlin/language_pl.h
index 9c38a6d..b1559c4 100644
--- a/Marlin/language_pl.h
+++ b/Marlin/language_pl.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_PL_H
 #define LANGUAGE_PL_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -51,16 +50,16 @@
 #define MSG_SET_HOME_OFFSETS                "Ust. poz. zer."
 #define MSG_HOME_OFFSETS_APPLIED            "Poz. zerowa ust."
 #define MSG_SET_ORIGIN                      "Ustaw punkt zero"
-#define MSG_PREHEAT_PLA                     "Rozgrzej PLA"
-#define MSG_PREHEAT_PLA_N                   "Rozgrzej PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Roz. PLA Wszystko"
-#define MSG_PREHEAT_PLA_BEDONLY             "Rozgrzej PLA Loze"
-#define MSG_PREHEAT_PLA_SETTINGS            "Ustaw. rozg. PLA"
-#define MSG_PREHEAT_ABS                     "Rozgrzej ABS"
-#define MSG_PREHEAT_ABS_N                   "Rozgrzej ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Roz. ABS Wszystko"
-#define MSG_PREHEAT_ABS_BEDONLY             "Rozgrzej ABS Loze"
-#define MSG_PREHEAT_ABS_SETTINGS            "Ustaw. rozg. ABS"
+#define MSG_PREHEAT_1                       "Rozgrzej PLA"
+#define MSG_PREHEAT_1_N                     "Rozgrzej PLA "
+#define MSG_PREHEAT_1_ALL                   "Roz. PLA Wszystko"
+#define MSG_PREHEAT_1_BEDONLY               "Rozgrzej PLA Loze"
+#define MSG_PREHEAT_1_SETTINGS              "Ustaw. rozg. PLA"
+#define MSG_PREHEAT_2                       "Rozgrzej ABS"
+#define MSG_PREHEAT_2_N                     "Rozgrzej ABS "
+#define MSG_PREHEAT_2_ALL                   "Roz. ABS Wszystko"
+#define MSG_PREHEAT_2_BEDONLY               "Rozgrzej ABS Loze"
+#define MSG_PREHEAT_2_SETTINGS              "Ustaw. rozg. ABS"
 #define MSG_H1                              "1"
 #define MSG_H2                              "2"
 #define MSG_H3                              "3"
@@ -181,8 +180,6 @@
 #define MSG_ERR_MINTEMP                     "Err: min. temp."
 #define MSG_ERR_MAXTEMP_BED                 "Err: max. temp. loza"
 #define MSG_ERR_MINTEMP_BED                 "Err: min. temp. loza"
-#define MSG_END_HOUR                        "godzin"
-#define MSG_END_MINUTE                      "minut"
 #define MSG_HEATING                         "Rozgrzewanie..."
 #define MSG_HEATING_COMPLETE                "Rozgrzano"
 #define MSG_BED_HEATING                     "Rozgrzewanie loza..."
diff --git a/Marlin/language_pt-br.h b/Marlin/language_pt-br.h
index cc37f31..3db6e15 100644
--- a/Marlin/language_pt-br.h
+++ b/Marlin/language_pt-br.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_PT_BR_H
 #define LANGUAGE_PT_BR_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Ajustar Jogo"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Ajustar orig."
-#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_ALL                 "Pre-aq.Todo PLA"
-#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_PLA_SETTINGS            "Ajustar PLA"
-#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_ALL                 "Pre-aq.Todo ABS"
-#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_ABS_SETTINGS            "Ajustar ABS"
+#define MSG_PREHEAT_1                       "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_N                     "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_ALL                   "Pre-aq.Todo PLA"
+#define MSG_PREHEAT_1_BEDONLY               "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_1_SETTINGS              "Ajustar PLA"
+#define MSG_PREHEAT_2                       "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_N                     "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_ALL                   "Pre-aq.Todo ABS"
+#define MSG_PREHEAT_2_BEDONLY               "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_2_SETTINGS              "Ajustar ABS"
 #define MSG_COOLDOWN                        "Esfriar"
 #define MSG_SWITCH_PS_ON                    "Ligar"
 #define MSG_SWITCH_PS_OFF                   "Desligar"
@@ -158,8 +157,6 @@
 #define MSG_ERR_MINTEMP                     "Err: T Minima"
 #define MSG_ERR_MAXTEMP_BED                 "Err: T Base Maxima"
 #define MSG_ERR_MINTEMP_BED                 "Err: T Base Minima"
-#define MSG_END_HOUR                        "Horas"
-#define MSG_END_MINUTE                      "Minutos"
 #define MSG_HEATING                         "Aquecendo..."
 #define MSG_HEATING_COMPLETE                "Aquecida."
 #define MSG_BED_HEATING                     "Aquecendo base.."
diff --git a/Marlin/language_pt-br_utf8.h b/Marlin/language_pt-br_utf8.h
index feb38b4..a556c24 100644
--- a/Marlin/language_pt-br_utf8.h
+++ b/Marlin/language_pt-br_utf8.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_PT_BR_UTF_H
 #define LANGUAGE_PT_BR_UTF_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -49,16 +48,16 @@
 #define MSG_SET_HOME_OFFSETS                "Ajustar Jogo"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Ajustar orig."
-#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_ALL                 "Pre-aq.Todo PLA"
-#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_PLA_SETTINGS            "Ajustar PLA"
-#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_ALL                 "Pre-aq.Todo ABS"
-#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_ABS_SETTINGS            "Ajustar ABS"
+#define MSG_PREHEAT_1                       "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_N                     "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_ALL                   "Pre-aq.Todo PLA"
+#define MSG_PREHEAT_1_BEDONLY               "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_1_SETTINGS              "Ajustar PLA"
+#define MSG_PREHEAT_2                       "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_N                     "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_ALL                   "Pre-aq.Todo ABS"
+#define MSG_PREHEAT_2_BEDONLY               "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_2_SETTINGS              "Ajustar ABS"
 #define MSG_COOLDOWN                        "Esfriar"
 #define MSG_SWITCH_PS_ON                    "Ligar"
 #define MSG_SWITCH_PS_OFF                   "Desligar"
@@ -158,8 +157,6 @@
 #define MSG_ERR_MINTEMP                     "Err: T Mínima"
 #define MSG_ERR_MAXTEMP_BED                 "Err: T Base Máxima"
 #define MSG_ERR_MINTEMP_BED                 "Err: T Base Mínima"
-#define MSG_END_HOUR                        "Horas"
-#define MSG_END_MINUTE                      "Minutos"
 #define MSG_HEATING                         "Aquecendo..."
 #define MSG_HEATING_COMPLETE                "Aquecida."
 #define MSG_BED_HEATING                     "Aquecendo base.."
diff --git a/Marlin/language_pt.h b/Marlin/language_pt.h
index 4c857a7..a0df879 100644
--- a/Marlin/language_pt.h
+++ b/Marlin/language_pt.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_PT_H
 #define LANGUAGE_PT_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -53,16 +52,16 @@
 #define MSG_SET_HOME_OFFSETS                "Definir desvio"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Definir origem"
-#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_ALL                 "Pre-aq. PLA Tudo"
-#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_PLA_SETTINGS            "Definicoes PLA"
-#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Pre-aq. ABS Tudo"
-#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_ABS_SETTINGS            "Definicoes ABS"
+#define MSG_PREHEAT_1                       "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_N                     "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_ALL                   "Pre-aq. PLA Tudo"
+#define MSG_PREHEAT_1_BEDONLY               "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_1_SETTINGS              "Definicoes PLA"
+#define MSG_PREHEAT_2                       "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_N                     "Pre-aquecer ABS "
+#define MSG_PREHEAT_2_ALL                   "Pre-aq. ABS Tudo"
+#define MSG_PREHEAT_2_BEDONLY               "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_2_SETTINGS              "Definicoes ABS"
 #define MSG_COOLDOWN                        "Arrefecer"
 #define MSG_SWITCH_PS_ON                    "Ligar"
 #define MSG_SWITCH_PS_OFF                   "Desligar"
@@ -166,8 +165,6 @@
 #define MSG_ERR_MINTEMP                     "Err: T Minima"
 #define MSG_ERR_MAXTEMP_BED                 "Err: T Base Maxima"
 #define MSG_ERR_MINTEMP_BED                 "Err: T Base Minima"
-#define MSG_END_HOUR                        "horas"
-#define MSG_END_MINUTE                      "minutos"
 #define MSG_HEATING                         "Aquecendo..."
 #define MSG_HEATING_COMPLETE                "Aquecida."
 #define MSG_BED_HEATING                     "Aquecendo base.."
diff --git a/Marlin/language_pt_utf8.h b/Marlin/language_pt_utf8.h
index c2fab4d..24ce828 100644
--- a/Marlin/language_pt_utf8.h
+++ b/Marlin/language_pt_utf8.h
@@ -30,7 +30,6 @@
 #ifndef LANGUAGE_PT_UTF_H
 #define LANGUAGE_PT_UTF_H
 
-#define MAPPER_NON
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
 #define DISPLAY_CHARSET_ISO10646_1
@@ -53,16 +52,16 @@
 #define MSG_SET_HOME_OFFSETS                "Definir desvio"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets aplicados"
 #define MSG_SET_ORIGIN                      "Definir origem"
-#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA"
-#define MSG_PREHEAT_PLA_ALL                 "Pre-aq. PLA Tudo"
-#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_PLA_SETTINGS            "Definições PLA"
-#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"
-#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Pre-aq. ABS Tudo"
-#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
-#define MSG_PREHEAT_ABS_SETTINGS            "Definições ABS"
+#define MSG_PREHEAT_1                       "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_N                     "Pre-aquecer PLA"
+#define MSG_PREHEAT_1_ALL                   "Pre-aq. PLA Tudo"
+#define MSG_PREHEAT_1_BEDONLY               "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_1_SETTINGS              "Definições PLA"
+#define MSG_PREHEAT_2                       "Pre-aquecer ABS"
+#define MSG_PREHEAT_2_N                     "Pre-aquecer ABS "
+#define MSG_PREHEAT_2_ALL                   "Pre-aq. ABS Tudo"
+#define MSG_PREHEAT_2_BEDONLY               "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"
+#define MSG_PREHEAT_2_SETTINGS              "Definições ABS"
 #define MSG_COOLDOWN                        "Arrefecer"
 #define MSG_SWITCH_PS_ON                    "Ligar"
 #define MSG_SWITCH_PS_OFF                   "Desligar"
@@ -166,8 +165,6 @@
 #define MSG_ERR_MINTEMP                     "Err: T Mínima"
 #define MSG_ERR_MAXTEMP_BED                 "Err: T Base Máxima"
 #define MSG_ERR_MINTEMP_BED                 "Err: T Base Mínima"
-#define MSG_END_HOUR                        "horas"
-#define MSG_END_MINUTE                      "minutos"
 #define MSG_HEATING                         "Aquecendo..."
 #define MSG_HEATING_COMPLETE                "Aquecida."
 #define MSG_BED_HEATING                     "Aquecendo base.."
diff --git a/Marlin/language_ru.h b/Marlin/language_ru.h
index 4d0f976..aa381c8 100644
--- a/Marlin/language_ru.h
+++ b/Marlin/language_ru.h
@@ -49,16 +49,16 @@
 #define MSG_SET_HOME_OFFSETS                "Запомнить парковку"
 #define MSG_HOME_OFFSETS_APPLIED            "Offsets applied"
 #define MSG_SET_ORIGIN                      "Запомнить ноль"
-#define MSG_PREHEAT_PLA                     "Преднагрев PLA"
-#define MSG_PREHEAT_PLA_N                   "Греть PLA Сопло "
-#define MSG_PREHEAT_PLA_ALL                 "Греть PLA Все"
-#define MSG_PREHEAT_PLA_BEDONLY             "Греть PLA Стол"
-#define MSG_PREHEAT_PLA_SETTINGS            "Настройки PLA"
-#define MSG_PREHEAT_ABS                     "Преднагрев ABS"
-#define MSG_PREHEAT_ABS_N                   "Греть ABS Сопло "
-#define MSG_PREHEAT_ABS_ALL                 "Греть ABS Все"
-#define MSG_PREHEAT_ABS_BEDONLY             "Греть ABS Стол"
-#define MSG_PREHEAT_ABS_SETTINGS            "Настройки ABS"
+#define MSG_PREHEAT_1                       "Преднагрев PLA"
+#define MSG_PREHEAT_1_N                     "Греть PLA Сопло "
+#define MSG_PREHEAT_1_ALL                   "Греть PLA Все"
+#define MSG_PREHEAT_1_BEDONLY               "Греть PLA Стол"
+#define MSG_PREHEAT_1_SETTINGS              "Настройки PLA"
+#define MSG_PREHEAT_2                       "Преднагрев ABS"
+#define MSG_PREHEAT_2_N                     "Греть ABS Сопло "
+#define MSG_PREHEAT_2_ALL                   "Греть ABS Все"
+#define MSG_PREHEAT_2_BEDONLY               "Греть ABS Стол"
+#define MSG_PREHEAT_2_SETTINGS              "Настройки ABS"
 #define MSG_COOLDOWN                        "Охлаждение"
 #define MSG_SWITCH_PS_ON                    "Включить Питание"
 #define MSG_SWITCH_PS_OFF                   "Отключить Питание"
@@ -156,8 +156,6 @@
 #define MSG_ERR_MINTEMP                     "Ошибка: Т мин."
 #define MSG_ERR_MAXTEMP_BED                 "Ошибка:Т макс.стол"
 #define MSG_ERR_MINTEMP_BED                 "Ошибка:Т мин.стол"
-#define MSG_END_HOUR                        "часов"
-#define MSG_END_MINUTE                      "минут"
 #define MSG_HEATING                         "Нагреваю сопло..."
 #define MSG_HEATING_COMPLETE                "Нагрев выполнен"
 #define MSG_BED_HEATING                     "Нагреваю стол"
diff --git a/Marlin/language_test.h b/Marlin/language_test.h
index 17ad7bc..99fa712 100644
--- a/Marlin/language_test.h
+++ b/Marlin/language_test.h
@@ -46,11 +46,10 @@
 //   Kanji (an other Japanese symbol set) uses far more than two codepages. So currently I don't see a chance to map the Unicodes. Its not
 //   impossible to have a close to direct mapping but will need giant conversion tables and fonts (we don't want to have in a embedded system).
 
-
-#define MAPPER_NON         // For direct ascii codes ( until now all languages except ru, de, fi, kana_utf8, ... )
 //#define MAPPER_C2C3        // For most European languages when language file is in utf8
 //#define MAPPER_D0D1        // For Cyrillic
 //#define MAPPER_E382E383    // For Katakana
+//#define MAPPER_NON         // For direct ascii codes. Fall back mapper - if no other is defined.
 
 // Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h
 //#define SIMULATE_ROMFONT
@@ -58,6 +57,7 @@
 // Select the better font for full graphic displays.
 //#define DISPLAY_CHARSET_ISO10646_1
 //#define DISPLAY_CHARSET_ISO10646_5
+//#define DISPLAY_CHARSET_ISO10646_GREEK
 //#define DISPLAY_CHARSET_ISO10646_KANA
 
 
@@ -141,8 +141,8 @@
   #define MSG_DISABLE_STEPPERS                STRG_C2_8
   #define MSG_AUTO_HOME                       STRG_C2_9
   #define MSG_SET_HOME_OFFSETS                STRG_C2_a
-  #define MSG_PREHEAT_PLA                     STRG_C2_b
-  #define MSG_PREHEAT_ABS                     STRG_C3_8
+  #define MSG_PREHEAT_1                       STRG_C2_b
+  #define MSG_PREHEAT_2                       STRG_C3_8
   #define MSG_COOLDOWN                        STRG_C3_9
   #define MSG_SWITCH_PS_OFF                   STRG_C3_a
   #define MSG_MOVE_AXIS                       STRG_C3_b
@@ -176,8 +176,8 @@
   #define MSG_DISABLE_STEPPERS                STRG_D0_8
   #define MSG_AUTO_HOME                       STRG_D0_9
   #define MSG_SET_HOME_OFFSETS                STRG_D0_a
-  #define MSG_PREHEAT_PLA                     STRG_D0_b
-  #define MSG_PREHEAT_ABS                     STRG_D1_8
+  #define MSG_PREHEAT_1                       STRG_D0_b
+  #define MSG_PREHEAT_2                       STRG_D1_8
   #define MSG_COOLDOWN                        STRG_D1_9
   #define MSG_SWITCH_PS_OFF                   STRG_D1_a
   #define MSG_MOVE_AXIS                       STRG_D1_b
@@ -211,8 +211,8 @@
   #define MSG_DISABLE_STEPPERS                STRG_E382_8
   #define MSG_AUTO_HOME                       STRG_E382_9
   #define MSG_SET_HOME_OFFSETS                STRG_E382_a
-  #define MSG_PREHEAT_PLA                     STRG_E382_b
-  #define MSG_PREHEAT_ABS                     STRG_E383_8
+  #define MSG_PREHEAT_1                       STRG_E382_b
+  #define MSG_PREHEAT_2                       STRG_E383_8
   #define MSG_COOLDOWN                        STRG_E383_9
   #define MSG_SWITCH_PS_OFF                   STRG_E383_a
   #define MSG_MOVE_AXIS                       STRG_E383_b
diff --git a/Marlin/macros.h b/Marlin/macros.h
index 2b535bb..7dbadee 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -97,6 +97,8 @@
 #define PENDING(NOW,SOON) ((long)(NOW-(SOON))<0)
 #define ELAPSED(NOW,SOON) (!PENDING(NOW,SOON))
 
-#define NOOP do{}while(0)
+#define NOOP do{} while(0)
+
+#define CEILING(x,y) (((x) + (y) - 1) / (y))
 
 #endif //__MACROS_H
diff --git a/Marlin/nozzle.h b/Marlin/nozzle.h
new file mode 100644
index 0000000..3e9ae87
--- /dev/null
+++ b/Marlin/nozzle.h
@@ -0,0 +1,195 @@
+/*
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __NOZZLE_H__
+#define __NOZZLE_H__
+
+#include "Marlin.h"
+#include "point_t.h"
+
+/**
+ * @brief Nozzle class
+ *
+ * @todo: Do not ignore the end.z value and allow XYZ movements
+ */
+class Nozzle {
+  private:
+    /**
+     * @brief Stroke clean pattern
+     * @details Wipes the nozzle back and forth in a linear movement
+     *
+     * @param start point_t defining the starting point
+     * @param end point_t defining the ending point
+     * @param strokes number of strokes to execute
+     */
+    static void stroke(
+      __attribute__((unused)) point_t const &start,
+      __attribute__((unused)) point_t const &end,
+      __attribute__((unused)) uint8_t const &strokes
+    ) __attribute__((optimize ("Os"))) {
+      #if ENABLED(NOZZLE_CLEAN_FEATURE)
+
+        #if ENABLED(NOZZLE_CLEAN_PARK)
+          // Store the current coords
+          point_t const initial = {
+            current_position[X_AXIS],
+            current_position[Y_AXIS],
+            current_position[Z_AXIS],
+            current_position[E_AXIS]
+          };
+        #endif // NOZZLE_CLEAN_PARK
+
+        // Move to the starting point
+        do_blocking_move_to_xy(start.x, start.y);
+        do_blocking_move_to_z(start.z);
+
+        // Start the stroke pattern
+        for (uint8_t i = 0; i < (strokes >>1); i++) {
+          do_blocking_move_to_xy(end.x, end.y);
+          do_blocking_move_to_xy(start.x, start.y);
+        }
+
+        #if ENABLED(NOZZLE_CLEAN_PARK)
+          // Move the nozzle to the initial point
+          do_blocking_move_to_z(initial.z);
+          do_blocking_move_to_xy(initial.x, initial.y);
+        #endif // NOZZLE_CLEAN_PARK
+
+      #endif // NOZZLE_CLEAN_FEATURE
+    }
+
+    /**
+     * @brief Zig-zag clean pattern
+     * @details Apply a zig-zag cleanning pattern
+     *
+     * @param start point_t defining the starting point
+     * @param end point_t defining the ending point
+     * @param strokes number of strokes to execute
+     * @param objects number of objects to create
+     */
+    static void zigzag(
+      __attribute__((unused)) point_t const &start,
+      __attribute__((unused)) point_t const &end,
+      __attribute__((unused)) uint8_t const &strokes,
+      __attribute__((unused)) uint8_t const &objects
+    ) __attribute__((optimize ("Os"))) {
+      #if ENABLED(NOZZLE_CLEAN_FEATURE)
+        float A = fabs(end.y - start.y); // [twice the] Amplitude
+        float P = fabs(end.x - start.x) / (objects << 1); // Period
+
+        // Don't allow impossible triangles
+        if (A <= 0.0f || P <= 0.0f ) return;
+
+        #if ENABLED(NOZZLE_CLEAN_PARK)
+          // Store the current coords
+          point_t const initial = {
+            current_position[X_AXIS],
+            current_position[Y_AXIS],
+            current_position[Z_AXIS],
+            current_position[E_AXIS]
+          };
+        #endif // NOZZLE_CLEAN_PARK
+
+        for (uint8_t j = 0; j < strokes; j++) {
+          for (uint8_t i = 0; i < (objects << 1); i++) {
+            float const x = start.x + i * P;
+            float const y = start.y + (A/P) * (P - fabs(fmod((i*P), (2*P)) - P));
+
+            do_blocking_move_to_xy(x, y);
+            if (i == 0) do_blocking_move_to_z(start.z);
+          }
+
+          for (int i = (objects << 1); i > -1; i--) {
+            float const x = start.x + i * P;
+            float const y = start.y + (A/P) * (P - fabs(fmod((i*P), (2*P)) - P));
+
+            do_blocking_move_to_xy(x, y);
+          }
+        }
+
+        #if ENABLED(NOZZLE_CLEAN_PARK)
+          // Move the nozzle to the initial point
+          do_blocking_move_to_z(initial.z);
+          do_blocking_move_to_xy(initial.x, initial.y);
+        #endif // NOZZLE_CLEAN_PARK
+
+      #endif // NOZZLE_CLEAN_FEATURE
+    }
+
+  public:
+    /**
+     * @brief Clean the nozzle
+     * @details Starts the selected clean procedure pattern
+     *
+     * @param pattern one of the available patterns
+     * @param argument depends on the cleaning pattern
+     */
+    static void clean(
+      __attribute__((unused)) uint8_t const &pattern,
+      __attribute__((unused)) uint8_t const &strokes,
+      __attribute__((unused)) uint8_t const &objects = 0
+    ) __attribute__((optimize ("Os"))) {
+      #if ENABLED(NOZZLE_CLEAN_FEATURE)
+        switch (pattern) {
+          case 1:
+            Nozzle::zigzag(
+              NOZZLE_CLEAN_START_PT,
+              NOZZLE_CLEAN_END_PT, strokes, objects);
+            break;
+
+          default:
+            Nozzle::stroke(
+              NOZZLE_CLEAN_START_PT,
+              NOZZLE_CLEAN_END_PT, strokes);
+        }
+      #endif // NOZZLE_CLEAN_FEATURE
+    }
+
+    static void park(
+      __attribute__((unused)) uint8_t const &z_action
+    ) __attribute__((optimize ("Os"))) {
+      #if ENABLED(NOZZLE_PARK_FEATURE)
+        float const z = current_position[Z_AXIS];
+        point_t const park = NOZZLE_PARK_POINT;
+
+        switch(z_action) {
+          case 1: // force Z-park height
+            do_blocking_move_to_z(park.z);
+            break;
+
+          case 2: // Raise by Z-park height
+            do_blocking_move_to_z(
+              (z + park.z > Z_MAX_POS) ? Z_MAX_POS : z + park.z);
+            break;
+
+          default: // Raise to Z-park height if lower
+            if (current_position[Z_AXIS] < park.z)
+              do_blocking_move_to_z(park.z);
+        }
+
+        do_blocking_move_to_xy(park.x, park.y);
+
+      #endif // NOZZLE_PARK_FEATURE
+    }
+};
+
+#endif
diff --git a/Marlin/pins.h b/Marlin/pins.h
index bd25121..8800845 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -31,6 +31,8 @@
   #include "pins_GEN7_13.h"
 #elif MB(GEN7_14)
   #include "pins_GEN7_14.h"
+#elif MB(CNCONTROLS_11)
+  #include "pins_CNCONTROLS_11.h"
 #elif MB(CNCONTROLS_12)
   #include "pins_CNCONTROLS_12.h"
 #elif MB(CHEAPTRONIC)
@@ -369,8 +371,8 @@
 #define __EPIN(p,q) E##p##_##q##_PIN
 #define _EPIN(p,q) __EPIN(p,q)
 
-#if ENABLED(DUAL_X_CARRIAGE)
-  // The X2 axis, if any, should be the next open extruder port
+// The X2 axis, if any, should be the next open extruder port
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
   #ifndef X2_STEP_PIN
     #define X2_STEP_PIN   _EPIN(EXTRUDERS, STEP)
     #define X2_DIR_PIN    _EPIN(EXTRUDERS, DIR)
@@ -378,25 +380,32 @@
   #endif
   #undef _X2_PINS
   #define _X2_PINS X2_STEP_PIN, X2_DIR_PIN, X2_ENABLE_PIN,
-  #define Y2_Z2_E_INDEX INCREMENT(EXTRUDERS)
+  #define Y2_E_INDEX INCREMENT(EXTRUDERS)
 #else
-  #define Y2_Z2_E_INDEX EXTRUDERS
+  #define Y2_E_INDEX EXTRUDERS
 #endif
 
 // The Y2 axis, if any, should be the next open extruder port
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS) && !defined(Y2_STEP_PIN)
-  #define Y2_STEP_PIN   _EPIN(Y2_Z2_E_INDEX, STEP)
-  #define Y2_DIR_PIN    _EPIN(Y2_Z2_E_INDEX, DIR)
-  #define Y2_ENABLE_PIN _EPIN(Y2_Z2_E_INDEX, ENABLE)
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  #ifndef Y2_STEP_PIN
+    #define Y2_STEP_PIN   _EPIN(Y2_E_INDEX, STEP)
+    #define Y2_DIR_PIN    _EPIN(Y2_E_INDEX, DIR)
+    #define Y2_ENABLE_PIN _EPIN(Y2_E_INDEX, ENABLE)
+  #endif
   #undef _Y2_PINS
   #define _Y2_PINS Y2_STEP_PIN, Y2_DIR_PIN, Y2_ENABLE_PIN,
+  #define Z2_E_INDEX INCREMENT(Y2_E_INDEX)
+#else
+  #define Z2_E_INDEX Y2_E_INDEX
 #endif
 
 // The Z2 axis, if any, should be the next open extruder port
-#if ENABLED(Z_DUAL_STEPPER_DRIVERS) && !defined(Z2_STEP_PIN)
-  #define Z2_STEP_PIN   _EPIN(Y2_Z2_E_INDEX, STEP)
-  #define Z2_DIR_PIN    _EPIN(Y2_Z2_E_INDEX, DIR)
-  #define Z2_ENABLE_PIN _EPIN(Y2_Z2_E_INDEX, ENABLE)
+#if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+  #ifndef Z2_STEP_PIN
+    #define Z2_STEP_PIN   _EPIN(Z2_E_INDEX, STEP)
+    #define Z2_DIR_PIN    _EPIN(Z2_E_INDEX, DIR)
+    #define Z2_ENABLE_PIN _EPIN(Z2_E_INDEX, ENABLE)
+  #endif
   #undef _Z2_PINS
   #define _Z2_PINS Z2_STEP_PIN, Z2_DIR_PIN, Z2_ENABLE_PIN,
 #endif
@@ -415,4 +424,3 @@
 #define HAS_DIGIPOTSS (PIN_EXISTS(DIGIPOTSS))
 
 #endif //__PINS_H
-
diff --git a/Marlin/pins_CNCONTROLS_11.h b/Marlin/pins_CNCONTROLS_11.h
new file mode 100644
index 0000000..1de35a2
--- /dev/null
+++ b/Marlin/pins_CNCONTROLS_11.h
@@ -0,0 +1,101 @@
+/**
+ * CartesioV11 pin assignments
+ */
+
+#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)
+  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+#endif
+
+#define BOARD_NAME            "CN Controls V11"
+
+//#define LARGE_FLASH true
+
+#define X_ENABLE_PIN          35
+#define X_STEP_PIN            34
+#define X_DIR_PIN             36
+#define X_MIN_PIN             43
+#define X_MAX_PIN             -1
+
+#define Y_ENABLE_PIN          38
+#define Y_STEP_PIN            37
+#define Y_DIR_PIN             39
+#define Y_MIN_PIN             45
+#define Y_MAX_PIN             -1
+
+#define Z_ENABLE_PIN          41
+#define Z_STEP_PIN            40
+#define Z_DIR_PIN             48
+#define Z_MIN_PIN             42
+#define Z_MAX_PIN             -1
+
+#define E0_ENABLE_PIN          3
+#define E0_STEP_PIN           29
+#define E0_DIR_PIN            28
+#define HEATER_0_PIN           5
+#define TEMP_0_PIN             0  // ANALOG INPUT !!
+
+#define E1_ENABLE_PIN         60
+#define E1_STEP_PIN           61
+#define E1_DIR_PIN            62
+#define HEATER_1_PIN          58
+#define TEMP_1_PIN             3  // 3 for tool2 -> 2 for chambertemp
+
+#define E2_ENABLE_PIN         16
+#define E2_STEP_PIN           15
+#define E2_DIR_PIN            14
+#define HEATER_2_PIN          64
+#define TEMP_2_PIN             2  // 9 for tool3 -> 2 for chambertemp
+
+#define E3_ENABLE_PIN         47
+#define E3_STEP_PIN           44
+#define E3_DIR_PIN            49
+#define HEATER_3_PIN          46
+#define TEMP_3_PIN            11  // 11 for tool4 -> 2 for chambertemp
+
+#define HEATER_BED_PIN         2
+#define TEMP_BED_PIN           1  // ANALOG INPUT !!
+
+// Tools
+
+//#define TOOL_0_PIN           4
+//#define TOOL_1_PIN          59
+//#define TOOL_2_PIN           8
+//#define TOOL_3_PIN          30
+//#define TOOL_PWM_PIN         7  // common PWM pin for all tools
+
+// Common I/O
+
+//#define TEMP_CHAMBER_PIN     2  // ANALOG INPUT !!
+//#define FIL_RUNOUT_PIN      -1
+//#define PWM_1_PIN           11
+//#define PWM_2_PIN           10
+//#define SPARE_IO            12
+//#define FAN_PIN              7  // common PWM pin for all tools
+
+// User interface
+#define BEEPER_PIN             6
+
+// Pins for DOGM SPI LCD Support
+#define DOGLCD_A0             26
+#define DOGLCD_CS             24
+#define DOGLCD_MOSI           -1
+#define DOGLCD_SCK            -1
+
+// The encoder and click button
+#define BTN_EN1               23
+#define BTN_EN2               25
+#define BTN_ENC               27
+
+// Hardware buttons for manual movement of XYZ
+#define SHIFT_OUT             19
+#define SHIFT_LD              18
+#define SHIFT_CLK             17
+
+//#define UI1                 31
+//#define UI2                 22
+
+// Other
+#define SDSS                  53
+#define SD_DETECT_PIN         13
+#define STAT_LED_BLUE         -1
+#define STAT_LED_RED          31
diff --git a/Marlin/pins_CNCONTROLS_12.h b/Marlin/pins_CNCONTROLS_12.h
index f1de6c1..cb33834 100644
--- a/Marlin/pins_CNCONTROLS_12.h
+++ b/Marlin/pins_CNCONTROLS_12.h
@@ -32,13 +32,13 @@
 #define E0_STEP_PIN           57
 #define E0_DIR_PIN            55
 #define HEATER_0_PIN          11
-#define TEMP_0_PIN            0   // ANALOG INPUT !!
+#define TEMP_0_PIN             0  // ANALOG INPUT !!
 
 #define E1_ENABLE_PIN         60
 #define E1_STEP_PIN           61
 #define E1_DIR_PIN            62
 #define HEATER_1_PIN           9
-#define TEMP_1_PIN             9  // 9 for tool3 -> 13 for chambertemp
+#define TEMP_1_PIN             9  // 9 for tool2 -> 13 for chambertemp
 
 #define E2_ENABLE_PIN         44
 #define E2_STEP_PIN           46
@@ -86,9 +86,9 @@
 #define LCD_SCREEN_ROT_180
 
 // The encoder and click button
-#define BTN_EN1 36
-#define BTN_EN2 34
-#define BTN_ENC 38
+#define BTN_EN1               36
+#define BTN_EN2               34
+#define BTN_ENC               38
 
 // Hardware buttons for manual movement of XYZ
 #define SHIFT_OUT             42
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index b742dfe..aacc041 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -129,18 +129,16 @@ float Planner::previous_nominal_speed;
  * Class and Instance Methods
  */
 
-Planner::Planner() {
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    bed_level_matrix.set_to_identity();
-  #endif
-  init();
-}
+Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   memset(position, 0, sizeof(position)); // clear position
   for (int i = 0; i < NUM_AXIS; i++) previous_speed[i] = 0.0;
   previous_nominal_speed = 0.0;
+  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    bed_level_matrix.set_to_identity();
+  #endif
 }
 
 /**
@@ -397,8 +395,12 @@ void Planner::check_axes_activity() {
   #endif
 
   #if ENABLED(BARICUDA)
-    unsigned char tail_valve_pressure = baricuda_valve_pressure,
-                  tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+    #if HAS_HEATER_1
+      unsigned char tail_valve_pressure = baricuda_valve_pressure;
+    #endif
+    #if HAS_HEATER_2
+      unsigned char tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+    #endif
   #endif
 
   if (blocks_queued()) {
@@ -411,8 +413,12 @@ void Planner::check_axes_activity() {
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
-      tail_valve_pressure = block->valve_pressure;
-      tail_e_to_p_pressure = block->e_to_p_pressure;
+      #if HAS_HEATER_1
+        tail_valve_pressure = block->valve_pressure;
+      #endif
+      #if HAS_HEATER_2
+        tail_e_to_p_pressure = block->e_to_p_pressure;
+      #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
diff --git a/Marlin/point_t.h b/Marlin/point_t.h
new file mode 100644
index 0000000..dbad668
--- /dev/null
+++ b/Marlin/point_t.h
@@ -0,0 +1,46 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __POINT_T__
+#define __POINT_T__
+
+struct point_t {
+  float x;
+  float y;
+  float z;
+  float e;
+
+  point_t(float const x, float const y)
+    : point_t(x, y, NAN, NAN) {}
+
+  point_t(float const x, float const y, float const z)
+    : point_t(x, y, z, NAN) {}
+
+  point_t(float const x, float const y, float const z, float const e) {
+    this->x = x;
+    this->y = y;
+    this->z = z;
+    this->e = e;
+  }
+};
+
+#endif
diff --git a/Marlin/printcounter.cpp b/Marlin/printcounter.cpp
index 78e3630..489503c 100644
--- a/Marlin/printcounter.cpp
+++ b/Marlin/printcounter.cpp
@@ -27,12 +27,12 @@ PrintCounter::PrintCounter(): super() {
   this->loadStats();
 }
 
-uint16_t PrintCounter::deltaDuration() {
+millis_t PrintCounter::deltaDuration() {
   #if ENABLED(DEBUG_PRINTCOUNTER)
     PrintCounter::debug(PSTR("deltaDuration"));
   #endif
 
-  uint16_t tmp = this->lastDuration;
+  millis_t tmp = this->lastDuration;
   this->lastDuration = this->duration();
   return this->lastDuration - tmp;
 }
@@ -41,13 +41,25 @@ bool PrintCounter::isLoaded() {
   return this->loaded;
 }
 
+void PrintCounter::incFilamentUsed(double const &amount) {
+  #if ENABLED(DEBUG_PRINTCOUNTER)
+    PrintCounter::debug(PSTR("incFilamentUsed"));
+  #endif
+
+  // Refuses to update data if object is not loaded
+  if (!this->isLoaded()) return;
+
+  this->data.filamentUsed += amount; // mm
+}
+
+
 void PrintCounter::initStats() {
   #if ENABLED(DEBUG_PRINTCOUNTER)
     PrintCounter::debug(PSTR("initStats"));
   #endif
 
   this->loaded = true;
-  this->data = { 0, 0, 0, 0 };
+  this->data = { 0, 0, 0, 0, 0.0 };
 
   this->saveStats();
   eeprom_write_byte((uint8_t *) this->address, 0x16);
@@ -60,7 +72,8 @@ void PrintCounter::loadStats() {
 
   // Checks if the EEPROM block is initialized
   if (eeprom_read_byte((uint8_t *) this->address) != 0x16) this->initStats();
-  else eeprom_read_block(&this->data, (void *)(this->address + sizeof(uint8_t)), sizeof(printStatistics));
+  else eeprom_read_block(&this->data,
+    (void *)(this->address + sizeof(uint8_t)), sizeof(printStatistics));
 
   this->loaded = true;
 }
@@ -70,31 +83,40 @@ void PrintCounter::saveStats() {
     PrintCounter::debug(PSTR("saveStats"));
   #endif
 
-  // Refuses to save data is object is not loaded
+  // Refuses to save data if object is not loaded
   if (!this->isLoaded()) return;
 
   // Saves the struct to EEPROM
-  eeprom_update_block(&this->data, (void *)(this->address + sizeof(uint8_t)), sizeof(printStatistics));
+  eeprom_update_block(&this->data,
+    (void *)(this->address + sizeof(uint8_t)), sizeof(printStatistics));
 }
 
 void PrintCounter::showStats() {
-  SERIAL_ECHOPGM("Print statistics: Total: ");
+  SERIAL_PROTOCOLPGM(MSG_STATS);
+
+  SERIAL_ECHOPGM("Prints: ");
   SERIAL_ECHO(this->data.totalPrints);
 
   SERIAL_ECHOPGM(", Finished: ");
   SERIAL_ECHO(this->data.finishedPrints);
 
-  SERIAL_ECHOPGM(", Failed: ");
+  SERIAL_ECHOPGM(", Failed: "); // Note: Removes 1 from failures with an active counter
   SERIAL_ECHO(this->data.totalPrints - this->data.finishedPrints
-    - ((this->isRunning() || this->isPaused()) ? 1 : 0)); // Removes 1 from failures with an active counter
+    - ((this->isRunning() || this->isPaused()) ? 1 : 0));
+
+  SERIAL_EOL;
+  SERIAL_PROTOCOLPGM(MSG_STATS);
 
   uint32_t t = this->data.printTime / 60;
-  SERIAL_ECHOPGM(", Total print time: ");
-  SERIAL_ECHO(t / 60);
+  SERIAL_ECHOPGM("Total time: ");
+
+  SERIAL_ECHO(t / 60 / 24);
+  SERIAL_ECHOPGM("d ");
 
+  SERIAL_ECHO((t / 60) % 24);
   SERIAL_ECHOPGM("h ");
-  SERIAL_ECHO(t % 60);
 
+  SERIAL_ECHO(t % 60);
   SERIAL_ECHOPGM("min");
 
   #if ENABLED(DEBUG_PRINTCOUNTER)
@@ -103,35 +125,58 @@ void PrintCounter::showStats() {
     SERIAL_ECHOPGM(")");
   #endif
 
-  // @todo longestPrint missing implementation
+  uint32_t l = this->data.longestPrint / 60;
+  SERIAL_ECHOPGM(", Longest job: ");
+
+  SERIAL_ECHO(l / 60 / 24);
+  SERIAL_ECHOPGM("d ");
+
+  SERIAL_ECHO((l / 60) % 24);
+  SERIAL_ECHOPGM("h ");
+
+  SERIAL_ECHO(l % 60);
+  SERIAL_ECHOPGM("min");
+
+  #if ENABLED(DEBUG_PRINTCOUNTER)
+    SERIAL_ECHOPGM(" (");
+    SERIAL_ECHO(this->data.longestPrint);
+    SERIAL_ECHOPGM(")");
+  #endif
+
+  SERIAL_EOL;
+  SERIAL_PROTOCOLPGM(MSG_STATS);
+
+  SERIAL_ECHOPGM("Filament used: ");
+  SERIAL_ECHO(this->data.filamentUsed / 1000);
+  SERIAL_ECHOPGM("m");
+
   SERIAL_EOL;
 }
 
 void PrintCounter::tick() {
   if (!this->isRunning()) return;
 
-  static uint32_t update_before = millis(),
-                  eeprom_before = millis();
+  static uint32_t update_last = millis(),
+                  eeprom_last = millis();
 
-  uint32_t now = millis();
+  millis_t now = millis();
 
   // Trying to get the amount of calculations down to the bare min
   const static uint16_t i = this->updateInterval * 1000;
 
-  if (now - update_before >= i) {
+  if (now - update_last >= i) {
     #if ENABLED(DEBUG_PRINTCOUNTER)
       PrintCounter::debug(PSTR("tick"));
     #endif
 
     this->data.printTime += this->deltaDuration();
-    update_before = now;
+    update_last = now;
   }
 
   // Trying to get the amount of calculations down to the bare min
-  const static uint32_t j = this->saveInterval * 1000;
-
-  if (now - eeprom_before >= j) {
-    eeprom_before = now;
+  const static millis_t j = this->saveInterval * 1000;
+  if (now - eeprom_last >= j) {
+    eeprom_last = now;
     this->saveStats();
   }
 }
@@ -163,6 +208,10 @@ bool PrintCounter::stop() {
   if (super::stop()) {
     this->data.finishedPrints++;
     this->data.printTime += this->deltaDuration();
+
+    if (this->duration() > this->data.longestPrint)
+      this->data.longestPrint = this->duration();
+
     this->saveStats();
     return true;
   }
diff --git a/Marlin/printcounter.h b/Marlin/printcounter.h
index d6ac80b..0e9d06f 100644
--- a/Marlin/printcounter.h
+++ b/Marlin/printcounter.h
@@ -24,6 +24,7 @@
 #define PRINTCOUNTER_H
 
 #include "macros.h"
+#include "language.h"
 #include "stopwatch.h"
 #include <avr/eeprom.h>
 
@@ -35,8 +36,9 @@ struct printStatistics {    // 13 bytes
   //const uint8_t magic;    // Magic header, it will always be 0x16
   uint16_t totalPrints;     // Number of prints
   uint16_t finishedPrints;  // Number of complete prints
-  uint32_t printTime;       // Total printing time
-  uint32_t longestPrint;    // Longest print job - not in use
+  uint32_t printTime;       // Accumulated printing time
+  uint32_t longestPrint;    // Longest successfull print job
+  double   filamentUsed;    // Accumulated filament consumed in mm
 };
 
 class PrintCounter: public Stopwatch {
@@ -74,7 +76,7 @@ class PrintCounter: public Stopwatch {
      * @details Stores the timestamp of the last deltaDuration(), this is
      * required due to the updateInterval cycle.
      */
-    uint16_t lastDuration;
+    millis_t lastDuration;
 
     /**
      * @brief Stats were loaded from EERPROM
@@ -90,7 +92,7 @@ class PrintCounter: public Stopwatch {
      * used internally for print statistics accounting is not intended to be a
      * user callable function.
      */
-    uint16_t deltaDuration();
+    millis_t deltaDuration();
 
   public:
     /**
@@ -106,6 +108,14 @@ class PrintCounter: public Stopwatch {
     bool isLoaded();
 
     /**
+     * @brief Increments the total filament used
+     * @details The total filament used counter will be incremented by "amount".
+     *
+     * @param amount The amount of filament used in mm
+     */
+    void incFilamentUsed(double const &amount);
+
+    /**
      * @brief Resets the Print Statistics
      * @details Resets the statistics to zero and saves them to EEPROM creating
      * also the magic header.
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 300bd28..57fa3b5 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -120,7 +120,10 @@ unsigned short Stepper::OCR1A_nominal;
 
 volatile long Stepper::endstops_trigsteps[3];
 
-#if ENABLED(DUAL_X_CARRIAGE)
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
+  #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
+#elif ENABLED(DUAL_X_CARRIAGE)
   #define X_APPLY_DIR(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
       X_DIR_WRITE(v); \
@@ -143,15 +146,15 @@ volatile long Stepper::endstops_trigsteps[3];
 #endif
 
 #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  #define Y_APPLY_DIR(v,Q) { Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }
-  #define Y_APPLY_STEP(v,Q) { Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }
+  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
+  #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
 #else
   #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
 #endif
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
-  #define Z_APPLY_DIR(v,Q) { Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
   #if ENABLED(Z_DUAL_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) \
     if (performing_homing) { \
@@ -169,7 +172,7 @@ volatile long Stepper::endstops_trigsteps[3];
       Z2_STEP_WRITE(v); \
     }
   #else
-    #define Z_APPLY_STEP(v,Q) { Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }
+    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
   #endif
 #else
   #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
@@ -669,14 +672,15 @@ void Stepper::init() {
 
   // Initialize Step Pins
   #if HAS_X_STEP
-    AXIS_INIT(x, X, X);
-    #if ENABLED(DUAL_X_CARRIAGE) && HAS_X2_STEP
-      AXIS_INIT(x, X2, X);
+    #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
+      X2_STEP_INIT;
+      X2_STEP_WRITE(INVERT_X_STEP_PIN);
     #endif
+    AXIS_INIT(x, X, X);
   #endif
 
   #if HAS_Y_STEP
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_STEP
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
       Y2_STEP_INIT;
       Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
     #endif
@@ -684,7 +688,7 @@ void Stepper::init() {
   #endif
 
   #if HAS_Z_STEP
-    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_STEP
+    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
       Z2_STEP_INIT;
       Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
diff --git a/Marlin/stepper_indirection.h b/Marlin/stepper_indirection.h
index 24e4c7c..56c1506 100644
--- a/Marlin/stepper_indirection.h
+++ b/Marlin/stepper_indirection.h
@@ -60,7 +60,7 @@
 #define X_ENABLE_READ READ(X_ENABLE_PIN)
 
 // X2 motor
-#if ENABLED(DUAL_X_CARRIAGE)
+#if HAS_X2_ENABLE
   #define X2_STEP_INIT SET_OUTPUT(X2_STEP_PIN)
   #define X2_STEP_WRITE(STATE) WRITE(X2_STEP_PIN,STATE)
   #define X2_STEP_READ READ(X2_STEP_PIN)
@@ -88,7 +88,7 @@
 #define Y_ENABLE_READ READ(Y_ENABLE_PIN)
 
 // Y2 motor
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+#if HAS_Y2_ENABLE
   #define Y2_STEP_INIT SET_OUTPUT(Y2_STEP_PIN)
   #define Y2_STEP_WRITE(STATE) WRITE(Y2_STEP_PIN,STATE)
   #define Y2_STEP_READ READ(Y2_STEP_PIN)
@@ -116,7 +116,7 @@
 #define Z_ENABLE_READ READ(Z_ENABLE_PIN)
 
 // Z2 motor
-#if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+#if HAS_Z2_ENABLE
   #define Z2_STEP_INIT SET_OUTPUT(Z2_STEP_PIN)
   #define Z2_STEP_WRITE(STATE) WRITE(Z2_STEP_PIN,STATE)
   #define Z2_STEP_READ READ(Z2_STEP_PIN)
diff --git a/Marlin/stopwatch.cpp b/Marlin/stopwatch.cpp
index 7a9e90d..042dbfc 100644
--- a/Marlin/stopwatch.cpp
+++ b/Marlin/stopwatch.cpp
@@ -88,9 +88,9 @@ bool Stopwatch::isPaused() {
   return (this->state == STOPWATCH_PAUSED) ? true : false;
 }
 
-uint16_t Stopwatch::duration() {
+millis_t Stopwatch::duration() {
   return (((this->isRunning()) ? millis() : this->stopTimestamp)
-          - this->startTimestamp) / 1000 + this->accumulator;
+          - this->startTimestamp) / 1000UL + this->accumulator;
 }
 
 #if ENABLED(DEBUG_STOPWATCH)
diff --git a/Marlin/stopwatch.h b/Marlin/stopwatch.h
index f5ce233..173b5ef 100644
--- a/Marlin/stopwatch.h
+++ b/Marlin/stopwatch.h
@@ -42,9 +42,9 @@ enum StopwatchState {
 class Stopwatch {
   private:
     StopwatchState state;
-    uint16_t accumulator;
-    uint32_t startTimestamp;
-    uint32_t stopTimestamp;
+    millis_t accumulator;
+    millis_t startTimestamp;
+    millis_t stopTimestamp;
 
   public:
     /**
@@ -101,7 +101,7 @@ class Stopwatch {
      * @details Returns the total number of seconds the timer has been running.
      * @return the delta since starting the stopwatch
      */
-    uint16_t duration();
+    millis_t duration();
 
     #if ENABLED(DEBUG_STOPWATCH)
 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 1aff9b3..beb4f63 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -50,13 +50,12 @@ Temperature thermalManager;
 
 // public:
 
-int Temperature::current_temperature_raw[HOTENDS] = { 0 };
-float Temperature::current_temperature[HOTENDS] = { 0.0 };
-int Temperature::target_temperature[HOTENDS] = { 0 };
-
-int Temperature::current_temperature_bed_raw = 0;
-float Temperature::current_temperature_bed = 0.0;
-int Temperature::target_temperature_bed = 0;
+float Temperature::current_temperature[HOTENDS] = { 0.0 },
+      Temperature::current_temperature_bed = 0.0;
+int   Temperature::current_temperature_raw[HOTENDS] = { 0 },
+      Temperature::target_temperature[HOTENDS] = { 0 },
+      Temperature::current_temperature_bed_raw = 0,
+      Temperature::target_temperature_bed = 0;
 
 #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   float Temperature::redundant_temperature = 0.0;
@@ -69,7 +68,7 @@ unsigned char Temperature::soft_pwm_bed;
 #endif
 
 #if ENABLED(PIDTEMP)
-  #if ENABLED(PID_PARAMS_PER_HOTEND)
+  #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     float Temperature::Kp[HOTENDS] = ARRAY_BY_HOTENDS1(DEFAULT_Kp),
           Temperature::Ki[HOTENDS] = ARRAY_BY_HOTENDS1((DEFAULT_Ki) * (PID_dT)),
           Temperature::Kd[HOTENDS] = ARRAY_BY_HOTENDS1((DEFAULT_Kd) / (PID_dT));
@@ -107,6 +106,7 @@ unsigned char Temperature::soft_pwm_bed;
 #endif
 
 #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
+  bool Temperature::allow_cold_extrude = false;
   float Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
 #endif
 
@@ -120,34 +120,34 @@ unsigned char Temperature::soft_pwm_bed;
 volatile bool Temperature::temp_meas_ready = false;
 
 #if ENABLED(PIDTEMP)
-  float Temperature::temp_iState[HOTENDS] = { 0 };
-  float Temperature::temp_dState[HOTENDS] = { 0 };
-  float Temperature::pTerm[HOTENDS];
-  float Temperature::iTerm[HOTENDS];
-  float Temperature::dTerm[HOTENDS];
+  float Temperature::temp_iState[HOTENDS] = { 0 },
+        Temperature::temp_dState[HOTENDS] = { 0 },
+        Temperature::pTerm[HOTENDS],
+        Temperature::iTerm[HOTENDS],
+        Temperature::dTerm[HOTENDS];
 
   #if ENABLED(PID_ADD_EXTRUSION_RATE)
     float Temperature::cTerm[HOTENDS];
-    long Temperature::last_position[HOTENDS];
+    long Temperature::last_e_position;
     long Temperature::lpq[LPQ_MAX_LEN];
     int Temperature::lpq_ptr = 0;
   #endif
 
-  float Temperature::pid_error[HOTENDS];
-  float Temperature::temp_iState_min[HOTENDS];
-  float Temperature::temp_iState_max[HOTENDS];
+  float Temperature::pid_error[HOTENDS],
+        Temperature::temp_iState_min[HOTENDS],
+        Temperature::temp_iState_max[HOTENDS];
   bool Temperature::pid_reset[HOTENDS];
 #endif
 
 #if ENABLED(PIDTEMPBED)
-  float Temperature::temp_iState_bed = { 0 };
-  float Temperature::temp_dState_bed = { 0 };
-  float Temperature::pTerm_bed;
-  float Temperature::iTerm_bed;
-  float Temperature::dTerm_bed;
-  float Temperature::pid_error_bed;
-  float Temperature::temp_iState_min_bed;
-  float Temperature::temp_iState_max_bed;
+  float Temperature::temp_iState_bed = { 0 },
+        Temperature::temp_dState_bed = { 0 },
+        Temperature::pTerm_bed,
+        Temperature::iTerm_bed,
+        Temperature::dTerm_bed,
+        Temperature::pid_error_bed,
+        Temperature::temp_iState_min_bed,
+        Temperature::temp_iState_max_bed;
 #else
   millis_t Temperature::next_bed_check_ms;
 #endif
@@ -156,10 +156,10 @@ unsigned long Temperature::raw_temp_value[4] = { 0 };
 unsigned long Temperature::raw_temp_bed_value = 0;
 
 // Init min and max temp with extreme values to prevent false errors during startup
-int Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP);
-int Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP);
-int Temperature::minttemp[HOTENDS] = { 0 };
-int Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
+int Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP),
+    Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP),
+    Temperature::minttemp[HOTENDS] = { 0 },
+    Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
 
 #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   int Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
@@ -444,11 +444,11 @@ Temperature::Temperature() { }
 
 void Temperature::updatePID() {
   #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_ADD_EXTRUSION_RATE)
+      last_e_position = 0;
+    #endif
     HOTEND_LOOP() {
       temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
-      #if ENABLED(PID_ADD_EXTRUSION_RATE)
-        last_position[e] = 0;
-      #endif
     }
   #endif
   #if ENABLED(PIDTEMPBED)
@@ -531,10 +531,8 @@ float Temperature::get_pid_output(int e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
-    #define _HOTEND_EXTRUDER active_extruder
   #else
     #define _HOTEND_TEST     e == active_extruder
-    #define _HOTEND_EXTRUDER e
   #endif
   float pid_output;
   #if ENABLED(PIDTEMP)
@@ -566,14 +564,14 @@ float Temperature::get_pid_output(int e) {
           cTerm[HOTEND_INDEX] = 0;
           if (_HOTEND_TEST) {
             long e_position = stepper.position(E_AXIS);
-            if (e_position > last_position[_HOTEND_EXTRUDER]) {
-              lpq[lpq_ptr++] = e_position - last_position[_HOTEND_EXTRUDER];
-              last_position[_HOTEND_EXTRUDER] = e_position;
+            if (e_position > last_e_position) {
+              lpq[lpq_ptr] = e_position - last_e_position;
+              last_e_position = e_position;
             }
             else {
-              lpq[lpq_ptr++] = 0;
+              lpq[lpq_ptr] = 0;
             }
-            if (lpq_ptr >= lpq_len) lpq_ptr = 0;
+            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] / planner.axis_steps_per_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
             pid_output += cTerm[HOTEND_INDEX];
           }
@@ -952,7 +950,7 @@ void Temperature::init() {
       temp_iState_min[e] = 0.0;
       temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
       #if ENABLED(PID_ADD_EXTRUSION_RATE)
-        last_position[e] = 0;
+        last_e_position = 0;
       #endif
     #endif //PIDTEMP
     #if ENABLED(PIDTEMPBED)
@@ -961,6 +959,10 @@ void Temperature::init() {
     #endif //PIDTEMPBED
   }
 
+  #if ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE)
+    last_e_position = 0;
+  #endif
+
   #if HAS_HEATER_0
     SET_OUTPUT(HEATER_0_PIN);
   #endif
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index dbb4343..8fab0db 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -52,13 +52,12 @@ class Temperature {
 
   public:
 
-    static int current_temperature_raw[HOTENDS];
-    static float current_temperature[HOTENDS];
-    static int target_temperature[HOTENDS];
-
-    static int current_temperature_bed_raw;
-    static float current_temperature_bed;
-    static int target_temperature_bed;
+    static float current_temperature[HOTENDS],
+                 current_temperature_bed;
+    static int   current_temperature_raw[HOTENDS],
+                 target_temperature[HOTENDS],
+                 current_temperature_bed_raw,
+                 target_temperature_bed;
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static float redundant_temperature;
@@ -76,13 +75,13 @@ class Temperature {
 
     #if ENABLED(PIDTEMP)
 
-      #if ENABLED(PID_PARAMS_PER_HOTEND)
+      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
 
         static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
           static float Kc[HOTENDS];
         #endif
-        #define PID_PARAM(param, e) Temperature::param[e]
+        #define PID_PARAM(param, h) Temperature::param[h]
 
       #else
 
@@ -90,7 +89,7 @@ class Temperature {
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
           static float Kc;
         #endif
-        #define PID_PARAM(param, e) Temperature::param
+        #define PID_PARAM(param, h) Temperature::param
 
       #endif // PID_PARAMS_PER_HOTEND
 
@@ -121,12 +120,13 @@ class Temperature {
     #endif
 
     #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
+      static bool allow_cold_extrude;
       static float extrude_min_temp;
       static bool tooColdToExtrude(uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
-        return degHotend(HOTEND_INDEX) < extrude_min_temp;
+        return allow_cold_extrude ? false : degHotend(HOTEND_INDEX) < extrude_min_temp;
       }
     #else
       static bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
@@ -142,46 +142,46 @@ class Temperature {
     static volatile bool temp_meas_ready;
 
     #if ENABLED(PIDTEMP)
-      static float temp_iState[HOTENDS];
-      static float temp_dState[HOTENDS];
-      static float pTerm[HOTENDS];
-      static float iTerm[HOTENDS];
-      static float dTerm[HOTENDS];
+      static float temp_iState[HOTENDS],
+                   temp_dState[HOTENDS],
+                   pTerm[HOTENDS],
+                   iTerm[HOTENDS],
+                   dTerm[HOTENDS];
 
       #if ENABLED(PID_ADD_EXTRUSION_RATE)
         static float cTerm[HOTENDS];
-        static long last_position[HOTENDS];
+        static long last_e_position;
         static long lpq[LPQ_MAX_LEN];
         static int lpq_ptr;
       #endif
 
-      static float pid_error[HOTENDS];
-      static float temp_iState_min[HOTENDS];
-      static float temp_iState_max[HOTENDS];
+      static float pid_error[HOTENDS],
+                   temp_iState_min[HOTENDS],
+                   temp_iState_max[HOTENDS];
       static bool pid_reset[HOTENDS];
     #endif
 
     #if ENABLED(PIDTEMPBED)
-      static float temp_iState_bed;
-      static float temp_dState_bed;
-      static float pTerm_bed;
-      static float iTerm_bed;
-      static float dTerm_bed;
-      static float pid_error_bed;
-      static float temp_iState_min_bed;
-      static float temp_iState_max_bed;
+      static float temp_iState_bed,
+                   temp_dState_bed,
+                   pTerm_bed,
+                   iTerm_bed,
+                   dTerm_bed,
+                   pid_error_bed,
+                   temp_iState_min_bed,
+                   temp_iState_max_bed;
     #else
       static millis_t next_bed_check_ms;
     #endif
 
-    static unsigned long raw_temp_value[4];
-    static unsigned long raw_temp_bed_value;
+    static unsigned long raw_temp_value[4],
+                         raw_temp_bed_value;
 
     // Init min and max temp with extreme values to prevent false errors during startup
-    static int minttemp_raw[HOTENDS];
-    static int maxttemp_raw[HOTENDS];
-    static int minttemp[HOTENDS];
-    static int maxttemp[HOTENDS];
+    static int minttemp_raw[HOTENDS],
+               maxttemp_raw[HOTENDS],
+               minttemp[HOTENDS],
+               maxttemp[HOTENDS];
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static int consecutive_low_temperature_error[HOTENDS];
@@ -247,11 +247,24 @@ class Temperature {
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
-      static bool is_preheating(uint8_t hotend) {
-        return preheat_end_time[hotend] && PENDING(millis(), preheat_end_time[hotend]);
+      static bool is_preheating(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
+      }
+      static void start_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
+      }
+      static void reset_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = 0;
       }
-      static void start_preheat_time(uint8_t hotend) { preheat_end_time[hotend] = millis() + MILLISECONDS_PREHEAT_TIME; }
-      static void reset_preheat_time(uint8_t hotend) { preheat_end_time[hotend] = 0; }
     #else
       #define is_preheating(n) (false)
     #endif
@@ -306,9 +319,9 @@ class Temperature {
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0.0f)
-          reset_preheat_time(hotend);
-        else if (target_temperature[hotend] == 0.0f)
-          start_preheat_time(hotend);
+          reset_preheat_time(HOTEND_INDEX);
+        else if (target_temperature[HOTEND_INDEX] == 0.0f)
+          start_preheat_time(HOTEND_INDEX);
       #endif
       target_temperature[HOTEND_INDEX] = celsius;
       #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index f7c3b1d..5437248 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -33,13 +33,8 @@
   #include "printcounter.h"
 #endif
 
-int plaPreheatHotendTemp;
-int plaPreheatHPBTemp;
-int plaPreheatFanSpeed;
-
-int absPreheatHotendTemp;
-int absPreheatHPBTemp;
-int absPreheatFanSpeed;
+int preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1,
+    preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2;
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   millis_t previous_lcd_status_ms = 0;
@@ -218,30 +213,31 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
    * START_SCREEN generates the init code for a screen function
    *
    *   encoderLine is the position based on the encoder
-   *   currentMenuViewOffset is the top menu line to display
-   *   _drawLineNr is the index of the LCD line (0-3)
-   *   _lineNr is the menu item to draw and process
-   *   _menuItemNr is the index of each MENU_ITEM
+   *   encoderTopLine is the top menu line to display
+   *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
+   *   _menuLineNr is the menu item to draw and process
+   *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
    */
-  #define _START_SCREEN(CODE) do { \
+  #define _START_SCREEN(CODE, SKIP) \
     ENCODER_DIRECTION_MENUS(); \
     encoderRateMultiplierEnabled = false; \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
-    uint8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
-    NOMORE(currentMenuViewOffset, encoderLine); \
-    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
+    int8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
+    NOMORE(encoderTopLine, encoderLine); \
+    int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
+    bool _skipStatic = SKIP; \
     CODE; \
-    for (uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
-      _menuItemNr = 0;
+    for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT; _lcdLineNr++, _menuLineNr++) { \
+      _thisItemNr = 0;
 
-  #define START_SCREEN() _START_SCREEN(0)
+  #define START_SCREEN() _START_SCREEN(NOOP, false)
 
   /**
    * START_MENU generates the init code for a menu function
    *
    *   wasClicked indicates the controller was clicked
    */
-  #define START_MENU() _START_SCREEN(bool wasClicked = LCD_CLICKED)
+  #define START_MENU() _START_SCREEN(bool wasClicked = LCD_CLICKED, true)
 
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
@@ -264,49 +260,73 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
    *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
    *
    */
-  #define _MENU_ITEM_PART_1(type, label, args...) \
-    if (_menuItemNr == _lineNr) { \
+  #define _MENU_ITEM_PART_1(TYPE, LABEL, ARGS...) \
+    if (_menuLineNr == _thisItemNr) { \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_ ## type(encoderLine == _menuItemNr, _drawLineNr, PSTR(label), ## args); \
-      if (wasClicked && encoderLine == _menuItemNr) { \
+        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## ARGS); \
+      if (wasClicked && encoderLine == _thisItemNr) { \
         lcd_quick_feedback()
 
-  #define _MENU_ITEM_PART_2(type, args...) \
-        menu_action_ ## type(args); \
+  #define _MENU_ITEM_PART_2(TYPE, ARGS...) \
+        menu_action_ ## TYPE(ARGS); \
         return; \
       } \
     } \
-    _menuItemNr++
+    _thisItemNr++
 
-  #define MENU_ITEM(type, label, args...) do { \
-      _MENU_ITEM_PART_1(type, label, ## args); \
-      _MENU_ITEM_PART_2(type, ## args); \
+  #define MENU_ITEM(TYPE, LABEL, ARGS...) do { \
+      _skipStatic = false; \
+      _MENU_ITEM_PART_1(TYPE, LABEL, ## ARGS); \
+      _MENU_ITEM_PART_2(TYPE, ## ARGS); \
     } while(0)
 
   // Used to print static text with no visible cursor.
-  #define STATIC_ITEM(label, args...) \
-    if (_menuItemNr == _lineNr) { \
-      if (encoderLine == _menuItemNr && _menuItemNr < LCD_HEIGHT - 1) \
+  #define STATIC_ITEM(LABEL, ARGS...) \
+    if (_menuLineNr == _thisItemNr) { \
+      if (_skipStatic && encoderLine <= _thisItemNr) { \
         encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
+      } \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_static(_drawLineNr, PSTR(label), ## args); \
+        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## ARGS); \
     } \
-    _menuItemNr++
+    _thisItemNr++
+
+  /**
+   *
+   * END_SCREEN  Closing code for a screen having only static items.
+   *             Do simplified scrolling of the entire screen.
+   *
+   * END_MENU    Closing code for a screen with menu items.
+   *             Scroll as-needed to keep the selected line in view.
+   *
+   * At this point _thisItemNr equals the total number of items.
+   * 
+   */
 
+  // Simple-scroll by using encoderLine as encoderTopLine
   #define END_SCREEN() \
-      if (encoderLine >= _menuItemNr) { \
-        encoderPosition = _menuItemNr * (ENCODER_STEPS_PER_MENU_ITEM) - 1; \
-        encoderLine = _menuItemNr - 1; \
-      } \
-      if (encoderLine >= currentMenuViewOffset + LCD_HEIGHT) { \
-        currentMenuViewOffset = encoderLine - (LCD_HEIGHT) + 1; \
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-        _lineNr = currentMenuViewOffset - 1; \
-        _drawLineNr = -1; \
-      } \
-    } } while(0)
+    } \
+    NOMORE(encoderLine, _thisItemNr - LCD_HEIGHT); \
+    NOLESS(encoderLine, 0); \
+    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    if (encoderTopLine != encoderLine) { \
+      encoderTopLine = encoderLine; \
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
+    }
 
-  #define END_MENU() END_SCREEN()
+  // Scroll through menu items, scrolling as-needed to stay in view
+  #define END_MENU() \
+    } \
+    if (encoderLine >= _thisItemNr) { \
+      encoderLine = _thisItemNr - 1; \
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    } \
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
+      encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
+    } \
+    UNUSED(_skipStatic)
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
@@ -324,7 +344,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
 
   #endif //ENCODER_RATE_MULTIPLIER
 
-  #define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)
+  #define MENU_ITEM_DUMMY() do { _thisItemNr++; } while(0)
   #define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)
   #define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
@@ -344,7 +364,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
     volatile uint8_t slow_buttons; // Bits of the pressed buttons.
   #endif
-  uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */
+  int8_t encoderTopLine;              /* scroll offset in the current menu */
   millis_t next_button_update_ms;
   uint8_t lastEncoderBits;
   uint32_t encoderPosition;
@@ -380,10 +400,8 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
     if (currentScreen != screen) {
       currentScreen = screen;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-      #if ENABLED(NEWPANEL)
-        encoderPosition = encoder;
-        if (feedback) lcd_quick_feedback();
-      #endif
+      encoderPosition = encoder;
+      if (feedback) lcd_quick_feedback();
       if (screen == lcd_status_screen) {
         defer_return_to_status = false;
         screen_history_depth = 0;
@@ -400,9 +418,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   inline void lcd_save_previous_menu() {
     if (screen_history_depth < COUNT(screen_history)) {
       screen_history[screen_history_depth].menu_function = currentScreen;
-      #if ENABLED(ULTIPANEL)
-        screen_history[screen_history_depth].encoder_position = encoderPosition;
-      #endif
+      screen_history[screen_history_depth].encoder_position = encoderPosition;
       ++screen_history_depth;
     }
   }
@@ -410,10 +426,10 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   static void lcd_goto_previous_menu(bool feedback=false) {
     if (screen_history_depth > 0) {
       --screen_history_depth;
-      lcd_goto_screen(screen_history[screen_history_depth].menu_function, feedback
-        #if ENABLED(ULTIPANEL)
-          , screen_history[screen_history_depth].encoder_position
-        #endif
+      lcd_goto_screen(
+        screen_history[screen_history_depth].menu_function,
+        feedback,
+        screen_history[screen_history_depth].encoder_position
       );
     }
     else
@@ -658,6 +674,7 @@ void kill_screen(const char* lcd_msg) {
     long babysteps_done = 0;
 
     static void _lcd_babystep(const AxisEnum axis, const char* msg) {
+      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         int babystep_increment = (int32_t)encoderPosition * BABYSTEP_MULTIPLICATOR;
@@ -670,7 +687,6 @@ void kill_screen(const char* lcd_msg) {
         lcd_implementation_drawedit(msg, ftostr43sign(
           ((1000 * babysteps_done) / planner.axis_steps_per_mm[axis]) * 0.001f
         ));
-      if (LCD_CLICKED) lcd_goto_previous_menu(true);
     }
 
     #if ENABLED(BABYSTEP_XY)
@@ -871,29 +887,29 @@ void kill_screen(const char* lcd_msg) {
   }
 
   #if TEMP_SENSOR_0 != 0
-    void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-    void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+    void lcd_preheat_pla0() { _lcd_preheat(0, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
+    void lcd_preheat_abs0() { _lcd_preheat(0, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
   #endif
 
   #if HOTENDS > 1
-    void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-    void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+    void lcd_preheat_pla1() { _lcd_preheat(1, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
+    void lcd_preheat_abs1() { _lcd_preheat(1, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
     #if HOTENDS > 2
-      void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-      void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+      void lcd_preheat_pla2() { _lcd_preheat(2, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
+      void lcd_preheat_abs2() { _lcd_preheat(2, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
       #if HOTENDS > 3
-        void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-        void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
+        void lcd_preheat_pla3() { _lcd_preheat(3, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
+        void lcd_preheat_abs3() { _lcd_preheat(3, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
       #endif
     #endif
 
     void lcd_preheat_pla0123() {
       #if HOTENDS > 1
-        thermalManager.setTargetHotend(plaPreheatHotendTemp, 1);
+        thermalManager.setTargetHotend(preheatHotendTemp1, 1);
         #if HOTENDS > 2
-          thermalManager.setTargetHotend(plaPreheatHotendTemp, 2);
+          thermalManager.setTargetHotend(preheatHotendTemp1, 2);
           #if HOTENDS > 3
-            thermalManager.setTargetHotend(plaPreheatHotendTemp, 3);
+            thermalManager.setTargetHotend(preheatHotendTemp1, 3);
           #endif
         #endif
       #endif
@@ -901,11 +917,11 @@ void kill_screen(const char* lcd_msg) {
     }
     void lcd_preheat_abs0123() {
       #if HOTENDS > 1
-        thermalManager.setTargetHotend(absPreheatHotendTemp, 1);
+        thermalManager.setTargetHotend(preheatHotendTemp2, 1);
         #if HOTENDS > 2
-          thermalManager.setTargetHotend(absPreheatHotendTemp, 2);
+          thermalManager.setTargetHotend(preheatHotendTemp2, 2);
           #if HOTENDS > 3
-            thermalManager.setTargetHotend(absPreheatHotendTemp, 3);
+            thermalManager.setTargetHotend(preheatHotendTemp2, 3);
           #endif
         #endif
       #endif
@@ -915,8 +931,8 @@ void kill_screen(const char* lcd_msg) {
   #endif // HOTENDS > 1
 
   #if TEMP_SENSOR_BED != 0
-    void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }
-    void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }
+    void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, preheatBedTemp1, preheatFanSpeed1); }
+    void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, preheatBedTemp2, preheatFanSpeed2); }
   #endif
 
   #if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)
@@ -925,20 +941,20 @@ void kill_screen(const char* lcd_msg) {
       START_MENU();
       MENU_ITEM(back, MSG_PREPARE);
       #if HOTENDS == 1
-        MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_pla0);
       #else
-        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);
-        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_pla0);
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_pla1);
         #if HOTENDS > 2
-          MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_pla2);
           #if HOTENDS > 3
-            MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);
+            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_pla3);
           #endif
         #endif
-        MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
+        MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_pla0123);
       #endif
       #if TEMP_SENSOR_BED != 0
-        MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);
+        MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_pla_bedonly);
       #endif
       END_MENU();
     }
@@ -947,20 +963,20 @@ void kill_screen(const char* lcd_msg) {
       START_MENU();
       MENU_ITEM(back, MSG_PREPARE);
       #if HOTENDS == 1
-        MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_abs0);
       #else
-        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);
-        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_abs0);
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_abs1);
         #if HOTENDS > 2
-          MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_abs2);
           #if HOTENDS > 3
-            MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);
+            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_abs3);
           #endif
         #endif
-        MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
+        MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_abs0123);
       #endif
       #if TEMP_SENSOR_BED != 0
-        MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);
+        MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_abs_bedonly);
       #endif
       END_MENU();
     }
@@ -1236,11 +1252,11 @@ void kill_screen(const char* lcd_msg) {
     //
     #if TEMP_SENSOR_0 != 0
       #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0
-        MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
-        MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
+        MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_pla_menu);
+        MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_abs_menu);
       #else
-        MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
-        MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_pla0);
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_abs0);
       #endif
     #endif
 
@@ -1284,12 +1300,14 @@ void kill_screen(const char* lcd_msg) {
 
   #endif // DELTA_CALIBRATION_MENU
 
+  float move_menu_scale;
+
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send immediately
    */
   inline void manage_manual_move() {
-    if (manual_move_axis != (int8_t)NO_AXIS && millis() >= manual_move_start_time && !planner.is_full()) {
+    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
       #if ENABLED(DELTA)
         calculate_delta(current_position);
         planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, manual_move_e_index);
@@ -1312,7 +1330,7 @@ void kill_screen(const char* lcd_msg) {
     #if EXTRUDERS > 1
       if (axis == E_AXIS) manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
-    manual_move_start_time = millis() + 500UL; // 1/2 second delay
+    manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
@@ -1322,9 +1340,8 @@ void kill_screen(const char* lcd_msg) {
    *
    */
 
-  float move_menu_scale;
-
   static void _lcd_move_xyz(const char* name, AxisEnum axis, float min, float max) {
+    if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       refresh_cmd_timeout();
@@ -1336,7 +1353,6 @@ void kill_screen(const char* lcd_msg) {
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr41sign(current_position[axis]));
-    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
   #if ENABLED(DELTA)
     static float delta_clip_radius_2 =  (DELTA_PRINTABLE_RADIUS) * (DELTA_PRINTABLE_RADIUS);
@@ -1353,6 +1369,7 @@ void kill_screen(const char* lcd_msg) {
       int8_t eindex = -1
     #endif
   ) {
+    if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
@@ -1370,7 +1387,7 @@ void kill_screen(const char* lcd_msg) {
         pos_label = PSTR(MSG_MOVE_E);
       #else
         switch (eindex) {
-          case 0: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
+          default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
           case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
           #if EXTRUDERS > 2
             case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
@@ -1382,7 +1399,6 @@ void kill_screen(const char* lcd_msg) {
       #endif //EXTRUDERS > 1
       lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
     }
-    if (LCD_CLICKED) lcd_goto_previous_menu(true);
   }
 
   #if EXTRUDERS > 1
@@ -1532,14 +1548,14 @@ void kill_screen(const char* lcd_msg) {
     // Helpers for editing PID Ki & Kd values
     // grab the PID value out of the temp variable; scale it; then update the PID driver
     void copy_and_scalePID_i(int e) {
-      #if DISABLED(PID_PARAMS_PER_HOTEND)
+      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
         UNUSED(e);
       #endif
       PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
       thermalManager.updatePID();
     }
     void copy_and_scalePID_d(int e) {
-      #if DISABLED(PID_PARAMS_PER_HOTEND)
+      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
         UNUSED(e);
       #endif
       PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
@@ -1699,12 +1715,12 @@ void kill_screen(const char* lcd_msg) {
     //
     // Preheat PLA conf
     //
-    MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
+    MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
 
     //
     // Preheat ABS conf
     //
-    MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
+    MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
     END_MENU();
   }
 
@@ -1716,12 +1732,12 @@ void kill_screen(const char* lcd_msg) {
   static void lcd_control_temperature_preheat_pla_settings_menu() {
     START_MENU();
     MENU_ITEM(back, MSG_TEMPERATURE);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &preheatFanSpeed1, 0, 255);
     #if TEMP_SENSOR_0 != 0
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &preheatHotendTemp1, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
     #endif
     #if TEMP_SENSOR_BED != 0
-      MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_BED, &preheatBedTemp1, BED_MINTEMP, BED_MAXTEMP - 15);
     #endif
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
@@ -1737,12 +1753,12 @@ void kill_screen(const char* lcd_msg) {
   static void lcd_control_temperature_preheat_abs_settings_menu() {
     START_MENU();
     MENU_ITEM(back, MSG_TEMPERATURE);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &preheatFanSpeed2, 0, 255);
     #if TEMP_SENSOR_0 != 0
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &preheatHotendTemp2, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
     #endif
     #if TEMP_SENSOR_BED != 0
-      MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_BED, &preheatBedTemp2, BED_MINTEMP, BED_MAXTEMP - 15);
     #endif
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
@@ -1841,6 +1857,7 @@ void kill_screen(const char* lcd_msg) {
    */
   #if HAS_LCD_CONTRAST
     static void lcd_set_contrast() {
+      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         set_lcd_contrast(lcd_contrast + encoderPosition);
@@ -1856,7 +1873,6 @@ void kill_screen(const char* lcd_msg) {
           #endif
         );
       }
-      if (LCD_CLICKED) lcd_goto_previous_menu(true);
     }
   #endif // HAS_LCD_CONTRAST
 
@@ -1890,13 +1906,13 @@ void kill_screen(const char* lcd_msg) {
     #if !PIN_EXISTS(SD_DETECT)
       static void lcd_sd_refresh() {
         card.initsd();
-        currentMenuViewOffset = 0;
+        encoderTopLine = 0;
       }
     #endif
 
     static void lcd_sd_updir() {
       card.updir();
-      currentMenuViewOffset = 0;
+      encoderTopLine = 0;
     }
 
     /**
@@ -1921,7 +1937,7 @@ void kill_screen(const char* lcd_msg) {
       }
 
       for (uint16_t i = 0; i < fileCnt; i++) {
-        if (_menuItemNr == _lineNr) {
+        if (_menuLineNr == _thisItemNr) {
           card.getfilename(
              #if ENABLED(SDCARD_RATHERRECENTFIRST)
                fileCnt-1 -
@@ -1948,22 +1964,29 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(PRINTCOUNTER)
       /**
        *
-       * About Printer > Stastics submenu
+       * About Printer > Statistics submenu
        *
        */
       static void lcd_info_stats_menu() {
+        if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+
         PrintCounter print_job_counter = PrintCounter();
         print_job_counter.loadStats();
         printStatistics stats = print_job_counter.getStats();
 
-        char printTime[6];
-        sprintf(printTime, "%02d:%02d", int(stats.printTime / 60), int(stats.printTime % 60));
+        char timeString[14];
+        sprintf_P(timeString,
+        PSTR("%i" MSG_SHORT_DAY " %i" MSG_SHORT_HOUR " %i" MSG_SHORT_MINUTE),
+          int(stats.printTime / 60 / 60 / 24),
+          int((stats.printTime / 60 / 60) % 24),
+          int((stats.printTime / 60) % 60)
+        );
 
-        if (LCD_CLICKED) lcd_goto_previous_menu(true);
-        START_SCREEN();
-        STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", itostr3left(stats.totalPrints));        // Print Count : 999
-        STATIC_ITEM(MSG_INFO_FINISHED_PRINTS ": ", itostr3left(stats.finishedPrints)); // Finished    : 666
-        STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", printTime);                              // Total Time  : 12:34
+        START_SCREEN();                                                                              // 12345678901234567890
+        STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));        // Print Count: 999
+        STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints)); // Completed  : 666
+        STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", false, false);                                         // Total Time :
+        STATIC_ITEM("  ", false, false, timeString);                                                 //   12345d 12h 34m
         END_SCREEN();
       }
     #endif // PRINTCOUNTER
@@ -1974,48 +1997,48 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_thermistors_menu() {
-      if (LCD_CLICKED) lcd_goto_previous_menu(true);
+      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
       START_SCREEN();
       #define THERMISTOR_ID TEMP_SENSOR_0
       #include "thermistornames.h"
-      STATIC_ITEM("T0: " THERMISTOR_NAME);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP));
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP));
+      STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
 
       #if TEMP_SENSOR_1 != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_1
         #include "thermistornames.h"
-        STATIC_ITEM("T1: " THERMISTOR_NAME);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP));
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP));
+        STATIC_ITEM("T1: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP), false);
       #endif
 
       #if TEMP_SENSOR_2 != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_2
         #include "thermistornames.h"
-        STATIC_ITEM("T2: " THERMISTOR_NAME);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP));
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP));
+        STATIC_ITEM("T2: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP), false);
       #endif
 
       #if TEMP_SENSOR_3 != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_3
         #include "thermistornames.h"
-        STATIC_ITEM("T3: " THERMISTOR_NAME);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP));
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP));
+        STATIC_ITEM("T3: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP), false);
       #endif
 
       #if TEMP_SENSOR_BED != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_BED
         #include "thermistornames.h"
-        STATIC_ITEM("TBed:" THERMISTOR_NAME);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP));
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP));
+        STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
       #endif
       END_SCREEN();
     }
@@ -2026,9 +2049,9 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_board_menu() {
-      if (LCD_CLICKED) lcd_goto_previous_menu(true);
+      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
       START_SCREEN();
-      STATIC_ITEM(BOARD_NAME);                                 // MyPrinterController
+      STATIC_ITEM(BOARD_NAME, true, true);                     // MyPrinterController
       STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE)); // Baud: 250000
       STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION);    // Protocol: 1.0
       #ifdef POWER_SUPPLY
@@ -2047,9 +2070,9 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_printer_menu() {
-      if (LCD_CLICKED) lcd_goto_previous_menu(true);
+      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
       START_SCREEN();
-      STATIC_ITEM(MSG_MARLIN);                                   // Marlin
+      STATIC_ITEM(MSG_MARLIN, true, true);                       // Marlin
       STATIC_ITEM(SHORT_BUILD_VERSION);                          // x.x.x-Branch
       STATIC_ITEM(STRING_DISTRIBUTION_DATE);                     // YYYY-MM-DD HH:MM
       STATIC_ITEM(MACHINE_NAME);                                 // My3DPrinter
@@ -2091,7 +2114,7 @@ void kill_screen(const char* lcd_msg) {
     static void lcd_filament_change_option_menu() {
       START_MENU();
       #if LCD_HEIGHT > 2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER);
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
       #endif
       MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_filament_change_resume_print);
       MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_EXTRUDE, lcd_filament_change_extrude_more);
@@ -2100,7 +2123,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_init_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
       #ifdef MSG_FILAMENT_CHANGE_INIT_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
@@ -2113,7 +2136,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_unload_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
       #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
@@ -2126,7 +2149,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_insert_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
       #ifdef MSG_FILAMENT_CHANGE_INSERT_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
@@ -2139,7 +2162,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_load_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
       #ifdef MSG_FILAMENT_CHANGE_LOAD_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
@@ -2152,7 +2175,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_extrude_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_1);
       #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_2);
@@ -2165,7 +2188,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_filament_change_resume_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
       #ifdef MSG_FILAMENT_CHANGE_RESUME_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
@@ -2338,12 +2361,14 @@ void kill_screen(const char* lcd_msg) {
     lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     next_button_update_ms = millis() + 500;
 
+    // Buzz and wait. The delay is needed for buttons to settle!
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+      delay(10);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
-    delay(10); // needed for buttons to settle
   }
 
   /**
@@ -2422,7 +2447,7 @@ void lcd_init() {
       SET_INPUT(BTN_RT);
     #endif
 
-  #else  // Not NEWPANEL
+  #else // !NEWPANEL
 
     #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
       pinMode(SR_DATA_PIN, OUTPUT);
@@ -2437,7 +2462,7 @@ void lcd_init() {
       WRITE(SHIFT_EN, LOW);
     #endif // SR_LCD_2W_NL
 
-  #endif//!NEWPANEL
+  #endif // !NEWPANEL
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT(SD_DETECT_PIN);
@@ -2459,7 +2484,11 @@ void lcd_init() {
 int lcd_strlen(const char* s) {
   int i = 0, j = 0;
   while (s[i]) {
-    if ((s[i] & 0xc0) != 0x80) j++;
+    #ifdef MAPPER_NON
+      j++;
+    #else
+      if ((s[i] & 0xc0) != 0x80) j++;
+    #endif
     i++;
   }
   return j;
@@ -2468,7 +2497,11 @@ int lcd_strlen(const char* s) {
 int lcd_strlen_P(const char* s) {
   int j = 0;
   while (pgm_read_byte(s)) {
-    if ((pgm_read_byte(s) & 0xc0) != 0x80) j++;
+    #ifdef MAPPER_NON
+      j++; 
+    #else
+      if ((pgm_read_byte(s) & 0xc0) != 0x80) j++;
+    #endif
     s++;
   }
   return j;
@@ -2853,6 +2886,7 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
       GET_BUTTON_STATES(buttons);
     #endif //!NEWPANEL
 
+    // Manage encoder rotation
     #if ENABLED(REVERSE_MENU_DIRECTION) && ENABLED(REVERSE_ENCODER_DIRECTION)
       #define ENCODER_DIFF_CW  (encoderDiff -= encoderDirection)
       #define ENCODER_DIFF_CCW (encoderDiff += encoderDirection)
@@ -2868,7 +2902,6 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     #endif
     #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: ENCODER_DIFF_CW; break; case _E2: ENCODER_DIFF_CCW; }
 
-    //manage encoder rotation
     uint8_t enc = 0;
     if (buttons & EN_A) enc |= B01;
     if (buttons & EN_B) enc |= B10;
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index fde78c0..7a00806 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -90,12 +90,12 @@
     FORCE_INLINE void lcd_buttons_update() {}
   #endif
 
-  extern int plaPreheatHotendTemp;
-  extern int plaPreheatHPBTemp;
-  extern int plaPreheatFanSpeed;
-  extern int absPreheatHotendTemp;
-  extern int absPreheatHPBTemp;
-  extern int absPreheatFanSpeed;
+  extern int preheatHotendTemp1;
+  extern int preheatBedTemp1;
+  extern int preheatFanSpeed1;
+  extern int preheatHotendTemp2;
+  extern int preheatBedTemp2;
+  extern int preheatFanSpeed2;
 
   #if ENABLED(FILAMENT_LCD_DISPLAY)
     extern millis_t previous_lcd_status_ms;
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 7f7bee5..b5342bd 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -443,15 +443,6 @@ unsigned lcd_print(char c) { return charset_mapper(c); }
     lcd.setCursor(indent, 2); lcd.print('\x02'); lcd_printPGM(PSTR( "------" ));  lcd.print('\x03');
   }
 
-  void safe_delay(uint16_t del){
-    while (del > 50) {
-      del -= 50;
-      delay(50);
-      thermalManager.manage_heater();
-    }
-    delay(del);
-  }
-
   void bootscreen() {
     byte top_left[8] = {
       B00000,
@@ -830,7 +821,8 @@ static void lcd_implementation_status_screen() {
 
 #if ENABLED(LCD_INFO_MENU) || ENABLED(FILAMENT_CHANGE_FEATURE)
 
-  static void lcd_implementation_drawmenu_static(uint8_t row, const char* pstr, const char *valstr=NULL, bool center=true) {
+  static void lcd_implementation_drawmenu_static(uint8_t row, const char* pstr, bool center=true, bool invert=false, const char *valstr=NULL) {
+    UNUSED(invert);
     char c;
     int8_t n = LCD_WIDTH;
     lcd.setCursor(0, row);
@@ -838,13 +830,13 @@ static void lcd_implementation_status_screen() {
       int8_t pad = (LCD_WIDTH - lcd_strlen_P(pstr)) / 2;
       while (--pad >= 0) { lcd.print(' '); n--; }
     }
-    while ((c = pgm_read_byte(pstr)) && n > 0) {
+    while (n > 0 && (c = pgm_read_byte(pstr))) {
       n -= lcd_print(c);
       pstr++;
     }
-    if (valstr) {
-      lcd_print(valstr);
-      n -= lcd_strlen(valstr);
+    if (valstr) while (n > 0 && (c = *valstr)) {
+      n -= lcd_print(c);
+      valstr++;
     }
     while (n-- > 0) lcd.print(' ');
   }
diff --git a/Marlin/utf_mapper.h b/Marlin/utf_mapper.h
index ae599af..bba85e1 100644
--- a/Marlin/utf_mapper.h
+++ b/Marlin/utf_mapper.h
@@ -38,6 +38,8 @@
     #define MAPPER_ONE_TO_ONE
   #elif ENABLED(DISPLAY_CHARSET_ISO10646_KANA)
     #define MAPPER_ONE_TO_ONE
+  #elif ENABLED(DISPLAY_CHARSET_ISO10646_GREEK)
+    #define MAPPER_ONE_TO_ONE
   #endif
 #else // SIMULATE_ROMFONT
   #if DISPLAY_CHARSET_HD44780 == JAPANESE
@@ -144,26 +146,50 @@
   #endif // DISPLAY_CHARSET_HD44780
 #endif // SIMULATE_ROMFONT
 
-#if ENABLED(MAPPER_NON)
+#if ENABLED(MAPPER_C2C3)
 
   char charset_mapper(char c) {
-    HARDWARE_CHAR_OUT( c );
+    static uint8_t utf_hi_char; // UTF-8 high part
+    static bool seen_c2 = false;
+    uint8_t d = c;
+    if ( d >= 0x80u ) { // UTF-8 handling
+      if ( (d >= 0xc0u) && (!seen_c2) ) {
+        utf_hi_char = d - 0xc2u;
+        seen_c2 = true;
+        return 0;
+      }
+      else if (seen_c2) {
+        d &= 0x3fu;
+        #ifndef MAPPER_ONE_TO_ONE
+          HARDWARE_CHAR_OUT((char)pgm_read_byte_near(utf_recode + d + (utf_hi_char << 6) - 0x20));
+        #else
+          HARDWARE_CHAR_OUT((char)(0x80u + (utf_hi_char << 6) + d)) ;
+        #endif
+      }
+      else {
+        HARDWARE_CHAR_OUT('?');
+      }
+    }
+    else {
+      HARDWARE_CHAR_OUT((char) c );
+    }
+    seen_c2 = false;
     return 1;
   }
 
-#elif ENABLED(MAPPER_C2C3)
+#elif ENABLED(MAPPER_CECF)
 
   char charset_mapper(char c) {
     static uint8_t utf_hi_char; // UTF-8 high part
-    static bool seen_c2 = false;
+    static bool seen_ce = false;
     uint8_t d = c;
     if ( d >= 0x80 ) { // UTF-8 handling
-      if ( (d >= 0xc0) && (!seen_c2) ) {
-        utf_hi_char = d - 0xc2;
-        seen_c2 = true;
+      if ( (d >= 0xc0) && (!seen_ce) ) {
+        utf_hi_char = d - 0xce;
+        seen_ce = true;
         return 0;
       }
-      else if (seen_c2) {
+      else if (seen_ce) {
         d &= 0x3f;
         #ifndef MAPPER_ONE_TO_ONE
           HARDWARE_CHAR_OUT((char)pgm_read_byte_near(utf_recode + d + (utf_hi_char << 6) - 0x20));
@@ -178,7 +204,38 @@
     else {
       HARDWARE_CHAR_OUT((char) c );
     }
-    seen_c2 = false;
+    seen_ce = false;
+    return 1;
+  }
+
+#elif ENABLED(MAPPER_CECF)
+
+  char charset_mapper(char c) {
+    static uint8_t utf_hi_char; // UTF-8 high part
+    static bool seen_ce = false;
+    uint8_t d = c;
+    if ( d >= 0x80 ) { // UTF-8 handling
+      if ( (d >= 0xc0) && (!seen_ce) ) {
+        utf_hi_char = d - 0xce;
+        seen_ce = true;
+        return 0;
+      }
+      else if (seen_ce) {
+        d &= 0x3f;
+        #ifndef MAPPER_ONE_TO_ONE
+          HARDWARE_CHAR_OUT((char)pgm_read_byte_near(utf_recode + d + (utf_hi_char << 6) - 0x20));
+        #else
+          HARDWARE_CHAR_OUT((char)(0x80 + (utf_hi_char << 6) + d)) ;
+        #endif
+      }
+      else {
+        HARDWARE_CHAR_OUT('?');
+      }
+    }
+    else {
+      HARDWARE_CHAR_OUT((char) c );
+    }
+    seen_ce = false;
     return 1;
   }
 
@@ -289,8 +346,13 @@
 
 #else
 
-  #error "You have to define one of the DISPLAY_INPUT_CODE_MAPPERs in your language_xx.h file" // should not occur because (en) will set.
+  #define MAPPER_NON
+
+  char charset_mapper(char c) {
+    HARDWARE_CHAR_OUT( c );
+    return 1;
+  }
 
-#endif // code mappers
+  #endif // code mappers
 
 #endif // UTF_MAPPER_H
diff --git a/Marlin/utility.cpp b/Marlin/utility.cpp
new file mode 100644
index 0000000..385fe3d
--- /dev/null
+++ b/Marlin/utility.cpp
@@ -0,0 +1,33 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Marlin.h"
+#include "temperature.h"
+
+void safe_delay(uint16_t ms) {
+  while (ms > 50) {
+    ms -= 50;
+    delay(50);
+    thermalManager.manage_heater();
+  }
+  delay(ms);
+}
diff --git a/buildroot/bin/restore_configs b/buildroot/bin/restore_configs
index ca77e55..ba7a72c 100755
--- a/buildroot/bin/restore_configs
+++ b/buildroot/bin/restore_configs
@@ -3,3 +3,7 @@
 cp Marlin/Configuration.h.backup      Marlin/Configuration.h
 cp Marlin/Configuration_adv.h.backup  Marlin/Configuration_adv.h
 cp Marlin/pins_RAMPS_14.h.backup      Marlin/pins_RAMPS_14.h
+
+if [ -f Marlin/_Bootscreen.h ]; then
+  rm Marlin/_Bootscreen.h
+fi
diff --git a/buildroot/bin/use_example_configs b/buildroot/bin/use_example_configs
index d1e6e46..9f55c52 100755
--- a/buildroot/bin/use_example_configs
+++ b/buildroot/bin/use_example_configs
@@ -1,3 +1,7 @@
 #!/usr/bin/env bash
 
-eval "cp Marlin/example_configurations/$1/Configuration* Marlin/"
+eval "cp Marlin/example_configurations/${1}/Configuration* Marlin/"
+
+if [ -f "Marlin/example_configurations/${1}/_Bootscreen.h" ]; then
+  cp "Marlin/example_configurations/${1}/_Bootscreen.h" Marlin/
+fi

