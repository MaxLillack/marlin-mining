commit 4d6128780767d099a09e4f2fecdc03bac2aad503 (from 280504e2e097ea33a8927a83c8e5cada6346df83)
Merge: 280504e b17b858
Author: Bo Herrmannsen <bo.herrmannsen@gmail.com>
Date:   Wed Dec 17 23:28:30 2014 +0100

    Merge pull request #1186 from boelle/Marlin_v1
    
    adding hardware files for OMC

diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/boards.txt b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/boards.txt
new file mode 100644
index 0000000..363d615
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/boards.txt
@@ -0,0 +1,23 @@
+##############################################################
+
+omc.name=OMC with Atmega644 at 20Mhz
+
+omc.upload.maximum_size=63488
+omc.upload.maximum_data_size=4096
+
+omc.upload.protocol=stk500v2
+omc.upload.speed=115200
+omc.bootloader.path=OMC
+omc.bootloader.file=bootloader-644-20MHz.hex
+
+omc.bootloader.low_fuses=0xE7
+omc.bootloader.high_fuses=0xD4
+omc.bootloader.extended_fuses=0xFC
+omc.bootloader.unlock_bits=0x3F
+omc.bootloader.lock_bits=0x0F
+
+omc.build.mcu=atmega644
+omc.build.f_cpu=20000000L
+omc.build.board=AVR_OMC
+omc.build.core=arduino:arduino
+omc.build.variant=sanguino
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/OMC/bootloader-644-20MHz.hex b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/OMC/bootloader-644-20MHz.hex
new file mode 100644
index 0000000..d216c65
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/OMC/bootloader-644-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539441ED5AE363E570E090E0C2
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..1711014
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,713 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_324P.hex
new file mode 100644
index 0000000..e67fe88
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_324P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D85E90E94067D88E0F2
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644.hex b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644.hex
new file mode 100644
index 0000000..d5557de
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644.hex
@@ -0,0 +1,120 @@
+:10F800000C94387C0C94557C0C94557C0C94557C51
+:10F810000C94557C0C94557C0C94557C0C94557C24
+:10F820000C94557C0C94557C0C94557C0C94557C14
+:10F830000C94557C0C94557C0C94557C0C94557C04
+:10F840000C94557C0C94557C0C94557C0C94557CF4
+:10F850000C94557C0C94557C0C94557C0C94557CE4
+:10F860000C94557C0C94557C0C94557C0C94557CD4
+:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
+:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
+:10F89000D9F712E0A0E0B1E001C01D92A930B10794
+:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
+:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
+:10F8C000CDBF882309F481E020E0482F552741155A
+:10F8D000510509F43DC0289A19821A821B821C82A4
+:10F8E0000BC089819A81AB81BC810196A11DB11D9C
+:10F8F00089839A83AB83BC8389819A81AB81BC81E4
+:10F9000080589E43A040B04060F3289819821A8224
+:10F910001B821C820BC089819A81AB81BC810196BC
+:10F92000A11DB11D89839A83AB83BC8389819A8190
+:10F93000AB81BC8180509A4FA040B04060F32F5FF4
+:10F94000822F992787FD9095841795070CF4C3CFD4
+:10F9500019821A821B821C8289819A81AB81BC81A7
+:10F9600080509147A240B040A0F489819A81AB8138
+:10F97000BC810196A11DB11D89839A83AB83BC8391
+:10F9800089819A81AB81BC8180509147A240B0406F
+:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
+:10F9A000CF910895EF92FF920F931F93EE24FF24BF
+:10F9B000870128988091C00087FD17C00894E11C3A
+:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
+:10F9D000080780E0180770F3E0910001F091010141
+:10F9E00009958091C00087FFE9CF289A8091C600D1
+:10F9F000992787FD90951F910F91FF90EF900895A3
+:10FA0000982F8091C00085FFFCCF9093C600089589
+:10FA10000E94D27C803271F0809102018F5F8093CE
+:10FA20000201853009F00895E0910001F091010193
+:10FA30000995089584E10E94007D80E10E94007D87
+:10FA40000895CF93C82F0E94D27C803241F08091DC
+:10FA500002018F5F80930201853081F40AC084E146
+:10FA60000E94007D8C2F0E94007D80E10E94007D1D
+:10FA700005C0E0910001F09101010995CF91089531
+:10FA8000282F90E007C08091C0008823E4F7809180
+:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
+:10FAA000CDBF000094B714BE809160008861809340
+:10FAB00060001092600091FF74C189E18093C400DE
+:10FAC0001092C50088E18093C10086E08093C20057
+:10FAD0005098589A209A83E00E94577C81E00E94B7
+:10FAE000577C0E94D27C8033B9F18133C1F18034DC
+:10FAF00009F456C0813409F45CC0823409F46EC044
+:10FB0000853409F471C0803539F1813509F4F3C0C9
+:10FB1000823511F1853509F4D3C0863509F4CBC09F
+:10FB2000843609F465C0843709F4EBC0853709F4DD
+:10FB3000D2C0863709F44AC0809102018F5F80935A
+:10FB40000201853071F6E0910001F0910101099503
+:10FB50000E94D27C803349F60E94087DC2CF0E9469
+:10FB6000D27CC82F803241F784E10E94007D81E47D
+:10FB70000E94007D86E50E94007D82E50E94007D56
+:10FB80008C2F0E94007D89E40E94007D83E50E9405
+:10FB9000007D80E50E94007D80E10E94007DA1CF74
+:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
+:10FBB00098CF0E94D27C803809F407C1813809F4BB
+:10FBC00000C1823809F4F9C0883921F080E00E9430
+:10FBD000217D87CF83E00E94217D83CF84E10E9435
+:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
+:10FBF0000E94D27C809306020E94D27C80930502F0
+:10FC0000809108028E7F809308020E94D27C853406
+:10FC100009F44BC0E5E0F1E0119281E0E438F80727
+:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
+:10FC30001816190678F405E011E00E94D27CF8014C
+:10FC400081938F0121968091050290910602C81739
+:10FC5000D90798F30E94D27C803209F06DCF809151
+:10FC6000080280FFB6C0C0E0D0E0209105023091CC
+:10FC7000060212161306B8F4E0910301F091040194
+:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
+:10FC9000FA9AF99A31962196C217D30798F3F093FE
+:10FCA0000401E093030184E175CF80910802816033
+:10FCB00080930802AFCF84E00E94407D80E087CF30
+:10FCC0000E94D27C809303010E94D27C8093040125
+:10FCD0000E94087D06CF0E94D27C803209F02CCF92
+:10FCE00084E10E94007D8EE10E94007D86E90E94F1
+:10FCF000007D89E04FCF0E94087D88E080936000FE
+:10FD0000FFCF0E94D27C809306020E94D27C809317
+:10FD100005020E94D27C853409F449C08091080212
+:10FD20008E7F809308028091030190910401880FD7
+:10FD3000991F90930401809303010E94D27C80322A
+:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
+:10FD50000502309106021216130608F01DCFE0913D
+:10FD60000301F09104018091080280FF96C0F99987
+:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
+:10FD80000301F09104013196F0930401E093030123
+:10FD900020910502309106022196C217D30718F36D
+:10FDA000FBCEE0910001F0910101099586CE809192
+:10FDB0000802816080930802C0CF80E10E94217D0B
+:10FDC00090CE81E00E94217D8CCE82E00E94217D38
+:10FDD00088CE8091030190910401880F991F909320
+:10FDE0000401809303018091050280FF09C0809186
+:10FDF00005029091060201969093060280930502F7
+:10FE0000F999FECF1127E0910301F0910401C5E0BB
+:10FE1000D1E08091050290910602103091F400919A
+:10FE2000570001700130D9F303E000935700E895C3
+:10FE30000091570001700130D9F301E100935700A0
+:10FE4000E895099019900091570001700130D9F39D
+:10FE500001E000935700E8951395103898F01127AA
+:10FE60000091570001700130D9F305E0009357006D
+:10FE7000E8950091570001700130D9F301E100933A
+:10FE80005700E8953296029709F0C7CF103011F06D
+:10FE90000296E5CF112484E17DCE869580FF06C0D1
+:10FEA0003196F0930401E093030176CF84910E9490
+:10FEB000007D2091050230910602E0910301F0914E
+:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
+:10FED000007D0E94D27C182F0E94007DC1362CF03C
+:10FEE000C75511363CF0175508C0C033D4F3C05382
+:10FEF0001136CCF710330CF01053C295C07FC10FF0
+:10FF00008C2F992787FD9095CF911F910895CF93BE
+:10FF1000282F992787FD9095807F907095958795DC
+:10FF20009595879595958795959587958A303CF019
+:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
+:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
+:0AFF50000E94007DCF910895FFCFBD
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..99a6ae1
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..5714395
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0xF800
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/variants/sanguino/pins_arduino.h b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/variants/sanguino/pins_arduino.h
new file mode 100644
index 0000000..f4298d8
--- /dev/null
+++ b/ArduinoAddons/Arduino_1.0.x/hardware/OMC_tkj/variants/sanguino/pins_arduino.h
@@ -0,0 +1,269 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+
+  Changelog
+  -----------
+  11/25/11  - ryan@ryanmsutton.com - Add pins for Sanguino 644P and 1284P
+  07/15/12  - ryan@ryanmsutton.com - Updated for arduino0101
+
+  Improvements by Kristian Lauszus, kristianl@tkjelectronics.dk
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+const static uint8_t SS   = 4;
+const static uint8_t MOSI = 5;
+const static uint8_t MISO = 6;
+const static uint8_t SCK  = 7;
+
+static const uint8_t SDA = 17;
+static const uint8_t SCL = 16;
+
+#define LED_BUILTIN 0
+
+static const uint8_t A0 = 31;
+static const uint8_t A1 = 30;
+static const uint8_t A2 = 29;
+static const uint8_t A3 = 28;
+static const uint8_t A4 = 27;
+static const uint8_t A5 = 26;
+static const uint8_t A6 = 25;
+static const uint8_t A7 = 24;
+
+// ATMEL ATMEGA644/ATMEGA1284 / SANGUINO
+//
+//                        +---\/---+
+//            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//     SS PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//                  RST  9|        |32  AREF
+//                  VCC 10|        |31  GND
+//                  GND 11|        |30  AVCC
+//                XTAL2 12|        |29  PC7 (D 23)
+//                XTAL1 13|        |28  PC6 (D 22)
+//       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                        +--------+
+//
+#define NUM_DIGITAL_PINS            24
+#define NUM_ANALOG_INPUTS           8
+
+#define analogInputToDigitalPin(p)  ((p < 8) ? 31 - (p): -1)
+#define analogPinToChannel(p)       ((p < 8) ? (p) : 31 - (p))
+
+#define digitalPinHasPWM(p)         ((p) == 3 || (p) == 4 || (p) == 12 || (p) == 13 || (p) == 14 || (p) == 15 )
+
+#define digitalPinToPCICR(p)        ( (((p) >= 0) && ((p) <= 31)) ? (&PCICR) : ((uint8_t *)0) )
+
+#define digitalPinToPCICRbit(p)     ( (((p) >= 24) && ((p) <= 31)) ? 0 : \
+                                    ( (((p) >=  0) && ((p) <=  7)) ? 1 : \
+                                    ( (((p) >= 16) && ((p) <= 23)) ? 2 : \
+                                    ( (((p) >=  8) && ((p) <= 15)) ? 3 : \
+                                    0 ) ) ) )
+
+#define digitalPinToPCMSK(p)        ( (((p) >= 24) && ((p) <= 31)) ? (&PCMSK0) : \
+                                    ( (((p) >=  0) && ((p) <=  7)) ? (&PCMSK1) : \
+                                    ( (((p) >= 16) && ((p) <= 23)) ? (&PCMSK2) : \
+                                    ( (((p) >=  8) && ((p) <= 15)) ? (&PCMSK3) : \
+                                    ((uint8_t *)0) ) ) ) )
+
+
+#define digitalPinToPCMSKbit(p)     ( (((p) >= 24) && ((p) <= 31)) ? (31 - (p)) : \
+                                    ( (((p) >=  0) && ((p) <=  7)) ? (p) : \
+                                    ( (((p) >= 16) && ((p) <= 23)) ? ((p) - 16) : \
+                                    ( (((p) >=  8) && ((p) <= 15)) ? ((p) - 8) : \
+                                    0 ) ) ) )
+
+#define digitalPinToInterrupt(p)    ((p) == 10 ? 0 : ((p) == 11 ? 1 : ((p) == 2 ? 2 : NOT_AN_INTERRUPT)))
+
+#ifdef ARDUINO_MAIN
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint16_t PROGMEM port_to_mode_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &DDRA,
+        (uint16_t) &DDRB,
+        (uint16_t) &DDRC,
+        (uint16_t) &DDRD,
+};
+
+const uint16_t PROGMEM port_to_output_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &PORTA,
+        (uint16_t) &PORTB,
+        (uint16_t) &PORTC,
+        (uint16_t) &PORTD,
+};
+const uint16_t PROGMEM port_to_input_PGM[] =
+{
+        NOT_A_PORT,
+        (uint16_t) &PINA,
+        (uint16_t) &PINB,
+        (uint16_t) &PINC,
+        (uint16_t) &PIND,
+};
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+        PB, /* 0 */
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PB,
+        PD, /* 8 */
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PD,
+        PC, /* 16 */
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PC,
+        PA, /* 24 */
+        PA,
+        PA,
+        PA,
+        PA,
+        PA,
+        PA,
+        PA  /* 31 */
+};
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+        _BV(0), /* 0, port B */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(0), /* 8, port D */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(0), /* 16, port C */
+        _BV(1),
+        _BV(2),
+        _BV(3),
+        _BV(4),
+        _BV(5),
+        _BV(6),
+        _BV(7),
+        _BV(7), /* 24, port A */
+        _BV(6),
+        _BV(5),
+        _BV(4),
+        _BV(3),
+        _BV(2),
+        _BV(1),
+        _BV(0)
+};
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+        NOT_ON_TIMER,   /* 0  - PB0 */
+        NOT_ON_TIMER,   /* 1  - PB1 */
+        NOT_ON_TIMER,   /* 2  - PB2 */
+        TIMER0A,        /* 3  - PB3 */
+        TIMER0B,        /* 4  - PB4 */
+        NOT_ON_TIMER,   /* 5  - PB5 */
+        NOT_ON_TIMER,   /* 6  - PB6 */
+        NOT_ON_TIMER,   /* 7  - PB7 */
+        NOT_ON_TIMER,   /* 8  - PD0 */
+        NOT_ON_TIMER,   /* 9  - PD1 */
+        NOT_ON_TIMER,   /* 10 - PD2 */
+        NOT_ON_TIMER,   /* 11 - PD3 */
+        TIMER1B,        /* 12 - PD4 */
+        TIMER1A,        /* 13 - PD5 */
+        TIMER2B,        /* 14 - PD6 */
+        TIMER2A,        /* 15 - PD7 */
+        NOT_ON_TIMER,   /* 16 - PC0 */
+        NOT_ON_TIMER,   /* 17 - PC1 */
+        NOT_ON_TIMER,   /* 18 - PC2 */
+        NOT_ON_TIMER,   /* 19 - PC3 */
+        NOT_ON_TIMER,   /* 20 - PC4 */
+        NOT_ON_TIMER,   /* 21 - PC5 */
+        NOT_ON_TIMER,   /* 22 - PC6 */
+        NOT_ON_TIMER,   /* 23 - PC7 */
+        NOT_ON_TIMER,   /* 24 - PA0 */
+        NOT_ON_TIMER,   /* 25 - PA1 */
+        NOT_ON_TIMER,   /* 26 - PA2 */
+        NOT_ON_TIMER,   /* 27 - PA3 */
+        NOT_ON_TIMER,   /* 28 - PA4 */
+        NOT_ON_TIMER,   /* 29 - PA5 */
+        NOT_ON_TIMER,   /* 30 - PA6 */
+        NOT_ON_TIMER   /* 31 - PA7 */
+};
+#endif
+
+// These serial port names are intended to allow libraries and architecture-neutral
+// sketches to automatically default to the correct port name for a particular type
+// of use.  For example, a GPS module would normally connect to SERIAL_PORT_HARDWARE_OPEN,
+// the first hardware serial port whose RX/TX pins are not dedicated to another use.
+//
+// SERIAL_PORT_MONITOR        Port which normally prints to the Arduino Serial Monitor
+//
+// SERIAL_PORT_USBVIRTUAL     Port which is USB virtual serial
+//
+// SERIAL_PORT_LINUXBRIDGE    Port which connects to a Linux system via Bridge library
+//
+// SERIAL_PORT_HARDWARE       Hardware serial port, physical RX & TX pins.
+//
+// SERIAL_PORT_HARDWARE_OPEN  Hardware serial ports which are open for use.  Their RX & TX
+//                            pins are NOT connected to anything by default.
+
+#define SERIAL_PORT_MONITOR         Serial
+#define SERIAL_PORT_HARDWARE        Serial
+#define SERIAL_PORT_HARDWARE1       Serial1
+#define SERIAL_PORT_HARDWARE_OPEN   Serial1
+
+#endif

