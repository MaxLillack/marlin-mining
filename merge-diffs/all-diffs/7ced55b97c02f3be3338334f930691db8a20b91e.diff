commit 7ced55b97c02f3be3338334f930691db8a20b91e
Merge: a65a26d 1561c6d
Author: midopple <mdoppler@gmx.at>
Date:   Sat Jul 27 08:06:44 2013 -0700

    Merge pull request #1 from ErikZalm/Marlin_v1
    
    merge

diff --git a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
index 1711014..3b56dfd 100644
--- a/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_0.xx/Gen6/bootloaders/atmega644p/ATmegaBOOT.c
@@ -168,7 +168,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
index 1711014..3b56dfd 100644
--- a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -168,7 +168,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp b/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
index 23713f4..c3362f6 100644
--- a/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
+++ b/ArduinoAddons/Arduino_0.xx/libraries/LiquidCrystal/LiquidCrystal.cpp
@@ -21,7 +21,7 @@
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 
 LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
diff --git a/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c b/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
index f86bf06..4a8758c 100644
--- a/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
+++ b/ArduinoAddons/Arduino_0.xx/libraries/U8glib/utility/chessengine.c
@@ -72,7 +72,7 @@
 	- Castling: Need to check for fields under attack
 	    --> done
 	
-	- Check for WIN / LOOSE situation, perhaps call ce_Eval() once on the top-level board setup
+	- Check for WIN / LOSE situation, perhaps call ce_Eval() once on the top-level board setup
 	    just after the real move
 	- cleanup cu_Move
 	    --> almost done
diff --git a/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp b/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
index 0653487..61efca4 100644
--- a/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
+++ b/ArduinoAddons/Arduino_1.x.x/libraries/LiquidCrystal/LiquidCrystal.cpp
@@ -21,7 +21,7 @@
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 
 LiquidCrystal::LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
diff --git a/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c b/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
index f86bf06..4a8758c 100644
--- a/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
+++ b/ArduinoAddons/Arduino_1.x.x/libraries/U8glib/utility/chessengine.c
@@ -72,7 +72,7 @@
 	- Castling: Need to check for fields under attack
 	    --> done
 	
-	- Check for WIN / LOOSE situation, perhaps call ce_Eval() once on the top-level board setup
+	- Check for WIN / LOSE situation, perhaps call ce_Eval() once on the top-level board setup
 	    just after the real move
 	- cleanup cu_Move
 	    --> almost done
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
index 9354a78..1df3f03 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega/ATmegaBOOT_168.c
@@ -301,7 +301,7 @@ int main(void)
 	WDTCSR = 0;
 
 	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-	if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+	if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
 		app_start();  // skip bootloader
 #else
 	asm volatile("nop\n\t");
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
index fd19d14..51bd8d5 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -172,7 +172,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
index 733542d..7e0adff 100644
--- a/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
+++ b/ArduinoAddons/Arduino_1.x.x/sanguino/bootloaders/atmega644p/ATmegaBOOT.c.tst
@@ -172,7 +172,7 @@ int main(void)
     WDTCSR = 0;
 
     // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+    if (! (ch &  _BV(EXTRF))) // if it's a not an external reset...
       app_start();  // skip bootloader
 #endif
 
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index eed4abc..db02b1d 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -1,15 +1,15 @@
 #ifndef CONFIGURATION_H
 #define CONFIGURATION_H
 
-// This configurtion file contains the basic settings.
-// Advanced settings can be found in Configuration_adv.h 
+// This configuration file contains the basic settings.
+// Advanced settings can be found in Configuration_adv.h
 // BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
 
-//User specified version info of this build to display in [Pronterface, etc] terminal window during startup.
-//Implementation of an idea by Prof Braino to inform user that any changes made
-//to this build by the user have been successfully uploaded into firmware.
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
 #define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
-#define STRING_CONFIG_H_AUTHOR "(none, default config)" //Who made the changes.
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 
 // SERIAL_PORT selects which serial port should be used for communication with the host.
 // This allows the connection of wireless adapters (for instance) to non-default port pins.
@@ -26,8 +26,9 @@
 // 12 = Gen7 v1.3
 // 13 = Gen7 v1.4
 // 3  = MEGA/RAMPS up to 1.2 = 3
-// 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Bed, Fan)
+// 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
 // 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
+// 35 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)
 // 4  = Duemilanove w/ ATMega328P pin assignment
 // 5  = Gen6
 // 51 = Gen6 deluxe
@@ -35,28 +36,77 @@
 // 62 = Sanguinololu 1.2 and above
 // 63 = Melzi
 // 64 = STB V1.1
+// 65 = Azteeg X1
+// 66 = Melzi with ATmega1284 (MaKr3d version)
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 77 = 3Drag Controller
 // 8  = Teensylu
 // 80 = Rumba
 // 81 = Printrboard (AT90USB1286)
 // 82 = Brainwave (AT90USB646)
 // 9  = Gen3+
 // 70 = Megatronics
+// 701= Megatronics v2.0
+// 702= Minitronics v1.0
 // 90 = Alpha OMCA board
 // 91 = Final OMCA board
 // 301 = Rambo
+// 21 = Elefu Ra Board (v3)
 
 #ifndef MOTHERBOARD
 #define MOTHERBOARD 7
 #endif
 
+// Define this to set a custom name for your generic Mendel,
+// #define CUSTOM_MENDEL_NAME "This Mendel"
+
+// This defines the number of extruders
+#define EXTRUDERS 1
+
 //// The following define selects which power supply you have. Please choose the one that matches your setup
 // 1 = ATX
 // 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
 
 #define POWER_SUPPLY 1
 
+
+//===========================================================================
+//============================== Delta Settings =============================
+//===========================================================================
+// Enable DELTA kinematics
+//#define DELTA
+
+// Make delta curves from many straight lines (linear interpolation).
+// This is a trade-off between visible corners (not enough segments)
+// and processor overload (too many expensive sqrt calls).
+#define DELTA_SEGMENTS_PER_SECOND 200
+
+// Center-to-center distance of the holes in the diagonal push rods.
+#define DELTA_DIAGONAL_ROD 250.0 // mm
+
+// Horizontal offset from middle of printer to smooth rod center.
+#define DELTA_SMOOTH_ROD_OFFSET 175.0 // mm
+
+// Horizontal offset of the universal joints on the end effector.
+#define DELTA_EFFECTOR_OFFSET 33.0 // mm
+
+// Horizontal offset of the universal joints on the carriages.
+#define DELTA_CARRIAGE_OFFSET 18.0 // mm
+
+// Effective horizontal distance bridged by diagonal push rods.
+#define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
+
+// Effective X/Y positions of the three vertical towers.
+#define SIN_60 0.8660254037844386
+#define COS_60 0.5
+#define DELTA_TOWER1_X -SIN_60*DELTA_RADIUS // front left tower
+#define DELTA_TOWER1_Y -COS_60*DELTA_RADIUS
+#define DELTA_TOWER2_X SIN_60*DELTA_RADIUS // front right tower
+#define DELTA_TOWER2_Y -COS_60*DELTA_RADIUS
+#define DELTA_TOWER3_X 0.0 // back middle tower
+#define DELTA_TOWER3_Y DELTA_RADIUS
+
 //===========================================================================
 //=============================Thermal Settings  ============================
 //===========================================================================
@@ -77,25 +127,30 @@
 // 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
 // 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
 // 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 60 is 100k Maker's Tool Works Kapton Bed Thermister
 //
-//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k 
+//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
 //                          (but gives greater accuracy and more stable PID)
 // 51 is 100k thermistor - EPCOS (1k pullup)
 // 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
 // 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan) (1k pullup)
 
 #define TEMP_SENSOR_0 -1
-#define TEMP_SENSOR_1 0
+#define TEMP_SENSOR_1 -1
 #define TEMP_SENSOR_2 0
 #define TEMP_SENSOR_BED 0
 
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT 
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
 // Actual temperature must be close to target for this long before M109 returns success
-#define TEMP_RESIDENCY_TIME 10	// (seconds)
+#define TEMP_RESIDENCY_TIME 10  // (seconds)
 #define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
-#define TEMP_WINDOW     1       // (degC) Window around target to start the recidency timer x degC early.
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
 
 // The minimal temperature defines the temperature below which the heater will not be enabled It is used
-// to check that the wiring to the thermistor is not broken. 
+// to check that the wiring to the thermistor is not broken.
 // Otherwise this would lead to the heater being powered on all the time.
 #define HEATER_0_MINTEMP 5
 #define HEATER_1_MINTEMP 5
@@ -118,57 +173,57 @@
 // PID settings:
 // Comment the following line to disable PID and enable bang-bang.
 #define PIDTEMP
-#define BANG_MAX 256 // limits current to nozzle while in bang-bang mode; 256=full current
-#define PID_MAX 256 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 256=full current
+#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
 #ifdef PIDTEMP
-  //#define PID_DEBUG // Sends debug data to the serial port. 
+  //#define PID_DEBUG // Sends debug data to the serial port.
   //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
   #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
-  #define K1 0.95 //smoothing factor withing the PID
+  #define K1 0.95 //smoothing factor within the PID
   #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
 
 // If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
 // Ultimaker
     #define  DEFAULT_Kp 22.2
-    #define  DEFAULT_Ki 1.08  
-    #define  DEFAULT_Kd 114  
+    #define  DEFAULT_Ki 1.08
+    #define  DEFAULT_Kd 114
 
 // Makergear
 //    #define  DEFAULT_Kp 7.0
-//    #define  DEFAULT_Ki 0.1  
-//    #define  DEFAULT_Kd 12  
+//    #define  DEFAULT_Ki 0.1
+//    #define  DEFAULT_Kd 12
 
-// Mendel Parts V9 on 12V    
+// Mendel Parts V9 on 12V
 //    #define  DEFAULT_Kp 63.0
 //    #define  DEFAULT_Ki 2.25
 //    #define  DEFAULT_Kd 440
 #endif // PIDTEMP
 
 // Bed Temperature Control
-// Select PID or bang-bang with PIDTEMPBED.  If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
 //
-// uncomment this to enable PID on the bed.   It uses the same ferquency PWM as the extruder. 
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
 // If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
 // which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
-// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater. 
-// If your configuration is significantly different than this and you don't understand the issues involved, you proabaly 
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
 // shouldn't use bed PID until someone else verifies your hardware works.
 // If this is enabled, find your own PID constants below.
 //#define PIDTEMPBED
 //
 //#define BED_LIMIT_SWITCHING
 
-// This sets the max power delived to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
 // all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
-// setting this to anything other than 256 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
 // so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
-#define MAX_BED_POWER 256 // limits duty cycle to bed; 256=full current
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
 
 #ifdef PIDTEMPBED
 //120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, argressive factor of .15 (vs .1, 1, 10)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
     #define  DEFAULT_bedKp 10.00
     #define  DEFAULT_bedKi .023
     #define  DEFAULT_bedKd 305.4
@@ -200,17 +255,17 @@
 // Uncomment the following line to enable CoreXY kinematics
 // #define COREXY
 
-// corse Endstop Settings
+// coarse Endstop Settings
 #define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
 
 #ifndef ENDSTOPPULLUPS
-  // fine Enstop settings: Individual Pullups. will be ignord if ENDSTOPPULLUPS is defined
-  #define ENDSTOPPULLUP_XMAX
-  #define ENDSTOPPULLUP_YMAX
-  #define ENDSTOPPULLUP_ZMAX
-  #define ENDSTOPPULLUP_XMIN
-  #define ENDSTOPPULLUP_YMIN
-  //#define ENDSTOPPULLUP_ZMIN
+  // fine Enstop settings: Individual Pullups. will be ignored if ENDSTOPPULLUPS is defined
+  // #define ENDSTOPPULLUP_XMAX
+  // #define ENDSTOPPULLUP_YMAX
+  // #define ENDSTOPPULLUP_ZMAX
+  // #define ENDSTOPPULLUP_XMIN
+  // #define ENDSTOPPULLUP_YMIN
+  // #define ENDSTOPPULLUP_ZMIN
 #endif
 
 #ifdef ENDSTOPPULLUPS
@@ -223,10 +278,16 @@
 #endif
 
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool X_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
-const bool Y_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
-const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops. 
+const bool X_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops.
+const bool Y_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops.
+const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of the endstops.
 //#define DISABLE_MAX_ENDSTOPS
+//#define DISABLE_MIN_ENDSTOPS
+
+// Disable max endstops for compatibility with endstop checking routine
+#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
+  #define DISABLE_MAX_ENDSTOPS
+#endif
 
 // For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
 #define X_ENABLE_ON 0
@@ -253,8 +314,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Y_HOME_DIR -1
 #define Z_HOME_DIR -1
 
-#define min_software_endstops true //If true, axis won't move to coordinates less than HOME_POS.
-#define max_software_endstops true  //If true, axis won't move to coordinates greater than the defined lengths below.
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
 // Travel limits after homing
 #define X_MAX_POS 205
 #define X_MIN_POS 0
@@ -272,22 +333,24 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 //#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
 
 //Manual homing switch locations:
+// For deltabots this means top and center of the cartesian print volume.
 #define MANUAL_X_HOME_POS 0
 #define MANUAL_Y_HOME_POS 0
 #define MANUAL_Z_HOME_POS 0
+//#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.
 
 //// MOVEMENT SETTINGS
 #define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
 #define HOMING_FEEDRATE {50*60, 50*60, 4*60, 0}  // set the homing speeds (mm/min)
 
-// default settings 
+// default settings
 
-#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for ultimaker
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for Ultimaker
 #define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 25}    // (mm/sec)
 #define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
 
-#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves 
-#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for r retracts
+#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts
 
 // Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
 // The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
@@ -295,7 +358,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 // #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-// The speed change that does not require acceleration (i.e. the software might assume it can be done instanteneously)
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
 #define DEFAULT_XYJERK                20.0    // (mm/sec)
 #define DEFAULT_ZJERK                 0.4     // (mm/sec)
 #define DEFAULT_EJERK                 5.0    // (mm/sec)
@@ -307,7 +370,7 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // EEPROM
 // the microcontroller can store settings in the EEPROM, e.g. max velocity...
 // M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
 //define this to enable eeprom support
 //#define EEPROM_SETTINGS
@@ -315,15 +378,28 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // please keep turned on if you can.
 //#define EEPROM_CHITCHAT
 
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180 
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
 //LCD and SD support
 //#define ULTRA_LCD  //general lcd support, also 16x2
-//#define DOGLCD	// Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
+//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 //#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
 
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
 
+// The MaKr3d Makr-Panel with graphic controller and SD support
+// http://reprap.org/wiki/MaKr3d_MaKrPanel
+//#define MAKRPANEL
+
 // The RepRapDiscount Smart Controller (white PCB)
 // http://reprap.org/wiki/RepRapDiscount_Smart_Controller
 //#define REPRAP_DISCOUNT_SMART_CONTROLLER
@@ -338,7 +414,25 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
 //#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
 
+// The RepRapWorld REPRAPWORLD_KEYPAD v1.1
+// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
+//#define REPRAPWORLD_KEYPAD
+//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click
+
+// The Elefu RA Board Control Panel
+// http://www.elefu.com/index.php?route=product/product&product_id=53
+// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARUDINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C
+//#define RA_CONTROL_PANEL
+
 //automatic expansion
+#if defined (MAKRPANEL)
+ #define DOGLCD
+ #define SDSUPPORT
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define DEFAULT_LCD_CONTRAST 17
+#endif
+
 #if defined (REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)
  #define DOGLCD
  #define U8GLIB_ST7920
@@ -348,44 +442,104 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
  #define ULTIPANEL
  #define NEWPANEL
-#endif 
+#endif
 
-// Preheat Constants
-#define PLA_PREHEAT_HOTEND_TEMP 180 
-#define PLA_PREHEAT_HPB_TEMP 70
-#define PLA_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+#if defined(REPRAPWORLD_KEYPAD)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+#if defined(RA_CONTROL_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define LCD_I2C_TYPE_PCA8574
+ #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+#endif
 
-#define ABS_PREHEAT_HOTEND_TEMP 240
-#define ABS_PREHEAT_HPB_TEMP 100
-#define ABS_PREHEAT_FAN_SPEED 255		// Insert Value between 0 and 255
+//I2C PANELS
 
+//#define LCD_I2C_SAINSMART_YWROBOT
+#ifdef LCD_I2C_SAINSMART_YWROBOT
+  // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )
+  // Make sure it is placed in the Arduino libraries directory.
+  #define LCD_I2C_TYPE_PCF8575
+  #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
+
+// PANELOLU2 LCD with status LEDs, separate encoder and click inputs
+//#define LCD_I2C_PANELOLU2
+#ifdef LCD_I2C_PANELOLU2
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)
+  // Note: The PANELOLU2 encoder click input can either be directly connected to a pin 
+  //       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1). 
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
+
+// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
+//#define LCD_I2C_VIKI
+#ifdef LCD_I2C_VIKI
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // Note: The pause/stop/resume LCD button pin should be connected to the Arduino
+  //       BTN_ENC pin (or set BTN_ENC to -1 if not used)
+  #define LCD_I2C_TYPE_MCP23017 
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
 
 #ifdef ULTIPANEL
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
   #define ULTRA_LCD
-	#ifdef DOGLCD	// Change number of lines to match the DOG graphic display
-		#define LCD_WIDTH 20
-		#define LCD_HEIGHT 5
-	#else
-		#define LCD_WIDTH 20
-		#define LCD_HEIGHT 4
-	#endif
-#else //no panel but just lcd 
+  #ifdef DOGLCD // Change number of lines to match the DOG graphic display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 4
+  #endif
+#else //no panel but just lcd
   #ifdef ULTRA_LCD
-	#ifdef DOGLCD	// Change number of lines to match the 128x64 graphics display
-		#define LCD_WIDTH 20
-		#define LCD_HEIGHT 5
-	#else
-		#define LCD_WIDTH 16
-		#define LCD_HEIGHT 2
-	#endif    
+  #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 16
+    #define LCD_HEIGHT 2
+  #endif
   #endif
 #endif
 
+// default LCD contrast for dogm-like LCD displays
+#ifdef DOGLCD
+# ifndef DEFAULT_LCD_CONTRAST
+#  define DEFAULT_LCD_CONTRAST 32
+# endif
+#endif
+
 // Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
 //#define FAST_PWM_FAN
 
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not ass annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
 // M240  Triggers a camera by emulating a Canon RC-1 Remote
 // Data from: http://www.doc-diy.net/photo/rc-1_hacked/
 // #define PHOTOGRAPH_PIN     23
@@ -393,6 +547,31 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 // SF send wrong arc g-codes when using Arc Point as fillet procedure
 //#define SF_ARC_FIX
 
+// Support for the BariCUDA Paste Extruder.
+//#define BARICUDA
+
+/*********************************************************************\
+* R/C SERVO support
+* Sponsored by TrinityLabs, Reworked by codexmas
+**********************************************************************/
+
+// Number of servos
+//
+// If you select a configuration below, this will receive a default value and does not need to be set manually
+// set it manually if you have more servos than extruders and wish to manually control some
+// leaving it undefined or defining as 0 will disable the servo subsystem
+// If unsure, leave commented / disabled
+//
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
+
+// Servo Endstops
+// 
+// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.
+// Use M206 command to correct for switch height offset to actual nozzle height. Store that setting with M500.
+// 
+//#define SERVO_ENDSTOPS {-1, -1, 0} // Servo index for X, Y, Z. Disable with -1
+//#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 70,0} // X,Y,Z Axis Extend and Retract angles
+
 #include "Configuration_adv.h"
 #include "thermistortables.h"
 
diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
index 4e11c44..65d0302 100644
--- a/Marlin/ConfigurationStore.cpp
+++ b/Marlin/ConfigurationStore.cpp
@@ -37,7 +37,7 @@ void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size)
 // the default values are used whenever there is a change to the data, to prevent
 // wrong data being written to the variables.
 // ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.
-#define EEPROM_VERSION "V07"
+#define EEPROM_VERSION "V08"
 
 #ifdef EEPROM_SETTINGS
 void Config_StoreSettings() 
@@ -78,6 +78,10 @@ void Config_StoreSettings()
     EEPROM_WRITE_VAR(i,dummy);
     EEPROM_WRITE_VAR(i,dummy);
   #endif
+  #ifndef DOGLCD
+    int lcd_contrast = 32;
+  #endif
+  EEPROM_WRITE_VAR(i,lcd_contrast);
   char ver2[4]=EEPROM_VERSION;
   i=EEPROM_OFFSET;
   EEPROM_WRITE_VAR(i,ver2); // validate data
@@ -198,6 +202,10 @@ void Config_RetrieveSettings()
         EEPROM_READ_VAR(i,Kp);
         EEPROM_READ_VAR(i,Ki);
         EEPROM_READ_VAR(i,Kd);
+        #ifndef DOGLCD
+        int lcd_contrast;
+        #endif
+        EEPROM_READ_VAR(i,lcd_contrast);
 
 		// Call updatePID (similar to when we have processed M301)
 		updatePID();
@@ -244,6 +252,9 @@ void Config_ResetDefault()
     absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;
     absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;
 #endif
+#ifdef DOGLCD
+    lcd_contrast = DEFAULT_LCD_CONTRAST;
+#endif
 #ifdef PIDTEMP
     Kp = DEFAULT_Kp;
     Ki = scalePID_i(DEFAULT_Ki);
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 7fc95b9..f555d60 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -18,12 +18,6 @@
 //#define WATCH_TEMP_PERIOD 40000 //40 seconds
 //#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds
 
-// Wait for Cooldown
-// This defines if the M109 call should not block if it is cooling down.
-// example: From a current temp of 220, you set M109 S200. 
-// if CooldownNoWait is defined M109 will not wait for the cooldown to finish
-#define CooldownNoWait true
-
 #ifdef PIDTEMP
   // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
   // if Kc is choosen well, the additional required power due to increased melting should be compensated.
@@ -63,21 +57,31 @@
 //This is for controlling a fan to cool down the stepper drivers
 //it will turn on when any driver is enabled
 //and turn off after the set amount of seconds from last driver being disabled again
-//#define CONTROLLERFAN_PIN 23 //Pin used for the fan to cool controller, comment out to disable this function
-#define CONTROLLERFAN_SEC 60 //How many seconds, after all motors were disabled, the fan should run
+#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)
+#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run
+#define CONTROLLERFAN_SPEED 255  // == full speed
 
 // When first starting the main fan, run it at full speed for the
 // given number of milliseconds.  This gets the fan spinning reliably
 // before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)
 //#define FAN_KICKSTART_TIME 100
 
+// Extruder cooling fans
+// Configure fan pin outputs to automatically turn on/off when the associated
+// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
+// Multiple extruders can be assigned to the same pin in which case 
+// the fan will turn on when any selected extruder is above the threshold.
+#define EXTRUDER_0_AUTO_FAN_PIN   -1
+#define EXTRUDER_1_AUTO_FAN_PIN   -1
+#define EXTRUDER_2_AUTO_FAN_PIN   -1
+#define EXTRUDER_AUTO_FAN_TEMPERATURE 50
+#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
+
+
 //===========================================================================
 //=============================Mechanical Settings===========================
 //===========================================================================
 
-// This defines the number of extruders
-#define EXTRUDERS 1
-
 #define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
 
 
@@ -142,6 +146,31 @@
   #define EXTRUDERS 1
 #endif
 
+// Enable this for dual x-carriage printers. 
+// A dual x-carriage design has the advantage that the inactive extruder can be parked which
+// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
+// allowing faster printing speeds.
+//#define DUAL_X_CARRIAGE
+#ifdef DUAL_X_CARRIAGE
+// Configuration for second X-carriage
+// Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
+// the second x-carriage always homes to the maximum endstop.
+#define X2_MIN_POS 88     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
+#define X2_MAX_POS 350.45 // set maximum to the distance between toolheads when both heads are homed 
+#define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
+    // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
+    // without modifying the firmware (through the "M218 T1 X???" command).
+    // Remember: you should set the second extruder x-offset to 0 in your slicer.
+
+// Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)
+#define X2_ENABLE_PIN 29
+#define X2_STEP_PIN 25
+#define X2_DIR_PIN 23
+
+#endif // DUAL_X_CARRIAGE
+    
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
 #define X_HOME_RETRACT_MM 5 
 #define Y_HOME_RETRACT_MM 5 
@@ -210,9 +239,9 @@
 //  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
 //#define WATCHDOG_RESET_MANUAL
 #endif
-
-// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
-//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+
+// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
+//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
 
 // extruder advance constant (s2/mm3)
 //
@@ -276,7 +305,7 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
-
+
 
 //The ASCII buffer for recieving from the serial:
 #define MAX_CMD_SIZE 96
@@ -308,6 +337,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 //===========================================================================
 //=============================  Define Defines  ============================
 //===========================================================================
+#if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
+  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+#endif
 
 #if TEMP_SENSOR_0 > 0
   #define THERMISTORHEATER_0 TEMP_SENSOR_0
diff --git a/Marlin/DOGMbitmaps.h b/Marlin/DOGMbitmaps.h
index a5d8702..984f421 100644
--- a/Marlin/DOGMbitmaps.h
+++ b/Marlin/DOGMbitmaps.h
@@ -1,7 +1,7 @@
 #define START_BMPWIDTH 	60	//Width in pixels
 #define START_BMPHEIGHT 	64	//Height in pixels
 #define START_BMPBYTEWIDTH 	8	//Width in bytes
-unsigned char start_bmp[574] PROGMEM = { //AVR-GCC, WinAVR
+const unsigned char start_bmp[574] PROGMEM = { //AVR-GCC, WinAVR
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,
 0xFF,0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xF0,
@@ -71,7 +71,7 @@ unsigned char start_bmp[574] PROGMEM = { //AVR-GCC, WinAVR
 #define STATUS_SCREENWIDTH 		115	//Width in pixels
 #define STATUS_SCREENHEIGHT 	19	//Height in pixels
 #define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes
-unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR
+const unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x0C,0x60,
@@ -96,7 +96,7 @@ unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR
 #define STATUS_SCREENWIDTH 		115	//Width in pixels
 #define STATUS_SCREENHEIGHT 	19	//Height in pixels
 #define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes
-unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR
+const unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x61,0xF8,0x60,
diff --git a/Marlin/LiquidCrystalRus.cpp b/Marlin/LiquidCrystalRus.cpp
index 4bd8de7..c193e44 100644
--- a/Marlin/LiquidCrystalRus.cpp
+++ b/Marlin/LiquidCrystalRus.cpp
@@ -36,7 +36,7 @@ const PROGMEM uint8_t utf_recode[] =
 //    S = 0; No shift 
 //
 // Note, however, that resetting the Arduino doesn't reset the LCD, so we
-// can't assume that its in that state when a sketch starts (and the
+// can't assume that it's in that state when a sketch starts (and the
 // LiquidCrystal constructor is called).
 // 
 // modified 27 Jul 2011
diff --git a/Marlin/Makefile b/Marlin/Makefile
index e09d15f..a56bc1e 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -1,12 +1,12 @@
 # Sprinter Arduino Project Makefile
-# 
+#
 # Makefile Based on:
 # Arduino 0011 Makefile
 # Arduino adaptation by mellis, eighthave, oli.keller
 # Marlin adaption by Daid
 #
 # This has been tested with Arduino 0022.
-# 
+#
 # This makefile allows you to build sketches from the command line
 # without the Arduino environment (or Java).
 #
@@ -21,7 +21,7 @@
 #     (e.g. UPLOAD_PORT = /dev/tty.USB0).  If the exact name of this file
 #     changes, you can use * as a wildcard (e.g. UPLOAD_PORT = /dev/tty.usb*).
 #
-#  3. Set the line containing "MCU" to match your board's processor. 
+#  3. Set the line containing "MCU" to match your board's processor.
 #     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
 #     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
 #     change F_CPU to 8000000. If you are using Gen7 electronics, you
@@ -44,7 +44,7 @@ ARDUINO_INSTALL_DIR  ?= ../../arduino-0022
 ARDUINO_VERSION      ?= 22
 
 # You can optionally set a path to the avr-gcc tools. Requires a trailing slash. (ex: /usr/local/avr-gcc/bin)
-AVR_TOOLS_PATH ?= 
+AVR_TOOLS_PATH ?=
 
 #Programmer configuration
 UPLOAD_RATE        ?= 115200
@@ -114,6 +114,12 @@ MCU              ?= atmega644p
 else ifeq  ($(HARDWARE_MOTHERBOARD),63)
 HARDWARE_VARIANT ?= Sanguino
 MCU              ?= atmega644p
+else ifeq  ($(HARDWARE_MOTHERBOARD),65)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega1284p
+else ifeq  ($(HARDWARE_MOTHERBOARD),66)
+HARDWARE_VARIANT ?= Sanguino
+MCU              ?= atmega1284p
 
 #Ultimaker
 else ifeq  ($(HARDWARE_MOTHERBOARD),7)
@@ -213,7 +219,7 @@ CXXSRC = WMath.cpp WString.cpp Print.cpp Marlin_main.cpp	\
 	SdFile.cpp SdVolume.cpp motion_control.cpp planner.cpp		\
 	stepper.cpp temperature.cpp cardreader.cpp ConfigurationStore.cpp \
 	watchdog.cpp
-CXXSRC += LiquidCrystal.cpp ultralcd.cpp SPI.cpp
+CXXSRC += LiquidCrystal.cpp ultralcd.cpp SPI.cpp Servo.cpp Tone.cpp
 
 #Check for Arduino 1.0.0 or higher and use the correct sourcefiles for that version
 ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
@@ -277,6 +283,7 @@ ifneq ($(HARDWARE_MOTHERBOARD),)
 CTUNING += -DMOTHERBOARD=${HARDWARE_MOTHERBOARD}
 endif
 #CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
+CEXTRA = -fno-use-cxa-atexit
 
 CFLAGS := $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CEXTRA) $(CTUNING)
 CXXFLAGS :=         $(CDEFS) $(CINCS) -O$(OPT) -Wall    $(CEXTRA) $(CTUNING)
@@ -287,7 +294,7 @@ LDFLAGS = -lm
 # Programming support using avrdude. Settings and variables.
 AVRDUDE_PORT = $(UPLOAD_PORT)
 AVRDUDE_WRITE_FLASH = -U flash:w:$(BUILD_DIR)/$(TARGET).hex:i
-AVRDUDE_FLAGS = -D -C $(ARDUINO_INSTALL_DIR)/hardware/tools/avrdude.conf \
+AVRDUDE_FLAGS = -D -C $(ARDUINO_INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
 	-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
 	-b $(UPLOAD_RATE)
 
@@ -317,19 +324,19 @@ endif
 # Default target.
 all: sizeafter
 
-build: $(BUILD_DIR) elf hex 
+build: $(BUILD_DIR) elf hex
 
 # Creates the object directory
-$(BUILD_DIR): 
+$(BUILD_DIR):
 	$P mkdir -p $(BUILD_DIR)
 
 elf: $(BUILD_DIR)/$(TARGET).elf
 hex: $(BUILD_DIR)/$(TARGET).hex
 eep: $(BUILD_DIR)/$(TARGET).eep
-lss: $(BUILD_DIR)/$(TARGET).lss 
+lss: $(BUILD_DIR)/$(TARGET).lss
 sym: $(BUILD_DIR)/$(TARGET).sym
 
-# Program the device.  
+# Program the device.
 # Do not try to reset an arduino if it's not one
 upload: $(BUILD_DIR)/$(TARGET).hex
 ifeq (${AVRDUDE_PROGRAMMER}, arduino)
@@ -356,7 +363,7 @@ COFFCONVERT=$(OBJCOPY) --debugging \
 	--change-section-address .data-0x800000 \
 	--change-section-address .bss-0x800000 \
 	--change-section-address .noinit-0x800000 \
-	--change-section-address .eeprom-0x810000 
+	--change-section-address .eeprom-0x810000
 
 
 coff: $(BUILD_DIR)/$(TARGET).elf
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 25c5aca..1ae9494 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -96,7 +96,11 @@ void process_commands();
 
 void manage_inactivity();
 
-#if X_ENABLE_PIN > -1
+#if defined(DUAL_X_CARRIAGE) && defined(X_ENABLE_PIN) && X_ENABLE_PIN > -1 \
+    && defined(X2_ENABLE_PIN) && X2_ENABLE_PIN > -1
+  #define  enable_x() do { WRITE(X_ENABLE_PIN, X_ENABLE_ON); WRITE(X2_ENABLE_PIN, X_ENABLE_ON); } while (0)
+  #define disable_x() do { WRITE(X_ENABLE_PIN,!X_ENABLE_ON); WRITE(X2_ENABLE_PIN,!X_ENABLE_ON); } while (0)
+#elif defined(X_ENABLE_PIN) && X_ENABLE_PIN > -1
   #define  enable_x() WRITE(X_ENABLE_PIN, X_ENABLE_ON)
   #define disable_x() WRITE(X_ENABLE_PIN,!X_ENABLE_ON)
 #else
@@ -104,7 +108,7 @@ void manage_inactivity();
   #define disable_x() ;
 #endif
 
-#if Y_ENABLE_PIN > -1
+#if defined(Y_ENABLE_PIN) && Y_ENABLE_PIN > -1
   #define  enable_y() WRITE(Y_ENABLE_PIN, Y_ENABLE_ON)
   #define disable_y() WRITE(Y_ENABLE_PIN,!Y_ENABLE_ON)
 #else
@@ -112,7 +116,7 @@ void manage_inactivity();
   #define disable_y() ;
 #endif
 
-#if Z_ENABLE_PIN > -1
+#if defined(Z_ENABLE_PIN) && Z_ENABLE_PIN > -1
   #ifdef Z_DUAL_STEPPER_DRIVERS
     #define  enable_z() { WRITE(Z_ENABLE_PIN, Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN, Z_ENABLE_ON); }
     #define disable_z() { WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN,!Z_ENABLE_ON); }
@@ -157,6 +161,9 @@ void FlushSerialRequestResend();
 void ClearToSend();
 
 void get_coordinates();
+#ifdef DELTA
+void calculate_delta(float cartesian[3]);
+#endif
 void prepare_move();
 void kill();
 void Stop();
@@ -186,6 +193,14 @@ extern float add_homeing[3];
 extern float min_pos[3];
 extern float max_pos[3];
 extern int fanSpeed;
+#ifdef BARICUDA
+extern int ValvePressure;
+extern int EtoPPressure;
+#endif
+
+#ifdef FAN_SOFT_PWM
+extern unsigned char fanSpeedSoftPwm;
+#endif
 
 #ifdef FWRETRACT
 extern bool autoretract_enabled;
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 4d7d0a2..2d6211c 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -34,13 +34,19 @@
 #include "pins.h"
 
 #ifdef ULTRA_LCD
-	#ifdef DOGLCD
-		#include <U8glib.h> // library for graphics LCD by Oli Kraus (https://code.google.com/p/u8glib/)
-	#else
-		#include <LiquidCrystal.h> // library for character LCD
-	#endif
+  #if defined(LCD_I2C_TYPE_PCF8575)
+    #include <Wire.h>
+    #include <LiquidCrystal_I2C.h>
+  #elif defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)
+    #include <Wire.h>
+    #include <LiquidTWI2.h>
+  #elif defined(DOGLCD)
+    #include <U8glib.h> // library for graphics LCD by Oli Kraus (https://code.google.com/p/u8glib/)
+  #else
+    #include <LiquidCrystal.h> // library for character LCD
+  #endif
 #endif
 
-#if DIGIPOTSS_PIN > -1
+#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 9f2ba7b..886edca 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -3,17 +3,17 @@
 /*
     Reprap firmware based on Sprinter and grbl.
  Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
- 
+
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
- 
+
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
- 
+
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -22,8 +22,8 @@
  This firmware is a mashup between Sprinter and grbl.
   (https://github.com/kliment/Sprinter)
   (https://github.com/simen/grbl/tree)
- 
- It has preliminary support for Matthew Roberts advance algorithm 
+
+ It has preliminary support for Matthew Roberts advance algorithm
     http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
  */
 
@@ -40,7 +40,11 @@
 #include "language.h"
 #include "pins_arduino.h"
 
-#if DIGIPOTSS_PIN > -1
+#if NUM_SERVOS > 0
+#include "Servo.h"
+#endif
+
+#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
 
@@ -63,17 +67,9 @@
 // G91 - Use Relative Coordinates
 // G92 - Set current position to cordinates given
 
-//RepRap M Codes
+// M Codes
 // M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
 // M1   - Same as M0
-// M104 - Set extruder target temp
-// M105 - Read current temp
-// M106 - Fan on
-// M107 - Fan off
-// M109 - Wait for extruder current temp to reach target temp.
-// M114 - Display current position
-
-//Custom M Codes
 // M17  - Enable/Power all stepper motors
 // M18  - Disable all stepper motors; same as M84
 // M20  - List SD card
@@ -88,21 +84,33 @@
 // M29  - Stop SD write
 // M30  - Delete file from SD (M30 filename.g)
 // M31  - Output time since last M109 or SD card start to serial
+// M32  - Select file and start SD print (Can be used when printing from SD card)
 // M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
 // M80  - Turn on Power Supply
 // M81  - Turn off Power Supply
 // M82  - Set E codes absolute (default)
 // M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-// M84  - Disable steppers until next move, 
+// M84  - Disable steppers until next move,
 //        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
 // M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
 // M92  - Set axis_steps_per_unit - same syntax as G92
-// M114 - Output current position to serial port 
-// M115	- Capabilities string
+// M104 - Set extruder target temp
+// M105 - Read current temp
+// M106 - Fan on
+// M107 - Fan off
+// M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
+//        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
+// M114 - Output current position to serial port
+// M115 - Capabilities string
 // M117 - display message
 // M119 - Output Endstop status to serial port
+// M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
+// M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
+// M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+// M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 // M140 - Set bed target temp
-// M190 - Wait for bed current temp to reach target temp.
+// M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
+//        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
 // M200 - Set filament diameter
 // M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 // M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
@@ -117,14 +125,16 @@
 // M220 S<factor in percent>- set speed factor override percentage
 // M221 S<factor in percent>- set extrude factor override percentage
 // M240 - Trigger a camera to take a photograph
+// M250 - Set LCD contrast C<contrast value> (value 0..63)
+// M280 - set servo position absolute. P: servo index, S: angle or microseconds
 // M300 - Play beepsound S<frequency Hz> P<duration ms>
 // M301 - Set PID parameters P I and D
-// M302 - Allow cold extrudes
+// M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
 // M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
 // M304 - Set bed PID parameters P I and D
 // M400 - Finish all moves
 // M500 - stores paramters in EEPROM
-// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
 // M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
 // M503 - print the current settings (from memory not from eeprom)
 // M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
@@ -160,14 +170,22 @@ float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
 float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
 // Extruder offset, only in XY plane
 #if EXTRUDERS > 1
-float extruder_offset[2][EXTRUDERS] = { 
+float extruder_offset[2][EXTRUDERS] = {
 #if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
-  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y 
+  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y
 #endif
-}; 
+};
 #endif
 uint8_t active_extruder = 0;
 int fanSpeed=0;
+#ifdef SERVO_ENDSTOPS
+  int servo_endstops[] = SERVO_ENDSTOPS;
+  int servo_endstop_angles[] = SERVO_ENDSTOP_ANGLES;
+#endif
+#ifdef BARICUDA
+int ValvePressure=0;
+int EtoPPressure=0;
+#endif
 
 #ifdef FWRETRACT
   bool autoretract_enabled=true;
@@ -176,11 +194,18 @@ int fanSpeed=0;
   float retract_recover_length=0, retract_recover_feedrate=8*60;
 #endif
 
+#ifdef ULTIPANEL
+	bool powersupply = true;
+#endif
+
 //===========================================================================
 //=============================private variables=============================
 //===========================================================================
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};
+#ifdef DELTA
+static float delta[3] = {0.0, 0.0, 0.0};
+#endif
 static float offset[3] = {0.0, 0.0, 0.0};
 static bool home_all_axis = true;
 static float feedrate = 1500.0, next_feedrate, saved_feedrate;
@@ -217,6 +242,13 @@ static uint8_t tmp_extruder;
 
 bool Stopped=false;
 
+#if NUM_SERVOS > 0
+  Servo servos[NUM_SERVOS];
+#endif
+
+bool CooldownNoWait = true;
+bool target_direction;
+
 //===========================================================================
 //=============================ROUTINES=============================
 //===========================================================================
@@ -283,49 +315,72 @@ void enquecommand_P(const char *cmd)
 
 void setup_killpin()
 {
-  #if( KILL_PIN>-1 )
+  #if defined(KILL_PIN) && KILL_PIN > -1
     pinMode(KILL_PIN,INPUT);
     WRITE(KILL_PIN,HIGH);
   #endif
 }
-    
+
 void setup_photpin()
 {
-  #ifdef PHOTOGRAPH_PIN
-    #if (PHOTOGRAPH_PIN > -1)
+  #if defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN > -1
     SET_OUTPUT(PHOTOGRAPH_PIN);
     WRITE(PHOTOGRAPH_PIN, LOW);
-    #endif
-  #endif 
+  #endif
 }
 
 void setup_powerhold()
 {
- #ifdef SUICIDE_PIN
-   #if (SUICIDE_PIN> -1)
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, HIGH);
-   #endif
- #endif
- #if (PS_ON_PIN > -1)
-   SET_OUTPUT(PS_ON_PIN);
-   WRITE(PS_ON_PIN, PS_ON_AWAKE);
- #endif
+  #if defined(SUICIDE_PIN) && SUICIDE_PIN > -1
+    SET_OUTPUT(SUICIDE_PIN);
+    WRITE(SUICIDE_PIN, HIGH);
+  #endif
+  #if defined(PS_ON_PIN) && PS_ON_PIN > -1
+    SET_OUTPUT(PS_ON_PIN);
+    WRITE(PS_ON_PIN, PS_ON_AWAKE);
+  #endif
 }
 
 void suicide()
 {
- #ifdef SUICIDE_PIN
-    #if (SUICIDE_PIN> -1) 
-      SET_OUTPUT(SUICIDE_PIN);
-      WRITE(SUICIDE_PIN, LOW);
-    #endif
+  #if defined(SUICIDE_PIN) && SUICIDE_PIN > -1
+    SET_OUTPUT(SUICIDE_PIN);
+    WRITE(SUICIDE_PIN, LOW);
+  #endif
+}
+
+void servo_init()
+{
+  #if (NUM_SERVOS >= 1) && defined(SERVO0_PIN) && (SERVO0_PIN > -1)
+    servos[0].attach(SERVO0_PIN);
+  #endif
+  #if (NUM_SERVOS >= 2) && defined(SERVO1_PIN) && (SERVO1_PIN > -1)
+    servos[1].attach(SERVO1_PIN);
+  #endif
+  #if (NUM_SERVOS >= 3) && defined(SERVO2_PIN) && (SERVO2_PIN > -1)
+    servos[2].attach(SERVO2_PIN);
+  #endif
+  #if (NUM_SERVOS >= 4) && defined(SERVO3_PIN) && (SERVO3_PIN > -1)
+    servos[3].attach(SERVO3_PIN);
+  #endif
+  #if (NUM_SERVOS >= 5)
+    #error "TODO: enter initalisation code for more servos"
+  #endif
+
+  // Set position of Servo Endstops that are defined
+  #ifdef SERVO_ENDSTOPS
+  for(int8_t i = 0; i < 3; i++)
+  {
+    if(servo_endstops[i] > -1) {
+      servos[servo_endstops[i]].write(servo_endstop_angles[i * 2 + 1]);
+    }
+  }
   #endif
 }
 
 void setup()
 {
-  setup_killpin(); 
+  setup_killpin();
   setup_powerhold();
   MYSERIAL.begin(BAUDRATE);
   SERIAL_PROTOCOLLNPGM("start");
@@ -362,25 +417,23 @@ void setup()
   {
     fromsd[i] = false;
   }
-  
+
   // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
-  Config_RetrieveSettings(); 
+  Config_RetrieveSettings();
 
-  tp_init();    // Initialize temperature loop 
+  tp_init();    // Initialize temperature loop
   plan_init();  // Initialize planner;
   watchdog_init();
   st_init();    // Initialize stepper, this enables interrupts!
   setup_photpin();
-  
+  servo_init();
+
   lcd_init();
+  _delay_ms(1000);	// wait 1sec to display the splash screen
   
-  #ifdef CONTROLLERFAN_PIN
+  #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
     SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
-  #endif
-  
-  #ifdef EXTRUDERFAN_PIN
-    SET_OUTPUT(EXTRUDERFAN_PIN); //Set pin used for extruder cooling fan
-  #endif
+  #endif 
 }
 
 
@@ -396,9 +449,9 @@ void loop()
     #ifdef SDSUPPORT
       if(card.saving)
       {
-	if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)
-	{
-	  card.write_command(cmdbuffer[bufindr]);
+        if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)
+        {
+          card.write_command(cmdbuffer[bufindr]);
           if(card.logging)
           {
             process_commands();
@@ -407,16 +460,16 @@ void loop()
           {
             SERIAL_PROTOCOLLNPGM(MSG_OK);
           }
-	}
-	else
-	{
-	  card.closefile();
-	  SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
-	}
+        }
+        else
+        {
+          card.closefile();
+          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+        }
       }
       else
       {
-	process_commands();
+        process_commands();
       }
     #else
       process_commands();
@@ -431,14 +484,14 @@ void loop()
   lcd_update();
 }
 
-void get_command() 
-{ 
+void get_command()
+{
   while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
     serial_char = MYSERIAL.read();
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1) ) 
+    if(serial_char == '\n' ||
+       serial_char == '\r' ||
+       (serial_char == ':' && comment_mode == false) ||
+       serial_count >= (MAX_CMD_SIZE - 1) )
     {
       if(!serial_count) { //if empty line
         comment_mode = false; //for new command
@@ -479,7 +532,7 @@ void get_command()
             }
             //if no errors, continue parsing
           }
-          else 
+          else
           {
             SERIAL_ERROR_START;
             SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
@@ -511,11 +564,11 @@ void get_command()
           case 2:
           case 3:
             if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.
-	      #ifdef SDSUPPORT
+          #ifdef SDSUPPORT
               if(card.saving)
                 break;
-	      #endif //SDSUPPORT
-              SERIAL_PROTOCOLLNPGM(MSG_OK); 
+          #endif //SDSUPPORT
+              SERIAL_PROTOCOLLNPGM(MSG_OK);
             }
             else {
               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
@@ -545,10 +598,10 @@ void get_command()
   while( !card.eof()  && buflen < BUFSIZE) {
     int16_t n=card.get();
     serial_char = (char)n;
-    if(serial_char == '\n' || 
-       serial_char == '\r' || 
-       (serial_char == ':' && comment_mode == false) || 
-       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
+    if(serial_char == '\n' ||
+       serial_char == '\r' ||
+       (serial_char == ':' && comment_mode == false) ||
+       serial_count >= (MAX_CMD_SIZE - 1)||n==-1)
     {
       if(card.eof()){
         SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
@@ -564,7 +617,7 @@ void get_command()
         lcd_setstatus(time);
         card.printingHasFinished();
         card.checkautostart(true);
-        
+
       }
       if(!serial_count)
       {
@@ -576,7 +629,7 @@ void get_command()
         fromsd[bufindw] = true;
         buflen += 1;
         bufindw = (bufindw + 1)%BUFSIZE;
-//      }     
+//      }
       comment_mode = false; //for new command
       serial_count = 0; //clear buffer
     }
@@ -586,20 +639,20 @@ void get_command()
       if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
     }
   }
-  
+
   #endif //SDSUPPORT
 
 }
 
 
-float code_value() 
-{ 
-  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL)); 
+float code_value()
+{
+  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL));
 }
 
-long code_value_long() 
-{ 
-  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10)); 
+long code_value_long()
+{
+  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10));
 }
 
 bool code_seen(char code)
@@ -608,17 +661,17 @@ bool code_seen(char code)
   return (strchr_pointer != NULL);  //Return True if a character was found
 }
 
-#define DEFINE_PGM_READ_ANY(type, reader)		\
-    static inline type pgm_read_any(const type *p)	\
-	{ return pgm_read_##reader##_near(p); }
+#define DEFINE_PGM_READ_ANY(type, reader)       \
+    static inline type pgm_read_any(const type *p)  \
+    { return pgm_read_##reader##_near(p); }
 
 DEFINE_PGM_READ_ANY(float,       float);
 DEFINE_PGM_READ_ANY(signed char, byte);
 
-#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG)	\
-static const PROGMEM type array##_P[3] =		\
-    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };		\
-static inline type array(int axis)			\
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
+static const PROGMEM type array##_P[3] =        \
+    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \
+static inline type array(int axis)          \
     { return pgm_read_any(&array##_P[axis]); }
 
 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);
@@ -628,7 +681,44 @@ XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
 XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
 
+#ifdef DUAL_X_CARRIAGE
+  #if EXTRUDERS == 1 || defined(COREXY) \
+      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \
+      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \
+      || !defined(X_MAX_PIN) || X_MAX_PIN < 0
+    #error "Missing or invalid definitions for DUAL_X_CARRIAGE mode."
+  #endif
+  #if X_HOME_DIR != -1 || X2_HOME_DIR != 1
+    #error "Please use canonical x-carriage assignment" // the x-carriages are defined by their homing directions
+  #endif  
+    
+static float x_home_pos(int extruder) {
+  if (extruder == 0)
+    return base_home_pos(X_AXIS) + add_homeing[X_AXIS];
+  else
+    // In dual carriage mode the extruder offset provides an override of the
+    // second X-carriage offset when homed - otherwise X2_HOME_POS is used.
+    // This allow soft recalibration of the second extruder offset position without firmware reflash 
+    // (through the M218 command).
+    return (extruder_offset[X_AXIS][1] > 0) ? extruder_offset[X_AXIS][1] : X2_HOME_POS;
+}
+
+static int x_home_dir(int extruder) {
+  return (extruder == 0) ? X_HOME_DIR : X2_HOME_DIR;
+}
+
+static float inactive_x_carriage_pos = X2_MAX_POS;
+#endif     
+
 static void axis_is_at_home(int axis) {
+#ifdef DUAL_X_CARRIAGE
+  if (axis == X_AXIS && active_extruder != 0) {
+    current_position[X_AXIS] = x_home_pos(active_extruder);
+    min_pos[X_AXIS] =          X2_MIN_POS;
+    max_pos[X_AXIS] =          max(extruder_offset[X_AXIS][1], X2_MAX_POS);
+    return;
+  }
+#endif  
   current_position[axis] = base_home_pos(axis) + add_homeing[axis];
   min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
   max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
@@ -642,28 +732,52 @@ static void homeaxis(int axis) {
       axis==Y_AXIS ? HOMEAXIS_DO(Y) :
       axis==Z_AXIS ? HOMEAXIS_DO(Z) :
       0) {
+    int axis_home_dir = home_dir(axis);
+#ifdef DUAL_X_CARRIAGE
+    if (axis == X_AXIS)
+      axis_home_dir = x_home_dir(active_extruder);
+#endif
+
+    // Engage Servo endstop if enabled
+    #ifdef SERVO_ENDSTOPS
+      if (SERVO_ENDSTOPS[axis] > -1) {
+        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2]);
+      }
+    #endif
+      
     current_position[axis] = 0;
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = 1.5 * max_length(axis) * home_dir(axis);
+    destination[axis] = 1.5 * max_length(axis) * axis_home_dir;
     feedrate = homing_feedrate[axis];
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
-   
+
     current_position[axis] = 0;
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-    destination[axis] = -home_retract_mm(axis) * home_dir(axis);
+    destination[axis] = -home_retract_mm(axis) * axis_home_dir;
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
-   
-    destination[axis] = 2*home_retract_mm(axis) * home_dir(axis);
-    feedrate = homing_feedrate[axis]/2 ; 
+
+    destination[axis] = 2*home_retract_mm(axis) * axis_home_dir;
+#ifdef DELTA
+    feedrate = homing_feedrate[axis]/10;
+#else
+    feedrate = homing_feedrate[axis]/2 ;
+#endif
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
-   
-    axis_is_at_home(axis);					
+
+    axis_is_at_home(axis);
     destination[axis] = current_position[axis];
     feedrate = 0.0;
     endstops_hit_on_purpose();
+
+    // Retract Servo endstop if enabled
+    #ifdef SERVO_ENDSTOPS
+      if (SERVO_ENDSTOPS[axis] > -1) {
+        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2 + 1]);
+      }
+    #endif
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
@@ -703,7 +817,7 @@ void process_commands()
       codenum = 0;
       if(code_seen('P')) codenum = code_value(); // milliseconds to wait
       if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
+
       st_synchronize();
       codenum += millis();  // keep track of when we started waiting
       previous_millis_cmd = millis();
@@ -713,30 +827,30 @@ void process_commands()
         lcd_update();
       }
       break;
-      #ifdef FWRETRACT  
+      #ifdef FWRETRACT
       case 10: // G10 retract
-      if(!retracted) 
+      if(!retracted)
       {
         destination[X_AXIS]=current_position[X_AXIS];
         destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
+        destination[Z_AXIS]=current_position[Z_AXIS];
         current_position[Z_AXIS]+=-retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
+        destination[E_AXIS]=current_position[E_AXIS]-retract_length;
         feedrate=retract_feedrate;
         retracted=true;
         prepare_move();
       }
-      
+
       break;
       case 11: // G10 retract_recover
-      if(!retracted) 
+      if(!retracted)
       {
         destination[X_AXIS]=current_position[X_AXIS];
         destination[Y_AXIS]=current_position[Y_AXIS];
-        destination[Z_AXIS]=current_position[Z_AXIS]; 
-        
+        destination[Z_AXIS]=current_position[Z_AXIS];
+
         current_position[Z_AXIS]+=retract_zlift;
-        current_position[E_AXIS]+=-retract_recover_length; 
+        current_position[E_AXIS]+=-retract_recover_length;
         feedrate=retract_recover_feedrate;
         retracted=false;
         prepare_move();
@@ -748,34 +862,73 @@ void process_commands()
       saved_feedmultiply = feedmultiply;
       feedmultiply = 100;
       previous_millis_cmd = millis();
-      
+
       enable_endstops(true);
-      
+
       for(int8_t i=0; i < NUM_AXIS; i++) {
         destination[i] = current_position[i];
       }
-      feedrate = 0.0;
+          feedrate = 0.0;
+
+#ifdef DELTA
+          // A delta can only safely home all axis at the same time
+          // all axis have to home at the same time
+
+          // Move all carriages up together until the first endstop is hit.
+          current_position[X_AXIS] = 0;
+          current_position[Y_AXIS] = 0;
+          current_position[Z_AXIS] = 0;
+          plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
+
+          destination[X_AXIS] = 3 * Z_MAX_LENGTH;
+          destination[Y_AXIS] = 3 * Z_MAX_LENGTH;
+          destination[Z_AXIS] = 3 * Z_MAX_LENGTH;
+          feedrate = 1.732 * homing_feedrate[X_AXIS];
+          plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
+          st_synchronize();
+          endstops_hit_on_purpose();
+
+          current_position[X_AXIS] = destination[X_AXIS];
+          current_position[Y_AXIS] = destination[Y_AXIS];
+          current_position[Z_AXIS] = destination[Z_AXIS];
+          
+          // take care of back off and rehome now we are all at the top
+          HOMEAXIS(X);
+          HOMEAXIS(Y);
+          HOMEAXIS(Z);
+
+          calculate_delta(current_position);
+          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+
+#else // NOT DELTA
+
       home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));
-      
+
       #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
       }
       #endif
-      
+
       #ifdef QUICK_HOME
       if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
       {
-        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;  
+        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;
 
-        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]); 
-        destination[X_AXIS] = 1.5 * X_MAX_LENGTH * X_HOME_DIR;destination[Y_AXIS] = 1.5 * Y_MAX_LENGTH * Y_HOME_DIR;  
-        feedrate = homing_feedrate[X_AXIS]; 
+       #ifndef DUAL_X_CARRIAGE
+        int x_axis_home_dir = home_dir(X_AXIS);
+       #else
+        int x_axis_home_dir = x_home_dir(active_extruder);
+       #endif
+        
+        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+        destination[X_AXIS] = 1.5 * max_length(X_AXIS) * x_axis_home_dir;destination[Y_AXIS] = 1.5 * max_length(Y_AXIS) * home_dir(Y_AXIS);
+        feedrate = homing_feedrate[X_AXIS];
         if(homing_feedrate[Y_AXIS]<feedrate)
-          feedrate =homing_feedrate[Y_AXIS]; 
+          feedrate =homing_feedrate[Y_AXIS];
         plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
         st_synchronize();
-    
+
         axis_is_at_home(X_AXIS);
         axis_is_at_home(Y_AXIS);
         plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
@@ -785,25 +938,36 @@ void process_commands()
         feedrate = 0.0;
         st_synchronize();
         endstops_hit_on_purpose();
+
+        current_position[X_AXIS] = destination[X_AXIS];
+        current_position[Y_AXIS] = destination[Y_AXIS];
+        current_position[Z_AXIS] = destination[Z_AXIS];
       }
       #endif
-      
-      if((home_all_axis) || (code_seen(axis_codes[X_AXIS]))) 
+
+      if((home_all_axis) || (code_seen(axis_codes[X_AXIS])))
       {
+      #ifdef DUAL_X_CARRIAGE
+        int tmp_extruder = active_extruder;
+        active_extruder = !active_extruder;
+        HOMEAXIS(X);
+        inactive_x_carriage_pos = current_position[X_AXIS];
+        active_extruder = tmp_extruder;
+      #endif         
         HOMEAXIS(X);
       }
 
       if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
         HOMEAXIS(Y);
       }
-      
+
       #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
       if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
         HOMEAXIS(Z);
       }
       #endif
-      
-      if(code_seen(axis_codes[X_AXIS])) 
+
+      if(code_seen(axis_codes[X_AXIS]))
       {
         if(code_value_long() != 0) {
           current_position[X_AXIS]=code_value()+add_homeing[0];
@@ -822,11 +986,12 @@ void process_commands()
         }
       }
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      
+#endif // else DELTA
+          
       #ifdef ENDSTOPS_ONLY_FOR_HOMING
         enable_endstops(false);
       #endif
-      
+
       feedrate = saved_feedrate;
       feedmultiply = saved_feedmultiply;
       previous_millis_cmd = millis();
@@ -842,13 +1007,13 @@ void process_commands()
       if(!code_seen(axis_codes[E_AXIS]))
         st_synchronize();
       for(int8_t i=0; i < NUM_AXIS; i++) {
-        if(code_seen(axis_codes[i])) { 
+        if(code_seen(axis_codes[i])) {
            if(i == E_AXIS) {
-             current_position[i] = code_value();  
+             current_position[i] = code_value();
              plan_set_e_position(current_position[E_AXIS]);
            }
            else {
-             current_position[i] = code_value()+add_homeing[i];  
+             current_position[i] = code_value()+add_homeing[i];
              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            }
         }
@@ -859,7 +1024,7 @@ void process_commands()
 
   else if(code_seen('M'))
   {
-    switch( (int)code_value() ) 
+    switch( (int)code_value() )
     {
 #ifdef ULTIPANEL
     case 0: // M0 - Unconditional stop - Wait for user button press on LCD
@@ -869,18 +1034,18 @@ void process_commands()
       codenum = 0;
       if(code_seen('P')) codenum = code_value(); // milliseconds to wait
       if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait
-      
+
       st_synchronize();
       previous_millis_cmd = millis();
       if (codenum > 0){
         codenum += millis();  // keep track of when we started waiting
-        while(millis()  < codenum && !LCD_CLICKED){
+        while(millis()  < codenum && !lcd_clicked()){
           manage_heater();
           manage_inactivity();
           lcd_update();
         }
       }else{
-        while(!LCD_CLICKED){
+        while(!lcd_clicked()){
           manage_heater();
           manage_inactivity();
           lcd_update();
@@ -892,12 +1057,12 @@ void process_commands()
 #endif
     case 17:
         LCD_MESSAGEPGM(MSG_NO_MOVE);
-        enable_x(); 
-        enable_y(); 
-        enable_z(); 
-        enable_e0(); 
-        enable_e1(); 
-        enable_e2(); 
+        enable_x();
+        enable_y();
+        enable_z();
+        enable_e0();
+        enable_e1();
+        enable_e2();
       break;
 
 #ifdef SDSUPPORT
@@ -907,9 +1072,9 @@ void process_commands()
       SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
       break;
     case 21: // M21 - init SD card
-      
+
       card.initsd();
-      
+
       break;
     case 22: //M22 - release SD card
       card.release();
@@ -949,18 +1114,31 @@ void process_commands()
       //processed in write to file routine above
       //card,saving = false;
       break;
-    case 30: //M30 <filename> Delete File 
-	if (card.cardOK){
-		card.closefile();
-		starpos = (strchr(strchr_pointer + 4,'*'));
-                if(starpos != NULL){
-                char* npos = strchr(cmdbuffer[bufindr], 'N');
-                strchr_pointer = strchr(npos,' ') + 1;
-                *(starpos-1) = '\0';
-         }
-	 card.removeFile(strchr_pointer + 4);
-	}
-	break;
+    case 30: //M30 <filename> Delete File
+      if (card.cardOK){
+        card.closefile();
+        starpos = (strchr(strchr_pointer + 4,'*'));
+        if(starpos != NULL){
+          char* npos = strchr(cmdbuffer[bufindr], 'N');
+          strchr_pointer = strchr(npos,' ') + 1;
+          *(starpos-1) = '\0';
+        }
+        card.removeFile(strchr_pointer + 4);
+      }
+      break;
+    case 32: //M32 - Select file and start SD print
+      if(card.sdprinting) {
+        st_synchronize();
+        card.closefile();
+        card.sdprinting = false;
+      }
+      starpos = (strchr(strchr_pointer + 4,'*'));
+      if(starpos!=NULL)
+        *(starpos-1)='\0';
+      card.openFile(strchr_pointer + 4,true);
+      card.startFileprint();
+      starttime=millis();
+      break;
     case 928: //M928 - Start SD write
       starpos = (strchr(strchr_pointer + 5,'*'));
       if(starpos != NULL){
@@ -970,7 +1148,7 @@ void process_commands()
       }
       card.openLogFile(strchr_pointer+5);
       break;
-	
+
 #endif //SDSUPPORT
 
     case 31: //M31 take time since the start of the SD print or an M109 command
@@ -1003,6 +1181,10 @@ void process_commands()
             break;
           }
         }
+      #if defined(FAN_PIN) && FAN_PIN > -1
+        if (pin_number == FAN_PIN)
+          fanSpeed = pin_status;
+      #endif
         if (pin_number > -1)
         {
           pinMode(pin_number, OUTPUT);
@@ -1024,14 +1206,14 @@ void process_commands()
     case 105 : // M105
       if(setTargetedHotend(105)){
         break;
-      }
-      #if (TEMP_0_PIN > -1)
+        }
+      #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
         SERIAL_PROTOCOLPGM("ok T:");
-        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);
         SERIAL_PROTOCOLPGM(" /");
-        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1); 
-        #if TEMP_BED_PIN > -1
-          SERIAL_PROTOCOLPGM(" B:");  
+        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1);
+        #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
+          SERIAL_PROTOCOLPGM(" B:");
           SERIAL_PROTOCOL_F(degBed(),1);
           SERIAL_PROTOCOLPGM(" /");
           SERIAL_PROTOCOL_F(degTargetBed(),1);
@@ -1042,44 +1224,50 @@ void process_commands()
       #endif
 
         SERIAL_PROTOCOLPGM(" @:");
-        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));  
+        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));
 
         SERIAL_PROTOCOLPGM(" B@:");
-        SERIAL_PROTOCOL(getHeaterPower(-1));  
+        SERIAL_PROTOCOL(getHeaterPower(-1));
 
         SERIAL_PROTOCOLLN("");
       return;
       break;
-    case 109: 
+    case 109:
     {// M109 - Wait for extruder heater to reach target.
       if(setTargetedHotend(109)){
         break;
       }
-      LCD_MESSAGEPGM(MSG_HEATING);   
+      LCD_MESSAGEPGM(MSG_HEATING);
       #ifdef AUTOTEMP
         autotemp_enabled=false;
       #endif
-      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
+      if (code_seen('S')) { 
+        setTargetHotend(code_value(), tmp_extruder);
+        CooldownNoWait = true;
+      } else if (code_seen('R')) {
+        setTargetHotend(code_value(), tmp_extruder);
+        CooldownNoWait = false;
+      }
       #ifdef AUTOTEMP
         if (code_seen('S')) autotemp_min=code_value();
         if (code_seen('B')) autotemp_max=code_value();
-        if (code_seen('F')) 
+        if (code_seen('F'))
         {
           autotemp_factor=code_value();
           autotemp_enabled=true;
         }
       #endif
-      
+
       setWatch();
-      codenum = millis(); 
+      codenum = millis();
 
       /* See if we are heating up or cooling down */
-      bool target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
+      target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
 
       #ifdef TEMP_RESIDENCY_TIME
         long residencyStart;
         residencyStart = -1;
-        /* continue to loop until we have reached the target temp   
+        /* continue to loop until we have reached the target temp
           _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
         while((residencyStart == -1) ||
               (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL))) ) {
@@ -1089,9 +1277,9 @@ void process_commands()
           if( (millis() - codenum) > 1000UL )
           { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
             SERIAL_PROTOCOLPGM("T:");
-            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1); 
+            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);
             SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)tmp_extruder); 
+            SERIAL_PROTOCOL((int)tmp_extruder);
             #ifdef TEMP_RESIDENCY_TIME
               SERIAL_PROTOCOLPGM(" W:");
               if(residencyStart > -1)
@@ -1099,7 +1287,7 @@ void process_commands()
                  codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
                  SERIAL_PROTOCOLLN( codenum );
               }
-              else 
+              else
               {
                  SERIAL_PROTOCOLLN( "?" );
               }
@@ -1116,7 +1304,7 @@ void process_commands()
               or when current temp falls outside the hysteresis after target temp was reached */
           if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
               (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
-              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) ) 
+              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) )
           {
             residencyStart = millis();
           }
@@ -1128,11 +1316,20 @@ void process_commands()
       }
       break;
     case 190: // M190 - Wait for bed heater to reach target.
-    #if TEMP_BED_PIN > -1
+    #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
         LCD_MESSAGEPGM(MSG_BED_HEATING);
-        if (code_seen('S')) setTargetBed(code_value());
-        codenum = millis(); 
-        while(isHeatingBed()) 
+        if (code_seen('S')) { 
+          setTargetBed(code_value());
+          CooldownNoWait = true;
+        } else if (code_seen('R')) {
+          setTargetBed(code_value());
+          CooldownNoWait = false;
+        }
+        codenum = millis();
+        
+        target_direction = isHeatingBed(); // true if heating, false if cooling
+        
+        while ( target_direction ? (isHeatingBed()) : (isCoolingBed()&&(CooldownNoWait==false)) )
         {
           if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
           {
@@ -1140,11 +1337,11 @@ void process_commands()
             SERIAL_PROTOCOLPGM("T:");
             SERIAL_PROTOCOL(tt);
             SERIAL_PROTOCOLPGM(" E:");
-            SERIAL_PROTOCOL((int)active_extruder); 
+            SERIAL_PROTOCOL((int)active_extruder);
             SERIAL_PROTOCOLPGM(" B:");
-            SERIAL_PROTOCOL_F(degBed(),1); 
-            SERIAL_PROTOCOLLN(""); 
-            codenum = millis(); 
+            SERIAL_PROTOCOL_F(degBed(),1);
+            SERIAL_PROTOCOLLN("");
+            codenum = millis();
           }
           manage_heater();
           manage_inactivity();
@@ -1155,38 +1352,86 @@ void process_commands()
     #endif
         break;
 
-    #if FAN_PIN > -1
+    #if defined(FAN_PIN) && FAN_PIN > -1
       case 106: //M106 Fan On
         if (code_seen('S')){
            fanSpeed=constrain(code_value(),0,255);
         }
         else {
-          fanSpeed=255;			
+          fanSpeed=255;
         }
         break;
       case 107: //M107 Fan Off
         fanSpeed = 0;
         break;
     #endif //FAN_PIN
+    #ifdef BARICUDA
+      // PWM for HEATER_1_PIN
+      #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1
+        case 126: //M126 valve open
+          if (code_seen('S')){
+             ValvePressure=constrain(code_value(),0,255);
+          }
+          else {
+            ValvePressure=255;
+          }
+          break;
+        case 127: //M127 valve closed
+          ValvePressure = 0;
+          break;
+      #endif //HEATER_1_PIN
 
-    #if (PS_ON_PIN > -1)
-      case 80: // M80 - ATX Power On
+      // PWM for HEATER_2_PIN
+      #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1
+        case 128: //M128 valve open
+          if (code_seen('S')){
+             EtoPPressure=constrain(code_value(),0,255);
+          }
+          else {
+            EtoPPressure=255;
+          }
+          break;
+        case 129: //M129 valve closed
+          EtoPPressure = 0;
+          break;
+      #endif //HEATER_2_PIN
+    #endif
+
+    #if defined(PS_ON_PIN) && PS_ON_PIN > -1
+      case 80: // M80 - Turn on Power Supply
         SET_OUTPUT(PS_ON_PIN); //GND
         WRITE(PS_ON_PIN, PS_ON_AWAKE);
+        #ifdef ULTIPANEL
+          powersupply = true;
+          LCD_MESSAGEPGM(WELCOME_MSG);
+          lcd_update();
+        #endif
         break;
       #endif
       
-      case 81: // M81 - ATX Power Off
-      
-      #if defined SUICIDE_PIN && SUICIDE_PIN > -1
+      case 81: // M81 - Turn off Power Supply
+        disable_heater();
+        st_synchronize();
+        disable_e0();
+        disable_e1();
+        disable_e2();
+        finishAndDisableSteppers();
+        fanSpeed = 0;
+        delay(1000); // Wait a little before to switch off
+      #if defined(SUICIDE_PIN) && SUICIDE_PIN > -1
         st_synchronize();
         suicide();
-      #elif (PS_ON_PIN > -1)
-        SET_OUTPUT(PS_ON_PIN); 
+      #elif defined(PS_ON_PIN) && PS_ON_PIN > -1
+        SET_OUTPUT(PS_ON_PIN);
         WRITE(PS_ON_PIN, PS_ON_ASLEEP);
       #endif
-		break;
-        
+      #ifdef ULTIPANEL
+        powersupply = false;
+        LCD_MESSAGEPGM(MACHINE_NAME" "MSG_OFF".");
+        lcd_update();
+      #endif
+	  break;
+
     case 82:
       axis_relative_modes[3] = false;
       break;
@@ -1195,11 +1440,11 @@ void process_commands()
       break;
     case 18: //compatibility
     case 84: // M84
-      if(code_seen('S')){ 
-        stepper_inactive_time = code_value() * 1000; 
+      if(code_seen('S')){
+        stepper_inactive_time = code_value() * 1000;
       }
       else
-      { 
+      {
         bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));
         if(all_axis)
         {
@@ -1221,18 +1466,18 @@ void process_commands()
               disable_e1();
               disable_e2();
             }
-          #endif 
+          #endif
         }
       }
       break;
     case 85: // M85
       code_seen('S');
-      max_inactive_time = code_value() * 1000; 
+      max_inactive_time = code_value() * 1000;
       break;
     case 92: // M92
-      for(int8_t i=0; i < NUM_AXIS; i++) 
+      for(int8_t i=0; i < NUM_AXIS; i++)
       {
-        if(code_seen(axis_codes[i])) 
+        if(code_seen(axis_codes[i]))
         {
           if(i == 3) { // E
             float value = code_value();
@@ -1266,16 +1511,16 @@ void process_commands()
       SERIAL_PROTOCOL(current_position[Y_AXIS]);
       SERIAL_PROTOCOLPGM("Z:");
       SERIAL_PROTOCOL(current_position[Z_AXIS]);
-      SERIAL_PROTOCOLPGM("E:");      
+      SERIAL_PROTOCOLPGM("E:");
       SERIAL_PROTOCOL(current_position[E_AXIS]);
-      
+
       SERIAL_PROTOCOLPGM(MSG_COUNT_X);
       SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
       SERIAL_PROTOCOLPGM("Y:");
       SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
       SERIAL_PROTOCOLPGM("Z:");
       SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
-      
+
       SERIAL_PROTOCOLLN("");
       break;
     case 120: // M120
@@ -1286,34 +1531,34 @@ void process_commands()
       break;
     case 119: // M119
     SERIAL_PROTOCOLLN(MSG_M119_REPORT);
-      #if (X_MIN_PIN > -1)
+      #if defined(X_MIN_PIN) && X_MIN_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_X_MIN);
         SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
-      #if (X_MAX_PIN > -1)
+      #if defined(X_MAX_PIN) && X_MAX_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_X_MAX);
         SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
-      #if (Y_MIN_PIN > -1)
+      #if defined(Y_MIN_PIN) && Y_MIN_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_Y_MIN);
         SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
-      #if (Y_MAX_PIN > -1)
+      #if defined(Y_MAX_PIN) && Y_MAX_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_Y_MAX);
         SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
-      #if (Z_MIN_PIN > -1)
+      #if defined(Z_MIN_PIN) && Z_MIN_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_Z_MIN);
         SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
-      #if (Z_MAX_PIN > -1)
+      #if defined(Z_MAX_PIN) && Z_MAX_PIN > -1
         SERIAL_PROTOCOLPGM(MSG_Z_MAX);
         SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_ENDSTOPS_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
       #endif
       break;
       //TODO: update for all axis, use for loop
     case 201: // M201
-      for(int8_t i=0; i < NUM_AXIS; i++) 
+      for(int8_t i=0; i < NUM_AXIS; i++)
       {
         if(code_seen(axis_codes[i]))
         {
@@ -1321,7 +1566,7 @@ void process_commands()
         }
       }
       // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
-	  reset_acceleration_rates();
+      reset_acceleration_rates();
       break;
     #if 0 // Not used for Sprinter/grbl gen6
     case 202: // M202
@@ -1352,7 +1597,7 @@ void process_commands()
     }
     break;
     case 206: // M206 additional homeing offset
-      for(int8_t i=0; i < 3; i++) 
+      for(int8_t i=0; i < 3; i++)
       {
         if(code_seen(axis_codes[i])) add_homeing[i] = code_value();
       }
@@ -1360,47 +1605,47 @@ void process_commands()
     #ifdef FWRETRACT
     case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
     {
-      if(code_seen('S')) 
+      if(code_seen('S'))
       {
         retract_length = code_value() ;
       }
-      if(code_seen('F')) 
+      if(code_seen('F'))
       {
         retract_feedrate = code_value() ;
       }
-      if(code_seen('Z')) 
+      if(code_seen('Z'))
       {
         retract_zlift = code_value() ;
       }
     }break;
     case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
     {
-      if(code_seen('S')) 
+      if(code_seen('S'))
       {
         retract_recover_length = code_value() ;
       }
-      if(code_seen('F')) 
+      if(code_seen('F'))
       {
         retract_recover_feedrate = code_value() ;
       }
     }break;
     case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
     {
-      if(code_seen('S')) 
+      if(code_seen('S'))
       {
         int t= code_value() ;
         switch(t)
         {
           case 0: autoretract_enabled=false;retracted=false;break;
           case 1: autoretract_enabled=true;retracted=false;break;
-          default: 
+          default:
             SERIAL_ECHO_START;
             SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
             SERIAL_ECHO(cmdbuffer[bufindr]);
             SERIAL_ECHOLNPGM("\"");
         }
       }
-      
+
     }break;
     #endif // FWRETRACT
     #if EXTRUDERS > 1
@@ -1409,7 +1654,7 @@ void process_commands()
       if(setTargetedHotend(218)){
         break;
       }
-      if(code_seen('X')) 
+      if(code_seen('X'))
       {
         extruder_offset[X_AXIS][tmp_extruder] = code_value();
       }
@@ -1419,7 +1664,7 @@ void process_commands()
       }
       SERIAL_ECHO_START;
       SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
-      for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++) 
+      for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++)
       {
          SERIAL_ECHO(" ");
          SERIAL_ECHO(extruder_offset[X_AXIS][tmp_extruder]);
@@ -1431,7 +1676,7 @@ void process_commands()
     #endif
     case 220: // M220 S<factor in percent>- set speed factor override percentage
     {
-      if(code_seen('S')) 
+      if(code_seen('S'))
       {
         feedmultiply = code_value() ;
       }
@@ -1439,23 +1684,63 @@ void process_commands()
     break;
     case 221: // M221 S<factor in percent>- set extrude factor override percentage
     {
-      if(code_seen('S')) 
+      if(code_seen('S'))
       {
         extrudemultiply = code_value() ;
       }
     }
     break;
     
-    #if defined(LARGE_FLASH) && LARGE_FLASH == true && defined(BEEPER) && BEEPER > -1
+    #if NUM_SERVOS > 0
+    case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
+      {
+        int servo_index = -1;
+        int servo_position = 0;
+        if (code_seen('P'))
+          servo_index = code_value();
+        if (code_seen('S')) {
+          servo_position = code_value();
+          if ((servo_index >= 0) && (servo_index < NUM_SERVOS)) {
+            servos[servo_index].write(servo_position);
+          }
+          else {
+            SERIAL_ECHO_START;
+            SERIAL_ECHO("Servo ");
+            SERIAL_ECHO(servo_index);
+            SERIAL_ECHOLN(" out of range");
+          }
+        }
+        else if (servo_index >= 0) {
+          SERIAL_PROTOCOL(MSG_OK);
+          SERIAL_PROTOCOL(" Servo ");
+          SERIAL_PROTOCOL(servo_index);
+          SERIAL_PROTOCOL(": ");
+          SERIAL_PROTOCOL(servos[servo_index].read());
+          SERIAL_PROTOCOLLN("");
+        }
+      }
+      break;
+    #endif // NUM_SERVOS > 0
+
+    #if LARGE_FLASH == true && ( BEEPER > 0 || defined(ULTRALCD) )
     case 300: // M300
     {
-      int beepS = 1;
-      int beepP = 1000;
-      if(code_seen('S')) beepS = code_value();
-      if(code_seen('P')) beepP = code_value();
-      tone(BEEPER, beepS);
-      delay(beepP);
-      noTone(BEEPER);
+      int beepS = code_seen('S') ? code_value() : 110;
+      int beepP = code_seen('P') ? code_value() : 1000;
+      if (beepS > 0)
+      {
+        #if BEEPER > 0
+          tone(BEEPER, beepS);
+          delay(beepP);
+          noTone(BEEPER);
+        #elif defined(ULTRALCD)
+          lcd_buzz(beepS, beepP);
+        #endif
+      }
+      else
+      {
+        delay(beepP);
+      }
     }
     break;
     #endif // M300
@@ -1470,10 +1755,10 @@ void process_commands()
         #ifdef PID_ADD_EXTRUSION_RATE
         if(code_seen('C')) Kc = code_value();
         #endif
-        
+
         updatePID();
         SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(" p:");
         SERIAL_PROTOCOL(Kp);
         SERIAL_PROTOCOL(" i:");
         SERIAL_PROTOCOL(unscalePID_i(Ki));
@@ -1497,7 +1782,7 @@ void process_commands()
 
         updatePID();
         SERIAL_PROTOCOL(MSG_OK);
-		SERIAL_PROTOCOL(" p:");
+        SERIAL_PROTOCOL(" p:");
         SERIAL_PROTOCOL(bedKp);
         SERIAL_PROTOCOL(" i:");
         SERIAL_PROTOCOL(unscalePID_i(bedKi));
@@ -1509,8 +1794,7 @@ void process_commands()
     #endif //PIDTEMP
     case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
      {
-      #ifdef PHOTOGRAPH_PIN
-        #if (PHOTOGRAPH_PIN > -1)
+      #if defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN > -1
         const uint8_t NUM_PULSES=16;
         const float PULSE_LENGTH=0.01524;
         for(int i=0; i < NUM_PULSES; i++) {
@@ -1526,24 +1810,38 @@ void process_commands()
           WRITE(PHOTOGRAPH_PIN, LOW);
           _delay_ms(PULSE_LENGTH);
         }
-        #endif
       #endif
      }
     break;
-      
-    case 302: // allow cold extrudes
+#ifdef DOGLCD
+    case 250: // M250  Set LCD contrast value: C<value> (value 0..63)
+     {
+	  if (code_seen('C')) {
+	   lcd_setcontrast( ((int)code_value())&63 );
+          }
+          SERIAL_PROTOCOLPGM("lcd contrast value: ");
+          SERIAL_PROTOCOL(lcd_contrast);
+          SERIAL_PROTOCOLLN("");
+     }
+    break;
+#endif
+    #ifdef PREVENT_DANGEROUS_EXTRUDE
+    case 302: // allow cold extrudes, or set the minimum extrude temperature
     {
-      allow_cold_extrudes(true);
+	  float temp = .0;
+	  if (code_seen('S')) temp=code_value();
+      set_extrude_min_temp(temp);
     }
     break;
+	#endif
     case 303: // M303 PID autotune
     {
       float temp = 150.0;
       int e=0;
       int c=5;
       if (code_seen('E')) e=code_value();
-			if (e<0)
-				temp=70;
+        if (e<0)
+          temp=70;
       if (code_seen('S')) temp=code_value();
       if (code_seen('C')) c=code_value();
       PID_autotune(temp, e, c);
@@ -1595,7 +1893,7 @@ void process_commands()
         lastpos[Z_AXIS]=current_position[Z_AXIS];
         lastpos[E_AXIS]=current_position[E_AXIS];
         //retract by E
-        if(code_seen('E')) 
+        if(code_seen('E'))
         {
           target[E_AXIS]+= code_value();
         }
@@ -1606,9 +1904,9 @@ void process_commands()
           #endif
         }
         plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
+
         //lift Z
-        if(code_seen('Z')) 
+        if(code_seen('Z'))
         {
           target[Z_AXIS]+= code_value();
         }
@@ -1619,9 +1917,9 @@ void process_commands()
           #endif
         }
         plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
+
         //move xy
-        if(code_seen('X')) 
+        if(code_seen('X'))
         {
           target[X_AXIS]+= code_value();
         }
@@ -1631,7 +1929,7 @@ void process_commands()
             target[X_AXIS]= FILAMENTCHANGE_XPOS ;
           #endif
         }
-        if(code_seen('Y')) 
+        if(code_seen('Y'))
         {
           target[Y_AXIS]= code_value();
         }
@@ -1641,9 +1939,9 @@ void process_commands()
             target[Y_AXIS]= FILAMENTCHANGE_YPOS ;
           #endif
         }
-        
+
         plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
+
         if(code_seen('L'))
         {
           target[E_AXIS]+= code_value();
@@ -1654,9 +1952,9 @@ void process_commands()
             target[E_AXIS]+= FILAMENTCHANGE_FINALRETRACT ;
           #endif
         }
-        
+
         plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);
-        
+
         //finish moves
         st_synchronize();
         //disable extruder steppers so filament can be removed
@@ -1666,27 +1964,28 @@ void process_commands()
         delay(100);
         LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);
         uint8_t cnt=0;
-        while(!LCD_CLICKED){
+        while(!lcd_clicked()){
           cnt++;
           manage_heater();
           manage_inactivity();
           lcd_update();
-          
-          #if BEEPER > -1
           if(cnt==0)
           {
+          #if BEEPER > 0
             SET_OUTPUT(BEEPER);
-            
+
             WRITE(BEEPER,HIGH);
             delay(3);
             WRITE(BEEPER,LOW);
             delay(3);
-          }
+          #else 
+            lcd_buzz(1000/6,100);
           #endif
+          }
         }
-        
+
         //return to normal
-        if(code_seen('L')) 
+        if(code_seen('L'))
         {
           target[E_AXIS]+= -code_value();
         }
@@ -1704,10 +2003,10 @@ void process_commands()
         plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], lastpos[E_AXIS], feedrate/60, active_extruder); //final untretract
     }
     break;
-    #endif //FILAMENTCHANGEENABLE    
+    #endif //FILAMENTCHANGEENABLE
     case 907: // M907 Set digital trimpot motor current using axis codes.
     {
-      #if DIGIPOTSS_PIN > -1
+      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
         for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
         if(code_seen('B')) digipot_current(4,code_value());
         if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
@@ -1716,7 +2015,7 @@ void process_commands()
     break;
     case 908: // M908 Control digital trimpot directly.
     {
-      #if DIGIPOTSS_PIN > -1
+      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
         uint8_t channel,current;
         if(code_seen('P')) channel=code_value();
         if(code_seen('S')) current=code_value();
@@ -1726,8 +2025,8 @@ void process_commands()
     break;
     case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
     {
-      #if X_MS1_PIN > -1
-        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value()); 
+      #if defined(X_MS1_PIN) && X_MS1_PIN > -1
+        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value());
         for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
         if(code_seen('B')) microstep_mode(4,code_value());
         microstep_readings();
@@ -1736,7 +2035,7 @@ void process_commands()
     break;
     case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
     {
-      #if X_MS1_PIN > -1
+      #if defined(X_MS1_PIN) && X_MS1_PIN > -1
       if(code_seen('S')) switch((int)code_value())
       {
         case 1:
@@ -1761,7 +2060,7 @@ void process_commands()
     }
   }
 
-  else if(code_seen('T')) 
+  else if(code_seen('T'))
   {
     tmp_extruder = code_value();
     if(tmp_extruder >= EXTRUDERS) {
@@ -1783,15 +2082,30 @@ void process_commands()
       if(tmp_extruder != active_extruder) {
         // Save current position to return to after applying extruder offset
         memcpy(destination, current_position, sizeof(destination));
+      #ifdef DUAL_X_CARRIAGE
+        // only apply Y extruder offset in dual x carriage mode (x offset is already used in determining home pos)
+        current_position[Y_AXIS] = current_position[Y_AXIS] -
+                     extruder_offset[Y_AXIS][active_extruder] +
+                     extruder_offset[Y_AXIS][tmp_extruder];
+
+        float tmp_x_pos = current_position[X_AXIS];
+
+        // Set the new active extruder and position
+        active_extruder = tmp_extruder;
+        axis_is_at_home(X_AXIS); //this function updates X min/max values.
+        current_position[X_AXIS] = inactive_x_carriage_pos;
+        inactive_x_carriage_pos = tmp_x_pos;      
+      #else    
         // Offset extruder (only by XY)
         int i;
         for(i = 0; i < 2; i++) {
-           current_position[i] = current_position[i] - 
+           current_position[i] = current_position[i] -
                                  extruder_offset[i][active_extruder] +
                                  extruder_offset[i][tmp_extruder];
         }
         // Set the new active extruder and position
         active_extruder = tmp_extruder;
+      #endif //else DUAL_X_CARRIAGE
         plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         // Move to the old position if 'F' was in the parameters
         if(make_move && Stopped == false) {
@@ -1832,14 +2146,14 @@ void ClearToSend()
   if(fromsd[bufindr])
     return;
   #endif //SDSUPPORT
-  SERIAL_PROTOCOLLNPGM(MSG_OK); 
+  SERIAL_PROTOCOLLNPGM(MSG_OK);
 }
 
 void get_coordinates()
 {
   bool seen[4]={false,false,false,false};
   for(int8_t i=0; i < NUM_AXIS; i++) {
-    if(code_seen(axis_codes[i])) 
+    if(code_seen(axis_codes[i]))
     {
       destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
       seen[i]=true;
@@ -1857,23 +2171,23 @@ void get_coordinates()
     float echange=destination[E_AXIS]-current_position[E_AXIS];
     if(echange<-MIN_RETRACT) //retract
     {
-      if(!retracted) 
+      if(!retracted)
       {
-      
+
       destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
       //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
       float correctede=-echange-retract_length;
       //to generate the additional steps, not the destination is changed, but inversely the current position
-      current_position[E_AXIS]+=-correctede; 
+      current_position[E_AXIS]+=-correctede;
       feedrate=retract_feedrate;
       retracted=true;
       }
-      
+
     }
-    else 
+    else
       if(echange>MIN_RETRACT) //retract_recover
     {
-      if(retracted) 
+      if(retracted)
       {
       //current_position[Z_AXIS]+=-retract_zlift;
       //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
@@ -1883,7 +2197,7 @@ void get_coordinates()
       retracted=false;
       }
     }
-    
+
   }
   #endif //FWRETRACT
 }
@@ -1901,7 +2215,7 @@ void get_arc_coordinates()
 
    if(code_seen('I')) {
      offset[0] = code_value();
-   } 
+   }
    else {
      offset[0] = 0.0;
    }
@@ -1928,11 +2242,64 @@ void clamp_to_software_endstops(float target[3])
   }
 }
 
+#ifdef DELTA
+void calculate_delta(float cartesian[3])
+{
+  delta[X_AXIS] = sqrt(sq(DELTA_DIAGONAL_ROD)
+                       - sq(DELTA_TOWER1_X-cartesian[X_AXIS])
+                       - sq(DELTA_TOWER1_Y-cartesian[Y_AXIS])
+                       ) + cartesian[Z_AXIS];
+  delta[Y_AXIS] = sqrt(sq(DELTA_DIAGONAL_ROD)
+                       - sq(DELTA_TOWER2_X-cartesian[X_AXIS])
+                       - sq(DELTA_TOWER2_Y-cartesian[Y_AXIS])
+                       ) + cartesian[Z_AXIS];
+  delta[Z_AXIS] = sqrt(sq(DELTA_DIAGONAL_ROD)
+                       - sq(DELTA_TOWER3_X-cartesian[X_AXIS])
+                       - sq(DELTA_TOWER3_Y-cartesian[Y_AXIS])
+                       ) + cartesian[Z_AXIS];
+  /*
+  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
+  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
+  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
+
+  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
+  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
+  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
+  */
+}
+#endif
+
 void prepare_move()
 {
   clamp_to_software_endstops(destination);
 
-  previous_millis_cmd = millis(); 
+  previous_millis_cmd = millis();
+#ifdef DELTA
+  float difference[NUM_AXIS];
+  for (int8_t i=0; i < NUM_AXIS; i++) {
+    difference[i] = destination[i] - current_position[i];
+  }
+  float cartesian_mm = sqrt(sq(difference[X_AXIS]) +
+                            sq(difference[Y_AXIS]) +
+                            sq(difference[Z_AXIS]));
+  if (cartesian_mm < 0.000001) { cartesian_mm = abs(difference[E_AXIS]); }
+  if (cartesian_mm < 0.000001) { return; }
+  float seconds = 6000 * cartesian_mm / feedrate / feedmultiply;
+  int steps = max(1, int(DELTA_SEGMENTS_PER_SECOND * seconds));
+  // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
+  // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
+  // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);
+  for (int s = 1; s <= steps; s++) {
+    float fraction = float(s) / float(steps);
+    for(int8_t i=0; i < NUM_AXIS; i++) {
+      destination[i] = current_position[i] + difference[i] * fraction;
+    }
+    calculate_delta(destination);
+    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
+                     destination[E_AXIS], feedrate*feedmultiply/60/100.0,
+                     active_extruder);
+  }
+#else
   // Do not use feedmultiply for E or Z only moves
   if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
       plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
@@ -1940,6 +2307,7 @@ void prepare_move()
   else {
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
   }
+#endif
   for(int8_t i=0; i < NUM_AXIS; i++) {
     current_position[i] = destination[i];
   }
@@ -1950,7 +2318,7 @@ void prepare_arc_move(char isclockwise) {
 
   // Trace the arc
   mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);
-  
+
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
@@ -1960,7 +2328,14 @@ void prepare_arc_move(char isclockwise) {
   previous_millis_cmd = millis();
 }
 
-#ifdef CONTROLLERFAN_PIN
+#if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
+
+#if defined(FAN_PIN)
+  #if CONTROLLERFAN_PIN == FAN_PIN 
+    #error "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"
+  #endif
+#endif  
+
 unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
 unsigned long lastMotorCheck = 0;
 
@@ -1969,59 +2344,44 @@ void controllerFan()
   if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
   {
     lastMotorCheck = millis();
-    
+
     if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)
     #if EXTRUDERS > 2
        || !READ(E2_ENABLE_PIN)
     #endif
     #if EXTRUDER > 1
+      #if defined(X2_ENABLE_PIN) && X2_ENABLE_PIN > -1
+       || !READ(X2_ENABLE_PIN)
+      #endif
        || !READ(E1_ENABLE_PIN)
     #endif
-       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...    
+       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...
     {
       lastMotor = millis(); //... set time to NOW so the fan will turn on
     }
     
-    if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
+    if ((millis() - lastMotor) >= (CONTROLLERFAN_SECS*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
     {
-      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
+        digitalWrite(CONTROLLERFAN_PIN, 0); 
+        analogWrite(CONTROLLERFAN_PIN, 0); 
     }
     else
     {
-      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
+        // allows digital or PWM fan output to be used (see M42 handling)
+        digitalWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);
+        analogWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED); 
     }
   }
 }
 #endif
 
-#ifdef EXTRUDERFAN_PIN
-unsigned long lastExtruderCheck = 0;
-
-void extruderFan()
+void manage_inactivity()
 {
-  if ((millis() - lastExtruderCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
-  {
-    lastExtruderCheck = millis();
-           
-    if (degHotend(active_extruder) < EXTRUDERFAN_DEC)
-    {
-      WRITE(EXTRUDERFAN_PIN, LOW); //... turn the fan off
-    }
-    else
-    {
-      WRITE(EXTRUDERFAN_PIN, HIGH); //... turn the fan on
-    }
-  }
-}
-#endif
-
-void manage_inactivity() 
-{ 
-  if( (millis() - previous_millis_cmd) >  max_inactive_time ) 
-    if(max_inactive_time) 
-      kill(); 
+  if( (millis() - previous_millis_cmd) >  max_inactive_time )
+    if(max_inactive_time)
+      kill();
   if(stepper_inactive_time)  {
-    if( (millis() - previous_millis_cmd) >  stepper_inactive_time ) 
+    if( (millis() - previous_millis_cmd) >  stepper_inactive_time )
     {
       if(blocks_queued() == false) {
         disable_x();
@@ -2033,23 +2393,23 @@ void manage_inactivity()
       }
     }
   }
-  #if( KILL_PIN>-1 )
+  #if defined(KILL_PIN) && KILL_PIN > -1
     if( 0 == READ(KILL_PIN) )
       kill();
   #endif
-  #ifdef CONTROLLERFAN_PIN
+  #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
     controllerFan(); //Check if fan should be turned on to cool stepper drivers down
   #endif
   #ifdef EXTRUDER_RUNOUT_PREVENT
-    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 ) 
+    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 )
     if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
     {
      bool oldstatus=READ(E0_ENABLE_PIN);
      enable_e0();
      float oldepos=current_position[E_AXIS];
      float oldedes=destination[E_AXIS];
-     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
-                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
+     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
+                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                       EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
      current_position[E_AXIS]=oldepos;
      destination[E_AXIS]=oldedes;
@@ -2073,8 +2433,10 @@ void kill()
   disable_e0();
   disable_e1();
   disable_e2();
-  
-  if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
+
+#if defined(PS_ON_PIN) && PS_ON_PIN > -1
+  pinMode(PS_ON_PIN,INPUT);
+#endif  
   SERIAL_ERROR_START;
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   LCD_ALERTMESSAGEPGM(MSG_KILLED);
@@ -2102,7 +2464,7 @@ void setPwmFrequency(uint8_t pin, int val)
   val &= 0x07;
   switch(digitalPinToTimer(pin))
   {
- 
+
     #if defined(TCCR0A)
     case TIMER0A:
     case TIMER0B:
@@ -2144,7 +2506,7 @@ void setPwmFrequency(uint8_t pin, int val)
          break;
     #endif
 
-    #if defined(TCCR4A) 
+    #if defined(TCCR4A)
     case TIMER4A:
     case TIMER4B:
     case TIMER4C:
@@ -2153,7 +2515,7 @@ void setPwmFrequency(uint8_t pin, int val)
          break;
    #endif
 
-    #if defined(TCCR5A) 
+    #if defined(TCCR5A)
     case TIMER5A:
     case TIMER5B:
     case TIMER5C:
@@ -2192,3 +2554,4 @@ bool setTargetedHotend(int code){
   }
   return false;
 }
+
diff --git a/Marlin/Servo.cpp b/Marlin/Servo.cpp
new file mode 100644
index 0000000..47c16aa
--- /dev/null
+++ b/Marlin/Servo.cpp
@@ -0,0 +1,341 @@
+/*
+ Servo.cpp - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
+ Copyright (c) 2009 Michael Margolis.  All right reserved.
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+
+ A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.
+ The servos are pulsed in the background using the value most recently written using the write() method
+
+ Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
+ Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.
+
+ The methods are:
+
+ Servo - Class for manipulating servo motors connected to Arduino pins.
+
+ attach(pin )  - Attaches a servo motor to an i/o pin.
+ attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds
+ default min is 544, max is 2400
+
+ write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)
+ writeMicroseconds() - Sets the servo pulse width in microseconds
+ read()      - Gets the last written servo pulse width as an angle between 0 and 180.
+ readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)
+ attached()  - Returns true if there is a servo attached.
+ detach()    - Stops an attached servos from pulsing its i/o pin.
+
+*/
+#include "Configuration.h" 
+
+#ifdef NUM_SERVOS
+#include <avr/interrupt.h>
+#include <Arduino.h>
+
+#include "Servo.h"
+
+#define usToTicks(_us)    (( clockCyclesPerMicrosecond()* _us) / 8)     // converts microseconds to tick (assumes prescale of 8)  // 12 Aug 2009
+#define ticksToUs(_ticks) (( (unsigned)_ticks * 8)/ clockCyclesPerMicrosecond() ) // converts from ticks back to microseconds
+
+
+#define TRIM_DURATION       2                               // compensation ticks to trim adjust for digitalWrite delays // 12 August 2009
+
+//#define NBR_TIMERS        (MAX_SERVOS / SERVOS_PER_TIMER)
+
+static servo_t servos[MAX_SERVOS];                          // static array of servo structures
+static volatile int8_t Channel[_Nbr_16timers ];             // counter for the servo being pulsed for each timer (or -1 if refresh interval)
+
+uint8_t ServoCount = 0;                                     // the total number of attached servos
+
+
+// convenience macros
+#define SERVO_INDEX_TO_TIMER(_servo_nbr) ((timer16_Sequence_t)(_servo_nbr / SERVOS_PER_TIMER)) // returns the timer controlling this servo
+#define SERVO_INDEX_TO_CHANNEL(_servo_nbr) (_servo_nbr % SERVOS_PER_TIMER)       // returns the index of the servo on this timer
+#define SERVO_INDEX(_timer,_channel)  ((_timer*SERVOS_PER_TIMER) + _channel)     // macro to access servo index by timer and channel
+#define SERVO(_timer,_channel)  (servos[SERVO_INDEX(_timer,_channel)])            // macro to access servo class by timer and channel
+
+#define SERVO_MIN() (MIN_PULSE_WIDTH - this->min * 4)  // minimum value in uS for this servo
+#define SERVO_MAX() (MAX_PULSE_WIDTH - this->max * 4)  // maximum value in uS for this servo
+
+/************ static functions common to all instances ***********************/
+
+static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
+{
+  if( Channel[timer] < 0 )
+    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer
+  else{
+    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )
+      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated
+  }
+
+  Channel[timer]++;    // increment to the next channel
+  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
+    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
+    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
+      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
+  }
+  else {
+    // finished all channels so wait for the refresh period to expire before starting over
+    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
+      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);
+    else
+      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
+    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
+  }
+}
+
+#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
+// Interrupt handlers for Arduino
+#if defined(_useTimer1)
+SIGNAL (TIMER1_COMPA_vect)
+{
+  handle_interrupts(_timer1, &TCNT1, &OCR1A);
+}
+#endif
+
+#if defined(_useTimer3)
+SIGNAL (TIMER3_COMPA_vect)
+{
+  handle_interrupts(_timer3, &TCNT3, &OCR3A);
+}
+#endif
+
+#if defined(_useTimer4)
+SIGNAL (TIMER4_COMPA_vect)
+{
+  handle_interrupts(_timer4, &TCNT4, &OCR4A);
+}
+#endif
+
+#if defined(_useTimer5)
+SIGNAL (TIMER5_COMPA_vect)
+{
+  handle_interrupts(_timer5, &TCNT5, &OCR5A);
+}
+#endif
+
+#elif defined WIRING
+// Interrupt handlers for Wiring
+#if defined(_useTimer1)
+void Timer1Service()
+{
+  handle_interrupts(_timer1, &TCNT1, &OCR1A);
+}
+#endif
+#if defined(_useTimer3)
+void Timer3Service()
+{
+  handle_interrupts(_timer3, &TCNT3, &OCR3A);
+}
+#endif
+#endif
+
+
+static void initISR(timer16_Sequence_t timer)
+{
+#if defined (_useTimer1)
+  if(timer == _timer1) {
+    TCCR1A = 0;             // normal counting mode
+    TCCR1B = _BV(CS11);     // set prescaler of 8
+    TCNT1 = 0;              // clear the timer count
+#if defined(__AVR_ATmega8__)|| defined(__AVR_ATmega128__)
+    TIFR |= _BV(OCF1A);      // clear any pending interrupts;
+    TIMSK |=  _BV(OCIE1A) ;  // enable the output compare interrupt
+#else
+    // here if not ATmega8 or ATmega128
+    TIFR1 |= _BV(OCF1A);     // clear any pending interrupts;
+    TIMSK1 |=  _BV(OCIE1A) ; // enable the output compare interrupt
+#endif
+#if defined(WIRING)
+    timerAttach(TIMER1OUTCOMPAREA_INT, Timer1Service);
+#endif
+  }
+#endif
+
+#if defined (_useTimer3)
+  if(timer == _timer3) {
+    TCCR3A = 0;             // normal counting mode
+    TCCR3B = _BV(CS31);     // set prescaler of 8
+    TCNT3 = 0;              // clear the timer count
+#if defined(__AVR_ATmega128__)
+    TIFR |= _BV(OCF3A);     // clear any pending interrupts;
+	ETIMSK |= _BV(OCIE3A);  // enable the output compare interrupt
+#else
+    TIFR3 = _BV(OCF3A);     // clear any pending interrupts;
+    TIMSK3 =  _BV(OCIE3A) ; // enable the output compare interrupt
+#endif
+#if defined(WIRING)
+    timerAttach(TIMER3OUTCOMPAREA_INT, Timer3Service);  // for Wiring platform only
+#endif
+  }
+#endif
+
+#if defined (_useTimer4)
+  if(timer == _timer4) {
+    TCCR4A = 0;             // normal counting mode
+    TCCR4B = _BV(CS41);     // set prescaler of 8
+    TCNT4 = 0;              // clear the timer count
+    TIFR4 = _BV(OCF4A);     // clear any pending interrupts;
+    TIMSK4 =  _BV(OCIE4A) ; // enable the output compare interrupt
+  }
+#endif
+
+#if defined (_useTimer5)
+  if(timer == _timer5) {
+    TCCR5A = 0;             // normal counting mode
+    TCCR5B = _BV(CS51);     // set prescaler of 8
+    TCNT5 = 0;              // clear the timer count
+    TIFR5 = _BV(OCF5A);     // clear any pending interrupts;
+    TIMSK5 =  _BV(OCIE5A) ; // enable the output compare interrupt
+  }
+#endif
+}
+
+static void finISR(timer16_Sequence_t timer)
+{
+    //disable use of the given timer
+#if defined WIRING   // Wiring
+  if(timer == _timer1) {
+    #if defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)
+    TIMSK1 &=  ~_BV(OCIE1A) ;  // disable timer 1 output compare interrupt
+    #else
+    TIMSK &=  ~_BV(OCIE1A) ;  // disable timer 1 output compare interrupt
+    #endif
+    timerDetach(TIMER1OUTCOMPAREA_INT);
+  }
+  else if(timer == _timer3) {
+    #if defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)
+    TIMSK3 &= ~_BV(OCIE3A);    // disable the timer3 output compare A interrupt
+    #else
+    ETIMSK &= ~_BV(OCIE3A);    // disable the timer3 output compare A interrupt
+    #endif
+    timerDetach(TIMER3OUTCOMPAREA_INT);
+  }
+#else
+    //For arduino - in future: call here to a currently undefined function to reset the timer
+#endif
+}
+
+static boolean isTimerActive(timer16_Sequence_t timer)
+{
+  // returns true if any servo is active on this timer
+  for(uint8_t channel=0; channel < SERVOS_PER_TIMER; channel++) {
+    if(SERVO(timer,channel).Pin.isActive == true)
+      return true;
+  }
+  return false;
+}
+
+
+/****************** end of static functions ******************************/
+
+Servo::Servo()
+{
+  if( ServoCount < MAX_SERVOS) {
+    this->servoIndex = ServoCount++;                    // assign a servo index to this instance
+	servos[this->servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);   // store default values  - 12 Aug 2009
+  }
+  else
+    this->servoIndex = INVALID_SERVO ;  // too many servos
+}
+
+uint8_t Servo::attach(int pin)
+{
+  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
+}
+
+uint8_t Servo::attach(int pin, int min, int max)
+{
+  if(this->servoIndex < MAX_SERVOS ) {
+    pinMode( pin, OUTPUT) ;                                   // set servo pin to output
+    servos[this->servoIndex].Pin.nbr = pin;
+    // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 < 128
+    this->min  = (MIN_PULSE_WIDTH - min)/4; //resolution of min/max is 4 uS
+    this->max  = (MAX_PULSE_WIDTH - max)/4;
+    // initialize the timer if it has not already been initialized
+    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
+    if(isTimerActive(timer) == false)
+      initISR(timer);
+    servos[this->servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive
+  }
+  return this->servoIndex ;
+}
+
+void Servo::detach()
+{
+  servos[this->servoIndex].Pin.isActive = false;
+  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
+  if(isTimerActive(timer) == false) {
+    finISR(timer);
+  }
+}
+
+void Servo::write(int value)
+{
+  if(value < MIN_PULSE_WIDTH)
+  {  // treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
+    if(value < 0) value = 0;
+    if(value > 180) value = 180;
+    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());
+  }
+  this->writeMicroseconds(value);
+}
+
+void Servo::writeMicroseconds(int value)
+{
+  // calculate and store the values for the given channel
+  byte channel = this->servoIndex;
+  if( (channel < MAX_SERVOS) )   // ensure channel is valid
+  {
+    if( value < SERVO_MIN() )          // ensure pulse width is valid
+      value = SERVO_MIN();
+    else if( value > SERVO_MAX() )
+      value = SERVO_MAX();
+
+  	value = value - TRIM_DURATION;
+    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009
+
+    uint8_t oldSREG = SREG;
+    cli();
+    servos[channel].ticks = value;
+    SREG = oldSREG;
+  }
+}
+
+int Servo::read() // return the value as degrees
+{
+  return  map( this->readMicroseconds()+1, SERVO_MIN(), SERVO_MAX(), 0, 180);
+}
+
+int Servo::readMicroseconds()
+{
+  unsigned int pulsewidth;
+  if( this->servoIndex != INVALID_SERVO )
+    pulsewidth = ticksToUs(servos[this->servoIndex].ticks)  + TRIM_DURATION ;   // 12 aug 2009
+  else
+    pulsewidth  = 0;
+
+  return pulsewidth;
+}
+
+bool Servo::attached()
+{
+  return servos[this->servoIndex].Pin.isActive ;
+}
+
+#endif
diff --git a/Marlin/Servo.h b/Marlin/Servo.h
new file mode 100644
index 0000000..17c99f7
--- /dev/null
+++ b/Marlin/Servo.h
@@ -0,0 +1,132 @@
+/*
+  Servo.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
+  Copyright (c) 2009 Michael Margolis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+/*
+
+  A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.
+  The servos are pulsed in the background using the value most recently written using the write() method
+
+  Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
+  Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.
+  The sequence used to sieze timers is defined in timers.h
+
+  The methods are:
+
+   Servo - Class for manipulating servo motors connected to Arduino pins.
+
+   attach(pin )  - Attaches a servo motor to an i/o pin.
+   attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds
+   default min is 544, max is 2400
+
+   write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)
+   writeMicroseconds() - Sets the servo pulse width in microseconds
+   read()      - Gets the last written servo pulse width as an angle between 0 and 180.
+   readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)
+   attached()  - Returns true if there is a servo attached.
+   detach()    - Stops an attached servos from pulsing its i/o pin.
+ */
+
+#ifndef Servo_h
+#define Servo_h
+
+#include <inttypes.h>
+
+/*
+ * Defines for 16 bit timers used with  Servo library
+ *
+ * If _useTimerX is defined then TimerX is a 16 bit timer on the curent board
+ * timer16_Sequence_t enumerates the sequence that the timers should be allocated
+ * _Nbr_16timers indicates how many 16 bit timers are available.
+ *
+ */
+
+// Say which 16 bit timers can be used and in what order
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define _useTimer5
+//#define _useTimer1
+#define _useTimer3
+#define _useTimer4
+//typedef enum { _timer5, _timer1, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;
+typedef enum { _timer5, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;
+
+#elif defined(__AVR_ATmega32U4__)
+//#define _useTimer1
+#define _useTimer3
+//typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;
+typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;
+
+#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)
+#define _useTimer3
+//#define _useTimer1
+//typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;
+typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;
+
+#elif defined(__AVR_ATmega128__) ||defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)
+#define _useTimer3
+//#define _useTimer1
+//typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;
+typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;
+
+#else  // everything else
+//#define _useTimer1
+//typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;
+typedef enum { _Nbr_16timers } timer16_Sequence_t ;
+#endif
+
+#define Servo_VERSION           2      // software version of this library
+
+#define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo
+#define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo
+#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
+#define REFRESH_INTERVAL    20000     // minumim time to refresh servos in microseconds
+
+#define SERVOS_PER_TIMER       12     // the maximum number of servos controlled by one timer
+#define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)
+
+#define INVALID_SERVO         255     // flag indicating an invalid servo index
+
+typedef struct  {
+  uint8_t nbr        :6 ;             // a pin number from 0 to 63
+  uint8_t isActive   :1 ;             // true if this channel is enabled, pin not pulsed if false
+} ServoPin_t   ;
+
+typedef struct {
+  ServoPin_t Pin;
+  unsigned int ticks;
+} servo_t;
+
+class Servo
+{
+public:
+  Servo();
+  uint8_t attach(int pin);           // attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure
+  uint8_t attach(int pin, int min, int max); // as above but also sets min and max values for writes.
+  void detach();
+  void write(int value);             // if value is < 200 its treated as an angle, otherwise as pulse width in microseconds
+  void writeMicroseconds(int value); // Write pulse width in microseconds
+  int read();                        // returns current pulse width as an angle between 0 and 180 degrees
+  int readMicroseconds();            // returns current pulse width in microseconds for this servo (was read_us() in first release)
+  bool attached();                   // return true if this servo is attached, otherwise false
+private:
+   uint8_t servoIndex;               // index into the channel data for this servo
+   int8_t min;                       // minimum is this value times 4 added to MIN_PULSE_WIDTH
+   int8_t max;                       // maximum is this value times 4 added to MAX_PULSE_WIDTH
+};
+
+#endif
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 89a77b9..1eeec91 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -18,6 +18,8 @@ CardReader::CardReader()
    saving = false;
    logging = false;
    autostart_atmillis=0;
+   workDirDepth = 0;
+   memset(workDirParents, 0, sizeof(workDirParents));
 
    autostart_stilltocheck=true; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
    lastnr=0;
@@ -204,7 +206,6 @@ void CardReader::startFileprint()
   if(cardOK)
   {
     sdprinting = true;
-    
   }
 }
 
@@ -521,19 +522,24 @@ void CardReader::chdir(const char * relpath)
   }
   else
   {
-    workDirParentParent=workDirParent;
-    workDirParent=*parent;
-    
+    if (workDirDepth < MAX_DIR_DEPTH) {
+      for (int d = ++workDirDepth; d--;)
+        workDirParents[d+1] = workDirParents[d];
+      workDirParents[0]=*parent;
+    }
     workDir=newfile;
   }
 }
 
 void CardReader::updir()
 {
-  if(!workDir.isRoot())
+  if(workDirDepth > 0)
   {
-    workDir=workDirParent;
-    workDirParent=workDirParentParent;
+    --workDirDepth;
+    workDir = workDirParents[0];
+    int d;
+    for (int d = 0; d < workDirDepth; d++)
+      workDirParents[d] = workDirParents[d+1];
   }
 }
 
diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index fe5c8b7..6e59645 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -3,6 +3,8 @@
 
 #ifdef SDSUPPORT
 
+#define MAX_DIR_DEPTH 10
+
 #include "SdFile.h"
 enum LsAction {LS_SerialPrint,LS_Count,LS_GetFilename};
 class CardReader
@@ -53,7 +55,8 @@ public:
   bool filenameIsDir;
   int lastnr; //last number of the autostart;
 private:
-  SdFile root,*curDir,workDir,workDirParent,workDirParentParent;
+  SdFile root,*curDir,workDir,workDirParents[MAX_DIR_DEPTH];
+  uint16_t workDirDepth;
   Sd2Card card;
   SdVolume volume;
   SdFile file;
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index c5192e7..8d450cb 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -19,12 +19,25 @@
 * Implementation of the LCD display routines for a DOGM128 graphic display. These are common LCD 128x64 pixel graphic displays.
 **/
 
+#ifdef ULTIPANEL
+#define BLEN_A 0
+#define BLEN_B 1
+#define BLEN_C 2
+#define EN_A (1<<BLEN_A)
+#define EN_B (1<<BLEN_B)
+#define EN_C (1<<BLEN_C)
+#define encrot0 0
+#define encrot1 2
+#define encrot2 3
+#define encrot3 1
+#define LCD_CLICKED (buttons&EN_C)
+#endif
 
-// CHANGE_DE begin ***
-#include <U8glib.h>	// DE_U8glib
+#include <U8glib.h>
 #include "DOGMbitmaps.h"
 #include "dogm_font_data_marlin.h"
 #include "ultralcd.h"
+#include "ultralcd_st7920_u8glib_rrd.h"
 
 
 /* Russian language not supported yet, needs custom font
@@ -61,17 +74,28 @@
 
 #define FONT_STATUSMENU	u8g_font_6x9
 
+int lcd_contrast;
 
 // LCD selection
 #ifdef U8GLIB_ST7920
-// SPI Com: SCK = en = (D4), MOSI = rw = (RS), CS = di = (ENABLE)
-U8GLIB_ST7920_128X64_1X u8g(LCD_PINS_D4, LCD_PINS_ENABLE, LCD_PINS_RS);
+//U8GLIB_ST7920_128X64_RRD u8g(0,0,0);
+U8GLIB_ST7920_128X64_RRD u8g(0);
+#elif defined(MAKRPANEL)
+// The MaKrPanel display, ST7565 controller as well
+U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);
 #else
+// for regular DOGM128 display with HW-SPI
 U8GLIB_DOGM128 u8g(DOGLCD_CS, DOGLCD_A0);	// HW-SPI Com: CS, A0
 #endif
 
 static void lcd_implementation_init()
 {
+#ifdef LCD_PIN_BL
+	pinMode(LCD_PIN_BL, OUTPUT);	// Enable LCD backlight
+	digitalWrite(LCD_PIN_BL, HIGH);
+#endif
+
+        u8g.setContrast(lcd_contrast);	
 	//  Uncomment this if you have the first generation (V1.10) of STBs board
 	//  pinMode(17, OUTPUT);	// Enable LCD backlight
 	//  digitalWrite(17, HIGH);
@@ -88,11 +112,11 @@ static void lcd_implementation_init()
 	u8g.setRot90();	// Rotate screen by 90°
 #endif
 
-#ifdef LCD_SCREEN_ROT_180;
+#ifdef LCD_SCREEN_ROT_180
 	u8g.setRot180();	// Rotate screen by 180°
 #endif
 
-#ifdef LCD_SCREEN_ROT_270;
+#ifdef LCD_SCREEN_ROT_270
 	u8g.setRot270();	// Rotate screen by 270°
 #endif
 
@@ -105,14 +129,14 @@ static void lcd_implementation_init()
 			u8g.setFont(u8g_font_6x10_marlin);
 			u8g.drawStr(62,10,"MARLIN"); 
 			u8g.setFont(u8g_font_5x8);
-			u8g.drawStr(62,19,"V1.0.0 RC2");
+			u8g.drawStr(62,19,"V1.0.0 RC2-mm");
 			u8g.setFont(u8g_font_6x10_marlin);
 			u8g.drawStr(62,28,"by ErikZalm");
 			u8g.drawStr(62,41,"DOGM128 LCD");
 			u8g.setFont(u8g_font_5x8);
 			u8g.drawStr(62,48,"enhancements");
 			u8g.setFont(u8g_font_5x8);
-			u8g.drawStr(62,55,"by STB");
+			u8g.drawStr(62,55,"by STB, MM");
 			u8g.drawStr(62,61,"uses u");
 			u8g.drawStr90(92,57,"8");
 			u8g.drawStr(100,61,"glib");
@@ -266,7 +290,7 @@ static void lcd_implementation_status_screen()
  // Fan
  u8g.setFont(FONT_STATUSMENU);
  u8g.setPrintPos(104,27);
- #if FAN_PIN > 0
+ #if defined(FAN_PIN) && FAN_PIN > -1
  u8g.print(itostr3(int((fanSpeed*100)/256 + 1)));
  u8g.print("%");
  #else
diff --git a/Marlin/example_configurations/delta/Configuration.h b/Marlin/example_configurations/delta/Configuration.h
new file mode 100644
index 0000000..7fbb4d8
--- /dev/null
+++ b/Marlin/example_configurations/delta/Configuration.h
@@ -0,0 +1,585 @@
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+// This configuration file contains the basic settings.
+// Advanced settings can be found in Configuration_adv.h
+// BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
+
+// User-specified version info of this build to display in [Pronterface, etc] terminal window during
+// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
+// build by the user have been successfully uploaded into firmware.
+#define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time
+#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
+
+// SERIAL_PORT selects which serial port should be used for communication with the host.
+// This allows the connection of wireless adapters (for instance) to non-default port pins.
+// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
+#define SERIAL_PORT 0
+
+// This determines the communication speed of the printer
+#define BAUDRATE 250000
+//#define BAUDRATE 115200
+
+//// The following define selects which electronics board you have. Please choose the one that matches your setup
+// 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"
+// 11 = Gen7 v1.1, v1.2 = 11
+// 12 = Gen7 v1.3
+// 13 = Gen7 v1.4
+// 3  = MEGA/RAMPS up to 1.2 = 3
+// 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
+// 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
+// 35 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)
+// 4  = Duemilanove w/ ATMega328P pin assignment
+// 5  = Gen6
+// 51 = Gen6 deluxe
+// 6  = Sanguinololu < 1.2
+// 62 = Sanguinololu 1.2 and above
+// 63 = Melzi
+// 64 = STB V1.1
+// 65 = Azteeg X1
+// 66 = Melzi with ATmega1284 (MaKr3d version)
+// 7  = Ultimaker
+// 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
+// 77 = 3Drag Controller
+// 8  = Teensylu
+// 80 = Rumba
+// 81 = Printrboard (AT90USB1286)
+// 82 = Brainwave (AT90USB646)
+// 9  = Gen3+
+// 70 = Megatronics
+// 701= Megatronics v2.0
+// 702= Minitronics v1.0
+// 90 = Alpha OMCA board
+// 91 = Final OMCA board
+// 301 = Rambo
+// 21 = Elefu Ra Board (v3)
+
+#ifndef MOTHERBOARD
+#define MOTHERBOARD 33
+#endif
+
+// Define this to set a custom name for your generic Mendel,
+// #define CUSTOM_MENDEL_NAME "This Mendel"
+
+// This defines the number of extruders
+#define EXTRUDERS 1
+
+//// The following define selects which power supply you have. Please choose the one that matches your setup
+// 1 = ATX
+// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+
+#define POWER_SUPPLY 1
+
+
+//===========================================================================
+//============================== Delta Settings =============================
+//===========================================================================
+// Enable DELTA kinematics and most of the default configuration for Deltas
+#define DELTA
+
+// Make delta curves from many straight lines (linear interpolation).
+// This is a trade-off between visible corners (not enough segments)
+// and processor overload (too many expensive sqrt calls).
+#define DELTA_SEGMENTS_PER_SECOND 200
+
+// Center-to-center distance of the holes in the diagonal push rods.
+#define DELTA_DIAGONAL_ROD 250.0 // mm
+
+// Horizontal offset from middle of printer to smooth rod center.
+#define DELTA_SMOOTH_ROD_OFFSET 175.0 // mm
+
+// Horizontal offset of the universal joints on the end effector.
+#define DELTA_EFFECTOR_OFFSET 33.0 // mm
+
+// Horizontal offset of the universal joints on the carriages.
+#define DELTA_CARRIAGE_OFFSET 18.0 // mm
+
+// Effective horizontal distance bridged by diagonal push rods.
+#define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-DELTA_EFFECTOR_OFFSET-DELTA_CARRIAGE_OFFSET)
+
+// Effective X/Y positions of the three vertical towers.
+#define SIN_60 0.8660254037844386
+#define COS_60 0.5
+#define DELTA_TOWER1_X -SIN_60*DELTA_RADIUS // front left tower
+#define DELTA_TOWER1_Y -COS_60*DELTA_RADIUS
+#define DELTA_TOWER2_X SIN_60*DELTA_RADIUS // front right tower
+#define DELTA_TOWER2_Y -COS_60*DELTA_RADIUS
+#define DELTA_TOWER3_X 0.0 // back middle tower
+#define DELTA_TOWER3_Y DELTA_RADIUS
+
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
+//
+//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table
+//
+//// Temperature sensor settings:
+// -2 is thermocouple with MAX6675 (only for sensor 0)
+// -1 is thermocouple with AD595
+// 0 is not used
+// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)
+// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
+// 3 is mendel-parts thermistor (4.7k pullup)
+// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
+// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan) (4.7k pullup)
+// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
+// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
+// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
+// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
+// 10 is 100k RS thermistor 198-961 (4.7k pullup)
+// 60 is 100k Maker's Tool Works Kapton Bed Thermister
+//
+//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k
+//                          (but gives greater accuracy and more stable PID)
+// 51 is 100k thermistor - EPCOS (1k pullup)
+// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
+// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan) (1k pullup)
+
+#define TEMP_SENSOR_0 -1
+#define TEMP_SENSOR_1 -1
+#define TEMP_SENSOR_2 0
+#define TEMP_SENSOR_BED 0
+
+// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.
+//#define TEMP_SENSOR_1_AS_REDUNDANT 
+#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10
+
+// Actual temperature must be close to target for this long before M109 returns success
+#define TEMP_RESIDENCY_TIME 10  // (seconds)
+#define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
+#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
+
+// The minimal temperature defines the temperature below which the heater will not be enabled It is used
+// to check that the wiring to the thermistor is not broken.
+// Otherwise this would lead to the heater being powered on all the time.
+#define HEATER_0_MINTEMP 5
+#define HEATER_1_MINTEMP 5
+#define HEATER_2_MINTEMP 5
+#define BED_MINTEMP 5
+
+// When temperature exceeds max temp, your heater will be switched off.
+// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!
+// You should use MINTEMP for thermistor short/failure protection.
+#define HEATER_0_MAXTEMP 275
+#define HEATER_1_MAXTEMP 275
+#define HEATER_2_MAXTEMP 275
+#define BED_MAXTEMP 150
+
+// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the
+// average current. The value should be an integer and the heat bed will be turned on for 1 interval of
+// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.
+//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4
+
+// PID settings:
+// Comment the following line to disable PID and enable bang-bang.
+#define PIDTEMP
+#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current
+#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
+#ifdef PIDTEMP
+  //#define PID_DEBUG // Sends debug data to the serial port.
+  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
+  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
+                                  // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
+  #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term
+  #define K1 0.95 //smoothing factor within the PID
+  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine
+
+// If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it
+// Ultimaker
+    #define  DEFAULT_Kp 22.2
+    #define  DEFAULT_Ki 1.08
+    #define  DEFAULT_Kd 114
+
+// Makergear
+//    #define  DEFAULT_Kp 7.0
+//    #define  DEFAULT_Ki 0.1
+//    #define  DEFAULT_Kd 12
+
+// Mendel Parts V9 on 12V
+//    #define  DEFAULT_Kp 63.0
+//    #define  DEFAULT_Ki 2.25
+//    #define  DEFAULT_Kd 440
+#endif // PIDTEMP
+
+// Bed Temperature Control
+// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis
+//
+// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.
+// If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,
+// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.
+// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.
+// If your configuration is significantly different than this and you don't understand the issues involved, you probably
+// shouldn't use bed PID until someone else verifies your hardware works.
+// If this is enabled, find your own PID constants below.
+//#define PIDTEMPBED
+//
+//#define BED_LIMIT_SWITCHING
+
+// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.
+// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)
+// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,
+// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)
+#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
+
+#ifdef PIDTEMPBED
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
+    #define  DEFAULT_bedKp 10.00
+    #define  DEFAULT_bedKi .023
+    #define  DEFAULT_bedKd 305.4
+
+//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
+//from pidautotune
+//    #define  DEFAULT_bedKp 97.1
+//    #define  DEFAULT_bedKi 1.41
+//    #define  DEFAULT_bedKd 1675.16
+
+// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
+#endif // PIDTEMPBED
+
+
+
+//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit
+//can be software-disabled for whatever purposes by
+#define PREVENT_DANGEROUS_EXTRUDE
+//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.
+#define PREVENT_LENGTHY_EXTRUDE
+
+#define EXTRUDE_MINTEMP 170
+#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+// Uncomment the following line to enable CoreXY kinematics
+// #define COREXY
+
+// coarse Endstop Settings
+#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors
+
+#ifndef ENDSTOPPULLUPS
+  // fine Enstop settings: Individual Pullups. will be ignored if ENDSTOPPULLUPS is defined
+  // #define ENDSTOPPULLUP_XMAX
+  // #define ENDSTOPPULLUP_YMAX
+  // #define ENDSTOPPULLUP_ZMAX
+  // #define ENDSTOPPULLUP_XMIN
+  // #define ENDSTOPPULLUP_YMIN
+  // #define ENDSTOPPULLUP_ZMIN
+#endif
+
+#ifdef ENDSTOPPULLUPS
+  #define ENDSTOPPULLUP_XMAX
+  #define ENDSTOPPULLUP_YMAX
+  #define ENDSTOPPULLUP_ZMAX
+  #define ENDSTOPPULLUP_XMIN
+  #define ENDSTOPPULLUP_YMIN
+  #define ENDSTOPPULLUP_ZMIN
+#endif
+
+// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
+const bool X_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops.
+const bool Y_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops.
+const bool Z_ENDSTOPS_INVERTING = false; // set to true to invert the logic of the endstops.
+
+// deltas never have min endstops
+#define DISABLE_MIN_ENDSTOPS
+
+// Disable max endstops for compatibility with endstop checking routine
+#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
+  #define DISABLE_MAX_ENDSTOPS
+#endif
+
+// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1
+#define X_ENABLE_ON 0
+#define Y_ENABLE_ON 0
+#define Z_ENABLE_ON 0
+#define E_ENABLE_ON 0 // For all extruders
+
+// Disables axis when it's not being used.
+#define DISABLE_X false
+#define DISABLE_Y false
+#define DISABLE_Z false
+#define DISABLE_E false // For all extruders
+
+#define INVERT_X_DIR false // DELTA does not invert
+#define INVERT_Y_DIR false
+#define INVERT_Z_DIR false
+
+#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false
+#define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false
+
+// ENDSTOP SETTINGS:
+// Sets direction of endstops when homing; 1=MAX, -1=MIN
+// deltas always home to max
+#define X_HOME_DIR 1
+#define Y_HOME_DIR 1
+#define Z_HOME_DIR 1
+
+#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.
+#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.
+
+// Travel limits after homing
+#define X_MAX_POS 90
+#define X_MIN_POS -90
+#define Y_MAX_POS 90
+#define Y_MIN_POS -90
+#define Z_MAX_POS MANUAL_Z_HOME_POS
+#define Z_MIN_POS 0
+
+#define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)
+#define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)
+#define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
+
+// The position of the homing switches
+//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
+
+//Manual homing switch locations:
+
+#define MANUAL_HOME_POSITIONS  // MANUAL_*_HOME_POS below will be used
+// For deltabots this means top and center of the cartesian print volume.
+#define MANUAL_X_HOME_POS 0
+#define MANUAL_Y_HOME_POS 0
+#define MANUAL_Z_HOME_POS 250 // For delta: Distance between nozzle and print surface after homing.
+
+//// MOVEMENT SETTINGS
+#define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E
+
+// delta homing speeds must be the same on xyz
+#define HOMING_FEEDRATE {200*60, 200*60, 200*60, 0}  // set the homing speeds (mm/min)
+
+// default settings
+// delta speeds must be the same on xyz
+#define DEFAULT_AXIS_STEPS_PER_UNIT   {80, 80, 80, 760*1.1}  // default steps per unit for Kossel (GT2, 20 tooth)
+#define DEFAULT_MAX_FEEDRATE          {500, 500, 500, 25}    // (mm/sec)
+#define DEFAULT_MAX_ACCELERATION      {9000,9000,9000,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.
+
+#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts
+
+// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).
+// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).
+// For the other hotends it is their distance from the extruder 0 hotend.
+// #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
+// #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
+
+// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)
+#define DEFAULT_XYJERK                20.0    // (mm/sec)
+#define DEFAULT_ZJERK                 20.0    // (mm/sec) Must be same as XY for delta
+#define DEFAULT_EJERK                 5.0    // (mm/sec)
+
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
+
+// EEPROM
+// the microcontroller can store settings in the EEPROM, e.g. max velocity...
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+//define this to enable eeprom support
+//#define EEPROM_SETTINGS
+//to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:
+// please keep turned on if you can.
+//#define EEPROM_CHITCHAT
+
+// Preheat Constants
+#define PLA_PREHEAT_HOTEND_TEMP 180 
+#define PLA_PREHEAT_HPB_TEMP 70
+#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+#define ABS_PREHEAT_HOTEND_TEMP 240
+#define ABS_PREHEAT_HPB_TEMP 100
+#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255
+
+//LCD and SD support
+//#define ULTRA_LCD  //general lcd support, also 16x2
+//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
+//#define SDSUPPORT // Enable SD Card Support in Hardware Console
+//#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
+
+//#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
+//#define ULTIPANEL  //the ultipanel as on thingiverse
+
+// The MaKr3d Makr-Panel with graphic controller and SD support
+// http://reprap.org/wiki/MaKr3d_MaKrPanel
+//#define MAKRPANEL
+
+// The RepRapDiscount Smart Controller (white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Smart_Controller
+//#define REPRAP_DISCOUNT_SMART_CONTROLLER
+
+// The GADGETS3D G3D LCD/SD Controller (blue PCB)
+// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel
+//#define G3D_PANEL
+
+// The RepRapDiscount FULL GRAPHIC Smart Controller (quadratic white PCB)
+// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
+//
+// ==> REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib
+//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+
+// The RepRapWorld REPRAPWORLD_KEYPAD v1.1
+// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626
+//#define REPRAPWORLD_KEYPAD
+//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click
+
+// The Elefu RA Board Control Panel
+// http://www.elefu.com/index.php?route=product/product&product_id=53
+// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARUDINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C
+//#define RA_CONTROL_PANEL
+
+//automatic expansion
+#if defined (MAKRPANEL)
+ #define DOGLCD
+ #define SDSUPPORT
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define DEFAULT_LCD_CONTRAST 17
+#endif
+
+#if defined (REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)
+ #define DOGLCD
+ #define U8GLIB_ST7920
+ #define REPRAP_DISCOUNT_SMART_CONTROLLER
+#endif
+
+#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+#endif
+
+#if defined(REPRAPWORLD_KEYPAD)
+  #define NEWPANEL
+  #define ULTIPANEL
+#endif
+#if defined(RA_CONTROL_PANEL)
+ #define ULTIPANEL
+ #define NEWPANEL
+ #define LCD_I2C_TYPE_PCA8574
+ #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+#endif
+
+//I2C PANELS
+
+//#define LCD_I2C_SAINSMART_YWROBOT
+#ifdef LCD_I2C_SAINSMART_YWROBOT
+  // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )
+  // Make sure it is placed in the Arduino libraries directory.
+  #define LCD_I2C_TYPE_PCF8575
+  #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
+
+// PANELOLU2 LCD with status LEDs, separate encoder and click inputs
+//#define LCD_I2C_PANELOLU2
+#ifdef LCD_I2C_PANELOLU2
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)
+  // Note: The PANELOLU2 encoder click input can either be directly connected to a pin 
+  //       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1). 
+  #define LCD_I2C_TYPE_MCP23017
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
+
+// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs
+//#define LCD_I2C_VIKI
+#ifdef LCD_I2C_VIKI
+  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )
+  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.
+  // Note: The pause/stop/resume LCD button pin should be connected to the Arduino
+  //       BTN_ENC pin (or set BTN_ENC to -1 if not used)
+  #define LCD_I2C_TYPE_MCP23017 
+  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander
+  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)
+  #define NEWPANEL
+  #define ULTIPANEL 
+#endif
+
+#ifdef ULTIPANEL
+//  #define NEWPANEL  //enable this if you have a click-encoder panel
+  #define SDSUPPORT
+  #define ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the DOG graphic display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 4
+  #endif
+#else //no panel but just lcd
+  #ifdef ULTRA_LCD
+  #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display
+    #define LCD_WIDTH 20
+    #define LCD_HEIGHT 5
+  #else
+    #define LCD_WIDTH 16
+    #define LCD_HEIGHT 2
+  #endif
+  #endif
+#endif
+
+// default LCD contrast for dogm-like LCD displays
+#ifdef DOGLCD
+# ifndef DEFAULT_LCD_CONTRAST
+#  define DEFAULT_LCD_CONTRAST 32
+# endif
+#endif
+
+// Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
+//#define FAST_PWM_FAN
+
+// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
+// which is not ass annoying as with the hardware PWM. On the other hand, if this frequency
+// is too low, you should also increment SOFT_PWM_SCALE.
+//#define FAN_SOFT_PWM
+
+// Incrementing this by 1 will double the software PWM frequency,
+// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
+// However, control resolution will be halved for each increment;
+// at zero value, there are 128 effective control positions.
+#define SOFT_PWM_SCALE 0
+
+// M240  Triggers a camera by emulating a Canon RC-1 Remote
+// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
+// #define PHOTOGRAPH_PIN     23
+
+// SF send wrong arc g-codes when using Arc Point as fillet procedure
+//#define SF_ARC_FIX
+
+// Support for the BariCUDA Paste Extruder.
+//#define BARICUDA
+
+/*********************************************************************\
+* R/C SERVO support
+* Sponsored by TrinityLabs, Reworked by codexmas
+**********************************************************************/
+
+// Number of servos
+//
+// If you select a configuration below, this will receive a default value and does not need to be set manually
+// set it manually if you have more servos than extruders and wish to manually control some
+// leaving it undefined or defining as 0 will disable the servo subsystem
+// If unsure, leave commented / disabled
+//
+//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command
+
+// Servo Endstops
+// 
+// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.
+// Use M206 command to correct for switch height offset to actual nozzle height. Store that setting with M500.
+// 
+//#define SERVO_ENDSTOPS {-1, -1, 0} // Servo index for X, Y, Z. Disable with -1
+//#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 70,0} // X,Y,Z Axis Extend and Retract angles
+
+#include "Configuration_adv.h"
+#include "thermistortables.h"
+
+#endif //__CONFIGURATION_H
diff --git a/Marlin/example_configurations/delta/Configuration_adv.h b/Marlin/example_configurations/delta/Configuration_adv.h
new file mode 100644
index 0000000..f279b0e
--- /dev/null
+++ b/Marlin/example_configurations/delta/Configuration_adv.h
@@ -0,0 +1,396 @@
+#ifndef CONFIGURATION_ADV_H
+#define CONFIGURATION_ADV_H
+
+//===========================================================================
+//=============================Thermal Settings  ============================
+//===========================================================================
+
+#ifdef BED_LIMIT_SWITCHING
+  #define BED_HYSTERESIS 2 //only disable heating if T>target+BED_HYSTERESIS and enable heating if T>target-BED_HYSTERESIS
+#endif
+#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control
+
+//// Heating sanity check:
+// This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature
+// If the temperature has not increased at the end of that period, the target temperature is set to zero. 
+// It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature
+//  differ by at least 2x WATCH_TEMP_INCREASE
+//#define WATCH_TEMP_PERIOD 40000 //40 seconds
+//#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds
+
+#ifdef PIDTEMP
+  // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.
+  // if Kc is choosen well, the additional required power due to increased melting should be compensated.
+  #define PID_ADD_EXTRUSION_RATE  
+  #ifdef PID_ADD_EXTRUSION_RATE
+    #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)
+  #endif
+#endif
+
+
+//automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.
+//The maximum buffered steps/sec of the extruder motor are called "se".
+//You enter the autotemp mode by a M109 S<mintemp> T<maxtemp> F<factor>
+// the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp
+// you exit the value by any M109 without F*
+// Also, if the temperature is set to a value <mintemp, it is not changed by autotemp.
+// on an ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode
+#define AUTOTEMP
+#ifdef AUTOTEMP
+  #define AUTOTEMP_OLDWEIGHT 0.98
+#endif
+
+//  extruder run-out prevention. 
+//if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
+//#define EXTRUDER_RUNOUT_PREVENT  
+#define EXTRUDER_RUNOUT_MINTEMP 190  
+#define EXTRUDER_RUNOUT_SECONDS 30.
+#define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament
+#define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed
+#define EXTRUDER_RUNOUT_EXTRUDE 100
+
+//These defines help to calibrate the AD595 sensor in case you get wrong temperature measurements.
+//The measured temperature is defined as "actualTemp = (measuredTemp * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET"
+#define TEMP_SENSOR_AD595_OFFSET 0.0
+#define TEMP_SENSOR_AD595_GAIN   1.0
+
+//This is for controlling a fan to cool down the stepper drivers
+//it will turn on when any driver is enabled
+//and turn off after the set amount of seconds from last driver being disabled again
+#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)
+#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run
+#define CONTROLLERFAN_SPEED 255  // == full speed
+
+// When first starting the main fan, run it at full speed for the
+// given number of milliseconds.  This gets the fan spinning reliably
+// before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)
+//#define FAN_KICKSTART_TIME 100
+
+// Extruder cooling fans
+// Configure fan pin outputs to automatically turn on/off when the associated
+// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
+// Multiple extruders can be assigned to the same pin in which case 
+// the fan will turn on when any selected extruder is above the threshold.
+#define EXTRUDER_0_AUTO_FAN_PIN   -1
+#define EXTRUDER_1_AUTO_FAN_PIN   -1
+#define EXTRUDER_2_AUTO_FAN_PIN   -1
+#define EXTRUDER_AUTO_FAN_TEMPERATURE 50
+#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
+
+
+//===========================================================================
+//=============================Mechanical Settings===========================
+//===========================================================================
+
+#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing
+
+
+//// AUTOSET LOCATIONS OF LIMIT SWITCHES
+//// Added by ZetaPhoenix 09-15-2012
+#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations
+  #define X_HOME_POS MANUAL_X_HOME_POS
+  #define Y_HOME_POS MANUAL_Y_HOME_POS
+  #define Z_HOME_POS MANUAL_Z_HOME_POS
+#else //Set min/max homing switch positions based upon homing direction and min/max travel limits
+  //X axis
+  #if X_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * -0.5
+    #else
+      #define X_HOME_POS X_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else    
+    #ifdef BED_CENTER_AT_0_0
+      #define X_HOME_POS X_MAX_LENGTH * 0.5
+    #else
+      #define X_HOME_POS X_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //X_HOME_DIR == -1
+  
+  //Y axis
+  #if Y_HOME_DIR == -1
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * -0.5
+    #else
+      #define Y_HOME_POS Y_MIN_POS
+    #endif //BED_CENTER_AT_0_0
+  #else    
+    #ifdef BED_CENTER_AT_0_0
+      #define Y_HOME_POS Y_MAX_LENGTH * 0.5
+    #else
+      #define Y_HOME_POS Y_MAX_POS
+    #endif //BED_CENTER_AT_0_0
+  #endif //Y_HOME_DIR == -1
+  
+  // Z axis
+  #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used
+    #define Z_HOME_POS Z_MIN_POS
+  #else    
+    #define Z_HOME_POS Z_MAX_POS
+  #endif //Z_HOME_DIR == -1
+#endif //End auto min/max positions
+//END AUTOSET LOCATIONS OF LIMIT SWITCHES -ZP
+
+
+//#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
+
+// A single Z stepper driver is usually used to drive 2 stepper motors.
+// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
+// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
+// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
+// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+//#define Z_DUAL_STEPPER_DRIVERS
+
+#ifdef Z_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+// Enable this for dual x-carriage printers. 
+// A dual x-carriage design has the advantage that the inactive extruder can be parked which
+// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
+// allowing faster printing speeds.
+//#define DUAL_X_CARRIAGE
+#ifdef DUAL_X_CARRIAGE
+// Configuration for second X-carriage
+// Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
+// the second x-carriage always homes to the maximum endstop.
+#define X2_MIN_POS 88     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
+#define X2_MAX_POS 350.45 // set maximum to the distance between toolheads when both heads are homed 
+#define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
+#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
+    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
+    // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops
+    // without modifying the firmware (through the "M218 T1 X???" command).
+    // Remember: you should set the second extruder x-offset to 0 in your slicer.
+
+// Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)
+#define X2_ENABLE_PIN 29
+#define X2_STEP_PIN 25
+#define X2_DIR_PIN 23
+
+#endif // DUAL_X_CARRIAGE
+    
+//homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
+#define X_HOME_RETRACT_MM 5 
+#define Y_HOME_RETRACT_MM 5
+#define Z_HOME_RETRACT_MM 5 // deltas need the same for all three axis
+
+
+//#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
+
+#define AXIS_RELATIVE_MODES {false, false, false, false}
+
+#define MAX_STEP_FREQUENCY 40000 // Max step frequency for Ultimaker (5000 pps / half step)
+
+//By default pololu step drivers require an active high signal. However, some high power drivers require an active low signal as step.
+#define INVERT_X_STEP_PIN false
+#define INVERT_Y_STEP_PIN false
+#define INVERT_Z_STEP_PIN false
+#define INVERT_E_STEP_PIN false
+
+//default stepper release if idle
+#define DEFAULT_STEPPER_DEACTIVE_TIME 60
+
+#define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate
+#define DEFAULT_MINTRAVELFEEDRATE     0.0
+
+// minimum time in microseconds that a movement needs to take if the buffer is emptied.
+#define DEFAULT_MINSEGMENTTIME        20000
+
+// If defined the movements slow down when the look ahead buffer is only half full
+// (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
+//#define SLOWDOWN
+
+// Frequency limit
+// See nophead's blog for more info
+// Not working O
+//#define XY_FREQUENCY_LIMIT  15
+
+// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end
+// of the buffer and all stops. This should not be much greater than zero and should only be changed
+// if unwanted behavior is observed on a user's machine when running at very slow speeds.
+#define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)
+
+// MS1 MS2 Stepper Driver Microstepping mode table
+#define MICROSTEP1 LOW,LOW
+#define MICROSTEP2 HIGH,LOW
+#define MICROSTEP4 LOW,HIGH
+#define MICROSTEP8 HIGH,HIGH
+#define MICROSTEP16 HIGH,HIGH
+
+// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.
+#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]
+
+// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)
+#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
+
+
+//===========================================================================
+//=============================Additional Features===========================
+//===========================================================================
+
+#define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
+#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
+
+// The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
+//#define USE_WATCHDOG
+
+#ifdef USE_WATCHDOG
+// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.
+// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.
+//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.
+//#define WATCHDOG_RESET_MANUAL
+#endif
+
+// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
+//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+
+// extruder advance constant (s2/mm3)
+//
+// advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2
+//
+// hooke's law says:		force = k * distance
+// bernoulli's priniciple says:	v ^ 2 / 2 + g . h + pressure / density = constant
+// so: v ^ 2 is proportional to number of steps we advance the extruder
+//#define ADVANCE
+
+#ifdef ADVANCE
+  #define EXTRUDER_ADVANCE_K .0
+
+  #define D_FILAMENT 2.85
+  #define STEPS_MM_E 836
+  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+
+#endif // ADVANCE
+
+// Arc interpretation settings:
+#define MM_PER_ARC_SEGMENT 1
+#define N_ARC_CORRECTION 25
+
+const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement
+
+// If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted
+// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT 
+// in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should
+// be commented out otherwise
+#define SDCARDDETECTINVERTED 
+
+#ifdef ULTIPANEL
+ #undef SDCARDDETECTINVERTED
+#endif
+
+// Power Signal Control Definitions
+// By default use ATX definition
+#ifndef POWER_SUPPLY
+  #define POWER_SUPPLY 1
+#endif
+// 1 = ATX
+#if (POWER_SUPPLY == 1) 
+  #define PS_ON_AWAKE  LOW
+  #define PS_ON_ASLEEP HIGH
+#endif
+// 2 = X-Box 360 203W
+#if (POWER_SUPPLY == 2) 
+  #define PS_ON_AWAKE  HIGH
+  #define PS_ON_ASLEEP LOW
+#endif
+
+//===========================================================================
+//=============================Buffers           ============================
+//===========================================================================
+
+// The number of linear motions that can be in the plan at any give time.  
+// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.
+#if defined SDSUPPORT
+  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+#else
+  #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
+#endif
+
+
+//The ASCII buffer for recieving from the serial:
+#define MAX_CMD_SIZE 96
+#define BUFSIZE 4
+
+
+// Firmware based and LCD controled retract
+// M207 and M208 can be used to define parameters for the retraction. 
+// The retraction can be called by the slicer using G10 and G11
+// until then, intended retractions can be detected by moves that only extrude and the direction. 
+// the moves are than replaced by the firmware controlled ones.
+
+// #define FWRETRACT  //ONLY PARTIALLY TESTED
+#define MIN_RETRACT 0.1 //minimum extruded mm to accept a automatic gcode retraction attempt
+
+
+//adds support for experimental filament exchange support M600; requires display
+#ifdef ULTIPANEL
+  //#define FILAMENTCHANGEENABLE
+  #ifdef FILAMENTCHANGEENABLE
+    #define FILAMENTCHANGE_XPOS 3
+    #define FILAMENTCHANGE_YPOS 3
+    #define FILAMENTCHANGE_ZADD 10
+    #define FILAMENTCHANGE_FIRSTRETRACT -2
+    #define FILAMENTCHANGE_FINALRETRACT -100
+  #endif
+#endif
+ 
+//===========================================================================
+//=============================  Define Defines  ============================
+//===========================================================================
+#if EXTRUDERS > 1 && defined TEMP_SENSOR_1_AS_REDUNDANT
+  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
+#endif
+
+#if TEMP_SENSOR_0 > 0
+  #define THERMISTORHEATER_0 TEMP_SENSOR_0
+  #define HEATER_0_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_1 > 0
+  #define THERMISTORHEATER_1 TEMP_SENSOR_1
+  #define HEATER_1_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_2 > 0
+  #define THERMISTORHEATER_2 TEMP_SENSOR_2
+  #define HEATER_2_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_BED > 0
+  #define THERMISTORBED TEMP_SENSOR_BED
+  #define BED_USES_THERMISTOR
+#endif
+#if TEMP_SENSOR_0 == -1
+  #define HEATER_0_USES_AD595
+#endif
+#if TEMP_SENSOR_1 == -1
+  #define HEATER_1_USES_AD595
+#endif
+#if TEMP_SENSOR_2 == -1
+  #define HEATER_2_USES_AD595
+#endif
+#if TEMP_SENSOR_BED == -1
+  #define BED_USES_AD595
+#endif
+#if TEMP_SENSOR_0 == -2
+  #define HEATER_0_USES_MAX6675
+#endif
+#if TEMP_SENSOR_0 == 0
+  #undef HEATER_0_MINTEMP
+  #undef HEATER_0_MAXTEMP
+#endif
+#if TEMP_SENSOR_1 == 0
+  #undef HEATER_1_MINTEMP
+  #undef HEATER_1_MAXTEMP
+#endif
+#if TEMP_SENSOR_2 == 0
+  #undef HEATER_2_MINTEMP
+  #undef HEATER_2_MAXTEMP
+#endif
+#if TEMP_SENSOR_BED == 0
+  #undef BED_MINTEMP
+  #undef BED_MAXTEMP
+#endif
+
+
+#endif //__CONFIGURATION_ADV_H
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index ed77b50..0746bf1 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -2575,8 +2575,702 @@ pins
 #define PF7_DDR			DDRF
 #endif
 
+
+#if defined (__AVR_ATmega1281__) || defined (__AVR_ATmega2561__)
+// UART
+#define	RXD					DIO0
+#define	TXD					DIO1
+
+// SPI
+#define	SCK					DIO10
+#define	MISO				DIO12
+#define	MOSI				DIO11
+#define	SS					DIO16
+
+// TWI (I2C)
+#define	SCL					DIO17
+#define	SDA					DIO18
+
+// timers and PWM
+#define	OC0A				DIO9
+#define	OC0B				DIO4
+#define	OC1A				DIO7
+#define	OC1B				DIO8
+#define	OC2A				DIO6
+#define	OC3A				DIO5
+#define	OC3B				DIO2
+#define	OC3C				DIO3
+
+
+// change for your board
+#define	DEBUG_LED		DIO46
+
+/*
+pins
+*/
+#define	DIO0_PIN		PINE0
+#define	DIO0_RPORT	PINE
+#define	DIO0_WPORT	PORTE
+#define	DIO0_DDR		DDRE
+#define DIO0_PWM		NULL
+
+#define	DIO1_PIN		PINE1
+#define	DIO1_RPORT	PINE
+#define	DIO1_WPORT	PORTE
+#define	DIO1_DDR		DDRE
+#define DIO1_PWM		NULL
+
+#define	DIO2_PIN		PINE4
+#define	DIO2_RPORT	PINE
+#define	DIO2_WPORT	PORTE
+#define	DIO2_DDR		DDRE
+#define DIO2_PWM		&OCR3BL
+
+#define	DIO3_PIN		PINE5
+#define	DIO3_RPORT	PINE
+#define	DIO3_WPORT	PORTE
+#define	DIO3_DDR		DDRE
+#define DIO3_PWM		&OCR3CL
+
+#define	DIO4_PIN		PING5
+#define	DIO4_RPORT	PING
+#define	DIO4_WPORT	PORTG
+#define	DIO4_DDR		DDRG
+#define DIO4_PWM		&OCR0B
+
+#define	DIO5_PIN		PINE3
+#define	DIO5_RPORT	PINE
+#define	DIO5_WPORT	PORTE
+#define	DIO5_DDR		DDRE
+#define DIO5_PWM		&OCR3AL
+
+#define	DIO6_PIN		PINB4
+#define	DIO6_RPORT	PINB
+#define	DIO6_WPORT	PORTB
+#define	DIO6_DDR		DDRB
+#define DIO6_PWM		&OCR2AL
+
+#define	DIO7_PIN		PINB5
+#define	DIO7_RPORT	PINB
+#define	DIO7_WPORT	PORTB
+#define	DIO7_DDR		DDRB
+#define DIO7_PWM		&OCR1AL
+
+#define	DIO8_PIN		PINB6
+#define	DIO8_RPORT	PINB
+#define	DIO8_WPORT	PORTB
+#define	DIO8_DDR		DDRB
+#define DIO8_PWM		&OCR1BL
+
+#define	DIO9_PIN		PINB7
+#define	DIO9_RPORT	PINB
+#define	DIO9_WPORT	PORTB
+#define	DIO9_DDR		DDRB
+#define DIO9_PWM		&OCR0AL
+
+#define	DIO10_PIN		PINB1
+#define	DIO10_RPORT	PINB
+#define	DIO10_WPORT	PORTB
+#define	DIO10_DDR		DDRB
+#define DIO10_PWM		NULL
+
+#define	DIO11_PIN		PINB2
+#define	DIO11_RPORT	PINB
+#define	DIO11_WPORT	PORTB
+#define	DIO11_DDR		DDRB
+#define DIO11_PWM		NULL
+
+#define	DIO12_PIN		PINB3
+#define	DIO12_RPORT	PINB
+#define	DIO12_WPORT	PORTB
+#define	DIO12_DDR		DDRB
+#define DIO12_PWM		NULL
+
+#define	DIO13_PIN		PINE2
+#define	DIO13_RPORT	PINE
+#define	DIO13_WPORT	PORTE
+#define	DIO13_DDR		DDRE
+#define DIO13_PWM		NULL
+
+#define	DIO14_PIN		PINE6
+#define	DIO14_RPORT	PINE
+#define	DIO14_WPORT	PORTE
+#define	DIO14_DDR		DDRE
+#define DIO14_PWM		NULL
+
+#define	DIO15_PIN		PINE7
+#define	DIO15_RPORT	PINE
+#define	DIO15_WPORT	PORTE
+#define	DIO15_DDR		DDRE
+#define DIO15_PWM		NULL
+
+#define	DIO16_PIN		PINB0
+#define	DIO16_RPORT	PINB
+#define	DIO16_WPORT	PORTB
+#define	DIO16_DDR		DDRB
+#define DIO16_PWM		NULL
+
+#define	DIO17_PIN		PIND0
+#define	DIO17_RPORT	PIND
+#define	DIO17_WPORT	PORTD
+#define	DIO17_DDR		DDRD
+#define DIO17_PWM		NULL
+
+#define	DIO18_PIN		PIND1
+#define	DIO18_RPORT	PIND
+#define	DIO18_WPORT	PORTD
+#define	DIO18_DDR		DDRD
+#define DIO18_PWM		NULL
+
+#define	DIO19_PIN		PIND2
+#define	DIO19_RPORT	PIND
+#define	DIO19_WPORT	PORTD
+#define	DIO19_DDR		DDRD
+#define DIO19_PWM		NULL
+
+#define	DIO20_PIN		PIND3
+#define	DIO20_RPORT	PIND
+#define	DIO20_WPORT	PORTD
+#define	DIO20_DDR		DDRD
+#define DIO20_PWM		NULL
+
+#define	DIO21_PIN		PIND4
+#define	DIO21_RPORT	PIND
+#define	DIO21_WPORT	PORTD
+#define	DIO21_DDR		DDRD
+#define DIO21_PWM		NULL
+
+#define	DIO22_PIN		PIND5
+#define	DIO22_RPORT	PIND
+#define	DIO22_WPORT	PORTD
+#define	DIO22_DDR		DDRD
+#define DIO22_PWM		NULL
+
+#define	DIO23_PIN		PIND6
+#define	DIO23_RPORT	PIND
+#define	DIO23_WPORT	PORTD
+#define	DIO23_DDR		DDRD
+#define DIO23_PWM		NULL
+
+#define	DIO24_PIN		PIND7
+#define	DIO24_RPORT	PIND
+#define	DIO24_WPORT	PORTD
+#define	DIO24_DDR		DDRD
+#define DIO24_PWM		NULL
+
+#define	DIO25_PIN		PING0
+#define	DIO25_RPORT	PING
+#define	DIO25_WPORT	PORTG
+#define	DIO25_DDR		DDRG
+#define DIO25_PWM		NULL
+
+#define	DIO26_PIN		PING1
+#define	DIO26_RPORT	PING
+#define	DIO26_WPORT	PORTG
+#define	DIO26_DDR		DDRG
+#define DIO26_PWM		NULL
+
+#define	DIO27_PIN		PING2
+#define	DIO27_RPORT	PING
+#define	DIO27_WPORT	PORTG
+#define	DIO27_DDR		DDRG
+#define DIO27_PWM		NULL
+
+#define	DIO28_PIN		PING3
+#define	DIO28_RPORT	PING
+#define	DIO28_WPORT	PORTG
+#define	DIO28_DDR		DDRG
+#define DIO28_PWM		NULL
+
+#define	DIO29_PIN		PING4
+#define	DIO29_RPORT	PING
+#define	DIO29_WPORT	PORTG
+#define	DIO29_DDR		DDRG
+#define DIO29_PWM		NULL
+
+#define	DIO30_PIN		PINC0
+#define	DIO30_RPORT	PINC
+#define	DIO30_WPORT	PORTC
+#define	DIO30_DDR		DDRC
+#define DIO30_PWM		NULL
+
+#define	DIO31_PIN		PINC1
+#define	DIO31_RPORT	PINC
+#define	DIO31_WPORT	PORTC
+#define	DIO31_DDR		DDRC
+#define DIO31_PWM		NULL
+
+#define	DIO32_PIN		PINC2
+#define	DIO32_RPORT	PINC
+#define	DIO32_WPORT	PORTC
+#define	DIO32_DDR		DDRC
+#define DIO32_PWM		NULL
+
+#define	DIO33_PIN		PINC3
+#define	DIO33_RPORT	PINC
+#define	DIO33_WPORT	PORTC
+#define	DIO33_DDR		DDRC
+#define DIO33_PWM		NULL
+
+#define	DIO34_PIN		PINC4
+#define	DIO34_RPORT	PINC
+#define	DIO34_WPORT	PORTC
+#define	DIO34_DDR		DDRC
+#define DIO34_PWM		NULL
+
+#define	DIO35_PIN		PINC5
+#define	DIO35_RPORT	PINC
+#define	DIO35_WPORT	PORTC
+#define	DIO35_DDR		DDRC
+#define DIO35_PWM		NULL
+
+#define	DIO36_PIN		PINC6
+#define	DIO36_RPORT	PINC
+#define	DIO36_WPORT	PORTC
+#define	DIO36_DDR		DDRC
+#define DIO36_PWM		NULL
+
+#define	DIO37_PIN		PINC7
+#define	DIO37_RPORT	PINC
+#define	DIO37_WPORT	PORTC
+#define	DIO37_DDR		DDRC
+#define DIO37_PWM		NULL
+
+#define	DIO38_PIN		PINA0
+#define	DIO38_RPORT	PINA
+#define	DIO38_WPORT	PORTA
+#define	DIO38_DDR		DDRA
+#define DIO38_PWM		NULL
+
+#define	DIO39_PIN		PINA1
+#define	DIO39_RPORT	PINA
+#define	DIO39_WPORT	PORTA
+#define	DIO39_DDR		DDRA
+#define DIO39_PWM		NULL
+
+#define	DIO40_PIN		PINA2
+#define	DIO40_RPORT	PINA
+#define	DIO40_WPORT	PORTA
+#define	DIO40_DDR		DDRA
+#define DIO40_PWM		NULL
+
+#define	DIO41_PIN		PINA3
+#define	DIO41_RPORT	PINA
+#define	DIO41_WPORT	PORTA
+#define	DIO41_DDR		DDRA
+#define DIO41_PWM		NULL
+
+#define	DIO42_PIN		PINA4
+#define	DIO42_RPORT	PINA
+#define	DIO42_WPORT	PORTA
+#define	DIO42_DDR		DDRA
+#define DIO42_PWM		NULL
+
+#define	DIO43_PIN		PINA5
+#define	DIO43_RPORT	PINA
+#define	DIO43_WPORT	PORTA
+#define	DIO43_DDR		DDRA
+#define DIO43_PWM		NULL
+
+#define	DIO44_PIN		PINA6
+#define	DIO44_RPORT	PINA
+#define	DIO44_WPORT	PORTA
+#define	DIO44_DDR		DDRA
+#define DIO44_PWM		NULL
+
+#define	DIO45_PIN		PINA7
+#define	DIO45_RPORT	PINA
+#define	DIO45_WPORT	PORTA
+#define	DIO45_DDR		DDRA
+#define DIO45_PWM		NULL
+
+#define	DIO46_PIN		PINF0
+#define	DIO46_RPORT	PINF
+#define	DIO46_WPORT	PORTF
+#define	DIO46_DDR		DDRF
+#define DIO46_PWM		NULL
+
+#define	DIO47_PIN		PINF1
+#define	DIO47_RPORT	PINF
+#define	DIO47_WPORT	PORTF
+#define	DIO47_DDR		DDRF
+#define DIO47_PWM		NULL
+
+#define	DIO48_PIN		PINF2
+#define	DIO48_RPORT	PINF
+#define	DIO48_WPORT	PORTF
+#define	DIO48_DDR		DDRF
+#define DIO48_PWM		NULL
+
+#define	DIO49_PIN		PINF3
+#define	DIO49_RPORT	PINF
+#define	DIO49_WPORT	PORTF
+#define	DIO49_DDR		DDRF
+#define DIO49_PWM		NULL
+
+#define	DIO50_PIN		PINF4
+#define	DIO50_RPORT	PINF
+#define	DIO50_WPORT	PORTF
+#define	DIO50_DDR		DDRF
+#define DIO50_PWM		NULL
+
+#define	DIO51_PIN		PINF5
+#define	DIO51_RPORT	PINF
+#define	DIO51_WPORT	PORTF
+#define	DIO51_DDR		DDRF
+#define DIO51_PWM		NULL
+
+#define	DIO52_PIN		PINF6
+#define	DIO52_RPORT	PINF
+#define	DIO52_WPORT	PORTF
+#define	DIO52_DDR		DDRF
+#define DIO52_PWM		NULL
+
+#define	DIO53_PIN		PINF7
+#define	DIO53_RPORT	PINF
+#define	DIO53_WPORT	PORTF
+#define	DIO53_DDR		DDRF
+#define DIO53_PWM		NULL
+
+
+
+
+#undef PA0
+#define PA0_PIN			PINA0
+#define PA0_RPORT		PINA
+#define PA0_WPORT		PORTA
+#define PA0_DDR			DDRA
+#define PA0_PWM			NULL
+#undef PA1
+#define PA1_PIN			PINA1
+#define PA1_RPORT		PINA
+#define PA1_WPORT		PORTA
+#define PA1_DDR			DDRA
+#define PA1_PWM			NULL
+#undef PA2
+#define PA2_PIN			PINA2
+#define PA2_RPORT		PINA
+#define PA2_WPORT		PORTA
+#define PA2_DDR			DDRA
+#define PA2_PWM			NULL
+#undef PA3
+#define PA3_PIN			PINA3
+#define PA3_RPORT		PINA
+#define PA3_WPORT		PORTA
+#define PA3_DDR			DDRA
+#define PA3_PWM			NULL
+#undef PA4
+#define PA4_PIN			PINA4
+#define PA4_RPORT		PINA
+#define PA4_WPORT		PORTA
+#define PA4_DDR			DDRA
+#define PA4_PWM			NULL
+#undef PA5
+#define PA5_PIN			PINA5
+#define PA5_RPORT		PINA
+#define PA5_WPORT		PORTA
+#define PA5_DDR			DDRA
+#define PA5_PWM			NULL
+#undef PA6
+#define PA6_PIN			PINA6
+#define PA6_RPORT		PINA
+#define PA6_WPORT		PORTA
+#define PA6_DDR			DDRA
+#define PA6_PWM			NULL
+#undef PA7
+#define PA7_PIN			PINA7
+#define PA7_RPORT		PINA
+#define PA7_WPORT		PORTA
+#define PA7_DDR			DDRA
+#define PA7_PWM			NULL
+
+#undef PB0
+#define PB0_PIN			PINB0
+#define PB0_RPORT		PINB
+#define PB0_WPORT		PORTB
+#define PB0_DDR			DDRB
+#define PB0_PWM			NULL
+#undef PB1
+#define PB1_PIN			PINB1
+#define PB1_RPORT		PINB
+#define PB1_WPORT		PORTB
+#define PB1_DDR			DDRB
+#define PB1_PWM			NULL
+#undef PB2
+#define PB2_PIN			PINB2
+#define PB2_RPORT		PINB
+#define PB2_WPORT		PORTB
+#define PB2_DDR			DDRB
+#define PB2_PWM			NULL
+#undef PB3
+#define PB3_PIN			PINB3
+#define PB3_RPORT		PINB
+#define PB3_WPORT		PORTB
+#define PB3_DDR			DDRB
+#define PB3_PWM			NULL
+#undef PB4
+#define PB4_PIN			PINB4
+#define PB4_RPORT		PINB
+#define PB4_WPORT		PORTB
+#define PB4_DDR			DDRB
+#define PB4_PWM			&OCR2A
+#undef PB5
+#define PB5_PIN			PINB5
+#define PB5_RPORT		PINB
+#define PB5_WPORT		PORTB
+#define PB5_DDR			DDRB
+#define PB5_PWM			NULL
+#undef PB6
+#define PB6_PIN			PINB6
+#define PB6_RPORT		PINB
+#define PB6_WPORT		PORTB
+#define PB6_DDR			DDRB
+#define PB6_PWM			NULL
+#undef PB7
+#define PB7_PIN			PINB7
+#define PB7_RPORT		PINB
+#define PB7_WPORT		PORTB
+#define PB7_DDR			DDRB
+#define PB7_PWM			&OCR0A
+
+#undef PC0
+#define PC0_PIN			PINC0
+#define PC0_RPORT		PINC
+#define PC0_WPORT		PORTC
+#define PC0_DDR			DDRC
+#define PC0_PWM			NULL
+#undef PC1
+#define PC1_PIN			PINC1
+#define PC1_RPORT		PINC
+#define PC1_WPORT		PORTC
+#define PC1_DDR			DDRC
+#define PC1_PWM			NULL
+#undef PC2
+#define PC2_PIN			PINC2
+#define PC2_RPORT		PINC
+#define PC2_WPORT		PORTC
+#define PC2_DDR			DDRC
+#define PC2_PWM			NULL
+#undef PC3
+#define PC3_PIN			PINC3
+#define PC3_RPORT		PINC
+#define PC3_WPORT		PORTC
+#define PC3_DDR			DDRC
+#define PC3_PWM			NULL
+#undef PC4
+#define PC4_PIN			PINC4
+#define PC4_RPORT		PINC
+#define PC4_WPORT		PORTC
+#define PC4_DDR			DDRC
+#define PC4_PWM			NULL
+#undef PC5
+#define PC5_PIN			PINC5
+#define PC5_RPORT		PINC
+#define PC5_WPORT		PORTC
+#define PC5_DDR			DDRC
+#define PC5_PWM			NULL
+#undef PC6
+#define PC6_PIN			PINC6
+#define PC6_RPORT		PINC
+#define PC6_WPORT		PORTC
+#define PC6_DDR			DDRC
+#define PC6_PWM			NULL
+#undef PC7
+#define PC7_PIN			PINC7
+#define PC7_RPORT		PINC
+#define PC7_WPORT		PORTC
+#define PC7_DDR			DDRC
+#define PC7_PWM			NULL
+
+#undef PD0
+#define PD0_PIN			PIND0
+#define PD0_RPORT		PIND
+#define PD0_WPORT		PORTD
+#define PD0_DDR			DDRD
+#define PD0_PWM			NULL
+#undef PD1
+#define PD1_PIN			PIND1
+#define PD1_RPORT		PIND
+#define PD1_WPORT		PORTD
+#define PD1_DDR			DDRD
+#define PD1_PWM			NULL
+#undef PD2
+#define PD2_PIN			PIND2
+#define PD2_RPORT		PIND
+#define PD2_WPORT		PORTD
+#define PD2_DDR			DDRD
+#define PD2_PWM			NULL
+#undef PD3
+#define PD3_PIN			PIND3
+#define PD3_RPORT		PIND
+#define PD3_WPORT		PORTD
+#define PD3_DDR			DDRD
+#define PD3_PWM			NULL
+#undef PD4
+#define PD4_PIN			PIND4
+#define PD4_RPORT		PIND
+#define PD4_WPORT		PORTD
+#define PD4_DDR			DDRD
+#define PD4_PWM			NULL
+#undef PD5
+#define PD5_PIN			PIND5
+#define PD5_RPORT		PIND
+#define PD5_WPORT		PORTD
+#define PD5_DDR			DDRD
+#define PD5_PWM			NULL
+#undef PD6
+#define PD6_PIN			PIND6
+#define PD6_RPORT		PIND
+#define PD6_WPORT		PORTD
+#define PD6_DDR			DDRD
+#define PD6_PWM			NULL
+#undef PD7
+#define PD7_PIN			PIND7
+#define PD7_RPORT		PIND
+#define PD7_WPORT		PORTD
+#define PD7_DDR			DDRD
+#define PD7_PWM			NULL
+
+#undef PE0
+#define PE0_PIN			PINE0
+#define PE0_RPORT		PINE
+#define PE0_WPORT		PORTE
+#define PE0_DDR			DDRE
+#define PE0_PWM			NULL
+#undef PE1
+#define PE1_PIN			PINE1
+#define PE1_RPORT		PINE
+#define PE1_WPORT		PORTE
+#define PE1_DDR			DDRE
+#define PE1_PWM			NULL
+#undef PE2
+#define PE2_PIN			PINE2
+#define PE2_RPORT		PINE
+#define PE2_WPORT		PORTE
+#define PE2_DDR			DDRE
+#define PE2_PWM			NULL
+#undef PE3
+#define PE3_PIN			PINE3
+#define PE3_RPORT		PINE
+#define PE3_WPORT		PORTE
+#define PE3_DDR			DDRE
+#define PE3_PWM			&OCR3AL
+#undef PE4
+#define PE4_PIN			PINE4
+#define PE4_RPORT		PINE
+#define PE4_WPORT		PORTE
+#define PE4_DDR			DDRE
+#define PE4_PWM			&OCR3BL
+#undef PE5
+#define PE5_PIN			PINE5
+#define PE5_RPORT		PINE
+#define PE5_WPORT		PORTE
+#define PE5_DDR			DDRE
+#define PE5_PWM			&OCR3CL
+#undef PE6
+#define PE6_PIN			PINE6
+#define PE6_RPORT		PINE
+#define PE6_WPORT		PORTE
+#define PE6_DDR			DDRE
+#define PE6_PWM			NULL
+#undef PE7
+#define PE7_PIN			PINE7
+#define PE7_RPORT		PINE
+#define PE7_WPORT		PORTE
+#define PE7_DDR			DDRE
+#define PE7_PWM			NULL
+
+#undef PF0
+#define PF0_PIN			PINF0
+#define PF0_RPORT		PINF
+#define PF0_WPORT		PORTF
+#define PF0_DDR			DDRF
+#define PF0_PWM			NULL
+#undef PF1
+#define PF1_PIN			PINF1
+#define PF1_RPORT		PINF
+#define PF1_WPORT		PORTF
+#define PF1_DDR			DDRF
+#define PF1_PWM			NULL
+#undef PF2
+#define PF2_PIN			PINF2
+#define PF2_RPORT		PINF
+#define PF2_WPORT		PORTF
+#define PF2_DDR			DDRF
+#define PF2_PWM			NULL
+#undef PF3
+#define PF3_PIN			PINF3
+#define PF3_RPORT		PINF
+#define PF3_WPORT		PORTF
+#define PF3_DDR			DDRF
+#define PF3_PWM			NULL
+#undef PF4
+#define PF4_PIN			PINF4
+#define PF4_RPORT		PINF
+#define PF4_WPORT		PORTF
+#define PF4_DDR			DDRF
+#define PF4_PWM			NULL
+#undef PF5
+#define PF5_PIN			PINF5
+#define PF5_RPORT		PINF
+#define PF5_WPORT		PORTF
+#define PF5_DDR			DDRF
+#define PF5_PWM			NULL
+#undef PF6
+#define PF6_PIN			PINF6
+#define PF6_RPORT		PINF
+#define PF6_WPORT		PORTF
+#define PF6_DDR			DDRF
+#define PF6_PWM			NULL
+#undef PF7
+#define PF7_PIN			PINF7
+#define PF7_RPORT		PINF
+#define PF7_WPORT		PORTF
+#define PF7_DDR			DDRF
+#define PF7_PWM			NULL
+
+#undef PG0
+#define PG0_PIN			PING0
+#define PG0_RPORT		PING
+#define PG0_WPORT		PORTG
+#define PG0_DDR			DDRG
+#define PG0_PWM			NULL
+#undef PG1
+#define PG1_PIN			PING1
+#define PG1_RPORT		PING
+#define PG1_WPORT		PORTG
+#define PG1_DDR			DDRG
+#define PG1_PWM			NULL
+#undef PG2
+#define PG2_PIN			PING2
+#define PG2_RPORT		PING
+#define PG2_WPORT		PORTG
+#define PG2_DDR			DDRG
+#define PG2_PWM			NULL
+#undef PG3
+#define PG3_PIN			PING3
+#define PG3_RPORT		PING
+#define PG3_WPORT		PORTG
+#define PG3_DDR			DDRG
+#define PG3_PWM			NULL
+#undef PG4
+#define PG4_PIN			PING4
+#define PG4_RPORT		PING
+#define PG4_WPORT		PORTG
+#define PG4_DDR			DDRG
+#define PG4_PWM			NULL
+#undef PG5
+#define PG5_PIN			PING5
+#define PG5_RPORT		PING
+#define PG5_WPORT		PORTG
+#define PG5_DDR			DDRG
+#define PG5_PWM			&OCR0B
+
+
+#endif
+
 #ifndef	DIO0_PIN
 #error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request
 #endif
 
-#endif /* _FASTIO_ARDUINO_H */
+#endif /* _FASTIO_ARDUINO_H */
diff --git a/Marlin/language.h b/Marlin/language.h
index 6079ba7..17222c7 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -1,1485 +1,1537 @@
-#ifndef LANGUAGE_H
-#define LANGUAGE_H
-
-// NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES
-//
-//   ==&gt; ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
-//   ==&gt; ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
-
-// Languages
-// 1  English
-// 2  Polish
-// 3  French	(awaiting translation!)
-// 4  German
-// 5  Spanish
-// 6  Russian
-// 7  Italian
-// 8  Portuguese
-// 9  Finnish
-
-#ifndef LANGUAGE_CHOICE
-#define LANGUAGE_CHOICE 1  // Pick your language from the list above
-#endif
-
-#define PROTOCOL_VERSION "1.0"
-
-#if MOTHERBOARD == 7 || MOTHERBOARD == 71
-	#define MACHINE_NAME "Ultimaker"
-	#define FIRMWARE_URL "http://firmware.ultimaker.com"
-#elif MOTHERBOARD == 80
-	#define MACHINE_NAME "Rumba"
-	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
-#else
-	#define MACHINE_NAME "Mendel"
-	#define FIRMWARE_URL "http://www.mendel-parts.com"
-#endif
-
-#define STRINGIFY_(n) #n
-#define STRINGIFY(n) STRINGIFY_(n)
-
-#if LANGUAGE_CHOICE == 1
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Ready."
-	#define MSG_SD_INSERTED "Card inserted"
-	#define MSG_SD_REMOVED "Card removed"
-	#define MSG_MAIN "Main"
-	#define MSG_AUTOSTART "Autostart"
-	#define MSG_DISABLE_STEPPERS "Disable Steppers"
-	#define MSG_AUTO_HOME "Auto Home"
-	#define MSG_SET_ORIGIN "Set Origin"
-	#define MSG_PREHEAT_PLA "Preheat PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
-	#define MSG_PREHEAT_ABS "Preheat ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
-	#define MSG_COOLDOWN "Cooldown"
-	#define MSG_EXTRUDE "Extrude"
-	#define MSG_RETRACT "Retract"
-	#define MSG_MOVE_AXIS "Move Axis"
-	#define MSG_SPEED "Speed"
-	#define MSG_NOZZLE "Nozzle"
-	#define MSG_NOZZLE1 "Nozzle2"
-	#define MSG_NOZZLE2 "Nozzle3"
-	#define MSG_BED "Bed"
-	#define MSG_FAN_SPEED "Fan speed"
-	#define MSG_FLOW "Flow"
-	#define MSG_CONTROL "Control"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Fact"
-	#define MSG_AUTOTEMP "Autotemp"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Accel"
+#ifndef LANGUAGE_H
+#define LANGUAGE_H
+
+// NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES
+//
+//   ==> ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" 
+//   ==> ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS
+
+// Languages
+// 1  English
+// 2  Polish
+// 3  French
+// 4  German
+// 5  Spanish
+// 6  Russian
+// 7  Italian
+// 8  Portuguese
+// 9  Finnish
+
+#ifndef LANGUAGE_CHOICE
+#define LANGUAGE_CHOICE 1  // Pick your language from the list above
+#endif
+
+#define PROTOCOL_VERSION "1.0"
+
+#if MOTHERBOARD == 7 || MOTHERBOARD == 71
+	#define MACHINE_NAME "Ultimaker"
+	#define FIRMWARE_URL "http://firmware.ultimaker.com"
+#elif MOTHERBOARD == 80
+	#define MACHINE_NAME "Rumba"
+	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"
+#elif MOTHERBOARD == 77
+	#define MACHINE_NAME "3Drag"
+	#define FIRMWARE_URL "http://3dprint.elettronicain.it/"
+#else
+	#ifdef CUSTOM_MENDEL_NAME
+		#define MACHINE_NAME CUSTOM_MENDEL_NAME
+	#else
+		#define MACHINE_NAME "Mendel"
+	#endif
+	#define FIRMWARE_URL "http://www.mendel-parts.com"
+#endif
+
+#define STRINGIFY_(n) #n
+#define STRINGIFY(n) STRINGIFY_(n)
+
+#if LANGUAGE_CHOICE == 1
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Ready."
+	#define MSG_SD_INSERTED "Card inserted"
+	#define MSG_SD_REMOVED "Card removed"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Disable Steppers"
+	#define MSG_AUTO_HOME "Auto Home"
+	#define MSG_SET_ORIGIN "Set Origin"
+	#define MSG_PREHEAT_PLA "Preheat PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"
+	#define MSG_PREHEAT_ABS "Preheat ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"
+	#define MSG_COOLDOWN "Cooldown"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_EXTRUDE "Extrude"
+	#define MSG_RETRACT "Retract"
+	#define MSG_MOVE_AXIS "Move Axis"
+	#define MSG_SPEED "Speed"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Bed"
+	#define MSG_FAN_SPEED "Fan speed"
+	#define MSG_FLOW "Flow"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Accel"
 	#define MSG_VXY_JERK "Vxy-jerk"
 	#define MSG_VZ_JERK "Vz-jerk"
 	#define MSG_VE_JERK "Ve-jerk"
-	#define MSG_VMAX "Vmax "
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "VTrav min"
-	#define MSG_AMAX "Amax "
-	#define MSG_A_RETRACT "A-retract"
-	#define MSG_XSTEPS "Xsteps/mm"
-	#define MSG_YSTEPS "Ysteps/mm"
-	#define MSG_ZSTEPS "Zsteps/mm"
-	#define MSG_ESTEPS "Esteps/mm"
-	#define MSG_RECTRACT "Rectract"
-	#define MSG_TEMPERATURE "Temperature"
-	#define MSG_MOTION "Motion"
-	#define MSG_STORE_EPROM "Store memory"
-	#define MSG_LOAD_EPROM "Load memory"
-	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
-	#define MSG_REFRESH "Refresh"
-	#define MSG_WATCH "Info screen"
-	#define MSG_PREPARE "Prepare"
-	#define MSG_TUNE "Tune"
-	#define MSG_PAUSE_PRINT "Pause Print"
-	#define MSG_RESUME_PRINT "Resume Print"
-	#define MSG_STOP_PRINT "Stop Print"
-	#define MSG_CARD_MENU "Print from SD"
-	#define MSG_NO_CARD "No Card"
-	#define MSG_DWELL "Sleep..."
-	#define MSG_USERWAIT "Wait for user..."
-	#define MSG_RESUMING "Resuming print"
-	#define MSG_NO_MOVE "No move."
-	#define MSG_KILLED "KILLED. "
-	#define MSG_STOPPED "STOPPED. "
-	#define MSG_CONTROL_RETRACT  "Retract mm"
-	#define MSG_CONTROL_RETRACTF "Retract  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT "AutoRetr."
-	#define MSG_FILAMENTCHANGE "Change filament"
-	#define MSG_INIT_SDCARD "Init. SD-Card"	
-	#define MSG_CNG_SDCARD "Change SD-Card"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X: "
-	#define MSG_ERR_KILLED "Printer halted. kill() called!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
-	#define MSG_RESEND "Resend: "
-	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened: "
-	#define MSG_SD_SIZE " Size: "
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
-
-	#define MSG_STEPPER_TO_HIGH "Steprate to high: "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 2
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Gotowe."
-	#define MSG_SD_INSERTED "Karta wlozona"
-	#define MSG_SD_REMOVED "Karta usunieta"
-	#define MSG_MAIN "Main"
-	#define MSG_AUTOSTART "Autostart"
-	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
-	#define MSG_AUTO_HOME "Auto. poz. zerowa"
-	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
-	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
-	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
-	#define MSG_COOLDOWN "Chlodzenie"
-	#define MSG_EXTRUDE "Ekstruzja"
-	#define MSG_RETRACT "Cofanie"
-	#define MSG_MOVE_AXIS "Ruch osi"
-	#define MSG_SPEED "Predkosc"
-	#define MSG_NOZZLE "Dysza"
-	#define MSG_NOZZLE1 "Dysza2"
-	#define MSG_NOZZLE2 "Dysza3"
-	#define MSG_BED "Loze"
-	#define MSG_FAN_SPEED "Obroty wiatraka"
-	#define MSG_FLOW "Przeplyw"
-	#define MSG_CONTROL "Kontrola"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Mnoznik"
-	#define MSG_AUTOTEMP "Auto. temp."
-	#define MSG_ON "Wl. "
-	#define MSG_OFF "Wyl."
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Acc"
-	#define MSG_VXY_JERK "Zryw Vxy"
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-retract"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Rectract"
+	#define MSG_TEMPERATURE "Temperature"
+	#define MSG_MOTION "Motion"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM "Store memory"
+	#define MSG_LOAD_EPROM "Load memory"
+	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"
+	#define MSG_REFRESH "Refresh"
+	#define MSG_WATCH "Info screen"
+	#define MSG_PREPARE "Prepare"
+	#define MSG_TUNE "Tune"
+	#define MSG_PAUSE_PRINT "Pause Print"
+	#define MSG_RESUME_PRINT "Resume Print"
+	#define MSG_STOP_PRINT "Stop Print"
+	#define MSG_CARD_MENU "Print from SD"
+	#define MSG_NO_CARD "No Card"
+	#define MSG_DWELL "Sleep..."
+	#define MSG_USERWAIT "Wait for user..."
+	#define MSG_RESUMING "Resuming print"
+	#define MSG_NO_MOVE "No move."
+	#define MSG_KILLED "KILLED. "
+	#define MSG_STOPPED "STOPPED. "
+	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACTF "Retract  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " External Reset"
+	#define MSG_BROWNOUT_RESET " Brown out Reset"
+	#define MSG_WATCHDOG_RESET " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET " Software Reset"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Last Updated: "
+	#define MSG_FREE_MEMORY " Free Memory: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Done saving file."
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "
+	#define MSG_FILE_PRINTED "Done printing file"
+	#define MSG_BEGIN_FILE_LIST "Begin file list"
+	#define MSG_END_FILE_LIST "End file list"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
+	#define MSG_HEATING "Heating..."
+	#define MSG_HEATING_COMPLETE "Heating done."
+	#define MSG_BED_HEATING "Bed Heating."
+	#define MSG_BED_DONE "Bed done."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Count X: "
+	#define MSG_ERR_KILLED "Printer halted. kill() called!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"
+	#define MSG_RESEND "Resend: "
+	#define MSG_UNKNOWN_COMMAND "Unknown command: \""
+	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
+	#define MSG_INVALID_EXTRUDER "Invalid extruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
+	#define MSG_SD_INIT_FAIL "SD init fail"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
+	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
+	#define MSG_SD_CARD_OK "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
+	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
+	#define MSG_SD_FILE_OPENED "File opened: "
+	#define MSG_SD_SIZE " Size: "
+	#define MSG_SD_FILE_SELECTED "File selected"
+	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
+	#define MSG_SD_PRINTING_BYTE "SD printing byte "
+	#define MSG_SD_NOT_PRINTING "Not SD printing"
+	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate too high: "
+	#define MSG_ENDSTOPS_HIT "endstops hit: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 2
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Gotowe."
+	#define MSG_SD_INSERTED "Karta wlozona"
+	#define MSG_SD_REMOVED "Karta usunieta"
+	#define MSG_MAIN "Main"
+	#define MSG_AUTOSTART "Autostart"
+	#define MSG_DISABLE_STEPPERS "Wylacz silniki"
+	#define MSG_AUTO_HOME "Auto. poz. zerowa"
+	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"
+	#define MSG_PREHEAT_PLA "Rozgrzej PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"
+	#define MSG_PREHEAT_ABS "Rozgrzej ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"
+	#define MSG_COOLDOWN "Chlodzenie"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_EXTRUDE "Ekstruzja"
+	#define MSG_RETRACT "Cofanie"
+	#define MSG_MOVE_AXIS "Ruch osi"
+	#define MSG_SPEED "Predkosc"
+	#define MSG_NOZZLE "Dysza"
+	#define MSG_NOZZLE1 "Dysza2"
+	#define MSG_NOZZLE2 "Dysza3"
+	#define MSG_BED "Loze"
+	#define MSG_FAN_SPEED "Obroty wiatraka"
+	#define MSG_FLOW "Przeplyw"
+	#define MSG_CONTROL "Kontrola"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Mnoznik"
+	#define MSG_AUTOTEMP "Auto. temp."
+	#define MSG_ON "Wl. "
+	#define MSG_OFF "Wyl."
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Acc"
+	#define MSG_VXY_JERK "Zryw Vxy"
 	#define MSG_VZ_JERK "Zryw Vz"
 	#define MSG_VE_JERK "Zryw Ve"
-	#define MSG_VMAX "Vmax"
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "Vskok min"
-	#define MSG_AMAX "Amax"
-	#define MSG_A_RETRACT "A-wycofanie"
-	#define MSG_XSTEPS "krokiX/mm"
-	#define MSG_YSTEPS "krokiY/mm"
-	#define MSG_ZSTEPS "krokiZ/mm"
-	#define MSG_ESTEPS "krokiE/mm"
-	#define MSG_RECTRACT "Wycofanie"
-	#define MSG_TEMPERATURE "Temperatura"
-	#define MSG_MOTION "Ruch"
-	#define MSG_STORE_EPROM "Zapisz w pamieci"
-	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
-	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
-	#define MSG_REFRESH "\004Odswiez"
-	#define MSG_WATCH "Obserwuj"
-	#define MSG_PREPARE "Przygotuj"
-	#define MSG_CONTROL "Kontroluj"
-	#define MSG_TUNE "Strojenie"
-	#define MSG_PAUSE_PRINT "Pauza"
-	#define MSG_RESUME_PRINT "Wznowienie"
-	#define MSG_STOP_PRINT "Stop"
-	#define MSG_CARD_MENU "Menu SDCard"
-	#define MSG_NO_CARD "Brak karty"
-	#define MSG_DWELL "Uspij..."
-	#define MSG_USERWAIT "Czekaj na uzytkownika..."
-	#define MSG_RESUMING "Wznawiam drukowanie"
-	#define MSG_NO_MOVE "Brak ruchu."
-	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
-	#define MSG_KILLED "Ubity. "
-	#define MSG_STOPPED "Zatrzymany. "
-	#define MSG_STEPPER_RELEASED "Zwolniony."
-	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
-	#define MSG_CONTROL_RETRACTF "Wycofaj  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
-	#define MSG_AUTORETRACT "Auto. wycofanie"
-	#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "Kolejkowanie \""
-	#define MSG_POWERUP "Zasilanie wlaczone"
-	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
-	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
-	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
-	#define MSG_SOFTWARE_RESET " Reset (programowy)"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Autor: "
-	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
-	#define MSG_FREE_MEMORY " Wolna pamiec: "
-	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Plik zapisany."
-	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
-	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
-	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
-	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
-	#define MSG_END_FILE_LIST "Koniec listy plikow"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
-	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
-	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
-	#define MSG_HEATING "Nagrzewanie ekstrudera..."
-	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
-	#define MSG_BED_HEATING "Nagrzewanie loza..."
-	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Liczenie X: "
-	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
-	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
-	#define MSG_RESEND "Wyslij ponownie: "
-	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
-	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
-	#define MSG_ENDSTOP_HIT "WYZWOLONY"
-	#define MSG_ENDSTOP_OPEN "otwarty"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
-	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
-	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
-	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
-	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
-	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
-	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
-	#define MSG_SD_FILE_OPENED "Otwarto plik:"
-	#define MSG_SD_SIZE " Rozmiar:"
-	#define MSG_SD_FILE_SELECTED "Wybrano plik"
-	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
-	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
-	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
-
-	#define MSG_STEPPER_TO_HIGH "Za duza czestotliwosc krokow: "
-	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 3
-
-#define WELCOME_MSG MACHINE_NAME " Pret."
-#define MSG_SD_INSERTED "Carte inseree"
-#define MSG_SD_REMOVED "Carte retiree"
-#define MSG_MAIN " Principal \003"
-#define MSG_AUTOSTART " Demarrage auto."
-#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
-#define MSG_AUTO_HOME " Home auto."
-#define MSG_SET_ORIGIN " Regler origine"
-#define MSG_PREHEAT_PLA " Prechauffage PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
-#define MSG_PREHEAT_ABS " Prechauffage ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
-#define MSG_COOLDOWN " Refroidissement"
-#define MSG_EXTRUDE " Extrusion"
-#define MSG_RETRACT " Retractation"
-#define MSG_PREHEAT_PLA " Prechauffage PLA"
-#define MSG_PREHEAT_ABS " Prechauffage ABS"
-#define MSG_MOVE_AXIS " Deplacer axe \x7E"
-#define MSG_SPEED " Vitesse:"
-#define MSG_NOZZLE " \002Buse:"
-#define MSG_NOZZLE1 " \002Buse2:"
-#define MSG_NOZZLE2 " \002Buse3:"
-#define MSG_BED " \002Lit:"
-#define MSG_FAN_SPEED " Vitesse ventilateur:"
-#define MSG_FLOW " Flux:"
-#define MSG_CONTROL " Controle \003"
-#define MSG_MIN " \002 Min:"
-#define MSG_MAX " \002 Max:"
-#define MSG_FACTOR " \002 Facteur:"
-#define MSG_AUTOTEMP " Temp. Auto.:"
-#define MSG_ON "Marche "
-#define MSG_OFF "Arret"
-#define MSG_PID_P " PID-P: "
-#define MSG_PID_I " PID-I: "
-#define MSG_PID_D " PID-D: "
-#define MSG_PID_C " PID-C: "
-#define MSG_ACC " Acc:"
-#define MSG_VXY_JERK "Vxy-jerk"
-#define MSG_VZ_JERK "Vz-jerk"
-#define MSG_VE_JERK "Ve-jerk"
-#define MSG_VMAX " Vmax "
-#define MSG_X "x:"
-#define MSG_Y "y:"
-#define MSG_Z "z:"
-#define MSG_E "e:"
-#define MSG_VMIN " Vmin:"
-#define MSG_VTRAV_MIN " Vdepl min:"
-#define MSG_AMAX " Amax "
-#define MSG_A_RETRACT " A-retract:"
-#define MSG_XSTEPS " Xpas/mm:"
-#define MSG_YSTEPS " Ypas/mm:"
-#define MSG_ZSTEPS " Zpas/mm:"
-#define MSG_ESTEPS " Epas/mm:"
-#define MSG_MAIN_WIDE " Principal \003"
-#define MSG_RECTRACT_WIDE " Rectractater \x7E"
-#define MSG_TEMPERATURE_WIDE " Temperature \x7E"
-#define MSG_TEMPERATURE_RTN " Temperature \003"
-#define MSG_MOTION_WIDE " Mouvement \x7E"
-#define MSG_STORE_EPROM " Sauvegarder memoire"
-#define MSG_LOAD_EPROM " Lire memoire"
-#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
-#define MSG_REFRESH "\004Actualiser"
-#define MSG_WATCH " Surveiller \003"
-#define MSG_PREPARE " Preparer \x7E"
-#define MSG_PREPARE_ALT " Prepare \003"
-#define MSG_CONTROL_ARROW " Controle \x7E"
-#define MSG_RETRACT_ARROW " Retracter \x7E"
-#define MSG_TUNE " Regler \x7E"
-#define MSG_PAUSE_PRINT " Pause impression \x7E"
-#define MSG_RESUME_PRINT " Reprendre impression \x7E"
-#define MSG_STOP_PRINT " Arreter impression \x7E"
-#define MSG_CARD_MENU " Menu carte \x7E"
-#define MSG_NO_CARD " Pas de carte"
-#define MSG_DWELL "Repos..."
-#define MSG_USERWAIT "Attente de l'utilisateur..."
-#define MSG_NO_MOVE "Aucun mouvement."
-#define MSG_PART_RELEASE "Relache partielle"
-#define MSG_KILLED "TUE."
-#define MSG_STOPPED "STOPPE."
-#define MSG_STEPPER_RELEASED "RELACHE."
-#define MSG_CONTROL_RETRACT " Retractation mm:"
-#define MSG_CONTROL_RETRACTF " Retractation F:"
-#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
-#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
-#define MSG_AUTORETRACT " Retract. Auto.:"
-#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-#define MSG_Enqueing "Mise en tampon \""
-#define MSG_POWERUP "Allumage"
-#define MSG_EXTERNAL_RESET " RAZ Externe"
-#define MSG_BROWNOUT_RESET " RAZ defaut alim."
-#define MSG_WATCHDOG_RESET " RAZ Watchdog"
-#define MSG_SOFTWARE_RESET " RAZ logicielle"
-#define MSG_MARLIN "Marlin "
-#define MSG_AUTHOR " | Auteur: "
-#define MSG_CONFIGURATION_VER " Derniere MaJ: "
-#define MSG_FREE_MEMORY " Memoire libre: "
-#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
-#define MSG_OK "ok"
-#define MSG_FILE_SAVED "Fichier enregistre."
-#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
-#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
-#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
-#define MSG_FILE_PRINTED "Impression terminee"
-#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
-#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
-#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
-#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
-#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
-#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
-#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
-#define MSG_HEATING "En chauffe..."
-#define MSG_HEATING_COMPLETE "Chauffe terminee."
-#define MSG_BED_HEATING "Chauffe du lit."
-#define MSG_BED_DONE "Chauffe du lit terminee."
-#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X " Compteur X: "
-#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
-#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
-#define MSG_RESEND "Renvoie: "
-#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
-#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
-#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
-#define MSG_X_MIN "x_min: "
-#define MSG_X_MAX "x_max: "
-#define MSG_Y_MIN "y_min: "
-#define MSG_Y_MAX "y_max: "
-#define MSG_Z_MIN "z_min: "
-#define MSG_Z_MAX "z_max: "
-#define MSG_M119_REPORT "Affichage du status des fin de course"
-#define MSG_ENDSTOP_HIT "DECLENCHE"
-#define MSG_ENDSTOP_OPEN "OUVERT"
-#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
-#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
-#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
-#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
-#define MSG_SD_CARD_OK "Carte SD Ok"
-#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
-#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
-#define MSG_SD_FILE_OPENED "Fichier ouvert: "
-#define MSG_SD_SIZE " Taille: "
-#define MSG_SD_FILE_SELECTED "Fichier selectionne"
-#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
-#define MSG_SD_PRINTING_BYTE "Octet impression SD "
-#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
-#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
-#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
-
-#define MSG_STEPPER_TO_HIGH "Steprate trop eleve: "
-#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
-#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
-#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
-	
-#endif
-
-
-#if LANGUAGE_CHOICE == 4
-
-// LCD Menu Messages
-
-	#define WELCOME_MSG MACHINE_NAME " Bereit."
-
-	#define MSG_SD_INSERTED      "SDKarte erkannt"
-	#define MSG_SD_REMOVED       "SDKarte entfernt"
-	#define MSG_MAIN             "Hauptmneü"
-	#define MSG_AUTOSTART        "Autostart"
-	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
-	#define MSG_AUTO_HOME        "Auto Nullpunkt"
-	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
-	#define MSG_PREHEAT_PLA      "Vorwärmen PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Vorwärmen PLA Einstellungen"
-	#define MSG_PREHEAT_ABS      "Vorwärmen ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Vorwärmen ABS Einstellungen"
-	#define MSG_COOLDOWN         "Abkühlen"
-	#define MSG_EXTRUDE          "Extrude"
-	#define MSG_RETRACT          "Retract"
-	#define MSG_MOVE_AXIS        "Achsen bewegen"
-	#define MSG_SPEED            "Geschw"
-	#define MSG_NOZZLE           "Düse"
-	#define MSG_NOZZLE1          "Düse2"
-	#define MSG_NOZZLE2          "Düse3"
-	#define MSG_BED              "Bett"
-	#define MSG_FAN_SPEED        "Lüftergeschw."
-	#define MSG_FLOW             "Fluß"
-	#define MSG_CONTROL          "Einstellungen"
-	#define MSG_MIN              "\002 Min"
-	#define MSG_MAX              "\002 Max"
-	#define MSG_FACTOR           "\002 Faktor"
-	#define MSG_AUTOTEMP         "AutoTemp"
-	#define MSG_ON               "Ein"
-	#define MSG_OFF              "Aus"
-	#define MSG_PID_P            "PID-P"
-	#define MSG_PID_I            "PID-I"
-	#define MSG_PID_D            "PID-D"
-	#define MSG_PID_C            "PID-C"
-	#define MSG_ACC              "Acc"
-	#define MSG_VXY_JERK         "Vxy-jerk"
+	#define MSG_VMAX "Vmax"
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "Vskok min"
+	#define MSG_AMAX "Amax"
+	#define MSG_A_RETRACT "A-wycofanie"
+	#define MSG_XSTEPS "krokiX/mm"
+	#define MSG_YSTEPS "krokiY/mm"
+	#define MSG_ZSTEPS "krokiZ/mm"
+	#define MSG_ESTEPS "krokiE/mm"
+	#define MSG_RECTRACT "Wycofanie"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Ruch"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM "Zapisz w pamieci"
+	#define MSG_LOAD_EPROM "Wczytaj z pamieci"
+	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"
+	#define MSG_REFRESH "\004Odswiez"
+	#define MSG_WATCH "Obserwuj"
+	#define MSG_PREPARE "Przygotuj"
+	#define MSG_CONTROL "Kontroluj"
+	#define MSG_TUNE "Strojenie"
+	#define MSG_PAUSE_PRINT "Pauza"
+	#define MSG_RESUME_PRINT "Wznowienie"
+	#define MSG_STOP_PRINT "Stop"
+	#define MSG_CARD_MENU "Menu SDCard"
+	#define MSG_NO_CARD "Brak karty"
+	#define MSG_DWELL "Uspij..."
+	#define MSG_USERWAIT "Czekaj na uzytkownika..."
+	#define MSG_RESUMING "Wznawiam drukowanie"
+	#define MSG_NO_MOVE "Brak ruchu."
+	#define MSG_PART_RELEASE "Czesciowe zwolnienie"
+	#define MSG_KILLED "Ubity. "
+	#define MSG_STOPPED "Zatrzymany. "
+	#define MSG_STEPPER_RELEASED "Zwolniony."
+	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
+	#define MSG_CONTROL_RETRACTF "Wycofaj  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"
+	#define MSG_AUTORETRACT "Auto. wycofanie"
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "Kolejkowanie \""
+	#define MSG_POWERUP "Zasilanie wlaczone"
+	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"
+	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"
+	#define MSG_WATCHDOG_RESET " Reset (watchdog)"
+	#define MSG_SOFTWARE_RESET " Reset (programowy)"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "
+	#define MSG_FREE_MEMORY " Wolna pamiec: "
+	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Plik zapisany."
+	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "
+	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"
+	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"
+	#define MSG_BEGIN_FILE_LIST "Start listy plikow"
+	#define MSG_END_FILE_LIST "Koniec listy plikow"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "
+	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("
+	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "
+	#define MSG_HEATING "Nagrzewanie ekstrudera..."
+	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."
+	#define MSG_BED_HEATING "Nagrzewanie loza..."
+	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Liczenie X: "
+	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"
+	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"
+	#define MSG_RESEND "Wyslij ponownie: "
+	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "
+	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"
+	#define MSG_ENDSTOP_HIT "WYZWOLONY"
+	#define MSG_ENDSTOP_OPEN "otwarty"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"
+	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"
+	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"
+	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"
+	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"
+	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"
+	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "
+	#define MSG_SD_FILE_OPENED "Otwarto plik:"
+	#define MSG_SD_SIZE " Rozmiar:"
+	#define MSG_SD_FILE_SELECTED "Wybrano plik"
+	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "
+	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "
+	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "
+
+	#define MSG_STEPPER_TOO_HIGH "Za duza czestotliwosc krokow: "
+	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 3
+
+	#define WELCOME_MSG MACHINE_NAME " Pret."
+	#define MSG_SD_INSERTED "Carte inseree"
+	#define MSG_SD_REMOVED "Carte retiree"
+	#define MSG_MAIN " Principal \003"
+	#define MSG_AUTOSTART " Demarrage auto."
+	#define MSG_DISABLE_STEPPERS " Desactiver moteurs"
+	#define MSG_AUTO_HOME " Home auto."
+	#define MSG_SET_ORIGIN " Regler origine"
+	#define MSG_PREHEAT_PLA " Prechauffage PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"
+	#define MSG_PREHEAT_ABS " Prechauffage ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " Regl. prechauffe ABS"
+	#define MSG_COOLDOWN " Refroidissement"
+	#define MSG_SWITCH_PS_ON "Allumer alimentation"
+	#define MSG_SWITCH_PS_OFF "Eteindre alimentation"
+	#define MSG_EXTRUDE " Extrusion"
+	#define MSG_RETRACT " Retractation"
+	#define MSG_PREHEAT_PLA " Prechauffage PLA"
+	#define MSG_PREHEAT_ABS " Prechauffage ABS"
+	#define MSG_MOVE_AXIS " Deplacer axe \x7E"
+	#define MSG_SPEED " Vitesse:"
+	#define MSG_NOZZLE " \002Buse:"
+	#define MSG_NOZZLE1 " \002Buse2:"
+	#define MSG_NOZZLE2 " \002Buse3:"
+	#define MSG_BED " \002Lit:"
+	#define MSG_FAN_SPEED " Vitesse ventilateur:"
+	#define MSG_FLOW " Flux:"
+	#define MSG_CONTROL " Controle \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Facteur:"
+	#define MSG_AUTOTEMP " Temp. Auto.:"
+	#define MSG_ON "Marche "
+	#define MSG_OFF "Arret"
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC " Acc:"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VZ_JERK "Vz-jerk"
+	#define MSG_VE_JERK "Ve-jerk"
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " Vdepl min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_XSTEPS " Xpas/mm:"
+	#define MSG_YSTEPS " Ypas/mm:"
+	#define MSG_ZSTEPS " Zpas/mm:"
+	#define MSG_ESTEPS " Epas/mm:"
+	#define MSG_MAIN_WIDE " Principal \003"
+	#define MSG_RECTRACT "Rectracter"
+	#define MSG_TEMPERATURE "Temperature"
+	#define MSG_MOTION "Mouvement"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM " Sauvegarder memoire"
+	#define MSG_LOAD_EPROM " Lire memoire"
+	#define MSG_RESTORE_FAILSAFE " Restaurer memoire"
+	#define MSG_REFRESH "\004Actualiser"
+	#define MSG_WATCH " Surveiller \003"
+	#define MSG_PREPARE " Preparer \x7E"
+	#define MSG_PREPARE_ALT " Prepare \003"
+	#define MSG_CONTROL_ARROW " Controle \x7E"
+	#define MSG_RETRACT_ARROW " Retracter \x7E"
+	#define MSG_TUNE " Regler \x7E"
+	#define MSG_PAUSE_PRINT " Pause impression \x7E"
+	#define MSG_RESUME_PRINT " Reprendre impression \x7E"
+	#define MSG_STOP_PRINT " Arreter impression \x7E"
+	#define MSG_CARD_MENU " Menu carte \x7E"
+	#define MSG_NO_CARD " Pas de carte"
+	#define MSG_DWELL "Repos..."
+	#define MSG_USERWAIT "Attente de l'utilisateur..."
+	#define MSG_RESUMING "Reprise de l'impression"
+	#define MSG_NO_MOVE "Aucun mouvement."
+	#define MSG_PART_RELEASE "Relache partielle"
+	#define MSG_KILLED "TUE."
+	#define MSG_STOPPED "STOPPE."
+	#define MSG_STEPPER_RELEASED "RELACHE."
+	#define MSG_CONTROL_RETRACT " Retractation mm:"
+	#define MSG_CONTROL_RETRACTF " Retractation F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Hop mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " UnRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " UnRet F:"
+	#define MSG_AUTORETRACT " Retract. Auto.:"
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. la carte SD"	
+	#define MSG_CNG_SDCARD "Changer de carte SD"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "Mise en tampon \""
+	#define MSG_POWERUP "Allumage"
+	#define MSG_EXTERNAL_RESET " RAZ Externe"
+	#define MSG_BROWNOUT_RESET " RAZ defaut alim."
+	#define MSG_WATCHDOG_RESET " RAZ Watchdog"
+	#define MSG_SOFTWARE_RESET " RAZ logicielle"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Auteur: "
+	#define MSG_CONFIGURATION_VER " Derniere MaJ: "
+	#define MSG_FREE_MEMORY " Memoire libre: "
+	#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Fichier enregistre."
+	#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "
+	#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "
+	#define MSG_FILE_PRINTED "Impression terminee"
+	#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"
+	#define MSG_END_FILE_LIST "Fin de la liste de fichiers"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"
+	#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"
+	#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "
+	#define MSG_HEATING "En chauffe..."
+	#define MSG_HEATING_COMPLETE "Chauffe terminee."
+	#define MSG_BED_HEATING "Chauffe du lit."
+	#define MSG_BED_DONE "Chauffe du lit terminee."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Compteur X: "
+	#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"
+	#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"
+	#define MSG_RESEND "Renvoie: "
+	#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""
+	#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "
+	#define MSG_INVALID_EXTRUDER "Extrudeur invalide"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Affichage du status des fin de course"
+	#define MSG_ENDSTOP_HIT "DECLENCHE"
+	#define MSG_ENDSTOP_OPEN "OUVERT"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"
+	#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"
+	#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"
+	#define MSG_SD_OPENROOT_FAIL "Echec openRoot"
+	#define MSG_SD_CARD_OK "Carte SD Ok"
+	#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"
+	#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "
+	#define MSG_SD_FILE_OPENED "Fichier ouvert: "
+	#define MSG_SD_SIZE " Taille: "
+	#define MSG_SD_FILE_SELECTED "Fichier selectionne"
+	#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "
+	#define MSG_SD_PRINTING_BYTE "Octet impression SD "
+	#define MSG_SD_NOT_PRINTING "Pas d'impression SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate trop eleve: "
+	#define MSG_ENDSTOPS_HIT "Fin de course atteint: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"
+	
+#endif
+
+
+#if LANGUAGE_CHOICE == 4
+
+// LCD Menu Messages
+
+	#define WELCOME_MSG MACHINE_NAME " Bereit."
+
+	#define MSG_SD_INSERTED      "SDKarte erkannt"
+	#define MSG_SD_REMOVED       "SDKarte entfernt"
+	#define MSG_MAIN             "Hauptmenü"
+	#define MSG_AUTOSTART        "Autostart"
+	#define MSG_DISABLE_STEPPERS "Stepper abschalten"
+	#define MSG_AUTO_HOME        "Auto Nullpunkt"
+	#define MSG_SET_ORIGIN       "Setze Nullpunkt"
+	#define MSG_PREHEAT_PLA      "Vorwärmen PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Vorwärmen PLA Einstellungen"
+	#define MSG_PREHEAT_ABS      "Vorwärmen ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Vorwärmen ABS Einstellungen"
+	#define MSG_COOLDOWN         "Abkühlen"
+	#define MSG_SWITCH_PS_ON     "Switch Power On"
+	#define MSG_SWITCH_PS_OFF    "Switch Power Off"
+	#define MSG_EXTRUDE          "Extrude"
+	#define MSG_RETRACT          "Retract"
+	#define MSG_MOVE_AXIS        "Achsen bewegen"
+	#define MSG_SPEED            "Geschw"
+	#define MSG_NOZZLE           "Düse"
+	#define MSG_NOZZLE1          "Düse2"
+	#define MSG_NOZZLE2          "Düse3"
+	#define MSG_BED              "Bett"
+	#define MSG_FAN_SPEED        "Lüftergeschw."
+	#define MSG_FLOW             "Fluss"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_MIN              "\002 Min"
+	#define MSG_MAX              "\002 Max"
+	#define MSG_FACTOR           "\002 Faktor"
+	#define MSG_AUTOTEMP         "AutoTemp"
+	#define MSG_ON               "Ein"
+	#define MSG_OFF              "Aus"
+	#define MSG_PID_P            "PID-P"
+	#define MSG_PID_I            "PID-I"
+	#define MSG_PID_D            "PID-D"
+	#define MSG_PID_C            "PID-C"
+	#define MSG_ACC              "Acc"
+	#define MSG_VXY_JERK         "Vxy-jerk"
 	#define MSG_VZ_JERK          "Vz-jerk"
 	#define MSG_VE_JERK          "Ve-jerk"
-	#define MSG_VMAX             "Vmax "
-	#define MSG_X                "x"
-	#define MSG_Y                "y"
-	#define MSG_Z                "z"
-	#define MSG_E                "e"
-	#define MSG_VMIN             "Vmin"
-	#define MSG_VTRAV_MIN        "VTrav min"
-	#define MSG_AMAX             "Amax "
-	#define MSG_A_RETRACT        "A-Retract"
-	#define MSG_XSTEPS           "Xsteps/mm"
-	#define MSG_YSTEPS           "Ysteps/mm"
-	#define MSG_ZSTEPS           "Zsteps/mm"
-	#define MSG_ESTEPS           "Esteps/mm"
-	#define MSG_RECTRACT_WIDE    "Rectract"
-	#define MSG_WATCH            "Beobachten"
-	#define MSG_TEMPERATURE      "Temperatur"
-	#define MSG_MOTION           "Bewegung"
-	#define MSG_STORE_EPROM      "EPROM speichern"
-	#define MSG_LOAD_EPROM       "EPROM laden"
-	#define MSG_RESTORE_FAILSAFE "Standardkonfig."
-	#define MSG_REFRESH          "Aktualisieren"
-	#define MSG_PREPARE          "Vorbereitung"
-	#define MSG_CONTROL          "Einstellungen"
-	#define MSG_TUNE             "Justierung"
-	#define MSG_PAUSE_PRINT      "Druck anhalten"
-	#define MSG_RESUME_PRINT     "Druck fortsetz"
-	#define MSG_STOP_PRINT       "Druck stoppen"
-	#define MSG_CARD_MENU        "SDKarten Menü"
-	#define MSG_NO_CARD          "Keine SDKarte"
-	#define MSG_DWELL            "Warten..."		
-	#define MSG_USERWAIT         "Warte auf Nutzer..."
-    #define MSG_RESUMING         "Druck fortsetzung"
-	#define MSG_NO_MOVE          "Kein Zug."
-	#define MSG_PART_RELEASE     "Stepper tlw frei"
-	#define MSG_KILLED           "KILLED"
-	#define MSG_STOPPED          "GESTOPPT"
-	#define MSG_STEPPER_RELEASED "Stepper frei"
-    #define MSG_CONTROL_RETRACT  "Retract mm"
-    #define MSG_CONTROL_RETRACTF "Retract  F"
-    #define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
-    #define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-    #define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-    #define MSG_AUTORETRACT      "AutoRetr."
-    #define MSG_FILAMENTCHANGE "Filament wechseln"
-	
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " External Reset"
-	#define MSG_BROWNOUT_RESET " Brown out Reset"
-	#define MSG_WATCHDOG_RESET " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET " Software Reset"
-	#define MSG_MARLIN "Marlin: "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Last Updated: "
-	#define MSG_FREE_MEMORY " Free Memory: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Done saving file."
-	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
-	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
-	#define MSG_FILE_PRINTED "Done printing file"
-	#define MSG_BEGIN_FILE_LIST "Begin file list"
-	#define MSG_END_FILE_LIST "End file list"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
-	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
-	#define MSG_HEATING "Heating..."
-	#define MSG_HEATING_COMPLETE "Heating done."
-	#define MSG_BED_HEATING "Bed Heating."
-	#define MSG_BED_DONE "Bed done."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Count X:"
-	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
-	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"
-	#define MSG_RESEND "Resend:"
-	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
-	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
-	#define MSG_INVALID_EXTRUDER "Invalid extruder"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Reporting endstop status"
-	#define MSG_ENDSTOP_HIT "TRIGGERED"
-	#define MSG_ENDSTOP_OPEN "open"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
-	#define MSG_SD_INIT_FAIL "SD init fail"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
-	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
-	#define MSG_SD_CARD_OK "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
-	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
-	#define MSG_SD_FILE_OPENED "File opened:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "File selected"
-	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
-	#define MSG_SD_PRINTING_BYTE "SD printing byte "
-	#define MSG_SD_NOT_PRINTING "Not SD printing"
-	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
-
-	#define MSG_STEPPER_TO_HIGH "Steprate to high : "
-	#define MSG_ENDSTOPS_HIT "endstops hit: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 5
-
-// LCD Menu Messages
-#define WELCOME_MSG MACHINE_NAME " Lista."
-#define MSG_SD_INSERTED "Tarjeta SD Colocada"
-#define MSG_SD_REMOVED "Tarjeta SD Retirada"
-#define MSG_MAIN " Menu Principal \003"
-#define MSG_AUTOSTART " Autostart"
-#define MSG_DISABLE_STEPPERS " Apagar Motores"
-#define MSG_AUTO_HOME " Llevar Ejes al Cero"
-#define MSG_SET_ORIGIN " Establecer Cero"
-#define MSG_COOLDOWN " Enfriar"
-#define MSG_EXTRUDE " Extruir"
-#define MSG_RETRACT " Retraer"
-#define MSG_PREHEAT_PLA " Precalentar PLA"
-#define MSG_PREHEAT_PLA_SETTINGS " Ajustar temp. PLA"
-#define MSG_PREHEAT_ABS " Precalentar ABS"
-#define MSG_PREHEAT_ABS_SETTINGS " Ajustar temp. ABS"
-#define MSG_MOVE_AXIS " Mover Ejes      \x7E"
-#define MSG_SPEED " Velocidad:"
-#define MSG_NOZZLE " \002Nozzle:"
-#define MSG_NOZZLE1 " \002Nozzle2:"
-#define MSG_NOZZLE2 " \002Nozzle3:"
-#define MSG_BED " \002Base:"
-#define MSG_FAN_SPEED " Ventilador:"
-#define MSG_FLOW " Flujo:"
-#define MSG_CONTROL " Control \003"
-#define MSG_MIN " \002 Min:"
-#define MSG_MAX " \002 Max:"
-#define MSG_FACTOR " \002 Fact:"
-#define MSG_AUTOTEMP " Autotemp:"
-#define MSG_ON "On "
-#define MSG_OFF "Off"
-#define MSG_PID_P " PID-P: "
-#define MSG_PID_I " PID-I: "
-#define MSG_PID_D " PID-D: "
-#define MSG_PID_C " PID-C: "
-#define MSG_ACC  " Acc:"
-#define MSG_VXY_JERK " Vxy-jerk: "
-#define MSG_VZ_JERK "Vz-jerk"
-#define MSG_VE_JERK "Ve-jerk"
-#define MSG_VMAX " Vmax "
-#define MSG_X "x:"
-#define MSG_Y "y:"
-#define MSG_Z "z:"
-#define MSG_E "e:"
-#define MSG_VMIN " Vmin:"
-#define MSG_VTRAV_MIN " VTrav min:"
-#define MSG_AMAX " Amax "
-#define MSG_A_RETRACT " A-retrac.:"
-#define MSG_XSTEPS " Xpasos/mm:"
-#define MSG_YSTEPS " Ypasos/mm:"
-#define MSG_ZSTEPS " Zpasos/mm:"
-#define MSG_ESTEPS " Epasos/mm:"
-#define MSG_MAIN_WIDE " Menu Principal  \003"
-#define MSG_RECTRACT_WIDE " Retraer         \x7E"
-#define MSG_TEMPERATURE_WIDE " Temperatura     \x7E"
-#define MSG_TEMPERATURE_RTN  " Temperatura     \003"
-#define MSG_MOTION_WIDE " Movimiento      \x7E"
-#define MSG_STORE_EPROM " Guardar Memoria"
-#define MSG_LOAD_EPROM " Cargar Memoria"
-#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
-#define MSG_REFRESH "\004Volver a cargar"
-#define MSG_WATCH " Monitorizar \003"
-#define MSG_PREPARE " Preparar \x7E"
-#define MSG_PREPARE_ALT " Preparar \003"
-#define MSG_CONTROL_ARROW " Control  \x7E"
-#define MSG_RETRACT_ARROW " Retraer  \x7E"
-#define MSG_TUNE " Ajustar \x7E"
-#define MSG_PAUSE_PRINT " Pausar Impresion \x7E"
-#define MSG_RESUME_PRINT " Reanudar Impresion \x7E"
-#define MSG_STOP_PRINT " Detener Impresion \x7E"
-#define MSG_CARD_MENU " Menu de SD    \x7E"
-#define MSG_NO_CARD " No hay Tarjeta SD"
-#define MSG_DWELL "Reposo..."
-#define MSG_USERWAIT "Esperando Ordenes..."
-#define MSG_NO_MOVE "Sin movimiento"
-#define MSG_PART_RELEASE "Desacople Parcial"
-#define MSG_KILLED "PARADA DE EMERGENCIA. "
-#define MSG_STOPPED "PARADA. "
-#define MSG_STEPPER_RELEASED "Desacoplada."
-#define MSG_CONTROL_RETRACT  " Retraer mm:"
-#define MSG_CONTROL_RETRACTF " Retraer  F:"
-#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
-#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF " DesRet F:"
-#define MSG_AUTORETRACT " AutoRetr.:"
-#define MSG_FILAMENTCHANGE "Change filament"
-// Serial Console Messages
-
-#define MSG_Enqueing "En cola \""
-#define MSG_POWERUP "PowerUp"
-#define MSG_EXTERNAL_RESET " Reset Externo"
-#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
-#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
-#define MSG_SOFTWARE_RESET " Reset por Software"
-#define MSG_MARLIN "Marlin "
-#define MSG_AUTHOR " | Autor: "
-#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
-#define MSG_FREE_MEMORY " Memoria libre: "
-#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-#define MSG_OK "ok"
-#define MSG_FILE_SAVED "Guardado."
-#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"
-#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"
-#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"
-#define MSG_FILE_PRINTED "Impresion terminada"
-#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"
-#define MSG_END_FILE_LIST "Fin de la lista de archivos"
-#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
-#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
-#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
-#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
-#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
-#define MSG_HEATING "Calentando..."
-#define MSG_HEATING_COMPLETE "Calentamiento Hecho."
-#define MSG_BED_HEATING "Calentando la base."
-#define MSG_BED_DONE "Base Caliente."
-#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X " Cuenta X:"
-#define MSG_ERR_KILLED "¡¡Impresora Parada con kill()!!"
-#define MSG_ERR_STOPPED "¡Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela antes de continuar)"
-#define MSG_RESEND "Reenviar:"
-#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
-#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
-#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
-#define MSG_X_MIN "x_min: "
-#define MSG_X_MAX "x_max: "
-#define MSG_Y_MIN "y_min: "
-#define MSG_Y_MAX "y_max: "
-#define MSG_Z_MIN "z_min: "
-#define MSG_M119_REPORT "Comprobando fines de carrera."
-#define MSG_ENDSTOP_HIT "PULSADO"
-#define MSG_ENDSTOP_OPEN "abierto"
-#define MSG_HOTEND_OFFSET "Hotend offsets:"
-        
-#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
-#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
-#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
-#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"
-#define MSG_SD_CARD_OK "Tarjeta SD OK"
-#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"
-#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "
-#define MSG_SD_FILE_OPENED "Archivo abierto:"
-#define MSG_SD_SIZE " Tamaño:"
-#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"
-#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "
-#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
-#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
-#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
-#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
-
-#define MSG_STEPPER_TO_HIGH "Steprate demasiado alto : "
-#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
-#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
-#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
-
-#endif
-
-#if LANGUAGE_CHOICE == 6
-
-// LCD Menu Messages
-#define WELCOME_MSG MACHINE_NAME			" Готов"
-#define MSG_SD_INSERTED						"Карта вставлена"
-#define MSG_SD_REMOVED						"Карта извлечена"
-#define MSG_MAIN							" Меню              \003"
-#define MSG_AUTOSTART						" Автостарт          "
-#define MSG_DISABLE_STEPPERS				" Выключить двигатели"
-#define MSG_AUTO_HOME						" Парковка           "
-#define MSG_SET_ORIGIN						" Запомнить ноль     "
-#define MSG_PREHEAT_PLA						" Преднагрев PLA     "
-#define MSG_PREHEAT_PLA_SETTINGS			" Настр. преднагр.PLA"
-#define MSG_PREHEAT_ABS						" Преднагрев ABS     "
-#define MSG_PREHEAT_ABS_SETTINGS			" Настр. преднагр.ABS"
-#define MSG_COOLDOWN						" Охлаждение         "
-#define MSG_EXTRUDE							" Экструзия          "
-#define MSG_RETRACT							" Откат"
-#define MSG_MOVE_AXIS						" Движение по осям  \x7E"
-#define MSG_SPEED							" Скорость:"
-#define MSG_NOZZLE							" \002 Фильера:"
-#define MSG_NOZZLE1							" \002 Фильера2:"
-#define MSG_NOZZLE2							" \002 Фильера3:"
-#define MSG_BED								" \002 Кровать:"
-#define MSG_FAN_SPEED						" Куллер:"
-#define MSG_FLOW							" Поток:"
-#define MSG_CONTROL							" Настройки \003"
-#define MSG_MIN								" \002 Минимум:"
-#define MSG_MAX								" \002 Максимум:"
-#define MSG_FACTOR							" \002 Фактор:"
-#define MSG_AUTOTEMP						" Autotemp:"
-#define MSG_ON								"Вкл. "
-#define MSG_OFF								"Выкл. "
-#define MSG_PID_P							" PID-P: "
-#define MSG_PID_I							" PID-I: "
-#define MSG_PID_D							" PID-D: "
-#define MSG_PID_C							" PID-C: "
-#define MSG_ACC								" Acc:"
-#define MSG_VXY_JERK						" Vxy-jerk: "
-#define MSG_VZ_JERK                         "Vz-jerk"
-#define MSG_VE_JERK                         "Ve-jerk"
-#define MSG_VMAX							" Vmax "
-#define MSG_X								"x:"
-#define MSG_Y								"y:"
-#define MSG_Z								"z:"
-#define MSG_E								"e:"
-#define MSG_VMIN							" Vmin:"
-#define MSG_VTRAV_MIN						" VTrav min:"
-#define MSG_AMAX							" Amax "
-#define MSG_A_RETRACT						" A-retract:"
-#define MSG_XSTEPS							" X шаг/mm:"
-#define MSG_YSTEPS							" Y шаг/mm:"
-#define MSG_ZSTEPS							" Z шаг/mm:"
-#define MSG_ESTEPS							" E шаг/mm:"
-#define MSG_RECTRACT    					" Откат подачи      \x7E"
-#define MSG_TEMPERATURE  				" Температура       \x7E"
-#define MSG_MOTION						" Скорости          \x7E"
-#define MSG_STORE_EPROM						" Сохранить настройки"
-#define MSG_LOAD_EPROM						" Загрузить настройки"
-#define MSG_RESTORE_FAILSAFE				" Сброс настроек     "
-#define MSG_REFRESH							"\004Обновить           "
-#define MSG_WATCH							" Обзор             \003"
-#define MSG_PREPARE							" Действия          \x7E"
-#define MSG_TUNE					" Настройки         \x7E"
-#define MSG_PAUSE_PRINT						" Пауза печати      \x7E"
-#define MSG_RESUME_PRINT					" Продолжить печать \x7E"
-#define MSG_STOP_PRINT						" Остановить печать \x7E"
-#define MSG_CARD_MENU						" Меню карты        \x7E"
-#define MSG_NO_CARD							" Нет карты"
-#define MSG_DWELL							"Сон..."
-#define MSG_USERWAIT						"Нажмите для продолж."
-#define MSG_NO_MOVE							"Нет движения.       "
-#define MSG_PART_RELEASE					" Извлечение принта  "
-#define MSG_KILLED							"УБИТО. "
-#define MSG_STOPPED							"ОСТАНОВЛЕНО. "
-#define MSG_CONTROL_RETRACT					" Откат mm:"
-#define MSG_CONTROL_RETRACTF				" Откат  F:"
-#define MSG_CONTROL_RETRACT_ZLIFT			" Прыжок mm:"
-#define MSG_CONTROL_RETRACT_RECOVER			" Возврат +mm:"
-#define MSG_CONTROL_RETRACT_RECOVERF		" Возврат  F:"
-#define MSG_AUTORETRACT						" АвтоОткат:"
-#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-#define MSG_Enqueing						"Запланировано \""
-#define MSG_POWERUP							"Включение питания"
-#define MSG_EXTERNAL_RESET					" Внешний сброс"
-#define MSG_BROWNOUT_RESET					" Brown out сброс"
-#define MSG_WATCHDOG_RESET					" Watchdog сброс"
-#define MSG_SOFTWARE_RESET					" программный сброс"
-#define MSG_MARLIN							"Marlin "
-#define MSG_AUTHOR							" | Автор: "
-#define MSG_CONFIGURATION_VER				" Последнее обновление: "
-#define MSG_FREE_MEMORY						" Памяти свободно: "
-#define MSG_PLANNER_BUFFER_BYTES			"  Буффер очереди команд Bytes: "
-#define MSG_OK								"ok"
-#define MSG_FILE_SAVED						"Файл записан."
-#define MSG_ERR_LINE_NO						"Номен строки это не последняя строка+1, последняя строка:"
-#define MSG_ERR_CHECKSUM_MISMATCH			"контрольная сумма не совпадает, последняя строка:"
-#define MSG_ERR_NO_CHECKSUM					"нет контрольной суммы для строки, последняя строка:"
-#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"нет строки для контрольной суммы, последняя строка:"
-#define MSG_FILE_PRINTED					"Печать файла завершена"
-#define MSG_BEGIN_FILE_LIST					"Список файлов"
-#define MSG_END_FILE_LIST					"Конец списка файлов"
-#define MSG_M104_INVALID_EXTRUDER			"M104 ошибка экструдера "
-#define MSG_M105_INVALID_EXTRUDER			"M105 ошибка экструдера "
-#define MSG_M218_INVALID_EXTRUDER			"M218 ошибка экструдера "
-#define MSG_ERR_NO_THERMISTORS				"Нет термистра - нет температуры"
-#define MSG_M109_INVALID_EXTRUDER			"M109 ошибка экструдера "
-#define MSG_HEATING							"Нагрев...  "
-#define MSG_HEATING_COMPLETE				"Наргето.    "
-#define MSG_BED_HEATING						"Нагрев стола...     "
-#define MSG_BED_DONE						"Стол нагрет.        "
-#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-#define MSG_COUNT_X							" Count X:"
-#define MSG_ERR_KILLED						"Принтер остановлен. вызов kill() !!"
-#define MSG_ERR_STOPPED						"Ошибка принтера, останов. Устраните неисправность и используйте M999 для перезагрузки!. (Температура недоступна. Проверьте датчики)"
-#define MSG_RESEND							"Переотправка:"
-#define MSG_UNKNOWN_COMMAND					"Неизвестная команда:\""
-#define MSG_ACTIVE_EXTRUDER					"Активный экструдер: "
-#define MSG_INVALID_EXTRUDER				"Ошибка экструдера"
-#define MSG_X_MIN							"x_min:"
-#define MSG_X_MAX							"x_max:"
-#define MSG_Y_MIN							"y_min:"
-#define MSG_Y_MAX							"y_max:"
-#define MSG_Z_MIN							"z_min:"
-#define MSG_Z_MAX							"z_max:"
-#define MSG_M119_REPORT						"Статус концевиков"
-#define MSG_ENDSTOP_HIT						"Срабатывание концевика"
-#define MSG_ENDSTOP_OPEN					"Концевик освобожден"
-#define MSG_HOTEND_OFFSET					"Hotend offsets:"
-#define MSG_SD_CANT_OPEN_SUBDIR				"Не открыть папку"
-#define MSG_SD_INIT_FAIL					"Ошибка инициализации SD"
-#define MSG_SD_VOL_INIT_FAIL				"Ошибка инициализации раздела"
-#define MSG_SD_OPENROOT_FAIL				"Не прочесть содержимое корня"
-#define MSG_SD_CARD_OK						"SD карта в порядке"
-#define MSG_SD_WORKDIR_FAIL					"не открыть рабочую папку"
-#define MSG_SD_OPEN_FILE_FAIL				"Ошибка чтения, файл: "
-#define MSG_SD_FILE_OPENED					"Файл открыт:"
-#define MSG_SD_SIZE							" Размер:"
-#define MSG_SD_FILE_SELECTED				"Файл выбран"
-#define MSG_SD_WRITE_TO_FILE				"Запись в файл: "
-#define MSG_SD_PRINTING_BYTE				"SD печать byte "
-#define MSG_SD_NOT_PRINTING					"нет SD печати"
-#define MSG_SD_ERR_WRITE_TO_FILE			"ошибка записи в файл"
-#define MSG_SD_CANT_ENTER_SUBDIR			"Не зайти в папку:"
-#define MSG_STEPPER_TO_HIGH					"Частота шагов очень высока : "
-#define MSG_ENDSTOPS_HIT					"концевик сработал: "
-#define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
-#define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 7
-
-	// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronto."
-	#define MSG_SD_INSERTED          "SD Card inserita"
-	#define MSG_SD_REMOVED           "SD Card rimossa"
-	#define MSG_MAIN                 "Menu principale"
-	#define MSG_AUTOSTART            "Autostart"
-	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"
-	#define MSG_AUTO_HOME            "Auto Home"
-	#define MSG_SET_ORIGIN           "Imposta Origine"
-	#define MSG_PREHEAT_PLA          "Preriscalda PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"
-	#define MSG_PREHEAT_ABS          "Preriscalda ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"
-	#define MSG_COOLDOWN             "Rafredda"
-	#define MSG_EXTRUDE              "Estrudi"
-	#define MSG_RETRACT              "Ritrai"
-	#define MSG_MOVE_AXIS            "Muovi Asse"
-	#define MSG_SPEED                "Velcità"
-	#define MSG_NOZZLE               "Ugello"
-	#define MSG_NOZZLE1              "Ugello2"
-	#define MSG_NOZZLE2              "Ugello3"
-	#define MSG_BED                  "Piatto"
-	#define MSG_FAN_SPEED            "Ventola"
-	#define MSG_FLOW                 "Flusso"
-	#define MSG_CONTROL              "Controllo"
-	#define MSG_MIN                  " \002 Min:"
-	#define MSG_MAX                  " \002 Max:"
-	#define MSG_FACTOR               " \002 Fact:"
-	#define MSG_AUTOTEMP             "Autotemp"
-	#define MSG_ON                   "On "
-	#define MSG_OFF                  "Off"
-	#define MSG_PID_P                "PID-P"
-	#define MSG_PID_I                "PID-I"
-	#define MSG_PID_D                "PID-D"
-	#define MSG_PID_C                "PID-C"
-	#define MSG_ACC                  "Accel"
-	#define MSG_VXY_JERK             "Vxy-jerk"
+	#define MSG_VMAX             "Vmax "
+	#define MSG_X                "x"
+	#define MSG_Y                "y"
+	#define MSG_Z                "z"
+	#define MSG_E                "e"
+	#define MSG_VMIN             "Vmin"
+	#define MSG_VTRAV_MIN        "VTrav min"
+	#define MSG_AMAX             "Amax "
+	#define MSG_A_RETRACT        "A-Retract"
+	#define MSG_XSTEPS           "Xsteps/mm"
+	#define MSG_YSTEPS           "Ysteps/mm"
+	#define MSG_ZSTEPS           "Zsteps/mm"
+	#define MSG_ESTEPS           "Esteps/mm"
+	#define MSG_RECTRACT_WIDE    "Rectract"
+	#define MSG_WATCH            "Beobachten"
+	#define MSG_TEMPERATURE      "Temperatur"
+	#define MSG_MOTION           "Bewegung"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM      "EPROM speichern"
+	#define MSG_LOAD_EPROM       "EPROM laden"
+	#define MSG_RESTORE_FAILSAFE "Standardkonfig."
+	#define MSG_REFRESH          "Aktualisieren"
+	#define MSG_PREPARE          "Vorbereitung"
+	#define MSG_CONTROL          "Einstellungen"
+	#define MSG_TUNE             "Justierung"
+	#define MSG_PAUSE_PRINT      "Druck anhalten"
+	#define MSG_RESUME_PRINT     "Druck fortsetz"
+	#define MSG_STOP_PRINT       "Druck stoppen"
+	#define MSG_CARD_MENU        "SDKarten Menü"
+	#define MSG_NO_CARD          "Keine SDKarte"
+	#define MSG_DWELL            "Warten..."		
+	#define MSG_USERWAIT         "Warte auf Nutzer..."
+	#define MSG_RESUMING         "Druck fortsetzung"
+	#define MSG_NO_MOVE          "Kein Zug."
+	#define MSG_PART_RELEASE     "Stepper tlw frei"
+	#define MSG_KILLED           "KILLED"
+	#define MSG_STOPPED          "GESTOPPT"
+	#define MSG_STEPPER_RELEASED "Stepper frei"
+	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACTF "Retract  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT      "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Filament wechseln"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+	
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " External Reset"
+	#define MSG_BROWNOUT_RESET " Brown out Reset"
+	#define MSG_WATCHDOG_RESET " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET " Software Reset"
+	#define MSG_MARLIN "Marlin: "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Last Updated: "
+	#define MSG_FREE_MEMORY " Free Memory: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Done saving file."
+	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"
+	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"
+	#define MSG_FILE_PRINTED "Done printing file"
+	#define MSG_BEGIN_FILE_LIST "Begin file list"
+	#define MSG_END_FILE_LIST "End file list"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "
+	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "
+	#define MSG_HEATING "Heating..."
+	#define MSG_HEATING_COMPLETE "Heating done."
+	#define MSG_BED_HEATING "Bed Heating."
+	#define MSG_BED_DONE "Bed done."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Count X:"
+	#define MSG_ERR_KILLED "Printer halted. kill() called !!"
+	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"
+	#define MSG_RESEND "Resend:"
+	#define MSG_UNKNOWN_COMMAND "Unknown command:\""
+	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "
+	#define MSG_INVALID_EXTRUDER "Invalid extruder"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Reporting endstop status"
+	#define MSG_ENDSTOP_HIT "TRIGGERED"
+	#define MSG_ENDSTOP_OPEN "open"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"
+	#define MSG_SD_INIT_FAIL "SD init fail"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"
+	#define MSG_SD_OPENROOT_FAIL "openRoot failed"
+	#define MSG_SD_CARD_OK "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open failed"
+	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "
+	#define MSG_SD_FILE_OPENED "File opened:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "File selected"
+	#define MSG_SD_WRITE_TO_FILE "Writing to file: "
+	#define MSG_SD_PRINTING_BYTE "SD printing byte "
+	#define MSG_SD_NOT_PRINTING "Not SD printing"
+	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate too high : "
+	#define MSG_ENDSTOPS_HIT "endstops hit: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 5
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME "Lista."
+	#define MSG_SD_INSERTED "Tarjeta SD Colocada"
+	#define MSG_SD_REMOVED "Tarjeta SD Retirada"
+	#define MSG_MAIN "Menu Principal"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS "Apagar Motores"
+	#define MSG_AUTO_HOME "Llevar al Origen" // "Llevar Ejes al Cero"
+	#define MSG_SET_ORIGIN "Establecer Cero"
+	#define MSG_PREHEAT_PLA "Precalentar PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Ajustar temp. PLA"
+	#define MSG_PREHEAT_ABS "Precalentar ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Ajustar temp. ABS"
+	#define MSG_COOLDOWN "Enfriar"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_EXTRUDE "Extruir"
+	#define MSG_RETRACT "Retraer"
+	#define MSG_MOVE_AXIS "Mover Ejes"
+	#define MSG_SPEED "Velocidad"
+	#define MSG_NOZZLE "Nozzle"
+	#define MSG_NOZZLE1 "Nozzle2"
+	#define MSG_NOZZLE2 "Nozzle3"
+	#define MSG_BED "Base"
+	#define MSG_FAN_SPEED "Ventilador"
+	#define MSG_FLOW "Flujo"
+	#define MSG_CONTROL "Control"
+	#define MSG_MIN "\002 Min"
+	#define MSG_MAX "\002 Max"
+	#define MSG_FACTOR "\002 Fact"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On"
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Acel"
+	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VZ_JERK "Vz-jerk"
+	#define MSG_VE_JERK "Ve-jerk"
+	#define MSG_VMAX "Vmax"
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VTrav min"
+	#define MSG_AMAX "Amax"
+	#define MSG_A_RETRACT "A-retrac."
+	#define MSG_XSTEPS "X pasos/mm"
+	#define MSG_YSTEPS "Y pasos/mm"
+	#define MSG_ZSTEPS "Z pasos/mm"
+	#define MSG_ESTEPS "E pasos/mm"
+	#define MSG_RECTRACT "Retraer"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Movimiento"
+	#define MSG_STORE_EPROM "Guardar Memoria"
+	#define MSG_LOAD_EPROM "Cargar Memoria"
+	#define MSG_RESTORE_FAILSAFE "Rest. de emergencia"
+	#define MSG_REFRESH "Volver a cargar"
+	#define MSG_WATCH "Monitorizar"
+	#define MSG_PREPARE "Preparar"
+	#define MSG_TUNE "Ajustar"
+	#define MSG_PAUSE_PRINT "Pausar Impresion"
+	#define MSG_RESUME_PRINT "Reanudar Impresion"
+	#define MSG_STOP_PRINT "Detener Impresion"
+	#define MSG_CARD_MENU "Menu de SD"
+	#define MSG_NO_CARD "No hay Tarjeta SD"
+	#define MSG_DWELL "Reposo..."
+	#define MSG_USERWAIT "Esperando Ordenes..."
+	#define MSG_RESUMING "Resumiendo Impresion"
+	#define MSG_NO_MOVE "Sin movimiento"
+	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_STOPPED "PARADA."
+	#define MSG_CONTROL_RETRACT  "Retraer mm"
+	#define MSG_CONTROL_RETRACTF "Retraer  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Levantar mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet F"
+	#define MSG_AUTORETRACT "AutoRetr."
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Iniciando. Tarjeta-SD"
+	#define MSG_CNG_SDCARD "Cambiar Tarjeta-SD"
+	#define MSG_RECTRACT_WIDE "Retraer"
+	#define MSG_TEMPERATURE_WIDE "Temperatura"
+	#define MSG_TEMPERATURE_RTN  "Temperatura"
+	#define MSG_MAIN_WIDE "Menu Principal"
+	#define MSG_MOTION_WIDE "Movimiento"
+	#define MSG_PREPARE_ALT "Preparar"
+	#define MSG_CONTROL_ARROW "Control"
+	#define MSG_RETRACT_ARROW "Retraer"
+	#define MSG_PART_RELEASE "Desacople Parcial"
+	#define MSG_STEPPER_RELEASED "Desacoplada."
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "En cola \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Autor: "
+	#define MSG_CONFIGURATION_VER " Ultima actualizacion: "
+	#define MSG_FREE_MEMORY " Memoria libre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardado."
+	#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"
+	#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"
+	#define MSG_FILE_PRINTED "Impresion terminada"
+	#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"
+	#define MSG_END_FILE_LIST "Fin de la lista de archivos"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "
+	#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "
+	#define MSG_HEATING "Calentando..."
+	#define MSG_HEATING_COMPLETE "Calentamiento Hecho."
+	#define MSG_BED_HEATING "Calentando la base."
+	#define MSG_BED_DONE "Base Caliente."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Cuenta X:"
+	#define MSG_ERR_KILLED "¡¡Impresora Parada con kill()!!"
+	#define MSG_ERR_STOPPED "¡Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela antes de continuar)"
+	#define MSG_RESEND "Reenviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor Invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Comprobando fines de carrera."
+	#define MSG_ENDSTOP_HIT "PULSADO"
+	#define MSG_ENDSTOP_OPEN "abierto"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+	#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."
+	#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"
+	#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"
+	#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"
+	#define MSG_SD_CARD_OK "Tarjeta SD OK"
+	#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"
+	#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "
+	#define MSG_SD_FILE_OPENED "Archivo abierto:"
+	#define MSG_SD_SIZE " Tamaño:"
+	#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"
+	#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "
+	#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "
+	#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"
+	#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate demasiado alto : "
+	#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"
+
+#endif
+
+#if LANGUAGE_CHOICE == 6
+
+	// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME			" Готов"
+	#define MSG_SD_INSERTED						"Карта вставлена"
+	#define MSG_SD_REMOVED						"Карта извлечена"
+	#define MSG_MAIN							" Меню              \003"
+	#define MSG_AUTOSTART						" Автостарт          "
+	#define MSG_DISABLE_STEPPERS				" Выключить двигатели"
+	#define MSG_AUTO_HOME						" Парковка           "
+	#define MSG_SET_ORIGIN						" Запомнить ноль     "
+	#define MSG_PREHEAT_PLA						" Преднагрев PLA     "
+	#define MSG_PREHEAT_PLA_SETTINGS			" Настр. преднагр.PLA"
+	#define MSG_PREHEAT_ABS						" Преднагрев ABS     "
+	#define MSG_PREHEAT_ABS_SETTINGS			" Настр. преднагр.ABS"
+	#define MSG_COOLDOWN						" Охлаждение         "
+	#define MSG_SWITCH_PS_ON					"Switch Power On"
+	#define MSG_SWITCH_PS_OFF					"Switch Power Off"
+	#define MSG_EXTRUDE							" Экструзия          "
+	#define MSG_RETRACT							" Откат"
+	#define MSG_MOVE_AXIS						" Движение по осям  \x7E"
+	#define MSG_SPEED							" Скорость:"
+	#define MSG_NOZZLE							" \002 Фильера:"
+	#define MSG_NOZZLE1							" \002 Фильера2:"
+	#define MSG_NOZZLE2							" \002 Фильера3:"
+	#define MSG_BED								" \002 Кровать:"
+	#define MSG_FAN_SPEED						" Куллер:"
+	#define MSG_FLOW							" Поток:"
+	#define MSG_CONTROL							" Настройки \003"
+	#define MSG_MIN								" \002 Минимум:"
+	#define MSG_MAX								" \002 Максимум:"
+	#define MSG_FACTOR							" \002 Фактор:"
+	#define MSG_AUTOTEMP						" Autotemp:"
+	#define MSG_ON								"Вкл. "
+	#define MSG_OFF								"Выкл. "
+	#define MSG_PID_P							" PID-P: "
+	#define MSG_PID_I							" PID-I: "
+	#define MSG_PID_D							" PID-D: "
+	#define MSG_PID_C							" PID-C: "
+	#define MSG_ACC								" Acc:"
+	#define MSG_VXY_JERK						" Vxy-jerk: "
+	#define MSG_VZ_JERK                         "Vz-jerk"
+	#define MSG_VE_JERK                         "Ve-jerk"
+	#define MSG_VMAX							" Vmax "
+	#define MSG_X								"x:"
+	#define MSG_Y								"y:"
+	#define MSG_Z								"z:"
+	#define MSG_E								"e:"
+	#define MSG_VMIN							" Vmin:"
+	#define MSG_VTRAV_MIN						" VTrav min:"
+	#define MSG_AMAX							" Amax "
+	#define MSG_A_RETRACT						" A-retract:"
+	#define MSG_XSTEPS							" X шаг/mm:"
+	#define MSG_YSTEPS							" Y шаг/mm:"
+	#define MSG_ZSTEPS							" Z шаг/mm:"
+	#define MSG_ESTEPS							" E шаг/mm:"
+	#define MSG_RECTRACT    					" Откат подачи      \x7E"
+	#define MSG_TEMPERATURE  				" Температура       \x7E"
+	#define MSG_MOTION						" Скорости          \x7E"
+		#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM						" Сохранить настройки"
+	#define MSG_LOAD_EPROM						" Загрузить настройки"
+	#define MSG_RESTORE_FAILSAFE				" Сброс настроек     "
+	#define MSG_REFRESH							"\004Обновить           "
+	#define MSG_WATCH							" Обзор             \003"
+	#define MSG_PREPARE							" Действия          \x7E"
+	#define MSG_TUNE					" Настройки         \x7E"
+	#define MSG_PAUSE_PRINT						" Пауза печати      \x7E"
+	#define MSG_RESUME_PRINT					" Продолжить печать \x7E"
+	#define MSG_STOP_PRINT						" Остановить печать \x7E"
+	#define MSG_CARD_MENU						" Меню карты        \x7E"
+	#define MSG_NO_CARD							" Нет карты"
+	#define MSG_DWELL							"Сон..."
+	#define MSG_USERWAIT						"Нажмите для продолж."
+	#define MSG_RESUMING "Resuming print"
+	#define MSG_NO_MOVE							"Нет движения.       "
+	#define MSG_PART_RELEASE					" Извлечение принта  "
+	#define MSG_KILLED							"УБИТО. "
+	#define MSG_STOPPED							"ОСТАНОВЛЕНО. "
+	#define MSG_CONTROL_RETRACT					" Откат mm:"
+	#define MSG_CONTROL_RETRACTF				" Откат  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT			" Прыжок mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER			" Возврат +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF		" Возврат  F:"
+	#define MSG_AUTORETRACT						" АвтоОткат:"
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing						"Запланировано \""
+	#define MSG_POWERUP							"Включение питания"
+	#define MSG_EXTERNAL_RESET					" Внешний сброс"
+	#define MSG_BROWNOUT_RESET					" Brown out сброс"
+	#define MSG_WATCHDOG_RESET					" Watchdog сброс"
+	#define MSG_SOFTWARE_RESET					" программный сброс"
+	#define MSG_MARLIN							"Marlin "
+	#define MSG_AUTHOR							" | Автор: "
+	#define MSG_CONFIGURATION_VER				" Последнее обновление: "
+	#define MSG_FREE_MEMORY						" Памяти свободно: "
+	#define MSG_PLANNER_BUFFER_BYTES			"  Буффер очереди команд Bytes: "
+	#define MSG_OK								"ok"
+	#define MSG_FILE_SAVED						"Файл записан."
+	#define MSG_ERR_LINE_NO						"Номен строки это не последняя строка+1, последняя строка:"
+	#define MSG_ERR_CHECKSUM_MISMATCH			"контрольная сумма не совпадает, последняя строка:"
+	#define MSG_ERR_NO_CHECKSUM					"нет контрольной суммы для строки, последняя строка:"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"нет строки для контрольной суммы, последняя строка:"
+	#define MSG_FILE_PRINTED					"Печать файла завершена"
+	#define MSG_BEGIN_FILE_LIST					"Список файлов"
+	#define MSG_END_FILE_LIST					"Конец списка файлов"
+	#define MSG_M104_INVALID_EXTRUDER			"M104 ошибка экструдера "
+	#define MSG_M105_INVALID_EXTRUDER			"M105 ошибка экструдера "
+	#define MSG_M218_INVALID_EXTRUDER			"M218 ошибка экструдера "
+	#define MSG_ERR_NO_THERMISTORS				"Нет термистра - нет температуры"
+	#define MSG_M109_INVALID_EXTRUDER			"M109 ошибка экструдера "
+	#define MSG_HEATING							"Нагрев...  "
+	#define MSG_HEATING_COMPLETE				"Наргето.    "
+	#define MSG_BED_HEATING						"Нагрев стола...     "
+	#define MSG_BED_DONE						"Стол нагрет.        "
+	#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X							" Count X:"
+	#define MSG_ERR_KILLED						"Принтер остановлен. вызов kill() !!"
+	#define MSG_ERR_STOPPED						"Ошибка принтера, останов. Устраните неисправность и используйте M999 для перезагрузки!. (Температура недоступна. Проверьте датчики)"
+	#define MSG_RESEND							"Переотправка:"
+	#define MSG_UNKNOWN_COMMAND					"Неизвестная команда:\""
+	#define MSG_ACTIVE_EXTRUDER					"Активный экструдер: "
+	#define MSG_INVALID_EXTRUDER				"Ошибка экструдера"
+	#define MSG_X_MIN							"x_min:"
+	#define MSG_X_MAX							"x_max:"
+	#define MSG_Y_MIN							"y_min:"
+	#define MSG_Y_MAX							"y_max:"
+	#define MSG_Z_MIN							"z_min:"
+	#define MSG_Z_MAX							"z_max:"
+	#define MSG_M119_REPORT						"Статус концевиков"
+	#define MSG_ENDSTOP_HIT						"Срабатывание концевика"
+	#define MSG_ENDSTOP_OPEN					"Концевик освобожден"
+	#define MSG_HOTEND_OFFSET					"Hotend offsets:"
+	#define MSG_SD_CANT_OPEN_SUBDIR				"Не открыть папку"
+	#define MSG_SD_INIT_FAIL					"Ошибка инициализации SD"
+	#define MSG_SD_VOL_INIT_FAIL				"Ошибка инициализации раздела"
+	#define MSG_SD_OPENROOT_FAIL				"Не прочесть содержимое корня"
+	#define MSG_SD_CARD_OK						"SD карта в порядке"
+	#define MSG_SD_WORKDIR_FAIL					"не открыть рабочую папку"
+	#define MSG_SD_OPEN_FILE_FAIL				"Ошибка чтения, файл: "
+	#define MSG_SD_FILE_OPENED					"Файл открыт:"
+	#define MSG_SD_SIZE							" Размер:"
+	#define MSG_SD_FILE_SELECTED				"Файл выбран"
+	#define MSG_SD_WRITE_TO_FILE				"Запись в файл: "
+	#define MSG_SD_PRINTING_BYTE				"SD печать byte "
+	#define MSG_SD_NOT_PRINTING					"нет SD печати"
+	#define MSG_SD_ERR_WRITE_TO_FILE			"ошибка записи в файл"
+	#define MSG_SD_CANT_ENTER_SUBDIR			"Не зайти в папку:"
+	#define MSG_STEPPER_TOO_HIGH				"Частота шагов очень высока : "
+	#define MSG_ENDSTOPS_HIT					"концевик сработал: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP			" защита холодной экструзии"
+	#define MSG_ERR_LONG_EXTRUDE_STOP			" защита превышения длинны экструзии"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 7
+
+	// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronta"
+	#define MSG_SD_INSERTED          "SD Card inserita"
+	#define MSG_SD_REMOVED           "SD Card rimossa"
+	#define MSG_MAIN                 "Menu principale"
+	#define MSG_AUTOSTART            "Autostart"
+	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"
+	#define MSG_AUTO_HOME            "Auto Home"
+	#define MSG_SET_ORIGIN           "Imposta Origine"
+	#define MSG_PREHEAT_PLA          "Preriscalda PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"
+	#define MSG_PREHEAT_ABS          "Preriscalda ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"
+	#define MSG_COOLDOWN             "Raffredda"
+	#define MSG_SWITCH_PS_ON         "Switch Power On"
+	#define MSG_SWITCH_PS_OFF        "Switch Power Off"
+	#define MSG_EXTRUDE              "Estrudi"
+	#define MSG_RETRACT              "Ritrai"
+	#define MSG_MOVE_AXIS            "Muovi Asse"
+	#define MSG_SPEED                "Velcità"
+	#define MSG_NOZZLE               "Ugello"
+	#define MSG_NOZZLE1              "Ugello2"
+	#define MSG_NOZZLE2              "Ugello3"
+	#define MSG_BED                  "Piatto"
+	#define MSG_FAN_SPEED            "Ventola"
+	#define MSG_FLOW                 "Flusso"
+	#define MSG_CONTROL              "Controllo"
+	#define MSG_MIN                  " \002 Min:"
+	#define MSG_MAX                  " \002 Max:"
+	#define MSG_FACTOR               " \002 Fact:"
+	#define MSG_AUTOTEMP             "Autotemp"
+	#define MSG_ON                   "On "
+	#define MSG_OFF                  "Off"
+	#define MSG_PID_P                "PID-P"
+	#define MSG_PID_I                "PID-I"
+	#define MSG_PID_D                "PID-D"
+	#define MSG_PID_C                "PID-C"
+	#define MSG_ACC                  "Accel"
+	#define MSG_VXY_JERK             "Vxy-jerk"
 	#define MSG_VZ_JERK              "Vz-jerk"
 	#define MSG_VE_JERK              "Ve-jerk"
-	#define MSG_VMAX                 "Vmax"
-	#define MSG_X                    "x"
-	#define MSG_Y                    "y"
-	#define MSG_Z                    "z"
-	#define MSG_E                    "e"
-	#define MSG_VMIN                 "Vmin"
-	#define MSG_VTRAV_MIN            "VTrav min"
-	#define MSG_AMAX                 "Amax"
-	#define MSG_A_RETRACT            "A-retract"
-	#define MSG_XSTEPS               "Xpassi/mm"
-	#define MSG_YSTEPS               "Ypassi/mm"
-	#define MSG_ZSTEPS               "Zpassi/mm"
-	#define MSG_ESTEPS               "Epassi/mm"
-	#define MSG_RECTRACT             "Ritrai"
-	#define MSG_TEMPERATURE          "Temperatura"
-	#define MSG_MOTION               "Movimento"
-	#define MSG_STORE_EPROM          "Salva in EEPROM"
-	#define MSG_LOAD_EPROM           "Carica da EEPROM"
-	#define MSG_RESTORE_FAILSAFE     "Impostaz. default"
-	#define MSG_REFRESH              "Aggiorna"
-	#define MSG_WATCH                "Guarda"
-	#define MSG_PREPARE              "Prepara"
-	#define MSG_TUNE                 "Adatta"
-	#define MSG_PAUSE_PRINT          "Pausa"
-	#define MSG_RESUME_PRINT         "Riprendi Stampa"
-	#define MSG_STOP_PRINT           "Arresta Stampa"
-	#define MSG_CARD_MENU            "SD Card Menu"
-	#define MSG_NO_CARD              "No SD Card"
-	#define MSG_DWELL                "Sospensione..."
-	#define MSG_USERWAIT             "Attendi Utente..."
-	#define MSG_RESUMING             "Riprendi Stampa"
-	#define MSG_NO_MOVE              "Nessun Movimento."
-	#define MSG_KILLED               "UCCISO. "
-	#define MSG_STOPPED              "ARRESTATO. "
-	#define MSG_CONTROL_RETRACT      "Ritrai mm"
-	#define MSG_CONTROL_RETRACTF     "Ritrai  F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT          "AutoArretramento"
-	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
-	#define MSG_FILAMENTCHANGE       "Cambia filamento"
-	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
-	#define MSG_CNG_SDCARD           "Cambia SD-Card"
-
-	// Serial Console Messages
-
-	#define MSG_Enqueing             "accodamento \""
-	#define MSG_POWERUP              "Accensione"
-	#define MSG_EXTERNAL_RESET       " Reset Esterno"
-	#define MSG_BROWNOUT_RESET       " Brown out Reset"
-	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
-	#define MSG_SOFTWARE_RESET       " Software Reset"
-	#define MSG_MARLIN               "Marlin "
-	#define MSG_AUTHOR               " | Autore: "
-	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
-	#define MSG_FREE_MEMORY          " Memoria Libera: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK                   "ok"
-	#define MSG_FILE_SAVED           "File Salvato."
-	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "
-	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "
-	#define MSG_FILE_PRINTED         "File stampato"
-	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
-	#define MSG_END_FILE_LIST        "Fine Lista File"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
-	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
-	#define MSG_HEATING              "Riscaldamento..."
-	#define MSG_HEATING_COMPLETE     "Stampante Calda."
-	#define MSG_BED_HEATING          "Riscaldamento Piatto."
-	#define MSG_BED_DONE             "Piatto Pronto."
-	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X              " Calcola X: "
-	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
-	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
-	#define MSG_RESEND               "Reinviato:"
-	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""
-	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
-	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
-	#define MSG_X_MIN                "x_min: "
-	#define MSG_X_MAX                "x_max: "
-	#define MSG_Y_MIN                "y_min: "
-	#define MSG_Y_MAX                "y_max: "
-	#define MSG_Z_MIN                "z_min: "
-	#define MSG_Z_MAX                "z_max: "
-	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
-	#define MSG_ENDSTOP_HIT          "INNESCATO"
-	#define MSG_ENDSTOP_OPEN         "aperto"
-	#define MSG_HOTEND_OFFSET        "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
-	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
-	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
-	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
-	#define MSG_SD_CARD_OK           "SD card ok"
-	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
-	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
-	#define MSG_SD_FILE_OPENED       "File aperto: "
-	#define MSG_SD_SIZE              " Dimensione: "
-	#define MSG_SD_FILE_SELECTED     "File selezionato"
-	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
-	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
-	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
-
-	#define MSG_STEPPER_TO_HIGH      "Steprate troppo alto: "
-	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
-
-#endif
-
-
-#if LANGUAGE_CHOICE == 8
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " Pronta."
-	#define MSG_SD_INSERTED "Cartao SD inserido"
-	#define MSG_SD_REMOVED "Cartao SD removido"
-	#define MSG_MAIN " Menu Principal \003"
-	#define MSG_AUTOSTART " Autostart"
-	#define MSG_DISABLE_STEPPERS " Apagar Motores"
-	#define MSG_AUTO_HOME " Ir para Origen"
-	#define MSG_SET_ORIGIN " Estabelecer Origen"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
-	#define MSG_COOLDOWN " Esfriar"
-	#define MSG_EXTRUDE " Extrudar"
-	#define MSG_RETRACT " Retrair"
-	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
-	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
-	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
-	#define MSG_SPEED " Velocidade:"
-	#define MSG_NOZZLE " \002Nozzle:"
-	#define MSG_NOZZLE1 " \002Nozzle2:"
-	#define MSG_NOZZLE2 " \002Nozzle3:"
-	#define MSG_BED " \002Base:"
-	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
-	#define MSG_FLOW " Fluxo:"
-	#define MSG_CONTROL " Controle \003"
-	#define MSG_MIN " \002 Min:"
-	#define MSG_MAX " \002 Max:"
-	#define MSG_FACTOR " \002 Fact:"
-	#define MSG_AUTOTEMP " Autotemp:"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P " PID-P: "
-	#define MSG_PID_I " PID-I: "
-	#define MSG_PID_D " PID-D: "
-	#define MSG_PID_C " PID-C: "
-	#define MSG_ACC  " Acc:"
-	#define MSG_VXY_JERK " Vxy-jerk: "
+	#define MSG_VMAX                 "Vmax"
+	#define MSG_X                    "x"
+	#define MSG_Y                    "y"
+	#define MSG_Z                    "z"
+	#define MSG_E                    "e"
+	#define MSG_VMIN                 "Vmin"
+	#define MSG_VTRAV_MIN            "VTrav min"
+	#define MSG_AMAX                 "Amax"
+	#define MSG_A_RETRACT            "A-retract"
+	#define MSG_XSTEPS               "Xpassi/mm"
+	#define MSG_YSTEPS               "Ypassi/mm"
+	#define MSG_ZSTEPS               "Zpassi/mm"
+	#define MSG_ESTEPS               "Epassi/mm"
+	#define MSG_RECTRACT             "Ritrai"
+	#define MSG_TEMPERATURE          "Temperatura"
+	#define MSG_MOTION               "Movimento"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM          "Salva in EEPROM"
+	#define MSG_LOAD_EPROM           "Carica da EEPROM"
+	#define MSG_RESTORE_FAILSAFE     "Impostaz. default"
+	#define MSG_REFRESH              "Aggiorna"
+	#define MSG_WATCH                "Guarda"
+	#define MSG_PREPARE              "Prepara"
+	#define MSG_TUNE                 "Adatta"
+	#define MSG_PAUSE_PRINT          "Pausa"
+	#define MSG_RESUME_PRINT         "Riprendi Stampa"
+	#define MSG_STOP_PRINT           "Arresta Stampa"
+	#define MSG_CARD_MENU            "SD Card Menu"
+	#define MSG_NO_CARD              "No SD Card"
+	#define MSG_DWELL                "Sospensione..."
+	#define MSG_USERWAIT             "Attendi Utente..."
+	#define MSG_RESUMING             "Riprendi Stampa"
+	#define MSG_NO_MOVE              "Nessun Movimento."
+	#define MSG_KILLED               "UCCISO. "
+	#define MSG_STOPPED              "ARRESTATO. "
+	#define MSG_CONTROL_RETRACT      "Ritrai mm"
+	#define MSG_CONTROL_RETRACTF     "Ritrai  F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT          "AutoArretramento"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."
+	#define MSG_FILAMENTCHANGE       "Cambia filamento"
+	#define MSG_INIT_SDCARD          "Iniz. SD-Card"
+	#define MSG_CNG_SDCARD           "Cambia SD-Card"
+
+	// Serial Console Messages
+
+	#define MSG_Enqueing             "accodamento \""
+	#define MSG_POWERUP              "Accensione"
+	#define MSG_EXTERNAL_RESET       " Reset Esterno"
+	#define MSG_BROWNOUT_RESET       " Brown out Reset"
+	#define MSG_WATCHDOG_RESET       " Watchdog Reset"
+	#define MSG_SOFTWARE_RESET       " Software Reset"
+	#define MSG_MARLIN               "Marlin "
+	#define MSG_AUTHOR               " | Autore: "
+	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "
+	#define MSG_FREE_MEMORY          " Memoria Libera: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK                   "ok"
+	#define MSG_FILE_SAVED           "File Salvato."
+	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "
+	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "
+	#define MSG_FILE_PRINTED         "File stampato"
+	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"
+	#define MSG_END_FILE_LIST        "Fine Lista File"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "
+	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "
+	#define MSG_HEATING              "Riscaldamento..."
+	#define MSG_HEATING_COMPLETE     "Stampante Calda."
+	#define MSG_BED_HEATING          "Riscaldamento Piatto."
+	#define MSG_BED_DONE             "Piatto Pronto."
+	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X              " Calcola X: "
+	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"
+	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"
+	#define MSG_RESEND               "Reinviato:"
+	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""
+	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "
+	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"
+	#define MSG_X_MIN                "x_min: "
+	#define MSG_X_MAX                "x_max: "
+	#define MSG_Y_MIN                "y_min: "
+	#define MSG_Y_MAX                "y_max: "
+	#define MSG_Z_MIN                "z_min: "
+	#define MSG_Z_MAX                "z_max: "
+	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"
+	#define MSG_ENDSTOP_HIT          "INNESCATO"
+	#define MSG_ENDSTOP_OPEN         "aperto"
+	#define MSG_HOTEND_OFFSET        "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"
+	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"
+	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"
+	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"
+	#define MSG_SD_CARD_OK           "SD card ok"
+	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"
+	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "
+	#define MSG_SD_FILE_OPENED       "File aperto: "
+	#define MSG_SD_SIZE              " Dimensione: "
+	#define MSG_SD_FILE_SELECTED     "File selezionato"
+	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "
+	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "
+	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "
+
+	#define MSG_STEPPER_TOO_HIGH     "Steprate troppo alto: "
+	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"
+
+#endif
+
+
+#if LANGUAGE_CHOICE == 8
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " Pronta."
+	#define MSG_SD_INSERTED "Cartao SD inserido"
+	#define MSG_SD_REMOVED "Cartao SD removido"
+	#define MSG_MAIN " Menu Principal \003"
+	#define MSG_AUTOSTART " Autostart"
+	#define MSG_DISABLE_STEPPERS " Apagar Motores"
+	#define MSG_AUTO_HOME " Ir para Origen"
+	#define MSG_SET_ORIGIN " Estabelecer Origen"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"
+	#define MSG_COOLDOWN " Esfriar"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_EXTRUDE " Extrudar"
+	#define MSG_RETRACT " Retrair"
+	#define MSG_PREHEAT_PLA " pre-aquecer PLA"
+	#define MSG_PREHEAT_ABS " pre-aquecer ABS"
+	#define MSG_MOVE_AXIS " Mover eixo      \x7E"
+	#define MSG_SPEED " Velocidade:"
+	#define MSG_NOZZLE " \002Nozzle:"
+	#define MSG_NOZZLE1 " \002Nozzle2:"
+	#define MSG_NOZZLE2 " \002Nozzle3:"
+	#define MSG_BED " \002Base:"
+	#define MSG_FAN_SPEED " Velocidade Ventoinha:"
+	#define MSG_FLOW " Fluxo:"
+	#define MSG_CONTROL " Controle \003"
+	#define MSG_MIN " \002 Min:"
+	#define MSG_MAX " \002 Max:"
+	#define MSG_FACTOR " \002 Fact:"
+	#define MSG_AUTOTEMP " Autotemp:"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P " PID-P: "
+	#define MSG_PID_I " PID-I: "
+	#define MSG_PID_D " PID-D: "
+	#define MSG_PID_C " PID-C: "
+	#define MSG_ACC  " Acc:"
+	#define MSG_VXY_JERK " Vxy-jerk: "
 	#define MSG_VZ_JERK "Vz-jerk"
 	#define MSG_VE_JERK "Ve-jerk"
-	#define MSG_VMAX " Vmax "
-	#define MSG_X "x:"
-	#define MSG_Y "y:"
-	#define MSG_Z "z:"
-	#define MSG_E "e:"
-	#define MSG_VMIN " Vmin:"
-	#define MSG_VTRAV_MIN " VTrav min:"
-	#define MSG_AMAX " Amax "
-	#define MSG_A_RETRACT " A-retract:"
-	#define MSG_XSTEPS " Xpasso/mm:"
-	#define MSG_YSTEPS " Ypasso/mm:"
-	#define MSG_ZSTEPS " Zpasso/mm:"
-	#define MSG_ESTEPS " Epasso/mm:"
-	#define MSG_MAIN_WIDE " Menu Principal  \003"
-	#define MSG_RECTRACT_WIDE " Retrair    \x7E"
-	#define MSG_TEMPERATURE_WIDE " Temperatura \x7E"
-	#define MSG_TEMPERATURE_RTN " Temperatura  \003"
-	#define MSG_MOTION_WIDE " Movimento     \x7E"
-	#define MSG_STORE_EPROM " Guardar memoria"
-	#define MSG_LOAD_EPROM " Carregar memoria"
-	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
-	#define MSG_REFRESH "\004Recarregar"
-	#define MSG_WATCH " Monitorar   \003"
-	#define MSG_PREPARE " Preparar \x7E"
-	#define MSG_PREPARE_ALT " Preparar \003"
-	#define MSG_CONTROL_ARROW " Controle \x7E"
-	#define MSG_RETRACT_ARROW " Retrair \x7E"
-	#define MSG_TUNE " Tune    \x7E"
-	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
-	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
-	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
-	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
-	#define MSG_NO_CARD " Sem cartao SD"
-	#define MSG_DWELL "Repouso..."
-	#define MSG_USERWAIT "Esperando Ordem..."
-	#define MSG_NO_MOVE "Sem movimento."
-	#define MSG_PART_RELEASE "Lancamento Parcial"
-	#define MSG_KILLED "PARADA DE EMERGENCIA. "
-	#define MSG_STOPPED "PARADA. "
-	#define MSG_STEPPER_RELEASED "Lancado."
-	#define MSG_CONTROL_RETRACT  " Retrair mm:"
-	#define MSG_CONTROL_RETRACTF " Retrair  F:"
-	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
-	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
-	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
-	#define MSG_AUTORETRACT " AutoRetr.:"
-        #define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
-        #define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "enqueing \""
-	#define MSG_POWERUP "PowerUp"
-	#define MSG_EXTERNAL_RESET " Reset Externo"
-	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
-	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
-	#define MSG_SOFTWARE_RESET " Reset por Software"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
-	#define MSG_FREE_MEMORY " memoria Livre: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Guardado."
-	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
-	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
-	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
-	#define MSG_FILE_PRINTED "Impressao terminada"
-	#define MSG_BEGIN_FILE_LIST "Começo da lista de arquivos"
-	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor inválido "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor inválido "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor inválido "
-	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor inválido "
-	#define MSG_HEATING "Aquecendo..."
-	#define MSG_HEATING_COMPLETE "Aquecido."
-	#define MSG_BED_HEATING "Aquecendo a Base."
-	#define MSG_BED_DONE "Base quente."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Conta X:"
-	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
-	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomeçar!. (Temperatura reiniciada. Ajuste antes de recomeçar)"
-	#define MSG_RESEND "Reenviar:"
-	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
-	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
-	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Relatando estado do ponto final"
-	#define MSG_ENDSTOP_HIT "PULSADO"
-	#define MSG_ENDSTOP_OPEN "Aberto"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
-	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
-	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
-	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
-	#define MSG_SD_CARD_OK "cartao SD ok"
-	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
-	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
-	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
-	#define MSG_SD_SIZE " Size:"
-	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
-	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
-	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
-	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
-	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
-
-	#define MSG_STEPPER_TO_HIGH "Steprate muito alto : "
-	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
-
-
-#endif
-
-
-
-#if LANGUAGE_CHOICE == 9
-
-// Finnish
-
-// LCD Menu Messages
-	#define WELCOME_MSG MACHINE_NAME " valmis"
-	#define MSG_SD_INSERTED "Kortti asetettu"
-	#define MSG_SD_REMOVED "Kortti poistettu"
-	#define MSG_MAIN "Palaa"
-	#define MSG_AUTOSTART "Automaatti"
-	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"
-	#define MSG_AUTO_HOME "Aja referenssiin"
-	#define MSG_SET_ORIGIN "Aseta origo"
-	#define MSG_PREHEAT_PLA "Esilammita PLA"
-	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"
-	#define MSG_PREHEAT_ABS "Esilammita ABS"
-	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"
-	#define MSG_COOLDOWN "Jaahdyta"
-	#define MSG_EXTRUDE "Pursota"
-	#define MSG_RETRACT "Veda takaisin"
-	#define MSG_MOVE_AXIS "Liikuta akseleita"
-	#define MSG_SPEED "Nopeus"
-	#define MSG_NOZZLE "Suutin"
-	#define MSG_NOZZLE1 "Suutin2"
-	#define MSG_NOZZLE2 "Suutin3"
-	#define MSG_BED "Alusta"
-	#define MSG_FAN_SPEED "Tuul. nopeus"
-	#define MSG_FLOW "Virtaus"
-	#define MSG_CONTROL "Kontrolli"
-	#define MSG_MIN " \002 Min"
-	#define MSG_MAX " \002 Max"
-	#define MSG_FACTOR " \002 Kerr"
-	#define MSG_AUTOTEMP "Autotemp"
-	#define MSG_ON "On "
-	#define MSG_OFF "Off"
-	#define MSG_PID_P "PID-P"
-	#define MSG_PID_I "PID-I"
-	#define MSG_PID_D "PID-D"
-	#define MSG_PID_C "PID-C"
-	#define MSG_ACC  "Kiihtyv"
-	#define MSG_VXY_JERK "Vxy-jerk"
+	#define MSG_VMAX " Vmax "
+	#define MSG_X "x:"
+	#define MSG_Y "y:"
+	#define MSG_Z "z:"
+	#define MSG_E "e:"
+	#define MSG_VMIN " Vmin:"
+	#define MSG_VTRAV_MIN " VTrav min:"
+	#define MSG_AMAX " Amax "
+	#define MSG_A_RETRACT " A-retract:"
+	#define MSG_XSTEPS " Xpasso/mm:"
+	#define MSG_YSTEPS " Ypasso/mm:"
+	#define MSG_ZSTEPS " Zpasso/mm:"
+	#define MSG_ESTEPS " Epasso/mm:"
+	#define MSG_MAIN_WIDE " Menu Principal  \003"
+	#define MSG_RECTRACT "Retrair"
+	#define MSG_TEMPERATURE "Temperatura"
+	#define MSG_MOTION "Movimento"
+	#define MSG_STORE_EPROM " Guardar memoria"
+	#define MSG_LOAD_EPROM " Carregar memoria"
+	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"
+	#define MSG_REFRESH "\004Recarregar"
+	#define MSG_WATCH " Monitorar   \003"
+	#define MSG_PREPARE " Preparar \x7E"
+	#define MSG_PREPARE_ALT " Preparar \003"
+	#define MSG_CONTROL_ARROW " Controle \x7E"
+	#define MSG_RETRACT_ARROW " Retrair \x7E"
+	#define MSG_TUNE " Tune    \x7E"
+	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"
+	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"
+	#define MSG_STOP_PRINT " Parar Impressao   \x7E"
+	#define MSG_CARD_MENU " Menu cartao SD    \x7E"
+	#define MSG_NO_CARD " Sem cartao SD"
+	#define MSG_DWELL "Repouso..."
+	#define MSG_USERWAIT "Esperando Ordem..."
+	#define MSG_RESUMING "Resuming print"
+	#define MSG_NO_MOVE "Sem movimento."
+	#define MSG_PART_RELEASE "Lancamento Parcial"
+	#define MSG_KILLED "PARADA DE EMERGENCIA. "
+	#define MSG_STOPPED "PARADA. "
+	#define MSG_STEPPER_RELEASED "Lancado."
+	#define MSG_CONTROL_RETRACT  " Retrair mm:"
+	#define MSG_CONTROL_RETRACTF " Retrair  F:"
+	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"
+	#define MSG_AUTORETRACT " AutoRetr.:"
+	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "enqueing \""
+	#define MSG_POWERUP "PowerUp"
+	#define MSG_EXTERNAL_RESET " Reset Externo"
+	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"
+	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"
+	#define MSG_SOFTWARE_RESET " Reset por Software"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "
+	#define MSG_FREE_MEMORY " memoria Livre: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Guardado."
+	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"
+	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"
+	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"
+	#define MSG_FILE_PRINTED "Impressao terminada"
+	#define MSG_BEGIN_FILE_LIST "Começo da lista de arquivos"
+	#define MSG_END_FILE_LIST "Fim da lista de arquivos"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor inválido "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor inválido "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor inválido "
+	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor inválido "
+	#define MSG_HEATING "Aquecendo..."
+	#define MSG_HEATING_COMPLETE "Aquecido."
+	#define MSG_BED_HEATING "Aquecendo a Base."
+	#define MSG_BED_DONE "Base quente."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Conta X:"
+	#define MSG_ERR_KILLED "Impressora parada com kill() !!"
+	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomeçar!. (Temperatura reiniciada. Ajuste antes de recomeçar)"
+	#define MSG_RESEND "Reenviar:"
+	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""
+	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "
+	#define MSG_INVALID_EXTRUDER "Extrusor invalido"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Relatando estado do ponto final"
+	#define MSG_ENDSTOP_HIT "PULSADO"
+	#define MSG_ENDSTOP_OPEN "Aberto"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"
+	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"
+	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"
+	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"
+	#define MSG_SD_CARD_OK "cartao SD ok"
+	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"
+	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "
+	#define MSG_SD_FILE_OPENED "Arquivo aberto:"
+	#define MSG_SD_SIZE " Size:"
+	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"
+	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "
+	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "
+	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"
+	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"
+
+	#define MSG_STEPPER_TOO_HIGH "Steprate muito alto : "
+	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"
+
+
+#endif
+
+
+
+#if LANGUAGE_CHOICE == 9
+
+// Finnish
+
+// LCD Menu Messages
+	#define WELCOME_MSG MACHINE_NAME " valmis"
+	#define MSG_SD_INSERTED "Kortti asetettu"
+	#define MSG_SD_REMOVED "Kortti poistettu"
+	#define MSG_MAIN "Palaa"
+	#define MSG_AUTOSTART "Automaatti"
+	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"
+	#define MSG_AUTO_HOME "Aja referenssiin"
+	#define MSG_SET_ORIGIN "Aseta origo"
+	#define MSG_PREHEAT_PLA "Esilammita PLA"
+	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"
+	#define MSG_PREHEAT_ABS "Esilammita ABS"
+	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"
+	#define MSG_COOLDOWN "Jaahdyta"
+	#define MSG_SWITCH_PS_ON "Switch Power On"
+	#define MSG_SWITCH_PS_OFF "Switch Power Off"
+	#define MSG_EXTRUDE "Pursota"
+	#define MSG_RETRACT "Veda takaisin"
+	#define MSG_MOVE_AXIS "Liikuta akseleita"
+	#define MSG_SPEED "Nopeus"
+	#define MSG_NOZZLE "Suutin"
+	#define MSG_NOZZLE1 "Suutin2"
+	#define MSG_NOZZLE2 "Suutin3"
+	#define MSG_BED "Alusta"
+	#define MSG_FAN_SPEED "Tuul. nopeus"
+	#define MSG_FLOW "Virtaus"
+	#define MSG_CONTROL "Kontrolli"
+	#define MSG_MIN " \002 Min"
+	#define MSG_MAX " \002 Max"
+	#define MSG_FACTOR " \002 Kerr"
+	#define MSG_AUTOTEMP "Autotemp"
+	#define MSG_ON "On "
+	#define MSG_OFF "Off"
+	#define MSG_PID_P "PID-P"
+	#define MSG_PID_I "PID-I"
+	#define MSG_PID_D "PID-D"
+	#define MSG_PID_C "PID-C"
+	#define MSG_ACC  "Kiihtyv"
+	#define MSG_VXY_JERK "Vxy-jerk"
 	#define MSG_VZ_JERK "Vz-jerk"
 	#define MSG_VE_JERK "Ve-jerk"
-	#define MSG_VMAX "Vmax "
-	#define MSG_X "x"
-	#define MSG_Y "y"
-	#define MSG_Z "z"
-	#define MSG_E "e"
-	#define MSG_VMIN "Vmin"
-	#define MSG_VTRAV_MIN "VLiike min"
-	#define MSG_AMAX "Amax "
-	#define MSG_A_RETRACT "A-peruuta"
-	#define MSG_XSTEPS "Xsteps/mm"
-	#define MSG_YSTEPS "Ysteps/mm"
-	#define MSG_ZSTEPS "Zsteps/mm"
-	#define MSG_ESTEPS "Esteps/mm"
-	#define MSG_RECTRACT "Veda takaisin"
-	#define MSG_TEMPERATURE "Lampotila"
-	#define MSG_MOTION "Liike"
-	#define MSG_STORE_EPROM "Tallenna muistiin"
-	#define MSG_LOAD_EPROM "Lataa muistista"
-	#define MSG_RESTORE_FAILSAFE "Palauta oletus"
-	#define MSG_REFRESH "Paivita"
-	#define MSG_WATCH "Seuraa"
-	#define MSG_PREPARE "Valmistele"
-	#define MSG_TUNE "Saada"
-	#define MSG_PAUSE_PRINT "Keskeyta tulostus"
-	#define MSG_RESUME_PRINT "Jatka tulostusta"
-	#define MSG_STOP_PRINT "Pysayta tulostus"
-	#define MSG_CARD_MENU "Korttivalikko"
-	#define MSG_NO_CARD "Ei korttia"
-	#define MSG_DWELL "Nukkumassa..."
-	#define MSG_USERWAIT "Odotetaan valintaa..."
-	#define MSG_RESUMING "Jatketaan tulostusta"
-	#define MSG_NO_MOVE "Ei liiketta."
-	#define MSG_KILLED "KILLED. "
-	#define MSG_STOPPED "STOPPED. "
-	#define MSG_CONTROL_RETRACT  "Veda mm"
-	#define MSG_CONTROL_RETRACTF "Veda F"
-	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"
-	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
-	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
-	#define MSG_AUTORETRACT "AutoVeto."
-	#define MSG_FILAMENTCHANGE "Change filament"
-
-// Serial Console Messages
-
-	#define MSG_Enqueing "jonoon \""
-	#define MSG_POWERUP "Kaynnistys"
-	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"
-	#define MSG_BROWNOUT_RESET " Alajannite Reset"
-	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
-	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
-	#define MSG_MARLIN "Marlin "
-	#define MSG_AUTHOR " | Author: "
-	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
-	#define MSG_FREE_MEMORY " Vapaata muistia: "
-	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
-	#define MSG_OK "ok"
-	#define MSG_FILE_SAVED "Tiedosto tallennettu."
-	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "
-	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "
-	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "
-	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "
-	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"
-	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"
-	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
-	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
-	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
-	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
-	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
-	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
-	#define MSG_HEATING "Lammitan..."
-	#define MSG_HEATING_COMPLETE "Lammitys valmis."
-	#define MSG_BED_HEATING "Alusta lampiaa."
-	#define MSG_BED_DONE "Alusta valmis."
-	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
-	#define MSG_COUNT_X " Laskuri X: "
-	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"
-	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"
-	#define MSG_RESEND "Uudelleenlahetys: "
-	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""
-	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "
-	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"
-	#define MSG_X_MIN "x_min: "
-	#define MSG_X_MAX "x_max: "
-	#define MSG_Y_MIN "y_min: "
-	#define MSG_Y_MAX "y_max: "
-	#define MSG_Z_MIN "z_min: "
-	#define MSG_Z_MAX "z_max: "
-	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"
-	#define MSG_ENDSTOP_HIT "AKTIIVISENA"
-	#define MSG_ENDSTOP_OPEN "avoinna"
-	#define MSG_HOTEND_OFFSET "Hotend offsets:"
-
-	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"
-	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"
-	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"
-	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"
-	#define MSG_SD_CARD_OK "SD kortti ok"
-	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"
-	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "
-	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "
-	#define MSG_SD_SIZE " Koko: "
-	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"
-	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "
-	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "
-	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"
-	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
-	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
-
-	#define MSG_STEPPER_TO_HIGH "Askellustaajuus liian suuri: "
-	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
-	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
-	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
-
-#endif
-#endif // ifndef LANGUAGE_H
+	#define MSG_VMAX "Vmax "
+	#define MSG_X "x"
+	#define MSG_Y "y"
+	#define MSG_Z "z"
+	#define MSG_E "e"
+	#define MSG_VMIN "Vmin"
+	#define MSG_VTRAV_MIN "VLiike min"
+	#define MSG_AMAX "Amax "
+	#define MSG_A_RETRACT "A-peruuta"
+	#define MSG_XSTEPS "Xsteps/mm"
+	#define MSG_YSTEPS "Ysteps/mm"
+	#define MSG_ZSTEPS "Zsteps/mm"
+	#define MSG_ESTEPS "Esteps/mm"
+	#define MSG_RECTRACT "Veda takaisin"
+	#define MSG_TEMPERATURE "Lampotila"
+	#define MSG_MOTION "Liike"
+	#define MSG_CONTRAST "LCD contrast"
+	#define MSG_STORE_EPROM "Tallenna muistiin"
+	#define MSG_LOAD_EPROM "Lataa muistista"
+	#define MSG_RESTORE_FAILSAFE "Palauta oletus"
+	#define MSG_REFRESH "Paivita"
+	#define MSG_WATCH "Seuraa"
+	#define MSG_PREPARE "Valmistele"
+	#define MSG_TUNE "Saada"
+	#define MSG_PAUSE_PRINT "Keskeyta tulostus"
+	#define MSG_RESUME_PRINT "Jatka tulostusta"
+	#define MSG_STOP_PRINT "Pysayta tulostus"
+	#define MSG_CARD_MENU "Korttivalikko"
+	#define MSG_NO_CARD "Ei korttia"
+	#define MSG_DWELL "Nukkumassa..."
+	#define MSG_USERWAIT "Odotetaan valintaa..."
+	#define MSG_RESUMING "Jatketaan tulostusta"
+	#define MSG_NO_MOVE "Ei liiketta."
+	#define MSG_KILLED "KILLED. "
+	#define MSG_STOPPED "STOPPED. "
+	#define MSG_CONTROL_RETRACT  "Veda mm"
+	#define MSG_CONTROL_RETRACTF "Veda F"
+	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"
+	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
+	#define MSG_AUTORETRACT "AutoVeto."
+	#define MSG_FILAMENTCHANGE "Change filament"
+	#define MSG_INIT_SDCARD "Init. SD-Card"	
+	#define MSG_CNG_SDCARD "Change SD-Card"
+
+// Serial Console Messages
+
+	#define MSG_Enqueing "jonoon \""
+	#define MSG_POWERUP "Kaynnistys"
+	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"
+	#define MSG_BROWNOUT_RESET " Alajannite Reset"
+	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"
+	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"
+	#define MSG_MARLIN "Marlin "
+	#define MSG_AUTHOR " | Author: "
+	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "
+	#define MSG_FREE_MEMORY " Vapaata muistia: "
+	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "
+	#define MSG_OK "ok"
+	#define MSG_FILE_SAVED "Tiedosto tallennettu."
+	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "
+	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "
+	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "
+	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "
+	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"
+	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"
+	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"
+	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "
+	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "
+	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "
+	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"
+	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "
+	#define MSG_HEATING "Lammitan..."
+	#define MSG_HEATING_COMPLETE "Lammitys valmis."
+	#define MSG_BED_HEATING "Alusta lampiaa."
+	#define MSG_BED_DONE "Alusta valmis."
+	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"
+	#define MSG_COUNT_X " Laskuri X: "
+	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"
+	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"
+	#define MSG_RESEND "Uudelleenlahetys: "
+	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""
+	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "
+	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"
+	#define MSG_X_MIN "x_min: "
+	#define MSG_X_MAX "x_max: "
+	#define MSG_Y_MIN "y_min: "
+	#define MSG_Y_MAX "y_max: "
+	#define MSG_Z_MIN "z_min: "
+	#define MSG_Z_MAX "z_max: "
+	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"
+	#define MSG_ENDSTOP_HIT "AKTIIVISENA"
+	#define MSG_ENDSTOP_OPEN "avoinna"
+	#define MSG_HOTEND_OFFSET "Hotend offsets:"
+
+	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"
+	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"
+	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"
+	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"
+	#define MSG_SD_CARD_OK "SD kortti ok"
+	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"
+	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "
+	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "
+	#define MSG_SD_SIZE " Koko: "
+	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"
+	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "
+	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "
+	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"
+	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"
+	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "
+
+	#define MSG_STEPPER_TOO_HIGH "Askellustaajuus liian suuri: "
+	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "
+	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"
+	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"
+
+#endif
+#endif // ifndef LANGUAGE_H
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 2424010..6023580 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -14,7 +14,7 @@
 #define DIGIPOTSS_PIN -1
 
 #if MOTHERBOARD == 99
-#define	KNOWN_BOARD 1
+#define KNOWN_BOARD 1
 
 #define X_STEP_PIN          2
 #define X_DIR_PIN           3
@@ -53,6 +53,7 @@
 
 #endif /* 99 */
 
+
 /****************************************************************************************
 * Gen7 v1.1, v1.2, v1.3 pin assignment
 *
@@ -227,8 +228,8 @@
 #endif
 
 //x axis pins
-    #define X_STEP_PIN      21                  //different from stanard GEN7
-    #define X_DIR_PIN       20				    //different from stanard GEN7
+    #define X_STEP_PIN      21                  // different from standard GEN7
+    #define X_DIR_PIN       20                  // different from standard GEN7
     #define X_ENABLE_PIN    24
     #define X_STOP_PIN      0
 
@@ -248,14 +249,14 @@
     #define E0_STEP_PIN      28
     #define E0_DIR_PIN       27
     #define E0_ENABLE_PIN    24
-    
+
     #define TEMP_0_PIN      2
     #define TEMP_1_PIN      -1
     #define TEMP_2_PIN      -1
     #define TEMP_BED_PIN        1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
-     
+
     #define HEATER_0_PIN    4
-    #define HEATER_1_PIN    -1   
+    #define HEATER_1_PIN    -1
     #define HEATER_2_PIN    -1
     #define HEATER_BED_PIN      3  // (bed)
 
@@ -272,40 +273,32 @@
     //our RS485 pins
     //#define TX_ENABLE_PIN       12
     //#define RX_ENABLE_PIN       13
-    
-    #define BEEPER -1	
-	#define SDCARDDETECT -1 		
-    #define SUICIDE_PIN -1						//has to be defined; otherwise Power_off doesn't work
-	
+
+    #define BEEPER -1
+    #define SDCARDDETECT -1
+    #define SUICIDE_PIN -1    //has to be defined; otherwise Power_off doesn't work
+
     #define KILL_PIN -1
-	//Pins for 4bit LCD Support 
-    #define LCD_PINS_RS 18 
+    //Pins for 4bit LCD Support
+    #define LCD_PINS_RS 18
     #define LCD_PINS_ENABLE 17
     #define LCD_PINS_D4 16
-    #define LCD_PINS_D5 15 
+    #define LCD_PINS_D5 15
     #define LCD_PINS_D6 13
     #define LCD_PINS_D7 14
-    
+
      //buttons are directly attached
     #define BTN_EN1 11
     #define BTN_EN2 10
     #define BTN_ENC 12  //the click
-    
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
 
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
 #endif
 
 /****************************************************************************************
 * Arduino Mega pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
+#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 #define KNOWN_BOARD 1
 
 //////////////////FIX THIS//////////////
@@ -315,156 +308,244 @@
  #endif
 #endif
 
+
 // uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1
 // #define RAMPS_V_1_3
 // #define RAMPS_V_1_0
 
-#if MOTHERBOARD == 33 || MOTHERBOARD == 34
 
-#define LARGE_FLASH        true
+#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 
-#define X_STEP_PIN         54
-#define X_DIR_PIN          55
-#define X_ENABLE_PIN       38
-#define X_MIN_PIN           3
-#define X_MAX_PIN           2
+  #define LARGE_FLASH true
+  
+  #if MOTHERBOARD == 77
+    #define X_STEP_PIN         54
+    #define X_DIR_PIN          55
+    #define X_ENABLE_PIN       38
+    #define X_MIN_PIN           3
+    #define X_MAX_PIN           -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
 
-#define Y_STEP_PIN         60
-#define Y_DIR_PIN          61
-#define Y_ENABLE_PIN       56
-#define Y_MIN_PIN          14
-#define Y_MAX_PIN          15
+    #define Y_STEP_PIN         60
+    #define Y_DIR_PIN          61
+    #define Y_ENABLE_PIN       56
+    #define Y_MIN_PIN          14
+    #define Y_MAX_PIN          -1   //15
 
-#define Z_STEP_PIN         46
-#define Z_DIR_PIN          48
-#define Z_ENABLE_PIN       62
-#define Z_MIN_PIN          18
-#define Z_MAX_PIN          19
+    #define Z_STEP_PIN         46
+    #define Z_DIR_PIN          48
+    #define Z_ENABLE_PIN       63
+    #define Z_MIN_PIN          18
+    #define Z_MAX_PIN          -1
 
-#define Z2_STEP_PIN        36
-#define Z2_DIR_PIN         34
-#define Z2_ENABLE_PIN      30
+    #define Z2_STEP_PIN        36
+    #define Z2_DIR_PIN         34
+    #define Z2_ENABLE_PIN      30
 
-#define E0_STEP_PIN        26
-#define E0_DIR_PIN         28
-#define E0_ENABLE_PIN      24
+    #define E0_STEP_PIN        26
+    #define E0_DIR_PIN         28
+    #define E0_ENABLE_PIN      24
 
-#define E1_STEP_PIN        36
-#define E1_DIR_PIN         34
-#define E1_ENABLE_PIN      30
+    #define E1_STEP_PIN        36
+    #define E1_DIR_PIN         34
+    #define E1_ENABLE_PIN      30
 
-#define SDPOWER            -1
-#define SDSS               53
-#define LED_PIN            13
+    #define SDPOWER            -1
+    #define SDSS               25//53
+    #define LED_PIN            13
 
-#if MOTHERBOARD == 33
-#define FAN_PIN            9 // (Sprinter config)
-#else
-#define FAN_PIN            4 // IO pin. Buffer needed
-#endif
-#define PS_ON_PIN          12
+    #define BEEPER             33    
 
-#if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
-#define KILL_PIN           41
-#else
-#define KILL_PIN           -1
-#endif
+  #else
 
-#define HEATER_0_PIN       10   // EXTRUDER 1
-#if MOTHERBOARD == 33
-#define HEATER_1_PIN       -1
-#else
-#define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
-#endif
-#define HEATER_2_PIN       -1   
-#define TEMP_0_PIN         13   // ANALOG NUMBERING
-#define TEMP_1_PIN         15   // ANALOG NUMBERING
-#define TEMP_2_PIN         -1   // ANALOG NUMBERING
-#define HEATER_BED_PIN     8    // BED
-#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+    #define X_STEP_PIN         54
+    #define X_DIR_PIN          55
+    #define X_ENABLE_PIN       38
+    #define X_MIN_PIN           3
+    #define X_MAX_PIN           2
+
+    #define Y_STEP_PIN         60
+    #define Y_DIR_PIN          61
+    #define Y_ENABLE_PIN       56
+    #define Y_MIN_PIN          14
+    #define Y_MAX_PIN          15
+
+    #define Z_STEP_PIN         46
+    #define Z_DIR_PIN          48
+    #define Z_ENABLE_PIN       62
+    #define Z_MIN_PIN          18
+    #define Z_MAX_PIN          19
+
+    #define Z2_STEP_PIN        36
+    #define Z2_DIR_PIN         34
+    #define Z2_ENABLE_PIN      30
+
+    #define E0_STEP_PIN        26
+    #define E0_DIR_PIN         28
+    #define E0_ENABLE_PIN      24
+
+    #define E1_STEP_PIN        36
+    #define E1_DIR_PIN         34
+    #define E1_ENABLE_PIN      30
+
+    #define SDPOWER            -1
+    #define SDSS               53
+    #define LED_PIN            13
+  #endif
 
-#ifdef ULTRA_LCD
+  #if MOTHERBOARD == 33 || MOTHERBOARD == 35
+    #define FAN_PIN            9 // (Sprinter config)
+  #else
+    #define FAN_PIN            4 // IO pin. Buffer needed
+  #endif
 
-  #ifdef NEWPANEL
-     //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
+  #if MOTHERBOARD == 77
+    #define FAN_PIN            8 
+  #endif
+  
+  #if MOTHERBOARD == 35
+    #define CONTROLLERFAN_PIN  10 //Pin used for the fan to cool controller
+  #endif
 
-    #define BLEN_A 0
-    #define BLEN_B 1
-    #define BLEN_C 2
+  #define PS_ON_PIN          12
 
-    #define LCD_PINS_RS 16 
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25 
-    #define LCD_PINS_D6 27
-    #define LCD_PINS_D7 29
-    
-    #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
-      #define BEEPER 37
+  #if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)
+    #define KILL_PIN           41
+  #else
+    #define KILL_PIN           -1
+  #endif
+
+  #if MOTHERBOARD == 35
+    #define HEATER_0_PIN       8
+  #else
+    #define HEATER_0_PIN       10   // EXTRUDER 1
+  #endif
 
-      #define BTN_EN1 31
-      #define BTN_EN2 33
-      #define BTN_ENC 35
+  #if MOTHERBOARD == 33 
+    #define HEATER_1_PIN       -1
+  #else
+    #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
+  #endif
+
+  #define HEATER_2_PIN       -1 
+
+  #if MOTHERBOARD == 77
+    #define HEATER_0_PIN       10   
+    #define HEATER_1_PIN       12 
+    #define HEATER_2_PIN       6   
+  #endif
 
-      #define SDCARDDETECT 49
+  #define TEMP_0_PIN         13   // ANALOG NUMBERING
+  #define TEMP_1_PIN         15   // ANALOG NUMBERING
+  #define TEMP_2_PIN         -1   // ANALOG NUMBERING
+
+  #if MOTHERBOARD == 35
+    #define HEATER_BED_PIN     -1    // NO BED
+  #else
+    #if MOTHERBOARD == 77
+      #define HEATER_BED_PIN     9    // BED
     #else
-      //arduino pin which triggers an piezzo beeper
-      #define BEEPER 33	 // Beeper on AUX-4
+      #define HEATER_BED_PIN     8    // BED
+    #endif
+  #endif
+  #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
-      //buttons are directly attached using AUX-2
-      #define BTN_EN1 37
-      #define BTN_EN2 35
-      #define BTN_ENC 31  //the click
 
-      #ifdef G3D_PANEL
-        #define SDCARDDETECT 49
-      #else
-        #define SDCARDDETECT -1  // Ramps does not use this port
-      #endif
+
+  #ifdef NUM_SERVOS
+    #define SERVO0_PIN         11
+
+    #if NUM_SERVOS > 1
+      #define SERVO1_PIN         6
     #endif
 
-  #else //old style panel with shift register
-    //arduino pin witch triggers an piezzo beeper
-    #define BEEPER 33		No Beeper added
+    #if NUM_SERVOS > 2
+      #define SERVO2_PIN         5
+    #endif
 
-    //buttons are attached to a shift register
-	// Not wired this yet
-    //#define SHIFT_CLK 38
-    //#define SHIFT_LD 42
-    //#define SHIFT_OUT 40
-    //#define SHIFT_EN 17
+    #if NUM_SERVOS > 3
+      #define SERVO3_PIN         4
+    #endif
+  #endif
+
+  #ifdef ULTRA_LCD
+
+    #ifdef NEWPANEL
+      #define LCD_PINS_RS 16 
+      #define LCD_PINS_ENABLE 17
+      #define LCD_PINS_D4 23
+      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D6 27
+      #define LCD_PINS_D7 29
+
+      #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER
+        #define BEEPER 37
+
+        #define BTN_EN1 31
+        #define BTN_EN2 33
+        #define BTN_ENC 35
+
+        #define SDCARDDETECT 49
+      #else
+        //arduino pin which triggers an piezzo beeper
+        #define BEEPER 33  // Beeper on AUX-4
+
+        //buttons are directly attached using AUX-2
+        #ifdef REPRAPWORLD_KEYPAD
+          #define BTN_EN1 64 // encoder
+          #define BTN_EN2 59 // encoder
+          #define BTN_ENC 63 // enter button
+          #define SHIFT_OUT 40 // shift register
+          #define SHIFT_CLK 44 // shift register
+          #define SHIFT_LD 42 // shift register
+        #else
+          #define BTN_EN1 37
+          #define BTN_EN2 35
+          #define BTN_ENC 31  //the click
+        #endif
+
+        #ifdef G3D_PANEL
+          #define SDCARDDETECT 49
+        #else
+          #define SDCARDDETECT -1  // Ramps does not use this port
+        #endif
     
-    #define LCD_PINS_RS 16 
-    #define LCD_PINS_ENABLE 17
-    #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25 
-    #define LCD_PINS_D6 27
-    #define LCD_PINS_D7 29
+      #endif
     
-    //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-
+      #if MOTHERBOARD == 77 
+        #define BEEPER -1 
+
+        #define LCD_PINS_RS 27 
+        #define LCD_PINS_ENABLE 29 
+        #define LCD_PINS_D4 37 
+        #define LCD_PINS_D5 35 
+        #define LCD_PINS_D6 33 
+        #define LCD_PINS_D7 31 
+
+       //buttons 
+       #define BTN_EN1 16 
+       #define BTN_EN2 17 
+       #define BTN_ENC 23 //the click 
+
+    #endif 
+    #else //old style panel with shift register
+      //arduino pin witch triggers an piezzo beeper
+      #define BEEPER 33		//No Beeper added
+
+      //buttons are attached to a shift register
+	// Not wired this yet
+      //#define SHIFT_CLK 38
+      //#define SHIFT_LD 42
+      //#define SHIFT_OUT 40
+      //#define SHIFT_EN 17
     
-    //bits in the shift register that carry the buttons for:
-    // left up center down right red
-    #define BL_LE 7
-    #define BL_UP 6
-    #define BL_MI 5
-    #define BL_DW 4
-    #define BL_RI 3
-    #define BL_ST 2
-
-    #define BLEN_B 1
-    #define BLEN_A 0
-  #endif 
-#endif //ULTRA_LCD
+      #define LCD_PINS_RS 16 
+      #define LCD_PINS_ENABLE 17
+      #define LCD_PINS_D4 23
+      #define LCD_PINS_D5 25 
+      #define LCD_PINS_D6 27
+      #define LCD_PINS_D7 29
+    #endif 
+  #endif //ULTRA_LCD
 
 #else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)
 
@@ -511,7 +592,8 @@
 #define TEMP_1_PIN          -1   
 #define TEMP_2_PIN          -1   
 #define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#endif// MOTHERBOARD == 33 || MOTHERBOARD == 34
+
+#endif // MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 
 // SPI for Max6675 Thermocouple 
 
@@ -525,7 +607,7 @@
   #define MAX6675_SS       49
 #endif
 
-#endif//MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34
+#endif //MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77
 
 /****************************************************************************************
 * Duemilanove w/ ATMega328P pin assignment
@@ -568,14 +650,139 @@
 #define HEATER_1_PIN        -1
 #define HEATER_2_PIN        -1
 #define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN          -1    
-#define TEMP_2_PIN          -1    
+#define TEMP_1_PIN          -1
+#define TEMP_2_PIN          -1
 #define HEATER_BED_PIN      -1
 #define TEMP_BED_PIN        -1
 
 #endif
 
 /****************************************************************************************
+* Elefu RA Board Pin Assignments
+*
+****************************************************************************************/
+#if MOTHERBOARD == 21
+#define	KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+#endif
+
+
+#define X_STEP_PIN		     49
+#define X_DIR_PIN			     13
+#define X_ENABLE_PIN		   48
+#define X_MIN_PIN			     35
+#define X_MAX_PIN			     -1 //34
+
+#define Y_STEP_PIN         11
+#define Y_DIR_PIN          9
+#define Y_ENABLE_PIN       12
+#define Y_MIN_PIN          33
+#define Y_MAX_PIN          -1 //32
+
+#define Z_STEP_PIN         7
+#define Z_DIR_PIN          6
+#define Z_ENABLE_PIN       8
+#define Z_MIN_PIN          31
+#define Z_MAX_PIN          -1 //30
+
+#define E2_STEP_PIN        43
+#define E2_DIR_PIN         47
+#define E2_ENABLE_PIN      42
+
+#define E1_STEP_PIN        18
+#define E1_DIR_PIN         19
+#define E1_ENABLE_PIN      38
+
+#define E0_STEP_PIN        40
+#define E0_DIR_PIN         41
+#define E0_ENABLE_PIN      37
+
+#define SDPOWER            -1
+#define LED_PIN            -1 //Use +12V Aux port for LED Ring
+
+#define FAN_PIN            16 //5V PWM
+
+#define PS_ON_PIN          10 //Set to -1 if using a manual switch on the PWRSW Connector
+#define SLEEP_WAKE_PIN		 26 //This feature still needs work
+
+#define HEATER_0_PIN       45	//12V PWM1
+#define HEATER_1_PIN       46	//12V PWM2
+#define HEATER_2_PIN       17	//12V PWM3
+#define HEATER_BED_PIN     44	//DOUBLE 12V PWM
+#define TEMP_0_PIN         3	//ANALOG NUMBERING
+#define TEMP_1_PIN         2 	//ANALOG NUMBERING
+#define TEMP_2_PIN         1 	//ANALOG NUMBERING
+#define TEMP_BED_PIN       0	//ANALOG NUMBERING
+
+#define BEEPER 		         36
+
+#define KILL_PIN           -1
+
+// M240  Triggers a camera by emulating a Canon RC-1 Remote
+// Data from: http://www.doc-diy.net/photo/rc-1_hacked/
+#define PHOTOGRAPH_PIN     29
+
+#ifdef RA_CONTROL_PANEL
+
+  #define SDSS             53
+  #define SDCARDDETECT     28
+
+  #define BTN_EN1          14
+  #define BTN_EN2          39
+  #define BTN_ENC          15  //the click
+    
+  #define BLEN_C           2
+  #define BLEN_B           1
+  #define BLEN_A           0
+    
+  //encoder rotation values
+  #define encrot0          0
+  #define encrot1          2
+  #define encrot2          3
+  #define encrot3          1
+  
+#endif //RA_CONTROL_PANEL
+
+#ifdef RA_DISCO
+  //variables for which pins the TLC5947 is using
+  #define TLC_CLOCK_PIN    25
+  #define TLC_BLANK_PIN    23
+  #define TLC_XLAT_PIN     22
+  #define TLC_DATA_PIN     24
+
+  //We also need to define pin to port number mapping for the 2560 to match the pins listed above. If you change the TLC pins, update this as well per the 2560 datasheet!
+  //This currently only works with the RA Board.
+  #define TLC_CLOCK_BIT 3 //bit 3 on port A
+  #define TLC_CLOCK_PORT &PORTA //bit 3 on port A
+  
+  #define TLC_BLANK_BIT 1 //bit 1 on port A
+  #define TLC_BLANK_PORT &PORTA //bit 1 on port A
+
+  #define TLC_DATA_BIT 2 //bit 2 on port A
+  #define TLC_DATA_PORT &PORTA //bit 2 on port A
+
+  #define TLC_XLAT_BIT 0 //bit 0 on port A
+  #define TLC_XLAT_PORT &PORTA //bit 0 on port A
+
+  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful 
+  //Leave it at at least 1 if you have enabled RA_LIGHTING
+  //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.
+  #define NUM_TLCS 2 
+
+  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions. 
+  //Modify them according to your specific situation.
+  //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.
+  #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards
+  //#define TRANS_ARRAY {7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 11, 12, 13, 14, 15} //backwards
+#endif //RA_LIGHTING
+
+
+#endif /* Ra Board */
+
+
+/****************************************************************************************
 * Gen6 pin assignment
 *
 ****************************************************************************************/
@@ -632,14 +839,14 @@
     #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410
     #define KILL_PIN        -1    //changed @ drakelive 20120830
     //our pin for debugging.
-    
+
     #define DEBUG_PIN        0
-    
+
     //our RS485 pins
-    #define TX_ENABLE_PIN	12
-    #define RX_ENABLE_PIN	13
+    #define TX_ENABLE_PIN 12
+    #define RX_ENABLE_PIN 13
+
 
-    
 #endif
 
 /****************************************************************************************
@@ -649,13 +856,16 @@
 #if MOTHERBOARD == 64
 #define STB
 #endif
-#if MOTHERBOARD == 63
+#if MOTHERBOARD == 63 || MOTHERBOARD == 66
 #define MELZI
 #endif
-#if MOTHERBOARD == 62 || MOTHERBOARD == 63 || MOTHERBOARD == 64
+#if MOTHERBOARD == 65
+#define AZTEEG_X1
+#endif
+#if MOTHERBOARD == 62 || MOTHERBOARD == 63 || MOTHERBOARD == 64 || MOTHERBOARD == 65 || MOTHERBOARD == 66
 #undef MOTHERBOARD
 #define MOTHERBOARD 6
-#define SANGUINOLOLU_V_1_2 
+#define SANGUINOLOLU_V_1_2
 #endif
 #if MOTHERBOARD == 6
 #define KNOWN_BOARD 1
@@ -682,7 +892,7 @@
 
 #define LED_PIN            -1
 
-#define FAN_PIN            -1 
+#define FAN_PIN            -1
 #if FAN_PIN == 12 || FAN_PIN ==13
 #define FAN_SOFT_PWM
 #endif
@@ -694,6 +904,12 @@
 
 #ifdef STB
 #define FAN_PIN            4
+	//  Uncomment this if you have the first generation (V1.10) of STBs board
+#define LCD_PIN_BL         17 // LCD backlight LED
+#endif
+
+#ifdef AZTEEG_X1
+#define FAN_PIN            4
 #endif
 
 #define PS_ON_PIN          -1
@@ -736,46 +952,65 @@
      //we have no buzzer installed
      #define BEEPER -1
      //LCD Pins
-	 	 #ifdef DOGLCD
-			 // Pins for DOGM SPI LCD Support
-			 #define DOGLCD_A0	30
-			 #define DOGLCD_CS	29
-			 // GLCD features
-			 #define LCD_CONTRAST 1
-			 // Uncomment screen orientation
-		     // #define LCD_SCREEN_ROT_0
-		     // #define LCD_SCREEN_ROT_90
-			 #define LCD_SCREEN_ROT_180
-		     // #define LCD_SCREEN_ROT_270
-			 #else // standard Hitachi LCD controller
-			 #define LCD_PINS_RS        4
-			 #define LCD_PINS_ENABLE    17
-			 #define LCD_PINS_D4        30
-			 #define LCD_PINS_D5        29
-			 #define LCD_PINS_D6        28
-			 #define LCD_PINS_D7        27
-         #endif
+     #ifdef DOGLCD
+       // Pins for DOGM SPI LCD Support
+       #define DOGLCD_A0  30
+       #define DOGLCD_CS  29
+       // GLCD features
+       #define LCD_CONTRAST 1
+       // Uncomment screen orientation
+         // #define LCD_SCREEN_ROT_0
+         // #define LCD_SCREEN_ROT_90
+       #define LCD_SCREEN_ROT_180
+         // #define LCD_SCREEN_ROT_270
+       #else // standard Hitachi LCD controller
+       #define LCD_PINS_RS        4
+       #define LCD_PINS_ENABLE    17
+       #define LCD_PINS_D4        30
+       #define LCD_PINS_D5        29
+       #define LCD_PINS_D6        28
+       #define LCD_PINS_D7        27
+     #endif
      //The encoder and click button
-     #define BTN_EN1 11  //must be a hardware interrupt pin
-     #define BTN_EN2 10 //must be hardware interrupt pin
-     #define BTN_ENC 16  //the switch
+     #define BTN_EN1 11  
+     #define BTN_EN2 10 
+     #ifdef LCD_I2C_PANELOLU2
+       #ifdef MELZI
+         #define BTN_ENC 29 //the click switch
+         #define SDSS 30 //to use the SD card reader on the Panelolu2 rather than the melzi board
+       #else
+         #define BTN_ENC 30 //the click switch
+       #endif
+     #else
+       #define BTN_ENC 16  //the click switch
+     #endif //Panelolu2
      //not connected to a pin
-     #define SDCARDDETECT -1
-     
-     //from the same bit in the RAMPS Newpanel define
-     //encoder rotation values
-     #define encrot0 0
-     #define encrot1 2
-     #define encrot2 3
-     #define encrot3 1
-     
-     #define BLEN_C 2
-     #define BLEN_B 1
-     #define BLEN_A 0
-     
+     #define SDCARDDETECT -1    
+    
    #endif //Newpanel
  #endif //Ultipanel
- 
+
+ #ifdef MAKRPANEL
+     #define BEEPER 29
+     // Pins for DOGM SPI LCD Support
+     #define DOGLCD_A0  30
+     #define DOGLCD_CS  17
+     #define LCD_PIN_BL	28	// backlight LED on PA3
+     // GLCD features
+     #define LCD_CONTRAST 1
+     // Uncomment screen orientation
+     #define LCD_SCREEN_ROT_0
+       // #define LCD_SCREEN_ROT_90
+       // #define LCD_SCREEN_ROT_180
+       // #define LCD_SCREEN_ROT_270
+     //The encoder and click button
+     #define BTN_EN1 11
+     #define BTN_EN2 10
+     #define BTN_ENC 16  //the click switch
+     //not connected to a pin
+     #define SDCARDDETECT -1    
+ #endif //Makrpanel
+
 #endif
 
 
@@ -805,17 +1040,17 @@
 #define Y_MAX_PIN 28
 #define Y_ENABLE_PIN 29
 
-#define Z_STEP_PIN 37 
+#define Z_STEP_PIN 37
 #define Z_DIR_PIN 39
 #define Z_MIN_PIN 30
 #define Z_MAX_PIN 32
 #define Z_ENABLE_PIN 35
 
-#define HEATER_BED_PIN 4 
-#define TEMP_BED_PIN 10  
+#define HEATER_BED_PIN 4
+#define TEMP_BED_PIN 10
 
 #define HEATER_0_PIN  2
-#define TEMP_0_PIN 8   
+#define TEMP_0_PIN 8
 
 #define HEATER_1_PIN 3
 #define TEMP_1_PIN 9
@@ -845,29 +1080,20 @@
   //arduino pin witch triggers an piezzo beeper
     #define BEEPER 18
 
-    #define LCD_PINS_RS 20 
+    #define LCD_PINS_RS 20
     #define LCD_PINS_ENABLE 17
     #define LCD_PINS_D4 16
-    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D5 21
     #define LCD_PINS_D6 5
     #define LCD_PINS_D7 6
-    
+
     //buttons are directly attached
     #define BTN_EN1 40
     #define BTN_EN2 42
     #define BTN_ENC 19  //the click
     
-    #define BLEN_C 2
-    #define BLEN_B 1
-    #define BLEN_A 0
-    
     #define SDCARDDETECT 38
     
-      //encoder rotation values
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
   #else //old style panel with shift register
     //arduino pin witch triggers an piezzo beeper
     #define BEEPER 18
@@ -877,40 +1103,15 @@
     #define SHIFT_LD 42
     #define SHIFT_OUT 40
     #define SHIFT_EN 17
-    
-    #define LCD_PINS_RS 16 
+
+    #define LCD_PINS_RS 16
     #define LCD_PINS_ENABLE 5
     #define LCD_PINS_D4 6
-    #define LCD_PINS_D5 21 
+    #define LCD_PINS_D5 21
     #define LCD_PINS_D6 20
     #define LCD_PINS_D7 19
-    
-    //encoder rotation values
-    #ifndef ULTIMAKERCONTROLLER
-     #define encrot0 0
-     #define encrot1 2
-     #define encrot2 3
-     #define encrot3 1
-    #else
-     #define encrot0 0
-     #define encrot1 1
-     #define encrot2 3
-     #define encrot3 2
-
-    #endif
-
+  
     #define SDCARDDETECT -1
-    //bits in the shift register that carry the buttons for:
-    // left up center down right red
-    #define BL_LE 7
-    #define BL_UP 6
-    #define BL_MI 5
-    #define BL_DW 4
-    #define BL_RI 3
-    #define BL_ST 2
-
-    #define BLEN_B 1
-    #define BLEN_A 0
   #endif 
 #endif //ULTRA_LCD
 
@@ -942,17 +1143,17 @@
 #define Y_MAX_PIN 16
 #define Y_ENABLE_PIN 29
 
-#define Z_STEP_PIN 37 
+#define Z_STEP_PIN 37
 #define Z_DIR_PIN 39
 #define Z_MIN_PIN 19
 #define Z_MAX_PIN 18
 #define Z_ENABLE_PIN 35
 
-#define HEATER_BED_PIN -1 
-#define TEMP_BED_PIN -1  
+#define HEATER_BED_PIN -1
+#define TEMP_BED_PIN -1
 
 #define HEATER_0_PIN  2
-#define TEMP_0_PIN 8   
+#define TEMP_0_PIN 8
 
 #define HEATER_1_PIN 1
 #define TEMP_1_PIN 1
@@ -976,10 +1177,10 @@
 #define KILL_PIN           -1
 #define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.
 
-#define LCD_PINS_RS 24 
+#define LCD_PINS_RS 24
 #define LCD_PINS_ENABLE 22
 #define LCD_PINS_D4 36
-#define LCD_PINS_D5 34 
+#define LCD_PINS_D5 34
 #define LCD_PINS_D6 32
 #define LCD_PINS_D7 30
 
@@ -1001,17 +1202,17 @@
 #define X_DIR_PIN          16
 #define X_ENABLE_PIN       48
 #define X_MIN_PIN          37
-#define X_MAX_PIN          36 
+#define X_MAX_PIN          36
 
 #define Y_STEP_PIN         54
-#define Y_DIR_PIN          47 
+#define Y_DIR_PIN          47
 #define Y_ENABLE_PIN       55
 #define Y_MIN_PIN          35
-#define Y_MAX_PIN          34 
+#define Y_MAX_PIN          34
 
-#define Z_STEP_PIN         57 
+#define Z_STEP_PIN         57
 #define Z_DIR_PIN          56
-#define Z_ENABLE_PIN       62 
+#define Z_ENABLE_PIN       62
 #define Z_MIN_PIN          33
 #define Z_MAX_PIN          32
 
@@ -1029,45 +1230,76 @@
 
 #define LED_PIN            13
 
-#define FAN_PIN            7 
+#define FAN_PIN            7
 //additional FAN1 PIN (e.g. useful for electronics fan or light on/off) on PIN 8
 
 #define PS_ON_PIN          45
 #define KILL_PIN           46
 
-#define HEATER_0_PIN       2    // EXTRUDER 1
-#define HEATER_1_PIN       3    // EXTRUDER 2
-#define HEATER_2_PIN       6    // EXTRUDER 3
+#if (TEMP_SENSOR_0==0)
+ #define TEMP_0_PIN         -1
+ #define HEATER_0_PIN       -1
+#else
+ #define HEATER_0_PIN        2    // EXTRUDER 1
+ #if (TEMP_SENSOR_0==-1)
+  #define TEMP_0_PIN         6    // ANALOG NUMBERING - connector *K1* on RUMBA thermocouple ADD ON is used
+ #else
+  #define TEMP_0_PIN         15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used
+ #endif
+#endif 
+
+#if (TEMP_SENSOR_1==0)
+ #define TEMP_1_PIN         -1
+ #define HEATER_1_PIN       -1
+#else
+ #define HEATER_1_PIN        3    // EXTRUDER 2
+ #if (TEMP_SENSOR_1==-1)
+  #define TEMP_1_PIN         5    // ANALOG NUMBERING - connector *K2* on RUMBA thermocouple ADD ON is used
+ #else
+  #define TEMP_1_PIN         14   // ANALOG NUMBERING - default connector for thermistor *T1* on rumba board is used
+ #endif
+#endif
+
+#if (TEMP_SENSOR_2==0)
+ #define TEMP_2_PIN         -1
+ #define HEATER_2_PIN       -1
+#else
+ #define HEATER_2_PIN        6    // EXTRUDER 3
+ #if (TEMP_SENSOR_2==-1)
+  #define TEMP_2_PIN         7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_BED is defined as thermocouple
+ #else
+  #define TEMP_2_PIN         13   // ANALOG NUMBERING - default connector for thermistor *T2* on rumba board is used
+ #endif
+#endif
+
+//optional for extruder 4 or chamber: #define TEMP_X_PIN         12   // ANALOG NUMBERING - default connector for thermistor *T3* on rumba board is used
 //optional FAN1 can be used as 4th heater output: #define HEATER_3_PIN       8    // EXTRUDER 4
-#define HEATER_BED_PIN     9    // BED
 
-#define TEMP_0_PIN         15   // ANALOG NUMBERING
-#define TEMP_1_PIN         14   // ANALOG NUMBERING
-#define TEMP_2_PIN         13   // ANALOG NUMBERING
-//optional for extruder 4 or chamber: #define TEMP_2_PIN         12   // ANALOG NUMBERING
-#define TEMP_BED_PIN       11   // ANALOG NUMBERING
+#if (TEMP_SENSOR_BED==0)
+ #define TEMP_BED_PIN       -1
+ #define HEATER_BED_PIN     -1
+#else
+ #define HEATER_BED_PIN      9    // BED
+ #if (TEMP_SENSOR_BED==-1)
+  #define TEMP_BED_PIN       7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_2 is defined as thermocouple
+ #else
+  #define TEMP_BED_PIN       11   // ANALOG NUMBERING - default connector for thermistor *THB* on rumba board is used
+ #endif
+#endif
 
 #define SDPOWER            -1
 #define SDSS               53
 #define SDCARDDETECT       49
 #define BEEPER             44
-#define LCD_PINS_RS        19 
+#define LCD_PINS_RS        19
 #define LCD_PINS_ENABLE    42
 #define LCD_PINS_D4        18
-#define LCD_PINS_D5        38 
+#define LCD_PINS_D5        38
 #define LCD_PINS_D6        41
 #define LCD_PINS_D7        40
 #define BTN_EN1            11
 #define BTN_EN2            12
 #define BTN_ENC            43
-//encoder rotation values
-#define BLEN_C 2
-#define BLEN_B 1
-#define BLEN_A 0
-#define encrot0 0
-#define encrot1 2
-#define encrot2 3
-#define encrot3 1
 
 #endif //MOTHERBOARD==80
 
@@ -1238,7 +1470,7 @@
 
 #define LED_PIN            -1
 
-#define FAN_PIN            -1 
+#define FAN_PIN            -1
 
 #define PS_ON_PIN         14
 #define KILL_PIN           -1
@@ -1277,7 +1509,7 @@
 *       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
 *        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
 *                  RST  9|        |32  AREF
-*                  VCC 10|        |31  GND 
+*                  VCC 10|        |31  GND
 *                  GND 11|        |30  AVCC
 *                XTAL2 12|        |29  PC7 (D 23)
 *                XTAL1 13|        |28  PC6 (D 22)
@@ -1334,7 +1566,7 @@
 #define KILL_PIN           -1
 
 #define HEATER_0_PIN       4
-#define HEATER_1_PIN       -1 // 12 
+#define HEATER_1_PIN       -1 // 12
 #define HEATER_2_PIN       -1 // 13
 #define TEMP_0_PIN          0 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
 #define TEMP_1_PIN         -1 // 1
@@ -1372,12 +1604,12 @@
 #define E0_ENABLE_PIN       10
 
 /* future proofing */
-#define __FS	20
-#define __FD	19
-#define __GS	18
-#define __GD	13
+#define __FS  20
+#define __FD  19
+#define __GS  18
+#define __GD  13
 
-#define UNUSED_PWM           14	/* PWM on LEFT connector */
+#define UNUSED_PWM           14 /* PWM on LEFT connector */
 
 #define E1_STEP_PIN         -1 // 21
 #define E1_DIR_PIN          -1 // 20
@@ -1396,18 +1628,18 @@
 #define KILL_PIN           -1
 
 #define HEATER_0_PIN        3 /*DONE PWM on RIGHT connector */
-#define HEATER_1_PIN       -1 
+#define HEATER_1_PIN       -1
 #define HEATER_2_PIN       -1
-#define HEATER_1_PIN       -1 
+#define HEATER_1_PIN       -1
 #define HEATER_2_PIN       -1
-#define TEMP_0_PIN          0 // ANALOG INPUT NUMBERING 
+#define TEMP_0_PIN          0 // ANALOG INPUT NUMBERING
 #define TEMP_1_PIN          1 // ANALOG
 #define TEMP_2_PIN         -1 // 2
 #define HEATER_BED_PIN      4
 #define TEMP_BED_PIN        2 // 1,2 or I2C
 
-#define I2C_SCL				16
-#define I2C_SDA				17
+#define I2C_SCL       16
+#define I2C_SDA       17
 
 #endif
 
@@ -1448,7 +1680,7 @@
 #define Z_MS2_PIN 67
 
 #define HEATER_BED_PIN 3
-#define TEMP_BED_PIN 2 
+#define TEMP_BED_PIN 2
 
 #define HEATER_0_PIN  9
 #define TEMP_0_PIN 0
@@ -1456,7 +1688,11 @@
 #define HEATER_1_PIN 7
 #define TEMP_1_PIN 1
 
+#ifdef BARICUDA
+#define HEATER_2_PIN 6
+#else
 #define HEATER_2_PIN -1
+#endif
 #define TEMP_2_PIN -1
 
 #define E0_STEP_PIN         34
@@ -1491,7 +1727,6 @@
 #if MOTHERBOARD == 70
 #define KNOWN_BOARD 1
 
-//////////////////FIX THIS//////////////
 
  #ifndef __AVR_ATmega2560__
  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
@@ -1537,9 +1772,9 @@
 
 #define HEATER_0_PIN       9    // EXTRUDER 1
 #define HEATER_1_PIN       8    // EXTRUDER 2 (FAN On Sprinter)
-#define HEATER_2_PIN       -1  
+#define HEATER_2_PIN       -1
 
-#if TEMP_SENSOR_0 == -1 
+#if TEMP_SENSOR_0 == -1
 #define TEMP_0_PIN         8   // ANALOG NUMBERING
 #else
 #define TEMP_0_PIN         13   // ANALOG NUMBERING
@@ -1551,21 +1786,21 @@
 #define HEATER_BED_PIN     10   // BED
 #define TEMP_BED_PIN       14   // ANALOG NUMBERING
 
-#define BEEPER 33			// Beeper on AUX-4
+#define BEEPER 33     // Beeper on AUX-4
 
 
 #ifdef ULTRA_LCD
 
   #ifdef NEWPANEL
   //arduino pin which triggers an piezzo beeper
-    
-    #define LCD_PINS_RS 16 
+
+    #define LCD_PINS_RS 16
     #define LCD_PINS_ENABLE 17
     #define LCD_PINS_D4 23
-    #define LCD_PINS_D5 25 
+    #define LCD_PINS_D5 25
     #define LCD_PINS_D6 27
     #define LCD_PINS_D7 29
-    
+
     //buttons are directly attached using AUX-2
     #define BTN_EN1 59
     #define BTN_EN2 64
@@ -1587,12 +1822,220 @@
 
 #endif
 
+/****************************************************************************************
+* MegaTronics v2.0
+*
+****************************************************************************************/
+#if MOTHERBOARD == 701
+ #define KNOWN_BOARD 1
+ 
+ 
+ #ifndef __AVR_ATmega2560__
+ #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+ 
+ #define LARGE_FLASH        true
+ 
+ #define X_STEP_PIN 26
+ #define X_DIR_PIN 27
+ #define X_ENABLE_PIN 25
+ #define X_MIN_PIN 37
+ #define X_MAX_PIN 40 //2 //Max endstops default to disabled "-1", set to commented value to enable.
+ 
+ #define Y_STEP_PIN 4 // A6
+ #define Y_DIR_PIN 54 // A0
+ #define Y_ENABLE_PIN 5
+ #define Y_MIN_PIN 41
+ #define Y_MAX_PIN 38 //15
+ 
+ #define Z_STEP_PIN 56 // A2
+ #define Z_DIR_PIN 60 // A6
+ #define Z_ENABLE_PIN 55 // A1
+ #define Z_MIN_PIN 18
+ #define Z_MAX_PIN 19
+ 
+ #define E0_STEP_PIN 35
+ #define E0_DIR_PIN 36
+ #define E0_ENABLE_PIN 34
+ 
+ #define E1_STEP_PIN 29
+ #define E1_DIR_PIN 39
+ #define E1_ENABLE_PIN 28
+ 
+ #define E2_STEP_PIN 23
+ #define E2_DIR_PIN 24
+ #define E2_ENABLE_PIN 22
+ 
+ #define SDPOWER -1
+ #define SDSS 53
+ #define LED_PIN 13
+ 
+ #define FAN_PIN 7
+ #define FAN2_PIN 6
+ #define PS_ON_PIN 12
+ #define KILL_PIN -1
+ 
+ #define HEATER_0_PIN 9 // EXTRUDER 1
+ #define HEATER_1_PIN 8 // EXTRUDER 2
+ #define HEATER_2_PIN -1
+ 
+ #if TEMP_SENSOR_0 == -1
+   #define TEMP_0_PIN 4 // ANALOG NUMBERING
+ #else
+   #define TEMP_0_PIN 13 // ANALOG NUMBERING
+ #endif
+ 
+ 
+ #if TEMP_SENSOR_1 == -1
+   #define TEMP_1_PIN 8 // ANALOG NUMBERING
+ #else
+   #define TEMP_1_PIN 15 // ANALOG NUMBERING
+ #endif
+ 
+ #define TEMP_2_PIN -1 // ANALOG NUMBERING
+ 
+ #define HEATER_BED_PIN 10 // BED
+ 
+ #if TEMP_SENSOR_BED == -1
+   #define TEMP_BED_PIN 8 // ANALOG NUMBERING
+ #else 
+   #define TEMP_BED_PIN 14 // ANALOG NUMBERING
+ #endif
+ 
+ #define BEEPER 64	
+ 
+ 
+ #define LCD_PINS_RS 14
+ #define LCD_PINS_ENABLE 15
+ #define LCD_PINS_D4 30
+ #define LCD_PINS_D5 31
+ #define LCD_PINS_D6 32
+ #define LCD_PINS_D7 33
+ 
+ 
+ //buttons are directly attached using keypad
+ #define BTN_EN1 61
+ #define BTN_EN2 59
+ #define BTN_ENC 43 //the click
+ 
+ #define BLEN_C 2
+ #define BLEN_B 1
+ #define BLEN_A 0
+ 
+ #define SDCARDDETECT -1	// Megatronics does not use this port
+ 
+   //encoder rotation values
+ #define encrot0 0
+ #define encrot1 2
+ #define encrot2 3
+ #define encrot3 1
+
+#endif
+
+
+/****************************************************************************************
+* Minitronics v1.0
+*
+****************************************************************************************/
+#if MOTHERBOARD == 702
+ #define KNOWN_BOARD 1
+ 
+ 
+ #ifndef __AVR_ATmega1281__
+ #error Oops! Make sure you have 'Minitronics ' selected from the 'Tools -> Boards' menu.
+ #endif
+ 
+ #define LARGE_FLASH        true
+ 
+ #define X_STEP_PIN 48
+ #define X_DIR_PIN 47
+ #define X_ENABLE_PIN 49
+ #define X_MIN_PIN 5
+ #define X_MAX_PIN -1 //2 //Max endstops default to disabled "-1", set to commented value to enable.
+ 
+ #define Y_STEP_PIN 39 // A6
+ #define Y_DIR_PIN 40 // A0
+ #define Y_ENABLE_PIN 38
+ #define Y_MIN_PIN 2
+ #define Y_MAX_PIN -1 //15
+ 
+ #define Z_STEP_PIN 42 // A2
+ #define Z_DIR_PIN 43 // A6
+ #define Z_ENABLE_PIN 41 // A1
+ #define Z_MIN_PIN 6
+ #define Z_MAX_PIN -1
+ 
+ #define E0_STEP_PIN 45
+ #define E0_DIR_PIN 44
+ #define E0_ENABLE_PIN 27
+ 
+ #define E1_STEP_PIN 36
+ #define E1_DIR_PIN 35
+ #define E1_ENABLE_PIN 37
+ 
+ #define E2_STEP_PIN -1
+ #define E2_DIR_PIN -1
+ #define E2_ENABLE_PIN -1
+ 
+ #define SDPOWER -1
+ #define SDSS 16
+ #define LED_PIN 46
+ 
+ #define FAN_PIN 9
+ #define FAN2_PIN -1
+ #define PS_ON_PIN -1
+ #define KILL_PIN -1
+ 
+ #define HEATER_0_PIN 7 // EXTRUDER 1
+ #define HEATER_1_PIN 8 // EXTRUDER 2
+ #define HEATER_2_PIN -1
+ 
+
+ #define TEMP_0_PIN 7 // ANALOG NUMBERING
+ #define TEMP_1_PIN 6 // ANALOG NUMBERING
+ #define TEMP_2_PIN -1 // ANALOG NUMBERING
+ 
+ #define HEATER_BED_PIN 3 // BED
+ #define TEMP_BED_PIN 6 // ANALOG NUMBERING
+ 
+ #define BEEPER -1	
+ 
+ 
+ #define LCD_PINS_RS -1
+ #define LCD_PINS_ENABLE -1
+ #define LCD_PINS_D4 -1
+ #define LCD_PINS_D5 -1
+ #define LCD_PINS_D6 -1
+ #define LCD_PINS_D7 -1
+ 
+ 
+ //buttons are directly attached using keypad
+ #define BTN_EN1 -1
+ #define BTN_EN2 -1
+ #define BTN_ENC -1 //the click
+ 
+ #define BLEN_C 2
+ #define BLEN_B 1
+ #define BLEN_A 0
+ 
+ #define SDCARDDETECT -1	// Megatronics does not use this port
+ 
+   //encoder rotation values
+ #define encrot0 0
+ #define encrot1 2
+ #define encrot2 3
+ #define encrot3 1
+
+#endif
+
+
+
 #ifndef KNOWN_BOARD
 #error Unknown MOTHERBOARD value in configuration.h
 #endif
 
 //List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
-#define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, HEATER_0_PIN, 
+#define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, HEATER_0_PIN,
 #if EXTRUDERS > 1
   #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN, HEATER_1_PIN,
 #else
@@ -1640,8 +2083,15 @@
 #define Z_MAX_PIN          -1
 #endif
 
+#ifdef DISABLE_MIN_ENDSTOPS
+#define X_MIN_PIN          -1
+#define Y_MIN_PIN          -1
+#define Z_MIN_PIN          -1
+#endif
+
 #define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, PS_ON_PIN, \
                         HEATER_BED_PIN, FAN_PIN,                  \
                         _E0_PINS _E1_PINS _E2_PINS             \
                         analogInputToDigitalPin(TEMP_0_PIN), analogInputToDigitalPin(TEMP_1_PIN), analogInputToDigitalPin(TEMP_2_PIN), analogInputToDigitalPin(TEMP_BED_PIN) }
 #endif
+
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 854fd19..8eff191 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -98,7 +98,7 @@ volatile unsigned char block_buffer_tail;           // Index of the block to pro
 //=============================private variables ============================
 //===========================================================================
 #ifdef PREVENT_DANGEROUS_EXTRUDE
-bool allow_cold_extrude=false;
+float extrude_min_temp=EXTRUDE_MINTEMP;
 #endif
 #ifdef XY_FREQUENCY_LIMIT
 #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
@@ -439,12 +439,20 @@ void check_axes_activity()
   unsigned char z_active = 0;
   unsigned char e_active = 0;
   unsigned char tail_fan_speed = fanSpeed;
+  #ifdef BARICUDA
+  unsigned char tail_valve_pressure = ValvePressure;
+  unsigned char tail_e_to_p_pressure = EtoPPressure;
+  #endif
   block_t *block;
 
   if(block_buffer_tail != block_buffer_head)
   {
     uint8_t block_index = block_buffer_tail;
     tail_fan_speed = block_buffer[block_index].fan_speed;
+    #ifdef BARICUDA
+    tail_valve_pressure = block_buffer[block_index].valve_pressure;
+    tail_e_to_p_pressure = block_buffer[block_index].e_to_p_pressure;
+    #endif
     while(block_index != block_buffer_head)
     {
       block = &block_buffer[block_index];
@@ -464,28 +472,40 @@ void check_axes_activity()
     disable_e1();
     disable_e2(); 
   }
-#if FAN_PIN > -1
-  #ifndef FAN_SOFT_PWM
-    #ifdef FAN_KICKSTART_TIME
-      static unsigned long fan_kick_end;
-      if (tail_fan_speed) {
-        if (fan_kick_end == 0) {
-          // Just starting up fan - run at full power.
-          fan_kick_end = millis() + FAN_KICKSTART_TIME;
-          tail_fan_speed = 255;
-        } else if (fan_kick_end > millis())
-          // Fan still spinning up.
-          tail_fan_speed = 255;
-      } else {
-        fan_kick_end = 0;
-      }
-    #endif//FAN_KICKSTART_TIME
-    analogWrite(FAN_PIN,tail_fan_speed);
+#if defined(FAN_PIN) && FAN_PIN > -1
+  #ifdef FAN_KICKSTART_TIME
+    static unsigned long fan_kick_end;
+    if (tail_fan_speed) {
+      if (fan_kick_end == 0) {
+        // Just starting up fan - run at full power.
+        fan_kick_end = millis() + FAN_KICKSTART_TIME;
+        tail_fan_speed = 255;
+      } else if (fan_kick_end > millis())
+        // Fan still spinning up.
+        tail_fan_speed = 255;
+    } else {
+      fan_kick_end = 0;
+    }
+  #endif//FAN_KICKSTART_TIME
+  #ifdef FAN_SOFT_PWM
+  fanSpeedSoftPwm = tail_fan_speed;
+  #else
+  analogWrite(FAN_PIN,tail_fan_speed);
   #endif//!FAN_SOFT_PWM
 #endif//FAN_PIN > -1
 #ifdef AUTOTEMP
   getHighESpeed();
 #endif
+
+#ifdef BARICUDA
+  #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1
+      analogWrite(HEATER_1_PIN,tail_valve_pressure);
+  #endif
+
+  #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1
+      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);
+  #endif
+#endif
 }
 
 
@@ -519,7 +539,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   #ifdef PREVENT_DANGEROUS_EXTRUDE
   if(target[E_AXIS]!=position[E_AXIS])
   {
-    if(degHotend(active_extruder)<EXTRUDE_MINTEMP && !allow_cold_extrude)
+    if(degHotend(active_extruder)<extrude_min_temp)
     {
       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
       SERIAL_ECHO_START;
@@ -544,8 +564,16 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   block->busy = false;
 
   // Number of steps for each axis
-  block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
-  block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
+#ifndef COREXY
+// default non-h-bot planning
+block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
+block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
+#else
+// corexy planning
+// these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
+block->steps_x = labs((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]));
+block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]));
+#endif
   block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
   block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
   block->steps_e *= extrudemultiply;
@@ -559,9 +587,14 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   }
 
   block->fan_speed = fanSpeed;
+  #ifdef BARICUDA
+  block->valve_pressure = ValvePressure;
+  block->e_to_p_pressure = EtoPPressure;
+  #endif
 
   // Compute direction bits for this block 
   block->direction_bits = 0;
+#ifndef COREXY
   if (target[X_AXIS] < position[X_AXIS])
   {
     block->direction_bits |= (1<<X_AXIS); 
@@ -570,6 +603,16 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   {
     block->direction_bits |= (1<<Y_AXIS); 
   }
+#else
+  if ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]) < 0)
+  {
+    block->direction_bits |= (1<<X_AXIS); 
+  }
+  if ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]) < 0)
+  {
+    block->direction_bits |= (1<<Y_AXIS); 
+  }
+#endif
   if (target[Z_AXIS] < position[Z_AXIS])
   {
     block->direction_bits |= (1<<Z_AXIS); 
@@ -614,8 +657,13 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   } 
 
   float delta_mm[4];
-  delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
-  delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
+  #ifndef COREXY
+    delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
+    delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
+  #else
+    delta_mm[X_AXIS] = ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[X_AXIS];
+    delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];
+  #endif
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
   if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
@@ -735,7 +783,7 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
       block->acceleration_st = axis_steps_per_sqr_second[Z_AXIS];
   }
   block->acceleration = block->acceleration_st / steps_per_mm;
-  block->acceleration_rate = (long)((float)block->acceleration_st * 8.388608);
+  block->acceleration_rate = (long)((float)block->acceleration_st * (16777216.0 / (F_CPU / 8.0)));
 
 #if 0  // Use old jerk for now
   // Compute path unit vector
@@ -896,12 +944,12 @@ uint8_t movesplanned()
   return (block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
 }
 
-void allow_cold_extrudes(bool allow)
-{
 #ifdef PREVENT_DANGEROUS_EXTRUDE
-  allow_cold_extrude=allow;
-#endif
+void set_extrude_min_temp(float temp)
+{
+  extrude_min_temp=temp;
 }
+#endif
 
 // Calculate the steps/s^2 acceleration rates, based on the mm/s^s
 void reset_acceleration_rates()
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 9a904e5..597eeb1 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -60,6 +60,10 @@ typedef struct {
   unsigned long final_rate;                          // The minimal rate at exit
   unsigned long acceleration_st;                     // acceleration steps/sec^2
   unsigned long fan_speed;
+  #ifdef BARICUDA
+  unsigned long valve_pressure;
+  unsigned long e_to_p_pressure;
+  #endif
   volatile char busy;
 } block_t;
 
@@ -135,7 +139,9 @@ FORCE_INLINE bool blocks_queued()
     return true;
 }
 
-void allow_cold_extrudes(bool allow);
+#ifdef PREVENT_DANGEROUS_EXTRUDE
+void set_extrude_min_temp(float temp);
+#endif
 
 void reset_acceleration_rates();
 #endif
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 3bc5e9c..2f1d912 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -29,7 +29,7 @@
 #include "language.h"
 #include "cardreader.h"
 #include "speed_lookuptable.h"
-#if DIGIPOTSS_PIN > -1
+#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
 #include <SPI.h>
 #endif
 
@@ -69,9 +69,9 @@ volatile long endstops_stepsTotal,endstops_stepsDone;
 static volatile bool endstop_x_hit=false;
 static volatile bool endstop_y_hit=false;
 static volatile bool endstop_z_hit=false;
-#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
-bool abort_on_endstop_hit = false;
-#endif
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+bool abort_on_endstop_hit = false;
+#endif
 
 static bool old_x_min_endstop=false;
 static bool old_x_max_endstop=false;
@@ -184,20 +184,20 @@ void checkHitEndstops()
      SERIAL_ECHOPAIR(" Z:",(float)endstops_trigsteps[Z_AXIS]/axis_steps_per_unit[Z_AXIS]);
      LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Z");
    }
-   SERIAL_ECHOLN("");
+   SERIAL_ECHOLN("");
    endstop_x_hit=false;
    endstop_y_hit=false;
-   endstop_z_hit=false;
-#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
-   if (abort_on_endstop_hit)
-   {
+   endstop_z_hit=false;
+#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+   if (abort_on_endstop_hit)
+   {
      card.sdprinting = false;
      card.closefile();
-     quickStop();
+     quickStop();
      setTargetHotend0(0);
      setTargetHotend1(0);
      setTargetHotend2(0);
-   }
+   }
 #endif
  }
 }
@@ -272,7 +272,7 @@ FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
     timer = (unsigned short)pgm_read_word_near(table_address);
     timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))>>3);
   }
-  if(timer < 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)
+  if(timer < 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TOO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)
   return timer;
 }
 
@@ -345,53 +345,89 @@ ISR(TIMER1_COMPA_vect)
     // Set directions TO DO This should be done once during init of trapezoid. Endstops -> interrupt
     out_bits = current_block->direction_bits;
 
-    // Set direction en check limit switches
-    if ((out_bits & (1<<X_AXIS)) != 0) {   // stepping along -X axis
-      #if !defined COREXY  //NOT COREXY
+
+    // Set the direction bits (X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY)
+    if((out_bits & (1<<X_AXIS))!=0){
+      #ifdef DUAL_X_CARRIAGE
+      if (active_extruder != 0)
+        WRITE(X2_DIR_PIN,INVERT_X_DIR);
+      else
+      #endif        
         WRITE(X_DIR_PIN, INVERT_X_DIR);
-      #endif
       count_direction[X_AXIS]=-1;
+    }
+    else{
+      #ifdef DUAL_X_CARRIAGE
+      if (active_extruder != 0)
+        WRITE(X2_DIR_PIN,!INVERT_X_DIR);
+      else
+      #endif        
+        WRITE(X_DIR_PIN, !INVERT_X_DIR);
+      count_direction[X_AXIS]=1;
+    }
+    if((out_bits & (1<<Y_AXIS))!=0){
+      WRITE(Y_DIR_PIN, INVERT_Y_DIR);
+      count_direction[Y_AXIS]=-1;
+    }
+    else{
+      WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
+      count_direction[Y_AXIS]=1;
+    }
+    
+    // Set direction en check limit switches
+    #ifndef COREXY
+    if ((out_bits & (1<<X_AXIS)) != 0) {   // stepping along -X axis
+    #else
+    if ((((out_bits & (1<<X_AXIS)) != 0)&&(out_bits & (1<<Y_AXIS)) != 0)) {   //-X occurs for -A and -B
+    #endif
       CHECK_ENDSTOPS
       {
-        #if X_MIN_PIN > -1
-          bool x_min_endstop=(READ(X_MIN_PIN) != X_ENDSTOPS_INVERTING);
-          if(x_min_endstop && old_x_min_endstop && (current_block->steps_x > 0)) {
-            endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
-            endstop_x_hit=true;
-            step_events_completed = current_block->step_event_count;
-          }
-          old_x_min_endstop = x_min_endstop;
-        #endif
+        #ifdef DUAL_X_CARRIAGE
+        // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
+        if ((active_extruder == 0 && X_HOME_DIR == -1) || (active_extruder != 0 && X2_HOME_DIR == -1))
+        #endif          
+        {
+          #if defined(X_MIN_PIN) && X_MIN_PIN > -1
+            bool x_min_endstop=(READ(X_MIN_PIN) != X_ENDSTOPS_INVERTING);
+            if(x_min_endstop && old_x_min_endstop && (current_block->steps_x > 0)) {
+              endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
+              endstop_x_hit=true;
+              step_events_completed = current_block->step_event_count;
+            }
+            old_x_min_endstop = x_min_endstop;
+          #endif
+        }
       }
     }
     else { // +direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(X_DIR_PIN,!INVERT_X_DIR);
-      #endif
-      
-      count_direction[X_AXIS]=1;
       CHECK_ENDSTOPS 
       {
-        #if X_MAX_PIN > -1
-          bool x_max_endstop=(READ(X_MAX_PIN) != X_ENDSTOPS_INVERTING);
-          if(x_max_endstop && old_x_max_endstop && (current_block->steps_x > 0)){
-            endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
-            endstop_x_hit=true;
-            step_events_completed = current_block->step_event_count;
-          }
-          old_x_max_endstop = x_max_endstop;
-        #endif
+        #ifdef DUAL_X_CARRIAGE
+        // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
+        if ((active_extruder == 0 && X_HOME_DIR == 1) || (active_extruder != 0 && X2_HOME_DIR == 1))
+        #endif          
+        {
+          #if defined(X_MAX_PIN) && X_MAX_PIN > -1
+            bool x_max_endstop=(READ(X_MAX_PIN) != X_ENDSTOPS_INVERTING);
+            if(x_max_endstop && old_x_max_endstop && (current_block->steps_x > 0)){
+              endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
+              endstop_x_hit=true;
+              step_events_completed = current_block->step_event_count;
+            }
+            old_x_max_endstop = x_max_endstop;
+          #endif
+        }  
       }
     }
 
+    #ifndef COREXY
     if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(Y_DIR_PIN,INVERT_Y_DIR);
-      #endif
-      count_direction[Y_AXIS]=-1;
+    #else
+    if ((((out_bits & (1<<X_AXIS)) != 0)&&(out_bits & (1<<Y_AXIS)) == 0)) {   // -Y occurs for -A and +B
+    #endif
       CHECK_ENDSTOPS
       {
-        #if Y_MIN_PIN > -1
+        #if defined(Y_MIN_PIN) && Y_MIN_PIN > -1
           bool y_min_endstop=(READ(Y_MIN_PIN) != Y_ENDSTOPS_INVERTING);
           if(y_min_endstop && old_y_min_endstop && (current_block->steps_y > 0)) {
             endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];
@@ -403,13 +439,9 @@ ISR(TIMER1_COMPA_vect)
       }
     }
     else { // +direction
-      #if !defined COREXY  //NOT COREXY
-        WRITE(Y_DIR_PIN,!INVERT_Y_DIR);
-      #endif
-      count_direction[Y_AXIS]=1;
       CHECK_ENDSTOPS
       {
-        #if Y_MAX_PIN > -1
+        #if defined(Y_MAX_PIN) && Y_MAX_PIN > -1
           bool y_max_endstop=(READ(Y_MAX_PIN) != Y_ENDSTOPS_INVERTING);
           if(y_max_endstop && old_y_max_endstop && (current_block->steps_y > 0)){
             endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];
@@ -420,28 +452,7 @@ ISR(TIMER1_COMPA_vect)
         #endif
       }
     }
-    
-    
-    #ifdef COREXY  //coreXY kinematics defined
-      if((current_block->steps_x >= current_block->steps_y)&&((out_bits & (1<<X_AXIS)) == 0)){  //+X is major axis
-        WRITE(X_DIR_PIN, !INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
-      }
-      if((current_block->steps_x >= current_block->steps_y)&&((out_bits & (1<<X_AXIS)) != 0)){  //-X is major axis
-        WRITE(X_DIR_PIN, INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, INVERT_Y_DIR);
-      }      
-      if((current_block->steps_y > current_block->steps_x)&&((out_bits & (1<<Y_AXIS)) == 0)){  //+Y is major axis
-        WRITE(X_DIR_PIN, !INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, INVERT_Y_DIR);
-      }        
-      if((current_block->steps_y > current_block->steps_x)&&((out_bits & (1<<Y_AXIS)) != 0)){  //-Y is major axis
-        WRITE(X_DIR_PIN, INVERT_X_DIR);
-        WRITE(Y_DIR_PIN, !INVERT_Y_DIR);
-      }  
-    #endif //coreXY
-    
-    
+
     if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
       WRITE(Z_DIR_PIN,INVERT_Z_DIR);
       
@@ -452,7 +463,7 @@ ISR(TIMER1_COMPA_vect)
       count_direction[Z_AXIS]=-1;
       CHECK_ENDSTOPS
       {
-        #if Z_MIN_PIN > -1
+        #if defined(Z_MIN_PIN) && Z_MIN_PIN > -1
           bool z_min_endstop=(READ(Z_MIN_PIN) != Z_ENDSTOPS_INVERTING);
           if(z_min_endstop && old_z_min_endstop && (current_block->steps_z > 0)) {
             endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
@@ -473,7 +484,7 @@ ISR(TIMER1_COMPA_vect)
       count_direction[Z_AXIS]=1;
       CHECK_ENDSTOPS
       {
-        #if Z_MAX_PIN > -1
+        #if defined(Z_MAX_PIN) && Z_MAX_PIN > -1
           bool z_max_endstop=(READ(Z_MAX_PIN) != Z_ENDSTOPS_INVERTING);
           if(z_max_endstop && old_z_max_endstop && (current_block->steps_z > 0)) {
             endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
@@ -516,13 +527,22 @@ ISR(TIMER1_COMPA_vect)
       }    
       #endif //ADVANCE
 
-      #if !defined COREXY      
         counter_x += current_block->steps_x;
         if (counter_x > 0) {
-          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
+          #ifdef DUAL_X_CARRIAGE
+          if (active_extruder != 0)
+            WRITE(X2_STEP_PIN,!INVERT_X_STEP_PIN);
+          else
+          #endif        
+            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
           counter_x -= current_block->step_event_count;
           count_position[X_AXIS]+=count_direction[X_AXIS];   
-          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
+          #ifdef DUAL_X_CARRIAGE
+          if (active_extruder != 0)
+            WRITE(X2_STEP_PIN,INVERT_X_STEP_PIN);
+          else
+          #endif        
+            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
         }
   
         counter_y += current_block->steps_y;
@@ -532,56 +552,7 @@ ISR(TIMER1_COMPA_vect)
           count_position[Y_AXIS]+=count_direction[Y_AXIS]; 
           WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
         }
-      #endif
   
-      #ifdef COREXY
-        counter_x += current_block->steps_x;        
-        counter_y += current_block->steps_y;
-        
-        if ((counter_x > 0)&&!(counter_y>0)){  //X step only
-          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-          counter_x -= current_block->step_event_count; 
-          count_position[X_AXIS]+=count_direction[X_AXIS];         
-          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-        }
-        
-        if (!(counter_x > 0)&&(counter_y>0)){  //Y step only
-          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-          counter_y -= current_block->step_event_count; 
-          count_position[Y_AXIS]+=count_direction[Y_AXIS];
-          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);
-          WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-        }        
-        
-        if ((counter_x > 0)&&(counter_y>0)){  //step in both axes
-          if (((out_bits & (1<<X_AXIS)) == 0)^((out_bits & (1<<Y_AXIS)) == 0)){  //X and Y in different directions
-            WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-            counter_x -= current_block->step_event_count;             
-            WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-            step_wait();
-            count_position[X_AXIS]+=count_direction[X_AXIS];
-            count_position[Y_AXIS]+=count_direction[Y_AXIS];
-            WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);
-            counter_y -= current_block->step_event_count;
-            WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);
-          }
-          else{  //X and Y in same direction
-            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);
-            counter_x -= current_block->step_event_count;             
-            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN) ;
-            step_wait();
-            count_position[X_AXIS]+=count_direction[X_AXIS];
-            count_position[Y_AXIS]+=count_direction[Y_AXIS];
-            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN); 
-            counter_y -= current_block->step_event_count;    
-            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);        
-          }
-        }
-      #endif //corexy
-      
       counter_z += current_block->steps_z;
       if (counter_z > 0) {
         WRITE(Z_STEP_PIN, !INVERT_Z_STEP_PIN);
@@ -743,20 +714,23 @@ void st_init()
   microstep_init(); //Initialize Microstepping Pins
   
   //Initialize Dir Pins
-  #if X_DIR_PIN > -1
+  #if defined(X_DIR_PIN) && X_DIR_PIN > -1
     SET_OUTPUT(X_DIR_PIN);
   #endif
-  #if Y_DIR_PIN > -1 
+  #if defined(X2_DIR_PIN) && X2_DIR_PIN > -1
+    SET_OUTPUT(X2_DIR_PIN);
+  #endif
+  #if defined(Y_DIR_PIN) && Y_DIR_PIN > -1 
     SET_OUTPUT(Y_DIR_PIN);
   #endif
-  #if Z_DIR_PIN > -1 
+  #if defined(Z_DIR_PIN) && Z_DIR_PIN > -1 
     SET_OUTPUT(Z_DIR_PIN);
 
-    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_DIR_PIN > -1)
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_DIR_PIN) && (Z2_DIR_PIN > -1)
       SET_OUTPUT(Z2_DIR_PIN);
     #endif
   #endif
-  #if E0_DIR_PIN > -1 
+  #if defined(E0_DIR_PIN) && E0_DIR_PIN > -1 
     SET_OUTPUT(E0_DIR_PIN);
   #endif
   #if defined(E1_DIR_PIN) && (E1_DIR_PIN > -1)
@@ -768,24 +742,28 @@ void st_init()
 
   //Initialize Enable Pins - steppers default to disabled.
 
-  #if (X_ENABLE_PIN > -1)
+  #if defined(X_ENABLE_PIN) && X_ENABLE_PIN > -1
     SET_OUTPUT(X_ENABLE_PIN);
     if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
   #endif
-  #if (Y_ENABLE_PIN > -1)
+  #if defined(X2_ENABLE_PIN) && X2_ENABLE_PIN > -1
+    SET_OUTPUT(X2_ENABLE_PIN);
+    if(!X_ENABLE_ON) WRITE(X2_ENABLE_PIN,HIGH);
+  #endif
+  #if defined(Y_ENABLE_PIN) && Y_ENABLE_PIN > -1
     SET_OUTPUT(Y_ENABLE_PIN);
     if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
   #endif
-  #if (Z_ENABLE_PIN > -1)
+  #if defined(Z_ENABLE_PIN) && Z_ENABLE_PIN > -1
     SET_OUTPUT(Z_ENABLE_PIN);
     if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
     
-    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_ENABLE_PIN > -1)
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_ENABLE_PIN) && (Z2_ENABLE_PIN > -1)
       SET_OUTPUT(Z2_ENABLE_PIN);
       if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);
     #endif
   #endif
-  #if (E0_ENABLE_PIN > -1)
+  #if defined(E0_ENABLE_PIN) && (E0_ENABLE_PIN > -1)
     SET_OUTPUT(E0_ENABLE_PIN);
     if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);
   #endif
@@ -800,42 +778,42 @@ void st_init()
 
   //endstops and pullups
   
-  #if X_MIN_PIN > -1
+  #if defined(X_MIN_PIN) && X_MIN_PIN > -1
     SET_INPUT(X_MIN_PIN); 
     #ifdef ENDSTOPPULLUP_XMIN
       WRITE(X_MIN_PIN,HIGH);
     #endif
   #endif
       
-  #if Y_MIN_PIN > -1
+  #if defined(Y_MIN_PIN) && Y_MIN_PIN > -1
     SET_INPUT(Y_MIN_PIN); 
     #ifdef ENDSTOPPULLUP_YMIN
       WRITE(Y_MIN_PIN,HIGH);
     #endif
   #endif
   
-  #if Z_MIN_PIN > -1
+  #if defined(Z_MIN_PIN) && Z_MIN_PIN > -1
     SET_INPUT(Z_MIN_PIN); 
     #ifdef ENDSTOPPULLUP_ZMIN
       WRITE(Z_MIN_PIN,HIGH);
     #endif
   #endif
       
-  #if X_MAX_PIN > -1
+  #if defined(X_MAX_PIN) && X_MAX_PIN > -1
     SET_INPUT(X_MAX_PIN); 
     #ifdef ENDSTOPPULLUP_XMAX
       WRITE(X_MAX_PIN,HIGH);
     #endif
   #endif
       
-  #if Y_MAX_PIN > -1
+  #if defined(Y_MAX_PIN) && Y_MAX_PIN > -1
     SET_INPUT(Y_MAX_PIN); 
     #ifdef ENDSTOPPULLUP_YMAX
       WRITE(Y_MAX_PIN,HIGH);
     #endif
   #endif
   
-  #if Z_MAX_PIN > -1
+  #if defined(Z_MAX_PIN) && Z_MAX_PIN > -1
     SET_INPUT(Z_MAX_PIN); 
     #ifdef ENDSTOPPULLUP_ZMAX
       WRITE(Z_MAX_PIN,HIGH);
@@ -844,26 +822,31 @@ void st_init()
  
 
   //Initialize Step Pins
-  #if (X_STEP_PIN > -1) 
+  #if defined(X_STEP_PIN) && (X_STEP_PIN > -1) 
     SET_OUTPUT(X_STEP_PIN);
     WRITE(X_STEP_PIN,INVERT_X_STEP_PIN);
     disable_x();
   #endif  
-  #if (Y_STEP_PIN > -1) 
+  #if defined(X2_STEP_PIN) && (X2_STEP_PIN > -1) 
+    SET_OUTPUT(X2_STEP_PIN);
+    WRITE(X2_STEP_PIN,INVERT_X_STEP_PIN);
+    disable_x();
+  #endif  
+  #if defined(Y_STEP_PIN) && (Y_STEP_PIN > -1) 
     SET_OUTPUT(Y_STEP_PIN);
     WRITE(Y_STEP_PIN,INVERT_Y_STEP_PIN);
     disable_y();
   #endif  
-  #if (Z_STEP_PIN > -1) 
+  #if defined(Z_STEP_PIN) && (Z_STEP_PIN > -1) 
     SET_OUTPUT(Z_STEP_PIN);
     WRITE(Z_STEP_PIN,INVERT_Z_STEP_PIN);
-    #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_STEP_PIN > -1)
+    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_STEP_PIN) && (Z2_STEP_PIN > -1)
       SET_OUTPUT(Z2_STEP_PIN);
       WRITE(Z2_STEP_PIN,INVERT_Z_STEP_PIN);
     #endif
     disable_z();
   #endif  
-  #if (E0_STEP_PIN > -1) 
+  #if defined(E0_STEP_PIN) && (E0_STEP_PIN > -1) 
     SET_OUTPUT(E0_STEP_PIN);
     WRITE(E0_STEP_PIN,INVERT_E_STEP_PIN);
     disable_e0();
@@ -879,10 +862,6 @@ void st_init()
     disable_e2();
   #endif  
 
-  #ifdef CONTROLLERFAN_PIN
-    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
-  #endif
-  
   // waveform generation = 0100 = CTC
   TCCR1B &= ~(1<<WGM13);
   TCCR1B |=  (1<<WGM12);
@@ -978,7 +957,7 @@ void quickStop()
 
 void digitalPotWrite(int address, int value) // From Arduino DigitalPotControl example
 {
-  #if DIGIPOTSS_PIN > -1
+  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
     digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip
     SPI.transfer(address); //  send in the address and value via SPI:
     SPI.transfer(value);
@@ -989,7 +968,7 @@ void digitalPotWrite(int address, int value) // From Arduino DigitalPotControl e
 
 void digipot_init() //Initialize Digipot Motor Current
 {
-  #if DIGIPOTSS_PIN > -1
+  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
     const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
     
     SPI.begin(); 
@@ -1002,7 +981,7 @@ void digipot_init() //Initialize Digipot Motor Current
 
 void digipot_current(uint8_t driver, int current)
 {
-  #if DIGIPOTSS_PIN > -1
+  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
     const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
     digitalPotWrite(digipot_ch[driver], current);
   #endif
@@ -1010,7 +989,7 @@ void digipot_current(uint8_t driver, int current)
 
 void microstep_init()
 {
-  #if X_MS1_PIN > -1
+  #if defined(X_MS1_PIN) && X_MS1_PIN > -1
   const uint8_t microstep_modes[] = MICROSTEP_MODES;
   pinMode(X_MS2_PIN,OUTPUT);
   pinMode(Y_MS2_PIN,OUTPUT);
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 8501775..f5df7a1 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -40,10 +40,13 @@
 int target_temperature[EXTRUDERS] = { 0 };
 int target_temperature_bed = 0;
 int current_temperature_raw[EXTRUDERS] = { 0 };
-float current_temperature[EXTRUDERS] = { 0 };
+float current_temperature[EXTRUDERS] = { 0.0 };
 int current_temperature_bed_raw = 0;
-float current_temperature_bed = 0;
-
+float current_temperature_bed = 0.0;
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  int redundant_temperature_raw = 0;
+  float redundant_temperature = 0.0;
+#endif
 #ifdef PIDTEMP
   float Kp=DEFAULT_Kp;
   float Ki=(DEFAULT_Ki*PID_dT);
@@ -59,6 +62,9 @@ float current_temperature_bed = 0;
   float bedKd=(DEFAULT_bedKd/PID_dT);
 #endif //PIDTEMPBED
   
+#ifdef FAN_SOFT_PWM
+  unsigned char fanSpeedSoftPwm;
+#endif
   
 //===========================================================================
 //=============================private variables============================
@@ -99,17 +105,20 @@ static volatile bool temp_meas_ready = false;
 #ifdef FAN_SOFT_PWM
   static unsigned char soft_pwm_fan;
 #endif
+#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
+    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
+    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
+  static unsigned long extruder_autofan_last_check;
+#endif  
 
-
-  
 #if EXTRUDERS > 3
-# error Unsupported number of extruders
+  # error Unsupported number of extruders
 #elif EXTRUDERS > 2
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
 #elif EXTRUDERS > 1
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
 #else
-# define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
+  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
 #endif
 
 // Init min and max temp with extreme values to prevent false errors during startup
@@ -121,8 +130,14 @@ static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
 #ifdef BED_MAXTEMP
 static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
 #endif
-static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
-static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };
+  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
+#else
+  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
+  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+#endif
 
 static float analog2temp(int raw, uint8_t e);
 static float analog2tempBed(int raw);
@@ -133,6 +148,10 @@ int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
 unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
 #endif //WATCH_TEMP_PERIOD
 
+#ifndef SOFT_PWM_SCALE
+#define SOFT_PWM_SCALE 0
+#endif
+
 //===========================================================================
 //=============================   functions      ============================
 //===========================================================================
@@ -154,28 +173,28 @@ void PID_autotune(float temp, int extruder, int ncycles)
   float Kp, Ki, Kd;
   float max = 0, min = 10000;
 
-	if ((extruder > EXTRUDERS)
+  if ((extruder > EXTRUDERS)
   #if (TEMP_BED_PIN <= -1)
-		||(extruder < 0)
-	#endif
-	){
-  	SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
-  	return;
-	}
+       ||(extruder < 0)
+  #endif
+       ){
+          SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
+          return;
+        }
 	
   SERIAL_ECHOLN("PID Autotune start");
   
   disable_heater(); // switch off all heaters.
 
-	if (extruder<0)
-	{
-	 	soft_pwm_bed = (MAX_BED_POWER)/2;
-		bias = d = (MAX_BED_POWER)/2;
-  }
-	else
-	{
-	  soft_pwm[extruder] = (PID_MAX)/2;
-		bias = d = (PID_MAX)/2;
+  if (extruder<0)
+  {
+     soft_pwm_bed = (MAX_BED_POWER)/2;
+     bias = d = (MAX_BED_POWER)/2;
+   }
+   else
+   {
+     soft_pwm[extruder] = (PID_MAX)/2;
+     bias = d = (PID_MAX)/2;
   }
 
 
@@ -193,10 +212,10 @@ void PID_autotune(float temp, int extruder, int ncycles)
       if(heating == true && input > temp) {
         if(millis() - t2 > 5000) { 
           heating=false;
-					if (extruder<0)
-						soft_pwm_bed = (bias - d) >> 1;
-					else
-						soft_pwm[extruder] = (bias - d) >> 1;
+          if (extruder<0)
+            soft_pwm_bed = (bias - d) >> 1;
+          else
+            soft_pwm[extruder] = (bias - d) >> 1;
           t1=millis();
           t_high=t1 - t2;
           max=temp;
@@ -247,28 +266,28 @@ void PID_autotune(float temp, int extruder, int ncycles)
               */
             }
           }
-					if (extruder<0)
-						soft_pwm_bed = (bias + d) >> 1;
-					else
-						soft_pwm[extruder] = (bias + d) >> 1;
+          if (extruder<0)
+            soft_pwm_bed = (bias + d) >> 1;
+          else
+            soft_pwm[extruder] = (bias + d) >> 1;
           cycles++;
           min=temp;
         }
       } 
     }
     if(input > (temp + 20)) {
-      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature to high");
+      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature too high");
       return;
     }
     if(millis() - temp_millis > 2000) {
-			int p;
-			if (extruder<0){
-	      p=soft_pwm_bed;       
-	      SERIAL_PROTOCOLPGM("ok B:");
-			}else{
-	      p=soft_pwm[extruder];       
-	      SERIAL_PROTOCOLPGM("ok T:");
-			}
+      int p;
+      if (extruder<0){
+        p=soft_pwm_bed;       
+        SERIAL_PROTOCOLPGM("ok B:");
+      }else{
+        p=soft_pwm[extruder];       
+        SERIAL_PROTOCOLPGM("ok T:");
+      }
 			
       SERIAL_PROTOCOL(input);   
       SERIAL_PROTOCOLPGM(" @:");
@@ -281,7 +300,7 @@ void PID_autotune(float temp, int extruder, int ncycles)
       return;
     }
     if(cycles > ncycles) {
-      SERIAL_PROTOCOLLNPGM("PID Autotune finished ! Place the Kp, Ki and Kd constants in the configuration.h");
+      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the Kp, Ki and Kd constants into Configuration.h");
       return;
     }
     lcd_update();
@@ -306,6 +325,78 @@ int getHeaterPower(int heater) {
   return soft_pwm[heater];
 }
 
+#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
+    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
+    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
+
+  #if defined(FAN_PIN) && FAN_PIN > -1
+    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN 
+       #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN"
+    #endif
+    #if EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN 
+       #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN"
+    #endif
+    #if EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN 
+       #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN"
+    #endif
+  #endif 
+
+void setExtruderAutoFanState(int pin, bool state)
+{
+  unsigned char newFanSpeed = (state != 0) ? EXTRUDER_AUTO_FAN_SPEED : 0;
+  // this idiom allows both digital and PWM fan outputs (see M42 handling).
+  pinMode(pin, OUTPUT);
+  digitalWrite(pin, newFanSpeed);
+  analogWrite(pin, newFanSpeed);
+}
+
+void checkExtruderAutoFans()
+{
+  uint8_t fanState = 0;
+
+  // which fan pins need to be turned on?      
+  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
+    if (current_temperature[0] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
+      fanState |= 1;
+  #endif
+  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
+    if (current_temperature[1] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
+    {
+      if (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
+        fanState |= 1;
+      else
+        fanState |= 2;
+    }
+  #endif
+  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
+    if (current_temperature[2] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
+    {
+      if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
+        fanState |= 1;
+      else if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) 
+        fanState |= 2;
+      else
+        fanState |= 4;
+    }
+  #endif
+  
+  // update extruder auto fan states
+  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
+    setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);
+  #endif 
+  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
+    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) 
+      setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);
+  #endif 
+  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
+    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN 
+        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)
+      setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);
+  #endif 
+}
+
+#endif // any extruder auto fan pins set
+
 void manage_heater()
 {
   float pid_input;
@@ -396,10 +487,31 @@ void manage_heater()
         }
     }
     #endif
-
+    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      if(fabs(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF) {
+        disable_heater();
+        if(IsStopped() == false) {
+          SERIAL_ERROR_START;
+          SERIAL_ERRORLNPGM("Extruder switched off. Temperature difference between temp sensors is too high !");
+          LCD_ALERTMESSAGEPGM("Err: REDUNDANT TEMP ERROR");
+        }
+        #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
+          Stop();
+        #endif
+      }
+    #endif
   } // End extruder for loop
-  
 
+  #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
+      (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
+      (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
+  if(millis() - extruder_autofan_last_check > 2500)  // only need to check fan state very infrequently
+  {
+    checkExtruderAutoFans();
+    extruder_autofan_last_check = millis();
+  }  
+  #endif       
+  
   #ifndef PIDTEMPBED
   if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
     return;
@@ -481,7 +593,11 @@ void manage_heater()
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
 static float analog2temp(int raw, uint8_t e) {
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  if(e > EXTRUDERS)
+#else
   if(e >= EXTRUDERS)
+#endif
   {
       SERIAL_ERROR_START;
       SERIAL_ERROR((int)e);
@@ -560,7 +676,9 @@ static void updateTemperaturesFromRawValues()
         current_temperature[e] = analog2temp(current_temperature_raw[e], e);
     }
     current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
-
+    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      redundant_temperature = analog2temp(redundant_temperature_raw, 1);
+    #endif
     //Reset the watchdog after we know we have a temperature measurement.
     watchdog_reset();
 
@@ -571,6 +689,12 @@ static void updateTemperaturesFromRawValues()
 
 void tp_init()
 {
+#if (MOTHERBOARD == 80) && ((TEMP_SENSOR_0==-1)||(TEMP_SENSOR_1==-1)||(TEMP_SENSOR_2==-1)||(TEMP_SENSOR_BED==-1))
+  //disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
+  MCUCR=(1<<JTD); 
+  MCUCR=(1<<JTD);
+#endif
+  
   // Finish init of mult extruder arrays 
   for(int e = 0; e < EXTRUDERS; e++) {
     // populate with the first value 
@@ -585,26 +709,26 @@ void tp_init()
 #endif //PIDTEMPBED
   }
 
-  #if (HEATER_0_PIN > -1) 
+  #if defined(HEATER_0_PIN) && (HEATER_0_PIN > -1) 
     SET_OUTPUT(HEATER_0_PIN);
   #endif  
-  #if (HEATER_1_PIN > -1) 
+  #if defined(HEATER_1_PIN) && (HEATER_1_PIN > -1) 
     SET_OUTPUT(HEATER_1_PIN);
   #endif  
-  #if (HEATER_2_PIN > -1) 
+  #if defined(HEATER_2_PIN) && (HEATER_2_PIN > -1) 
     SET_OUTPUT(HEATER_2_PIN);
   #endif  
-  #if (HEATER_BED_PIN > -1) 
+  #if defined(HEATER_BED_PIN) && (HEATER_BED_PIN > -1) 
     SET_OUTPUT(HEATER_BED_PIN);
   #endif  
-  #if (FAN_PIN > -1) 
+  #if defined(FAN_PIN) && (FAN_PIN > -1) 
     SET_OUTPUT(FAN_PIN);
     #ifdef FAST_PWM_FAN
     setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
     #ifdef FAN_SOFT_PWM
-	soft_pwm_fan=(unsigned char)fanSpeed;
-	#endif
+    soft_pwm_fan = fanSpeedSoftPwm / 2;
+    #endif
   #endif  
 
   #ifdef HEATER_0_USES_MAX6675
@@ -629,28 +753,28 @@ void tp_init()
   #ifdef DIDR2
     DIDR2 = 0;
   #endif
-  #if (TEMP_0_PIN > -1)
+  #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
     #if TEMP_0_PIN < 8
        DIDR0 |= 1 << TEMP_0_PIN; 
     #else
        DIDR2 |= 1<<(TEMP_0_PIN - 8); 
     #endif
   #endif
-  #if (TEMP_1_PIN > -1)
+  #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
     #if TEMP_1_PIN < 8
        DIDR0 |= 1<<TEMP_1_PIN; 
     #else
        DIDR2 |= 1<<(TEMP_1_PIN - 8); 
     #endif
   #endif
-  #if (TEMP_2_PIN > -1)
+  #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
     #if TEMP_2_PIN < 8
        DIDR0 |= 1 << TEMP_2_PIN; 
     #else
-       DIDR2 = 1<<(TEMP_2_PIN - 8); 
+       DIDR2 |= 1<<(TEMP_2_PIN - 8); 
     #endif
   #endif
-  #if (TEMP_BED_PIN > -1)
+  #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
     #if TEMP_BED_PIN < 8
        DIDR0 |= 1<<TEMP_BED_PIN; 
     #else
@@ -689,7 +813,7 @@ void tp_init()
 
 #if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
   minttemp[1] = HEATER_1_MINTEMP;
-  while(analog2temp(minttemp_raw[1], 1) > HEATER_1_MINTEMP) {
+  while(analog2temp(minttemp_raw[1], 1) < HEATER_1_MINTEMP) {
 #if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
     minttemp_raw[1] += OVERSAMPLENR;
 #else
@@ -710,7 +834,7 @@ void tp_init()
 
 #if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
   minttemp[2] = HEATER_2_MINTEMP;
-  while(analog2temp(minttemp_raw[2], 2) > HEATER_2_MINTEMP) {
+  while(analog2temp(minttemp_raw[2], 2) < HEATER_2_MINTEMP) {
 #if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
     minttemp_raw[2] += OVERSAMPLENR;
 #else
@@ -771,34 +895,34 @@ void disable_heater()
   for(int i=0;i<EXTRUDERS;i++)
     setTargetHotend(0,i);
   setTargetBed(0);
-  #if TEMP_0_PIN > -1
+  #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
   target_temperature[0]=0;
   soft_pwm[0]=0;
-   #if HEATER_0_PIN > -1  
+   #if defined(HEATER_0_PIN) && HEATER_0_PIN > -1  
      WRITE(HEATER_0_PIN,LOW);
    #endif
   #endif
      
-  #if TEMP_1_PIN > -1
+  #if defined(TEMP_1_PIN) && TEMP_1_PIN > -1
     target_temperature[1]=0;
     soft_pwm[1]=0;
-    #if HEATER_1_PIN > -1 
+    #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1 
       WRITE(HEATER_1_PIN,LOW);
     #endif
   #endif
       
-  #if TEMP_2_PIN > -1
+  #if defined(TEMP_2_PIN) && TEMP_2_PIN > -1
     target_temperature[2]=0;
     soft_pwm[2]=0;
-    #if HEATER_2_PIN > -1  
+    #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1  
       WRITE(HEATER_2_PIN,LOW);
     #endif
   #endif 
 
-  #if TEMP_BED_PIN > -1
+  #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
     target_temperature_bed=0;
     soft_pwm_bed=0;
-    #if HEATER_BED_PIN > -1  
+    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1  
       WRITE(HEATER_BED_PIN,LOW);
     #endif
   #endif 
@@ -904,14 +1028,14 @@ int read_max6675()
 // Timer 0 is shared with millies
 ISR(TIMER0_COMPB_vect)
 {
-  //these variables are only accesible from the ISR, but static, so they don't loose their value
+  //these variables are only accesible from the ISR, but static, so they don't lose their value
   static unsigned char temp_count = 0;
   static unsigned long raw_temp_0_value = 0;
   static unsigned long raw_temp_1_value = 0;
   static unsigned long raw_temp_2_value = 0;
   static unsigned long raw_temp_bed_value = 0;
   static unsigned char temp_state = 0;
-  static unsigned char pwm_count = 1;
+  static unsigned char pwm_count = (1 << SOFT_PWM_SCALE);
   static unsigned char soft_pwm_0;
   #if EXTRUDERS > 1
   static unsigned char soft_pwm_1;
@@ -934,12 +1058,12 @@ ISR(TIMER0_COMPB_vect)
     soft_pwm_2 = soft_pwm[2];
     if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1);
     #endif
-    #if HEATER_BED_PIN > -1
+    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
     soft_pwm_b = soft_pwm_bed;
     if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1);
     #endif
     #ifdef FAN_SOFT_PWM
-    soft_pwm_fan =(unsigned char) fanSpeed;
+    soft_pwm_fan = fanSpeedSoftPwm / 2;
     if(soft_pwm_fan > 0) WRITE(FAN_PIN,1);
     #endif
   }
@@ -950,19 +1074,19 @@ ISR(TIMER0_COMPB_vect)
   #if EXTRUDERS > 2
   if(soft_pwm_2 <= pwm_count) WRITE(HEATER_2_PIN,0);
   #endif
-  #if HEATER_BED_PIN > -1
+  #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
   if(soft_pwm_b <= pwm_count) WRITE(HEATER_BED_PIN,0);
   #endif
   #ifdef FAN_SOFT_PWM
   if(soft_pwm_fan <= pwm_count) WRITE(FAN_PIN,0);
   #endif
   
-  pwm_count++;
+  pwm_count += (1 << SOFT_PWM_SCALE);
   pwm_count &= 0x7f;
   
   switch(temp_state) {
     case 0: // Prepare TEMP_0
-      #if (TEMP_0_PIN > -1)
+      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
         #if TEMP_0_PIN > 7
           ADCSRB = 1<<MUX5;
         #else
@@ -975,7 +1099,7 @@ ISR(TIMER0_COMPB_vect)
       temp_state = 1;
       break;
     case 1: // Measure TEMP_0
-      #if (TEMP_0_PIN > -1)
+      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
         raw_temp_0_value += ADC;
       #endif
       #ifdef HEATER_0_USES_MAX6675 // TODO remove the blocking
@@ -984,7 +1108,7 @@ ISR(TIMER0_COMPB_vect)
       temp_state = 2;
       break;
     case 2: // Prepare TEMP_BED
-      #if (TEMP_BED_PIN > -1)
+      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
         #if TEMP_BED_PIN > 7
           ADCSRB = 1<<MUX5;
         #else
@@ -997,13 +1121,13 @@ ISR(TIMER0_COMPB_vect)
       temp_state = 3;
       break;
     case 3: // Measure TEMP_BED
-      #if (TEMP_BED_PIN > -1)
+      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
         raw_temp_bed_value += ADC;
       #endif
       temp_state = 4;
       break;
     case 4: // Prepare TEMP_1
-      #if (TEMP_1_PIN > -1)
+      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
         #if TEMP_1_PIN > 7
           ADCSRB = 1<<MUX5;
         #else
@@ -1016,13 +1140,13 @@ ISR(TIMER0_COMPB_vect)
       temp_state = 5;
       break;
     case 5: // Measure TEMP_1
-      #if (TEMP_1_PIN > -1)
+      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
         raw_temp_1_value += ADC;
       #endif
       temp_state = 6;
       break;
     case 6: // Prepare TEMP_2
-      #if (TEMP_2_PIN > -1)
+      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
         #if TEMP_2_PIN > 7
           ADCSRB = 1<<MUX5;
         #else
@@ -1035,7 +1159,7 @@ ISR(TIMER0_COMPB_vect)
       temp_state = 7;
       break;
     case 7: // Measure TEMP_2
-      #if (TEMP_2_PIN > -1)
+      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
         raw_temp_2_value += ADC;
       #endif
       temp_state = 0;
@@ -1055,6 +1179,9 @@ ISR(TIMER0_COMPB_vect)
 #if EXTRUDERS > 1
       current_temperature_raw[1] = raw_temp_1_value;
 #endif
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+      redundant_temperature_raw = raw_temp_1_value;
+#endif
 #if EXTRUDERS > 2
       current_temperature_raw[2] = raw_temp_2_value;
 #endif
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 7cc62aa..75ffcd0 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -37,6 +37,9 @@ extern int target_temperature[EXTRUDERS];
 extern float current_temperature[EXTRUDERS];
 extern int target_temperature_bed;
 extern float current_temperature_bed;
+#ifdef TEMP_SENSOR_1_AS_REDUNDANT
+  extern float redundant_temperature;
+#endif
 
 #ifdef PIDTEMP
   extern float Kp,Ki,Kd,Kc;
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index fe0619f..f6fc82d 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -8,6 +8,8 @@
 #include "stepper.h"
 #include "ConfigurationStore.h"
 
+int8_t encoderDiff; /* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */
+
 /* Configuration settings */
 int plaPreheatHotendTemp;
 int plaPreheatHPBTemp;
@@ -38,6 +40,7 @@ void copy_and_scalePID_d();
 /* Different menus */
 static void lcd_status_screen();
 #ifdef ULTIPANEL
+extern bool powersupply;
 static void lcd_main_menu();
 static void lcd_tune_menu();
 static void lcd_prepare_menu();
@@ -47,6 +50,9 @@ static void lcd_control_temperature_menu();
 static void lcd_control_temperature_preheat_pla_settings_menu();
 static void lcd_control_temperature_preheat_abs_settings_menu();
 static void lcd_control_motion_menu();
+#ifdef DOGLCD
+static void lcd_set_contrast();
+#endif
 static void lcd_control_retract_menu();
 static void lcd_sdcard_menu();
 
@@ -76,7 +82,14 @@ static void menu_action_setting_edit_callback_float51(const char* pstr, float* p
 static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
 static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, menuFunc_t callbackFunc);
 
-#define ENCODER_STEPS_PER_MENU_ITEM 5
+#define ENCODER_FEEDRATE_DEADZONE 10
+
+#if !defined(LCD_I2C_VIKI)
+  #define ENCODER_STEPS_PER_MENU_ITEM 5
+#else
+  #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation
+#endif
+
 
 /* Helper macros for menus */
 #define START_MENU() do { \
@@ -112,14 +125,16 @@ static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned l
     } } while(0)
 
 /** Used variables to keep track of the menu */
+#ifndef REPRAPWORLD_KEYPAD
 volatile uint8_t buttons;//Contains the bits of the currently pressed buttons.
-
+#else
+volatile uint8_t buttons_reprapworld_keypad; // to store the reprapworld_keypad shiftregister values
+#endif
 uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */
 uint32_t blocking_enc;
 uint8_t lastEncoderBits;
-int8_t encoderDiff; /* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */
 uint32_t encoderPosition;
-#if (SDCARDDETECT > -1)
+#if (SDCARDDETECT > 0)
 bool lcd_oldcardstatus;
 #endif
 #endif//ULTIPANEL
@@ -157,10 +172,34 @@ static void lcd_status_screen()
     if (LCD_CLICKED)
     {
         currentMenu = lcd_main_menu;
+        encoderPosition = 0;
         lcd_quick_feedback();
     }
-    feedmultiply += int(encoderPosition);
-    encoderPosition = 0;
+
+    // Dead zone at 100% feedrate
+    if ((feedmultiply < 100 && (feedmultiply + int(encoderPosition)) > 100) ||
+            (feedmultiply > 100 && (feedmultiply + int(encoderPosition)) < 100))
+    {
+        encoderPosition = 0;
+        feedmultiply = 100;
+    }
+
+    if (feedmultiply == 100 && int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
+    {
+        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
+        encoderPosition = 0;
+    }
+    else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
+    {
+        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
+        encoderPosition = 0;	
+    }
+    else if (feedmultiply != 100)
+    {
+        feedmultiply += int(encoderPosition);
+        encoderPosition = 0;
+    }
+
     if (feedmultiply < 10)
         feedmultiply = 10;
     if (feedmultiply > 999)
@@ -221,14 +260,14 @@ static void lcd_main_menu()
         }else{
             MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
 #if SDCARDDETECT < 1
-			MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));	// SD-card changed by user
-#endif			
+            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+#endif
         }
     }else{
         MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
-#if SDCARDDETECT < 1		
-		MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21"));	// Manually initialize the SD-card via user interface
-#endif		
+#if SDCARDDETECT < 1
+        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
+#endif
     }
 #endif
     END_MENU();
@@ -251,6 +290,7 @@ void lcd_preheat_pla()
     setTargetBed(plaPreheatHPBTemp);
     fanSpeed = plaPreheatFanSpeed;
     lcd_return_to_status();
+    setWatch(); // heater sanity check timer
 }
 
 void lcd_preheat_abs()
@@ -261,6 +301,16 @@ void lcd_preheat_abs()
     setTargetBed(absPreheatHPBTemp);
     fanSpeed = absPreheatFanSpeed;
     lcd_return_to_status();
+    setWatch(); // heater sanity check timer
+}
+
+static void lcd_cooldown()
+{
+    setTargetHotend0(0);
+    setTargetHotend1(0);
+    setTargetHotend2(0);
+    setTargetBed(0);
+    lcd_return_to_status();
 }
 
 static void lcd_tune_menu()
@@ -298,7 +348,15 @@ static void lcd_prepare_menu()
     //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
     MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla);
     MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs);
-    MENU_ITEM(gcode, MSG_COOLDOWN, PSTR("M104 S0\nM140 S0"));
+    MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+#if PS_ON_PIN > -1
+    if (powersupply)
+    {
+        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
+    }else{
+        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+    }
+#endif
     MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
     END_MENU();
 }
@@ -311,9 +369,9 @@ static void lcd_move_x()
     if (encoderPosition != 0)
     {
         current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (current_position[X_AXIS] < X_MIN_POS)
+        if (min_software_endstops && current_position[X_AXIS] < X_MIN_POS)
             current_position[X_AXIS] = X_MIN_POS;
-        if (current_position[X_AXIS] > X_MAX_POS)
+        if (max_software_endstops && current_position[X_AXIS] > X_MAX_POS)
             current_position[X_AXIS] = X_MAX_POS;
         encoderPosition = 0;
         plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
@@ -335,9 +393,9 @@ static void lcd_move_y()
     if (encoderPosition != 0)
     {
         current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (current_position[Y_AXIS] < Y_MIN_POS)
+        if (min_software_endstops && current_position[Y_AXIS] < Y_MIN_POS)
             current_position[Y_AXIS] = Y_MIN_POS;
-        if (current_position[Y_AXIS] > Y_MAX_POS)
+        if (max_software_endstops && current_position[Y_AXIS] > Y_MAX_POS)
             current_position[Y_AXIS] = Y_MAX_POS;
         encoderPosition = 0;
         plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
@@ -359,12 +417,12 @@ static void lcd_move_z()
     if (encoderPosition != 0)
     {
         current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (current_position[Z_AXIS] < Z_MIN_POS)
+        if (min_software_endstops && current_position[Z_AXIS] < Z_MIN_POS)
             current_position[Z_AXIS] = Z_MIN_POS;
-        if (current_position[Z_AXIS] > Z_MAX_POS)
+        if (max_software_endstops && current_position[Z_AXIS] > Z_MAX_POS)
             current_position[Z_AXIS] = Z_MAX_POS;
         encoderPosition = 0;
-        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 60, active_extruder);
+        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);
         lcdDrawUpdate = 1;
     }
     if (lcdDrawUpdate)
@@ -446,6 +504,10 @@ static void lcd_control_menu()
     MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
+#ifdef DOGLCD
+//    MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
+    MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);
+#endif
 #ifdef FWRETRACT
     MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
 #endif
@@ -459,10 +521,12 @@ static void lcd_control_menu()
 
 static void lcd_control_temperature_menu()
 {
-	// set up temp variables - undo the default scaling
-	raw_Ki = unscalePID_i(Ki);
-	raw_Kd = unscalePID_d(Kd);
-	
+#ifdef PIDTEMP
+    // set up temp variables - undo the default scaling
+    raw_Ki = unscalePID_i(Ki);
+    raw_Kd = unscalePID_d(Kd);
+#endif
+
     START_MENU();
     MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
@@ -484,7 +548,7 @@ static void lcd_control_temperature_menu()
 #endif
 #ifdef PIDTEMP
     MENU_ITEM_EDIT(float52, MSG_PID_P, &Kp, 1, 9990);
-	// i is typically a small value so allows values below 1
+    // i is typically a small value so allows values below 1
     MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
     MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d);
 # ifdef PID_ADD_EXTRUSION_RATE
@@ -555,6 +619,31 @@ static void lcd_control_motion_menu()
     END_MENU();
 }
 
+#ifdef DOGLCD
+static void lcd_set_contrast()
+{
+    if (encoderPosition != 0)
+    {
+        lcd_contrast -= encoderPosition;
+        if (lcd_contrast < 0) lcd_contrast = 0;
+        else if (lcd_contrast > 63) lcd_contrast = 63;
+        encoderPosition = 0;
+        lcdDrawUpdate = 1;
+        u8g.setContrast(lcd_contrast);
+    }
+    if (lcdDrawUpdate)
+    {
+        lcd_implementation_drawedit(PSTR("Contrast"), itostr2(lcd_contrast));
+    }
+    if (LCD_CLICKED)
+    {
+        lcd_quick_feedback();
+        currentMenu = lcd_control_menu;
+        encoderPosition = 0;
+    }
+}
+#endif
+
 #ifdef FWRETRACT
 static void lcd_control_retract_menu()
 {
@@ -687,6 +776,42 @@ menu_edit_type(float, float51, ftostr51, 10)
 menu_edit_type(float, float52, ftostr52, 100)
 menu_edit_type(unsigned long, long5, ftostr5, 0.01)
 
+#ifdef REPRAPWORLD_KEYPAD
+	static void reprapworld_keypad_move_z_up() {
+    encoderPosition = 1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+		lcd_move_z();
+  }
+	static void reprapworld_keypad_move_z_down() {
+    encoderPosition = -1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+		lcd_move_z();
+  }
+	static void reprapworld_keypad_move_x_left() {
+    encoderPosition = -1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+		lcd_move_x();
+  }
+	static void reprapworld_keypad_move_x_right() {
+    encoderPosition = 1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+		lcd_move_x();
+	}
+	static void reprapworld_keypad_move_y_down() {
+    encoderPosition = 1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+		lcd_move_y();
+	}
+	static void reprapworld_keypad_move_y_up() {
+		encoderPosition = -1;
+		move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+    lcd_move_y();
+	}
+	static void reprapworld_keypad_move_home() {
+		enquecommand_P((PSTR("G28"))); // move all axis home
+	}
+#endif
+
 /** End of menus **/
 
 static void lcd_quick_feedback()
@@ -745,11 +870,20 @@ void lcd_init()
 #ifdef NEWPANEL
     pinMode(BTN_EN1,INPUT);
     pinMode(BTN_EN2,INPUT); 
-    pinMode(BTN_ENC,INPUT); 
     pinMode(SDCARDDETECT,INPUT);
     WRITE(BTN_EN1,HIGH);
     WRITE(BTN_EN2,HIGH);
+  #if BTN_ENC > 0
+    pinMode(BTN_ENC,INPUT); 
     WRITE(BTN_ENC,HIGH);
+  #endif    
+  #ifdef REPRAPWORLD_KEYPAD
+    pinMode(SHIFT_CLK,OUTPUT);
+    pinMode(SHIFT_LD,OUTPUT);
+    pinMode(SHIFT_OUT,INPUT);
+    WRITE(SHIFT_OUT,HIGH);
+    WRITE(SHIFT_LD,HIGH);
+  #endif
 #else
     pinMode(SHIFT_CLK,OUTPUT);
     pinMode(SHIFT_LD,OUTPUT);
@@ -759,12 +893,14 @@ void lcd_init()
     WRITE(SHIFT_LD,HIGH); 
     WRITE(SHIFT_EN,LOW);
 #endif//!NEWPANEL
-#if (SDCARDDETECT > -1)
+#if (SDCARDDETECT > 0)
     WRITE(SDCARDDETECT, HIGH);
     lcd_oldcardstatus = IS_SD_INSERTED;
-#endif//(SDCARDDETECT > -1)
+#endif//(SDCARDDETECT > 0)
     lcd_buttons_update();
+#ifdef ULTIPANEL    
     encoderDiff = 0;
+#endif    
 }
 
 void lcd_update()
@@ -773,7 +909,11 @@ void lcd_update()
     
     lcd_buttons_update();
     
-    #if (SDCARDDETECT > -1)
+    #ifdef LCD_HAS_SLOW_BUTTONS
+    buttons |= lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
+    #endif
+    
+    #if (SDCARDDETECT > 0)
     if((IS_SD_INSERTED != lcd_oldcardstatus))
     {
         lcdDrawUpdate = 2;
@@ -796,6 +936,29 @@ void lcd_update()
     if (lcd_next_update_millis < millis())
     {
 #ifdef ULTIPANEL
+		#ifdef REPRAPWORLD_KEYPAD
+        	if (REPRAPWORLD_KEYPAD_MOVE_Z_UP) {
+        		reprapworld_keypad_move_z_up();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN) {
+        		reprapworld_keypad_move_z_down();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT) {
+        		reprapworld_keypad_move_x_left();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT) {
+        		reprapworld_keypad_move_x_right();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN) {
+        		reprapworld_keypad_move_y_down();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_Y_UP) {
+        		reprapworld_keypad_move_y_up();
+        	}
+        	if (REPRAPWORLD_KEYPAD_MOVE_HOME) {
+        		reprapworld_keypad_move_home();
+        	}
+		#endif
         if (encoderDiff)
         {
             lcdDrawUpdate = 1;
@@ -808,21 +971,26 @@ void lcd_update()
 #endif//ULTIPANEL
 
 #ifdef DOGLCD        // Changes due to different driver architecture of the DOGM display
-		blink++;	   // Variable for fan animation and alive dot
-		u8g.firstPage();
-		do {
-				u8g.setFont(u8g_font_6x10_marlin);
-				u8g.setPrintPos(125,0);
-				if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot
-				u8g.drawPixel(127,63);	// draw alive dot
-				u8g.setColorIndex(1);	// black on white
-				(*currentMenu)();
-				if (!lcdDrawUpdate)  break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()
-		   } while( u8g.nextPage() );
+        blink++;     // Variable for fan animation and alive dot
+        u8g.firstPage();
+        do 
+        {
+            u8g.setFont(u8g_font_6x10_marlin);
+            u8g.setPrintPos(125,0);
+            if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot
+            u8g.drawPixel(127,63); // draw alive dot
+            u8g.setColorIndex(1); // black on white
+            (*currentMenu)();
+            if (!lcdDrawUpdate)  break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()
+        } while( u8g.nextPage() );
 #else        
         (*currentMenu)();
 #endif
 
+#ifdef LCD_HAS_STATUS_INDICATORS
+        lcd_implementation_update_indicators();
+#endif
+
 #ifdef ULTIPANEL
         if(timeoutToStatus < millis() && currentMenu != lcd_status_screen)
         {
@@ -865,6 +1033,14 @@ void lcd_reset_alert_level()
     lcd_status_message_level = 0;
 }
 
+#ifdef DOGLCD
+void lcd_setcontrast(uint8_t value)
+{
+    lcd_contrast = value & 63;
+    u8g.setContrast(lcd_contrast);	
+}
+#endif
+
 #ifdef ULTIPANEL
 /* Warning: This function is called from interrupt context */
 void lcd_buttons_update()
@@ -873,9 +1049,25 @@ void lcd_buttons_update()
     uint8_t newbutton=0;
     if(READ(BTN_EN1)==0)  newbutton|=EN_A;
     if(READ(BTN_EN2)==0)  newbutton|=EN_B;
+  #if BTN_ENC > 0
     if((blocking_enc<millis()) && (READ(BTN_ENC)==0))
         newbutton |= EN_C;
+  #endif
     buttons = newbutton;
+    #ifdef REPRAPWORLD_KEYPAD
+      // for the reprapworld_keypad
+      uint8_t newbutton_reprapworld_keypad=0;
+      WRITE(SHIFT_LD,LOW);
+      WRITE(SHIFT_LD,HIGH);
+      for(int8_t i=0;i<8;i++) {
+          newbutton_reprapworld_keypad = newbutton_reprapworld_keypad>>1;
+          if(READ(SHIFT_OUT))
+              newbutton_reprapworld_keypad|=(1<<7);
+          WRITE(SHIFT_CLK,HIGH);
+          WRITE(SHIFT_CLK,LOW);
+      }
+      buttons_reprapworld_keypad=~newbutton_reprapworld_keypad; //invert it, because a pressed switch produces a logical 0
+	#endif
 #else   //read it from the shift register
     uint8_t newbutton=0;
     WRITE(SHIFT_LD,LOW);
@@ -930,6 +1122,18 @@ void lcd_buttons_update()
     }
     lastEncoderBits = enc;
 }
+
+void lcd_buzz(long duration, uint16_t freq)
+{ 
+#ifdef LCD_USE_I2C_BUZZER
+  lcd.buzz(duration,freq);
+#endif   
+}
+
+bool lcd_clicked() 
+{ 
+  return LCD_CLICKED;
+}
 #endif//ULTIPANEL
 
 /********************************/
@@ -1129,16 +1333,20 @@ char *ftostr52(const float &x)
 // grab the pid i value out of the temp variable; scale it; then update the PID driver
 void copy_and_scalePID_i()
 {
+#ifdef PIDTEMP
   Ki = scalePID_i(raw_Ki);
   updatePID();
-}	
+#endif
+}
 
 // Callback for after editing PID d value
 // grab the pid d value out of the temp variable; scale it; then update the PID driver
 void copy_and_scalePID_d()
 {
+#ifdef PIDTEMP
   Kd = scalePID_d(raw_Kd);
   updatePID();
-}	
-	
+#endif
+}
+
 #endif //ULTRA_LCD
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 28de229..d6fa0fd 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -11,7 +11,12 @@
   void lcd_setstatuspgm(const char* message);
   void lcd_setalertstatuspgm(const char* message);
   void lcd_reset_alert_level();
-  
+
+#ifdef DOGLCD
+  extern int lcd_contrast;
+  void lcd_setcontrast(uint8_t value);
+#endif
+
   static unsigned char blink = 0;	// Variable for visualisation of fan rotation in GLCD
 
   #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))
@@ -23,6 +28,9 @@
   #ifdef ULTIPANEL
   void lcd_buttons_update();
   extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
+  #ifdef REPRAPWORLD_KEYPAD
+    extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shiftregister values
+  #endif
   #else
   FORCE_INLINE void lcd_buttons_update() {}
   #endif
@@ -35,12 +43,34 @@
   extern int absPreheatHPBTemp;
   extern int absPreheatFanSpeed;
     
+  void lcd_buzz(long duration,uint16_t freq);
+  bool lcd_clicked();
+
   #ifdef NEWPANEL
     #define EN_C (1<<BLEN_C)
     #define EN_B (1<<BLEN_B)
     #define EN_A (1<<BLEN_A)
 
     #define LCD_CLICKED (buttons&EN_C)
+    #ifdef REPRAPWORLD_KEYPAD
+  	  #define EN_REPRAPWORLD_KEYPAD_F3 (1<<BLEN_REPRAPWORLD_KEYPAD_F3)
+  	  #define EN_REPRAPWORLD_KEYPAD_F2 (1<<BLEN_REPRAPWORLD_KEYPAD_F2)
+  	  #define EN_REPRAPWORLD_KEYPAD_F1 (1<<BLEN_REPRAPWORLD_KEYPAD_F1)
+  	  #define EN_REPRAPWORLD_KEYPAD_UP (1<<BLEN_REPRAPWORLD_KEYPAD_UP)
+  	  #define EN_REPRAPWORLD_KEYPAD_RIGHT (1<<BLEN_REPRAPWORLD_KEYPAD_RIGHT)
+  	  #define EN_REPRAPWORLD_KEYPAD_MIDDLE (1<<BLEN_REPRAPWORLD_KEYPAD_MIDDLE)
+  	  #define EN_REPRAPWORLD_KEYPAD_DOWN (1<<BLEN_REPRAPWORLD_KEYPAD_DOWN)
+  	  #define EN_REPRAPWORLD_KEYPAD_LEFT (1<<BLEN_REPRAPWORLD_KEYPAD_LEFT)
+
+  	  #define LCD_CLICKED ((buttons&EN_C) || (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F1))
+  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F2)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F3)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_LEFT)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_RIGHT)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_DOWN)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_UP)
+  	  #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_MIDDLE)
+    #endif //REPRAPWORLD_KEYPAD
   #else
     //atomatic, do not change
     #define B_LE (1<<BL_LE)
@@ -61,6 +91,7 @@
   FORCE_INLINE void lcd_setstatus(const char* message) {}
   FORCE_INLINE void lcd_buttons_update() {}
   FORCE_INLINE void lcd_reset_alert_level() {}
+  FORCE_INLINE void lcd_buzz(long duration,uint16_t freq) {}
 
   #define LCD_MESSAGEPGM(x) 
   #define LCD_ALERTMESSAGEPGM(x) 
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 88dea49..9be57a9 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -6,12 +6,196 @@
 * When selecting the rusian language, a slightly different LCD implementation is used to handle UTF8 characters.
 **/
 
-#if LANGUAGE_CHOICE == 6
-#include "LiquidCrystalRus.h"
-#define LCD_CLASS LiquidCrystalRus
+#ifndef REPRAPWORLD_KEYPAD
+extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
 #else
-#include <LiquidCrystal.h>
-#define LCD_CLASS LiquidCrystal
+extern volatile uint16_t buttons;  //an extended version of the last checked buttons in a bit array.
+#endif
+
+////////////////////////////////////
+// Setup button and encode mappings for each panel (into 'buttons' variable
+//
+// This is just to map common functions (across different panels) onto the same 
+// macro name. The mapping is independent of whether the button is directly connected or 
+// via a shift/i2c register.
+
+#ifdef ULTIPANEL
+// All Ultipanels might have an encoder - so this is always be mapped onto first two bits
+#define BLEN_B 1
+#define BLEN_A 0
+
+#define EN_B (1<<BLEN_B) // The two encoder pins are connected through BTN_EN1 and BTN_EN2
+#define EN_A (1<<BLEN_A)
+
+#if defined(BTN_ENC) && BTN_ENC > -1
+  // encoder click is directly connected
+  #define BLEN_C 2 
+  #define EN_C (1<<BLEN_C) 
+#endif 
+  
+//
+// Setup other button mappings of each panel
+//
+#if defined(LCD_I2C_VIKI)
+  #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)
+  
+  // button and encoder bit positions within 'buttons'
+  #define B_LE (BUTTON_LEFT<<B_I2C_BTN_OFFSET)    // The remaining normalized buttons are all read via I2C
+  #define B_UP (BUTTON_UP<<B_I2C_BTN_OFFSET)
+  #define B_MI (BUTTON_SELECT<<B_I2C_BTN_OFFSET)
+  #define B_DW (BUTTON_DOWN<<B_I2C_BTN_OFFSET)
+  #define B_RI (BUTTON_RIGHT<<B_I2C_BTN_OFFSET)
+
+  #if defined(BTN_ENC) && BTN_ENC > -1 
+    // the pause/stop/restart button is connected to BTN_ENC when used
+    #define B_ST (EN_C)                            // Map the pause/stop/resume button into its normalized functional name 
+    #define LCD_CLICKED (buttons&(B_MI|B_RI|B_ST)) // pause/stop button also acts as click until we implement proper pause/stop.
+  #else
+    #define LCD_CLICKED (buttons&(B_MI|B_RI))
+  #endif  
+
+  // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update
+  #define LCD_HAS_SLOW_BUTTONS
+
+#elif defined(LCD_I2C_PANELOLU2)
+  // encoder click can be read through I2C if not directly connected
+  #if BTN_ENC <= 0 
+    #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)
+  
+    #define B_MI (PANELOLU2_ENCODER_C<<B_I2C_BTN_OFFSET) // requires LiquidTWI2 library v1.2.3 or later
+
+    #define LCD_CLICKED (buttons&B_MI)
+
+    // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update
+    #define LCD_HAS_SLOW_BUTTONS
+  #else
+    #define LCD_CLICKED (buttons&EN_C)  
+  #endif
+
+#elif defined(REPRAPWORLD_KEYPAD)
+    // define register bit values, don't change it
+    #define BLEN_REPRAPWORLD_KEYPAD_F3 0
+    #define BLEN_REPRAPWORLD_KEYPAD_F2 1
+    #define BLEN_REPRAPWORLD_KEYPAD_F1 2
+    #define BLEN_REPRAPWORLD_KEYPAD_UP 3
+    #define BLEN_REPRAPWORLD_KEYPAD_RIGHT 4
+    #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
+    #define BLEN_REPRAPWORLD_KEYPAD_DOWN 6
+    #define BLEN_REPRAPWORLD_KEYPAD_LEFT 7
+    
+    #define REPRAPWORLD_BTN_OFFSET 3 // bit offset into buttons for shift register values
+
+    #define EN_REPRAPWORLD_KEYPAD_F3 (1<<(BLEN_REPRAPWORLD_KEYPAD_F3+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_F2 (1<<(BLEN_REPRAPWORLD_KEYPAD_F2+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_F1 (1<<(BLEN_REPRAPWORLD_KEYPAD_F1+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_UP (1<<(BLEN_REPRAPWORLD_KEYPAD_UP+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_RIGHT (1<<(BLEN_REPRAPWORLD_KEYPAD_RIGHT+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_MIDDLE (1<<(BLEN_REPRAPWORLD_KEYPAD_MIDDLE+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_DOWN (1<<(BLEN_REPRAPWORLD_KEYPAD_DOWN+REPRAPWORLD_BTN_OFFSET))
+    #define EN_REPRAPWORLD_KEYPAD_LEFT (1<<(BLEN_REPRAPWORLD_KEYPAD_LEFT+REPRAPWORLD_BTN_OFFSET))
+
+    #define LCD_CLICKED ((buttons&EN_C) || (buttons&EN_REPRAPWORLD_KEYPAD_F1))
+    #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons&EN_REPRAPWORLD_KEYPAD_DOWN)
+    #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons&EN_REPRAPWORLD_KEYPAD_UP)
+    #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons&EN_REPRAPWORLD_KEYPAD_MIDDLE)
+
+#elif defined(NEWPANEL)
+  #define LCD_CLICKED (buttons&EN_C)
+  
+#else // old style ULTIPANEL
+  //bits in the shift register that carry the buttons for:
+  // left up center down right red(stop)
+  #define BL_LE 7
+  #define BL_UP 6
+  #define BL_MI 5
+  #define BL_DW 4
+  #define BL_RI 3
+  #define BL_ST 2
+
+  //automatic, do not change
+  #define B_LE (1<<BL_LE)
+  #define B_UP (1<<BL_UP)
+  #define B_MI (1<<BL_MI)
+  #define B_DW (1<<BL_DW)
+  #define B_RI (1<<BL_RI)
+  #define B_ST (1<<BL_ST)
+  
+  #define LCD_CLICKED (buttons&(B_MI|B_ST))
+#endif
+
+////////////////////////
+// Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
+// These values are independent of which pins are used for EN_A and EN_B indications
+// The rotary encoder part is also independent to the chipset used for the LCD
+#if defined(EN_A) && defined(EN_B)
+  #ifndef ULTIMAKERCONTROLLER
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+  #else
+    #define encrot0 0
+    #define encrot1 1
+    #define encrot2 3
+    #define encrot3 2
+  #endif
+#endif 
+
+#endif //ULTIPANEL
+
+////////////////////////////////////
+// Create LCD class instance and chipset-specific information
+#if defined(LCD_I2C_TYPE_PCF8575)
+  // note: these are register mapped pins on the PCF8575 controller not Arduino pins
+  #define LCD_I2C_PIN_BL  3
+  #define LCD_I2C_PIN_EN  2
+  #define LCD_I2C_PIN_RW  1
+  #define LCD_I2C_PIN_RS  0
+  #define LCD_I2C_PIN_D4  4
+  #define LCD_I2C_PIN_D5  5
+  #define LCD_I2C_PIN_D6  6
+  #define LCD_I2C_PIN_D7  7
+
+  #include <Wire.h>
+  #include <LCD.h>
+  #include <LiquidCrystal_I2C.h>
+  #define LCD_CLASS LiquidCrystal_I2C
+  LCD_CLASS lcd(LCD_I2C_ADDRESS,LCD_I2C_PIN_EN,LCD_I2C_PIN_RW,LCD_I2C_PIN_RS,LCD_I2C_PIN_D4,LCD_I2C_PIN_D5,LCD_I2C_PIN_D6,LCD_I2C_PIN_D7);
+  
+#elif defined(LCD_I2C_TYPE_MCP23017)
+  //for the LED indicators (which maybe mapped to different things in lcd_implementation_update_indicators())
+  #define LED_A 0x04 //100
+  #define LED_B 0x02 //010
+  #define LED_C 0x01 //001
+
+  #define LCD_HAS_STATUS_INDICATORS
+
+  #include <Wire.h>
+  #include <LiquidTWI2.h>
+  #define LCD_CLASS LiquidTWI2
+  LCD_CLASS lcd(LCD_I2C_ADDRESS);
+  
+#elif defined(LCD_I2C_TYPE_MCP23008)
+  #include <Wire.h>
+  #include <LiquidTWI2.h>
+  #define LCD_CLASS LiquidTWI2
+  LCD_CLASS lcd(LCD_I2C_ADDRESS);  
+
+#elif defined(LCD_I2C_TYPE_PCA8574)
+    #include <LiquidCrystal_I2C.h>
+    #define LCD_CLASS LiquidCrystal_I2C
+    LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);
+  
+#else
+  // Standard directly connected LCD implementations
+  #if LANGUAGE_CHOICE == 6
+    #include "LiquidCrystalRus.h"
+    #define LCD_CLASS LiquidCrystalRus
+  #else 
+    #include <LiquidCrystal.h>
+    #define LCD_CLASS LiquidCrystal
+  #endif  
+  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7
 #endif
 
 /* Custom characters defined in the first 8 characters of the LCD */
@@ -25,7 +209,6 @@
 #define LCD_STR_CLOCK       "\x07"
 #define LCD_STR_ARROW_RIGHT "\x7E"  /* from the default character set */
 
-LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7
 static void lcd_implementation_init()
 {
     byte bedTemp[8] =
@@ -111,7 +294,31 @@ static void lcd_implementation_init()
         B00000,
         B00000
     }; //thanks Sonny Mounicou
+
+#if defined(LCDI2C_TYPE_PCF8575)
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+  #ifdef LCD_I2C_PIN_BL
+    lcd.setBacklightPin(LCD_I2C_PIN_BL,POSITIVE);
+    lcd.setBacklight(HIGH);
+  #endif
+  
+#elif defined(LCD_I2C_TYPE_MCP23017)
+    lcd.setMCPType(LTI_TYPE_MCP23017);
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    lcd.setBacklight(0); //set all the LEDs off to begin with
+    
+#elif defined(LCD_I2C_TYPE_MCP23008)
+    lcd.setMCPType(LTI_TYPE_MCP23008);
     lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+
+#elif defined(LCD_I2C_TYPE_PCA8574)
+      lcd.init();
+      lcd.backlight();
+    
+#else
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+#endif
+
     lcd.createChar(LCD_STR_BEDTEMP[0], bedTemp);
     lcd.createChar(LCD_STR_DEGREE[0], degree);
     lcd.createChar(LCD_STR_THERMOMETER[0], thermometer);
@@ -299,13 +506,13 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
     char c;
     //Use all characters in narrow LCDs
   #if LCD_WIDTH < 20
-    	uint8_t n = LCD_WIDTH - 1 - 1;
+      uint8_t n = LCD_WIDTH - 1 - 1;
     #else
-    	uint8_t n = LCD_WIDTH - 1 - 2;
+      uint8_t n = LCD_WIDTH - 1 - 2;
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -321,13 +528,13 @@ static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const
     char c;
     //Use all characters in narrow LCDs
   #if LCD_WIDTH < 20
-    	uint8_t n = LCD_WIDTH - 1 - 1 - strlen(data);
+      uint8_t n = LCD_WIDTH - 1 - 1 - strlen(data);
     #else
-    	uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);
+      uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -343,13 +550,13 @@ static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, cons
     char c;
     //Use all characters in narrow LCDs
   #if LCD_WIDTH < 20
-    	uint8_t n = LCD_WIDTH - 1 - 1 - strlen_P(data);
+      uint8_t n = LCD_WIDTH - 1 - 1 - strlen_P(data);
     #else
-    	uint8_t n = LCD_WIDTH - 1 - 2 - strlen_P(data);
+      uint8_t n = LCD_WIDTH - 1 - 2 - strlen_P(data);
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
-    while((c = pgm_read_byte(pstr)) != '\0')
+    while( ((c = pgm_read_byte(pstr)) != '\0') && (n>0) )
     {
         lcd.print(c);
         pstr++;
@@ -402,9 +609,9 @@ void lcd_implementation_drawedit(const char* pstr, char* value)
     lcd_printPGM(pstr);
     lcd.print(':');
    #if LCD_WIDTH < 20
-    	lcd.setCursor(LCD_WIDTH - strlen(value), 1);
+      lcd.setCursor(LCD_WIDTH - strlen(value), 1);
     #else
-    	lcd.setCursor(LCD_WIDTH -1 - strlen(value), 1);
+      lcd.setCursor(LCD_WIDTH -1 - strlen(value), 1);
    #endif
     lcd.print(value);
 }
@@ -419,7 +626,7 @@ static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char*
         filename = longFilename;
         longFilename[LCD_WIDTH-1] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -439,7 +646,7 @@ static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, co
         filename = longFilename;
         longFilename[LCD_WIDTH-1] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -460,7 +667,7 @@ static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const
         filename = longFilename;
         longFilename[LCD_WIDTH-2] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -481,7 +688,7 @@ static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pst
         filename = longFilename;
         longFilename[LCD_WIDTH-2] = '\0';
     }
-    while((c = *filename) != '\0')
+    while( ((c = *filename) != '\0') && (n>0) )
     {
         lcd.print(c);
         filename++;
@@ -501,15 +708,50 @@ static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pst
 
 static void lcd_implementation_quick_feedback()
 {
-#if BEEPER > -1
+#ifdef LCD_USE_I2C_BUZZER
+    lcd.buzz(60,1000/6);
+#elif defined(BEEPER) && BEEPER > -1
     SET_OUTPUT(BEEPER);
     for(int8_t i=0;i<10;i++)
     {
-		WRITE(BEEPER,HIGH);
-		delay(3);
-		WRITE(BEEPER,LOW);
-		delay(3);
+      WRITE(BEEPER,HIGH);
+      delayMicroseconds(100);
+      WRITE(BEEPER,LOW);
+      delayMicroseconds(100);
     }
 #endif
 }
+
+#ifdef LCD_HAS_STATUS_INDICATORS
+static void lcd_implementation_update_indicators()
+{
+  #if defined(LCD_I2C_PANELOLU2) || defined(LCD_I2C_VIKI)
+    //set the LEDS - referred to as backlights by the LiquidTWI2 library 
+    static uint8_t ledsprev = 0;
+    uint8_t leds = 0;
+    if (target_temperature_bed > 0) leds |= LED_A;
+    if (target_temperature[0] > 0) leds |= LED_B;
+    if (fanSpeed) leds |= LED_C;
+    #if EXTRUDERS > 1  
+      if (target_temperature[1] > 0) leds |= LED_C;
+    #endif
+    if (leds != ledsprev) {
+      lcd.setBacklight(leds);
+      ledsprev = leds;
+    }
+  #endif
+}
+#endif
+
+#ifdef LCD_HAS_SLOW_BUTTONS
+static uint8_t lcd_implementation_read_slow_buttons()
+{
+  #ifdef LCD_I2C_TYPE_MCP23017
+    // Reading these buttons this is likely to be too slow to call inside interrupt context
+    // so they are called during normal lcd_update
+    return lcd.readButtons() << B_I2C_BTN_OFFSET; 
+  #endif
+}
+#endif
+
 #endif//ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H
diff --git a/Marlin/ultralcd_st7920_u8glib_rrd.h b/Marlin/ultralcd_st7920_u8glib_rrd.h
new file mode 100644
index 0000000..e198a85
--- /dev/null
+++ b/Marlin/ultralcd_st7920_u8glib_rrd.h
@@ -0,0 +1,131 @@
+#ifndef ULCDST7920_H
+#define ULCDST7920_H
+
+#include "Marlin.h"
+
+#ifdef U8GLIB_ST7920
+
+//set optimization so ARDUINO optimizes this file
+#pragma GCC optimize (3)
+
+#define ST7920_CLK_PIN  LCD_PINS_D4
+#define ST7920_DAT_PIN  LCD_PINS_ENABLE
+#define ST7920_CS_PIN   LCD_PINS_RS
+
+//#define PAGE_HEIGHT 8   //128 byte frambuffer
+//#define PAGE_HEIGHT 16  //256 byte frambuffer
+#define PAGE_HEIGHT 32  //512 byte framebuffer
+
+#define WIDTH 128
+#define HEIGHT 64
+
+#include <U8glib.h>
+
+static void ST7920_SWSPI_SND_8BIT(uint8_t val)
+{
+  uint8_t i;
+  for( i=0; i<8; i++ )
+  {
+    WRITE(ST7920_CLK_PIN,0);
+    WRITE(ST7920_DAT_PIN,val&0x80); 
+    val<<=1;
+    WRITE(ST7920_CLK_PIN,1);
+  }
+}
+
+#define ST7920_CS()              {WRITE(ST7920_CS_PIN,1);u8g_10MicroDelay();}
+#define ST7920_NCS()             {WRITE(ST7920_CS_PIN,0);}
+#define ST7920_SET_CMD()         {ST7920_SWSPI_SND_8BIT(0xf8);u8g_10MicroDelay();}
+#define ST7920_SET_DAT()         {ST7920_SWSPI_SND_8BIT(0xfa);u8g_10MicroDelay();}
+#define ST7920_WRITE_BYTE(a)     {ST7920_SWSPI_SND_8BIT((a)&0xf0);ST7920_SWSPI_SND_8BIT((a)<<4);u8g_10MicroDelay();}
+#define ST7920_WRITE_BYTES(p,l)  {uint8_t i;for(i=0;i<l;i++){ST7920_SWSPI_SND_8BIT(*p&0xf0);ST7920_SWSPI_SND_8BIT(*p<<4);p++;}u8g_10MicroDelay();}
+
+uint8_t u8g_dev_rrd_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)
+{
+  uint8_t i,y;
+  switch(msg)
+  {
+    case U8G_DEV_MSG_INIT:
+      {
+        SET_OUTPUT(ST7920_CS_PIN);
+        WRITE(ST7920_CS_PIN,0);
+        SET_OUTPUT(ST7920_DAT_PIN);
+        WRITE(ST7920_DAT_PIN,0);
+        SET_OUTPUT(ST7920_CLK_PIN);
+        WRITE(ST7920_CLK_PIN,1);
+
+        ST7920_CS();
+        u8g_Delay(90);                 //initial delay for boot up
+        ST7920_SET_CMD();
+        ST7920_WRITE_BYTE(0x08);       //display off, cursor+blink off
+        ST7920_WRITE_BYTE(0x01);       //clear CGRAM ram
+        u8g_Delay(10);                 //delay for cgram clear
+        ST7920_WRITE_BYTE(0x3E);       //extended mode + gdram active
+        for(y=0;y<HEIGHT/2;y++)        //clear GDRAM
+        {
+          ST7920_WRITE_BYTE(0x80|y);   //set y
+          ST7920_WRITE_BYTE(0x80);     //set x = 0
+          ST7920_SET_DAT();
+          for(i=0;i<2*WIDTH/8;i++)     //2x width clears both segments
+            ST7920_WRITE_BYTE(0);
+          ST7920_SET_CMD();
+        }
+        ST7920_WRITE_BYTE(0x0C); //display on, cursor+blink off
+        ST7920_NCS();
+      }
+      break;
+
+    case U8G_DEV_MSG_STOP:
+      break;
+    case U8G_DEV_MSG_PAGE_NEXT:
+      {
+        uint8_t *ptr;
+        u8g_pb_t *pb = (u8g_pb_t *)(dev->dev_mem);
+        y = pb->p.page_y0;
+        ptr = (uint8_t*)pb->buf;
+
+        ST7920_CS();
+        for( i = 0; i < PAGE_HEIGHT; i ++ )
+        {
+          ST7920_SET_CMD();
+          if ( y < 32 )
+          {
+            ST7920_WRITE_BYTE(0x80 | y);       //y
+            ST7920_WRITE_BYTE(0x80);           //x=0
+          }
+          else
+          {
+            ST7920_WRITE_BYTE(0x80 | (y-32));  //y
+            ST7920_WRITE_BYTE(0x80 | 8);       //x=64
+          }
+
+          ST7920_SET_DAT();
+          ST7920_WRITE_BYTES(ptr,WIDTH/8); //ptr is incremented inside of macro
+          y++;
+        }
+        ST7920_NCS();
+      }
+      break;
+  }
+#if PAGE_HEIGHT == 8
+  return u8g_dev_pb8h1_base_fn(u8g, dev, msg, arg);
+#elif PAGE_HEIGHT == 16
+  return u8g_dev_pb16h1_base_fn(u8g, dev, msg, arg);
+#else
+  return u8g_dev_pb32h1_base_fn(u8g, dev, msg, arg);
+#endif
+}
+
+uint8_t   u8g_dev_st7920_128x64_rrd_buf[WIDTH*(PAGE_HEIGHT/8)] U8G_NOCOMMON;
+u8g_pb_t  u8g_dev_st7920_128x64_rrd_pb = {{PAGE_HEIGHT,HEIGHT,0,0,0},WIDTH,u8g_dev_st7920_128x64_rrd_buf};
+u8g_dev_t u8g_dev_st7920_128x64_rrd_sw_spi = {u8g_dev_rrd_st7920_128x64_fn,&u8g_dev_st7920_128x64_rrd_pb,&u8g_com_null_fn};
+
+class U8GLIB_ST7920_128X64_RRD : public U8GLIB
+{
+  public:
+    U8GLIB_ST7920_128X64_RRD(uint8_t dummy) : U8GLIB(&u8g_dev_st7920_128x64_rrd_sw_spi) {}
+};
+
+
+#endif //U8GLIB_ST7920
+#endif //ULCDST7920_H
diff --git a/README.md b/README.md
index 309fdd1..0148717 100644
--- a/README.md
+++ b/README.md
@@ -1,12 +1,8 @@
-WARNING: 
---------
-THIS IS RELEASE CANDIDATE 2 FOR MARLIN 1.0.0
+==========================
+Marlin 3D Printer Firmware
+==========================
 
-The configuration is now split in two files
-Configuration.h for the normal settings
-Configuration_adv.h for the advanced settings
-
-Gen7T is not supported.
+[![Flattr this git repo](http://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=ErikZalm&url=https://github.com/ErikZalm/Marlin&title=Marlin&language=&tags=github&category=software)
 
 Quick Information
 ===================
@@ -26,14 +22,14 @@ Features:
 *   High steprate
 *   Look ahead (Keep the speed high when possible. High cornering speed)
 *   Interrupt based temperature protection
-*   preliminary support for Matthew Roberts advance algorithm 
+*   preliminary support for Matthew Roberts advance algorithm
     For more info see: http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
 *   Full endstop support
 *   SD Card support
 *   SD Card folders (works in pronterface)
 *   SD Card autostart support
-*   LCD support (ideally 20x4) 
-*   LCD menu system for autonomous SD card printing, controlled by an click-encoder. 
+*   LCD support (ideally 20x4)
+*   LCD menu system for autonomous SD card printing, controlled by an click-encoder.
 *   EEPROM storage of e.g. max-velocity, max-acceleration, and similar variables
 *   many small but handy things originating from bkubicek's fork.
 *   Arc support
@@ -45,7 +41,11 @@ Features:
 *   Heater power reporting. Useful for PID monitoring.
 *   PID tuning
 *   CoreXY kinematics (www.corexy.com/theory.html)
+*   Delta kinematics
+*   Dual X-carriage support for multiple extruder systems
 *   Configurable serial port to support connection of wireless adaptors.
+*   Automatic operation of extruder/cold-end cooling fans based on nozzle temperature
+*   RC Servo Support, specify angle or duration for continuous rotation servos.
 
 The default baudrate is 250000. This baudrate has less jitter and hence errors than the usual 115200 baud, but is less supported by drivers and host-environments.
 
@@ -55,17 +55,17 @@ Differences and additions to the already good Sprinter firmware:
 
 *Look-ahead:*
 
-Marlin has look-ahead. While sprinter has to break and re-accelerate at each corner, 
-lookahead will only decelerate and accelerate to a velocity, 
+Marlin has look-ahead. While sprinter has to break and re-accelerate at each corner,
+lookahead will only decelerate and accelerate to a velocity,
 so that the change in vectorial velocity magnitude is less than the xy_jerk_velocity.
-This is only possible, if some future moves are already processed, hence the name. 
+This is only possible, if some future moves are already processed, hence the name.
 It leads to less over-deposition at corners, especially at flat angles.
 
 *Arc support:*
 
 Slic3r can find curves that, although broken into segments, were ment to describe an arc.
 Marlin is able to print those arcs. The advantage is the firmware can choose the resolution,
-and can perform the arc with nearly constant velocity, resulting in a nice finish. 
+and can perform the arc with nearly constant velocity, resulting in a nice finish.
 Also, less serial communication is needed.
 
 *Temperature Oversampling:*
@@ -94,7 +94,7 @@ After each reboot, it will magically load them from EEPROM, independent what you
 
 If your hardware supports it, you can build yourself a LCD-CardReader+Click+encoder combination. It will enable you to realtime tune temperatures,
 accelerations, velocities, flow rates, select and print files from the SD card, preheat, disable the steppers, and do other fancy stuff.
-One working hardware is documented here: http://www.thingiverse.com/thing:12663 
+One working hardware is documented here: http://www.thingiverse.com/thing:12663
 Also, with just a 20x4 or 16x2 display, useful data is shown.
 
 *SD card folders:*
@@ -129,57 +129,98 @@ necessary for backwards compatibility.
 An interrupt is used to manage ADC conversions, and enforce checking for critical temperatures.
 This leads to less blocking in the heater management routine.
 
+Implemented G Codes:
+====================
+
+*  G0  -> G1
+*  G1  - Coordinated Movement X Y Z E
+*  G2  - CW ARC
+*  G3  - CCW ARC
+*  G4  - Dwell S<seconds> or P<milliseconds>
+*  G10 - retract filament according to settings of M207
+*  G11 - retract recover filament according to settings of M208
+*  G28 - Home all Axis
+*  G90 - Use Absolute Coordinates
+*  G91 - Use Relative Coordinates
+*  G92 - Set current position to cordinates given
+
+M Codes
+*  M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+*  M1   - Same as M0
+*  M17  - Enable/Power all stepper motors
+*  M18  - Disable all stepper motors; same as M84
+*  M20  - List SD card
+*  M21  - Init SD card
+*  M22  - Release SD card
+*  M23  - Select SD file (M23 filename.g)
+*  M24  - Start/resume SD print
+*  M25  - Pause SD print
+*  M26  - Set SD position in bytes (M26 S12345)
+*  M27  - Report SD print status
+*  M28  - Start SD write (M28 filename.g)
+*  M29  - Stop SD write
+*  M30  - Delete file from SD (M30 filename.g)
+*  M31  - Output time since last M109 or SD card start to serial
+*  M32  - Select file and start SD print (Can be used when printing from SD card)
+*  M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
+*  M80  - Turn on Power Supply
+*  M81  - Turn off Power Supply
+*  M82  - Set E codes absolute (default)
+*  M83  - Set E codes relative while in Absolute Coordinates (G90) mode
+*  M84  - Disable steppers until next move, or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+*  M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+*  M92  - Set axis_steps_per_unit - same syntax as G92
+*  M104 - Set extruder target temp
+*  M105 - Read current temp
+*  M106 - Fan on
+*  M107 - Fan off
+*  M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
+*         Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
+*  M114 - Output current position to serial port
+*  M115 - Capabilities string
+*  M117 - display message
+*  M119 - Output Endstop status to serial port
+*  M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
+*  M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
+*  M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
+*  M140 - Set bed target temp
+*  M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
+*         Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
+*  M200 - Set filament diameter
+*  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+*  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
+*  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+*  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
+*  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
+*  M206 - set additional homeing offset
+*  M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
+*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]
+*  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+*  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
+*  M220 S<factor in percent>- set speed factor override percentage
+*  M221 S<factor in percent>- set extrude factor override percentage
+*  M240 - Trigger a camera to take a photograph
+*  M280 - Position an RC Servo P<index> S<angle/microseconds>, ommit S to report back current angle
+*  M300 - Play beepsound S<frequency Hz> P<duration ms>
+*  M301 - Set PID parameters P I and D
+*  M302 - Allow cold extrudes
+*  M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
+*  M304 - Set bed PID parameters P I and D
+*  M400 - Finish all moves
+*  M500 - stores paramters in EEPROM
+*  M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).
+*  M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
+*  M503 - print the current settings (from memory not from eeprom)
+*  M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+*  M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+*  M907 - Set digital trimpot motor current using axis codes.
+*  M908 - Control digital trimpot directly.
+*  M350 - Set microstepping mode.
+*  M351 - Toggle MS1 MS2 pins directly.
+*  M928 - Start SD logging (M928 filename.g) - ended by M29
+*  M999 - Restart after being stopped by error
 
-Non-standard M-Codes, different to an old version of sprinter:
-==============================================================
-Movement:
-
-*   G2  - CW ARC
-*   G3  - CCW ARC
-
-General:
-
-*   M17  - Enable/Power all stepper motors. Compatibility to ReplicatorG.
-*   M18  - Disable all stepper motors; same as M84.Compatibility to ReplicatorG.
-*   M30  - Print time since last M109 or SD card start to serial
-*   M42  - Change pin status via gcode
-*   M80  - Turn on Power Supply
-*   M81  - Turn off Power Supply
-*   M114 - Output current position to serial port 
-*   M119 - Output Endstop status to serial port
-
-Movement variables:
-
-*   M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
-*   M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-*   M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-*   M206 - set home offsets.  This sets the X,Y,Z coordinates of the endstops (and is added to the {X,Y,Z}_HOME_POS configuration options (and is also added to the coordinates, if any, provided to G82, as with earlier firmware)
-*   M220 - set build speed mulitplying S:factor in percent ; aka "realtime tuneing in the gcode". So you can slow down if you have islands in one height-range, and speed up otherwise.
-*   M221 - set the extrude multiplying S:factor in percent
-*   M400 - Finish all buffered moves.
-
-Temperature variables:
-*   M301 - Set PID parameters P I and D
-*   M302 - Allow cold extrudes
-*   M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-
-Advance:
-
-*   M200 - Set filament diameter for advance
-*   M205 - advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
-
-EEPROM:
-
-*   M500 - stores paramters in EEPROM. This parameters are stored:  axis_steps_per_unit,  max_feedrate, max_acceleration  ,acceleration,retract_acceleration,
-  minimumfeedrate,mintravelfeedrate,minsegmenttime,  jerk velocities, PID
-*   M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).  
-*   M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.
-*   M503 - print the current settings (from memory not from eeprom)
-
-MISC:
-
-*   M240 - Trigger a camera to take a photograph
-*   M999 - Restart after being stopped by error
 
 Configuring and compilation:
 ============================
@@ -190,12 +231,7 @@ Install the arduino software IDE/toolset v23 (Some configurations also work with
 For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
   copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
 
-Install Ultimaker's RepG 25 build
-    http://software.ultimaker.com
-For SD handling and as better substitute (apart from stl manipulation) download
-the very nice Kliment's printrun/pronterface  https://github.com/kliment/Printrun
-
-Copy the Ultimaker Marlin firmware
+Copy the Marlin firmware
    https://github.com/ErikZalm/Marlin/tree/Marlin_v1
    (Use the download button)
 
@@ -209,15 +245,8 @@ Click the Verify/Compile button
 Click the Upload button
 If all goes well the firmware is uploading
 
-Start Ultimaker's Custom RepG 25
-Make sure Show Experimental Profiles is enabled in Preferences
-Select Sprinter as the Driver
-
-Press the Connect button.
-
-KNOWN ISSUES: RepG will display:  Unknown: marlin x.y.z
-
 That's ok.  Enjoy Silky Smooth Printing.
 
 
 
+
