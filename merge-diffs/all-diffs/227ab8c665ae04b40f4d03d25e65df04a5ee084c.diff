commit 227ab8c665ae04b40f4d03d25e65df04a5ee084c (from e6af82ba2f5ef32dfd2477e0edd400c8ad659ad5)
Merge: e6af82b d28f5b9
Author: alexborro <alexborro@gmail.com>
Date:   Wed Feb 25 13:22:42 2015 -0300

    Merge pull request #1503 from MarcelMo/patch-2
    
    Support for simple customisable AutoZProbing area

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 61e966f..f986ee6 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1720,6 +1720,7 @@ void process_commands()
 
 #ifdef ENABLE_AUTO_BED_LEVELING
     case 29: // G29 Detailed Z-Probe, probes the bed at 3 or more points.
+    	     // Override probing area by providing [F]ront [B]ack [L]eft [R]ight Grid[P]oints values
         {
             #if Z_MIN_PIN == -1
             #error "You must have a Z_MIN endstop in order to enable Auto Bed Leveling feature!!! Z_MIN_PIN must point to a valid hardware pin."
@@ -1733,6 +1734,16 @@ void process_commands()
                 SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
                 break; // abort G29, since we don't know where we are
             }
+            int left_probe_bed_position=LEFT_PROBE_BED_POSITION;
+            int right_probe_bed_position=RIGHT_PROBE_BED_POSITION;
+            int back_probe_bed_position=BACK_PROBE_BED_POSITION;
+            int front_probe_bed_position=FRONT_PROBE_BED_POSITION;
+            int auto_bed_leveling_grid_points=AUTO_BED_LEVELING_GRID_POINTS;
+            if (code_seen('L')) left_probe_bed_position=(int)code_value();
+            if (code_seen('R')) right_probe_bed_position=(int)code_value();
+            if (code_seen('B')) back_probe_bed_position=(int)code_value();
+            if (code_seen('F')) front_probe_bed_position=(int)code_value();
+            if (code_seen('P')) auto_bed_leveling_grid_points=(int)code_value();
 
 #ifdef Z_PROBE_SLED
             dock_sled(false);
@@ -1754,8 +1765,8 @@ void process_commands()
 #ifdef AUTO_BED_LEVELING_GRID
             // probe at the points of a lattice grid
 
-            int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);
-            int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);
+            int xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (auto_bed_leveling_grid_points-1);
+            int yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (auto_bed_leveling_grid_points-1);
 
 
             // solve the plane equation ax + by + d = z
@@ -1765,32 +1776,35 @@ void process_commands()
             // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
 
             // "A" matrix of the linear system of equations
-            double eqnAMatrix[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS*3];
+            double eqnAMatrix[auto_bed_leveling_grid_points*auto_bed_leveling_grid_points*3];
+
             // "B" vector of Z points
-            double eqnBVector[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS];
+            double eqnBVector[auto_bed_leveling_grid_points*auto_bed_leveling_grid_points];
+
 
 
             int probePointCounter = 0;
             bool zig = true;
 
-            for (int yProbe=FRONT_PROBE_BED_POSITION; yProbe <= BACK_PROBE_BED_POSITION; yProbe += yGridSpacing)
+            for (int yProbe=front_probe_bed_position; yProbe <= back_probe_bed_position; yProbe += yGridSpacing)
+
             {
               int xProbe, xInc;
               if (zig)
               {
-                xProbe = LEFT_PROBE_BED_POSITION;
-                //xEnd = RIGHT_PROBE_BED_POSITION;
+                xProbe = left_probe_bed_position;
+                //xEnd = right_probe_bed_position;
                 xInc = xGridSpacing;
                 zig = false;
               } else // zag
               {
-                xProbe = RIGHT_PROBE_BED_POSITION;
-                //xEnd = LEFT_PROBE_BED_POSITION;
+                xProbe = right_probe_bed_position;
+                //xEnd = left_probe_bed_position;
                 xInc = -xGridSpacing;
                 zig = true;
               }
 
-              for (int xCount=0; xCount < AUTO_BED_LEVELING_GRID_POINTS; xCount++)
+              for (int xCount=0; xCount < auto_bed_leveling_grid_points; xCount++)
               {
                 float z_before;
                 if (probePointCounter == 0)
@@ -1822,9 +1836,9 @@ void process_commands()
 
                 eqnBVector[probePointCounter] = measured_z;
 
-                eqnAMatrix[probePointCounter + 0*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = xProbe;
-                eqnAMatrix[probePointCounter + 1*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = yProbe;
-                eqnAMatrix[probePointCounter + 2*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = 1;
+                eqnAMatrix[probePointCounter + 0*auto_bed_leveling_grid_points*auto_bed_leveling_grid_points] = xProbe;
+                eqnAMatrix[probePointCounter + 1*auto_bed_leveling_grid_points*auto_bed_leveling_grid_points] = yProbe;
+                eqnAMatrix[probePointCounter + 2*auto_bed_leveling_grid_points*auto_bed_leveling_grid_points] = 1;
                 probePointCounter++;
                 xProbe += xInc;
               }
@@ -1832,7 +1846,7 @@ void process_commands()
             clean_up_after_endstop_move();
 
             // solve lsq problem
-            double *plane_equation_coefficients = qr_solve(AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS, 3, eqnAMatrix, eqnBVector);
+            double *plane_equation_coefficients = qr_solve(auto_bed_leveling_grid_points*auto_bed_leveling_grid_points, 3, eqnAMatrix, eqnBVector);
 
             SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
             SERIAL_PROTOCOL(plane_equation_coefficients[0]);

commit 227ab8c665ae04b40f4d03d25e65df04a5ee084c (from d28f5b9e826d469062bb75c042afa5056e3e2e70)
Merge: e6af82b d28f5b9
Author: alexborro <alexborro@gmail.com>
Date:   Wed Feb 25 13:22:42 2015 -0300

    Merge pull request #1503 from MarcelMo/patch-2
    
    Support for simple customisable AutoZProbing area

diff --git a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
index 58354ce..6c0571c 100644
--- a/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
+++ b/ArduinoAddons/Arduino_1.5.x/hardware/marlin/avr/boards.txt
@@ -33,7 +33,7 @@ rambo.build.variant=rambo
 ########################################
 sanguino.name=Sanguino
 
-sanguino.upload.tool=ardunio:avrdude
+sanguino.upload.tool=arduino:avrdude
 sanguino.upload.protocol=stk500
 sanguino.upload.maximum_size=131072
 sanguino.upload.speed=57600
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 41e1ed7..afcd913 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -118,6 +118,7 @@ Here are some standard links for getting your machine calibrated:
 // 1010 is Pt1000 with 1k pullup (non standard)
 // 147 is Pt100 with 4k7 pullup
 // 110 is Pt100 with 1k pullup (non standard)
+// 999 is a Dummy Table. It will ALWAYS read 25C.. Use it for Testing or Development purposes. NEVER for production machine.
 
 #define TEMP_SENSOR_0 -1
 #define TEMP_SENSOR_1 -1
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 4d3579d..f2b3124 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -284,6 +284,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/LiquidCrystalRus.cpp b/Marlin/LiquidCrystalRus.cpp
index 6ee2c11..c741462 100644
--- a/Marlin/LiquidCrystalRus.cpp
+++ b/Marlin/LiquidCrystalRus.cpp
@@ -14,10 +14,14 @@
 // it is a Russian alphabet translation
 // except 0401 --> 0xa2 = ╗, 0451 --> 0xb5
 const PROGMEM uint8_t utf_recode[] = 
-       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
-         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
-         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
-         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
+       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,
+         0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,0xa8,
+         0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,
+         0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
+         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,
+         0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,0xbe,
+         0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,
+         0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
         };     
 
 // When the display powers up, it is configured as follows:
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 1063761..f986ee6 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -1865,30 +1865,25 @@ void process_commands()
             // Probe at 3 arbitrary points
             // Enhanced G29
             
-            float z_at_pt_1,z_at_pt_2,z_at_pt_3;
+            float z_at_pt_1, z_at_pt_2, z_at_pt_3;
             
-            if (code_seen('E') || code_seen('e') )
-               {
-               // probe 1               
-                z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING,1);
-               // probe 2
-                z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,2);
-               // probe 3
-                z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,3); 
-               }
-               else 
-               {
-	        // probe 1
-	        float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING);
-
-                // probe 2
-                float z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
-
-                // probe 3
-                float z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
-               }
+            if (code_seen('E') || code_seen('e')) {
+              // probe 1               
+              z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING,1);
+              // probe 2
+              z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,2);
+              // probe 3
+              z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,3); 
+            }
+            else {
+              // probe 1
+              z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING);
+              // probe 2
+              z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+              // probe 3
+              z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+            }
             clean_up_after_endstop_move();
-
             set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
 
 
@@ -3774,6 +3769,9 @@ case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or disp
 
         RUNPLAN; //should do nothing
 
+        //reset LCD alert message
+    	lcd_reset_alert_level();
+
         #ifdef DELTA
           calculate_delta(lastpos);
           plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], fr60, active_extruder); //move xyz back
@@ -4711,21 +4709,12 @@ bool setTargetedHotend(int code){
 
 
 float calculate_volumetric_multiplier(float diameter) {
-	float area = .0;
-	float radius = .0;
-
-	radius = diameter * .5;
-	if (! volumetric_enabled || radius == 0) {
-		area = 1;
-	}
-	else {
-		area = M_PI * pow(radius, 2);
-	}
-
-	return 1.0 / area;
+  if (!volumetric_enabled || diameter == 0) return 1.0;
+  float d2 = diameter * 0.5;
+  return 1.0 / (M_PI * d2 * d2);
 }
 
 void calculate_volumetric_multipliers() {
   for (int i=0; i<EXTRUDERS; i++)
-  	volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
+    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
diff --git a/Marlin/boards.h b/Marlin/boards.h
index c6997fe..2f1107b 100644
--- a/Marlin/boards.h
+++ b/Marlin/boards.h
@@ -50,10 +50,11 @@
 #define BOARD_LEAPFROG          999  // Leapfrog
 #define BOARD_WITBOX            41   // bq WITBOX
 #define BOARD_HEPHESTOS         42   // bq Prusa i3 Hephestos
+#define BOARD_BAM_DICE          401  // 2PrintBeta BAM&DICE with STK drivers
+#define BOARD_BAM_DICE_DUE      402  // 2PrintBeta BAM&DICE Due with STK drivers
 
 #define BOARD_99                99   // This is in pins.h but...?
 
 #define MB(board) (MOTHERBOARD==BOARD_##board)
-#define IS_RAMPS (MB(RAMPS_OLD) || MB(RAMPS_13_EFB) || MB(RAMPS_13_EEB) || MB(RAMPS_13_EFF) || MB(RAMPS_13_EEF))
 
 #endif //__BOARDS_H
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 498a654..a2dd678 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -65,7 +65,7 @@ void CardReader::lsDive(const char *prepend, SdFile parent, const char * const m
       createFilename(lfilename,p);
       
       path[0]=0;
-      if(strlen(prepend)==0) //avoid leading / if already in prepend
+      if(prepend[0]==0) //avoid leading / if already in prepend
       {
        strcat(path,"/");
       }
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index f512d32..c7df306 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -315,7 +315,7 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
 
 static void _drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, const char* data, bool pgm) {
   char c;
-  uint8_t n = LCD_WIDTH - 2 - (pgm ? strlen_P(data) : (strlen(data)));
+  uint8_t n = LCD_WIDTH - 2 - (pgm ? lcd_strlen_P(data) : (lcd_strlen((char*)data)));
 
   lcd_implementation_mark_as_selected(row, pre_char);
 
@@ -377,18 +377,18 @@ void lcd_implementation_drawedit(const char* pstr, char* value) {
   uint8_t char_width = DOG_CHAR_WIDTH;
 
   #ifdef USE_BIG_EDIT_FONT
-    if (strlen_P(pstr) <= LCD_WIDTH_EDIT - 1) {
+    if (lcd_strlen_P(pstr) <= LCD_WIDTH_EDIT - 1) {
       u8g.setFont(FONT_MENU_EDIT);
       lcd_width = LCD_WIDTH_EDIT + 1;
       char_width = DOG_CHAR_WIDTH_EDIT;
-      if (strlen_P(pstr) >= LCD_WIDTH_EDIT - strlen(value)) rows = 2;
+      if (lcd_strlen_P(pstr) >= LCD_WIDTH_EDIT - lcd_strlen(value)) rows = 2;
     }
     else {
       u8g.setFont(FONT_MENU);
     }
   #endif
 
-  if (strlen_P(pstr) > LCD_WIDTH - 2 - strlen(value)) rows = 2;
+  if (lcd_strlen_P(pstr) > LCD_WIDTH - 2 - lcd_strlen(value)) rows = 2;
 
   const float kHalfChar = DOG_CHAR_HEIGHT_EDIT / 2;
   float rowHeight = u8g.getHeight() / (rows + 1); // 1/(rows+1) = 1/2 or 1/3
@@ -396,7 +396,7 @@ void lcd_implementation_drawedit(const char* pstr, char* value) {
   u8g.setPrintPos(0, rowHeight + kHalfChar);
   lcd_printPGM(pstr);
   u8g.print(':');
-  u8g.setPrintPos((lcd_width-1-strlen(value)) * char_width, rows * rowHeight + kHalfChar);
+  u8g.setPrintPos((lcd_width-1-lcd_strlen(value)) * char_width, rows * rowHeight + kHalfChar);
   u8g.print(value);
 }
 
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 1412c99..0a9c8a1 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -284,6 +284,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index b3d9ed8..bf2daed 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -284,6 +284,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index 215ee49..a326698 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -287,6 +287,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 1412c99..0a9c8a1 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -284,6 +284,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/delta/Configuration_adv.h b/Marlin/example_configurations/delta/Configuration_adv.h
index 79d2036..9b49bfe 100644
--- a/Marlin/example_configurations/delta/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/Configuration_adv.h
@@ -279,6 +279,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index 6c181fb..1033b99 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -283,6 +283,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index 64fd9ec..df413f6 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -284,6 +284,11 @@
 //=============================Additional Features===========================
 //===========================================================================
 
+#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly
+#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceed this value, multiple the steps moved by ten to quickly advance the value
+#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceed this value, multiple the steps moved by 100 to really quickly advance the value
+//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
 //#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/
 #define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again
 
diff --git a/Marlin/language_en.h b/Marlin/language_en.h
index 086e5c1..5d38aa9 100644
--- a/Marlin/language_en.h
+++ b/Marlin/language_en.h
@@ -65,6 +65,18 @@
 #ifndef MSG_PREHEAT_ABS_SETTINGS
 #define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"
 #endif
+#ifndef MSG_H1
+#define MSG_H1                              "1"
+#endif
+#ifndef MSG_H2
+#define MSG_H2                              "2"
+#endif
+#ifndef MSG_H3
+#define MSG_H3                              "3"
+#endif
+#ifndef MSG_H4
+#define MSG_H4                              "4"
+#endif
 #ifndef MSG_COOLDOWN
 #define MSG_COOLDOWN                        "Cooldown"
 #endif
@@ -110,6 +122,15 @@
 #ifndef MSG_NOZZLE
 #define MSG_NOZZLE                          "Nozzle"
 #endif
+#ifndef MSG_N2
+#define MSG_N2                              " 2"
+#endif
+#ifndef MSG_N3
+#define MSG_N3                              " 3"
+#endif
+#ifndef MSG_N4
+#define MSG_N4                              " 4"
+#endif
 #ifndef MSG_BED
 #define MSG_BED                             "Bed"
 #endif
@@ -119,6 +140,18 @@
 #ifndef MSG_FLOW
 #define MSG_FLOW                            "Flow"
 #endif
+#ifndef MSG_F0
+#define MSG_F0                              " 0"
+#endif
+#ifndef MSG_F1
+#define MSG_F1                              " 1"
+#endif
+#ifndef MSG_F2
+#define MSG_F2                              " 2"
+#endif
+#ifndef MSG_F3
+#define MSG_F3                              " 3"
+#endif
 #ifndef MSG_CONTROL
 #define MSG_CONTROL                         "Control"
 #endif
@@ -152,6 +185,15 @@
 #ifndef MSG_PID_C
 #define MSG_PID_C                           "PID-C"
 #endif
+#ifndef MSG_E2
+#define MSG_E2                              " E2"
+#endif
+#ifndef MSG_E3
+#define MSG_E3                              " E3"
+#endif
+#ifndef MSG_E4
+#define MSG_E4                              " E4"
+#endif
 #ifndef MSG_ACC
 #define MSG_ACC                             "Accel"
 #endif
@@ -213,7 +255,7 @@
 #define MSG_VOLUMETRIC                      "Filament"
 #endif
 #ifndef MSG_VOLUMETRIC_ENABLED
-#define MSG_VOLUMETRIC_ENABLED		          "E in mm" STR_h3
+#define MSG_VOLUMETRIC_ENABLED		        "E in mm" STR_h3
 #endif
 #ifndef MSG_FILAMENT_SIZE_EXTRUDER_0
 #define MSG_FILAMENT_SIZE_EXTRUDER_0        "Fil. Dia. 1"
diff --git a/Marlin/language_fi.h b/Marlin/language_fi.h
index 2346600..62fdc76 100644
--- a/Marlin/language_fi.h
+++ b/Marlin/language_fi.h
@@ -17,38 +17,38 @@
 #define MSG_AUTO_HOME                       "Aja referenssiin"
 #define MSG_SET_HOME_OFFSETS                "Set home offsets"
 #define MSG_SET_ORIGIN                      "Aseta origo"
-#define MSG_PREHEAT_PLA                     "Esilammita PLA"
-#define MSG_PREHEAT_PLA_N                   "Esilammita PLA "
-#define MSG_PREHEAT_PLA_ALL                 "Esila. PLA Kaikki"
-#define MSG_PREHEAT_PLA_BEDONLY             "Esila. PLA Alusta"
-#define MSG_PREHEAT_PLA_SETTINGS            "Esilamm. PLA konf"
-#define MSG_PREHEAT_ABS                     "Esilammita ABS"
-#define MSG_PREHEAT_ABS_N                   "Esilammita ABS "
-#define MSG_PREHEAT_ABS_ALL                 "Esila. ABS Kaikki"
-#define MSG_PREHEAT_ABS_BEDONLY             "Esila. ABS Alusta"
-#define MSG_PREHEAT_ABS_SETTINGS            "Esilamm. ABS konf"
-#define MSG_COOLDOWN                        "Jaahdyta"
-#define MSG_SWITCH_PS_ON                    "Virta paalle"
+#define MSG_PREHEAT_PLA                     "Esil" STR_ae "mmit" STR_ae " PLA"
+#define MSG_PREHEAT_PLA_N                   "Esil" STR_ae "mmit" STR_ae " PLA "
+#define MSG_PREHEAT_PLA_ALL                 "Esil" STR_ae ". PLA Kaikki"
+#define MSG_PREHEAT_PLA_BEDONLY             "Esil" STR_ae ". PLA Alusta"
+#define MSG_PREHEAT_PLA_SETTINGS            "Esil" STR_ae "mm. PLA konf"
+#define MSG_PREHEAT_ABS                     "Esil" STR_ae "mmit" STR_ae " ABS"
+#define MSG_PREHEAT_ABS_N                   "Esil" STR_ae "mmit" STR_ae " ABS "
+#define MSG_PREHEAT_ABS_ALL                 "Esil" STR_ae ". ABS Kaikki"
+#define MSG_PREHEAT_ABS_BEDONLY             "Esil" STR_ae ". ABS Alusta"
+#define MSG_PREHEAT_ABS_SETTINGS            "Esil" STR_ae "mm. ABS konf"
+#define MSG_COOLDOWN                        "J" STR_ae "" STR_ae "hdyt" STR_ae ""
+#define MSG_SWITCH_PS_ON                    "Virta p" STR_ae "" STR_ae "lle"
 #define MSG_SWITCH_PS_OFF                   "Virta pois"
 #define MSG_EXTRUDE                         "Pursota"
-#define MSG_RETRACT                         "Veda takaisin"
+#define MSG_RETRACT                         "Ved" STR_ae " takaisin"
 #define MSG_MOVE_AXIS                       "Liikuta akseleita"
-#define MSG_MOVE_X                          "Move X"
-#define MSG_MOVE_Y                          "Move Y"
-#define MSG_MOVE_Z                          "Move Z"
+#define MSG_MOVE_X                          "Liikuta X"
+#define MSG_MOVE_Y                          "Liikuta Y"
+#define MSG_MOVE_Z                          "Liikuta Z"
 #define MSG_MOVE_E                          "Extruder"
-#define MSG_MOVE_01MM                       "Move 0.1mm"
-#define MSG_MOVE_1MM                        "Move 1mm"
-#define MSG_MOVE_10MM                       "Move 10mm"
+#define MSG_MOVE_01MM                       "Liikuta 0.1mm"
+#define MSG_MOVE_1MM                        "Liikuta 1mm"
+#define MSG_MOVE_10MM                       "Liikuta 10mm"
 #define MSG_SPEED                           "Nopeus"
 #define MSG_NOZZLE                          "Suutin"
 #define MSG_BED                             "Alusta"
 #define MSG_FAN_SPEED                       "Tuul. nopeus"
 #define MSG_FLOW                            "Virtaus"
 #define MSG_CONTROL                         "Kontrolli"
-#define MSG_MIN                             " \002 Min"
-#define MSG_MAX                             " \002 Max"
-#define MSG_FACTOR                          " \002 Kerr"
+#define MSG_MIN                             STR_THERMOMETER " Min"
+#define MSG_MAX                             STR_THERMOMETER " Max"
+#define MSG_FACTOR                          STR_THERMOMETER " Kerr"
 #define MSG_AUTOTEMP                        "Autotemp"
 #define MSG_ON                              "On "
 #define MSG_OFF                             "Off"
@@ -73,24 +73,24 @@
 #define MSG_YSTEPS                          "Ysteps/mm"
 #define MSG_ZSTEPS                          "Zsteps/mm"
 #define MSG_ESTEPS                          "Esteps/mm"
-#define MSG_TEMPERATURE                     "Lampotila"
+#define MSG_TEMPERATURE                     "L" STR_ae "mp" STR_oe "tila"
 #define MSG_MOTION                          "Liike"
 #define MSG_VOLUMETRIC                      "Filament"
-#define MSG_VOLUMETRIC_ENABLED		        "E in mm3"
+#define MSG_VOLUMETRIC_ENABLED              "E in mm3"
 #define MSG_FILAMENT_SIZE_EXTRUDER_0        "Fil. Dia. 1"
 #define MSG_FILAMENT_SIZE_EXTRUDER_1        "Fil. Dia. 2"
 #define MSG_FILAMENT_SIZE_EXTRUDER_2        "Fil. Dia. 3"
-#define MSG_CONTRAST                        "LCD contrast"
+#define MSG_CONTRAST                        "LCD kontrasti"
 #define MSG_STORE_EPROM                     "Tallenna muistiin"
 #define MSG_LOAD_EPROM                      "Lataa muistista"
 #define MSG_RESTORE_FAILSAFE                "Palauta oletus"
-#define MSG_REFRESH                         "Paivita"
+#define MSG_REFRESH                         "P" STR_ae "ivit" STR_ae ""
 #define MSG_WATCH                           "Seuraa"
 #define MSG_PREPARE                         "Valmistele"
-#define MSG_TUNE                            "Saada"
-#define MSG_PAUSE_PRINT                     "Keskeyta tulostus"
+#define MSG_TUNE                            "S" STR_ae "" STR_ae "d" STR_ae ""
+#define MSG_PAUSE_PRINT                     "Keskeyt" STR_ae " tulostus"
 #define MSG_RESUME_PRINT                    "Jatka tulostusta"
-#define MSG_STOP_PRINT                      "Pysayta tulostus"
+#define MSG_STOP_PRINT                      "Pys" STR_ae "yt" STR_ae " tulostus"
 #define MSG_CARD_MENU                       "Korttivalikko"
 #define MSG_NO_CARD                         "Ei korttia"
 #define MSG_DWELL                           "Nukkumassa..."
@@ -100,9 +100,9 @@
 #define MSG_NO_MOVE                         "Ei liiketta."
 #define MSG_KILLED                          "KILLED. "
 #define MSG_STOPPED                         "STOPPED. "
-#define MSG_CONTROL_RETRACT                 "Veda mm"
-#define MSG_CONTROL_RETRACT_SWAP            "Va. Veda mm"
-#define MSG_CONTROL_RETRACTF                "Veda V"
+#define MSG_CONTROL_RETRACT                 "Ved" STR_ae " mm"
+#define MSG_CONTROL_RETRACT_SWAP            "Va. Ved" STR_ae " mm"
+#define MSG_CONTROL_RETRACTF                "Ved" STR_ae " V"
 #define MSG_CONTROL_RETRACT_ZLIFT           "Z mm"
 #define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"
 #define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Va. UnRet +mm"
@@ -120,11 +120,11 @@
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
 
 #ifdef DELTA_CALIBRATION_MENU
-    #define MSG_DELTA_CALIBRATE             "Delta Calibration"
-    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"
-    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"
-    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"
-    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"
+    #define MSG_DELTA_CALIBRATE             "Delta Kalibrointi"
+    #define MSG_DELTA_CALIBRATE_X           "Kalibroi X"
+    #define MSG_DELTA_CALIBRATE_Y           "Kalibroi Y"
+    #define MSG_DELTA_CALIBRATE_Z           "Kalibroi Z"
+    #define MSG_DELTA_CALIBRATE_CENTER      "Kalibroi Center"
 #endif // DELTA_CALIBRATION_MENU
 
-#endif // LANGUAGE_FI_H
+#endif // LANGUAGE_FI_H
\ No newline at end of file
diff --git a/Marlin/language_ru.h b/Marlin/language_ru.h
index 03ea778..bcab50b 100644
--- a/Marlin/language_ru.h
+++ b/Marlin/language_ru.h
@@ -13,7 +13,7 @@
 #define WELCOME_MSG                         MACHINE_NAME " Готов."
 #define MSG_SD_INSERTED                     "Карта вставлена"
 #define MSG_SD_REMOVED                      "Карта извлечена"
-#define MSG_MAIN                            "Меню \003"
+#define MSG_MAIN                            "Меню"
 #define MSG_AUTOSTART                       "Автостарт"
 #define MSG_DISABLE_STEPPERS                "Выкл. двигатели"
 #define MSG_AUTO_HOME                       "Парковка"
@@ -43,14 +43,14 @@
 #define MSG_MOVE_1MM                        "Move 1mm"
 #define MSG_MOVE_10MM                       "Move 10mm"
 #define MSG_SPEED                           "Скорость"
-#define MSG_NOZZLE                          "\002 Фильера"
-#define MSG_BED                             "\002 Кровать"
+#define MSG_NOZZLE                          LCD_STR_THERMOMETER " Фильера"
+#define MSG_BED                             LCD_STR_THERMOMETER " Кровать"
 #define MSG_FAN_SPEED                       "Куллер"
 #define MSG_FLOW                            "Поток"
-#define MSG_CONTROL                         "Настройки \003"
-#define MSG_MIN                             "\002 Минимум"
-#define MSG_MAX                             "\002 Максимум"
-#define MSG_FACTOR                          "\002 Фактор"
+#define MSG_CONTROL                         "Настройки"
+#define MSG_MIN                             LCD_STR_THERMOMETER " Минимум"
+#define MSG_MAX                             LCD_STR_THERMOMETER " Максимум"
+#define MSG_FACTOR                          LCD_STR_THERMOMETER " Фактор"
 #define MSG_AUTOTEMP                        "Autotemp"
 #define MSG_ON                              "Вкл. "
 #define MSG_OFF                             "Выкл. "
@@ -75,10 +75,10 @@
 #define MSG_YSTEPS                          "Y шаг/mm"
 #define MSG_ZSTEPS                          "Z шаг/mm"
 #define MSG_ESTEPS                          "E шаг/mm"
-#define MSG_TEMPERATURE                     "Температура     \x7E"
-#define MSG_MOTION                          "Скорости        \x7E"
+#define MSG_TEMPERATURE                     "Температура"
+#define MSG_MOTION                          "Скорости"
 #define MSG_VOLUMETRIC                      "Filament"
-#define MSG_VOLUMETRIC_ENABLED		        "E in mm3"
+#define MSG_VOLUMETRIC_ENABLED		          "E in mm3"
 #define MSG_FILAMENT_SIZE_EXTRUDER_0        "Fil. Dia. 1"
 #define MSG_FILAMENT_SIZE_EXTRUDER_1        "Fil. Dia. 2"
 #define MSG_FILAMENT_SIZE_EXTRUDER_2        "Fil. Dia. 3"
@@ -86,14 +86,14 @@
 #define MSG_STORE_EPROM                     "Сохранить в EPROM"
 #define MSG_LOAD_EPROM                      "Загруз. из EPROM"
 #define MSG_RESTORE_FAILSAFE                "Сброс настроек"
-#define MSG_REFRESH                         "\004Обновить"
-#define MSG_WATCH                           "Обзор           \003"
-#define MSG_PREPARE                         "Действия        \x7E"
-#define MSG_TUNE                            "Настройки       \x7E"
+#define MSG_REFRESH                         LCD_STR_REFRESH "Обновить"
+#define MSG_WATCH                           "Обзор"
+#define MSG_PREPARE                         "Действия"
+#define MSG_TUNE                            "Настройки"
 #define MSG_PAUSE_PRINT                     "Продолжить печать"
 #define MSG_RESUME_PRINT                    "возобн. печать"
 #define MSG_STOP_PRINT                      "Остановить печать"
-#define MSG_CARD_MENU                       "Меню карты      \x7E"
+#define MSG_CARD_MENU                       "Меню карты"
 #define MSG_NO_CARD                         "Нет карты"
 #define MSG_DWELL                           "Сон..."
 #define MSG_USERWAIT                        "Ожиданиие"
diff --git a/Marlin/pins.h b/Marlin/pins.h
index ea8f96c..c33fa24 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -36,7 +36,7 @@
   #include "pins_SETHI.h"
 #elif MB(RAMPS_OLD)
   #include "pins_RAMPS_OLD.h"
-#elif IS_RAMPS
+#elif MB(RAMPS_13_EFB) || MB(RAMPS_13_EEB) || MB(RAMPS_13_EFF) || MB(RAMPS_13_EEF)
   #include "pins_RAMPS_13.h"
 #elif MB(DUEMILANOVE_328P)
   #include "pins_DUEMILANOVE_328P.h"
@@ -110,6 +110,10 @@
   #include "pins_WITBOX.h"
 #elif MB(HEPHESTOS)
   #include "pins_HEPHESTOS.h"
+#elif MB(BAM_DICE)
+  #include "pins_RAMPS_13.h"
+#elif MB(BAM_DICE_DUE)
+  #include "pins_BAM_DICE_DUE.h"
 #elif MB(99)
   #include "pins_99.h"
 #else
diff --git a/Marlin/pins_3DRAG.h b/Marlin/pins_3DRAG.h
index 4191dbc..9db6b56 100644
--- a/Marlin/pins_3DRAG.h
+++ b/Marlin/pins_3DRAG.h
@@ -4,6 +4,8 @@
 
 #include "pins_RAMPS_13.h"
 
+#define Z_ENABLE_PIN       63
+
 #define X_MAX_PIN          2
 #define Y_MAX_PIN          15
 #define Z_MAX_PIN          -1
diff --git a/Marlin/pins_AZTEEG_X3.h b/Marlin/pins_AZTEEG_X3.h
index 7eb8eae..d346e0b 100644
--- a/Marlin/pins_AZTEEG_X3.h
+++ b/Marlin/pins_AZTEEG_X3.h
@@ -3,3 +3,11 @@
  */
 
 #include "pins_RAMPS_13.h"
+
+#define FAN_PIN            9 // (Sprinter config)
+#define HEATER_1_PIN       -1
+
+#ifdef TEMP_STAT_LEDS
+  #define STAT_LED_RED       6
+  #define STAT_LED_BLUE     11
+#endif
diff --git a/Marlin/pins_AZTEEG_X3_PRO.h b/Marlin/pins_AZTEEG_X3_PRO.h
index ddb055a..5d0d70d 100644
--- a/Marlin/pins_AZTEEG_X3_PRO.h
+++ b/Marlin/pins_AZTEEG_X3_PRO.h
@@ -4,6 +4,9 @@
 
 #include "pins_RAMPS_13.h"
 
+#define FAN_PIN             9 // (Sprinter config)
+#define BEEPER             33
+
 #define E2_STEP_PIN        23
 #define E2_DIR_PIN         25
 #define E2_ENABLE_PIN      40
@@ -16,15 +19,16 @@
 #define E4_DIR_PIN         37
 #define E4_ENABLE_PIN      42
 
+#define HEATER_1_PIN       -1
 #define HEATER_2_PIN       16
 #define HEATER_3_PIN       17
-#define HEATER_4_PIN       4
-#define HEATER_5_PIN       5
-#define HEATER_6_PIN       6
+#define HEATER_4_PIN        4
+#define HEATER_5_PIN        5
+#define HEATER_6_PIN        6
 #define HEATER_7_PIN       11
 
 #define TEMP_2_PIN         12   // ANALOG NUMBERING
 #define TEMP_3_PIN         11   // ANALOG NUMBERING
 #define TEMP_4_PIN         10   // ANALOG NUMBERING
-#define TC1                4    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
-#define TC2                5    // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+#define TC1                 4   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+#define TC2                 5   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
diff --git a/Marlin/pins_BAM_DICE_DUE.h b/Marlin/pins_BAM_DICE_DUE.h
new file mode 100644
index 0000000..c3123d0
--- /dev/null
+++ b/Marlin/pins_BAM_DICE_DUE.h
@@ -0,0 +1,11 @@
+/**
+ * BAM&DICE Due (Arduino Mega) pin assignments
+ */
+
+#include "pins_RAMPS_13.h"
+
+#define FAN_PIN             9 // (Sprinter config)
+#define HEATER_1_PIN       -1
+
+#define TEMP_0_PIN          9 // ANALOG NUMBERING
+#define TEMP_1_PIN         11 // ANALOG NUMBERING
diff --git a/Marlin/pins_HEPHESTOS.h b/Marlin/pins_HEPHESTOS.h
index c5b7bcf..8fc5ba6 100644
--- a/Marlin/pins_HEPHESTOS.h
+++ b/Marlin/pins_HEPHESTOS.h
@@ -3,3 +3,6 @@
  */
 
 #include "pins_RAMPS_13.h"
+
+#define FAN_PIN             9 // (Sprinter config)
+#define HEATER_1_PIN       -1
diff --git a/Marlin/pins_MEGATRONICS_3.h b/Marlin/pins_MEGATRONICS_3.h
index 2cf0a89..3c53bca 100644
--- a/Marlin/pins_MEGATRONICS_3.h
+++ b/Marlin/pins_MEGATRONICS_3.h
@@ -8,6 +8,20 @@
 
 #define LARGE_FLASH        true
 
+// Servo support
+#ifdef NUM_SERVOS
+  #define SERVO0_PIN       46 //AUX3-6
+  #if NUM_SERVOS > 1
+    #define SERVO1_PIN     47 //AUX3-5
+    #if NUM_SERVOS > 2
+      #define SERVO2_PIN   48 //AUX3-4
+      #if NUM_SERVOS > 3
+        #define SERVO2_PIN 49 //AUX3-3
+      #endif
+    #endif
+  #endif
+#endif
+
 #define X_STEP_PIN         58
 #define X_DIR_PIN          57
 #define X_ENABLE_PIN       59
diff --git a/Marlin/pins_RAMPS_13.h b/Marlin/pins_RAMPS_13.h
index e2f74fc..840804a 100644
--- a/Marlin/pins_RAMPS_13.h
+++ b/Marlin/pins_RAMPS_13.h
@@ -7,10 +7,8 @@
  *  RAMPS_13_EEB (Extruder, Extruder, Bed)
  *  RAMPS_13_EFF (Extruder, Fan, Fan)
  *  RAMPS_13_EEF (Extruder, Extruder, Fan)
- *  3DRAG
- *  K8200
- *  AZTEEG_X3
- *  AZTEEG_X3_PRO
+ *
+ *  Other pins_MYBOARD.h files may override these defaults
  */
 
 #if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)
@@ -63,7 +61,7 @@
   #define FILWIDTH_PIN        5
 #endif
 
-#if MB(RAMPS_13_EFB) || MB(RAMPS_13_EFF) || MB(AZTEEG_X3) || MB(AZTEEG_X3_PRO) || MB(WITBOX) || MB(HEPHESTOS)
+#if MB(RAMPS_13_EFB) || MB(RAMPS_13_EFF)
   #define FAN_PIN            9 // (Sprinter config)
   #if MB(RAMPS_13_EFF)
     #define CONTROLLERFAN_PIN  -1 // Pin used for the fan to cool controller
@@ -88,7 +86,7 @@
   #define HEATER_0_PIN       10   // EXTRUDER 1
 #endif
 
-#if MB(RAMPS_13_EFB) || MB(AZTEEG_X3) || MB(WITBOX) || MB(HEPHESTOS)
+#if MB(RAMPS_13_EFB)
   #define HEATER_1_PIN       -1
 #else
   #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)
@@ -110,28 +108,14 @@
 
 #ifdef NUM_SERVOS
   #define SERVO0_PIN         11
-
   #if NUM_SERVOS > 1
-    #define SERVO1_PIN         6
-  #endif
-
-  #if NUM_SERVOS > 2
-    #define SERVO2_PIN         5
-  #endif
-
-  #if NUM_SERVOS > 3
-    #define SERVO3_PIN         4
-  #endif
-#endif
-
-#if MB(AZTEEG_X3_PRO)
-  #define BEEPER 33
-#endif
-
-#ifdef TEMP_STAT_LEDS
-  #if MB(AZTEEG_X3)
-    #define STAT_LED_RED       6
-    #define STAT_LED_BLUE     11
+    #define SERVO1_PIN        6
+    #if NUM_SERVOS > 2
+      #define SERVO2_PIN      5
+      #if NUM_SERVOS > 3
+        #define SERVO3_PIN    4
+      #endif
+    #endif
   #endif
 #endif
 
diff --git a/Marlin/pins_WITBOX.h b/Marlin/pins_WITBOX.h
index 4deda2c..a4eb0e3 100644
--- a/Marlin/pins_WITBOX.h
+++ b/Marlin/pins_WITBOX.h
@@ -3,3 +3,6 @@
  */
 
 #include "pins_RAMPS_13.h"
+
+#define FAN_PIN             9 // (Sprinter config)
+#define HEATER_1_PIN       -1
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index fe50e37..8e49d2b 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -43,7 +43,7 @@ block_t *current_block;  // A pointer to the block currently being traced
 //===========================================================================
 //=============================private variables ============================
 //===========================================================================
-//static makes it inpossible to be called from outside of this file by extern.!
+//static makes it impossible to be called from outside of this file by extern.!
 
 // Variables used by The Stepper Driver Interrupt
 static unsigned char out_bits;        // The next stepping-bits to be output
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index d5bd2d6..d50c426 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -455,19 +455,17 @@ void checkExtruderAutoFans()
     setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);
   #endif 
   #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
-    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) 
+    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN)
       setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);
   #endif 
   #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
-    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN 
-        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN)
+    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN
         && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)
       setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);
   #endif
   #if defined(EXTRUDER_3_AUTO_FAN_PIN) && EXTRUDER_3_AUTO_FAN_PIN > -1
-    if (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN 
-        && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN)
-        && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)
+    if (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN
+        && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN
         && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_2_AUTO_FAN_PIN)
       setExtruderAutoFanState(EXTRUDER_3_AUTO_FAN_PIN, (fanState & 8) != 0);
   #endif
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 599d0d0..aa1019b 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -1095,6 +1095,16 @@ const short temptable_1047[][2] PROGMEM = {
 };
 #endif
 
+#if (THERMISTORHEATER_0 == 999) || (THERMISTORHEATER_1 == 999) || (THERMISTORHEATER_2 == 999) || (THERMISTORHEATER_3 == 999) || (THERMISTORBED == 999) //User defined table
+// Dummy Thermistor table.. It will ALWAYS read 25C.
+const short temptable_999[][2] PROGMEM = {
+   {1*OVERSAMPLENR, 25},
+   {1023*OVERSAMPLENR, 25}
+};
+#endif
+
+
+
 #define _TT_NAME(_N) temptable_ ## _N
 #define TT_NAME(_N) _TT_NAME(_N)
 
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 3773ad3..2726547 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -10,6 +10,9 @@
 
 int8_t encoderDiff; /* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */
 
+bool encoderRateMultiplierEnabled;
+int32_t lastEncoderMovementMillis;
+
 /* Configuration settings */
 int plaPreheatHotendTemp;
 int plaPreheatHPBTemp;
@@ -41,11 +44,6 @@ char lcd_status_message[LCD_WIDTH+1] = WELCOME_MSG;
 #include "ultralcd_implementation_hitachi_HD44780.h"
 #endif
 
-/** forward declarations **/
-
-void copy_and_scalePID_i();
-void copy_and_scalePID_d();
-
 /* Different menus */
 static void lcd_status_screen();
 #ifdef ULTIPANEL
@@ -119,6 +117,7 @@ static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned l
 
 /* Helper macros for menus */
 #define START_MENU() do { \
+	encoderRateMultiplierEnabled = false; \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
     if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM < currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\
     uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
@@ -143,9 +142,39 @@ static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned l
     }\
     _menuItemNr++;\
 } while(0)
+#ifdef ENCODER_RATE_MULTIPLIER
+  #define MENU_MULTIPLIER_ITEM(type, label, args...) do { \
+    if (_menuItemNr == _lineNr) { \
+      if (lcdDrawUpdate) { \
+        const char* _label_pstr = PSTR(label); \
+        if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
+          lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \
+        } \
+        else { \
+          lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \
+        } \
+      } \
+      if (wasClicked && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
+        lcd_quick_feedback(); \
+        encoderRateMultiplierEnabled = true; \
+        lastEncoderMovementMillis = 0; \
+        menu_action_ ## type ( args ); \
+        return; \
+      } \
+    } \
+    _menuItemNr++; \
+  } while(0)
+#endif //ENCODER_RATE_MULTIPLIER
 #define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)
 #define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label) , ## args )
 #define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label) , ## args )
+#ifdef ENCODER_RATE_MULTIPLIER
+  #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label) , ## args )
+  #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label) , ## args )
+#else //!ENCODER_RATE_MULTIPLIER
+  #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label) , ## args )
+  #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label) , ## args )
+#endif //!ENCODER_RATE_MULTIPLIER
 #define END_MENU() \
     if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM >= _menuItemNr) encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; \
     if ((uint8_t)(encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) >= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \
@@ -185,9 +214,8 @@ void* editValue;
 int32_t minEditValue, maxEditValue;
 menuFunc_t callbackFunc;
 
-// place-holders for Ki and Kd edits, and the extruder # being edited
+// place-holders for Ki and Kd edits
 float raw_Ki, raw_Kd;
-int pid_current_extruder;
 
 static void lcd_goto_menu(menuFunc_t menu, const uint32_t encoder=0, const bool feedback=true) {
   if (currentMenu != menu) {
@@ -205,6 +233,7 @@ static void lcd_goto_menu(menuFunc_t menu, const uint32_t encoder=0, const bool
 /* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependent */
 static void lcd_status_screen()
 {
+	encoderRateMultiplierEnabled = false;
   #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && !defined(DOGLCD)
     uint16_t mil = millis();
     #ifndef PROGRESS_MSG_ONCE
@@ -233,15 +262,15 @@ static void lcd_status_screen()
     #endif
   #endif //LCD_PROGRESS_BAR
 
-    if (lcd_status_update_delay)
-        lcd_status_update_delay--;
-    else
-        lcdDrawUpdate = 1;
+  if (lcd_status_update_delay)
+    lcd_status_update_delay--;
+  else
+    lcdDrawUpdate = 1;
 
-    if (lcdDrawUpdate) {
-        lcd_implementation_status_screen();
-        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
-    }
+  if (lcdDrawUpdate) {
+    lcd_implementation_status_screen();
+    lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
+  }
 
 #ifdef ULTIPANEL
 
@@ -317,86 +346,82 @@ static void lcd_sdcard_pause() { card.pauseSDPrint(); }
 
 static void lcd_sdcard_resume() { card.startFileprint(); }
 
-static void lcd_sdcard_stop()
-{
-    card.sdprinting = false;
-    card.closefile();
-    quickStop();
-    if(SD_FINISHED_STEPPERRELEASE)
-    {
-        enquecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-    }
-    autotempShutdown();
+static void lcd_sdcard_stop() {
+  card.sdprinting = false;
+  card.closefile();
+  quickStop();
+  if (SD_FINISHED_STEPPERRELEASE) {
+    enquecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+  }
+  autotempShutdown();
 
-	cancel_heatup = true;
+  cancel_heatup = true;
 
-	lcd_setstatus(MSG_PRINT_ABORTED);
+  lcd_setstatus(MSG_PRINT_ABORTED);
 }
 
 /* Menu implementation */
-static void lcd_main_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_WATCH, lcd_status_screen);
-    if (movesplanned() || IS_SD_PRINTING)
-    {
-        MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
-    }else{
-        MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
-#ifdef DELTA_CALIBRATION_MENU
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
-#endif // DELTA_CALIBRATION_MENU
+static void lcd_main_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_WATCH, lcd_status_screen);
+  if (movesplanned() || IS_SD_PRINTING) {
+    MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+  }
+  else {
+    MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
+    #ifdef DELTA_CALIBRATION_MENU
+      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
+    #endif
+  }
+  MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
+
+  #ifdef SDSUPPORT
+    if (card.cardOK) {
+      if (card.isFileOpen()) {
+        if (card.sdprinting)
+          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
+        else
+          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
+        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+      }
+      else {
+        MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
+        #if SDCARDDETECT < 1
+          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+        #endif
+      }
     }
-/*JFR TEST*/            MENU_ITEM(gcode, "test multiline", PSTR("G4 S3\nM104 S50\nG4 S1\nM104 S200\nG4 S2\nM104 S0"));  // SD-card changed by user
-    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
-#ifdef SDSUPPORT
-    if (card.cardOK)
-    {
-        if (card.isFileOpen())
-        {
-            if (card.sdprinting)
-                MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
-            else
-                MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
-            MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
-        }else{
-            MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
-#if SDCARDDETECT < 1
-            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
-#endif
-        }
-    }else{
-        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
-#if SDCARDDETECT < 1
+    else {
+      MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
+      #if SDCARDDETECT < 1
         MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
-#endif
+      #endif
     }
-#endif
-    END_MENU();
+  #endif //SDSUPPORT
+
+  END_MENU();
 }
 
 #ifdef SDSUPPORT
-static void lcd_autostart_sd()
-{
-    card.autostart_index=0;
+  static void lcd_autostart_sd() {
+    card.autostart_index = 0;
     card.setroot();
     card.checkautostart(true);
-}
+  }
 #endif
 
-void lcd_set_home_offsets()
-{
-    for(int8_t i=0; i < NUM_AXIS; i++) {
-      if (i != E_AXIS) {
-        add_homing[i] -= current_position[i];
-        current_position[i] = 0.0;
-      }
+void lcd_set_home_offsets() {
+  for(int8_t i=0; i < NUM_AXIS; i++) {
+    if (i != E_AXIS) {
+      add_homing[i] -= current_position[i];
+      current_position[i] = 0.0;
     }
-    plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);
+  }
+  plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);
 
-    // Audio feedback
-    enquecommands_P(PSTR("M300 S659 P200\nM300 S698 P200"));
-    lcd_return_to_status();
+  // Audio feedback
+  enquecommands_P(PSTR("M300 S659 P200\nM300 S698 P200"));
+  lcd_return_to_status();
 }
 
 
@@ -417,274 +442,181 @@ void lcd_set_home_offsets()
 
 #endif //BABYSTEPPING
 
-static void lcd_tune_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
-    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);
-#if TEMP_SENSOR_0 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_1 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE " 2", &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_2 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE " 3", &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_3 != 0
-    MENU_ITEM_EDIT(int3, MSG_NOZZLE " 4", &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);
-#endif
-
-
-#if TEMP_SENSOR_BED != 0
-    MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
-#endif
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
+static void lcd_tune_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);
+  #if TEMP_SENSOR_0 != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+  #endif
+  #if TEMP_SENSOR_1 != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
+  #endif
+  #if TEMP_SENSOR_2 != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
+  #endif
+  #if TEMP_SENSOR_3 != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);
+  #endif
+  #if TEMP_SENSOR_BED != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
+  #endif
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
     MENU_ITEM_EDIT(int3, MSG_FLOW, &extrudemultiply, 10, 999);
-    MENU_ITEM_EDIT(int3, MSG_FLOW " 0", &extruder_multiply[0], 10, 999);
-#if TEMP_SENSOR_1 != 0
-    MENU_ITEM_EDIT(int3, MSG_FLOW " 1", &extruder_multiply[1], 10, 999);
-#endif
-#if TEMP_SENSOR_2 != 0
-    MENU_ITEM_EDIT(int3, MSG_FLOW " 2", &extruder_multiply[2], 10, 999);
-#endif
-#if TEMP_SENSOR_3 != 0
-    MENU_ITEM_EDIT(int3, MSG_FLOW " 3", &extruder_multiply[3], 10, 999);
-#endif
-
+    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_F0, &extruder_multiply[0], 10, 999);
+  #if TEMP_SENSOR_1 != 0
+    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_F1, &extruder_multiply[1], 10, 999);
+  #endif
+  #if TEMP_SENSOR_2 != 0
+    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_F2, &extruder_multiply[2], 10, 999);
+  #endif
+  #if TEMP_SENSOR_3 != 0
+    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_F3, &extruder_multiply[3], 10, 999);
+  #endif
 
-#ifdef BABYSTEPPING
+  #ifdef BABYSTEPPING
     #ifdef BABYSTEP_XY
       MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
       MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
     #endif //BABYSTEP_XY
     MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
-#endif
-#ifdef FILAMENTCHANGEENABLE
+  #endif
+  #ifdef FILAMENTCHANGEENABLE
      MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));
-#endif
-    END_MENU();
-}
-
-void lcd_preheat_pla0()
-{
-    setTargetHotend0(plaPreheatHotendTemp);
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
+  #endif
+  END_MENU();
 }
 
-void lcd_preheat_abs0()
-{
-    setTargetHotend0(absPreheatHotendTemp);
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
+void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {
+  if (temph > 0) setTargetHotend(temph, endnum);
+  setTargetBed(tempb);
+  fanSpeed = fan;
+  lcd_return_to_status();
+  setWatch(); // heater sanity check timer
 }
+void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
 
 #if TEMP_SENSOR_1 != 0 //2nd extruder preheat
-void lcd_preheat_pla1()
-{
-    setTargetHotend1(plaPreheatHotendTemp);
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
-void lcd_preheat_abs1()
-{
-    setTargetHotend1(absPreheatHotendTemp);
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
+  void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+  void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
 #endif //2nd extruder preheat
 
 #if TEMP_SENSOR_2 != 0 //3 extruder preheat
-void lcd_preheat_pla2()
-{
-    setTargetHotend2(plaPreheatHotendTemp);
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
-void lcd_preheat_abs2()
-{
-    setTargetHotend2(absPreheatHotendTemp);
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
+  void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+  void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
 #endif //3 extruder preheat
 
 #if TEMP_SENSOR_3 != 0 //4 extruder preheat
-void lcd_preheat_pla3()
-{
-    setTargetHotend3(plaPreheatHotendTemp);
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
-void lcd_preheat_abs3()
-{
-    setTargetHotend3(absPreheatHotendTemp);
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
+  void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+  void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
 #endif //4 extruder preheat
 
 #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 //more than one extruder present
-void lcd_preheat_pla0123()
-{
+  void lcd_preheat_pla0123() {
     setTargetHotend0(plaPreheatHotendTemp);
     setTargetHotend1(plaPreheatHotendTemp);
     setTargetHotend2(plaPreheatHotendTemp);
-    setTargetHotend3(plaPreheatHotendTemp);
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
-void lcd_preheat_abs0123()
-{
+    _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);
+  }
+  void lcd_preheat_abs0123() {
     setTargetHotend0(absPreheatHotendTemp);
     setTargetHotend1(absPreheatHotendTemp);
     setTargetHotend2(absPreheatHotendTemp);
-    setTargetHotend3(absPreheatHotendTemp);
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
+    _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);
+  }
 #endif //more than one extruder present
 
-void lcd_preheat_pla_bedonly()
-{
-    setTargetBed(plaPreheatHPBTemp);
-    fanSpeed = plaPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
+void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }
+void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }
 
-void lcd_preheat_abs_bedonly()
-{
-    setTargetBed(absPreheatHPBTemp);
-    fanSpeed = absPreheatFanSpeed;
-    lcd_return_to_status();
-    setWatch(); // heater sanity check timer
-}
-
-static void lcd_preheat_pla_menu()
-{
+static void lcd_preheat_pla_menu() {
   START_MENU();
   MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
-  MENU_ITEM(function, MSG_PREHEAT_PLA_N "1", lcd_preheat_pla0);
-#if TEMP_SENSOR_1 != 0 //2 extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_PLA_N "2", lcd_preheat_pla1);
-#endif //2 extruder preheat
-#if TEMP_SENSOR_2 != 0 //3 extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_PLA_N "3", lcd_preheat_pla2);
-#endif //3 extruder preheat
-#if TEMP_SENSOR_3 != 0 //4 extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_PLA_N "4", lcd_preheat_pla3);
-#endif //4 extruder preheat
-#if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 //all extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
-#endif //all extruder preheat
-#if TEMP_SENSOR_BED != 0
-  MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);
-#endif
+  MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);
+  #if TEMP_SENSOR_1 != 0 //2 extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);
+  #endif //2 extruder preheat
+  #if TEMP_SENSOR_2 != 0 //3 extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);
+  #endif //3 extruder preheat
+  #if TEMP_SENSOR_3 != 0 //4 extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);
+  #endif //4 extruder preheat
+  #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 //all extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
+  #endif //all extruder preheat
+  #if TEMP_SENSOR_BED != 0
+    MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);
+  #endif
   END_MENU();
 }
 
-static void lcd_preheat_abs_menu()
-{
+static void lcd_preheat_abs_menu() {
   START_MENU();
   MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
-  MENU_ITEM(function, MSG_PREHEAT_ABS_N "1", lcd_preheat_abs0);
-#if TEMP_SENSOR_1 != 0 //2 extruder preheat
-	MENU_ITEM(function, MSG_PREHEAT_ABS_N "2", lcd_preheat_abs1);
-#endif //2 extruder preheat
-#if TEMP_SENSOR_2 != 0 //3 extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_ABS_N "3", lcd_preheat_abs2);
-#endif //3 extruder preheat
-#if TEMP_SENSOR_3 != 0 //4 extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_ABS_N "4", lcd_preheat_abs3);
-#endif //4 extruder preheat
-#if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 //all extruder preheat
-  MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
-#endif //all extruder preheat
-
-#if TEMP_SENSOR_BED != 0
- MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);
-#endif
+  MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);
+  #if TEMP_SENSOR_1 != 0 //2 extruder preheat
+	  MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);
+  #endif //2 extruder preheat
+  #if TEMP_SENSOR_2 != 0 //3 extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);
+  #endif //3 extruder preheat
+  #if TEMP_SENSOR_3 != 0 //4 extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);
+  #endif //4 extruder preheat
+  #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 //all extruder preheat
+    MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
+  #endif //all extruder preheat
+  #if TEMP_SENSOR_BED != 0
+    MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);
+  #endif
   END_MENU();
 }
 
-void lcd_cooldown()
-{
-    setTargetHotend0(0);
-    setTargetHotend1(0);
-    setTargetHotend2(0);
-    setTargetHotend3(0);
-    setTargetBed(0);
-    fanSpeed = 0;
-    lcd_return_to_status();
+void lcd_cooldown() {
+  setTargetHotend0(0);
+  setTargetHotend1(0);
+  setTargetHotend2(0);
+  setTargetHotend3(0);
+  setTargetBed(0);
+  fanSpeed = 0;
+  lcd_return_to_status();
 }
 
-static void lcd_prepare_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
-#ifdef SDSUPPORT
+static void lcd_prepare_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+  #ifdef SDSUPPORT
     #ifdef MENU_ADDAUTOSTART
       MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
     #endif
-#endif
-    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
-    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-    MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-    //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
-#if TEMP_SENSOR_0 != 0
-  #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0
-    MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
-    MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
-  #else
-    MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
-    MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
   #endif
-#endif
-    MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
-#if PS_ON_PIN > -1
-    if (powersupply)
-    {
-        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
-    }else{
-        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
+  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+  MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
+  //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
+  #if TEMP_SENSOR_0 != 0
+    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0
+      MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
+      MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
+    #else
+      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
+      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
+    #endif
+  #endif
+  MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+  #if defined(POWER_SUPPLY) && POWER_SUPPLY > 0 && defined(PS_ON_PIN) && PS_ON_PIN > -1
+    if (powersupply) {
+      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
     }
-#endif
-    MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
-		
-    // JFR for RMud delta printer
-    MENU_ITEM(gcode, "Calibrate bed", PSTR("M702\nG28\nG1 X-77.94 Y-45 Z36 F8000\nG4 S3\nM701 P0\nG1 X77.94 Y-45 Z36\nG4 S3\nM701 P1\nG1 X0 Y90 Z36\nG4 S3\nM701 P2\nM700\nG1 X0 Y0 Z100 F8000"));
-    MENU_ITEM(gcode, "Check level", PSTR("G28\nG1 X0 Y0 Z1 F4000\nG1 X-77.94 Y-45 Z1\nG1 X77.94 Y-45\nG1 X0 Y90\nG1 X-77.94 Y-45\nG4 S2\nG1 X-77.94 Y-45 Z0.3 F2000\nG1 X-77.94 Y-45\nG1 X77.94 Y-45\nG1 X0 Y90\nG1 X-77.94 Y-45\nG1 X0 Y0 Z0"));
-    MENU_ITEM(gcode, "Retract filament", PSTR("M302\nM82\nG92 E0\nG1 F4000 E-800"));
-    MENU_ITEM(gcode, "Insert filament", PSTR("M302\nM82\nG92 E0\nG1 F4000 E60"));
-    MENU_ITEM(gcode, "Finalize filament", PSTR("G1 F4000 E790"));
-    END_MENU();
+    else {
+      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+    }
+  #endif
+  MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
+	
+  END_MENU();
 }
 
 #ifdef DELTA_CALIBRATION_MENU
@@ -726,394 +658,409 @@ static void lcd_move_x() { _lcd_move(PSTR("X"), X_AXIS, X_MIN_POS, X_MAX_POS); }
 static void lcd_move_y() { _lcd_move(PSTR("Y"), Y_AXIS, Y_MIN_POS, Y_MAX_POS); }
 static void lcd_move_z() { _lcd_move(PSTR("Z"), Z_AXIS, Z_MIN_POS, Z_MAX_POS); }
 
-static void lcd_move_e()
-{
-    if (encoderPosition != 0)
-    {
-        current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        encoderPosition = 0;
-        #ifdef DELTA
-        calculate_delta(current_position);
-        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
-        #else
-        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
-        #endif
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));
-    }
-    if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
+static void lcd_move_e() {
+  if (encoderPosition != 0) {
+    current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;
+    encoderPosition = 0;
+    #ifdef DELTA
+      calculate_delta(current_position);
+      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
+    #else
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
+    #endif
+    lcdDrawUpdate = 1;
+  }
+  if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));
+  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
 }
 
-static void lcd_move_menu_axis()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);
-    MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
-    MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
-    if (move_menu_scale < 10.0)
-    {
-        MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
-        MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
-    }
-    END_MENU();
+static void lcd_move_menu_axis() {
+  START_MENU();
+  MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);
+  MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
+  MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
+  if (move_menu_scale < 10.0) {
+    MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
+    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
+  }
+  END_MENU();
 }
 
-static void lcd_move_menu_10mm()
-{
-    move_menu_scale = 10.0;
-    lcd_move_menu_axis();
+static void lcd_move_menu_10mm() {
+  move_menu_scale = 10.0;
+  lcd_move_menu_axis();
 }
-static void lcd_move_menu_1mm()
-{
-    move_menu_scale = 1.0;
-    lcd_move_menu_axis();
+static void lcd_move_menu_1mm() {
+  move_menu_scale = 1.0;
+  lcd_move_menu_axis();
 }
-static void lcd_move_menu_01mm()
-{
-    move_menu_scale = 0.1;
-    lcd_move_menu_axis();
+static void lcd_move_menu_01mm() {
+  move_menu_scale = 0.1;
+  lcd_move_menu_axis();
 }
 
-static void lcd_move_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
-    MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
-    MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
-    MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
-    //TODO:X,Y,Z,E
-    END_MENU();
+static void lcd_move_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);
+  MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
+  MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
+  MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
+  //TODO:X,Y,Z,E
+  END_MENU();
 }
 
-static void lcd_control_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
-    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
-    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
-    MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
+static void lcd_control_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+  MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
+  MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
+  MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
 
-#ifdef DOGLCD
-//    MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
+  #ifdef DOGLCD
+    //MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
     MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);
-#endif
-#ifdef FWRETRACT
+  #endif
+  #ifdef FWRETRACT
     MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
-#endif
-#ifdef EEPROM_SETTINGS
+  #endif
+  #ifdef EEPROM_SETTINGS
     MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
     MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);
-#endif
-    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);
-    END_MENU();
+  #endif
+  MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);
+  END_MENU();
 }
 
-static void lcd_control_temperature_menu()
-{
+#ifdef PIDTEMP
+
+  // Helpers for editing PID Ki & Kd values
+  // grab the PID value out of the temp variable; scale it; then update the PID driver
+  void copy_and_scalePID_i(int e) {
+    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
+    updatePID();
+  }
+  void copy_and_scalePID_d(int e) {
+    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
+    updatePID();
+  }
+  void copy_and_scalePID_i_E1() { copy_and_scalePID_i(0); }
+  void copy_and_scalePID_d_E1() { copy_and_scalePID_d(0); }
+  #ifdef PID_PARAMS_PER_EXTRUDER
+    #if EXTRUDERS > 1
+      void copy_and_scalePID_i_E2() { copy_and_scalePID_i(1); }
+      void copy_and_scalePID_d_E2() { copy_and_scalePID_d(1); }
+      #if EXTRUDERS > 2
+        void copy_and_scalePID_i_E3() { copy_and_scalePID_i(2); }
+        void copy_and_scalePID_d_E3() { copy_and_scalePID_d(2); }
+        #if EXTRUDERS > 3
+          void copy_and_scalePID_i_E4() { copy_and_scalePID_i(3); }
+          void copy_and_scalePID_d_E4() { copy_and_scalePID_d(3); }
+        #endif //EXTRUDERS > 3
+      #endif //EXTRUDERS > 2
+    #endif //EXTRUDERS > 1
+  #endif //PID_PARAMS_PER_EXTRUDER
+
+#endif //PIDTEMP
+
+static void lcd_control_temperature_menu() {
   START_MENU();
   MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
-#if TEMP_SENSOR_0 != 0
-  MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_1 != 0 && EXTRUDERS > 1
-  MENU_ITEM_EDIT(int3, MSG_NOZZLE " 2", &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_2 != 0 && EXTRUDERS > 2
-  MENU_ITEM_EDIT(int3, MSG_NOZZLE " 3", &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_3 != 0 && EXTRUDERS > 3
-  MENU_ITEM_EDIT(int3, MSG_NOZZLE " 4", &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_BED != 0
-  MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
-#endif
-  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
-#if defined AUTOTEMP && (TEMP_SENSOR_0 != 0)
-  MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);
-  MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);
-  MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);
-  MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);
-#endif
-#ifdef PIDTEMP
-	// set up temp variables - undo the default scaling
-	pid_current_extruder = 0;
-	raw_Ki = unscalePID_i(PID_PARAM(Ki,0));
-	raw_Kd = unscalePID_d(PID_PARAM(Kd,0));
-	MENU_ITEM_EDIT(float52, MSG_PID_P, &PID_PARAM(Kp,0), 1, 9990);
-	// i is typically a small value so allows values below 1
-	MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
-	MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d);
+  #if TEMP_SENSOR_0 != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
+  #endif
+  #if EXTRUDERS > 1
+    #if TEMP_SENSOR_1 != 0
+      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
+    #endif
+    #if EXTRUDERS > 2
+      #if TEMP_SENSOR_2 != 0
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
+      #endif
+      #if EXTRUDERS > 3
+        #if TEMP_SENSOR_3 != 0
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);
+        #endif
+      #endif // EXTRUDERS > 3
+    #endif // EXTRUDERS > 2
+  #endif // EXTRUDERS > 1
+  #if TEMP_SENSOR_BED != 0
+    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
+  #endif
+  MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
+  #if defined(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
+    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);
+    MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);
+    MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);
+    MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);
+  #endif
+  #ifdef PIDTEMP
+    // set up temp variables - undo the default scaling
+    raw_Ki = unscalePID_i(PID_PARAM(Ki,0));
+    raw_Kd = unscalePID_d(PID_PARAM(Kd,0));
+    MENU_ITEM_EDIT(float52, MSG_PID_P, &PID_PARAM(Kp,0), 1, 9990);
+    // i is typically a small value so allows values below 1
+    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E1);
+    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d_E1);
     #ifdef PID_ADD_EXTRUSION_RATE
-	  MENU_ITEM_EDIT(float3, MSG_PID_C, &PID_PARAM(Kc,0), 1, 9990);
+      MENU_ITEM_EDIT(float3, MSG_PID_C, &PID_PARAM(Kc,0), 1, 9990);
     #endif//PID_ADD_EXTRUSION_RATE
-#ifdef PID_PARAMS_PER_EXTRUDER
-  #if EXTRUDERS > 1
-	  // set up temp variables - undo the default scaling
-	  pid_current_extruder = 0;
-	  raw_Ki = unscalePID_i(PID_PARAM(Ki,1));
-	  raw_Kd = unscalePID_d(PID_PARAM(Kd,1));
-	  MENU_ITEM_EDIT(float52, MSG_PID_P " E2", &PID_PARAM(Kp,1), 1, 9990);
-	  // i is typically a small value so allows values below 1
-	  MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I " E2", &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
-	  MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D " E2", &raw_Kd, 1, 9990, copy_and_scalePID_d);
-      #ifdef PID_ADD_EXTRUSION_RATE
-	    MENU_ITEM_EDIT(float3, MSG_PID_C " E2", &PID_PARAM(Kc,1), 1, 9990);
-      #endif//PID_ADD_EXTRUSION_RATE
-  #endif//EXTRUDERS > 1
-  #if EXTRUDERS > 2
-	    // set up temp variables - undo the default scaling
-	    pid_current_extruder = 0;
-	    raw_Ki = unscalePID_i(PID_PARAM(Ki,2));
-	    raw_Kd = unscalePID_d(PID_PARAM(Kd,2));
-	    MENU_ITEM_EDIT(float52, MSG_PID_P " E3", &PID_PARAM(Kp,2), 1, 9990);
-	    // i is typically a small value so allows values below 1
-	    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I " E3", &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
-	    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D " E3", &raw_Kd, 1, 9990, copy_and_scalePID_d);
+    #ifdef PID_PARAMS_PER_EXTRUDER
+      #if EXTRUDERS > 1
+        // set up temp variables - undo the default scaling
+        raw_Ki = unscalePID_i(PID_PARAM(Ki,1));
+        raw_Kd = unscalePID_d(PID_PARAM(Kd,1));
+        MENU_ITEM_EDIT(float52, MSG_PID_P MSG_E2, &PID_PARAM(Kp,1), 1, 9990);
+        // i is typically a small value so allows values below 1
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I MSG_E2, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E2);
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D MSG_E2, &raw_Kd, 1, 9990, copy_and_scalePID_d_E2);
         #ifdef PID_ADD_EXTRUSION_RATE
-	      MENU_ITEM_EDIT(float3, MSG_PID_C " E3", &PID_PARAM(Kc,2), 1, 9990);
+          MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E2, &PID_PARAM(Kc,1), 1, 9990);
         #endif//PID_ADD_EXTRUSION_RATE
-  #endif//EXTRUDERS > 2
-#endif // PID_PARAMS_PER_EXTRUDER
-#endif//PIDTEMP
-    MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
-    MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
-    END_MENU();
+
+        #if EXTRUDERS > 2
+          // set up temp variables - undo the default scaling
+          raw_Ki = unscalePID_i(PID_PARAM(Ki,2));
+          raw_Kd = unscalePID_d(PID_PARAM(Kd,2));
+          MENU_ITEM_EDIT(float52, MSG_PID_P MSG_E3, &PID_PARAM(Kp,2), 1, 9990);
+          // i is typically a small value so allows values below 1
+          MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I MSG_E3, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E3);
+          MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D MSG_E3, &raw_Kd, 1, 9990, copy_and_scalePID_d_E3);
+          #ifdef PID_ADD_EXTRUSION_RATE
+            MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E3, &PID_PARAM(Kc,2), 1, 9990);
+          #endif//PID_ADD_EXTRUSION_RATE
+
+          #if EXTRUDERS > 3
+            // set up temp variables - undo the default scaling
+            raw_Ki = unscalePID_i(PID_PARAM(Ki,3));
+            raw_Kd = unscalePID_d(PID_PARAM(Kd,3));
+            MENU_ITEM_EDIT(float52, MSG_PID_P MSG_E4, &PID_PARAM(Kp,3), 1, 9990);
+            // i is typically a small value so allows values below 1
+            MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I MSG_E4, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E4);
+            MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D MSG_E4, &raw_Kd, 1, 9990, copy_and_scalePID_d_E4);
+            #ifdef PID_ADD_EXTRUSION_RATE
+              MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E4, &PID_PARAM(Kc,3), 1, 9990);
+            #endif//PID_ADD_EXTRUSION_RATE
+          #endif//EXTRUDERS > 3
+        #endif//EXTRUDERS > 2
+      #endif//EXTRUDERS > 1
+    #endif //PID_PARAMS_PER_EXTRUDER
+  #endif//PIDTEMP
+  MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);
+  MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);
+  END_MENU();
 }
 
-static void lcd_control_temperature_preheat_pla_settings_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
-#if TEMP_SENSOR_0 != 0
+static void lcd_control_temperature_preheat_pla_settings_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
+  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);
+  #if TEMP_SENSOR_0 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_BED != 0
+  #endif
+  #if TEMP_SENSOR_BED != 0
     MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, 0, BED_MAXTEMP - 15);
-#endif
-#ifdef EEPROM_SETTINGS
+  #endif
+  #ifdef EEPROM_SETTINGS
     MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-#endif
-    END_MENU();
+  #endif
+  END_MENU();
 }
 
-static void lcd_control_temperature_preheat_abs_settings_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
-#if TEMP_SENSOR_0 != 0
+static void lcd_control_temperature_preheat_abs_settings_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);
+  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);
+  #if TEMP_SENSOR_0 != 0
     MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
-#endif
-#if TEMP_SENSOR_BED != 0
+  #endif
+  #if TEMP_SENSOR_BED != 0
     MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, 0, BED_MAXTEMP - 15);
-#endif
-#ifdef EEPROM_SETTINGS
+  #endif
+  #ifdef EEPROM_SETTINGS
     MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-#endif
-    END_MENU();
+  #endif
+  END_MENU();
 }
 
-static void lcd_control_motion_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
-#ifdef ENABLE_AUTO_BED_LEVELING
+static void lcd_control_motion_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+  #ifdef ENABLE_AUTO_BED_LEVELING
     MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
-#endif
-    MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
-    MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);
-    MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);
-    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &max_e_jerk, 1, 990);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);
-    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000, reset_acceleration_rates);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates);
-    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);
-    MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);
-    MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);
-    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);
-    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);
-#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+  #endif
+  MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
+  MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);
+  MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);
+  MENU_ITEM_EDIT(float3, MSG_VE_JERK, &max_e_jerk, 1, 990);
+  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);
+  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);
+  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);
+  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);
+  MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);
+  MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000, reset_acceleration_rates);
+  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates);
+  MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);
+  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);
+  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);
+  #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
     MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);
-#endif
-#ifdef SCARA
+  #endif
+  #ifdef SCARA
     MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);
     MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS],0.5,2);
-#endif
-    END_MENU();
+  #endif
+  END_MENU();
 }
 
-static void lcd_control_volumetric_menu()
-{
-	START_MENU();
-	MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
-
-	MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
-
-	if (volumetric_enabled) {
-		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
-#if EXTRUDERS > 1
-		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
-#if EXTRUDERS > 2
-		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
-#if EXTRUDERS > 3
-		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_3, &filament_size[3], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
-#endif //EXTRUDERS > 3
-#endif //EXTRUDERS > 2
-#endif //EXTRUDERS > 1
-	}
-
-	END_MENU();
+static void lcd_control_volumetric_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+
+  MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
+
+  if (volumetric_enabled) {
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+    #if EXTRUDERS > 1
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
+      #if EXTRUDERS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
+        #if EXTRUDERS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_3, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
+        #endif //EXTRUDERS > 3
+      #endif //EXTRUDERS > 2
+    #endif //EXTRUDERS > 1
+  }
+
+  END_MENU();
 }
+
 #ifdef DOGLCD
-static void lcd_set_contrast()
-{
-    if (encoderPosition != 0)
-    {
-        lcd_contrast -= encoderPosition;
-        if (lcd_contrast < 0) lcd_contrast = 0;
-        else if (lcd_contrast > 63) lcd_contrast = 63;
-        encoderPosition = 0;
-        lcdDrawUpdate = 1;
-        u8g.setContrast(lcd_contrast);
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
-    }
-    if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);
+
+static void lcd_set_contrast() {
+  if (encoderPosition != 0) {
+    lcd_contrast -= encoderPosition;
+    if (lcd_contrast < 0) lcd_contrast = 0;
+    else if (lcd_contrast > 63) lcd_contrast = 63;
+    encoderPosition = 0;
+    lcdDrawUpdate = 1;
+    u8g.setContrast(lcd_contrast);
+  }
+  if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
+  if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);
 }
-#endif
+
+#endif //DOGLCD
 
 #ifdef FWRETRACT
-static void lcd_control_retract_menu()
-{
-    START_MENU();
-    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
-    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
-    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
-    END_MENU();
+
+static void lcd_control_retract_menu() {
+  START_MENU();
+  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
+  MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
+  MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+  #if EXTRUDERS > 1
+    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
+  #endif
+  MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
+  MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
+  MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
+  #if EXTRUDERS > 1
+    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
+  #endif
+  MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
+  END_MENU();
 }
+
 #endif //FWRETRACT
 
 #if SDCARDDETECT == -1
-static void lcd_sd_refresh()
-{
+  static void lcd_sd_refresh() {
     card.initsd();
     currentMenuViewOffset = 0;
-}
+  }
 #endif
-static void lcd_sd_updir()
-{
-    card.updir();
-    currentMenuViewOffset = 0;
+
+static void lcd_sd_updir() {
+  card.updir();
+  currentMenuViewOffset = 0;
 }
 
-void lcd_sdcard_menu()
-{
-    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0)
-        return;	// nothing to do (so don't thrash the SD card)
-    uint16_t fileCnt = card.getnrfilenames();
-    START_MENU();
-    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
-    card.getWorkDirName();
-    if(card.filename[0]=='/')
-    {
-#if SDCARDDETECT == -1
-        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
-#endif
-    }else{
-        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
-    }
+void lcd_sdcard_menu() {
+  if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return;	// nothing to do (so don't thrash the SD card)
+  uint16_t fileCnt = card.getnrfilenames();
+  START_MENU();
+  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
+  card.getWorkDirName();
+  if (card.filename[0] == '/') {
+    #if SDCARDDETECT == -1
+      MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
+    #endif
+  }
+  else {
+    MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+  }
 
-    for(uint16_t i=0;i<fileCnt;i++)
-    {
-        if (_menuItemNr == _lineNr)
-        {
-            #ifndef SDCARD_RATHERRECENTFIRST
-              card.getfilename(i);
-            #else
-              card.getfilename(fileCnt-1-i);
-            #endif
-            if (card.filenameIsDir)
-            {
-                MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
-            }else{
-                MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
-            }
-        }else{
-            MENU_ITEM_DUMMY();
-        }
+  for(uint16_t i = 0; i < fileCnt; i++) {
+    if (_menuItemNr == _lineNr) {
+      #ifndef SDCARD_RATHERRECENTFIRST
+        card.getfilename(i);
+      #else
+        card.getfilename(fileCnt-1-i);
+      #endif
+      if (card.filenameIsDir)
+        MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+      else
+        MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
     }
-    END_MENU();
+    else {
+      MENU_ITEM_DUMMY();
+    }
+  }
+  END_MENU();
 }
 
 #define menu_edit_type(_type, _name, _strFunc, scale) \
-    void menu_edit_ ## _name () \
-    { \
-        if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
-        if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
-        if (lcdDrawUpdate) \
-            lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
-        if (LCD_CLICKED) \
-        { \
-            *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
-            lcd_goto_menu(prevMenu, prevEncoderPosition); \
-        } \
-    } \
-    void menu_edit_callback_ ## _name () { \
-        menu_edit_ ## _name (); \
-        if (LCD_CLICKED) (*callbackFunc)(); \
+  bool _menu_edit_ ## _name () { \
+    bool isClicked = LCD_CLICKED; \
+    if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
+    if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
+    if (lcdDrawUpdate) \
+        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
+    if (isClicked) { \
+      *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
+      lcd_goto_menu(prevMenu, prevEncoderPosition); \
     } \
-    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
-    { \
-        prevMenu = currentMenu; \
-        prevEncoderPosition = encoderPosition; \
-         \
-        lcdDrawUpdate = 2; \
-        currentMenu = menu_edit_ ## _name; \
-         \
-        editLabel = pstr; \
-        editValue = ptr; \
-        minEditValue = minValue * scale; \
-        maxEditValue = maxValue * scale - minEditValue; \
-        encoderPosition = (*ptr) * scale - minEditValue; \
-    }\
-    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \
-    { \
-        prevMenu = currentMenu; \
-        prevEncoderPosition = encoderPosition; \
-         \
-        lcdDrawUpdate = 2; \
-        currentMenu = menu_edit_callback_ ## _name; \
-         \
-        editLabel = pstr; \
-        editValue = ptr; \
-        minEditValue = minValue * scale; \
-        maxEditValue = maxValue * scale - minEditValue; \
-        encoderPosition = (*ptr) * scale - minEditValue; \
-        callbackFunc = callback;\
-    }
+    return isClicked; \
+  } \
+  void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \
+  void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \
+  static void _menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
+    prevMenu = currentMenu; \
+    prevEncoderPosition = encoderPosition; \
+     \
+    lcdDrawUpdate = 2; \
+    currentMenu = menu_edit_ ## _name; \
+     \
+    editLabel = pstr; \
+    editValue = ptr; \
+    minEditValue = minValue * scale; \
+    maxEditValue = maxValue * scale - minEditValue; \
+    encoderPosition = (*ptr) * scale - minEditValue; \
+  } \
+  static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \
+    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+    currentMenu = menu_edit_ ## _name; \
+  }\
+  static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) { \
+    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+    currentMenu = menu_edit_callback_ ## _name; \
+    callbackFunc = callback; \
+  }
 menu_edit_type(int, int3, itostr3, 1)
 menu_edit_type(float, float3, ftostr3, 1)
 menu_edit_type(float, float32, ftostr32, 100)
@@ -1124,94 +1071,81 @@ menu_edit_type(float, float52, ftostr52, 100)
 menu_edit_type(unsigned long, long5, ftostr5, 0.01)
 
 #ifdef REPRAPWORLD_KEYPAD
-	static void reprapworld_keypad_move_z_up() {
+  static void reprapworld_keypad_move_z_up() {
     encoderPosition = 1;
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-		lcd_move_z();
+    lcd_move_z();
   }
-	static void reprapworld_keypad_move_z_down() {
+  static void reprapworld_keypad_move_z_down() {
     encoderPosition = -1;
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-		lcd_move_z();
+    lcd_move_z();
   }
-	static void reprapworld_keypad_move_x_left() {
+  static void reprapworld_keypad_move_x_left() {
     encoderPosition = -1;
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-		lcd_move_x();
+    lcd_move_x();
   }
-	static void reprapworld_keypad_move_x_right() {
+  static void reprapworld_keypad_move_x_right() {
     encoderPosition = 1;
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-		lcd_move_x();
-	}
-	static void reprapworld_keypad_move_y_down() {
+    lcd_move_x();
+  }
+  static void reprapworld_keypad_move_y_down() {
     encoderPosition = 1;
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-		lcd_move_y();
-	}
-	static void reprapworld_keypad_move_y_up() {
-		encoderPosition = -1;
-		move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
     lcd_move_y();
-	}
-	static void reprapworld_keypad_move_home() {
-		enquecommands_P((PSTR("G28"))); // move all axis home
-	}
-#endif
+  }
+  static void reprapworld_keypad_move_y_up() {
+    encoderPosition = -1;
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+    lcd_move_y();
+  }
+  static void reprapworld_keypad_move_home() {
+    enquecommands_P((PSTR("G28"))); // move all axis home
+  }
+#endif //REPRAPWORLD_KEYPAD
 
 /** End of menus **/
 
-static void lcd_quick_feedback()
-{
-    lcdDrawUpdate = 2;
-    blocking_enc = millis() + 500;
-    lcd_implementation_quick_feedback();
+static void lcd_quick_feedback() {
+  lcdDrawUpdate = 2;
+  blocking_enc = millis() + 500;
+  lcd_implementation_quick_feedback();
 }
 
 /** Menu action functions **/
 static void menu_action_back(menuFunc_t data) { lcd_goto_menu(data); }
 static void menu_action_submenu(menuFunc_t data) { lcd_goto_menu(data); }
-
-static void menu_action_gcode(const char* pgcode)
-{
-    enquecommands_P(pgcode);
-}
-
-
+static void menu_action_gcode(const char* pgcode) { enquecommands_P(pgcode); }
 static void menu_action_function(menuFunc_t data) { (*data)(); }
-static void menu_action_sdfile(const char* filename, char* longFilename)
-{
-    char cmd[30];
-    char* c;
-    sprintf_P(cmd, PSTR("M23 %s"), filename);
-    for(c = &cmd[4]; *c; c++)
-        *c = tolower(*c);
-    enquecommand(cmd);
-    enquecommands_P(PSTR("M24"));
-    lcd_return_to_status();
+static void menu_action_sdfile(const char* filename, char* longFilename) {
+  char cmd[30];
+  char* c;
+  sprintf_P(cmd, PSTR("M23 %s"), filename);
+  for(c = &cmd[4]; *c; c++) *c = tolower(*c);
+  enquecommand(cmd);
+  enquecommands_P(PSTR("M24"));
+  lcd_return_to_status();
 }
-static void menu_action_sddirectory(const char* filename, char* longFilename)
-{
-    card.chdir(filename);
-    encoderPosition = 0;
+static void menu_action_sddirectory(const char* filename, char* longFilename) {
+  card.chdir(filename);
+  encoderPosition = 0;
 }
-static void menu_action_setting_edit_bool(const char* pstr, bool* ptr)
-{
-    *ptr = !(*ptr);
-}
-static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback)
-{
-	menu_action_setting_edit_bool(pstr, ptr);
-	(*callback)();
+static void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { *ptr = !(*ptr); }
+static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback) {
+  menu_action_setting_edit_bool(pstr, ptr);
+  (*callback)();
 }
-#endif//ULTIPANEL
+
+#endif //ULTIPANEL
 
 /** LCD API **/
-void lcd_init()
-{
-    lcd_implementation_init();
+void lcd_init() {
+  lcd_implementation_init();
+
+  #ifdef NEWPANEL
 
-#ifdef NEWPANEL
     SET_INPUT(BTN_EN1);
     SET_INPUT(BTN_EN2);
     WRITE(BTN_EN1,HIGH);
@@ -1246,133 +1180,170 @@ void lcd_init()
   #endif // SR_LCD_2W_NL
 #endif//!NEWPANEL
 
-#if defined (SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0)
-    pinMode(SDCARDDETECT,INPUT);
+  #if defined(SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0)
+    pinMode(SDCARDDETECT, INPUT);
     WRITE(SDCARDDETECT, HIGH);
     lcd_oldcardstatus = IS_SD_INSERTED;
-#endif//(SDCARDDETECT > 0)
-#ifdef LCD_HAS_SLOW_BUTTONS
+  #endif //(SDCARDDETECT > 0)
+
+  #ifdef LCD_HAS_SLOW_BUTTONS
     slow_buttons = 0;
-#endif
-    lcd_buttons_update();
-#ifdef ULTIPANEL
+  #endif
+
+  lcd_buttons_update();
+
+  #ifdef ULTIPANEL
     encoderDiff = 0;
-#endif
+  #endif
 }
 
-void lcd_update()
-{
-    static unsigned long timeoutToStatus = 0;
+int lcd_strlen(char *s) {
+  int i = 0, j = 0;
+  while (s[i]) {
+    if ((s[i] & 0xc0) != 0x80) j++;
+    i++;
+  }
+  return j;
+}
 
-    #ifdef LCD_HAS_SLOW_BUTTONS
+int lcd_strlen_P(const char *s) {
+  int j = 0;
+  while (pgm_read_byte(s)) {
+    if ((pgm_read_byte(s) & 0xc0) != 0x80) j++;
+    s++;
+  }
+  return j;
+}
+
+void lcd_update() {
+  static unsigned long timeoutToStatus = 0;
+
+  #ifdef LCD_HAS_SLOW_BUTTONS
     slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
-    #endif
+  #endif
 
-    lcd_buttons_update();
+  lcd_buttons_update();
 
-    #if (SDCARDDETECT > 0)
-    if((IS_SD_INSERTED != lcd_oldcardstatus && lcd_detected()))
-    {
-        lcdDrawUpdate = 2;
-        lcd_oldcardstatus = IS_SD_INSERTED;
-        lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
-          #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && !defined(DOGLCD)
-            currentMenu == lcd_status_screen
-          #endif
-        );
+  #if (SDCARDDETECT > 0)
+    if (IS_SD_INSERTED != lcd_oldcardstatus && lcd_detected()) {
+      lcdDrawUpdate = 2;
+      lcd_oldcardstatus = IS_SD_INSERTED;
+      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
+        #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && !defined(DOGLCD)
+          currentMenu == lcd_status_screen
+        #endif
+      );
 
-        if(lcd_oldcardstatus)
-        {
-            card.initsd();
-            LCD_MESSAGEPGM(MSG_SD_INSERTED);
-        }
-        else
-        {
-            card.release();
-            LCD_MESSAGEPGM(MSG_SD_REMOVED);
-        }
+      if (lcd_oldcardstatus) {
+        card.initsd();
+        LCD_MESSAGEPGM(MSG_SD_INSERTED);
+      }
+      else {
+        card.release();
+        LCD_MESSAGEPGM(MSG_SD_REMOVED);
+      }
     }
-    #endif//CARDINSERTED
+  #endif//CARDINSERTED
+
+  long ms = millis();
+  if (ms > lcd_next_update_millis) {
+
+    #ifdef ULTIPANEL
+
+      #ifdef REPRAPWORLD_KEYPAD
+        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
+        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
+        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
+        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
+        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
+        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
+        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
+      #endif
+
+      bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
+      if (encoderPastThreshold || LCD_CLICKED) {
+        if (encoderPastThreshold) {
+          int32_t encoderMultiplier = 1;
+
+          #ifdef ENCODER_RATE_MULTIPLIER
+
+            if (encoderRateMultiplierEnabled) {
+              int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;
+
+              if (lastEncoderMovementMillis != 0) {
+                // Note that the rate is always calculated between to passes through the 
+                // loop and that the abs of the encoderDiff value is tracked.
+                float encoderStepRate = (float)(encoderMovementSteps) / ((float)(ms - lastEncoderMovementMillis)) * 1000.0;
+
+                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
+
+                #ifdef ENCODER_RATE_MULTIPLIER_DEBUG
+                  SERIAL_ECHO_START;
+                  SERIAL_ECHO("Enc Step Rate: ");
+                  SERIAL_ECHO(encoderStepRate);
+                  SERIAL_ECHO("  Multiplier: ");
+                  SERIAL_ECHO(encoderMultiplier);
+                  SERIAL_ECHO("  ENCODER_10X_STEPS_PER_SEC: ");
+                  SERIAL_ECHO(ENCODER_10X_STEPS_PER_SEC);
+                  SERIAL_ECHO("  ENCODER_100X_STEPS_PER_SEC: ");
+                  SERIAL_ECHOLN(ENCODER_100X_STEPS_PER_SEC);
+                #endif //ENCODER_RATE_MULTIPLIER_DEBUG
+              }
+
+              lastEncoderMovementMillis = ms;
+            }
+          #endif //ENCODER_RATE_MULTIPLIER
 
-    if (lcd_next_update_millis < millis())
-    {
-#ifdef ULTIPANEL
-		#ifdef REPRAPWORLD_KEYPAD
-        	if (REPRAPWORLD_KEYPAD_MOVE_Z_UP) {
-        		reprapworld_keypad_move_z_up();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN) {
-        		reprapworld_keypad_move_z_down();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT) {
-        		reprapworld_keypad_move_x_left();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT) {
-        		reprapworld_keypad_move_x_right();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN) {
-        		reprapworld_keypad_move_y_down();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_Y_UP) {
-        		reprapworld_keypad_move_y_up();
-        	}
-        	if (REPRAPWORLD_KEYPAD_MOVE_HOME) {
-        		reprapworld_keypad_move_home();
-        	}
-		#endif
-        if (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP)
-        {
-            lcdDrawUpdate = 1;
-            encoderPosition += encoderDiff / ENCODER_PULSES_PER_STEP;
-            encoderDiff = 0;
-            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
+          lcdDrawUpdate = 1;
+          encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
+          encoderDiff = 0;
         }
-        if (LCD_CLICKED)
-            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
-#endif//ULTIPANEL
-
-#ifdef DOGLCD        // Changes due to different driver architecture of the DOGM display
-        blink++;     // Variable for fan animation and alive dot
-        u8g.firstPage();
-        do
-        {
-            u8g.setFont(FONT_MENU);
-            u8g.setPrintPos(125,0);
-            if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot
-            u8g.drawPixel(127,63); // draw alive dot
-            u8g.setColorIndex(1); // black on white
-            (*currentMenu)();
-            if (!lcdDrawUpdate)  break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()
-        } while( u8g.nextPage() );
-#else
+        timeoutToStatus = ms + LCD_TIMEOUT_TO_STATUS;
+      }
+
+    #endif //ULTIPANEL
+
+    #ifdef DOGLCD  // Changes due to different driver architecture of the DOGM display
+      blink++;     // Variable for fan animation and alive dot
+      u8g.firstPage();
+      do {
+        u8g.setFont(FONT_MENU);
+        u8g.setPrintPos(125, 0);
+        if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot
+        u8g.drawPixel(127, 63); // draw alive dot
+        u8g.setColorIndex(1); // black on white
         (*currentMenu)();
-#endif
+        if (!lcdDrawUpdate) break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()
+      } while( u8g.nextPage() );
+    #else
+      (*currentMenu)();
+    #endif
 
-#ifdef LCD_HAS_STATUS_INDICATORS
-        lcd_implementation_update_indicators();
-#endif
+    #ifdef LCD_HAS_STATUS_INDICATORS
+      lcd_implementation_update_indicators();
+    #endif
 
-#ifdef ULTIPANEL
-        if(timeoutToStatus < millis() && currentMenu != lcd_status_screen)
-        {
-            lcd_return_to_status();
-            lcdDrawUpdate = 2;
-        }
-#endif//ULTIPANEL
-        if (lcdDrawUpdate == 2) lcd_implementation_clear();
-        if (lcdDrawUpdate) lcdDrawUpdate--;
-        lcd_next_update_millis = millis() + LCD_UPDATE_INTERVAL;
-    }
+    #ifdef ULTIPANEL
+      if (currentMenu != lcd_status_screen && millis() > timeoutToStatus) {
+        lcd_return_to_status();
+        lcdDrawUpdate = 2;
+      }
+    #endif //ULTIPANEL
+
+    if (lcdDrawUpdate == 2) lcd_implementation_clear();
+    if (lcdDrawUpdate) lcdDrawUpdate--;
+    lcd_next_update_millis = millis() + LCD_UPDATE_INTERVAL;
+  }
 }
 
-void lcd_ignore_click(bool b)
-{
-    ignore_click = b;
-    wait_for_unclick = false;
+void lcd_ignore_click(bool b) {
+  ignore_click = b;
+  wait_for_unclick = false;
 }
 
 void lcd_finishstatus() {
-  int len = strlen(lcd_status_message);
+  int len = lcd_strlen(lcd_status_message);
   if (len > 0) {
     while (len < LCD_WIDTH) {
       lcd_status_message[len++] = ' ';
@@ -1391,145 +1362,122 @@ void lcd_finishstatus() {
     message_millis = millis();  //get status message to show up for a while
   #endif
 }
-void lcd_setstatus(const char* message)
-{
-    if (lcd_status_message_level > 0)
-        return;
-    strncpy(lcd_status_message, message, LCD_WIDTH);
-    lcd_finishstatus();
+
+void lcd_setstatus(const char* message) {
+  if (lcd_status_message_level > 0) return;
+  strncpy(lcd_status_message, message, LCD_WIDTH);
+  lcd_finishstatus();
 }
-void lcd_setstatuspgm(const char* message)
-{
-    if (lcd_status_message_level > 0)
-        return;
-    strncpy_P(lcd_status_message, message, LCD_WIDTH);
-    lcd_finishstatus();
+
+void lcd_setstatuspgm(const char* message) {
+  if (lcd_status_message_level > 0) return;
+  strncpy_P(lcd_status_message, message, LCD_WIDTH);
+  lcd_finishstatus();
 }
-void lcd_setalertstatuspgm(const char* message)
-{
-    lcd_setstatuspgm(message);
-    lcd_status_message_level = 1;
-#ifdef ULTIPANEL
+
+void lcd_setalertstatuspgm(const char* message) {
+  lcd_setstatuspgm(message);
+  lcd_status_message_level = 1;
+  #ifdef ULTIPANEL
     lcd_return_to_status();
-#endif//ULTIPANEL
-}
-void lcd_reset_alert_level()
-{
-    lcd_status_message_level = 0;
+  #endif
 }
 
+void lcd_reset_alert_level() { lcd_status_message_level = 0; }
+
 #ifdef DOGLCD
-void lcd_setcontrast(uint8_t value)
-{
+  void lcd_setcontrast(uint8_t value) {
     lcd_contrast = value & 63;
     u8g.setContrast(lcd_contrast);
-}
+  }
 #endif
 
 #ifdef ULTIPANEL
+
 /* Warning: This function is called from interrupt context */
-void lcd_buttons_update()
-{
-#ifdef NEWPANEL
-    uint8_t newbutton=0;
-    if(READ(BTN_EN1)==0)  newbutton|=EN_A;
-    if(READ(BTN_EN2)==0)  newbutton|=EN_B;
-  #if BTN_ENC > 0
-    if((blocking_enc<millis()) && (READ(BTN_ENC)==0))
-        newbutton |= EN_C;
-  #endif
+void lcd_buttons_update() {
+  #ifdef NEWPANEL
+    uint8_t newbutton = 0;
+    if (READ(BTN_EN1) == 0) newbutton |= EN_A;
+    if (READ(BTN_EN2) == 0) newbutton |= EN_B;
+    #if BTN_ENC > 0
+      if (millis() > blocking_enc && READ(BTN_ENC) == 0) newbutton |= EN_C;
+    #endif
     buttons = newbutton;
     #ifdef LCD_HAS_SLOW_BUTTONS
-    buttons |= slow_buttons;
+      buttons |= slow_buttons;
     #endif
     #ifdef REPRAPWORLD_KEYPAD
       // for the reprapworld_keypad
       uint8_t newbutton_reprapworld_keypad=0;
-      WRITE(SHIFT_LD,LOW);
-      WRITE(SHIFT_LD,HIGH);
-      for(int8_t i=0;i<8;i++) {
-          newbutton_reprapworld_keypad = newbutton_reprapworld_keypad>>1;
-          if(READ(SHIFT_OUT))
-              newbutton_reprapworld_keypad|=(1<<7);
-          WRITE(SHIFT_CLK,HIGH);
-          WRITE(SHIFT_CLK,LOW);
+      WRITE(SHIFT_LD, LOW);
+      WRITE(SHIFT_LD, HIGH);
+      for(int8_t i = 0; i < 8; i++) {
+        newbutton_reprapworld_keypad >>= 1;
+        if (READ(SHIFT_OUT)) newbutton_reprapworld_keypad |= (1 << 7);
+        WRITE(SHIFT_CLK, HIGH);
+        WRITE(SHIFT_CLK, LOW);
       }
       buttons_reprapworld_keypad=~newbutton_reprapworld_keypad; //invert it, because a pressed switch produces a logical 0
-	#endif
-#else   //read it from the shift register
-    uint8_t newbutton=0;
-    WRITE(SHIFT_LD,LOW);
-    WRITE(SHIFT_LD,HIGH);
-    unsigned char tmp_buttons=0;
-    for(int8_t i=0;i<8;i++)
-    {
-        newbutton = newbutton>>1;
-        if(READ(SHIFT_OUT))
-            newbutton|=(1<<7);
-        WRITE(SHIFT_CLK,HIGH);
-        WRITE(SHIFT_CLK,LOW);
+    #endif
+  #else   //read it from the shift register
+    uint8_t newbutton = 0;
+    WRITE(SHIFT_LD, LOW);
+    WRITE(SHIFT_LD, HIGH);
+    unsigned char tmp_buttons = 0;
+    for(int8_t i=0; i<8; i++) {
+      newbutton >>= 1;
+      if (READ(SHIFT_OUT)) newbutton |= (1 << 7);
+      WRITE(SHIFT_CLK, HIGH);
+      WRITE(SHIFT_CLK, LOW);
     }
-    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
-#endif//!NEWPANEL
-
-    //manage encoder rotation
-    uint8_t enc=0;
-    if (buttons & EN_A) enc |= B01;
-    if (buttons & EN_B) enc |= B10;
-    if(enc != lastEncoderBits)
-    {
-        switch(enc)
-        {
-        case encrot0:
-            if(lastEncoderBits==encrot3)
-                encoderDiff++;
-            else if(lastEncoderBits==encrot1)
-                encoderDiff--;
-            break;
-        case encrot1:
-            if(lastEncoderBits==encrot0)
-                encoderDiff++;
-            else if(lastEncoderBits==encrot2)
-                encoderDiff--;
-            break;
-        case encrot2:
-            if(lastEncoderBits==encrot1)
-                encoderDiff++;
-            else if(lastEncoderBits==encrot3)
-                encoderDiff--;
-            break;
-        case encrot3:
-            if(lastEncoderBits==encrot2)
-                encoderDiff++;
-            else if(lastEncoderBits==encrot0)
-                encoderDiff--;
-            break;
-        }
+    buttons = ~newbutton; //invert it, because a pressed switch produces a logical 0
+  #endif //!NEWPANEL
+
+  //manage encoder rotation
+  uint8_t enc=0;
+  if (buttons & EN_A) enc |= B01;
+  if (buttons & EN_B) enc |= B10;
+  if (enc != lastEncoderBits) {
+    switch(enc) {
+      case encrot0:
+        if (lastEncoderBits==encrot3) encoderDiff++;
+        else if (lastEncoderBits==encrot1) encoderDiff--;
+        break;
+      case encrot1:
+        if (lastEncoderBits==encrot0) encoderDiff++;
+        else if (lastEncoderBits==encrot2) encoderDiff--;
+        break;
+      case encrot2:
+        if (lastEncoderBits==encrot1) encoderDiff++;
+        else if (lastEncoderBits==encrot3) encoderDiff--;
+        break;
+      case encrot3:
+        if (lastEncoderBits==encrot2) encoderDiff++;
+        else if (lastEncoderBits==encrot0) encoderDiff--;
+        break;
     }
-    lastEncoderBits = enc;
+  }
+  lastEncoderBits = enc;
 }
 
-bool lcd_detected(void)
-{
-#if (defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
-  return lcd.LcdDetected() == 1;
-#else
-  return true;
-#endif
+bool lcd_detected(void) {
+  #if (defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
+    return lcd.LcdDetected() == 1;
+  #else
+    return true;
+  #endif
 }
 
-void lcd_buzz(long duration, uint16_t freq)
-{
-#ifdef LCD_USE_I2C_BUZZER
-  lcd.buzz(duration,freq);
-#endif
+void lcd_buzz(long duration, uint16_t freq) {
+  #ifdef LCD_USE_I2C_BUZZER
+    lcd.buzz(duration,freq);
+  #endif
 }
 
-bool lcd_clicked()
-{
-  return LCD_CLICKED;
-}
-#endif//ULTIPANEL
+bool lcd_clicked() { return LCD_CLICKED; }
+
+#endif //ULTIPANEL
 
 /********************************/
 /** Float conversion utilities **/
@@ -1785,24 +1733,4 @@ char *ftostr52(const float &x)
   return conv;
 }
 
-// Callback for after editing PID i value
-// grab the PID i value out of the temp variable; scale it; then update the PID driver
-void copy_and_scalePID_i()
-{
-#ifdef PIDTEMP
-  PID_PARAM(Ki, pid_current_extruder) = scalePID_i(raw_Ki);
-  updatePID();
-#endif
-}
-
-// Callback for after editing PID d value
-// grab the PID d value out of the temp variable; scale it; then update the PID driver
-void copy_and_scalePID_d()
-{
-#ifdef PIDTEMP
-	PID_PARAM(Kd, pid_current_extruder) = scalePID_d(raw_Kd);
-  updatePID();
-#endif
-}
-
 #endif //ULTRA_LCD
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 30175be..d861e9d 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -4,7 +4,8 @@
 #include "Marlin.h"
 
 #ifdef ULTRA_LCD
-
+  int lcd_strlen(char *s);
+  int lcd_strlen_P(const char *s);
   void lcd_update();
   void lcd_init();
   void lcd_setstatus(const char* message);
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 9eeee1e..1628bf8 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -636,7 +636,7 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
     {
         lcd.print(c);
         pstr++;
-        n--;
+        if ((pgm_read_byte(pstr) & 0xc0) != 0x80) n--;
     }
     while(n--)
         lcd.print(' ');
@@ -648,9 +648,9 @@ static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const
     char c;
     //Use all characters in narrow LCDs
   #if LCD_WIDTH < 20
-      uint8_t n = LCD_WIDTH - 1 - 1 - strlen(data);
+      uint8_t n = LCD_WIDTH - 1 - 1 - lcd_strlen(data);
     #else
-      uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);
+      uint8_t n = LCD_WIDTH - 1 - 2 - lcd_strlen(data);
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
@@ -658,7 +658,7 @@ static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const
     {
         lcd.print(c);
         pstr++;
-        n--;
+        if ((pgm_read_byte(pstr) & 0xc0) != 0x80) n--;
     }
     lcd.print(':');
     while(n--)
@@ -670,9 +670,9 @@ static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, cons
     char c;
     //Use all characters in narrow LCDs
   #if LCD_WIDTH < 20
-      uint8_t n = LCD_WIDTH - 1 - 1 - strlen_P(data);
+      uint8_t n = LCD_WIDTH - 1 - 1 - lcd_strlen_P(data);
     #else
-      uint8_t n = LCD_WIDTH - 1 - 2 - strlen_P(data);
+      uint8_t n = LCD_WIDTH - 1 - 2 - lcd_strlen_P(data);
   #endif
     lcd.setCursor(0, row);
     lcd.print(pre_char);
@@ -680,7 +680,7 @@ static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, cons
     {
         lcd.print(c);
         pstr++;
-        n--;
+        if ((pgm_read_byte(pstr) & 0xc0) != 0x80) n--;
     }
     lcd.print(':');
     while(n--)
@@ -733,9 +733,9 @@ void lcd_implementation_drawedit(const char* pstr, char* value)
     lcd_printPGM(pstr);
     lcd.print(':');
    #if LCD_WIDTH < 20
-      lcd.setCursor(LCD_WIDTH - strlen(value), 1);
+      lcd.setCursor(LCD_WIDTH - lcd_strlen(value), 1);
     #else
-      lcd.setCursor(LCD_WIDTH -1 - strlen(value), 1);
+      lcd.setCursor(LCD_WIDTH -1 - lcd_strlen(value), 1);
    #endif
     lcd.print(value);
 }

