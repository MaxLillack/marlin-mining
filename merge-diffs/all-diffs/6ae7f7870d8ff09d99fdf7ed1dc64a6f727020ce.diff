commit 6ae7f7870d8ff09d99fdf7ed1dc64a6f727020ce (from da2a6f9a312dd7cae3fb450784630a6051d7bbdf)
Merge: da2a6f9 8f19584
Author: fsantini <francesco.santini@gmail.com>
Date:   Mon Dec 23 12:20:32 2013 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into ErikZalm
    
    Conflicts:
    	Marlin/Configuration.h
    	Marlin/Marlin_main.cpp

diff --git a/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt b/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt
index ca2d74b..c1a1f08 100644
--- a/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt
+++ b/ArduinoAddons/Arduino_1.x.x/Sanguino/boards.txt
@@ -61,3 +61,25 @@ atmega1284.build.f_cpu=16000000L
 atmega1284.build.core=arduino
 atmega1284.build.variant=standard
 #
+
+##############################################################
+
+atmega1284.name=Sanguino W/ ATmega1284p 16mhz ceramic resonator
+
+atmega1284.upload.protocol=stk500
+atmega1284.upload.maximum_size=131072
+atmega1284.upload.speed=57600
+
+atmega1284.bootloader.low_fuses=0xD6
+atmega1284.bootloader.high_fuses=0xDC
+atmega1284.bootloader.extended_fuses=0xFD
+atmega1284.bootloader.path=atmega
+atmega1284.bootloader.file=ATmegaBOOT_168_atmega1284p.hex
+atmega1284.bootloader.unlock_bits=0x3F
+atmega1284.bootloader.lock_bits=0x0F
+
+atmega1284.build.mcu=atmega1284p
+atmega1284.build.f_cpu=16000000L
+atmega1284.build.core=arduino
+atmega1284.build.variant=standard
+#
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 8cb0a14..33a1c3a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -8,9 +8,9 @@
 //===========================================================================
 //============================= DELTA Printer ===============================
 //===========================================================================
-// For a Delta printer rplace the configuration files wilth the files in the 
+// For a Delta printer rplace the configuration files wilth the files in the
 // example_configurations/delta directory.
-// 
+//
 
 // User-specified version info of this build to display in [Pronterface, etc] terminal window during
 // startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
@@ -36,7 +36,8 @@
 // 11 = Gen7 v1.1, v1.2 = 11
 // 12 = Gen7 v1.3
 // 13 = Gen7 v1.4
-// 20 = Sethi 3D_1 
+// 2  = Cheaptronic v1.0
+// 20 = Sethi 3D_1
 // 3  = MEGA/RAMPS up to 1.2 = 3
 // 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
 // 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
@@ -335,9 +336,9 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 
   #define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z before homing (G28) for Probe Clearance.
                                         // Be sure you have this distance over your Z_MAX_POS in case
-    
+
   #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min
-  
+
   #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
 
@@ -346,26 +347,26 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
   // You MUST HAVE the SERVO_ENDSTOPS defined to use here a value higher than zero otherwise your code will not compile.
 
-//  #define PROBE_SERVO_DEACTIVATION_DELAY 300  
+//  #define PROBE_SERVO_DEACTIVATION_DELAY 300
 
 
-//If you have enabled the Bed Auto Levelling and are using the same Z Probe for Z Homing, 
+//If you have enabled the Bed Auto Levelling and are using the same Z Probe for Z Homing,
 //it is highly recommended you let this Z_SAFE_HOMING enabled!!!
 
-  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area. 
+  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
                           // When defined, it will:
                           // - Allow Z homing only after X and Y homing AND stepper drivers still enabled
                           // - If stepper drivers timeout, it will need X and Y homing again before Z homing
                           // - Position the probe in a defined XY point before Z Homing when homing all axis (G28)
                           // - Block Z homing only when the probe is outside bed area.
-  
+
   #ifdef Z_SAFE_HOMING
-    
+
     #define Z_SAFE_HOMING_X_POINT (X_MAX_LENGTH/2)    // X point for Z homing when homing all axis (G28)
     #define Z_SAFE_HOMING_Y_POINT (Y_MAX_LENGTH/2)    // Y point for Z homing when homing all axis (G28)
-    
+
   #endif
-  
+
   // with accurate bed leveling, the bed is sampled in a ACCURATE_BED_LEVELING_POINTSxACCURATE_BED_LEVELING_POINTS grid and least squares solution is calculated
   // Note: this feature occupies 10'206 byte
   #define ACCURATE_BED_LEVELING
@@ -443,6 +444,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 //#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
 //#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder
+//#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
 
@@ -549,7 +551,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 // Shift register panels
 // ---------------------
 // 2 wire Non-latching LCD SR from:
-// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection 
+// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
 //#define SR_LCD
 #ifdef SR_LCD
    #define SR_LCD_2W_NL    // Non latching 2 wire shiftregister
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 7b3ef4a..4e5d829 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -161,7 +161,7 @@
   #define EXTRUDERS 1
 #endif
 
-#ifdef Z_DUAL_STEPPER_DRIVERS && Y_DUAL_STEPPER_DRIVERS
+#if defined (Z_DUAL_STEPPER_DRIVERS) && defined (Y_DUAL_STEPPER_DRIVERS)
   #error "You cannot have dual drivers for both Y and Z"
 #endif
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index e37c3e1..8f00640 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -50,7 +50,7 @@
 
 #ifdef BLINKM
 #include "BlinkM.h"
-#include "Wire.h" 
+#include "Wire.h"
 #endif
 
 #if NUM_SERVOS > 0
@@ -99,7 +99,7 @@
 // M29  - Stop SD write
 // M30  - Delete file from SD (M30 filename.g)
 // M31  - Output time since last M109 or SD card start to serial
-// M32  - Select file and start SD print (Can be used _while_ printing from SD card files): 
+// M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
 //        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
 //        Call gcode file : "M32 P !filename#" and return to caller file after finishing (simiarl to #include).
 //        The '#' is necessary when calling from within sd files, as it stops buffer prereading
@@ -229,7 +229,11 @@ int EtoPPressure=0;
 #endif
 
 #ifdef ULTIPANEL
-	bool powersupply = true;
+  #ifdef PS_DEFAULT_OFF
+    bool powersupply = false;
+  #else
+	  bool powersupply = true;
+  #endif
 #endif
 
 #ifdef DELTA
@@ -418,7 +422,7 @@ void servo_init()
 
   #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
   delay(PROBE_SERVO_DEACTIVATION_DELAY);
-  servos[servo_endstops[Z_AXIS]].detach();  
+  servos[servo_endstops[Z_AXIS]].detach();
   #endif
 }
 
@@ -639,17 +643,17 @@ void get_command()
   if(!card.sdprinting || serial_count!=0){
     return;
   }
-  
+
   //'#' stops reading from sd to the buffer prematurely, so procedural macro calls are possible
-  // if it occures, stop_buffering is triggered and the buffer is ran dry. 
+  // if it occures, stop_buffering is triggered and the buffer is ran dry.
   // this character _can_ occure in serial com, due to checksums. however, no checksums are used in sd printing
-  
+
   static bool stop_buffering=false;
   if(buflen==0) stop_buffering=false;
-  
-  while( !card.eof()  && buflen < BUFSIZE && !stop_buffering) { 
+
+  while( !card.eof()  && buflen < BUFSIZE && !stop_buffering) {
     int16_t n=card.get();
-    serial_char = (char)n; 
+    serial_char = (char)n;
     if(serial_char == '\n' ||
        serial_char == '\r' ||
        (serial_char == '#' && comment_mode == false) ||
@@ -674,7 +678,7 @@ void get_command()
       }
       if(serial_char=='#')
         stop_buffering=true;
-      
+
       if(!serial_count)
       {
         comment_mode = false; //for new command
@@ -746,13 +750,13 @@ XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);
   #endif
   #if X_HOME_DIR != -1 || X2_HOME_DIR != 1
     #error "Please use canonical x-carriage assignment" // the x-carriages are defined by their homing directions
-  #endif  
+  #endif
 
 #define DXC_FULL_CONTROL_MODE 0
 #define DXC_AUTO_PARK_MODE    1
 #define DXC_DUPLICATION_MODE  2
 static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
- 
+
 static float x_home_pos(int extruder) {
   if (extruder == 0)
     return base_home_pos(X_AXIS) + add_homeing[X_AXIS];
@@ -770,12 +774,12 @@ static int x_home_dir(int extruder) {
 
 static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
 static bool active_extruder_parked = false; // used in mode 1 & 2
-static float raised_parked_position[NUM_AXIS]; // used in mode 1 
-static unsigned long delayed_move_time = 0; // used in mode 1 
+static float raised_parked_position[NUM_AXIS]; // used in mode 1
+static unsigned long delayed_move_time = 0; // used in mode 1
 static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
 static float duplicate_extruder_temp_offset = 0; // used in mode 2
 bool extruder_duplication_enabled = false; // used in mode 2
-#endif //DUAL_X_CARRIAGE    
+#endif //DUAL_X_CARRIAGE
 
 static void axis_is_at_home(int axis) {
 #ifdef DUAL_X_CARRIAGE
@@ -788,8 +792,8 @@ static void axis_is_at_home(int axis) {
     }
     else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
       current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];
-      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS]; 
-      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS], 
+      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS];
+      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS],
                                   max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
       return;
     }
@@ -881,7 +885,7 @@ static void run_z_probe() {
     st_synchronize();
 
     // move back down slowly to find bed
-    feedrate = homing_feedrate[Z_AXIS]/4; 
+    feedrate = homing_feedrate[Z_AXIS]/4;
     zPosition -= home_retract_mm(Z_AXIS) * 2;
     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
     st_synchronize();
@@ -978,7 +982,7 @@ static void homeaxis(int axis) {
 
     current_position[axis] = 0;
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-	
+
 
     // Engage Servo endstop if enabled
     #ifdef SERVO_ENDSTOPS
@@ -1036,7 +1040,7 @@ static void homeaxis(int axis) {
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
     if (axis==Z_AXIS) retract_z_probe();
 #endif
-    
+
   }
 }
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
@@ -1110,7 +1114,7 @@ void process_commands()
         destination[Y_AXIS]=current_position[Y_AXIS];
         destination[Z_AXIS]=current_position[Z_AXIS];
         current_position[Z_AXIS]+=retract_zlift;
-        destination[E_AXIS]=current_position[E_AXIS]+retract_length+retract_recover_length; 
+        destination[E_AXIS]=current_position[E_AXIS]+retract_length+retract_recover_length;
         feedrate=retract_recover_feedrate;
         retracted=false;
         prepare_move();
@@ -1224,10 +1228,10 @@ void process_commands()
         // reset state used by the different modes
         memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
         delayed_move_time = 0;
-        active_extruder_parked = true; 
-      #else      
+        active_extruder_parked = true;
+      #else
         HOMEAXIS(X);
-      #endif         
+      #endif
       }
 
       if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
@@ -1246,7 +1250,7 @@ void process_commands()
           current_position[Y_AXIS]=code_value()+add_homeing[1];
         }
       }
-      
+
       #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
         #ifndef Z_SAFE_HOMING
           if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
@@ -1258,14 +1262,14 @@ void process_commands()
             #endif
             HOMEAXIS(Z);
           }
-        #else                      // Z Safe mode activated. 
+        #else                      // Z Safe mode activated.
           if(home_all_axis) {
             destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
             destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
             feedrate = XY_TRAVEL_SPEED;
             current_position[Z_AXIS] = 0;
-			
+
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
             plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
             st_synchronize();
@@ -1283,7 +1287,7 @@ void process_commands()
               && (current_position[Y_AXIS]+Y_PROBE_OFFSET_FROM_EXTRUDER <= Y_MAX_POS)) {
 
               current_position[Z_AXIS] = 0;
-              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);			  
+              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
               destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
               feedrate = max_feedrate[Z_AXIS];
               plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
@@ -1303,8 +1307,8 @@ void process_commands()
         #endif
       #endif
 
-      
-     
+
+
       if(code_seen(axis_codes[Z_AXIS])) {
         if(code_value_long() != 0) {
           current_position[Z_AXIS]=code_value()+add_homeing[2];
@@ -1467,7 +1471,7 @@ void process_commands()
             run_z_probe();
             float z_at_xLeft_yFront = current_position[Z_AXIS];
             retract_z_probe();
-            
+
             SERIAL_PROTOCOLPGM("Bed x: ");
             SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);
             SERIAL_PROTOCOLPGM(" y: ");
@@ -1485,7 +1489,7 @@ void process_commands()
             run_z_probe();
             float z_at_xRight_yFront = current_position[Z_AXIS];
             retract_z_probe(); // Retract Z Servo endstop if available
-            
+
             SERIAL_PROTOCOLPGM("Bed x: ");
             SERIAL_PROTOCOL(RIGHT_PROBE_BED_POSITION);
             SERIAL_PROTOCOLPGM(" y: ");
@@ -1500,10 +1504,10 @@ void process_commands()
          
             
 #endif // ACCURATE_BED_LEVELING
-            st_synchronize();            
+            st_synchronize();
 
             // The following code correct the Z height difference from z-probe position and hotend tip position.
-            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend. 
+            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend.
             // When the bed is uneven, this height must be corrected.
             real_z = float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS];  //get the real Z (since the auto bed leveling is already correcting the plane)
             x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER;
@@ -1515,11 +1519,11 @@ void process_commands()
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         }
         break;
-        
+
     case 30: // G30 Single Z Probe
         {
             engage_z_probe(); // Engage Z Servo endstop if available
-            
+
             st_synchronize();
             // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
             setup_for_endstop_move();
@@ -1670,14 +1674,14 @@ void process_commands()
         card.removeFile(strchr_pointer + 4);
       }
       break;
-    case 32: //M32 - Select file and start SD print 
+    case 32: //M32 - Select file and start SD print
     {
       if(card.sdprinting) {
         st_synchronize();
 
       }
-      starpos = (strchr(strchr_pointer + 4,'*')); 
-      
+      starpos = (strchr(strchr_pointer + 4,'*'));
+
       char* namestartpos = (strchr(strchr_pointer + 4,'!'));   //find ! to indicate filename string start.
       if(namestartpos==NULL)
       {
@@ -1685,16 +1689,16 @@ void process_commands()
       }
       else
         namestartpos++; //to skip the '!'
-        
+
       if(starpos!=NULL)
         *(starpos-1)='\0';
-            
+
       bool call_procedure=(code_seen('P'));
-      
-      if(strchr_pointer>namestartpos) 
+
+      if(strchr_pointer>namestartpos)
         call_procedure=false;  //false alert, 'P' found within filename
-      
-      if( card.cardOK ) 
+
+      if( card.cardOK )
       {
         card.openFile(namestartpos,true,!call_procedure);
         if(code_seen('S'))
@@ -1767,7 +1771,7 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
         setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
       setWatch();
       break;
     case 140: // M140 set bed temp
@@ -1823,7 +1827,7 @@ void process_commands()
             SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);
           }
         #endif
-		
+
         SERIAL_PROTOCOLLN("");
       return;
       break;
@@ -1841,14 +1845,14 @@ void process_commands()
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = true;
       } else if (code_seen('R')) {
         setTargetHotend(code_value(), tmp_extruder);
 #ifdef DUAL_X_CARRIAGE
         if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
           setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
-#endif          
+#endif
         CooldownNoWait = false;
       }
       #ifdef AUTOTEMP
@@ -2012,7 +2016,7 @@ void process_commands()
             SET_OUTPUT(SUICIDE_PIN);
             WRITE(SUICIDE_PIN, HIGH);
         #endif
-        
+
         #ifdef ULTIPANEL
           powersupply = true;
           LCD_MESSAGEPGM(WELCOME_MSG);
@@ -2169,18 +2173,18 @@ void process_commands()
       #endif
       break;
       //TODO: update for all axis, use for loop
-    #ifdef BLINKM  
+    #ifdef BLINKM
     case 150: // M150
       {
         byte red;
         byte grn;
         byte blu;
-        
+
         if(code_seen('R')) red = code_value();
         if(code_seen('U')) grn = code_value();
         if(code_seen('B')) blu = code_value();
-        
-        SendColors(red,grn,blu);        
+
+        SendColors(red,grn,blu);
       }
       break;
     #endif //BLINKM
@@ -2302,7 +2306,7 @@ void process_commands()
       {
         extruder_offset[Z_AXIS][tmp_extruder] = code_value();
       }
-      #endif       
+      #endif
       SERIAL_ECHO_START;
       SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
       for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++)
@@ -2335,17 +2339,17 @@ void process_commands()
       }
     }
     break;
-	
+
 	case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
 	{
       if(code_seen('P')){
         int pin_number = code_value(); // pin number
         int pin_state = -1; // required pin state - default is inverted
-        
+
         if(code_seen('S')) pin_state = code_value(); // required pin state
-      
+
         if(pin_state >= -1 && pin_state <= 1){
-        
+
           for(int8_t i = 0; i < (int8_t)sizeof(sensitive_pins); i++)
           {
             if (sensitive_pins[i] == pin_number)
@@ -2354,28 +2358,28 @@ void process_commands()
               break;
             }
           }
-        
+
           if (pin_number > -1)
           {
             st_synchronize();
-            
+
             pinMode(pin_number, INPUT);
-            
+
             int target;
             switch(pin_state){
             case 1:
               target = HIGH;
               break;
-            
+
             case 0:
               target = LOW;
               break;
-            
+
             case -1:
               target = !digitalRead(pin_number);
               break;
             }
-            
+
             while(digitalRead(pin_number) != target){
               manage_heater();
               manage_inactivity();
@@ -2385,7 +2389,7 @@ void process_commands()
         }
       }
     }
-    break;	
+    break;
 
     #if NUM_SERVOS > 0
     case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
@@ -2561,13 +2565,13 @@ void process_commands()
         engage_z_probe();    // Engage Z Servo endstop if available
     }
     break;
-    
+
     case 402:
     {
         retract_z_probe();    // Retract Z Servo endstop if enabled
     }
     break;
-#endif    
+#endif
     case 500: // M500 Store settings in EEPROM
     {
         Config_StoreSettings();
@@ -2725,14 +2729,14 @@ void process_commands()
               //    M605 S0: Full control mode. The slicer has full control over x-carriage movement
               //    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
               //    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
-              //                         millimeters x-offset and an optional differential hotend temperature of 
+              //                         millimeters x-offset and an optional differential hotend temperature of
               //                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
               //                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
               //
               //    Note: the X axis should be homed after changing dual x-carriage mode.
     {
         st_synchronize();
-        
+
         if (code_seen('S'))
           dual_x_carriage_mode = code_value();
 
@@ -2743,7 +2747,7 @@ void process_commands()
 
           if (code_seen('R'))
             duplicate_extruder_temp_offset = code_value();
-            
+
           SERIAL_ECHO_START;
           SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
           SERIAL_ECHO(" ");
@@ -2759,13 +2763,13 @@ void process_commands()
         {
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
         }
-        
+
         active_extruder_parked = false;
         extruder_duplication_enabled = false;
         delayed_move_time = 0;
     }
     break;
-    #endif //DUAL_X_CARRIAGE         
+    #endif //DUAL_X_CARRIAGE
 
     case 907: // M907 Set digital trimpot motor current using axis codes.
     {
@@ -2846,19 +2850,19 @@ void process_commands()
         // Save current position to return to after applying extruder offset
         memcpy(destination, current_position, sizeof(destination));
       #ifdef DUAL_X_CARRIAGE
-        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false && 
+        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
             (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
         {
           // Park old head: 1) raise 2) move to park position 3) lower
-          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                 current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
-          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS], 
+          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                 current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
           st_synchronize();
         }
-        
+
         // apply Y & Z extruder offset (x offset is already used in determining home pos)
         current_position[Y_AXIS] = current_position[Y_AXIS] -
                      extruder_offset[Y_AXIS][active_extruder] +
@@ -2866,7 +2870,7 @@ void process_commands()
         current_position[Z_AXIS] = current_position[Z_AXIS] -
                      extruder_offset[Z_AXIS][active_extruder] +
                      extruder_offset[Z_AXIS][tmp_extruder];
-                     
+
         active_extruder = tmp_extruder;
 
         // This function resets the max/min values - the current position may be overwritten below.
@@ -2874,18 +2878,18 @@ void process_commands()
 
         if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)
         {
-          current_position[X_AXIS] = inactive_extruder_x_pos; 
+          current_position[X_AXIS] = inactive_extruder_x_pos;
           inactive_extruder_x_pos = destination[X_AXIS];
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
         {
           active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
           if (active_extruder == 0 || active_extruder_parked)
-            current_position[X_AXIS] = inactive_extruder_x_pos; 
+            current_position[X_AXIS] = inactive_extruder_x_pos;
           else
-            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset; 
+            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
           inactive_extruder_x_pos = destination[X_AXIS];
-          extruder_duplication_enabled = false; 
+          extruder_duplication_enabled = false;
         }
         else
         {
@@ -2895,7 +2899,7 @@ void process_commands()
           active_extruder_parked = true;
           delayed_move_time = 0;
         }
-      #else    
+      #else
         // Offset extruder (only by XY)
         int i;
         for(i = 0; i < 2; i++) {
@@ -3108,13 +3112,13 @@ void prepare_move()
     {
       // move duplicate extruder into correct duplication position.
       plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[X_AXIS], 1);
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
       st_synchronize();
       extruder_duplication_enabled = true;
       active_extruder_parked = false;
-    }  
+    }
     else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head
     {
       if (current_position[E_AXIS] == destination[E_AXIS])
@@ -3123,7 +3127,7 @@ void prepare_move()
         // be used as start of first non-travel move)
         if (delayed_move_time != 0xFFFFFFFFUL)
         {
-          memcpy(current_position, destination, sizeof(current_position)); 
+          memcpy(current_position, destination, sizeof(current_position));
           if (destination[Z_AXIS] > raised_parked_position[Z_AXIS])
             raised_parked_position[Z_AXIS] = destination[Z_AXIS];
           delayed_move_time = millis();
@@ -3133,9 +3137,9 @@ void prepare_move()
       delayed_move_time = 0;
       // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
       plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS],
           current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);
-      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
           current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
       active_extruder_parked = false;
     }
@@ -3301,7 +3305,7 @@ void manage_inactivity()
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       memcpy(destination,current_position,sizeof(destination));
-      prepare_move(); 
+      prepare_move();
     }
   #endif
   #ifdef TEMP_STAT_LEDS
diff --git a/Marlin/example_configurations/delta/Configuration.h b/Marlin/example_configurations/delta/Configuration.h
index dbd2892..0d232d3 100644
--- a/Marlin/example_configurations/delta/Configuration.h
+++ b/Marlin/example_configurations/delta/Configuration.h
@@ -5,6 +5,13 @@
 // Advanced settings can be found in Configuration_adv.h
 // BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration
 
+//===========================================================================
+//============================= DELTA Printer ===============================
+//===========================================================================
+// For a Delta printer rplace the configuration files wilth the files in the
+// example_configurations/delta directory.
+//
+
 // User-specified version info of this build to display in [Pronterface, etc] terminal window during
 // startup. Implementation of an idea by Prof Braino to inform user that any changes made to this
 // build by the user have been successfully uploaded into firmware.
@@ -18,13 +25,18 @@
 
 // This determines the communication speed of the printer
 #define BAUDRATE 250000
-//#define BAUDRATE 115200
+
+// This enables the serial port associated to the Bluetooth interface
+//#define BTENABLED              // Enable BT interface on AT90USB devices
+
 
 //// The following define selects which electronics board you have. Please choose the one that matches your setup
 // 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"
 // 11 = Gen7 v1.1, v1.2 = 11
 // 12 = Gen7 v1.3
 // 13 = Gen7 v1.4
+// 2  = Cheaptronic v1.0
+// 20 = Sethi 3D_1
 // 3  = MEGA/RAMPS up to 1.2 = 3
 // 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)
 // 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)
@@ -38,6 +50,7 @@
 // 64 = STB V1.1
 // 65 = Azteeg X1
 // 66 = Melzi with ATmega1284 (MaKr3d version)
+// 67 = Azteeg X3
 // 7  = Ultimaker
 // 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)
 // 77 = 3Drag Controller
@@ -45,6 +58,7 @@
 // 80 = Rumba
 // 81 = Printrboard (AT90USB1286)
 // 82 = Brainwave (AT90USB646)
+// 83 = SAV Mk-I (AT90USB1286)
 // 9  = Gen3+
 // 70 = Megatronics
 // 701= Megatronics v2.0
@@ -61,6 +75,10 @@
 // Define this to set a custom name for your generic Mendel,
 // #define CUSTOM_MENDEL_NAME "This Mendel"
 
+// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)
+// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)
+// #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"
+
 // This defines the number of extruders
 #define EXTRUDERS 1
 
@@ -70,6 +88,8 @@
 
 #define POWER_SUPPLY 1
 
+// Define this to have the electronics keep the powersupply off on startup. If you don't know what this is leave it.
+// #define PS_DEFAULT_OFF
 
 //===========================================================================
 //============================== Delta Settings =============================
@@ -125,9 +145,10 @@
 // 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)
 // 3 is mendel-parts thermistor (4.7k pullup)
 // 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!
-// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan) (4.7k pullup)
+// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)
 // 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)
 // 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)
+// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)
 // 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)
 // 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)
 // 10 is 100k RS thermistor 198-961 (4.7k pullup)
@@ -137,7 +158,7 @@
 //                          (but gives greater accuracy and more stable PID)
 // 51 is 100k thermistor - EPCOS (1k pullup)
 // 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)
-// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan) (1k pullup)
+// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)
 
 #define TEMP_SENSOR_0 -1
 #define TEMP_SENSOR_1 -1
@@ -282,16 +303,15 @@
 #endif
 
 // The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.
-const bool X_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-const bool Y_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-const bool X_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-const bool Y_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
-
-// deltas never have min endstops
+const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.
+//#define DISABLE_MAX_ENDSTOPS
+// Deltas never have min endstops
 #define DISABLE_MIN_ENDSTOPS
-
 // Disable max endstops for compatibility with endstop checking routine
 #if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)
   #define DISABLE_MAX_ENDSTOPS
@@ -338,6 +358,58 @@ const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic o
 #define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)
 #define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)
 #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
+//============================= Bed Auto Leveling ===========================
+
+//#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+
+#ifdef ENABLE_AUTO_BED_LEVELING
+
+  // these are the positions on the bed to do the probing
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define BACK_PROBE_BED_POSITION 180
+  #define FRONT_PROBE_BED_POSITION 20
+
+  // these are the offsets to the prob relative to the extruder tip (Hotend - Probe)
+  #define X_PROBE_OFFSET_FROM_EXTRUDER -25
+  #define Y_PROBE_OFFSET_FROM_EXTRUDER -29
+  #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35
+
+  #define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z before homing (G28) for Probe Clearance.
+                                        // Be sure you have this distance over your Z_MAX_POS in case
+
+  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min
+
+  #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
+  #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
+
+
+  //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk
+  //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
+  // You MUST HAVE the SERVO_ENDSTOPS defined to use here a value higher than zero otherwise your code will not compile.
+
+//  #define PROBE_SERVO_DEACTIVATION_DELAY 300
+
+
+//If you have enabled the Bed Auto Levelling and are using the same Z Probe for Z Homing,
+//it is highly recommended you let this Z_SAFE_HOMING enabled!!!
+
+  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with probe outside the bed area.
+                          // When defined, it will:
+                          // - Allow Z homing only after X and Y homing AND stepper drivers still enabled
+                          // - If stepper drivers timeout, it will need X and Y homing again before Z homing
+                          // - Position the probe in a defined XY point before Z Homing when homing all axis (G28)
+                          // - Block Z homing only when the probe is outside bed area.
+
+  #ifdef Z_SAFE_HOMING
+
+    #define Z_SAFE_HOMING_X_POINT (X_MAX_LENGTH/2)    // X point for Z homing when homing all axis (G28)
+    #define Z_SAFE_HOMING_Y_POINT (Y_MAX_LENGTH/2)    // Y point for Z homing when homing all axis (G28)
+
+  #endif
+
+#endif
+
 
 // The position of the homing switches
 //#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
@@ -406,7 +478,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic o
 //#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)
 //#define SDSUPPORT // Enable SD Card Support in Hardware Console
 //#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)
-
+//#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder
+//#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking
 //#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.
 //#define ULTIPANEL  //the ultipanel as on thingiverse
 
@@ -510,6 +583,17 @@ const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic o
   #define ULTIPANEL
 #endif
 
+// Shift register panels
+// ---------------------
+// 2 wire Non-latching LCD SR from:
+// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+//#define SR_LCD
+#ifdef SR_LCD
+   #define SR_LCD_2W_NL    // Non latching 2 wire shiftregister
+   //#define NEWPANEL
+#endif
+
+
 #ifdef ULTIPANEL
 //  #define NEWPANEL  //enable this if you have a click-encoder panel
   #define SDSUPPORT
@@ -543,6 +627,11 @@ const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic o
 // Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino
 //#define FAST_PWM_FAN
 
+// Temperature status leds that display the hotend and bet temperature.
+// If alle hotends and bed temperature and temperature setpoint are < 54C then the BLUE led is on.
+// Otherwise the RED led is on. There is 1C hysteresis.
+//#define TEMP_STAT_LEDS
+
 // Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
 // which is not ass annoying as with the hardware PWM. On the other hand, if this frequency
 // is too low, you should also increment SOFT_PWM_SCALE.
@@ -564,6 +653,9 @@ const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic o
 // Support for the BariCUDA Paste Extruder.
 //#define BARICUDA
 
+//define BlinkM/CyzRgb Support
+//#define BLINKM
+
 /*********************************************************************\
 * R/C SERVO support
 * Sponsored by TrinityLabs, Reworked by codexmas
diff --git a/Marlin/example_configurations/delta/Configuration_adv.h b/Marlin/example_configurations/delta/Configuration_adv.h
index d3c2d19..fcf6ff5 100644
--- a/Marlin/example_configurations/delta/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/Configuration_adv.h
@@ -40,6 +40,10 @@
   #define AUTOTEMP_OLDWEIGHT 0.98
 #endif
 
+//Show Temperature ADC value
+//The M105 command return, besides traditional information, the ADC value read from temperature sensors.
+//#define SHOW_TEMP_ADC_VALUES
+
 //  extruder run-out prevention. 
 //if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded
 //#define EXTRUDER_RUNOUT_PREVENT  
@@ -146,6 +150,21 @@
   #define EXTRUDERS 1
 #endif
 
+// Same again but for Y Axis.
+//#define Y_DUAL_STEPPER_DRIVERS
+
+// Define if the two Y drives need to rotate in opposite directions
+#define INVERT_Y2_VS_Y_DIR true
+
+#ifdef Y_DUAL_STEPPER_DRIVERS
+  #undef EXTRUDERS
+  #define EXTRUDERS 1
+#endif
+
+#if defined (Z_DUAL_STEPPER_DRIVERS) && defined (Y_DUAL_STEPPER_DRIVERS)
+  #error "You cannot have dual drivers for both Y and Z"
+#endif
+
 // Enable this for dual x-carriage printers. 
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage
@@ -155,8 +174,8 @@
 // Configuration for second X-carriage
 // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;
 // the second x-carriage always homes to the maximum endstop.
-#define X2_MIN_POS 88     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
-#define X2_MAX_POS 350.45 // set maximum to the distance between toolheads when both heads are homed 
+#define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage
+#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed 
 #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position
 #define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position 
     // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software 
@@ -169,14 +188,35 @@
 #define X2_STEP_PIN 25
 #define X2_DIR_PIN 23
 
-#endif // DUAL_X_CARRIAGE
+// There are a few selectable movement modes for dual x-carriages using M605 S<mode>
+//    Mode 0: Full control. The slicer has full control over both x-carriages and can achieve optimal travel results
+//                           as long as it supports dual x-carriages. (M605 S0)
+//    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so
+//                           that additional slicer support is not required. (M605 S1)
+//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all  
+//                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at
+//                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])
+
+// This is the default power-up mode which can be later using M605. 
+#define DEFAULT_DUAL_X_CARRIAGE_MODE 0 
+
+// As the x-carriages are independent we can now account for any relative Z offset
+#define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0
+
+// Default settings in "Auto-park Mode" 
+#define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder
+#define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder
+
+// Default x offset in duplication mode (typically set to half print bed width)
+#define DEFAULT_DUPLICATION_X_OFFSET 100
+
+#endif //DUAL_X_CARRIAGE
     
 //homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:
 #define X_HOME_RETRACT_MM 5 
-#define Y_HOME_RETRACT_MM 5
+#define Y_HOME_RETRACT_MM 5 
 #define Z_HOME_RETRACT_MM 5 // deltas need the same for all three axis
 
-
 //#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.
 
 #define AXIS_RELATIVE_MODES {false, false, false, false}
@@ -238,6 +278,11 @@
 #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?
 #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.
 
+#define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the filesystem block order. 
+// if a file is deleted, it frees a block. hence, the order is not purely cronological. To still have auto0.g accessible, there is again the option to do that.
+// using:
+//#define MENU_ADDAUTOSTART
+
 // The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.
 //#define USE_WATCHDOG
 
@@ -251,6 +296,26 @@
 // Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.
 //#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
 
+// Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process
+// it can e.g. be used to change z-positions in the print startup phase in realtime
+// does not respect endstops!
+//#define BABYSTEPPING
+#ifdef BABYSTEPPING
+  #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions
+  #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z
+  #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements
+  
+  #ifdef COREXY
+    #error BABYSTEPPING not implemented for COREXY yet.
+  #endif
+
+  #ifdef DELTA
+    #ifdef BABYSTEP_XY
+      #error BABYSTEPPING only implemented for Z axis on deltabots.
+    #endif
+  #endif
+#endif
+
 // extruder advance constant (s2/mm3)
 //
 // advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2
@@ -302,6 +367,9 @@ const unsigned int dropsegments=5; //everything with less than this number of st
   #define PS_ON_ASLEEP LOW
 #endif
 
+// Control heater 0 and heater 1 in parallel.
+//#define HEATERS_PARALLEL
+
 //===========================================================================
 //=============================Buffers           ============================
 //===========================================================================
@@ -332,7 +400,7 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 
 //adds support for experimental filament exchange support M600; requires display
 #ifdef ULTIPANEL
-  //#define FILAMENTCHANGEENABLE
+  #define FILAMENTCHANGEENABLE
   #ifdef FILAMENTCHANGEENABLE
     #define FILAMENTCHANGE_XPOS 3
     #define FILAMENTCHANGE_YPOS 3
@@ -341,6 +409,12 @@ const unsigned int dropsegments=5; //everything with less than this number of st
     #define FILAMENTCHANGE_FINALRETRACT -100
   #endif
 #endif
+
+#ifdef FILAMENTCHANGEENABLE
+  #ifdef EXTRUDER_RUNOUT_PREVENT
+    #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE
+  #endif 
+#endif
  
 //===========================================================================
 //=============================  Define Defines  ============================
@@ -349,6 +423,10 @@ const unsigned int dropsegments=5; //everything with less than this number of st
   #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS > 1"
 #endif
 
+#if EXTRUDERS > 1 && defined HEATERS_PARALLEL
+  #error "You cannot use HEATERS_PARALLEL if EXTRUDERS > 1"
+#endif
+
 #if TEMP_SENSOR_0 > 0
   #define THERMISTORHEATER_0 TEMP_SENSOR_0
   #define HEATER_0_USES_THERMISTOR
diff --git a/Marlin/pins.h b/Marlin/pins.h
index ba73a3c..b7cbac4 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -2288,6 +2288,107 @@
 
 #endif
 
+/****************************************************************************************
+* Cheaptronic v1.0
+*
+****************************************************************************************/
+#if MOTHERBOARD == 2
+ #define KNOWN_BOARD 1
+
+ #ifndef __AVR_ATmega2560__
+ #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+
+ #define LARGE_FLASH        true
+
+ //X motor stepper
+ #define X_STEP_PIN 14
+ #define X_DIR_PIN 15
+ #define X_ENABLE_PIN 24
+ 
+ //X endstop
+ #define X_MIN_PIN 3
+ #define X_MAX_PIN -1
+
+ //Y motor stepper
+ #define Y_STEP_PIN 35
+ #define Y_DIR_PIN 36
+ #define Y_ENABLE_PIN 31
+
+ //Y endstop
+ #define Y_MIN_PIN 2
+ #define Y_MAX_PIN -1
+ 
+ //Z motor stepper
+ #define Z_STEP_PIN 40
+ #define Z_DIR_PIN 41
+ #define Z_ENABLE_PIN 37
+
+ //Z endstop
+ #define Z_MIN_PIN 5
+ #define Z_MAX_PIN -1
+ 
+ //Extruder 0 stepper
+ #define E0_STEP_PIN 26
+ #define E0_DIR_PIN 28
+ #define E0_ENABLE_PIN 25
+
+ //Extruder 1 stepper
+ #define E1_STEP_PIN 33
+ #define E1_DIR_PIN 34
+ #define E1_ENABLE_PIN 30
+
+ #define SDPOWER -1
+ #define SDSS -1
+ #define LED_PIN -1
+
+ //FAN
+ #define FAN_PIN -1
+
+ #define PS_ON_PIN -1
+ #define KILL_PIN -1
+
+ #define HEATER_0_PIN 19 // EXTRUDER 1
+ #define HEATER_1_PIN 23 // EXTRUDER 2
+ //HeatedBad
+ #define HEATER_BED_PIN 22
+ //Cheaptronic v1.0 hasent EXTRUDER 3
+ #define HEATER_2_PIN -1
+ 
+ //Temperature sensors
+ #define TEMP_0_PIN 15
+ #define TEMP_1_PIN 14
+ #define TEMP_2_PIN -1
+ #define TEMP_BED_PIN 13
+
+ //Cheaptronic v1.0 dont support LCD
+ #define LCD_PINS_RS -1
+ #define LCD_PINS_ENABLE -1
+ #define LCD_PINS_D4 -1
+ #define LCD_PINS_D5 -1
+ #define LCD_PINS_D6 -1
+ #define LCD_PINS_D7 -1
+
+ //Cheaptronic v1.0 dont support keypad
+ #define BTN_EN1 -1
+ #define BTN_EN2 -1
+ #define BTN_ENC -1
+
+ #define BLEN_C 2
+ #define BLEN_B 1
+ #define BLEN_A 0
+
+ //Cheaptronic v1.0 does not use this port
+ #define SDCARDDETECT -1
+
+ //encoder rotation values
+ #define encrot0 0
+ #define encrot1 2
+ #define encrot2 3
+ #define encrot3 1
+
+#endif
+
 
 
 #ifndef KNOWN_BOARD
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index d9299c4..a9da533 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -186,9 +186,9 @@ void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exi
 
   long acceleration = block->acceleration_st;
   int32_t accelerate_steps =
-    ceil(estimate_acceleration_distance(block->initial_rate, block->nominal_rate, acceleration));
+    ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, acceleration));
   int32_t decelerate_steps =
-    floor(estimate_acceleration_distance(block->nominal_rate, block->final_rate, -acceleration));
+    floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -acceleration));
 
   // Calculate the size of Plateau of Nominal Rate.
   int32_t plateau_steps = block->step_event_count-accelerate_steps-decelerate_steps;
@@ -197,7 +197,7 @@ void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exi
   // have to use intersection_distance() to calculate when to abort acceleration and start braking
   // in order to reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
-    accelerate_steps = ceil(intersection_distance(block->initial_rate, block->final_rate, acceleration, block->step_event_count));
+    accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, acceleration, block->step_event_count));
     accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off
     accelerate_steps = min((uint32_t)accelerate_steps,block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 163c881..fe8cab0 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -90,12 +90,16 @@ static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned l
 #define ENCODER_FEEDRATE_DEADZONE 10
 
 #if !defined(LCD_I2C_VIKI)
-  #define ENCODER_STEPS_PER_MENU_ITEM 5
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+    #define ENCODER_STEPS_PER_MENU_ITEM 5
+  #endif
   #ifndef ENCODER_PULSES_PER_STEP
     #define ENCODER_PULSES_PER_STEP 1
   #endif
 #else
-  #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+    #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation
+  #endif
   #ifndef ENCODER_PULSES_PER_STEP
     #define ENCODER_PULSES_PER_STEP 1
   #endif
@@ -207,7 +211,7 @@ static void lcd_status_screen()
     else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
     {
         feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
-        encoderPosition = 0;	
+        encoderPosition = 0;
     }
     else if (feedmultiply != 100)
     {
@@ -407,7 +411,7 @@ static void lcd_tune_menu()
 #endif
     MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
     MENU_ITEM_EDIT(int3, MSG_FLOW, &extrudemultiply, 10, 999);
-    
+
 #ifdef BABYSTEPPING
     #ifdef BABYSTEP_XY
       MENU_ITEM(submenu, "Babystep X", lcd_babystep_x);
@@ -719,7 +723,7 @@ static void lcd_control_motion_menu()
     MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);
     MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);
     MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);
-    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);    
+    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);
 #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
     MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);
 #endif
@@ -781,7 +785,7 @@ static void lcd_sd_updir()
 
 void lcd_sdcard_menu()
 {
-    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) 
+    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0)
         return;	// nothing to do (so don't thrash the SD card)
     uint16_t fileCnt = card.getnrfilenames();
     START_MENU();
@@ -795,7 +799,7 @@ void lcd_sdcard_menu()
     }else{
         MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
     }
-    
+
     for(uint16_t i=0;i<fileCnt;i++)
     {
         if (_menuItemNr == _lineNr)
@@ -982,14 +986,14 @@ void lcd_init()
 
 #ifdef NEWPANEL
     pinMode(BTN_EN1,INPUT);
-    pinMode(BTN_EN2,INPUT); 
+    pinMode(BTN_EN2,INPUT);
     pinMode(SDCARDDETECT,INPUT);
     WRITE(BTN_EN1,HIGH);
     WRITE(BTN_EN2,HIGH);
   #if BTN_ENC > 0
-    pinMode(BTN_ENC,INPUT); 
+    pinMode(BTN_ENC,INPUT);
     WRITE(BTN_ENC,HIGH);
-  #endif    
+  #endif
   #ifdef REPRAPWORLD_KEYPAD
     pinMode(SHIFT_CLK,OUTPUT);
     pinMode(SHIFT_LD,OUTPUT);
@@ -1007,9 +1011,9 @@ void lcd_init()
      pinMode(SHIFT_EN,OUTPUT);
      pinMode(SHIFT_OUT,INPUT);
      WRITE(SHIFT_OUT,HIGH);
-     WRITE(SHIFT_LD,HIGH); 
+     WRITE(SHIFT_LD,HIGH);
      WRITE(SHIFT_EN,LOW);
-   #endif // SR_LCD_2W_NL    
+   #endif // SR_LCD_2W_NL
 #endif//!NEWPANEL
 
 #if (SDCARDDETECT > 0)
@@ -1020,28 +1024,28 @@ void lcd_init()
     slow_buttons = 0;
     #endif
     lcd_buttons_update();
-#ifdef ULTIPANEL    
+#ifdef ULTIPANEL
     encoderDiff = 0;
-#endif    
+#endif
 }
 
 void lcd_update()
 {
     static unsigned long timeoutToStatus = 0;
-    
+
     #ifdef LCD_HAS_SLOW_BUTTONS
     slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
     #endif
-    
+
     lcd_buttons_update();
-    
+
     #if (SDCARDDETECT > 0)
     if((IS_SD_INSERTED != lcd_oldcardstatus))
     {
         lcdDrawUpdate = 2;
         lcd_oldcardstatus = IS_SD_INSERTED;
         lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.
-        
+
         if(lcd_oldcardstatus)
         {
             card.initsd();
@@ -1054,7 +1058,7 @@ void lcd_update()
         }
     }
     #endif//CARDINSERTED
-    
+
     if (lcd_next_update_millis < millis())
     {
 #ifdef ULTIPANEL
@@ -1095,7 +1099,7 @@ void lcd_update()
 #ifdef DOGLCD        // Changes due to different driver architecture of the DOGM display
         blink++;     // Variable for fan animation and alive dot
         u8g.firstPage();
-        do 
+        do
         {
             u8g.setFont(u8g_font_6x10_marlin);
             u8g.setPrintPos(125,0);
@@ -1105,7 +1109,7 @@ void lcd_update()
             (*currentMenu)();
             if (!lcdDrawUpdate)  break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()
         } while( u8g.nextPage() );
-#else        
+#else
         (*currentMenu)();
 #endif
 
@@ -1159,7 +1163,7 @@ void lcd_reset_alert_level()
 void lcd_setcontrast(uint8_t value)
 {
     lcd_contrast = value & 63;
-    u8g.setContrast(lcd_contrast);	
+    u8g.setContrast(lcd_contrast);
 }
 #endif
 
@@ -1199,7 +1203,7 @@ void lcd_buttons_update()
     WRITE(SHIFT_LD,HIGH);
     unsigned char tmp_buttons=0;
     for(int8_t i=0;i<8;i++)
-    { 
+    {
         newbutton = newbutton>>1;
         if(READ(SHIFT_OUT))
             newbutton|=(1<<7);
@@ -1249,14 +1253,14 @@ void lcd_buttons_update()
 }
 
 void lcd_buzz(long duration, uint16_t freq)
-{ 
+{
 #ifdef LCD_USE_I2C_BUZZER
   lcd.buzz(duration,freq);
-#endif   
+#endif
 }
 
-bool lcd_clicked() 
-{ 
+bool lcd_clicked()
+{
   return LCD_CLICKED;
 }
 #endif//ULTIPANEL

commit 6ae7f7870d8ff09d99fdf7ed1dc64a6f727020ce (from 8f195844dd536e06b0192d729eee8722544d888e)
Merge: da2a6f9 8f19584
Author: fsantini <francesco.santini@gmail.com>
Date:   Mon Dec 23 12:20:32 2013 +0100

    Merge branch 'Marlin_v1' of https://github.com/ErikZalm/Marlin into ErikZalm
    
    Conflicts:
    	Marlin/Configuration.h
    	Marlin/Marlin_main.cpp

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index b4acbac..33a1c3a 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -367,6 +367,15 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 
   #endif
 
+  // with accurate bed leveling, the bed is sampled in a ACCURATE_BED_LEVELING_POINTSxACCURATE_BED_LEVELING_POINTS grid and least squares solution is calculated
+  // Note: this feature occupies 10'206 byte
+  #define ACCURATE_BED_LEVELING
+  
+  #ifdef ACCURATE_BED_LEVELING
+     // I wouldn't see a reason to go above 3 (=9 probing points on the bed)
+    #define ACCURATE_BED_LEVELING_POINTS 2
+  #endif
+  
 #endif
 
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index db072b9..8f00640 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -31,6 +31,9 @@
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 #include "vector_3.h"
+  #ifdef ACCURATE_BED_LEVELING
+    #include "qr_solve.h"
+  #endif
 #endif // ENABLE_AUTO_BED_LEVELING
 
 #include "ultralcd.h"
@@ -802,6 +805,31 @@ static void axis_is_at_home(int axis) {
 }
 
 #ifdef ENABLE_AUTO_BED_LEVELING
+#ifdef ACCURATE_BED_LEVELING
+static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
+{
+    vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
+    planeNormal.debug("planeNormal");
+    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
+    //bedLevel.debug("bedLevel");
+
+    //plan_bed_level_matrix.debug("bed level before");
+    //vector_3 uncorrected_position = plan_get_position_mm();
+    //uncorrected_position.debug("position before");
+
+    vector_3 corrected_position = plan_get_position();
+//    corrected_position.debug("position after");
+    current_position[X_AXIS] = corrected_position.x;
+    current_position[Y_AXIS] = corrected_position.y;
+    current_position[Z_AXIS] = corrected_position.z;
+
+    // but the bed at 0 so we don't go below it.
+    current_position[Z_AXIS] = -Z_PROBE_OFFSET_FROM_EXTRUDER;
+
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+}
+
+#else
 static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yFront, float z_at_xLeft_yBack) {
     plan_bed_level_matrix.set_to_identity();
 
@@ -811,11 +839,11 @@ static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yF
 
     vector_3 xPositive = (xRightyFront - xLeftyFront).get_normal();
     vector_3 yPositive = (xLeftyBack - xLeftyFront).get_normal();
-    vector_3 planeNormal = vector_3::cross(yPositive, xPositive).get_normal();
+    vector_3 planeNormal = vector_3::cross(xPositive, yPositive).get_normal();
 
     //planeNormal.debug("planeNormal");
     //yPositive.debug("yPositive");
-    matrix_3x3 bedLevel = matrix_3x3::create_look_at(planeNormal, yPositive);
+    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
     //bedLevel.debug("bedLevel");
 
     //plan_bed_level_matrix.debug("bed level before");
@@ -823,7 +851,6 @@ static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yF
     //uncorrected_position.debug("position before");
 
     // and set our bed level equation to do the right thing
-    plan_bed_level_matrix = matrix_3x3::create_inverse(bedLevel);
     //plan_bed_level_matrix.debug("bed level after");
 
     vector_3 corrected_position = plan_get_position();
@@ -837,6 +864,7 @@ static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yF
 
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 }
+#endif // ACCURATE_BED_LEVELING
 
 static void run_z_probe() {
     plan_bed_level_matrix.set_to_identity();
@@ -1325,7 +1353,99 @@ void process_commands()
             setup_for_endstop_move();
 
             feedrate = homing_feedrate[Z_AXIS];
-
+#ifdef ACCURATE_BED_LEVELING
+            
+            int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
+            int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (ACCURATE_BED_LEVELING_POINTS-1);
+            
+            
+            // solve the plane equation ax + by + d = z
+            // A is the matrix with rows [x y 1] for all the probed points
+            // B is the vector of the Z positions
+            // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
+            // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
+            
+            // "A" matrix of the linear system of equations
+            double eqnAMatrix[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS*3];
+            // "B" vector of Z points
+            double eqnBVector[ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS];
+            
+            
+            int probePointCounter = 0;
+            bool zig = true;
+            
+            for (int yProbe=FRONT_PROBE_BED_POSITION; yProbe <= BACK_PROBE_BED_POSITION; yProbe += yGridSpacing)
+            {
+              int xProbe, xInc;
+              if (zig)
+              {
+                xProbe = LEFT_PROBE_BED_POSITION;
+                //xEnd = RIGHT_PROBE_BED_POSITION;
+                xInc = xGridSpacing;
+                zig = false;
+              } else // zag
+              {
+                xProbe = RIGHT_PROBE_BED_POSITION;
+                //xEnd = LEFT_PROBE_BED_POSITION;
+                xInc = -xGridSpacing;
+                zig = true;
+              }
+              
+              for (int xCount=0; xCount < ACCURATE_BED_LEVELING_POINTS; xCount++)
+              {
+                if (probePointCounter == 0)
+                {
+                  // raise before probing
+                  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
+                } else
+                {               
+                  // raise extruder
+                  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);
+                }
+                
+                
+                do_blocking_move_to(xProbe - X_PROBE_OFFSET_FROM_EXTRUDER, yProbe - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
+    
+                engage_z_probe();   // Engage Z Servo endstop if available
+                run_z_probe();
+                eqnBVector[probePointCounter] = current_position[Z_AXIS];
+                retract_z_probe();
+    
+                SERIAL_PROTOCOLPGM("Bed x: ");
+                SERIAL_PROTOCOL(xProbe);
+                SERIAL_PROTOCOLPGM(" y: ");
+                SERIAL_PROTOCOL(yProbe);
+                SERIAL_PROTOCOLPGM(" z: ");
+                SERIAL_PROTOCOL(current_position[Z_AXIS]);
+                SERIAL_PROTOCOLPGM("\n");
+                
+                eqnAMatrix[probePointCounter + 0*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = xProbe;
+                eqnAMatrix[probePointCounter + 1*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = yProbe;
+                eqnAMatrix[probePointCounter + 2*ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS] = 1;
+                probePointCounter++;
+                xProbe += xInc;
+              }
+            }
+            clean_up_after_endstop_move();
+            
+            // solve lsq problem
+            double *plane_equation_coefficients = qr_solve(ACCURATE_BED_LEVELING_POINTS*ACCURATE_BED_LEVELING_POINTS, 3, eqnAMatrix, eqnBVector);
+            
+            SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
+            SERIAL_PROTOCOL(plane_equation_coefficients[0]);
+            SERIAL_PROTOCOLPGM(" b: ");
+            SERIAL_PROTOCOL(plane_equation_coefficients[1]);
+            SERIAL_PROTOCOLPGM(" d: ");
+            SERIAL_PROTOCOLLN(plane_equation_coefficients[2]);
+            
+            
+            set_bed_level_equation_lsq(plane_equation_coefficients);
+            
+            free(plane_equation_coefficients);
+            
+#else // ACCURATE_BED_LEVELING not defined
+            
+            
             // prob 1
             do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);
             do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, BACK_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
@@ -1381,7 +1501,9 @@ void process_commands()
             clean_up_after_endstop_move();
 
             set_bed_level_equation(z_at_xLeft_yFront, z_at_xRight_yFront, z_at_xLeft_yBack);
-
+         
+            
+#endif // ACCURATE_BED_LEVELING
             st_synchronize();
 
             // The following code correct the Z height difference from z-probe position and hotend tip position.
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 457988d..a9da533 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -942,7 +942,7 @@ vector_3 plan_get_position() {
 
 	//position.debug("in plan_get position");
 	//plan_bed_level_matrix.debug("in plan_get bed_level");
-	matrix_3x3 inverse = matrix_3x3::create_inverse(plan_bed_level_matrix);
+	matrix_3x3 inverse = matrix_3x3::transpose(plan_bed_level_matrix);
 	//inverse.debug("in plan_get inverse");
 	position.apply_rotation(inverse);
 	//position.debug("after rotation");
diff --git a/Marlin/qr_solve.cpp b/Marlin/qr_solve.cpp
new file mode 100644
index 0000000..0a49128
--- /dev/null
+++ b/Marlin/qr_solve.cpp
@@ -0,0 +1,1932 @@
+#include "qr_solve.h"
+
+#ifdef ACCURATE_BED_LEVELING
+
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>
+
+
+//# include "r8lib.h"
+
+int i4_min ( int i1, int i2 )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    I4_MIN returns the smaller of two I4's.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    29 August 2006
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, int I1, I2, two integers to be compared.
+
+    Output, int I4_MIN, the smaller of I1 and I2.
+*/
+{
+  int value;
+
+  if ( i1 < i2 )
+  {
+    value = i1;
+  }
+  else
+  {
+    value = i2;
+  }
+  return value;
+}
+
+double r8_epsilon ( void )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8_EPSILON returns the R8 round off unit.
+
+  Discussion:
+
+    R8_EPSILON is a number R which is a power of 2 with the property that,
+    to the precision of the computer's arithmetic,
+      1 < 1 + R
+    but
+      1 = ( 1 + R / 2 )
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    01 September 2012
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Output, double R8_EPSILON, the R8 round-off unit.
+*/
+{
+  const double value = 2.220446049250313E-016;
+
+  return value;
+}
+
+double r8_max ( double x, double y )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8_MAX returns the maximum of two R8's.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    07 May 2006
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, double X, Y, the quantities to compare.
+
+    Output, double R8_MAX, the maximum of X and Y.
+*/
+{
+  double value;
+
+  if ( y < x )
+  {
+    value = x;
+  }
+  else
+  {
+    value = y;
+  }
+  return value;
+}
+
+double r8_abs ( double x )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8_ABS returns the absolute value of an R8.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    07 May 2006
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, double X, the quantity whose absolute value is desired.
+
+    Output, double R8_ABS, the absolute value of X.
+*/
+{
+  double value;
+
+  if ( 0.0 <= x )
+  {
+    value = + x;
+  }
+  else
+  {
+    value = - x;
+  }
+  return value;
+}
+
+double r8_sign ( double x )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8_SIGN returns the sign of an R8.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    08 May 2006
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, double X, the number whose sign is desired.
+
+    Output, double R8_SIGN, the sign of X.
+*/
+{
+  double value;
+
+  if ( x < 0.0 )
+  {
+    value = - 1.0;
+  }
+  else
+  {
+    value = + 1.0;
+  }
+  return value;
+}
+
+double r8mat_amax ( int m, int n, double a[] )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8MAT_AMAX returns the maximum absolute value entry of an R8MAT.
+
+  Discussion:
+
+    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
+    in column-major order.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    07 September 2012
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, int M, the number of rows in A.
+
+    Input, int N, the number of columns in A.
+
+    Input, double A[M*N], the M by N matrix.
+
+    Output, double R8MAT_AMAX, the maximum absolute value entry of A.
+*/
+{
+  int i;
+  int j;
+  double value;
+
+  value = r8_abs ( a[0+0*m] );
+
+  for ( j = 0; j < n; j++ )
+  {
+    for ( i = 0; i < m; i++ )
+    {
+      if ( value < r8_abs ( a[i+j*m] ) )
+      {
+        value = r8_abs ( a[i+j*m] );
+      }
+    }
+  }
+  return value;
+}
+
+double *r8mat_copy_new ( int m, int n, double a1[] )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    R8MAT_COPY_NEW copies one R8MAT to a "new" R8MAT.
+
+  Discussion:
+
+    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
+    in column-major order.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    26 July 2008
+
+  Author:
+
+    John Burkardt
+
+  Parameters:
+
+    Input, int M, N, the number of rows and columns.
+
+    Input, double A1[M*N], the matrix to be copied.
+
+    Output, double R8MAT_COPY_NEW[M*N], the copy of A1.
+*/
+{
+  double *a2;
+  int i;
+  int j;
+
+  a2 = ( double * ) malloc ( m * n * sizeof ( double ) );
+
+  for ( j = 0; j < n; j++ )
+  {
+    for ( i = 0; i < m; i++ )
+    {
+      a2[i+j*m] = a1[i+j*m];
+    }
+  }
+
+  return a2;
+}
+
+/******************************************************************************/
+
+void daxpy ( int n, double da, double dx[], int incx, double dy[], int incy )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DAXPY computes constant times a vector plus a vector.
+
+  Discussion:
+
+    This routine uses unrolled loops for increments equal to one.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    30 March 2007
+
+  Author:
+
+    C version by John Burkardt
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979.
+
+    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
+    Basic Linear Algebra Subprograms for Fortran Usage,
+    Algorithm 539, 
+    ACM Transactions on Mathematical Software, 
+    Volume 5, Number 3, September 1979, pages 308-323.
+
+  Parameters:
+
+    Input, int N, the number of elements in DX and DY.
+
+    Input, double DA, the multiplier of DX.
+
+    Input, double DX[*], the first vector.
+
+    Input, int INCX, the increment between successive entries of DX.
+
+    Input/output, double DY[*], the second vector.
+    On output, DY[*] has been replaced by DY[*] + DA * DX[*].
+
+    Input, int INCY, the increment between successive entries of DY.
+*/
+{
+  int i;
+  int ix;
+  int iy;
+  int m;
+
+  if ( n <= 0 )
+  {
+    return;
+  }
+
+  if ( da == 0.0 )
+  {
+    return;
+  }
+/*
+  Code for unequal increments or equal increments
+  not equal to 1.
+*/
+  if ( incx != 1 || incy != 1 )
+  {
+    if ( 0 <= incx )
+    {
+      ix = 0;
+    }
+    else
+    {
+      ix = ( - n + 1 ) * incx;
+    }
+
+    if ( 0 <= incy )
+    {
+      iy = 0;
+    }
+    else
+    {
+      iy = ( - n + 1 ) * incy;
+    }
+
+    for ( i = 0; i < n; i++ )
+    {
+      dy[iy] = dy[iy] + da * dx[ix];
+      ix = ix + incx;
+      iy = iy + incy;
+    }
+  }
+/*
+  Code for both increments equal to 1.
+*/
+  else
+  {
+    m = n % 4;
+
+    for ( i = 0; i < m; i++ )
+    {
+      dy[i] = dy[i] + da * dx[i];
+    }
+
+    for ( i = m; i < n; i = i + 4 )
+    {
+      dy[i  ] = dy[i  ] + da * dx[i  ];
+      dy[i+1] = dy[i+1] + da * dx[i+1];
+      dy[i+2] = dy[i+2] + da * dx[i+2];
+      dy[i+3] = dy[i+3] + da * dx[i+3];
+    }
+  }
+  return;
+}
+/******************************************************************************/
+
+double ddot ( int n, double dx[], int incx, double dy[], int incy )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DDOT forms the dot product of two vectors.
+
+  Discussion:
+
+    This routine uses unrolled loops for increments equal to one.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    30 March 2007
+
+  Author:
+
+    C version by John Burkardt
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979.
+
+    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
+    Basic Linear Algebra Subprograms for Fortran Usage,
+    Algorithm 539, 
+    ACM Transactions on Mathematical Software, 
+    Volume 5, Number 3, September 1979, pages 308-323.
+
+  Parameters:
+
+    Input, int N, the number of entries in the vectors.
+
+    Input, double DX[*], the first vector.
+
+    Input, int INCX, the increment between successive entries in DX.
+
+    Input, double DY[*], the second vector.
+
+    Input, int INCY, the increment between successive entries in DY.
+
+    Output, double DDOT, the sum of the product of the corresponding
+    entries of DX and DY.
+*/
+{
+  double dtemp;
+  int i;
+  int ix;
+  int iy;
+  int m;
+
+  dtemp = 0.0;
+
+  if ( n <= 0 )
+  {
+    return dtemp;
+  }
+/*
+  Code for unequal increments or equal increments
+  not equal to 1.
+*/
+  if ( incx != 1 || incy != 1 )
+  {
+    if ( 0 <= incx )
+    {
+      ix = 0;
+    }
+    else
+    {
+      ix = ( - n + 1 ) * incx;
+    }
+
+    if ( 0 <= incy )
+    {
+      iy = 0;
+    }
+    else
+    {
+      iy = ( - n + 1 ) * incy;
+    }
+
+    for ( i = 0; i < n; i++ )
+    {
+      dtemp = dtemp + dx[ix] * dy[iy];
+      ix = ix + incx;
+      iy = iy + incy;
+    }
+  }
+/*
+  Code for both increments equal to 1.
+*/
+  else
+  {
+    m = n % 5;
+
+    for ( i = 0; i < m; i++ )
+    {
+      dtemp = dtemp + dx[i] * dy[i];
+    }
+
+    for ( i = m; i < n; i = i + 5 )
+    {
+      dtemp = dtemp + dx[i  ] * dy[i  ] 
+                    + dx[i+1] * dy[i+1] 
+                    + dx[i+2] * dy[i+2] 
+                    + dx[i+3] * dy[i+3] 
+                    + dx[i+4] * dy[i+4];
+    }
+  }
+  return dtemp;
+}
+/******************************************************************************/
+
+double dnrm2 ( int n, double x[], int incx )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DNRM2 returns the euclidean norm of a vector.
+
+  Discussion:
+
+     DNRM2 ( X ) = sqrt ( X' * X )
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    30 March 2007
+
+  Author:
+
+    C version by John Burkardt
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979.
+
+    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
+    Basic Linear Algebra Subprograms for Fortran Usage,
+    Algorithm 539,
+    ACM Transactions on Mathematical Software,
+    Volume 5, Number 3, September 1979, pages 308-323.
+
+  Parameters:
+
+    Input, int N, the number of entries in the vector.
+
+    Input, double X[*], the vector whose norm is to be computed.
+
+    Input, int INCX, the increment between successive entries of X.
+
+    Output, double DNRM2, the Euclidean norm of X.
+*/
+{
+  double absxi;
+  int i;
+  int ix;
+  double norm;
+  double scale;
+  double ssq;
+  double value;
+
+  if ( n < 1 || incx < 1 )
+  {
+    norm = 0.0;
+  }
+  else if ( n == 1 )
+  {
+    norm = r8_abs ( x[0] );
+  }
+  else
+  {
+    scale = 0.0;
+    ssq = 1.0;
+    ix = 0;
+
+    for ( i = 0; i < n; i++ )
+    {
+      if ( x[ix] != 0.0 )
+      {
+        absxi = r8_abs ( x[ix] );
+        if ( scale < absxi )
+        {
+          ssq = 1.0 + ssq * ( scale / absxi ) * ( scale / absxi );
+          scale = absxi;
+        }
+        else
+        {
+          ssq = ssq + ( absxi / scale ) * ( absxi / scale );
+        }
+      }
+      ix = ix + incx;
+    }
+
+    norm  = scale * sqrt ( ssq );
+  }
+
+  return norm;
+}
+/******************************************************************************/
+
+void dqrank ( double a[], int lda, int m, int n, double tol, int *kr, 
+  int jpvt[], double qraux[] )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DQRANK computes the QR factorization of a rectangular matrix.
+
+  Discussion:
+
+    This routine is used in conjunction with DQRLSS to solve
+    overdetermined, underdetermined and singular linear systems
+    in a least squares sense.
+
+    DQRANK uses the LINPACK subroutine DQRDC to compute the QR
+    factorization, with column pivoting, of an M by N matrix A.
+    The numerical rank is determined using the tolerance TOL.
+
+    Note that on output, ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate
+    of the condition number of the matrix of independent columns,
+    and of R.  This estimate will be <= 1/TOL.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    21 April 2012
+
+  Author:
+
+    C version by John Burkardt.
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979,
+    ISBN13: 978-0-898711-72-1,
+    LC: QA214.L56.
+
+  Parameters:
+
+    Input/output, double A[LDA*N].  On input, the matrix whose
+    decomposition is to be computed.  On output, the information from DQRDC.
+    The triangular matrix R of the QR factorization is contained in the
+    upper triangle and information needed to recover the orthogonal
+    matrix Q is stored below the diagonal in A and in the vector QRAUX.
+
+    Input, int LDA, the leading dimension of A, which must
+    be at least M.
+
+    Input, int M, the number of rows of A.
+
+    Input, int N, the number of columns of A.
+
+    Input, double TOL, a relative tolerance used to determine the
+    numerical rank.  The problem should be scaled so that all the elements
+    of A have roughly the same absolute accuracy, EPS.  Then a reasonable
+    value for TOL is roughly EPS divided by the magnitude of the largest
+    element.
+
+    Output, int *KR, the numerical rank.
+
+    Output, int JPVT[N], the pivot information from DQRDC.
+    Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly
+    independent to within the tolerance TOL and the remaining columns
+    are linearly dependent.
+
+    Output, double QRAUX[N], will contain extra information defining
+    the QR factorization.
+*/
+{
+  int i;
+  int j;
+  int job;
+  int k;
+  double *work;
+
+  for ( i = 0; i < n; i++ )
+  {
+    jpvt[i] = 0;
+  }
+
+  work = ( double * ) malloc ( n * sizeof ( double ) );
+  job = 1;
+
+  dqrdc ( a, lda, m, n, qraux, jpvt, work, job );
+
+  *kr = 0;
+  k = i4_min ( m, n );
+
+  for ( j = 0; j < k; j++ )
+  {
+    if ( r8_abs ( a[j+j*lda] ) <= tol * r8_abs ( a[0+0*lda] ) )
+    {
+      return;
+    }
+    *kr = j + 1;
+  }
+
+  free ( work );
+
+  return;
+}
+/******************************************************************************/
+
+void dqrdc ( double a[], int lda, int n, int p, double qraux[], int jpvt[], 
+  double work[], int job )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DQRDC computes the QR factorization of a real rectangular matrix.
+
+  Discussion:
+
+    DQRDC uses Householder transformations.
+
+    Column pivoting based on the 2-norms of the reduced columns may be
+    performed at the user's option.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    07 June 2005
+
+  Author:
+
+    C version by John Burkardt.
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, (Society for Industrial and Applied Mathematics),
+    3600 University City Science Center,
+    Philadelphia, PA, 19104-2688.
+    ISBN 0-89871-172-X
+
+  Parameters:
+
+    Input/output, double A(LDA,P).  On input, the N by P matrix
+    whose decomposition is to be computed.  On output, A contains in
+    its upper triangle the upper triangular matrix R of the QR
+    factorization.  Below its diagonal A contains information from
+    which the orthogonal part of the decomposition can be recovered.
+    Note that if pivoting has been requested, the decomposition is not that
+    of the original matrix A but that of A with its columns permuted
+    as described by JPVT.
+
+    Input, int LDA, the leading dimension of the array A.  LDA must
+    be at least N.
+
+    Input, int N, the number of rows of the matrix A.
+
+    Input, int P, the number of columns of the matrix A.
+
+    Output, double QRAUX[P], contains further information required
+    to recover the orthogonal part of the decomposition.
+
+    Input/output, integer JPVT[P].  On input, JPVT contains integers that
+    control the selection of the pivot columns.  The K-th column A(*,K) of A
+    is placed in one of three classes according to the value of JPVT(K).
+      > 0, then A(K) is an initial column.
+      = 0, then A(K) is a free column.
+      < 0, then A(K) is a final column.
+    Before the decomposition is computed, initial columns are moved to
+    the beginning of the array A and final columns to the end.  Both
+    initial and final columns are frozen in place during the computation
+    and only free columns are moved.  At the K-th stage of the
+    reduction, if A(*,K) is occupied by a free column it is interchanged
+    with the free column of largest reduced norm.  JPVT is not referenced
+    if JOB == 0.  On output, JPVT(K) contains the index of the column of the
+    original matrix that has been interchanged into the K-th column, if
+    pivoting was requested.
+
+    Workspace, double WORK[P].  WORK is not referenced if JOB == 0.
+
+    Input, int JOB, initiates column pivoting.
+    0, no pivoting is done.
+    nonzero, pivoting is done.
+*/
+{
+  int j;
+  int jp;
+  int l;
+  int lup;
+  int maxj;
+  double maxnrm;
+  double nrmxl;
+  int pl;
+  int pu;
+  int swapj;
+  double t;
+  double tt;
+
+  pl = 1;
+  pu = 0;
+/*
+  If pivoting is requested, rearrange the columns.
+*/
+  if ( job != 0 )
+  {
+    for ( j = 1; j <= p; j++ )
+    {
+      swapj = ( 0 < jpvt[j-1] );
+
+      if ( jpvt[j-1] < 0 )
+      {
+        jpvt[j-1] = -j;
+      }
+      else
+      {
+        jpvt[j-1] = j;
+      }
+
+      if ( swapj )
+      {
+        if ( j != pl )
+        {
+          dswap ( n, a+0+(pl-1)*lda, 1, a+0+(j-1), 1 );
+        }
+        jpvt[j-1] = jpvt[pl-1];
+        jpvt[pl-1] = j;
+        pl = pl + 1;
+      }
+    }
+    pu = p;
+
+    for ( j = p; 1 <= j; j-- )
+    {
+      if ( jpvt[j-1] < 0 )
+      {
+        jpvt[j-1] = -jpvt[j-1];
+
+        if ( j != pu )
+        {
+          dswap ( n, a+0+(pu-1)*lda, 1, a+0+(j-1)*lda, 1 );
+          jp = jpvt[pu-1];
+          jpvt[pu-1] = jpvt[j-1];
+          jpvt[j-1] = jp;
+        }
+        pu = pu - 1;
+      }
+    }
+  }
+/*
+  Compute the norms of the free columns.
+*/
+  for ( j = pl; j <= pu; j++ )
+  {
+    qraux[j-1] = dnrm2 ( n, a+0+(j-1)*lda, 1 );
+  }
+
+  for ( j = pl; j <= pu; j++ )
+  {
+    work[j-1] = qraux[j-1];
+  }
+/*
+  Perform the Householder reduction of A.
+*/
+  lup = i4_min ( n, p );
+
+  for ( l = 1; l <= lup; l++ )
+  {
+/*
+  Bring the column of largest norm into the pivot position.
+*/
+    if ( pl <= l && l < pu )
+    {
+      maxnrm = 0.0;
+      maxj = l;
+      for ( j = l; j <= pu; j++ )
+      {
+        if ( maxnrm < qraux[j-1] )
+        {
+          maxnrm = qraux[j-1];
+          maxj = j;
+        }
+      }
+
+      if ( maxj != l )
+      {
+        dswap ( n, a+0+(l-1)*lda, 1, a+0+(maxj-1)*lda, 1 );
+        qraux[maxj-1] = qraux[l-1];
+        work[maxj-1] = work[l-1];
+        jp = jpvt[maxj-1];
+        jpvt[maxj-1] = jpvt[l-1];
+        jpvt[l-1] = jp;
+      }
+    }
+/*
+  Compute the Householder transformation for column L.
+*/
+    qraux[l-1] = 0.0;
+
+    if ( l != n )
+    {
+      nrmxl = dnrm2 ( n-l+1, a+l-1+(l-1)*lda, 1 );
+
+      if ( nrmxl != 0.0 )
+      {
+        if ( a[l-1+(l-1)*lda] != 0.0 )
+        {
+          nrmxl = nrmxl * r8_sign ( a[l-1+(l-1)*lda] );
+        }
+
+        dscal ( n-l+1, 1.0 / nrmxl, a+l-1+(l-1)*lda, 1 );
+        a[l-1+(l-1)*lda] = 1.0 + a[l-1+(l-1)*lda];
+/*
+  Apply the transformation to the remaining columns, updating the norms.
+*/
+        for ( j = l + 1; j <= p; j++ )
+        {
+          t = -ddot ( n-l+1, a+l-1+(l-1)*lda, 1, a+l-1+(j-1)*lda, 1 ) 
+            / a[l-1+(l-1)*lda];
+          daxpy ( n-l+1, t, a+l-1+(l-1)*lda, 1, a+l-1+(j-1)*lda, 1 );
+
+          if ( pl <= j && j <= pu )
+          {
+            if ( qraux[j-1] != 0.0 )
+            {
+              tt = 1.0 - pow ( r8_abs ( a[l-1+(j-1)*lda] ) / qraux[j-1], 2 );
+              tt = r8_max ( tt, 0.0 );
+              t = tt;
+              tt = 1.0 + 0.05 * tt * pow ( qraux[j-1] / work[j-1], 2 );
+
+              if ( tt != 1.0 )
+              {
+                qraux[j-1] = qraux[j-1] * sqrt ( t );
+              }
+              else
+              {
+                qraux[j-1] = dnrm2 ( n-l, a+l+(j-1)*lda, 1 );
+                work[j-1] = qraux[j-1];
+              }
+            }
+          }
+        }
+/*
+  Save the transformation.
+*/
+        qraux[l-1] = a[l-1+(l-1)*lda];
+        a[l-1+(l-1)*lda] = -nrmxl;
+      }
+    }
+  }
+  return;
+}
+/******************************************************************************/
+
+int dqrls ( double a[], int lda, int m, int n, double tol, int *kr, double b[], 
+  double x[], double rsd[], int jpvt[], double qraux[], int itask )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DQRLS factors and solves a linear system in the least squares sense.
+
+  Discussion:
+
+    The linear system may be overdetermined, underdetermined or singular.
+    The solution is obtained using a QR factorization of the
+    coefficient matrix.
+
+    DQRLS can be efficiently used to solve several least squares
+    problems with the same matrix A.  The first system is solved
+    with ITASK = 1.  The subsequent systems are solved with
+    ITASK = 2, to avoid the recomputation of the matrix factors.
+    The parameters KR, JPVT, and QRAUX must not be modified
+    between calls to DQRLS.
+
+    DQRLS is used to solve in a least squares sense
+    overdetermined, underdetermined and singular linear systems.
+    The system is A*X approximates B where A is M by N.
+    B is a given M-vector, and X is the N-vector to be computed.
+    A solution X is found which minimimzes the sum of squares (2-norm)
+    of the residual,  A*X - B.
+
+    The numerical rank of A is determined using the tolerance TOL.
+
+    DQRLS uses the LINPACK subroutine DQRDC to compute the QR
+    factorization, with column pivoting, of an M by N matrix A.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    10 September 2012
+
+  Author:
+
+    C version by John Burkardt.
+
+  Reference:
+
+    David Kahaner, Cleve Moler, Steven Nash,
+    Numerical Methods and Software,
+    Prentice Hall, 1989,
+    ISBN: 0-13-627258-4,
+    LC: TA345.K34.
+
+  Parameters:
+
+    Input/output, double A[LDA*N], an M by N matrix.
+    On input, the matrix whose decomposition is to be computed.
+    In a least squares data fitting problem, A(I,J) is the
+    value of the J-th basis (model) function at the I-th data point.
+    On output, A contains the output from DQRDC.  The triangular matrix R
+    of the QR factorization is contained in the upper triangle and
+    information needed to recover the orthogonal matrix Q is stored
+    below the diagonal in A and in the vector QRAUX.
+
+    Input, int LDA, the leading dimension of A.
+
+    Input, int M, the number of rows of A.
+
+    Input, int N, the number of columns of A.
+
+    Input, double TOL, a relative tolerance used to determine the
+    numerical rank.  The problem should be scaled so that all the elements
+    of A have roughly the same absolute accuracy EPS.  Then a reasonable
+    value for TOL is roughly EPS divided by the magnitude of the largest
+    element.
+
+    Output, int *KR, the numerical rank.
+
+    Input, double B[M], the right hand side of the linear system.
+
+    Output, double X[N], a least squares solution to the linear
+    system.
+
+    Output, double RSD[M], the residual, B - A*X.  RSD may
+    overwrite B.
+
+    Workspace, int JPVT[N], required if ITASK = 1.
+    Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly
+    independent to within the tolerance TOL and the remaining columns
+    are linearly dependent.  ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate
+    of the condition number of the matrix of independent columns,
+    and of R.  This estimate will be <= 1/TOL.
+
+    Workspace, double QRAUX[N], required if ITASK = 1.
+
+    Input, int ITASK.
+    1, DQRLS factors the matrix A and solves the least squares problem.
+    2, DQRLS assumes that the matrix A was factored with an earlier
+       call to DQRLS, and only solves the least squares problem.
+
+    Output, int DQRLS, error code.
+    0:  no error
+    -1: LDA < M   (fatal error)
+    -2: N < 1     (fatal error)
+    -3: ITASK < 1 (fatal error)
+*/
+{
+  int ind;
+
+  if ( lda < m )
+  {
+    /*fprintf ( stderr, "\n" );
+    fprintf ( stderr, "DQRLS - Fatal error!\n" );
+    fprintf ( stderr, "  LDA < M.\n" );*/
+    ind = -1;
+    return ind;
+  }
+
+  if ( n <= 0 )
+  {
+    /*fprintf ( stderr, "\n" );
+    fprintf ( stderr, "DQRLS - Fatal error!\n" );
+    fprintf ( stderr, "  N <= 0.\n" );*/
+    ind = -2;
+    return ind;
+  }
+
+  if ( itask < 1 )
+  {
+    /*fprintf ( stderr, "\n" );
+    fprintf ( stderr, "DQRLS - Fatal error!\n" );
+    fprintf ( stderr, "  ITASK < 1.\n" );*/
+    ind = -3;
+    return ind;
+  }
+
+  ind = 0;
+/*
+  Factor the matrix.
+*/
+  if ( itask == 1 )
+  {
+    dqrank ( a, lda, m, n, tol, kr, jpvt, qraux );
+  }
+/*
+  Solve the least-squares problem.
+*/
+  dqrlss ( a, lda, m, n, *kr, b, x, rsd, jpvt, qraux );
+
+  return ind;
+}
+/******************************************************************************/
+
+void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[], 
+  double rsd[], int jpvt[], double qraux[] )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DQRLSS solves a linear system in a least squares sense.
+
+  Discussion:
+
+    DQRLSS must be preceeded by a call to DQRANK.
+
+    The system is to be solved is
+      A * X = B
+    where
+      A is an M by N matrix with rank KR, as determined by DQRANK,
+      B is a given M-vector,
+      X is the N-vector to be computed.
+
+    A solution X, with at most KR nonzero components, is found which
+    minimizes the 2-norm of the residual (A*X-B).
+
+    Once the matrix A has been formed, DQRANK should be
+    called once to decompose it.  Then, for each right hand
+    side B, DQRLSS should be called once to obtain the
+    solution and residual.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    10 September 2012
+
+  Author:
+
+    C version by John Burkardt
+
+  Parameters:
+
+    Input, double A[LDA*N], the QR factorization information
+    from DQRANK.  The triangular matrix R of the QR factorization is
+    contained in the upper triangle and information needed to recover
+    the orthogonal matrix Q is stored below the diagonal in A and in
+    the vector QRAUX.
+
+    Input, int LDA, the leading dimension of A, which must
+    be at least M.
+
+    Input, int M, the number of rows of A.
+
+    Input, int N, the number of columns of A.
+
+    Input, int KR, the rank of the matrix, as estimated by DQRANK.
+
+    Input, double B[M], the right hand side of the linear system.
+
+    Output, double X[N], a least squares solution to the
+    linear system.
+
+    Output, double RSD[M], the residual, B - A*X.  RSD may
+    overwite B.
+
+    Input, int JPVT[N], the pivot information from DQRANK.
+    Columns JPVT[0], ..., JPVT[KR-1] of the original matrix are linearly
+    independent to within the tolerance TOL and the remaining columns
+    are linearly dependent.
+
+    Input, double QRAUX[N], auxiliary information from DQRANK
+    defining the QR factorization.
+*/
+{
+  int i;
+  int info;
+  int j;
+  int job;
+  int k;
+  double t;
+
+  if ( kr != 0 )
+  {
+    job = 110;
+    info = dqrsl ( a, lda, m, kr, qraux, b, rsd, rsd, x, rsd, rsd, job );
+  }
+
+  for ( i = 0; i < n; i++ )
+  {
+    jpvt[i] = - jpvt[i];
+  }
+
+  for ( i = kr; i < n; i++ )
+  {
+    x[i] = 0.0;
+  }
+
+  for ( j = 1; j <= n; j++ )
+  {
+    if ( jpvt[j-1] <= 0 )
+    {
+      k = - jpvt[j-1];
+      jpvt[j-1] = k;
+
+      while ( k != j )
+      {
+        t = x[j-1];
+        x[j-1] = x[k-1];
+        x[k-1] = t;
+        jpvt[k-1] = -jpvt[k-1];
+        k = jpvt[k-1];
+      }
+    }
+  }
+  return;
+}
+/******************************************************************************/
+
+int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[], 
+  double qy[], double qty[], double b[], double rsd[], double ab[], int job )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DQRSL computes transformations, projections, and least squares solutions.
+
+  Discussion:
+
+    DQRSL requires the output of DQRDC.
+
+    For K <= min(N,P), let AK be the matrix
+
+      AK = ( A(JPVT[0]), A(JPVT(2)), ..., A(JPVT(K)) )
+
+    formed from columns JPVT[0], ..., JPVT(K) of the original
+    N by P matrix A that was input to DQRDC.  If no pivoting was
+    done, AK consists of the first K columns of A in their
+    original order.  DQRDC produces a factored orthogonal matrix Q
+    and an upper triangular matrix R such that
+
+      AK = Q * (R)
+               (0)
+
+    This information is contained in coded form in the arrays
+    A and QRAUX.
+
+    The parameters QY, QTY, B, RSD, and AB are not referenced
+    if their computation is not requested and in this case
+    can be replaced by dummy variables in the calling program.
+    To save storage, the user may in some cases use the same
+    array for different parameters in the calling sequence.  A
+    frequently occuring example is when one wishes to compute
+    any of B, RSD, or AB and does not need Y or QTY.  In this
+    case one may identify Y, QTY, and one of B, RSD, or AB, while
+    providing separate arrays for anything else that is to be
+    computed.
+
+    Thus the calling sequence
+
+      dqrsl ( a, lda, n, k, qraux, y, dum, y, b, y, dum, 110, info )
+
+    will result in the computation of B and RSD, with RSD
+    overwriting Y.  More generally, each item in the following
+    list contains groups of permissible identifications for
+    a single calling sequence.
+
+      1. (Y,QTY,B) (RSD) (AB) (QY)
+
+      2. (Y,QTY,RSD) (B) (AB) (QY)
+
+      3. (Y,QTY,AB) (B) (RSD) (QY)
+
+      4. (Y,QY) (QTY,B) (RSD) (AB)
+
+      5. (Y,QY) (QTY,RSD) (B) (AB)
+
+      6. (Y,QY) (QTY,AB) (B) (RSD)
+
+    In any group the value returned in the array allocated to
+    the group corresponds to the last member of the group.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    07 June 2005
+
+  Author:
+
+    C version by John Burkardt.
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, (Society for Industrial and Applied Mathematics),
+    3600 University City Science Center,
+    Philadelphia, PA, 19104-2688.
+    ISBN 0-89871-172-X
+
+  Parameters:
+
+    Input, double A[LDA*P], contains the output of DQRDC.
+
+    Input, int LDA, the leading dimension of the array A.
+
+    Input, int N, the number of rows of the matrix AK.  It must
+    have the same value as N in DQRDC.
+
+    Input, int K, the number of columns of the matrix AK.  K
+    must not be greater than min(N,P), where P is the same as in the
+    calling sequence to DQRDC.
+
+    Input, double QRAUX[P], the auxiliary output from DQRDC.
+
+    Input, double Y[N], a vector to be manipulated by DQRSL.
+
+    Output, double QY[N], contains Q * Y, if requested.
+
+    Output, double QTY[N], contains Q' * Y, if requested.
+
+    Output, double B[K], the solution of the least squares problem
+      minimize norm2 ( Y - AK * B),
+    if its computation has been requested.  Note that if pivoting was
+    requested in DQRDC, the J-th component of B will be associated with
+    column JPVT(J) of the original matrix A that was input into DQRDC.
+
+    Output, double RSD[N], the least squares residual Y - AK * B,
+    if its computation has been requested.  RSD is also the orthogonal
+    projection of Y onto the orthogonal complement of the column space
+    of AK.
+
+    Output, double AB[N], the least squares approximation Ak * B,
+    if its computation has been requested.  AB is also the orthogonal
+    projection of Y onto the column space of A.
+
+    Input, integer JOB, specifies what is to be computed.  JOB has
+    the decimal expansion ABCDE, with the following meaning:
+
+      if A != 0, compute QY.
+      if B != 0, compute QTY.
+      if C != 0, compute QTY and B.
+      if D != 0, compute QTY and RSD.
+      if E != 0, compute QTY and AB.
+
+    Note that a request to compute B, RSD, or AB automatically triggers
+    the computation of QTY, for which an array must be provided in the
+    calling sequence.
+
+    Output, int DQRSL, is zero unless the computation of B has
+    been requested and R is exactly singular.  In this case, INFO is the
+    index of the first zero diagonal element of R, and B is left unaltered.
+*/
+{
+  int cab;
+  int cb;
+  int cqty;
+  int cqy;
+  int cr;
+  int i;
+  int info;
+  int j;
+  int jj;
+  int ju;
+  double t;
+  double temp;
+/*
+  Set INFO flag.
+*/
+  info = 0;
+/*
+  Determine what is to be computed.
+*/
+  cqy =  (   job / 10000          != 0 );
+  cqty = ( ( job %  10000 )       != 0 );
+  cb =   ( ( job %   1000 ) / 100 != 0 );
+  cr =   ( ( job %    100 ) /  10 != 0 );
+  cab =  ( ( job %     10 )       != 0 );
+
+  ju = i4_min ( k, n-1 );
+/*
+  Special action when N = 1.
+*/
+  if ( ju == 0 )
+  {
+    if ( cqy )
+    {
+      qy[0] = y[0];
+    }
+
+    if ( cqty )
+    {
+      qty[0] = y[0];
+    }
+
+    if ( cab )
+    {
+      ab[0] = y[0];
+    }
+
+    if ( cb )
+    {
+      if ( a[0+0*lda] == 0.0 )
+      {
+        info = 1;
+      }
+      else
+      {
+        b[0] = y[0] / a[0+0*lda];
+      }
+    }
+
+    if ( cr )
+    {
+      rsd[0] = 0.0;
+    }
+    return info;
+  }
+/*
+  Set up to compute QY or QTY.
+*/
+  if ( cqy )
+  {
+    for ( i = 1; i <= n; i++ )
+    {
+      qy[i-1] = y[i-1];
+    }
+  }
+
+  if ( cqty )
+  {
+    for ( i = 1; i <= n; i++ )
+    {
+      qty[i-1] = y[i-1];
+    }
+  }
+/*
+  Compute QY.
+*/
+  if ( cqy )
+  {
+    for ( jj = 1; jj <= ju; jj++ )
+    {
+      j = ju - jj + 1;
+
+      if ( qraux[j-1] != 0.0 )
+      {
+        temp = a[j-1+(j-1)*lda];
+        a[j-1+(j-1)*lda] = qraux[j-1];
+        t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, qy+j-1, 1 ) / a[j-1+(j-1)*lda];
+        daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, qy+j-1, 1 );
+        a[j-1+(j-1)*lda] = temp;
+      }
+    }
+  }
+/*
+  Compute Q'*Y.
+*/
+  if ( cqty )
+  {
+    for ( j = 1; j <= ju; j++ )
+    {
+      if ( qraux[j-1] != 0.0 )
+      {
+        temp = a[j-1+(j-1)*lda];
+        a[j-1+(j-1)*lda] = qraux[j-1];
+        t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, qty+j-1, 1 ) / a[j-1+(j-1)*lda];
+        daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, qty+j-1, 1 );
+        a[j-1+(j-1)*lda] = temp;
+      }
+    }
+  }
+/*
+  Set up to compute B, RSD, or AB.
+*/
+  if ( cb )
+  {
+    for ( i = 1; i <= k; i++ )
+    {
+      b[i-1] = qty[i-1];
+    }
+  }
+
+  if ( cab )
+  {
+    for ( i = 1; i <= k; i++ )
+    {
+      ab[i-1] = qty[i-1];
+    }
+  }
+
+  if ( cr && k < n )
+  {
+    for ( i = k+1; i <= n; i++ )
+    {
+      rsd[i-1] = qty[i-1];
+    }
+  }
+
+  if ( cab && k+1 <= n )
+  {
+    for ( i = k+1; i <= n; i++ )
+    {
+      ab[i-1] = 0.0;
+    }
+  }
+
+  if ( cr )
+  {
+    for ( i = 1; i <= k; i++ )
+    {
+      rsd[i-1] = 0.0;
+    }
+  }
+/*
+  Compute B.
+*/
+  if ( cb )
+  {
+    for ( jj = 1; jj <= k; jj++ )
+    {
+      j = k - jj + 1;
+
+      if ( a[j-1+(j-1)*lda] == 0.0 )
+      {
+        info = j;
+        break;
+      }
+
+      b[j-1] = b[j-1] / a[j-1+(j-1)*lda];
+
+      if ( j != 1 )
+      {
+        t = -b[j-1];
+        daxpy ( j-1, t, a+0+(j-1)*lda, 1, b, 1 );
+      }
+    }
+  }
+/*
+  Compute RSD or AB as required.
+*/
+  if ( cr || cab )
+  {
+    for ( jj = 1; jj <= ju; jj++ )
+    {
+      j = ju - jj + 1;
+
+      if ( qraux[j-1] != 0.0 )
+      {
+        temp = a[j-1+(j-1)*lda];
+        a[j-1+(j-1)*lda] = qraux[j-1];
+
+        if ( cr )
+        {
+          t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, rsd+j-1, 1 ) 
+            / a[j-1+(j-1)*lda];
+          daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, rsd+j-1, 1 );
+        }
+
+        if ( cab )
+        {
+          t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, ab+j-1, 1 ) 
+            / a[j-1+(j-1)*lda];
+          daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, ab+j-1, 1 );
+        }
+        a[j-1+(j-1)*lda] = temp;
+      }
+    }
+  }
+
+  return info;
+}
+/******************************************************************************/
+
+/******************************************************************************/
+
+void dscal ( int n, double sa, double x[], int incx )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DSCAL scales a vector by a constant.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    30 March 2007
+
+  Author:
+
+    C version by John Burkardt
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979.
+
+    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
+    Basic Linear Algebra Subprograms for Fortran Usage,
+    Algorithm 539,
+    ACM Transactions on Mathematical Software,
+    Volume 5, Number 3, September 1979, pages 308-323.
+
+  Parameters:
+
+    Input, int N, the number of entries in the vector.
+
+    Input, double SA, the multiplier.
+
+    Input/output, double X[*], the vector to be scaled.
+
+    Input, int INCX, the increment between successive entries of X.
+*/
+{
+  int i;
+  int ix;
+  int m;
+
+  if ( n <= 0 )
+  {
+  }
+  else if ( incx == 1 )
+  {
+    m = n % 5;
+
+    for ( i = 0; i < m; i++ )
+    {
+      x[i] = sa * x[i];
+    }
+
+    for ( i = m; i < n; i = i + 5 )
+    {
+      x[i]   = sa * x[i];
+      x[i+1] = sa * x[i+1];
+      x[i+2] = sa * x[i+2];
+      x[i+3] = sa * x[i+3];
+      x[i+4] = sa * x[i+4];
+    }
+  }
+  else
+  {
+    if ( 0 <= incx )
+    {
+      ix = 0;
+    }
+    else
+    {
+      ix = ( - n + 1 ) * incx;
+    }
+
+    for ( i = 0; i < n; i++ )
+    {
+      x[ix] = sa * x[ix];
+      ix = ix + incx;
+    }
+  }
+  return;
+}
+/******************************************************************************/
+
+
+void dswap ( int n, double x[], int incx, double y[], int incy )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    DSWAP interchanges two vectors.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license. 
+
+  Modified:
+
+    30 March 2007
+
+  Author:
+
+    C version by John Burkardt
+
+  Reference:
+
+    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,
+    LINPACK User's Guide,
+    SIAM, 1979.
+
+    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,
+    Basic Linear Algebra Subprograms for Fortran Usage,
+    Algorithm 539, 
+    ACM Transactions on Mathematical Software, 
+    Volume 5, Number 3, September 1979, pages 308-323.
+
+  Parameters:
+
+    Input, int N, the number of entries in the vectors.
+
+    Input/output, double X[*], one of the vectors to swap.
+
+    Input, int INCX, the increment between successive entries of X.
+
+    Input/output, double Y[*], one of the vectors to swap.
+
+    Input, int INCY, the increment between successive elements of Y.
+*/
+{
+  int i;
+  int ix;
+  int iy;
+  int m;
+  double temp;
+
+  if ( n <= 0 )
+  {
+  }
+  else if ( incx == 1 && incy == 1 )
+  {
+    m = n % 3;
+
+    for ( i = 0; i < m; i++ )
+    {
+      temp = x[i];
+      x[i] = y[i];
+      y[i] = temp;
+    }
+
+    for ( i = m; i < n; i = i + 3 )
+    {
+      temp = x[i];
+      x[i] = y[i];
+      y[i] = temp;
+
+      temp = x[i+1];
+      x[i+1] = y[i+1];
+      y[i+1] = temp;
+
+      temp = x[i+2];
+      x[i+2] = y[i+2];
+      y[i+2] = temp;
+    }
+  }
+  else
+  {
+    if ( 0 <= incx )
+    {
+      ix = 0;
+    }
+    else
+    {
+      ix = ( - n + 1 ) * incx;
+    }
+
+    if ( 0 <= incy )
+    {
+      iy = 0;
+    }
+    else
+    {
+      iy = ( - n + 1 ) * incy;
+    }
+
+    for ( i = 0; i < n; i++ )
+    {
+      temp = x[ix];
+      x[ix] = y[iy];
+      y[iy] = temp;
+      ix = ix + incx;
+      iy = iy + incy;
+    }
+
+  }
+
+  return;
+}
+/******************************************************************************/
+
+/******************************************************************************/
+
+double *qr_solve ( int m, int n, double a[], double b[] )
+
+/******************************************************************************/
+/*
+  Purpose:
+
+    QR_SOLVE solves a linear system in the least squares sense.
+
+  Discussion:
+
+    If the matrix A has full column rank, then the solution X should be the
+    unique vector that minimizes the Euclidean norm of the residual.
+
+    If the matrix A does not have full column rank, then the solution is
+    not unique; the vector X will minimize the residual norm, but so will
+    various other vectors.
+
+  Licensing:
+
+    This code is distributed under the GNU LGPL license.
+
+  Modified:
+
+    11 September 2012
+
+  Author:
+
+    John Burkardt
+
+  Reference:
+
+    David Kahaner, Cleve Moler, Steven Nash,
+    Numerical Methods and Software,
+    Prentice Hall, 1989,
+    ISBN: 0-13-627258-4,
+    LC: TA345.K34.
+
+  Parameters:
+
+    Input, int M, the number of rows of A.
+
+    Input, int N, the number of columns of A.
+
+    Input, double A[M*N], the matrix.
+
+    Input, double B[M], the right hand side.
+
+    Output, double QR_SOLVE[N], the least squares solution.
+*/
+{
+  double *a_qr;
+  int ind;
+  int itask;
+  int *jpvt;
+  int kr;
+  int lda;
+  double *qraux;
+  double *r;
+  double tol;
+  double *x;
+
+  a_qr = r8mat_copy_new ( m, n, a );
+  lda = m;
+  tol = r8_epsilon ( ) / r8mat_amax ( m, n, a_qr );
+  x = ( double * ) malloc ( n * sizeof ( double ) );
+  jpvt = ( int * ) malloc ( n * sizeof ( int ) );
+  qraux = ( double * ) malloc ( n * sizeof ( double ) );
+  r = ( double * ) malloc ( m * sizeof ( double ) );
+  itask = 1;
+
+  ind = dqrls ( a_qr, lda, m, n, tol, &kr, b, x, r, jpvt, qraux, itask );
+
+  free ( a_qr );
+  free ( jpvt );
+  free ( qraux ); 
+  free ( r );
+
+  return x;
+}
+/******************************************************************************/
+
+#endif
diff --git a/Marlin/qr_solve.h b/Marlin/qr_solve.h
new file mode 100644
index 0000000..b756d1e
--- /dev/null
+++ b/Marlin/qr_solve.h
@@ -0,0 +1,22 @@
+#include "Configuration.h"
+
+#ifdef ACCURATE_BED_LEVELING
+
+void daxpy ( int n, double da, double dx[], int incx, double dy[], int incy );
+double ddot ( int n, double dx[], int incx, double dy[], int incy );
+double dnrm2 ( int n, double x[], int incx );
+void dqrank ( double a[], int lda, int m, int n, double tol, int *kr, 
+  int jpvt[], double qraux[] );
+void dqrdc ( double a[], int lda, int n, int p, double qraux[], int jpvt[], 
+  double work[], int job );
+int dqrls ( double a[], int lda, int m, int n, double tol, int *kr, double b[], 
+  double x[], double rsd[], int jpvt[], double qraux[], int itask );
+void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[], 
+  double rsd[], int jpvt[], double qraux[] );
+int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[], 
+  double qy[], double qty[], double b[], double rsd[], double ab[], int job );
+void dscal ( int n, double sa, double x[], int incx );
+void dswap ( int n, double x[], int incx, double y[], int incy );
+double *qr_solve ( int m, int n, double a[], double b[] );
+
+#endif
diff --git a/Marlin/vector_3.cpp b/Marlin/vector_3.cpp
index 8c8a0e1..c143e01 100644
--- a/Marlin/vector_3.cpp
+++ b/Marlin/vector_3.cpp
@@ -127,57 +127,32 @@ void matrix_3x3::set_to_identity()
 	matrix[6] = 0; matrix[7] = 0; matrix[8] = 1;
 }
 
-matrix_3x3 matrix_3x3::create_look_at(vector_3 target, vector_3 up)
-{
-    // There are lots of examples of look at code on the internet that don't do all these noramize and also find the position
-    // through several dot products.  The problem with them is that they have a bit of error in that all the vectors arn't normal and need to be.
-    vector_3 z_row = vector_3(-target.x, -target.y, -target.z).get_normal();
-    vector_3 x_row = vector_3::cross(up, z_row).get_normal();
-    vector_3 y_row = vector_3::cross(z_row, x_row).get_normal();
-
-    //x_row.debug("x_row");
-    //y_row.debug("y_row");
-    //z_row.debug("z_row");
-    
-    matrix_3x3 rot = matrix_3x3::create_from_rows(vector_3(x_row.x, y_row.x, z_row.x),
-                                vector_3(x_row.y, y_row.y, z_row.y),
-                                vector_3(x_row.z, y_row.z, z_row.z));
-
-    //rot.debug("rot");
+matrix_3x3 matrix_3x3::create_look_at(vector_3 target)
+{
+    vector_3 z_row = target.get_normal();
+    vector_3 x_row = vector_3(1, 0, -target.x/target.z).get_normal();
+    vector_3 y_row = vector_3(0, 1, -target.y/target.z).get_normal();
+
+   // x_row.debug("x_row");
+   // y_row.debug("y_row");
+   // z_row.debug("z_row");
+
+ 
+     // create the matrix already correctly transposed
+    matrix_3x3 rot = matrix_3x3::create_from_rows(x_row, y_row, z_row);
+
+ //   rot.debug("rot");
     return rot;
 }
 
-matrix_3x3 matrix_3x3::create_inverse(matrix_3x3 original)
-{
-	//original.debug("original");
-	float* A = original.matrix;
-	float determinant = 
-		+ A[0 * 3 + 0] * (A[1 * 3 + 1] * A[2 * 3 + 2] - A[2 * 3 + 1] * A[1 * 3 + 2])
-		- A[0 * 3 + 1] * (A[1 * 3 + 0] * A[2 * 3 + 2] - A[1 * 3 + 2] * A[2 * 3 + 0])
-		+ A[0 * 3 + 2] * (A[1 * 3 + 0] * A[2 * 3 + 1] - A[1 * 3 + 1] * A[2 * 3 + 0]);
-	matrix_3x3 inverse;
-	inverse.matrix[0 * 3 + 0] = +(A[1 * 3 + 1] * A[2 * 3 + 2] - A[2 * 3 + 1] * A[1 * 3 + 2]) / determinant;
-	inverse.matrix[0 * 3 + 1] = -(A[0 * 3 + 1] * A[2 * 3 + 2] - A[0 * 3 + 2] * A[2 * 3 + 1]) / determinant;
-	inverse.matrix[0 * 3 + 2] = +(A[0 * 3 + 1] * A[1 * 3 + 2] - A[0 * 3 + 2] * A[1 * 3 + 1]) / determinant;
-	inverse.matrix[1 * 3 + 0] = -(A[1 * 3 + 0] * A[2 * 3 + 2] - A[1 * 3 + 2] * A[2 * 3 + 0]) / determinant;
-	inverse.matrix[1 * 3 + 1] = +(A[0 * 3 + 0] * A[2 * 3 + 2] - A[0 * 3 + 2] * A[2 * 3 + 0]) / determinant;
-	inverse.matrix[1 * 3 + 2] = -(A[0 * 3 + 0] * A[1 * 3 + 2] - A[1 * 3 + 0] * A[0 * 3 + 2]) / determinant;
-	inverse.matrix[2 * 3 + 0] = +(A[1 * 3 + 0] * A[2 * 3 + 1] - A[2 * 3 + 0] * A[1 * 3 + 1]) / determinant;
-	inverse.matrix[2 * 3 + 1] = -(A[0 * 3 + 0] * A[2 * 3 + 1] - A[2 * 3 + 0] * A[0 * 3 + 1]) / determinant;
-	inverse.matrix[2 * 3 + 2] = +(A[0 * 3 + 0] * A[1 * 3 + 1] - A[1 * 3 + 0] * A[0 * 3 + 1]) / determinant;
-
-	vector_3 row0 = vector_3(inverse.matrix[0 * 3 + 0], inverse.matrix[0 * 3 + 1], inverse.matrix[0 * 3 + 2]);
-	vector_3 row1 = vector_3(inverse.matrix[1 * 3 + 0], inverse.matrix[1 * 3 + 1], inverse.matrix[1 * 3 + 2]);
-	vector_3 row2 = vector_3(inverse.matrix[2 * 3 + 0], inverse.matrix[2 * 3 + 1], inverse.matrix[2 * 3 + 2]);
-
-    row0.normalize();
-    row1.normalize();
-    row2.normalize();
-
-	inverse = matrix_3x3::create_from_rows(row0, row1, row2);
-
-	//inverse.debug("inverse");
-	return inverse;
+
+matrix_3x3 matrix_3x3::transpose(matrix_3x3 original)
+{
+  matrix_3x3 new_matrix;
+  new_matrix.matrix[0] = original.matrix[0]; new_matrix.matrix[1] = original.matrix[3]; new_matrix.matrix[2] = original.matrix[6]; 
+  new_matrix.matrix[3] = original.matrix[1]; new_matrix.matrix[4] = original.matrix[4]; new_matrix.matrix[5] = original.matrix[7]; 
+  new_matrix.matrix[6] = original.matrix[2]; new_matrix.matrix[7] = original.matrix[5]; new_matrix.matrix[8] = original.matrix[8];
+  return new_matrix;
 }
 
 void matrix_3x3::debug(char* title)
diff --git a/Marlin/vector_3.h b/Marlin/vector_3.h
index b08c336..0b9deca 100644
--- a/Marlin/vector_3.h
+++ b/Marlin/vector_3.h
@@ -47,8 +47,8 @@ struct matrix_3x3
 	float matrix[9];
 
 	static matrix_3x3 create_from_rows(vector_3 row_0, vector_3 row_1, vector_3 row_2);
-	static matrix_3x3 create_look_at(vector_3 target, vector_3 up);
-	static matrix_3x3 create_inverse(matrix_3x3 original);
+	static matrix_3x3 create_look_at(vector_3 target);
+	static matrix_3x3 transpose(matrix_3x3 original);
 
 	void set_to_identity();
 

