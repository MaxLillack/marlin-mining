commit 15bb3f284eb532a86514a2302e093616b4b53011 (from 4e5becfc51492599d191e23b384c17dc675d6c57)
Merge: 4e5becf eeb4f02
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Sun Nov 20 14:51:40 2011 +0100

    Merge branch 'Marlin_v1', remote-tracking branch 'origin/Marlin_v1' into Marlin_v1

diff --git a/Marlin/cardreader.h b/Marlin/cardreader.h
index 653f594..44ebf0e 100644
--- a/Marlin/cardreader.h
+++ b/Marlin/cardreader.h
@@ -28,7 +28,8 @@ public:
   
 
   void ls();
-  
+  void chdir(const char * relpath);
+  void updir();
 
   inline bool eof() { return sdpos>=filesize ;};
   inline int16_t get() {  sdpos = file.curPosition();return (int16_t)file.read();};
@@ -40,8 +41,9 @@ public:
   bool sdprinting ;  
   bool cardOK ;
   char filename[11];
+  bool filenameIsDir;
 private:
-  SdFile root,*curDir;
+  SdFile root,*curDir,workDir,workDirParent,workDirParentParent;
   Sd2Card card;
   SdVolume volume;
   SdFile file;
diff --git a/Marlin/cardreader.pde b/Marlin/cardreader.pde
index bab8783..c0dbc58 100644
--- a/Marlin/cardreader.pde
+++ b/Marlin/cardreader.pde
@@ -1,4 +1,5 @@
 #include "cardreader.h"
+//#include <unistd.h>
 #ifdef SDSUPPORT
 
 CardReader::CardReader()
@@ -36,11 +37,7 @@ char *createFilename(char *buffer,const dir_t &p) //buffer>12characters
   return buffer;
 }
 
-// bool SdFat::chdir(bool set_cwd) {
-//   if (set_cwd) SdBaseFile::cwd_ = &vwd_;
-//   vwd_.close();
-//   return vwd_.openRoot(&vol_);
-// }
+
 void  CardReader::lsDive(char *prepend,SdFile parent)
 {
   dir_t p;
@@ -85,11 +82,19 @@ void  CardReader::lsDive(char *prepend,SdFile parent)
     {
       if (p.name[0] == DIR_NAME_FREE) break;
       if (p.name[0] == DIR_NAME_DELETED || p.name[0] == '.'|| p.name[0] == '_') continue;
+      if ( p.name[0] == '.')
+      {
+        if ( p.name[1] != '.')
+        continue;
+      }
       if (!DIR_IS_FILE_OR_SUBDIR(&p)) continue;
+      filenameIsDir=DIR_IS_SUBDIR(&p);
       
-      
-      if(p.name[8]!='G') continue;
-      if(p.name[9]=='~') continue;
+      if(!filenameIsDir)
+      {
+        if(p.name[8]!='G') continue;
+        if(p.name[9]=='~') continue;
+      }
       //if(cnt++!=nr) continue;
       createFilename(filename,p);
       if(lsAction==LS_SerialPrint)
@@ -126,33 +131,35 @@ void CardReader::ls()
 void CardReader::initsd()
 {
   cardOK = false;
-  #if SDSS >- 1
-    if(root.isOpen())
-      root.close();
-    if (!card.init(SPI_FULL_SPEED,SDSS))
-    {
-      //if (!card.init(SPI_HALF_SPEED,SDSS))
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("SD init fail");
-    }
-    else if (!volume.init(&card))
-    {
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("volume.init failed");
-    }
-    else if (!root.openRoot(&volume)) 
-    {
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("openRoot failed");
-    }
-    else 
-    {
-      cardOK = true;
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM("SD card ok");
-    }
-    curDir=&root;
-  #endif //SDSS
+  if(root.isOpen())
+    root.close();
+  if (!card.init(SPI_FULL_SPEED,SDSS))
+  {
+    //if (!card.init(SPI_HALF_SPEED,SDSS))
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("SD init fail");
+  }
+  else if (!volume.init(&card))
+  {
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("volume.init failed");
+  }
+  else if (!root.openRoot(&volume)) 
+  {
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("openRoot failed");
+  }
+  else 
+  {
+    cardOK = true;
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPGM("SD card ok");
+  }
+  curDir=&root;
+  if(!workDir.openRoot(&volume))
+  {
+    SERIAL_ECHOLNPGM("workDir open failed");
+  }
 }
 void CardReader::release()
 {
@@ -229,6 +236,10 @@ void CardReader::openFile(char* name,bool read)
       
     }
   }
+  else //relative path
+  {
+    curDir=&workDir;
+  }
   if(read)
   {
     if (file.open(curDir, fname, O_READ)) 
@@ -362,6 +373,7 @@ void CardReader::closefile()
 
 void CardReader::getfilename(const uint8_t nr)
 {
+  curDir=&workDir;
   lsAction=LS_GetFilename;
   nrFiles=nr;
   curDir->rewind();
@@ -371,12 +383,45 @@ void CardReader::getfilename(const uint8_t nr)
 
 uint16_t CardReader::getnrfilenames()
 {
+  curDir=&workDir;
   lsAction=LS_Count;
   nrFiles=0;
   curDir->rewind();
   lsDive("",*curDir);
+  //SERIAL_ECHOLN(nrFiles);
   return nrFiles;
 }
 
+void CardReader::chdir(const char * relpath)
+{
+  SdFile newfile;
+  SdFile *parent=&root;
+  
+  if(workDir.isOpen())
+    parent=&workDir;
+  
+  if(!newfile.open(*parent,relpath, O_READ))
+  {
+   SERIAL_ECHO_START;
+   SERIAL_ECHOPGM("Cannot enter subdir:");
+   SERIAL_ECHOLN(relpath);
+  }
+  else
+  {
+    workDirParentParent=workDirParent;
+    workDirParent=*parent;
+    
+    workDir=newfile;
+  }
+}
+
+void CardReader::updir()
+{
+  if(!workDir.isRoot())
+  {
+    workDir=workDirParent;
+    workDirParent=workDirParentParent;
+  }
+}
 
 #endif //SDSUPPORT
\ No newline at end of file
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 6bae43d..6222c70 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -51,13 +51,13 @@
   #define blocktime 500
   #define lcdslow 5
     
-  enum MainStatus{Main_Status, Main_Menu, Main_Prepare, Main_Control, Main_SD};
+  enum MainStatus{Main_Status, Main_Menu, Main_Prepare, Main_Control, Main_SD,Sub_TempControl,Sub_MotionControl};
 
   class MainMenu{
   public:
     MainMenu();
     void update();
-    uint8_t activeline;
+    int8_t activeline;
     MainStatus status;
     uint8_t displayStartingRow;
     
@@ -65,6 +65,8 @@
     void showMainMenu();
     void showPrepare();
     void showControl();
+    void showControlMotion();
+    void showControlTemp();
     void showSD();
     bool force_lcd_update;
     int lastencoderpos;
@@ -72,6 +74,55 @@
     int8_t lastlineoffset;
     
     bool linechanging;
+    
+  private:
+    inline void updateActiveLines(const uint8_t &maxlines,volatile int &encoderpos)
+    {
+      if(linechanging) return; // an item is changint its value, do not switch lines hence
+      lastlineoffset=lineoffset; 
+      int curencoderpos=encoderpos;  
+      force_lcd_update=false;
+      if(  (abs(curencoderpos-lastencoderpos)<lcdslow) ) 
+      { 
+        lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?' ':' '); 
+        if(curencoderpos<0)  
+        {  
+          lineoffset--; 
+          if(lineoffset<0) lineoffset=0; 
+          curencoderpos=lcdslow-1; 
+          force_lcd_update=true; 
+        } 
+        if(curencoderpos>(LCD_HEIGHT-1+1)*lcdslow) 
+        { 
+          lineoffset++; 
+          curencoderpos=(LCD_HEIGHT-1)*lcdslow; 
+          if(lineoffset>(maxlines+1-LCD_HEIGHT)) 
+            lineoffset=maxlines+1-LCD_HEIGHT; 
+          if(curencoderpos>maxlines*lcdslow) 
+            curencoderpos=maxlines*lcdslow; 
+          force_lcd_update=true; 
+        } 
+        lastencoderpos=encoderpos=curencoderpos; 
+        activeline=curencoderpos/lcdslow;
+        if(activeline<0) activeline=0;
+        if(activeline>LCD_HEIGHT-1) activeline=LCD_HEIGHT-1;
+        if(activeline>maxlines) 
+        {
+          activeline=maxlines;
+          curencoderpos=maxlines*lcdslow;
+        }
+        lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');    
+      } 
+    }
+    
+    inline void clearIfNecessary()
+    {
+      if(lastlineoffset!=lineoffset ||force_lcd_update)
+      {
+        force_lcd_update=true;
+         lcd.clear();
+      } 
+    }
   };
 
   //conversion routines, could need some overworking
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index c4ea234..57f63c1 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -114,11 +114,13 @@ void lcd_init()
   };
   byte uplevel[8]={0x04, 0x0e, 0x1f, 0x04, 0x1c, 0x00, 0x00, 0x00};//thanks joris
   byte refresh[8]={0x00, 0x06, 0x19, 0x18, 0x03, 0x13, 0x0c, 0x00}; //thanks joris
+  byte folder [8]={0x00, 0x1c, 0x1f, 0x11, 0x11, 0x1f, 0x00, 0x00}; //thanks joris
   lcd.begin(LCD_WIDTH, LCD_HEIGHT);
   lcd.createChar(1,Degree);
   lcd.createChar(2,Thermometer);
   lcd.createChar(3,uplevel);
   lcd.createChar(4,refresh);
+  lcd.createChar(5,folder);
   LCD_MESSAGEPGM("UltiMarlin ready.");
 }
 
@@ -224,6 +226,7 @@ void buttons_check()
     buttons=~newbutton; //invert it, because a pressed switch produces a logical 0
   #endif
   
+  //manage encoder rotation
   char enc=0;
   if(buttons&EN_A)
     enc|=(1<<0);
@@ -279,7 +282,6 @@ MainMenu::MainMenu()
   linechanging=false;
 }
 
-
 void MainMenu::showStatus()
 { 
 #if LCD_HEIGHT==4
@@ -312,22 +314,22 @@ void MainMenu::showStatus()
     oldtargetHotEnd0=ttHotEnd0;
   }
   #if defined BED_USES_THERMISTOR || defined BED_USES_AD595 
-  static int oldtBed=-1;
-  static int oldtargetBed=-1; 
-  int tBed=intround(degBed());
-  if((tBed!=oldtBed)||force_lcd_update)
-  {
-    lcd.setCursor(1,0);
-    lcd.print(ftostr3(tBed));
-    olddegHotEnd0=tBed;
-  }
-  int targetBed=intround(degTargetBed());
-  if((targetBed!=oldtargetBed)||force_lcd_update)
-  {
-    lcd.setCursor(5,0);
-    lcd.print(ftostr3(targetBed));
-    oldtargetBed=targetBed;
-  }
+    static int oldtBed=-1;
+    static int oldtargetBed=-1; 
+    int tBed=intround(degBed());
+    if((tBed!=oldtBed)||force_lcd_update)
+    {
+      lcd.setCursor(1,0);
+      lcd.print(ftostr3(tBed));
+      oldtBed=tBed;
+    }
+    int targetBed=intround(degTargetBed());
+    if((targetBed!=oldtargetBed)||force_lcd_update)
+    {
+      lcd.setCursor(5,0);
+      lcd.print(ftostr3(targetBed));
+      oldtargetBed=targetBed;
+    }
   #endif
   //starttime=2;
   static uint16_t oldtime=0;
@@ -422,173 +424,88 @@ void MainMenu::showStatus()
   }
 
 #endif
+  force_lcd_update=false;
 }
 
 enum {ItemP_exit, ItemP_home, ItemP_origin, ItemP_preheat, ItemP_extrude, ItemP_disstep};
 
+//any action must not contain a ',' character anywhere, or this breaks:
+#define MENUITEM(repaint_action, click_action) \
+  {\
+    if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+    if((activeline==line) && CLICKED) {click_action} \
+  }
+  
 void MainMenu::showPrepare()
 {
  uint8_t line=0;
- if(lastlineoffset!=lineoffset)
- {
-   force_lcd_update=true;
-   clear(); 
- }
+ clearIfNecessary();
  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
  {
    //Serial.println((int)(line-lineoffset));
   switch(i)
   {
     case ItemP_exit:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Prepare");
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          status=Main_Menu;
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Prepare")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
     case ItemP_home:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Auto Home");
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          enquecommand("G28 X-105 Y-105 Z0");
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Auto Home")  ,  BLOCK;enquecommand("G28 X-105 Y-105 Z0");beepshort(); ) ;
+      break;
     case ItemP_origin:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Set Origin");
-          
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          enquecommand("G92 X0 Y0 Z0");
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Set Origin")  ,  BLOCK;enquecommand("G92 X0 Y0 Z0");beepshort(); ) ;
+      break;
     case ItemP_preheat:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Preheat"); 
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          setTargetHotend0(170);
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Preheat")  ,  BLOCK;setTargetHotend0(170);beepshort(); ) ;
+      break;
     case ItemP_extrude:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Extrude");
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          enquecommand("G92 E0");
-          enquecommand("G1 F700 E50");
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Extrude")  ,  BLOCK;enquecommand("G92 E0");enquecommand("G1 F700 E50");beepshort(); ) ;
+      break;
     case ItemP_disstep:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Disable Steppers");
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          enquecommand("M84");
-          beepshort();
-        }
-      }break;
+      MENUITEM(  lcdprintPGM(" Disable Steppers")  ,  BLOCK;enquecommand("M84");beepshort(); ) ;
+      break;
     default:   
       break;
   }
   line++;
  }
- lastlineoffset=lineoffset;
- if((encoderpos/lcdslow!=lastencoderpos/lcdslow)||force_lcd_update)
- {
-   
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?' ':' ');
-    
-    if(encoderpos<0)
-    {
-     lineoffset--;
-     if(lineoffset<0)
-       lineoffset=0;
-     encoderpos=0;
-     force_lcd_update=true;
-    }
-    if(encoderpos/lcdslow>3)
-    {
-     lineoffset++;
-     encoderpos=3*lcdslow;
-     if(lineoffset>(ItemP_disstep+1-LCD_HEIGHT))
-       lineoffset=ItemP_disstep+1-LCD_HEIGHT;
-     force_lcd_update=true;
-    }
-    //encoderpos=encoderpos%LCD_HEIGHT;
-    lastencoderpos=encoderpos;
-    activeline=encoderpos/lcdslow;
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');   
-  } 
+ updateActiveLines(ItemP_disstep,encoderpos);
 }
+
+
+//does not work
+// #define MENUCHANGEITEM(repaint_action,  enter_action, accept_action,  change_action) \
+//   {\
+//     if(force_lcd_update)  { lcd.setCursor(0,line);  repaint_action; } \
+//     if(activeline==line)  \
+//     { \
+//       if(CLICKED) \
+//       { \
+//         linechanging=!linechanging; \
+//         if(linechanging)  {enter_action;} \
+//         else {accept_action;} \
+//       }  \
+//       else \
+//       if(linechanging) {change_action};}\
+//   }
+//   
+
 enum {
-  ItemC_exit, ItemC_nozzle, 
-  ItemC_PID_P,ItemC_PID_I,ItemC_PID_D,ItemC_PID_C,
-  ItemC_fan, 
-  ItemC_acc, ItemC_xyjerk, 
-  ItemC_vmaxx, ItemC_vmaxy, ItemC_vmaxz, ItemC_vmaxe, 
-  ItemC_vtravmin,ItemC_vmin,  
-  ItemC_amaxx, ItemC_amaxy, ItemC_amaxz, ItemC_amaxe, 
-  ItemC_aret,ItemC_esteps, ItemC_store, ItemC_load,ItemC_failsafe
+  ItemCT_exit, ItemCT_nozzle, ItemCT_fan,
+  ItemCT_PID_P,ItemCT_PID_I,ItemCT_PID_D,ItemCT_PID_C
 };
 
-void MainMenu::showControl()
+void MainMenu::showControlTemp()
 {
- uint8_t line=0;
- if((lastlineoffset!=lineoffset)||force_lcd_update)
- {
-   force_lcd_update=true;
-   clear();
- }
+  uint8_t line=0;
+ clearIfNecessary();
  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
  {
   switch(i)
   {
-    case ItemC_exit:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);lcdprintPGM(" Control");
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          status=Main_Menu;
-          beepshort();
-        }
-      }break;
-    case ItemC_nozzle:
+    case ItemCT_exit:
+      MENUITEM(  lcdprintPGM(" Temperature")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCT_nozzle:
       {
         if(force_lcd_update)
         {
@@ -622,7 +539,7 @@ void MainMenu::showControl()
         }
       }break;
       
-      case ItemC_fan:
+      case ItemCT_fan:
       {
         if(force_lcd_update)
         {
@@ -659,12 +576,12 @@ void MainMenu::showControl()
           }
         }
       }break;
-    case ItemC_acc:
-    {
+      case ItemCT_PID_P: 
+      {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" Acc:");
-          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
+          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
+          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
         }
         
         if((activeline==line) )
@@ -674,30 +591,31 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)acceleration/100;
+               encoderpos=(int)Kp/5;
             }
             else
             {
-              acceleration= encoderpos*100;
+              Kp= encoderpos*5;
               encoderpos=activeline*lcdslow;
+                
             }
             BLOCK;
             beepshort();
           }
           if(linechanging)
           {
-            if(encoderpos<5) encoderpos=5;
-            if(encoderpos>990) encoderpos=990;
-            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
+            if(encoderpos<1) encoderpos=1;
+            if(encoderpos>9990/5) encoderpos=9990/5;
+            lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
           }
         }
       }break;
-    case ItemC_xyjerk: //max_xy_jerk
+    case ItemCT_PID_I: 
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
+          lcd.setCursor(0,line);lcdprintPGM(" PID-I: ");
+          lcd.setCursor(13,line);lcd.print(ftostr51(Ki));
         }
         
         if((activeline==line) )
@@ -707,11 +625,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)max_xy_jerk;
+               encoderpos=(int)(Ki*10);
             }
             else
             {
-              max_xy_jerk= encoderpos;
+              Ki= encoderpos/10.;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -720,18 +638,18 @@ void MainMenu::showControl()
           }
           if(linechanging)
           {
-            if(encoderpos<1) encoderpos=1;
-            if(encoderpos>990) encoderpos=990;
-            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
+            if(encoderpos<0) encoderpos=0;
+            if(encoderpos>9990) encoderpos=9990;
+            lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
           }
         }
       }break;
-      case ItemC_PID_P: 
+      case ItemCT_PID_D: 
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-P: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kp));
+          lcd.setCursor(0,line);lcdprintPGM(" PID-D: ");
+          lcd.setCursor(13,line);lcd.print(itostr4(Kd));
         }
         
         if((activeline==line) )
@@ -741,11 +659,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)Kp/5;
+               encoderpos=(int)Kd/5;
             }
             else
             {
-              Kp= encoderpos*5;
+              Kd= encoderpos*5;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -754,18 +672,19 @@ void MainMenu::showControl()
           }
           if(linechanging)
           {
-            if(encoderpos<1) encoderpos=1;
+            if(encoderpos<0) encoderpos=0;
             if(encoderpos>9990/5) encoderpos=9990/5;
             lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
           }
         }
-      }break;
-    case ItemC_PID_I: 
+      }break;   
+    case ItemCT_PID_C: 
+      #ifdef PID_ADD_EXTRUSION_RATE
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-I: ");
-          lcd.setCursor(13,line);lcd.print(ftostr51(Ki));
+          lcd.setCursor(0,line);lcdprintPGM(" PID-C: ");
+          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
         }
         
         if((activeline==line) )
@@ -775,11 +694,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)(Ki*10);
+               encoderpos=(int)Kc;
             }
             else
             {
-              Ki= encoderpos/10.;
+              Kc= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -789,17 +708,54 @@ void MainMenu::showControl()
           if(linechanging)
           {
             if(encoderpos<0) encoderpos=0;
-            if(encoderpos>9990) encoderpos=9990;
-            lcd.setCursor(13,line);lcd.print(ftostr51(encoderpos/10.));
+            if(encoderpos>990) encoderpos=990;
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
           }
         }
-      }break;
-      case ItemC_PID_D: 
-      {
+      }
+      #endif
+      break;
+    default:   
+      break;
+  }
+  line++;
+ }
+ #ifdef PID_ADD_EXTRUSION_RATE
+  updateActiveLines(ItemCT_PID_C,encoderpos);
+ #else
+  updateActiveLines(ItemCT_PID_D,encoderpos);
+ #endif
+}
+
+
+enum {
+  ItemCM_exit, 
+  ItemCM_acc, ItemCM_xyjerk, 
+  ItemCM_vmaxx, ItemCM_vmaxy, ItemCM_vmaxz, ItemCM_vmaxe, 
+  ItemCM_vtravmin,ItemCM_vmin,  
+  ItemCM_amaxx, ItemCM_amaxy, ItemCM_amaxz, ItemCM_amaxe, 
+  ItemCM_aret,ItemCM_esteps
+};
+
+
+
+void MainMenu::showControlMotion()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemCM_exit:
+      MENUITEM(  lcdprintPGM(" Motion")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
+    case ItemCM_acc:
+    {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-D: ");
-          lcd.setCursor(13,line);lcd.print(itostr4(Kd));
+          lcd.setCursor(0,line);lcdprintPGM(" Acc:");
+          lcd.setCursor(13,line);lcd.print(itostr3(acceleration/100));lcdprintPGM("00");
         }
         
         if((activeline==line) )
@@ -809,34 +765,30 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)Kd/5;
+               encoderpos=(int)acceleration/100;
             }
             else
             {
-              Kd= encoderpos*5;
+              acceleration= encoderpos*100;
               encoderpos=activeline*lcdslow;
-                
             }
             BLOCK;
             beepshort();
           }
           if(linechanging)
           {
-            if(encoderpos<0) encoderpos=0;
-            if(encoderpos>9990/5) encoderpos=9990/5;
-            lcd.setCursor(13,line);lcd.print(itostr4(encoderpos*5));
+            if(encoderpos<5) encoderpos=5;
+            if(encoderpos>990) encoderpos=990;
+            lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));lcdprintPGM("00");
           }
         }
       }break;
-    
-    
-      
-    case ItemC_PID_C: 
+    case ItemCM_xyjerk: //max_xy_jerk
       {
       if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" PID-C: ");
-          lcd.setCursor(13,line);lcd.print(itostr3(Kc));
+          lcd.setCursor(0,line);lcdprintPGM(" Vxy-jerk: ");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_xy_jerk));
         }
         
         if((activeline==line) )
@@ -846,11 +798,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)Kc;
+               encoderpos=(int)max_xy_jerk;
             }
             else
             {
-              Kc= encoderpos;
+              max_xy_jerk= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -859,25 +811,26 @@ void MainMenu::showControl()
           }
           if(linechanging)
           {
-            if(encoderpos<0) encoderpos=0;
+            if(encoderpos<1) encoderpos=1;
             if(encoderpos>990) encoderpos=990;
             lcd.setCursor(13,line);lcd.print(itostr3(encoderpos));
           }
         }
       }break;
-    case ItemC_vmaxx:
-    case ItemC_vmaxy:
-    case ItemC_vmaxz:
-    case ItemC_vmaxe:
+      
+    case ItemCM_vmaxx:
+    case ItemCM_vmaxy:
+    case ItemCM_vmaxz:
+    case ItemCM_vmaxe:
       {
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" Vmax ");
-          if(i==ItemC_vmaxx)lcdprintPGM("x:");
-          if(i==ItemC_vmaxy)lcdprintPGM("y:");
-          if(i==ItemC_vmaxz)lcdprintPGM("z:");
-          if(i==ItemC_vmaxe)lcdprintPGM("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemC_vmaxx]));
+          if(i==ItemCM_vmaxx)lcdprintPGM("x:");
+          if(i==ItemCM_vmaxy)lcdprintPGM("y:");
+          if(i==ItemCM_vmaxz)lcdprintPGM("z:");
+          if(i==ItemCM_vmaxe)lcdprintPGM("e:");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_feedrate[i-ItemCM_vmaxx]));
         }
         
         if((activeline==line) )
@@ -887,11 +840,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)max_feedrate[i-ItemC_vmaxx];
+               encoderpos=(int)max_feedrate[i-ItemCM_vmaxx];
             }
             else
             {
-              max_feedrate[i-ItemC_vmaxx]= encoderpos;
+              max_feedrate[i-ItemCM_vmaxx]= encoderpos;
               encoderpos=activeline*lcdslow;
                 
             }
@@ -907,7 +860,7 @@ void MainMenu::showControl()
         }
       }break;
     
-    case ItemC_vmin:
+    case ItemCM_vmin:
     {
       if(force_lcd_update)
         {
@@ -941,7 +894,7 @@ void MainMenu::showControl()
           }
         }
       }break;
-    case ItemC_vtravmin:
+    case ItemCM_vtravmin:
     {
       if(force_lcd_update)
         {
@@ -976,19 +929,19 @@ void MainMenu::showControl()
         }
       }break;
     
-    case ItemC_amaxx:      
-    case ItemC_amaxy:
-    case ItemC_amaxz:
-    case ItemC_amaxe:
+    case ItemCM_amaxx:      
+    case ItemCM_amaxy:
+    case ItemCM_amaxz:
+    case ItemCM_amaxe:
     {
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(" Amax ");
-          if(i==ItemC_amaxx)lcdprintPGM("x:");
-          if(i==ItemC_amaxy)lcdprintPGM("y:");
-          if(i==ItemC_amaxz)lcdprintPGM("z:");
-          if(i==ItemC_amaxe)lcdprintPGM("e:");
-          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemC_amaxx]/100));lcdprintPGM("00");
+          if(i==ItemCM_amaxx)lcdprintPGM("x:");
+          if(i==ItemCM_amaxy)lcdprintPGM("y:");
+          if(i==ItemCM_amaxz)lcdprintPGM("z:");
+          if(i==ItemCM_amaxe)lcdprintPGM("e:");
+          lcd.setCursor(13,line);lcd.print(itostr3(max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100));lcdprintPGM("00");
         }
         
         if((activeline==line) )
@@ -998,11 +951,11 @@ void MainMenu::showControl()
             linechanging=!linechanging;
             if(linechanging)
             {
-               encoderpos=(int)max_acceleration_units_per_sq_second[i-ItemC_amaxx]/100;
+               encoderpos=(int)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
             }
             else
             {
-              max_acceleration_units_per_sq_second[i-ItemC_amaxx]= encoderpos*100;
+              max_acceleration_units_per_sq_second[i-ItemCM_amaxx]= encoderpos*100;
               encoderpos=activeline*lcdslow;
             }
             BLOCK;
@@ -1016,7 +969,7 @@ void MainMenu::showControl()
           }
         }
       }break;
-    case ItemC_aret://float retract_acceleration = 7000;
+    case ItemCM_aret://float retract_acceleration = 7000;
     {
         if(force_lcd_update)
         {
@@ -1050,7 +1003,7 @@ void MainMenu::showControl()
           }
         }
       }break;
-    case ItemC_esteps://axis_steps_per_unit[i] = code_value();
+    case ItemCM_esteps://axis_steps_per_unit[i] = code_value();
          {
       if(force_lcd_update)
         {
@@ -1087,6 +1040,37 @@ void MainMenu::showControl()
           }
         }
       }break; 
+    default:   
+      break;
+  }
+  line++;
+ }
+ updateActiveLines(ItemCM_esteps,encoderpos);
+}
+
+
+enum {
+  ItemC_exit,ItemC_temp,ItemC_move,
+  ItemC_store, ItemC_load,ItemC_failsafe
+};
+
+void MainMenu::showControl()
+{
+ uint8_t line=0;
+ clearIfNecessary();
+ for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
+ {
+  switch(i)
+  {
+    case ItemC_exit:
+      MENUITEM(  lcdprintPGM(" Control     \x7E")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+    case ItemC_temp:
+      MENUITEM(  lcdprintPGM(" Temperature \x7E")  ,  BLOCK;status=Sub_TempControl;beepshort(); ) ;
+      break;
+   case ItemC_move:
+      MENUITEM(  lcdprintPGM(" Motion      \x7E")  ,  BLOCK;status=Sub_MotionControl;beepshort(); ) ;
+      break;
     case ItemC_store:
     {
       if(force_lcd_update)
@@ -1134,55 +1118,22 @@ void MainMenu::showControl()
   }
   line++;
  }
- lastlineoffset=lineoffset;
-
- if(!linechanging &&  ((encoderpos/lcdslow!=lastencoderpos/lcdslow)||force_lcd_update))
- {
-   
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?' ':' ');
-    
-    if(encoderpos<0)
-    {
-     lineoffset--;
-     if(lineoffset<0)
-       lineoffset=0;
-     encoderpos=0;
-     force_lcd_update=true;
-    }
-    if(encoderpos/lcdslow>3)
-    {
-     lineoffset++;
-     encoderpos=3*lcdslow;
-     if(lineoffset>(ItemC_failsafe+1-LCD_HEIGHT))
-       lineoffset=ItemC_failsafe+1-LCD_HEIGHT;
-     force_lcd_update=true;
-    }
-    //encoderpos=encoderpos%LCD_HEIGHT;
-    lastencoderpos=encoderpos;
-    activeline=encoderpos/lcdslow;
-    if(activeline>3) activeline=3;
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');   
-  } 
+ updateActiveLines(ItemC_failsafe,encoderpos);
 }
 
 
 
 
 
-
 void MainMenu::showSD()
 {
 #ifdef SDSUPPORT
  uint8_t line=0;
 
- if(lastlineoffset!=lineoffset)
- {
-   force_lcd_update=true; 
- }
+ clearIfNecessary();
  static uint8_t nrfiles=0;
  if(force_lcd_update)
  {
-   clear();
   if(card.cardOK)
   {
     nrfiles=card.getnrfilenames();
@@ -1192,78 +1143,85 @@ void MainMenu::showSD()
     nrfiles=0;
     lineoffset=0;
   }
-  //Serial.print("Nr files:"); Serial.println((int)nrfiles);
  }
- 
+ bool enforceupdate=false;
  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
  {
   switch(i)
   {
     case 0:
+      MENUITEM(  lcdprintPGM(" File")  ,  BLOCK;status=Main_Menu;beepshort(); ) ;
+      break;
+//     case 1:
+//       {
+//         if(force_lcd_update)
+//         {
+//           lcd.setCursor(0,line);
+//            #ifdef CARDINSERTED
+//           if(CARDINSERTED)
+//           #else
+//           if(true)
+//           #endif
+//           {
+//             lcdprintPGM(" \004Refresh");
+//           }
+//           else
+//           {
+//             lcdprintPGM(" \004Insert Card");
+//           }
+//           
+//         }
+//         if((activeline==line) && CLICKED)
+//         {
+//           BLOCK;
+//           beepshort();
+//           card.initsd();
+//           force_lcd_update=true;
+//            nrfiles=card.getnrfilenames();
+//         }
+//       }break;
+    case 1:
+      MENUITEM(  lcdprintPGM(" ..")  ,  BLOCK;card.updir();enforceupdate=true;lineoffset=0;beepshort(); ) ;
+      
+      break;
+    default:
+    {
+      #define FIRSTITEM 2
+      if(i-FIRSTITEM<nrfiles)
       {
         if(force_lcd_update)
         {
-          lcd.setCursor(0,line);lcdprintPGM(" File");
+          card.getfilename(i-FIRSTITEM);
+          //Serial.print("Filenr:");Serial.println(i-2);
+          lcd.setCursor(0,line);lcdprintPGM(" ");
+          if(card.filenameIsDir) lcd.print("\005");
+          lcd.print(card.filename);
         }
         if((activeline==line) && CLICKED)
         {
           BLOCK
-          status=Main_Menu;
-          beepshort();
-        }
-      }break;
-    case 1:
-      {
-        if(force_lcd_update)
-        {
-          lcd.setCursor(0,line);
-           #ifdef CARDINSERTED
-          if(CARDINSERTED)
-          #else
-          if(true)
-          #endif
+          card.getfilename(i-FIRSTITEM);
+          if(card.filenameIsDir)
           {
-            lcdprintPGM(" \004Refresh");
+            for(int8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            card.chdir(card.filename);
+            lineoffset=0;
+            enforceupdate=true;
           }
           else
           {
-            lcdprintPGM(" \004Insert Card");
+            char cmd[30];
+            for(int8_t i=0;i<strlen(card.filename);i++)
+              card.filename[i]=tolower(card.filename[i]);
+            sprintf(cmd,"M23 %s",card.filename);
+            //sprintf(cmd,"M115");
+            enquecommand(cmd);
+            enquecommand("M24");
+            beep(); 
+            status=Main_Status;
+            lcd_status(card.filename);
           }
-          
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK;
-          beepshort();
-          card.initsd();
-          force_lcd_update=true;
-           nrfiles=card.getnrfilenames();
-        }
-      }break;
-    default:
-    {
-      if(i-2<nrfiles)
-      {
-        if(force_lcd_update)
-        {
-          card.getfilename(i-2);
-          //Serial.print("Filenr:");Serial.println(i-2);
-          lcd.setCursor(0,line);lcdprintPGM(" ");lcd.print(card.filename);
-        }
-        if((activeline==line) && CLICKED)
-        {
-          BLOCK
-          card.getfilename(i-2);
-          char cmd[30];
-          for(int8_t i=0;i<strlen(card.filename);i++)
-            card.filename[i]=tolower(card.filename[i]);
-          sprintf(cmd,"M23 %s",card.filename);
-          //sprintf(cmd,"M115");
-          enquecommand(cmd);
-          enquecommand("M24");
-          beep(); 
-          status=Main_Status;
-          lcd_status(card.filename);
         }
       }
       
@@ -1272,93 +1230,38 @@ void MainMenu::showSD()
   }
   line++;
  }
- lastlineoffset=lineoffset;
- if((encoderpos!=lastencoderpos)||force_lcd_update)
+ updateActiveLines(FIRSTITEM+nrfiles-1,encoderpos);
+ if(enforceupdate)
  {
-   
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?' ':' ');
-    
-    if(encoderpos<0)
-    {
-     lineoffset--;
-     if(lineoffset<0)
-       lineoffset=0;
-     encoderpos=0;
-     force_lcd_update=true;
-    }
-    if(encoderpos/lcdslow>3)
-    {
-     lineoffset++;
-     encoderpos=3*lcdslow;
-     if(lineoffset>(1+nrfiles+1-LCD_HEIGHT))
-       lineoffset=1+nrfiles+1-LCD_HEIGHT;
-     force_lcd_update=true;
-     
-    }
-    lastencoderpos=encoderpos;
-    activeline=encoderpos;
-    if(activeline>3) 
-    {
-      activeline=3;
-    }
-    if(activeline<0) 
-    {
-      activeline=0;
-    }
-    if(activeline>1+nrfiles) activeline=1+nrfiles;
-    if(lineoffset>1+nrfiles) lineoffset=1+nrfiles;
-    lcd.setCursor(0,activeline);lcd.print((activeline+lineoffset)?'>':'\003');   
-    
-  }
+   force_lcd_update=true;
+   enforceupdate=false;
+ }
 #endif
 }
 
 enum {ItemM_watch, ItemM_prepare, ItemM_control, ItemM_file };
 void MainMenu::showMainMenu()
 {
-   //if(int(encoderpos/lcdslow)!=int(lastencoderpos/lcdslow))
-   //  force_lcd_update=true;
+
   #ifndef ULTIPANEL
     force_lcd_update=false;
   #endif
-   //Serial.println((int)activeline);
-   if(force_lcd_update)
-     clear();
+   
+  clearIfNecessary();
   for(int8_t line=0;line<LCD_HEIGHT;line++)
   {
     switch(line)
     { 
       case ItemM_watch:
-      {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Watch   \x7E");}
-        if((activeline==line)&&CLICKED)
-        {
-          BLOCK;
-          beepshort();
-          status=Main_Status;
-        }
-      } break;
+        MENUITEM(  lcdprintPGM(" Watch")  ,  BLOCK;status=Main_Status;beepshort(); ) ;
+       break;
       case ItemM_prepare:
-      {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Prepare \x7E");}
-        if((activeline==line)&&CLICKED)
-        {
-          BLOCK;
-          status=Main_Prepare;
-          beepshort();
-        }
-      } break;
+        MENUITEM(  lcdprintPGM(" Prepare \x7E")  ,  BLOCK;status=Main_Prepare;beepshort(); ) ;
+      break;
        
       case ItemM_control:
-      {
-        if(force_lcd_update) {lcd.setCursor(0,line);lcdprintPGM(" Control \x7E");}
-        if((activeline==line)&&CLICKED)
-        {
-          BLOCK;
-          status=Main_Control;
-          beepshort();
-        }
-      }break;
+        MENUITEM(  lcdprintPGM(" Control \x7E")  ,  BLOCK;status=Main_Control;beepshort(); ) ;
+      break;
       #ifdef SDSUPPORT
       case ItemM_file:    
       {
@@ -1392,6 +1295,9 @@ void MainMenu::showMainMenu()
           beepshort();
         }
       }break;
+      #else
+      case ItemM_file:
+        break;
       #endif
       default: 
         SERIAL_ERROR_START;
@@ -1399,24 +1305,7 @@ void MainMenu::showMainMenu()
       break;
     }
   }
-  if(activeline<0) 
-    activeline=0;
-  if(activeline>=LCD_HEIGHT) 
-    activeline=LCD_HEIGHT-1;
-  if((encoderpos!=lastencoderpos)||force_lcd_update)
-  {
-    lcd.setCursor(0,activeline);lcd.print(activeline?' ':' ');
-    if(encoderpos<0) encoderpos=0;
-    if(encoderpos>3*lcdslow) 
-      encoderpos=3*lcdslow;
-    activeline=abs(encoderpos/lcdslow)%LCD_HEIGHT;
-    if(activeline<0) 
-      activeline=0;
-    if(activeline>=LCD_HEIGHT) 
-      activeline=LCD_HEIGHT-1;
-    lastencoderpos=encoderpos;
-    lcd.setCursor(0,activeline);lcd.print(activeline?'>':'\003');
-  }
+  updateActiveLines(3,encoderpos);
 }
 
 void MainMenu::update()
@@ -1433,20 +1322,18 @@ void MainMenu::update()
       if(CARDINSERTED)
       {
         card.initsd();
-        lcd_status("Card inserted");
+        LCD_MESSAGEPGM("Card inserted");
       }
       else
       {
         card.release();
-        lcd_status("Card removed");
+        LCD_MESSAGEPGM("Card removed");
       }
     }
   #endif
  
   if(status!=oldstatus)
   {
-    //Serial.println(status);
-    //clear();
     force_lcd_update=true;
     encoderpos=0;
     lineoffset=0;
@@ -1482,6 +1369,14 @@ void MainMenu::update()
       {
         showControl(); 
       }break;
+      case Sub_MotionControl:
+      {
+        showControlMotion(); 
+      }break;
+      case Sub_TempControl:
+      {
+        showControlTemp(); 
+      }break;
       case Main_SD: 
       {
         showSD();
@@ -1490,7 +1385,7 @@ void MainMenu::update()
   
   if(timeoutToStatus<millis())
     status=Main_Status;
-  force_lcd_update=false;
+  //force_lcd_update=false;
   lastencoderpos=encoderpos;
 }
 
diff --git a/README.md b/README.md
index 22b3c9a..988bf9a 100644
--- a/README.md
+++ b/README.md
@@ -54,6 +54,7 @@ This is only possible, if some future moves are already processed, hence the nam
 It leads to less over-deposition at corners, especially at flat angles.
 
 *Arc support:*
+
 Splic3r can find curves that, although broken into segments, were ment to describe an arc.
 Marlin is able to print those arcs. The advantage is the firmware can choose the resolution,
 and can perform the arc with nearly constant velocity, resulting in a nice finish. 
@@ -118,13 +119,15 @@ This leads to less blocking in the heater management routine.
 
 Non-standard M-Codes, different to an old version of sprinter:
 ==============================================================
+Movement:
+
 *   G2  - CW ARC
 *   G3  - CCW ARC
 
 General:
 
-*   M17  - Enable/Power all stepper motors
-*   M18  - Disable all stepper motors; same as M84
+*   M17  - Enable/Power all stepper motors. Compatibility to ReplicatorG.
+*   M18  - Disable all stepper motors; same as M84.Compatibility to ReplicatorG.
 *   M30  - Print time since last M109 or SD card start to serial
 *   M42  - Change pin status via gcode
 *   M80  - Turn on Power Supply
@@ -137,9 +140,9 @@ Movement variables:
 *   M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 *   M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 *   M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
-*   M220 - set build speed factor override percentage S:factor in percent ; aka "realtime tuneing in the gcode"
+*   M220 - set build speed mulitplying S:factor in percent ; aka "realtime tuneing in the gcode". So you can slow down if you have islands in one height-range, and speed up otherwise.
 *   M301 - Set PID parameters P I and D
-*   M400 - Finish all moves
+*   M400 - Finish all buffered moves.
 
 Advance:
 

commit 15bb3f284eb532a86514a2302e093616b4b53011 (from eeb4f029dbaa8f12350f631441303832fc14fc9e)
Merge: 4e5becf eeb4f02
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Sun Nov 20 14:51:40 2011 +0100

    Merge branch 'Marlin_v1', remote-tracking branch 'origin/Marlin_v1' into Marlin_v1

diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 754dc36..8ee1656 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -465,24 +465,22 @@ inline bool code_seen(char code)
     destination[LETTER##_AXIS] = 1.5 * LETTER##_MAX_LENGTH * LETTER##_HOME_DIR; \
     feedrate = homing_feedrate[LETTER##_AXIS]; \
     prepare_move(); \
-    st_synchronize();\
     \
     current_position[LETTER##_AXIS] = 0;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     destination[LETTER##_AXIS] = -5 * LETTER##_HOME_DIR;\
     prepare_move(); \
-    st_synchronize();\
     \
     destination[LETTER##_AXIS] = 10 * LETTER##_HOME_DIR;\
     feedrate = homing_feedrate[LETTER##_AXIS]/2 ;  \
     prepare_move(); \
-    st_synchronize();\
     \
     current_position[LETTER##_AXIS] = (LETTER##_HOME_DIR == -1) ? 0 : LETTER##_MAX_LENGTH;\
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     destination[LETTER##_AXIS] = current_position[LETTER##_AXIS];\
     feedrate = 0.0;\
     st_synchronize();\
+    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);\
     endstops_hit_on_purpose();\
   }
 
@@ -680,7 +678,7 @@ inline void process_commands()
     case 140: // M140 set bed temp
       if (code_seen('S')) setTargetBed(code_value());
       break;
-    case 105: // M105
+    case 105 : // M105
       //SERIAL_ECHOLN(freeMemory());
        //test watchdog:
        //delay(20000);
@@ -817,7 +815,7 @@ inline void process_commands()
       axis_relative_modes[3] = true;
       break;
     case 18: //compatibility
-    case 84:
+    case 84: // M84
       if(code_seen('S')){ 
         stepper_inactive_time = code_value() * 1000; 
       }
@@ -854,14 +852,14 @@ inline void process_commands()
       SERIAL_PROTOCOL(current_position[Z_AXIS]);
       SERIAL_PROTOCOLPGM("E:");      
       SERIAL_PROTOCOL(current_position[E_AXIS]);
-      #ifdef DEBUG_STEPS
-        SERIAL_PROTOCOLPGM(" Count X:");
-        SERIAL_PROTOCOL(float(count_position[X_AXIS])/axis_steps_per_unit[X_AXIS]);
-        SERIAL_PROTOCOLPGM("Y:");
-        SERIAL_PROTOCOL(float(count_position[Y_AXIS])/axis_steps_per_unit[Y_AXIS]);
-        SERIAL_PROTOCOLPGM("Z:");
-        SERIAL_PROTOCOL(float(count_position[Z_AXIS])/axis_steps_per_unit[Z_AXIS]);
-      #endif
+      
+      SERIAL_PROTOCOLPGM(" Count X:");
+      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
+      SERIAL_PROTOCOLPGM("Y:");
+      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
+      SERIAL_PROTOCOLPGM("Z:");
+      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);
+      
       SERIAL_PROTOCOLLN("");
       break;
     case 119: // M119
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index b7f98b6..a59945d 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -754,6 +754,7 @@ void plan_set_position(const float &x, const float &y, const float &z, const flo
   position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
   position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
   position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  
+  st_set_position(position[X_AXIS], position[Y_AXIS], position[Z_AXIS], position[E_AXIS]);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   previous_speed[0] = 0.0;
   previous_speed[1] = 0.0;
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index b08e61a..771bccf 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -66,14 +66,12 @@ static char step_loops;
 
 volatile long endstops_trigsteps[3]={0,0,0};
 volatile long endstops_stepsTotal,endstops_stepsDone;
-static volatile bool endstops_hit=false;
+static volatile bool endstop_x_hit=false;
+static volatile bool endstop_y_hit=false;
+static volatile bool endstop_z_hit=false;
 
-// if DEBUG_STEPS is enabled, M114 can be used to compare two methods of determining the X,Y,Z position of the printer.
-// for debugging purposes only, should be disabled by default
-#ifdef DEBUG_STEPS
-  volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
-  volatile int count_direction[NUM_AXIS] = { 1, 1, 1, 1};
-#endif
+volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
+volatile char count_direction[NUM_AXIS] = { 1, 1, 1, 1};
 
 //===========================================================================
 //=============================functions         ============================
@@ -155,49 +153,32 @@ asm volatile ( \
 #define ENABLE_STEPPER_DRIVER_INTERRUPT()  TIMSK1 |= (1<<OCIE1A)
 #define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1<<OCIE1A)
 
-
-inline void endstops_triggered(const unsigned long &stepstaken)  
-{
-  //this will only work if there is no bufferig
-  //however, if you perform a move at which the endstops should be triggered, and wait for it to complete, i.e. by blocking command, it should work
-  //yes, it uses floats, but: if endstops are triggered, thats hopefully not critical anymore anyways.
-  //endstops_triggerpos;
-  
-  if(endstops_hit) //hitting a second time while the first hit is not reported
-    return;
-  if(current_block == NULL)
-    return;
-  endstops_stepsTotal=current_block->step_event_count;
-  endstops_stepsDone=stepstaken;
-  endstops_trigsteps[0]=current_block->steps_x;
-  endstops_trigsteps[1]=current_block->steps_y;
-  endstops_trigsteps[2]=current_block->steps_z;
-
-  endstops_hit=true;
-}
-
 void checkHitEndstops()
 {
-  if( !endstops_hit)
-   return;
-  float endstops_triggerpos[3]={0,0,0};
-  float ratiodone=endstops_stepsDone/float(endstops_stepsTotal);  //ratio of current_block thas was performed
-  
-  endstops_triggerpos[0]=current_position[0]-(endstops_trigsteps[0]*ratiodone)/float(axis_steps_per_unit[0]);
-  endstops_triggerpos[1]=current_position[1]-(endstops_trigsteps[1]*ratiodone)/float(axis_steps_per_unit[1]);
-  endstops_triggerpos[2]=current_position[2]-(endstops_trigsteps[2]*ratiodone)/float(axis_steps_per_unit[2]);
- SERIAL_ECHO_START;
- SERIAL_ECHOPGM("endstops hit: ");
- SERIAL_ECHOPAIR(" X:",endstops_triggerpos[0]);
- SERIAL_ECHOPAIR(" Y:",endstops_triggerpos[1]);
- SERIAL_ECHOPAIR(" Z:",endstops_triggerpos[2]);
- SERIAL_ECHOLN("");
- endstops_hit=false;
+ if( endstop_x_hit || endstop_y_hit || endstop_z_hit) {
+   SERIAL_ECHO_START;
+   SERIAL_ECHOPGM("endstops hit: ");
+   if(endstop_x_hit) {
+     SERIAL_ECHOPAIR(" X:",(float)endstops_trigsteps[X_AXIS]/axis_steps_per_unit[X_AXIS]);
+   }
+   if(endstop_y_hit) {
+     SERIAL_ECHOPAIR(" Y:",(float)endstops_trigsteps[Y_AXIS]/axis_steps_per_unit[Y_AXIS]);
+   }
+   if(endstop_z_hit) {
+     SERIAL_ECHOPAIR(" Z:",(float)endstops_trigsteps[Z_AXIS]/axis_steps_per_unit[Z_AXIS]);
+   }
+   SERIAL_ECHOLN("");
+   endstop_x_hit=false;
+   endstop_y_hit=false;
+   endstop_z_hit=false;
+ }
 }
 
 void endstops_hit_on_purpose()
 {
-  endstops_hit=false;
+  endstop_x_hit=false;
+  endstop_y_hit=false;
+  endstop_z_hit=false;
 }
 
 //         __________________________
@@ -312,24 +293,22 @@ ISR(TIMER1_COMPA_vect)
     // Set direction en check limit switches
     if ((out_bits & (1<<X_AXIS)) != 0) {   // -direction
       WRITE(X_DIR_PIN, INVERT_X_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[X_AXIS]=-1;
-      #endif
+      count_direction[X_AXIS]=-1;
       #if X_MIN_PIN > -1
-        if(READ(X_MIN_PIN) != ENDSTOPS_INVERTING) {
- //         endstops_triggered(step_events_completed);
+        if((READ(X_MIN_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_x > 0)) {
+          endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
+          endstop_x_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
     }
     else { // +direction 
       WRITE(X_DIR_PIN,!INVERT_X_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[X_AXIS]=1;
-      #endif
+      count_direction[X_AXIS]=1;
       #if X_MAX_PIN > -1
-        if((READ(X_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_x >0)){
- //         endstops_triggered(step_events_completed);
+        if((READ(X_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_x > 0)){
+          endstops_trigsteps[X_AXIS] = count_position[X_AXIS];
+          endstop_x_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -337,24 +316,22 @@ ISR(TIMER1_COMPA_vect)
 
     if ((out_bits & (1<<Y_AXIS)) != 0) {   // -direction
       WRITE(Y_DIR_PIN,INVERT_Y_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[Y_AXIS]=-1;
-      #endif
+      count_direction[Y_AXIS]=-1;
       #if Y_MIN_PIN > -1
-        if(READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) {
-//          endstops_triggered(step_events_completed);
+        if((READ(Y_MIN_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y > 0)) {
+          endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];
+          endstop_y_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
     }
     else { // +direction
     WRITE(Y_DIR_PIN,!INVERT_Y_DIR);
-      #ifdef DEBUG_STEPS
-        count_direction[Y_AXIS]=1;
-      #endif
+      count_direction[Y_AXIS]=1;
       #if Y_MAX_PIN > -1
-      if((READ(Y_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y >0)){
- //         endstops_triggered(step_events_completed);
+      if((READ(Y_MAX_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_y > 0)){
+          endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];
+          endstop_y_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
@@ -362,34 +339,36 @@ ISR(TIMER1_COMPA_vect)
 
     if ((out_bits & (1<<Z_AXIS)) != 0) {   // -direction
       WRITE(Z_DIR_PIN,INVERT_Z_DIR);
-      #ifdef DEBUG_STEPS
       count_direction[Z_AXIS]=-1;
-      #endif
       #if Z_MIN_PIN > -1
-        if(READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) {
- //         endstops_triggered(step_events_completed);
+        if((READ(Z_MIN_PIN) != ENDSTOPS_INVERTING) && (current_block->steps_z > 0)) {
+          endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
+          endstop_z_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
     }
     else { // +direction
       WRITE(Z_DIR_PIN,!INVERT_Z_DIR);
-      #ifdef DEBUG_STEPS
         count_direction[Z_AXIS]=1;
-      #endif
       #if Z_MAX_PIN > -1
-        if((READ(Z_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_z >0)){
- //         endstops_triggered(step_events_completed);
+        if((READ(Z_MAX_PIN) != ENDSTOPS_INVERTING)  && (current_block->steps_z > 0)){
+          endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
+          endstop_z_hit=true;
           step_events_completed = current_block->step_event_count;
         }
       #endif
     }
 
     #ifndef ADVANCE
-      if ((out_bits & (1<<E_AXIS)) != 0)   // -direction
+      if ((out_bits & (1<<E_AXIS)) != 0) {  // -direction
         WRITE(E_DIR_PIN,INVERT_E_DIR);
-      else // +direction
+        count_direction[E_AXIS]=-1;
+      }
+      else { // +direction
         WRITE(E_DIR_PIN,!INVERT_E_DIR);
+        count_direction[E_AXIS]=-1;
+      }
     #endif //!ADVANCE
 
     for(int8_t i=0; i < step_loops; i++) { // Take multiple steps per interrupt (For high speed moves) 
@@ -422,9 +401,7 @@ ISR(TIMER1_COMPA_vect)
         WRITE(X_STEP_PIN, HIGH);
         counter_x -= current_block->step_event_count;
         WRITE(X_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[X_AXIS]+=count_direction[X_AXIS];   
-        #endif
+        count_position[X_AXIS]+=count_direction[X_AXIS];   
       }
 
       counter_y += current_block->steps_y;
@@ -432,9 +409,7 @@ ISR(TIMER1_COMPA_vect)
         WRITE(Y_STEP_PIN, HIGH);
         counter_y -= current_block->step_event_count;
         WRITE(Y_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[Y_AXIS]+=count_direction[Y_AXIS];
-        #endif
+        count_position[Y_AXIS]+=count_direction[Y_AXIS];
       }
 
       counter_z += current_block->steps_z;
@@ -442,9 +417,7 @@ ISR(TIMER1_COMPA_vect)
         WRITE(Z_STEP_PIN, HIGH);
         counter_z -= current_block->step_event_count;
         WRITE(Z_STEP_PIN, LOW);
-        #ifdef DEBUG_STEPS
-          count_position[Z_AXIS]+=count_direction[Z_AXIS];
-        #endif
+        count_position[Z_AXIS]+=count_direction[Z_AXIS];
       }
 
       #ifndef ADVANCE
@@ -453,6 +426,7 @@ ISR(TIMER1_COMPA_vect)
           WRITE(E_STEP_PIN, HIGH);
           counter_e -= current_block->step_event_count;
           WRITE(E_STEP_PIN, LOW);
+          count_position[E_AXIS]+=count_direction[E_AXIS];
         }
       #endif //!ADVANCE
       step_events_completed += 1;  
@@ -669,3 +643,22 @@ void st_synchronize()
     LCD_STATUS;
   }   
 }
+
+void st_set_position(const long &x, const long &y, const long &z, const long &e)
+{
+  CRITICAL_SECTION_START;
+  count_position[X_AXIS] = x;
+  count_position[Y_AXIS] = y;
+  count_position[Z_AXIS] = z;
+  count_position[E_AXIS] = e;
+  CRITICAL_SECTION_END;
+}
+
+long st_get_position(char axis)
+{
+  long count_pos;
+  CRITICAL_SECTION_START;
+  count_pos = count_position[axis];
+  CRITICAL_SECTION_END;
+  return count_pos;
+}
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index ecbc713..eb07fa9 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -1,51 +1,51 @@
-/*
-  stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
-  Part of Grbl
-
-  Copyright (c) 2009-2011 Simen Svale Skogsrud
-
-  Grbl is free software: you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation, either version 3 of the License, or
-  (at your option) any later version.
-
-  Grbl is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef stepper_h
-#define stepper_h 
-
-#include "planner.h"
-
-// Initialize and start the stepper motor subsystem
-void st_init();
-
-// Block until all buffered steps are executed
-void st_synchronize();
-
-// The stepper subsystem goes to sleep when it runs out of things to execute. Call this
-// to notify the subsystem that it is time to go to work.
-void st_wake_up();
-
-// if DEBUG_STEPS is enabled, M114 can be used to compare two methods of determining the X,Y,Z position of the printer.
-// for debugging purposes only, should be disabled by default
-#ifdef DEBUG_STEPS
-  extern volatile long count_position[NUM_AXIS];
-  extern volatile int count_direction[NUM_AXIS];
-#endif
-  
-void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered
-void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();
-
-
-
-extern block_t *current_block;  // A pointer to the block currently being traced
-
-
+/*
+  stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
+  Part of Grbl
+
+  Copyright (c) 2009-2011 Simen Svale Skogsrud
+
+  Grbl is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  Grbl is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef stepper_h
+#define stepper_h 
+
+#include "planner.h"
+
+// Initialize and start the stepper motor subsystem
+void st_init();
+
+// Block until all buffered steps are executed
+void st_synchronize();
+
+// Set current position in steps
+void st_set_position(const long &x, const long &y, const long &z, const long &e);
+
+// Get current position in steps
+long st_get_position(char axis);
+
+// The stepper subsystem goes to sleep when it runs out of things to execute. Call this
+// to notify the subsystem that it is time to go to work.
+void st_wake_up();
+
+  
+void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered
+void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();
+
+
+
+extern block_t *current_block;  // A pointer to the block currently being traced
+
+
 #endif

