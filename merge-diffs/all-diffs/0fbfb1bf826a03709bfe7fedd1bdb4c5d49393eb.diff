commit 0fbfb1bf826a03709bfe7fedd1bdb4c5d49393eb (from 8340ca6e05bd9fce422331b99ab9ae35b4206f23)
Merge: 8340ca6 32a6451
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Thu Aug 28 16:27:52 2014 +0200

    Merge pull request #991 from bonm014/patch-1
    
    Leapfrog controller board support

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index d01186b..bebabc3 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -72,6 +72,7 @@
 // 301= Rambo
 // 21 = Elefu Ra Board (v3)
 // 88 = 5DPrint D8 Driver Board
+// 999 = Leapfrog
 
 #ifndef MOTHERBOARD
 #define MOTHERBOARD 7
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 1fb2c0e..9351d06 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -95,6 +95,76 @@
 #endif /* 88 */
 
 /****************************************************************************************
+* Leapfrog Driver board
+* 
+****************************************************************************************/
+#if MOTHERBOARD == 999  // Leapfrog board
+#define KNOWN_BOARD 1
+
+#ifndef __AVR_ATmega1280__
+ #ifndef __AVR_ATmega2560__
+ #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu.
+ #endif
+#endif
+
+#define X_STEP_PIN         28
+#define X_DIR_PIN          63
+#define X_ENABLE_PIN       29
+#define X_MIN_PIN          47
+#define X_MAX_PIN          -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.
+
+#define Y_STEP_PIN         14 // A6
+#define Y_DIR_PIN          15 // A0
+#define Y_ENABLE_PIN       39
+#define Y_MIN_PIN          48
+#define Y_MAX_PIN          -1   //15
+
+#define Z_STEP_PIN         31 // A2
+#define Z_DIR_PIN          32 // A6
+#define Z_ENABLE_PIN       30 // A1
+#define Z_MIN_PIN          49
+#define Z_MAX_PIN          -1
+
+#define E0_STEP_PIN         34  //34
+#define E0_DIR_PIN          35 //35
+#define E0_ENABLE_PIN       33 //33
+
+#define E1_STEP_PIN         37 //37
+#define E1_DIR_PIN          40 //40
+#define E1_ENABLE_PIN       36 //36
+
+#define Y2_STEP_PIN         37
+#define Y2_DIR_PIN          40
+#define Y2_ENABLE_PIN       36
+
+#define Z2_STEP_PIN         37
+#define Z2_DIR_PIN          40
+#define Z2_ENABLE_PIN       36
+
+#define SDPOWER            -1
+#define SDSS               11
+#define SDCARDDETECT       -1 // 10 optional also used as mode pin
+#define LED_PIN            13
+#define FAN_PIN            7
+#define PS_ON_PIN          -1
+#define KILL_PIN           -1
+#define SOL1_PIN   16
+#define SOL2_PIN    17
+
+#define HEATER_0_PIN       9
+#define HEATER_1_PIN       8 // 12
+#define HEATER_2_PIN       11 //-1 // 13
+#define TEMP_0_PIN         13 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_1_PIN         15 // 1
+#define TEMP_2_PIN         -1 // 2
+#define HEATER_BED_PIN     10 // 14/15
+#define TEMP_BED_PIN       14 // 1,2 or I2C
+/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
+
+
+#endif
+
+/****************************************************************************************
 *
 *
 ****************************************************************************************/

commit 0fbfb1bf826a03709bfe7fedd1bdb4c5d49393eb (from 32a6451ad8b9fe5c7d7f963b9883ef0584843c39)
Merge: 8340ca6 32a6451
Author: Erik van der Zalm <erik@vdzalm.eu>
Date:   Thu Aug 28 16:27:52 2014 +0200

    Merge pull request #991 from bonm014/patch-1
    
    Leapfrog controller board support

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 7f228b5..bebabc3 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -377,6 +377,7 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
 //============================= Bed Auto Leveling ===========================
 
 //#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)
+#define Z_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.
 
 #ifdef ENABLE_AUTO_BED_LEVELING
 
@@ -437,6 +438,8 @@ const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of
   #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.
   #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points
 
+  //#define Z_PROBE_SLED // turn on if you have a z-probe mounted on a sled like those designed by Charles Bell
+  //#define SLED_DOCKING_OFFSET 5 // the extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
   //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk
   //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 245f65c..6398f41 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -410,9 +410,11 @@ const unsigned int dropsegments=5; //everything with less than this number of st
 #ifdef FWRETRACT
   #define MIN_RETRACT 0.1                //minimum extruded mm to accept a automatic gcode retraction attempt
   #define RETRACT_LENGTH 3               //default retract length (positive mm)
+  #define RETRACT_LENGTH_SWAP 13         //default swap retract length (positive mm), for extruder change
   #define RETRACT_FEEDRATE 45            //default feedrate for retracting (mm/s)
   #define RETRACT_ZLIFT 0                //default retract Z-lift
   #define RETRACT_RECOVER_LENGTH 0       //default additional recover length (mm, added to retract length when recovering)
+  #define RETRACT_RECOVER_LENGTH_SWAP 0  //default additional swap recover length (mm, added to retract length when recovering from extruder change)
   #define RETRACT_RECOVER_FEEDRATE 8     //default feedrate for recovering from retraction (mm/s)
 #endif
 
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index e728209..062b6d4 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -231,9 +231,9 @@ extern unsigned char fanSpeedSoftPwm;
 
 #ifdef FWRETRACT
 extern bool autoretract_enabled;
-extern bool retracted;
-extern float retract_length, retract_feedrate, retract_zlift;
-extern float retract_recover_length, retract_recover_feedrate;
+extern bool retracted[EXTRUDERS];
+extern float retract_length, retract_length_swap, retract_feedrate, retract_zlift;
+extern float retract_recover_length, retract_recover_length_swap, retract_recover_feedrate;
 #endif
 
 extern unsigned long starttime;
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 0367eb4..24f2011 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -78,6 +78,8 @@
 // G28 - Home all Axis
 // G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
 // G30 - Single Z Probe, probes bed at current XY location.
+// G31 - Dock sled (Z_PROBE_SLED only)
+// G32 - Undock sled (Z_PROBE_SLED only)
 // G90 - Use Absolute Coordinates
 // G91 - Use Relative Coordinates
 // G92 - Set current position to coordinates given
@@ -243,11 +245,29 @@ int EtoPPressure=0;
 
 #ifdef FWRETRACT
   bool autoretract_enabled=false;
-  bool retracted=false;
+  bool retracted[EXTRUDERS]={false
+    #if EXTRUDERS > 1
+    , false
+     #if EXTRUDERS > 2
+      , false
+     #endif
+  #endif
+  };
+  bool retracted_swap[EXTRUDERS]={false
+    #if EXTRUDERS > 1
+    , false
+     #if EXTRUDERS > 2
+      , false
+     #endif
+  #endif
+  };
+
   float retract_length = RETRACT_LENGTH;
+  float retract_length_swap = RETRACT_LENGTH_SWAP;
   float retract_feedrate = RETRACT_FEEDRATE;
   float retract_zlift = RETRACT_ZLIFT;
   float retract_recover_length = RETRACT_RECOVER_LENGTH;
+  float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
   float retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;
 #endif
 
@@ -530,6 +550,10 @@ void setup()
   #ifdef DIGIPOT_I2C
     digipot_i2c_init();
   #endif
+#ifdef Z_PROBE_SLED
+  pinMode(SERVO0_PIN, OUTPUT);
+  digitalWrite(SERVO0_PIN, LOW); // turn it off
+#endif // Z_PROBE_SLED
 }
 
 
@@ -876,7 +900,7 @@ static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
     current_position[Y_AXIS] = corrected_position.y;
     current_position[Z_AXIS] = corrected_position.z;
 
-    // but the bed at 0 so we don't go below it.
+    // put the bed at 0 so we don't go below it.
     current_position[Z_AXIS] = zprobe_zoffset; // in the lsq we reach here after raising the extruder due to the loop structure
 
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
@@ -1017,10 +1041,14 @@ static float probe_pt(float x, float y, float z_before) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_before);
   do_blocking_move_to(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
 
+#ifndef Z_PROBE_SLED
   engage_z_probe();   // Engage Z Servo endstop if available
+#endif // Z_PROBE_SLED
   run_z_probe();
   float measured_z = current_position[Z_AXIS];
+#ifndef Z_PROBE_SLED
   retract_z_probe();
+#endif // Z_PROBE_SLED
 
   SERIAL_PROTOCOLPGM(MSG_BED);
   SERIAL_PROTOCOLPGM(" x: ");
@@ -1053,6 +1081,7 @@ static void homeaxis(int axis) {
     plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 
 
+#ifndef Z_PROBE_SLED
     // Engage Servo endstop if enabled
     #ifdef SERVO_ENDSTOPS
       #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
@@ -1065,7 +1094,7 @@ static void homeaxis(int axis) {
         servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2]);
       }
     #endif
-
+#endif // Z_PROBE_SLED
     destination[axis] = 1.5 * max_length(axis) * axis_home_dir;
     feedrate = homing_feedrate[axis];
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
@@ -1107,7 +1136,7 @@ static void homeaxis(int axis) {
       }
     #endif
 #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
-    if (axis==Z_AXIS) retract_z_probe();
+//    if (axis==Z_AXIS) retract_z_probe();
 #endif
 
   }
@@ -1119,41 +1148,95 @@ void refresh_cmd_timeout(void)
 }
 
 #ifdef FWRETRACT
-  void retract(bool retracting) {
-    if(retracting && !retracted) {
+  void retract(bool retracting, bool swapretract = false) {
+    if(retracting && !retracted[active_extruder]) {
       destination[X_AXIS]=current_position[X_AXIS];
       destination[Y_AXIS]=current_position[Y_AXIS];
       destination[Z_AXIS]=current_position[Z_AXIS];
       destination[E_AXIS]=current_position[E_AXIS];
-      current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
+      if (swapretract) {
+        current_position[E_AXIS]+=retract_length_swap/volumetric_multiplier[active_extruder];
+      } else {
+        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
+      }
       plan_set_e_position(current_position[E_AXIS]);
       float oldFeedrate = feedrate;
       feedrate=retract_feedrate*60;
-      retracted=true;
+      retracted[active_extruder]=true;
       prepare_move();
       current_position[Z_AXIS]-=retract_zlift;
+#ifdef DELTA
+      calculate_delta(current_position); // change cartesian kinematic to  delta kinematic;
+      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+#else
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#endif
       prepare_move();
       feedrate = oldFeedrate;
-    } else if(!retracting && retracted) {
+    } else if(!retracting && retracted[active_extruder]) {
       destination[X_AXIS]=current_position[X_AXIS];
       destination[Y_AXIS]=current_position[Y_AXIS];
       destination[Z_AXIS]=current_position[Z_AXIS];
       destination[E_AXIS]=current_position[E_AXIS];
       current_position[Z_AXIS]+=retract_zlift;
+#ifdef DELTA
+      calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
+      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
+#else
       plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#endif
       //prepare_move();
-      current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
+      if (swapretract) {
+        current_position[E_AXIS]-=(retract_length_swap+retract_recover_length_swap)/volumetric_multiplier[active_extruder]; 
+      } else {
+        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
+      }
       plan_set_e_position(current_position[E_AXIS]);
       float oldFeedrate = feedrate;
       feedrate=retract_recover_feedrate*60;
-      retracted=false;
+      retracted[active_extruder]=false;
       prepare_move();
       feedrate = oldFeedrate;
     }
   } //retract
 #endif //FWRETRACT
 
+#ifdef ENABLE_AUTO_BED_LEVELING
+//
+// Method to dock/undock a sled designed by Charles Bell.
+//
+// dock[in]     If true, move to MAX_X and engage the electromagnet
+// offset[in]   The additional distance to move to adjust docking location
+//
+static void dock_sled(bool dock, int offset=0) {
+ int z_loc;
+ 
+ if (!((axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS]))) {
+   LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
+   SERIAL_ECHO_START;
+   SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
+   return;
+ }
+
+ if (dock) {
+   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
+                       current_position[Y_AXIS],
+                       current_position[Z_AXIS]);
+   // turn off magnet
+   digitalWrite(SERVO0_PIN, LOW);
+ } else {
+   if (current_position[Z_AXIS] < (Z_RAISE_BEFORE_PROBING + 5))
+     z_loc = Z_RAISE_BEFORE_PROBING;
+   else
+     z_loc = current_position[Z_AXIS];
+   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
+                       Y_PROBE_OFFSET_FROM_EXTRUDER, z_loc);
+   // turn on magnet
+   digitalWrite(SERVO0_PIN, HIGH);
+ }
+}
+#endif
+
 void process_commands()
 {
   unsigned long codenum; //throw away variable
@@ -1217,10 +1300,19 @@ void process_commands()
       break;
       #ifdef FWRETRACT
       case 10: // G10 retract
+       #if EXTRUDERS > 1
+        retracted_swap[active_extruder]=(code_seen('S') && code_value_long() == 1); // checks for swap retract argument
+        retract(true,retracted_swap[active_extruder]);
+       #else
         retract(true);
+       #endif
       break;
       case 11: // G11 retract_recover
+       #if EXTRUDERS > 1
+        retract(false,retracted_swap[active_extruder]);
+       #else
         retract(false);
+       #endif 
       break;
       #endif //FWRETRACT
     case 28: //G28 Home all Axis one at a time
@@ -1455,6 +1547,9 @@ void process_commands()
                 break; // abort G29, since we don't know where we are
             }
 
+#ifdef Z_PROBE_SLED
+            dock_sled(false);
+#endif // Z_PROBE_SLED
             st_synchronize();
             // make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly
             //vector_3 corrected_position = plan_get_position_mm();
@@ -1580,13 +1675,15 @@ void process_commands()
             apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);         //Apply the correction sending the probe offset
             current_position[Z_AXIS] = z_tmp - real_z + current_position[Z_AXIS];   //The difference is added to current position and sent to planner.
             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+#ifdef Z_PROBE_SLED
+            dock_sled(true, -SLED_DOCKING_OFFSET); // correct for over travel.
+#endif // Z_PROBE_SLED
         }
         break;
-
+#ifndef Z_PROBE_SLED
     case 30: // G30 Single Z Probe
         {
             engage_z_probe(); // Engage Z Servo endstop if available
-
             st_synchronize();
             // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
             setup_for_endstop_move();
@@ -1604,10 +1701,17 @@ void process_commands()
             SERIAL_PROTOCOLPGM("\n");
 
             clean_up_after_endstop_move();
-
             retract_z_probe(); // Retract Z Servo endstop if available
         }
         break;
+#else
+    case 31: // dock the sled
+        dock_sled(true);
+        break;
+    case 32: // undock the sled
+        dock_sled(false);
+        break;
+#endif // Z_PROBE_SLED
 #endif // ENABLE_AUTO_BED_LEVELING
     case 90: // G90
       relative_mode = false;
@@ -1695,7 +1799,7 @@ void process_commands()
     case 23: //M23 - Select file
       starpos = (strchr(strchr_pointer + 4,'*'));
       if(starpos!=NULL)
-        *(starpos-1)='\0';
+        *(starpos)='\0';
       card.openFile(strchr_pointer + 4,true);
       break;
     case 24: //M24 - Start SD print
@@ -1718,7 +1822,7 @@ void process_commands()
       if(starpos != NULL){
         char* npos = strchr(cmdbuffer[bufindr], 'N');
         strchr_pointer = strchr(npos,' ') + 1;
-        *(starpos-1) = '\0';
+        *(starpos) = '\0';
       }
       card.openFile(strchr_pointer+4,false);
       break;
@@ -1733,7 +1837,7 @@ void process_commands()
         if(starpos != NULL){
           char* npos = strchr(cmdbuffer[bufindr], 'N');
           strchr_pointer = strchr(npos,' ') + 1;
-          *(starpos-1) = '\0';
+          *(starpos) = '\0';
         }
         card.removeFile(strchr_pointer + 4);
       }
@@ -1755,7 +1859,7 @@ void process_commands()
         namestartpos++; //to skip the '!'
 
       if(starpos!=NULL)
-        *(starpos-1)='\0';
+        *(starpos)='\0';
 
       bool call_procedure=(code_seen('P'));
 
@@ -1778,7 +1882,7 @@ void process_commands()
       if(starpos != NULL){
         char* npos = strchr(cmdbuffer[bufindr], 'N');
         strchr_pointer = strchr(npos,' ') + 1;
-        *(starpos-1) = '\0';
+        *(starpos) = '\0';
       }
       card.openLogFile(strchr_pointer+5);
       break;
@@ -1827,6 +1931,280 @@ void process_commands()
         }
       }
      break;
+
+// M48 Z-Probe repeatability measurement function.
+//
+// Usage:   M48 <n #_samples> <X X_position_for_samples> <Y Y_position_for_samples> <V Verbose_Level> <Engage_probe_for_each_reading> <L legs_of_movement_prior_to_doing_probe>
+//	
+// This function assumes the bed has been homed.  Specificaly, that a G28 command
+// as been issued prior to invoking the M48 Z-Probe repeatability measurement function.
+// Any information generated by a prior G29 Bed leveling command will be lost and need to be
+// regenerated.
+//
+// The number of samples will default to 10 if not specified.  You can use upper or lower case
+// letters for any of the options EXCEPT n.  n must be in lower case because Marlin uses a capital
+// N for its communication protocol and will get horribly confused if you send it a capital N.
+//
+
+#ifdef ENABLE_AUTO_BED_LEVELING
+#ifdef Z_PROBE_REPEATABILITY_TEST 
+
+    case 48: // M48 Z-Probe repeatability
+        {
+            #if Z_MIN_PIN == -1
+            #error "You must have a Z_MIN endstop in order to enable calculation of Z-Probe repeatability."
+            #endif
+
+	double sum=0.0; 
+	double mean=0.0; 
+	double sigma=0.0;
+	double sample_set[50];
+	int verbose_level=1, n=0, j, n_samples = 10, n_legs=0, engage_probe_for_each_reading=0 ;
+	double X_current, Y_current, Z_current;
+	double X_probe_location, Y_probe_location, Z_start_location, ext_position;
+	
+	if (code_seen('V') || code_seen('v')) {
+        	verbose_level = code_value();
+		if (verbose_level<0 || verbose_level>4 ) {
+			SERIAL_PROTOCOLPGM("?Verbose Level not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (verbose_level > 0)   {
+		SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test.   Version 2.00\n");
+		SERIAL_PROTOCOLPGM("Full support at: http://3dprintboard.com/forum.php\n");
+	}
+
+	if (code_seen('n')) {
+        	n_samples = code_value();
+		if (n_samples<4 || n_samples>50 ) {
+			SERIAL_PROTOCOLPGM("?Specified sample size not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	X_current = X_probe_location = st_get_position_mm(X_AXIS);
+	Y_current = Y_probe_location = st_get_position_mm(Y_AXIS);
+	Z_current = st_get_position_mm(Z_AXIS);
+	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
+	ext_position	 = st_get_position_mm(E_AXIS);
+
+	if (code_seen('E') || code_seen('e') ) 
+		engage_probe_for_each_reading++;
+
+	if (code_seen('X') || code_seen('x') ) {
+        	X_probe_location = code_value() -  X_PROBE_OFFSET_FROM_EXTRUDER;
+		if (X_probe_location<X_MIN_POS || X_probe_location>X_MAX_POS ) {
+			SERIAL_PROTOCOLPGM("?Specified X position out of range.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (code_seen('Y') || code_seen('y') ) {
+        	Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;
+		if (Y_probe_location<Y_MIN_POS || Y_probe_location>Y_MAX_POS ) {
+			SERIAL_PROTOCOLPGM("?Specified Y position out of range.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+	if (code_seen('L') || code_seen('l') ) {
+        	n_legs = code_value();
+		if ( n_legs==1 ) 
+			n_legs = 2;
+		if ( n_legs<0 || n_legs>15 ) {
+			SERIAL_PROTOCOLPGM("?Specified number of legs in movement not plausable.\n");
+			goto Sigma_Exit;
+		}
+	}
+
+//
+// Do all the preliminary setup work.   First raise the probe.
+//
+
+        st_synchronize();
+        plan_bed_level_matrix.set_to_identity();
+	plan_buffer_line( X_current, Y_current, Z_start_location,
+			ext_position,
+    			homing_feedrate[Z_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+
+//
+// Now get everything to the specified probe point So we can safely do a probe to
+// get us close to the bed.  If the Z-Axis is far from the bed, we don't want to 
+// use that as a starting point for each probe.
+//
+	if (verbose_level > 2) 
+		SERIAL_PROTOCOL("Positioning probe for the test.\n");
+
+	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
+			ext_position,
+    			homing_feedrate[X_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+
+	current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);
+	current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+	current_position[E_AXIS] = ext_position = st_get_position_mm(E_AXIS);
+
+// 
+// OK, do the inital probe to get us close to the bed.
+// Then retrace the right amount and use that in subsequent probes
+//
+
+        engage_z_probe();	
+
+	setup_for_endstop_move();
+	run_z_probe();
+
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
+
+	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
+			ext_position,
+    			homing_feedrate[X_AXIS]/60,
+			active_extruder);
+        st_synchronize();
+	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
+
+	if (engage_probe_for_each_reading)
+        	retract_z_probe();
+
+        for( n=0; n<n_samples; n++) {
+
+		do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Make sure we are at the probe location
+
+		if ( n_legs)  {
+		double radius=0.0, theta=0.0, x_sweep, y_sweep;
+		int rotational_direction, l;
+
+			rotational_direction = (unsigned long) millis() & 0x0001;			// clockwise or counter clockwise
+			radius = (unsigned long) millis() % (long) (X_MAX_LENGTH/4); 			// limit how far out to go 
+			theta = (float) ((unsigned long) millis() % (long) 360) / (360./(2*3.1415926));	// turn into radians
+
+//SERIAL_ECHOPAIR("starting radius: ",radius);
+//SERIAL_ECHOPAIR("   theta: ",theta);
+//SERIAL_ECHOPAIR("   direction: ",rotational_direction);
+//SERIAL_PROTOCOLLNPGM("");
+
+			for( l=0; l<n_legs-1; l++) {
+				if (rotational_direction==1)
+					theta += (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians
+				else
+					theta -= (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians
+
+				radius += (float) ( ((long) ((unsigned long) millis() % (long) 10)) - 5);
+				if ( radius<0.0 )
+					radius = -radius;
+
+				X_current = X_probe_location + cos(theta) * radius;
+				Y_current = Y_probe_location + sin(theta) * radius;
+
+				if ( X_current<X_MIN_POS)		// Make sure our X & Y are sane
+					 X_current = X_MIN_POS;
+				if ( X_current>X_MAX_POS)
+					 X_current = X_MAX_POS;
+
+				if ( Y_current<Y_MIN_POS)		// Make sure our X & Y are sane
+					 Y_current = Y_MIN_POS;
+				if ( Y_current>Y_MAX_POS)
+					 Y_current = Y_MAX_POS;
+
+				if (verbose_level>3 ) {
+					SERIAL_ECHOPAIR("x: ", X_current);
+					SERIAL_ECHOPAIR("y: ", Y_current);
+					SERIAL_PROTOCOLLNPGM("");
+				}
+
+				do_blocking_move_to( X_current, Y_current, Z_current );
+			}
+			do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Go back to the probe location
+		}
+
+		if (engage_probe_for_each_reading)  {
+        		engage_z_probe();	
+          		delay(1000);
+		}
+
+		setup_for_endstop_move();
+                run_z_probe();
+
+		sample_set[n] = current_position[Z_AXIS];
+
+//
+// Get the current mean for the data points we have so far
+//
+		sum=0.0; 
+		for( j=0; j<=n; j++) {
+			sum = sum + sample_set[j];
+		}
+		mean = sum / (double (n+1));
+//
+// Now, use that mean to calculate the standard deviation for the
+// data points we have so far
+//
+
+		sum=0.0; 
+		for( j=0; j<=n; j++) {
+			sum = sum + (sample_set[j]-mean) * (sample_set[j]-mean);
+		}
+		sigma = sqrt( sum / (double (n+1)) );
+
+		if (verbose_level > 1) {
+			SERIAL_PROTOCOL(n+1);
+			SERIAL_PROTOCOL(" of ");
+			SERIAL_PROTOCOL(n_samples);
+			SERIAL_PROTOCOLPGM("   z: ");
+			SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
+		}
+
+		if (verbose_level > 2) {
+			SERIAL_PROTOCOL(" mean: ");
+			SERIAL_PROTOCOL_F(mean,6);
+
+			SERIAL_PROTOCOL("   sigma: ");
+			SERIAL_PROTOCOL_F(sigma,6);
+		}
+
+		if (verbose_level > 0) 
+			SERIAL_PROTOCOLPGM("\n");
+
+		plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location, 
+				  current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);
+        	st_synchronize();
+
+		if (engage_probe_for_each_reading)  {
+        		retract_z_probe();	
+          		delay(1000);
+		}
+	}
+
+        retract_z_probe();
+	delay(1000);
+
+        clean_up_after_endstop_move();
+
+//      enable_endstops(true);
+
+	if (verbose_level > 0) {
+		SERIAL_PROTOCOLPGM("Mean: ");
+		SERIAL_PROTOCOL_F(mean, 6);
+		SERIAL_PROTOCOLPGM("\n");
+	}
+
+SERIAL_PROTOCOLPGM("Standard Deviation: ");
+SERIAL_PROTOCOL_F(sigma, 6);
+SERIAL_PROTOCOLPGM("\n\n");
+
+Sigma_Exit:
+        break;
+	}
+#endif		// Z_PROBE_REPEATABILITY_TEST 
+#endif		// ENABLE_AUTO_BED_LEVELING
+
     case 104: // M104
       if(setTargetedHotend(104)){
         break;
@@ -1947,7 +2325,7 @@ void process_commands()
 
       /* See if we are heating up or cooling down */
       target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling
-      
+
       cancel_heatup = false;
 
       #ifdef TEMP_RESIDENCY_TIME
@@ -2198,7 +2576,7 @@ void process_commands()
     case 117: // M117 display message
       starpos = (strchr(strchr_pointer + 5,'*'));
       if(starpos!=NULL)
-        *(starpos-1)='\0';
+        *(starpos)='\0';
       lcd_setstatus(strchr_pointer + 5);
       break;
     case 114: // M114
@@ -2396,8 +2774,28 @@ void process_commands()
         int t= code_value() ;
         switch(t)
         {
-          case 0: autoretract_enabled=false;retracted=false;break;
-          case 1: autoretract_enabled=true;retracted=false;break;
+          case 0: 
+          {
+            autoretract_enabled=false;
+            retracted[0]=false;
+            #if EXTRUDERS > 1
+              retracted[1]=false;
+            #endif
+            #if EXTRUDERS > 2
+              retracted[2]=false;
+            #endif
+          }break;
+          case 1: 
+          {
+            autoretract_enabled=true;
+            retracted[0]=false;
+            #if EXTRUDERS > 1
+              retracted[1]=false;
+            #endif
+            #if EXTRUDERS > 2
+              retracted[2]=false;
+            #endif
+          }break;
           default:
             SERIAL_ECHO_START;
             SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
@@ -2703,7 +3101,7 @@ void process_commands()
       st_synchronize();
     }
     break;
-#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS)
+#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS) && not defined(Z_PROBE_SLED)
     case 401:
     {
         engage_z_probe();    // Engage Z Servo endstop if available
@@ -3461,10 +3859,9 @@ void manage_inactivity()
   }
   
   #ifdef CHDK //Check if pin should be set to LOW after M240 set it to HIGH
-    if (chdkActive)
+    if (chdkActive && (millis() - chdkHigh > CHDK_DELAY))
     {
       chdkActive = false;
-      if (millis()-chdkHigh < CHDK_DELAY) return;
       WRITE(CHDK, LOW);
     }
   #endif
diff --git a/Marlin/language.h b/Marlin/language.h
index c032aca..8522018 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -171,9 +171,11 @@
 	#define MSG_KILLED "KILLED. "
 	#define MSG_STOPPED "STOPPED. "
 	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Swap Re.mm"
 	#define MSG_CONTROL_RETRACTF "Retract  V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "S UnRet+mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  V"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Change filament"
@@ -371,9 +373,11 @@
 	#define MSG_STOPPED "Zatrzymany. "
 	#define MSG_STEPPER_RELEASED "Zwolniony."
 	#define MSG_CONTROL_RETRACT  "Wycofaj mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Z Wycof. mm"
 	#define MSG_CONTROL_RETRACTF "Wycofaj  V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"
 	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Z Cof. wyc. +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  V"
 	#define MSG_AUTORETRACT "Auto. wycofanie"
 	#define MSG_FILAMENTCHANGE "Zmien filament"
@@ -572,9 +576,11 @@
 	#define MSG_STOPPED "STOPPE."
 	#define MSG_STEPPER_RELEASED "RELACHE."
 	#define MSG_CONTROL_RETRACT "Retraction mm"
+	#define MSG_CONTROL_RETRACT_SWAP "Ech. Retr. mm"
 	#define MSG_CONTROL_RETRACTF "Retraction V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Ech. UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet V"
 	#define MSG_AUTORETRACT "Retract. Auto."
 	#define MSG_FILAMENTCHANGE "Changer filament"
@@ -774,9 +780,11 @@
 	#define MSG_STOPPED          "GESTOPPT"
 	#define MSG_STEPPER_RELEASED "Stepper frei"
 	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Wechs. Retract mm"
 	#define MSG_CONTROL_RETRACTF "Retract  V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Wechs. UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  V"
 	#define MSG_AUTORETRACT      "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Filament wechseln"
@@ -972,9 +980,11 @@
 	#define MSG_KILLED "PARADA DE EMERG."
 	#define MSG_STOPPED "PARADA"
 	#define MSG_CONTROL_RETRACT  "Retraer mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Interc. Retraer mm"
 	#define MSG_CONTROL_RETRACTF "Retraer  V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Levantar mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Interc. DesRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet V"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Cambiar filamento"
@@ -1179,9 +1189,11 @@
 	#define MSG_KILLED							"УБИТО."
 	#define MSG_STOPPED							"ОСТАНОВЛЕНО."
 	#define MSG_CONTROL_RETRACT					"Откат mm:"
+	#define MSG_CONTROL_RETRACT_SWAP				"своп Откат mm:"
 	#define MSG_CONTROL_RETRACTF				"Откат  V:"
 	#define MSG_CONTROL_RETRACT_ZLIFT			"Прыжок mm:"
 	#define MSG_CONTROL_RETRACT_RECOVER			"Возврат +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP		"своп Возврат +mm:"
 	#define MSG_CONTROL_RETRACT_RECOVERF		"Возврат  V:"
 	#define MSG_AUTORETRACT						"АвтоОткат:"
 	#define MSG_FILAMENTCHANGE 					"Change filament"
@@ -1376,9 +1388,11 @@
 	#define MSG_KILLED               "UCCISO. "
 	#define MSG_STOPPED              "ARRESTATO. "
 	#define MSG_CONTROL_RETRACT      "Ritrai mm"
+	#define MSG_CONTROL_RETRACT_SWAP "Scamb. Ritrai mm"
 	#define MSG_CONTROL_RETRACTF     "Ritrai  V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Scamb. UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  V"
 	#define MSG_AUTORETRACT          "AutoArretramento"
 	#define MSG_FILAMENTCHANGE       "Cambia filamento"
@@ -1581,9 +1595,11 @@
 	#define MSG_STOPPED "PARADA. "
 	#define MSG_STEPPER_RELEASED "Lancado."
 	#define MSG_CONTROL_RETRACT  " Retrair mm:"
+	#define MSG_CONTROL_RETRACT_SWAP  "Troca Retrair mm:"
 	#define MSG_CONTROL_RETRACTF " Retrair  V:"
 	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"
 	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Troca DesRet +mm:"
 	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  V:"
 	#define MSG_AUTORETRACT " AutoRetr.:"
 	#define MSG_FILAMENTCHANGE "Change filament"
@@ -1781,9 +1797,11 @@
 	#define MSG_KILLED "KILLED. "
 	#define MSG_STOPPED "STOPPED. "
 	#define MSG_CONTROL_RETRACT  "Veda mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Va. Veda mm"
 	#define MSG_CONTROL_RETRACTF "Veda V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Va. UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  V"
 	#define MSG_AUTORETRACT "AutoVeto."
 	#define MSG_FILAMENTCHANGE "Change filament"
@@ -1979,9 +1997,11 @@
 	#define MSG_KILLED "ATURADA D'EMERCH."
 	#define MSG_STOPPED "ATURADA."
 	#define MSG_CONTROL_RETRACT  "Retraer mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Swap Retraer mm"
 	#define MSG_CONTROL_RETRACTF "Retraer  F"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Devantar mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Swap DesRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Cambear"
@@ -2185,9 +2205,11 @@
 	#define MSG_KILLED "AFGEBROKEN. "
 	#define MSG_STOPPED "GESTOPT. "
 	#define MSG_CONTROL_RETRACT  "Retract mm"
+	#define MSG_CONTROL_RETRACT_SWAP "Ruil Retract mm"
 	#define MSG_CONTROL_RETRACTF "Retract  F"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Ruil UnRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Verv. Filament"
@@ -2384,9 +2406,11 @@
 	#define MSG_KILLED "PARADA DE EMERG. "
 	#define MSG_STOPPED "ATURAT. "
 	#define MSG_CONTROL_RETRACT  "Retreure mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Swap Retreure mm"
 	#define MSG_CONTROL_RETRACTF "Retreure  F"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Aixecar mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Swap DesRet +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet  F"
 	#define MSG_AUTORETRACT "AutoRetr."
 	#define MSG_FILAMENTCHANGE "Canviar filament"
@@ -2582,9 +2606,11 @@
 	#define MSG_KILLED "LARRIALDI GELDIA"
 	#define MSG_STOPPED "GELDITUTA. "
 	#define MSG_CONTROL_RETRACT  "Atzera egin mm"
+	#define MSG_CONTROL_RETRACT_SWAP  "Swap Atzera egin mm"
 	#define MSG_CONTROL_RETRACTF "Atzera egin V"
 	#define MSG_CONTROL_RETRACT_ZLIFT "Igo mm"
 	#define MSG_CONTROL_RETRACT_RECOVER "Atzera egin +mm"
+	#define MSG_CONTROL_RETRACT_RECOVER_SWAP "Swap Atzera egin +mm"
 	#define MSG_CONTROL_RETRACT_RECOVERF "Atzera egin V"
 	#define MSG_AUTORETRACT "Atzera egin"
 	#define MSG_FILAMENTCHANGE "Aldatu filament."
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 3216380..9351d06 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -893,9 +893,9 @@
 
 #ifndef SDSUPPORT
 // these pins are defined in the SD library if building with SD support
-  #define MAX_SCK_PIN          52
-  #define MAX_MISO_PIN         50
-  #define MAX_MOSI_PIN         51
+  #define SCK_PIN          52
+  #define MISO_PIN         50
+  #define MOSI_PIN         51
   #define MAX6675_SS       53
 #else
   #define MAX6675_SS       49
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 5b20f86..4ae1871 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -96,6 +96,8 @@ float autotemp_factor=0.1;
 bool autotemp_enabled=false;
 #endif
 
+unsigned char g_uc_extruder_last_move[3] = {0,0,0};
+
 //===========================================================================
 //=================semi-private variables, used in inline  functions    =====
 //===========================================================================
@@ -662,11 +664,34 @@ block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-positi
   {
     if (DISABLE_INACTIVE_EXTRUDER) //enable only selected extruder
     {
+
+      if(g_uc_extruder_last_move[0] > 0) g_uc_extruder_last_move[0]--;
+      if(g_uc_extruder_last_move[1] > 0) g_uc_extruder_last_move[1]--;
+      if(g_uc_extruder_last_move[2] > 0) g_uc_extruder_last_move[2]--;
+      
       switch(extruder)
       {
-        case 0: enable_e0(); disable_e1(); disable_e2(); break;
-        case 1: disable_e0(); enable_e1(); disable_e2(); break;
-        case 2: disable_e0(); disable_e1(); enable_e2(); break;
+        case 0: 
+          enable_e0(); 
+          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
+          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
+        break;
+        case 1:
+          enable_e1(); 
+          g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
+          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
+        break;
+        case 2:
+          enable_e2(); 
+          g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE*2;
+          
+          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
+          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
+        break;        
       }
     }
     else //enable all
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index a10c255..6a5d58e 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -34,6 +34,9 @@
 #include "temperature.h"
 #include "watchdog.h"
 
+#include "Sd2PinMap.h"
+
+
 //===========================================================================
 //=============================public variables============================
 //===========================================================================
@@ -748,18 +751,22 @@ void tp_init()
 
   #ifdef HEATER_0_USES_MAX6675
     #ifndef SDSUPPORT
-      SET_OUTPUT(MAX_SCK_PIN);
-      WRITE(MAX_SCK_PIN,0);
+      SET_OUTPUT(SCK_PIN);
+      WRITE(SCK_PIN,0);
     
-      SET_OUTPUT(MAX_MOSI_PIN);
-      WRITE(MAX_MOSI_PIN,1);
+      SET_OUTPUT(MOSI_PIN);
+      WRITE(MOSI_PIN,1);
     
-      SET_INPUT(MAX_MISO_PIN);
-      WRITE(MAX_MISO_PIN,1);
+      SET_INPUT(MISO_PIN);
+      WRITE(MISO_PIN,1);
     #endif
+    /* Using pinMode and digitalWrite, as that was the only way I could get it to compile */
     
-    SET_OUTPUT(MAX6675_SS);
-    WRITE(MAX6675_SS,1);
+    //Have to toggle SD card CS pin to low first, to enable firmware to talk with SD card
+	pinMode(SS_PIN, OUTPUT);
+	digitalWrite(SS_PIN,0);  
+	pinMode(MAX6675_SS, OUTPUT);
+	digitalWrite(MAX6675_SS,1);
   #endif
 
   // Set analog inputs
@@ -1045,7 +1052,7 @@ void bed_max_temp_error(void) {
 
 #ifdef HEATER_0_USES_MAX6675
 #define MAX6675_HEAT_INTERVAL 250
-long max6675_previous_millis = -HEAT_INTERVAL;
+long max6675_previous_millis = MAX6675_HEAT_INTERVAL;
 int max6675_temp = 2000;
 
 int read_max6675()
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 18c8588..9797b0b 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -904,9 +904,15 @@ static void lcd_control_retract_menu()
     MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);
     MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+    #if EXTRUDERS > 1
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
+    #endif
     MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
     MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
+    #if EXTRUDERS > 1
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
+    #endif
     MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
     END_MENU();
 }
diff --git a/README.md b/README.md
index 17e920e..913b0c5 100644
--- a/README.md
+++ b/README.md
@@ -1,8 +1,8 @@
 ==========================
 Marlin 3D Printer Firmware
 ==========================
-[![Coverity Scan Build Status](https://scan.coverity.com/projects/2224/badge.svg)](https://scan.coverity.com/projects/2224)
-
+[![Coverity Scan Build Status](https://scan.coverity.com/projects/2224/badge.svg)](https://scan.coverity.com/projects/2224)
+
 Marlin has a GPL license because I believe in open development.
 Please do not use this code in products (3D printers, CNC etc) that are closed source or are crippled by a patent.
 
@@ -159,6 +159,8 @@ Implemented G Codes:
 *  G28 - Home all Axis
 *  G29 - Detailed Z-Probe, probes the bed at 3 points.  You must de at the home position for this to work correctly.
 *  G30 - Single Z Probe, probes bed at current XY location.
+*  G31 - Dock Z Probe sled (if enabled)
+*  G32 - Undock Z Probe sled (if enabled)
 *  G90 - Use Absolute Coordinates
 *  G91 - Use Relative Coordinates
 *  G92 - Set current position to cordinates given
@@ -207,15 +209,15 @@ M Codes
 *  M140 - Set bed target temp
 *  M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 *         Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
-*  M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
+*  M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
 *  M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 *  M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 *  M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 *  M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
 *  M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
 *  M206 - set additional homeing offset
-*  M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
-*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
+*  M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
+*  M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
 *  M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 *  M218 - set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 *  M220 S<factor in percent>- set speed factor override percentage
@@ -272,8 +274,46 @@ That's ok.  Enjoy Silky Smooth Printing.
 ===============================================
 Instructions for configuring Bed Auto Leveling
 ===============================================
+There are two options for this feature. You may choose to use a servo mounted on the X carriage or you may use a sled that mounts on the X axis and can be docked when not in use.
+See the section for each option below for specifics about installation and configuration. Also included are instructions that apply to both options.
+
+Note for RAMPS users:
+---------------------
+
+By default, RAMPS have no power on servo bus (if you happen to have a multimeter, check the voltage on servo power pins).
+In order to get the servo working, you need to supply 5V to 5V pin.. You can do it using your power supply (if it has a 5V output) or jumping the "Vcc" from Arduino to the 5V RAMPS rail.
+These 2 pins are located just between the Reset Button and the yellow fuses... There are marks in the board showing 5V and VCC.. just connect them..
+If jumping the arduino Vcc do RAMPS 5V rail, take care to not use a power hungry servo, otherwise you will cause a blackout in the arduino board ;-)
+
+Instructions for Both Options
+-----------------------------
+
 Uncomment the "ENABLE_AUTO_BED_LEVELING" define (commented by default)
 
+The following options define the probing positions. These are good starting values.
+I recommend to keep a better clearance from borders in the first run and then make the probes as close as possible to borders:
+
+* \#define LEFT_PROBE_BED_POSITION 30
+* \#define RIGHT_PROBE_BED_POSITION 140
+* \#define BACK_PROBE_BED_POSITION 140
+* \#define FRONT_PROBE_BED_POSITION 30
+
+A few more options:
+
+* \#define XY_TRAVEL_SPEED 6000
+
+X and Y axis travel speed between probes, in mm/min.
+Bear in mind that really fast moves may render step skipping. 6000 mm/min (100mm/s) is a good value.
+
+* \#define Z_RAISE_BEFORE_PROBING 10
+* \#define Z_RAISE_BETWEEN_PROBINGS 10
+
+The Z axis is lifted when traveling to the first probe point by Z_RAISE_BEFORE_PROBING value
+and then lifted when traveling from first to second and second to third point by Z_RAISE_BETWEEN_PROBINGS.
+All values are in mm as usual.
+
+Servo Option Notes
+------------------
 You will probably need a swivel Z-MIN endstop in the extruder. A rc servo do a great job.
 Check the system working here: http://www.youtube.com/watch?v=3IKMeOYz-1Q (Enable English subtitles)
 Teasing ;-) video: http://www.youtube.com/watch?v=x8eqSQNAyro
@@ -286,20 +326,10 @@ In order to get the servo working, you need to enable:
 
 * \#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 165,60} // X,Y,Z Axis Extend and Retract angles
 
-
 The first define tells firmware how many servos you have.
 The second tells what axis this servo will be attached to. In the example above, we have a servo in Z axis.
 The third one tells the angle in 2 situations: Probing (165º) and resting (60º). Check this with command M280 P0 S{angle} (example: M280 P0 S60 moves the servo to 60º)
 
-For RAMPS users:
-----------------
-
-By default, RAMPS have no power on servo bus (if you happen to have a multimeter, check the voltage on servo power pins).
-In order to get the servo working, you need to supply 5V to 5V pin.. You can do it using your power supply (if it has a 5V output) or jumping the "Vcc" from Arduino to the 5V RAMPS rail.
-These 2 pins are located just between the Reset Button and the yellow fuses... There are marks in the board showing 5V and VCC.. just connect them..
-If jumping the arduino Vcc do RAMPS 5V rail, take care to not use a power hungry servo, otherwise you will cause a blackout in the arduino board ;-)
-
-
 Next you need to define the Z endstop (probe) offset from hotend.
 My preferred method:
 
@@ -317,27 +347,42 @@ My preferred method:
 * \#define Z_PROBE_OFFSET_FROM_EXTRUDER -5.1
 
 
-The following options define the probing positions. These are good starting values.
-I recommend to keep a better clearance from borders in the first run and then make the probes as close as possible to borders:
+Sled Option Notes
+-----------------
+The sled option uses an electromagnet to attach and detach to/from the X carriage. See http://www.thingiverse.com/thing:396692 for more details on how to print and install this feature. It uses the same connections as the servo option.
 
-* \#define LEFT_PROBE_BED_POSITION 30
-* \#define RIGHT_PROBE_BED_POSITION 140
-* \#define BACK_PROBE_BED_POSITION 140
-* \#define FRONT_PROBE_BED_POSITION 30
+To use the sled option, you must define two additional things in Configuration.h:
 
-A few more options:
+* \#define Z_PROBE_SLED
+* \#define SLED_DOCKING_OFFSET 5
 
-* \#define XY_TRAVEL_SPEED 6000
+Uncomment the Z_PROBE_SLED to define to enable the sled (commented out by default).
 
-X and Y axis travel speed between probes, in mm/min.
-Bear in mind that really fast moves may render step skipping. 6000 mm/min (100mm/s) is a good value.
+Uncomment the SLED_DOCKING_OFFSET to set the extra distance the X axis must travel to dock the sled. This value can be found by moving the X axis to its maximum position then measure the distance to the right X end and subtract the width of the sled (23mm if you printed the sled from Thingiverse).
 
-* \#define Z_RAISE_BEFORE_PROBING 10
-* \#define Z_RAISE_BETWEEN_PROBINGS 10
+Next you need to define the Z endstop (probe) offset from hotend.
+My preferred method:
 
-The Z axis is lifted when traveling to the first probe point by Z_RAISE_BEFORE_PROBING value
-and then lifted when traveling from first to second and second to third point by Z_RAISE_BETWEEN_PROBINGS.
-All values are in mm as usual. 
+* a) Home the X and Y axes.
+* b) Move the X axis to about the center of the print bed. Make a mark on the print bed.
+* c) Move the Y axis to the maximum position. Make another mark.
+* d) Home the X axis and use a straight edge to make a line between the two points.
+* e) Repeat (b)-(d) reversing the X and Y. When you are done you will have two lines on the print bed. We will use these to measure the offset for the Z probe endstop.
+* f) Move the nozzle so that it is positioned on the center point of the two lines. You can use fine movement of 0.1mm to get it as close as possible. Note the position of X and Y.
+* g) Zero the Z axis with the G92 Z0 command.
+* h) Raise the Z axis about 20mmm.
+* i) Use the G32 command to retrieve the sled.
+* j) Now more the X and Y axis to the position recorded in (f).
+* k) Lower the Z axis in 0.1mm steps until you hear the "click" meaning the mechanical endstop was trigged. You can confirm with the M119 command. Note the position of the Z axis.
+* l) Make a mark on the print bed where the endstop lever has touched the print bed. Raise the Z-axis about 30mm to give yourself some room.
+* m) Now measure the distance from the center point to the endstop impact site along the X and Y axis using the lines drawn previously.
+* n) Fill in the values below. If the endstop mark is in front of the line running left-to-right, use positive values. If it is behind, use negative values. For the Z axis use the value from (k) and subtract 0.1mm.
+
+For example, suppose you measured the endstop position and it was 20mm to the right of the line running front-to-back, 10mm toward the front of the line running left-to-right, and the value from (k) was 2.85. The values for the defines would be:
+
+* \#define X_PROBE_OFFSET_FROM_EXTRUDER 20
+* \#define Y_PROBE_OFFSET_FROM_EXTRUDER 10
+* \#define Z_PROBE_OFFSET_FROM_EXTRUDER 2.75
 
 That's it.. enjoy never having to calibrate your Z endstop neither leveling your bed by hand anymore ;-)
 

