commit a9c334e8bce98110dbb81f2406568e8db50661e1 (from 842da54e68e33bcd1253584c560b68784ab6b1e9)
Merge: 842da54 1857e61
Author: Bo Herrmannsen <bo.herrmannsen@gmail.com>
Date:   Thu Dec 18 17:23:11 2014 +0100

    Merge pull request #1191 from thinkyhead/code_shrink
    
    Shrink and Optimize

diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 5aad019..673e9d5 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -91,10 +91,10 @@ void CardReader::lsDive(const char *prepend, SdFile parent, const char * const m
     {
       char pn0 = p.name[0];
       if (pn0 == DIR_NAME_FREE) break;
-      if (pn0 == DIR_NAME_DELETED || pn0 == '.'|| pn0 == '_') continue;
-      if (longFilename[0] != '\0' &&
-          (longFilename[0] == '.' || longFilename[0] == '_')) continue;
-      
+      if (pn0 == DIR_NAME_DELETED || pn0 == '.' || pn0 == '_') continue;
+      char lf0 = longFilename[0];
+      if (lf0 == '.' || lf0 == '_') continue;
+
       if (!DIR_IS_FILE_OR_SUBDIR(&p)) continue;
       filenameIsDir=DIR_IS_SUBDIR(&p);
 
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 0bfc8c1..ba7b986 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -39,7 +39,6 @@
 #include "ultralcd.h"
 #include "ultralcd_st7920_u8glib_rrd.h"
 
-
 /* Russian language not supported yet, needs custom font
 
 #if LANGUAGE_CHOICE == 6
@@ -57,20 +56,18 @@
 #define DOG_CHAR_WIDTH_LARGE	9
 #define DOG_CHAR_HEIGHT_LARGE	18
 
-
 #define START_ROW				0
 
-
 /* Custom characters defined in font font_6x10_marlin.c */
-#define LCD_STR_BEDTEMP     "\xFE"
 #define LCD_STR_DEGREE      "\xB0"
-#define LCD_STR_THERMOMETER "\xFF"
-#define LCD_STR_UPLEVEL     "\xFB"
 #define LCD_STR_REFRESH     "\xF8"
 #define LCD_STR_FOLDER      "\xF9"
-#define LCD_STR_FEEDRATE    "\xFD"
-#define LCD_STR_CLOCK       "\xFC"
 #define LCD_STR_ARROW_RIGHT "\xFA"
+#define LCD_STR_UPLEVEL     "\xFB"
+#define LCD_STR_CLOCK       "\xFC"
+#define LCD_STR_FEEDRATE    "\xFD"
+#define LCD_STR_BEDTEMP     "\xFE"
+#define LCD_STR_THERMOMETER "\xFF"
 
 #define FONT_STATUSMENU	u8g_font_6x9
 
@@ -167,6 +164,25 @@ static void lcd_printPGM(const char* str)
     }
 }
 
+static void _draw_heater_status(int x, int heater) {
+  bool isBed = heater < 0;
+  int y = 17 + (isBed ? 1 : 0);
+  u8g.setFont(FONT_STATUSMENU);
+  u8g.setPrintPos(x,6);
+  u8g.print(itostr3(int((heater >= 0 ? degTargetHotend(heater) : degTargetBed()) + 0.5)));
+  lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
+  u8g.setPrintPos(x,27);
+  u8g.print(itostr3(int(heater >= 0 ? degHotend(heater) : degBed()) + 0.5));
+  lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
+  if (!isHeatingHotend(0)) {
+    u8g.drawBox(x+7,y,2,2);
+  }
+  else {
+    u8g.setColorIndex(0); // white on black
+    u8g.drawBox(x+7,y,2,2);
+    u8g.setColorIndex(1); // black on white
+  }
+}
 
 static void lcd_implementation_status_screen()
 {
@@ -176,8 +192,7 @@ static void lcd_implementation_status_screen()
  u8g.setColorIndex(1);	// black on white
  
  // Symbols menu graphics, animated fan
- if ((blink % 2) &&  fanSpeed )	u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT,status_screen0_bmp);
-	else u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT,status_screen1_bmp);
+ u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT, (blink % 2) && fanSpeed ? status_screen0_bmp : status_screen1_bmp);
  
  #ifdef SDSUPPORT
  //SD Card Symbol
@@ -213,73 +228,17 @@ static void lcd_implementation_status_screen()
 		 }
  #endif
  
- // Extruder 1
- u8g.setFont(FONT_STATUSMENU);
- u8g.setPrintPos(6,6);
- u8g.print(itostr3(int(degTargetHotend(0) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- u8g.setPrintPos(6,27);
- u8g.print(itostr3(int(degHotend(0) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- if (!isHeatingHotend(0)) u8g.drawBox(13,17,2,2);
-	else
-		{
-		 u8g.setColorIndex(0);	// white on black
-		 u8g.drawBox(13,17,2,2);
-		 u8g.setColorIndex(1);	// black on white
-		}
- 
- // Extruder 2
- u8g.setFont(FONT_STATUSMENU);
- #if EXTRUDERS > 1
- u8g.setPrintPos(31,6);
- u8g.print(itostr3(int(degTargetHotend(1) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- u8g.setPrintPos(31,27);
- u8g.print(itostr3(int(degHotend(1) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- if (!isHeatingHotend(1)) u8g.drawBox(38,17,2,2);
-	else
-		{
-		 u8g.setColorIndex(0);	// white on black
-		 u8g.drawBox(38,17,2,2);
-		 u8g.setColorIndex(1);	// black on white
-		}
- #endif
- 
- // Extruder 3
- u8g.setFont(FONT_STATUSMENU);
- # if EXTRUDERS > 2
- u8g.setPrintPos(55,6);
- u8g.print(itostr3(int(degTargetHotend(2) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- u8g.setPrintPos(55,27);
- u8g.print(itostr3(int(degHotend(2) + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- if (!isHeatingHotend(2)) u8g.drawBox(62,17,2,2);
-	else
-		{
-		 u8g.setColorIndex(0);	// white on black
-		 u8g.drawBox(62,17,2,2);
-		 u8g.setColorIndex(1);	// black on white
-		}
- #endif
- 
- // Heatbed
- u8g.setFont(FONT_STATUSMENU);
- u8g.setPrintPos(81,6);
- u8g.print(itostr3(int(degTargetBed() + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- u8g.setPrintPos(81,27);
- u8g.print(itostr3(int(degBed() + 0.5)));
- lcd_printPGM(PSTR(LCD_STR_DEGREE " "));
- if (!isHeatingBed()) u8g.drawBox(88,18,2,2);
-	else
-		{
-		 u8g.setColorIndex(0);	// white on black
-		 u8g.drawBox(88,18,2,2);
-		 u8g.setColorIndex(1);	// black on white
-		}
+  // Extruders
+  _draw_heater_status(6, 0);
+  #if EXTRUDERS > 1
+    _draw_heater_status(31, 1);
+    #if EXTRUDERS > 2
+      _draw_heater_status(55, 2);
+    #endif
+  #endif
+
+  // Heatbed
+  _draw_heater_status(81, -1);
  
  // Fan
  u8g.setFont(FONT_STATUSMENU);
@@ -360,7 +319,7 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
 		   } else u8g.setColorIndex(1); // unmarked text is black on white
 		
 		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		if (pre_char != '>') u8g.print(pre_char); else u8g.print(' ');	// Row selector is obsolete
+		u8g.print(pre_char == '>' ? ' ' : pre_char);	// Row selector is obsolete
 
 
     while( (c = pgm_read_byte(pstr)) != '\0' )
@@ -378,57 +337,29 @@ static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, c
 		u8g.setColorIndex(1);		// restore settings to black on white
 }
 
-static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, char* data)
-{
-    static unsigned int fkt_cnt = 0;
-	char c;
-    uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);
-		
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(pre_char);
-	
-    while( (c = pgm_read_byte(pstr)) != '\0' )
-    {
-			u8g.print(c);
+static void _drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, char* data, bool pgm) {
+  char c;
+  uint8_t n = LCD_WIDTH - 1 - 2 - (pgm ? strlen_P(data) : strlen(data));
 		
-        pstr++;
-        n--;
-    }
-	
-		u8g.print(':');
-
-    while(n--){
-					u8g.print(' ');
-			  }
+  u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
+  u8g.print(pre_char);
 
-		u8g.print(data);
-}
-
-static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, const char* pstr, char pre_char, const char* data)
-{
-    char c;
-    uint8_t n= LCD_WIDTH - 1 - 2 - strlen_P(data);
+  while( (c = pgm_read_byte(pstr)) != '\0' ) {
+    u8g.print(c);
+    pstr++;
+    n--;
+  }
 
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(pre_char);
-	
-    while( (c = pgm_read_byte(pstr)) != '\0' )
-    {
-			u8g.print(c);
-		
-        pstr++;
-        n--;
-    }
+  u8g.print(':');
 
-		u8g.print(':');
-	
-    while(n--){
-					u8g.print(' ');
-			  }
+  while(n--) u8g.print(' ');
 
-		lcd_printPGM(data);
+  if (pgm) { lcd_printPGM(data); } else { u8g.print(data); }
 }
 
+#define lcd_implementation_drawmenu_setting_edit_generic(row, pstr, pre_char, data) _drawmenu_setting_edit_generic(row, pstr, pre_char, data, false)
+#define lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, pre_char, data) _drawmenu_setting_edit_generic(row, pstr, pre_char, data, true)
+
 #define lcd_implementation_drawmenu_setting_edit_int3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', itostr3(*(data)))
 #define lcd_implementation_drawmenu_setting_edit_int3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))
 #define lcd_implementation_drawmenu_setting_edit_float3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '>', ftostr3(*(data)))
@@ -474,118 +405,40 @@ void lcd_implementation_drawedit(const char* pstr, char* value)
 		u8g.print(value);
 }
 
-static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)
-{
-    char c;
-    uint8_t n = LCD_WIDTH - 1;
+static void _drawmenu_sd(uint8_t row, const char* pstr, const char* filename, char * const longFilename, bool isDir, bool isSelected) {
+  char c;
+  uint8_t n = LCD_WIDTH - 1;
 
-    if (longFilename[0] != '\0')
-    {
-        filename = longFilename;
-        longFilename[LCD_WIDTH-1] = '\0';
-    }
+  if (longFilename[0] != '\0') {
+    filename = longFilename;
+    longFilename[n] = '\0';
+  }
 
-		u8g.setColorIndex(1);		// black on white
-		u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);
-		u8g.setColorIndex(0);		// following text must be white on black
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(' ');	// Indent by 1 char
-	   
-    while((c = *filename) != '\0')
-    {
-		u8g.print(c);
-        filename++;
-        n--;
-    }
-    while(n--){
-					u8g.print(' ');
-			   }
-	u8g.setColorIndex(1);		// black on white
-}
-
-static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, const char* filename, char* longFilename)
-{
-    char c;
-    uint8_t n = LCD_WIDTH - 1;
+  if (isSelected) {
+    u8g.setColorIndex(1); // black on white
+    u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);
+    u8g.setColorIndex(0); // following text must be white on black
+  }
 
-    if (longFilename[0] != '\0')
-    {
-        filename = longFilename;
-        longFilename[LCD_WIDTH-1] = '\0';
-    }
+  u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
+  u8g.print(' ');	// Indent by 1 char
 
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(' ');
-		
-while((c = *filename) != '\0')
-    {
-			u8g.print(c);
-		
-        filename++;
-        n--;
-    }
-    while(n--){
-					u8g.print(' ');
-			   }
+  if (isDir) u8g.print(LCD_STR_FOLDER[0]);
 
-}
+  while((c = *filename) != '\0') {
+    u8g.print(c);
+    filename++;
+    n--;
+  }
+  while(n--) u8g.print(' ');
 
-static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)
-{
-    char c;
-    uint8_t n = LCD_WIDTH - 2;
-		
-    if (longFilename[0] != '\0')
-    {
-        filename = longFilename;
-        longFilename[LCD_WIDTH-2] = '\0';
-    }
-		u8g.setColorIndex(1);		// black on white
-		u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);
-		u8g.setColorIndex(0);		// following text must be white on black
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(' ');	// Indent by 1 char
-		u8g.print(LCD_STR_FOLDER[0]);		
-	   
-    while((c = *filename) != '\0')
-    {
-			u8g.print(c);
-		
-        filename++;
-        n--;
-    }
-    while(n--){
-					u8g.print(' ');
-			   }
-	u8g.setColorIndex(1);		// black on white
+  if (isSelected) u8g.setColorIndex(1); // black on white
 }
 
-static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pstr, const char* filename, char* longFilename)
-{
-    char c;
-    uint8_t n = LCD_WIDTH - 2;
-
-    if (longFilename[0] != '\0')
-    {
-        filename = longFilename;
-        longFilename[LCD_WIDTH-2] = '\0';
-    }
-
-		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);
-		u8g.print(' ');
-		u8g.print(LCD_STR_FOLDER[0]);
-
-    while((c = *filename) != '\0')
-    {
-			u8g.print(c);
-		
-        filename++;
-        n--;
-    }
-    while(n--){
-					u8g.print(' ');
-			   }
-}
+#define lcd_implementation_drawmenu_sdfile_selected(row, pstr, filename, longFilename) _drawmenu_sd(row, pstr, filename, longFilename, false, true)
+#define lcd_implementation_drawmenu_sdfile(row, pstr, filename, longFilename) _drawmenu_sd(row, pstr, filename, longFilename, false, false)
+#define lcd_implementation_drawmenu_sddirectory_selected(row, pstr, filename, longFilename) _drawmenu_sd(row, pstr, filename, longFilename, true, true)
+#define lcd_implementation_drawmenu_sddirectory(row, pstr, filename, longFilename) _drawmenu_sd(row, pstr, filename, longFilename, true, false)
 
 #define lcd_implementation_drawmenu_back_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
 #define lcd_implementation_drawmenu_back(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_UPLEVEL[0])
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 3fdbb6c..c0bcc8f 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -184,6 +184,14 @@ menuFunc_t callbackFunc;
 // place-holders for Ki and Kd edits
 float raw_Ki, raw_Kd;
 
+static void lcd_goto_menu(menuFunc_t menu, const uint32_t encoder=0, const bool feedback=true) {
+  if (currentMenu != menu) {
+    currentMenu = menu;
+    encoderPosition = encoder;
+    if (feedback) lcd_quick_feedback();
+  }
+}
+
 /* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependent */
 static void lcd_status_screen()
 {
@@ -218,9 +226,7 @@ static void lcd_status_screen()
 
     if (current_click)
     {
-        currentMenu = lcd_main_menu;
-        encoderPosition = 0;
-        lcd_quick_feedback();
+        lcd_goto_menu(lcd_main_menu);
         lcd_implementation_init(); // to maybe revive the LCD if static electricity killed it.
 #ifdef FILAMENT_LCD_DISPLAY
         message_millis=millis();  //get status message to show up for a while
@@ -255,7 +261,7 @@ static void lcd_status_screen()
 
     if (feedmultiply < 10)
         feedmultiply = 10;
-    if (feedmultiply > 999)
+    else if (feedmultiply > 999)
         feedmultiply = 999;
 #endif//ULTIPANEL
 }
@@ -263,10 +269,8 @@ static void lcd_status_screen()
 #ifdef ULTIPANEL
 static void lcd_return_to_status()
 {
-    encoderPosition = 0;
-    currentMenu = lcd_status_screen;
+    lcd_goto_menu(lcd_status_screen, 0, false);
 }
-
 static void lcd_sdcard_pause()
 {
     card.pauseSDPrint();
@@ -357,65 +361,20 @@ void lcd_set_home_offsets()
 
 
 #ifdef BABYSTEPPING
-static void lcd_babystep_x()
-{
-    if (encoderPosition != 0)
-    {
-        babystepsTodo[X_AXIS]+=(int)encoderPosition;
-        encoderPosition=0;
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_X),"");
-    }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_tune_menu;
-        encoderPosition = 0;
-    }
-}
 
-static void lcd_babystep_y()
-{
-    if (encoderPosition != 0)
-    {
-        babystepsTodo[Y_AXIS]+=(int)encoderPosition;
-        encoderPosition=0;
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_Y),"");
+  static void _lcd_babystep(int axis, const char *msg) {
+    if (encoderPosition != 0) {
+      babystepsTodo[axis] += (int)encoderPosition;
+      encoderPosition = 0;
+      lcdDrawUpdate = 1;
     }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_tune_menu;
-        encoderPosition = 0;
-    }
-}
+    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(msg), "");
+    if (LCD_CLICKED) lcd_goto_menu(lcd_tune_menu);
+  }
+  static void lcd_babystep_x() { _lcd_babystep(X_AXIS, MSG_BABYSTEPPING_X); }
+  static void lcd_babystep_y() { _lcd_babystep(Y_AXIS, MSG_BABYSTEPPING_Y); }
+  static void lcd_babystep_z() { _lcd_babystep(Z_AXIS, MSG_BABYSTEPPING_Z); }
 
-static void lcd_babystep_z()
-{
-    if (encoderPosition != 0)
-    {
-        babystepsTodo[Z_AXIS]+=BABYSTEP_Z_MULTIPLICATOR*(int)encoderPosition;
-        encoderPosition=0;
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR(MSG_BABYSTEPPING_Z),"");
-    }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_tune_menu;
-        encoderPosition = 0;
-    }
-}
 #endif //BABYSTEPPING
 
 static void lcd_tune_menu()
@@ -644,96 +603,28 @@ static void lcd_prepare_menu()
 float move_menu_scale;
 static void lcd_move_menu_axis();
 
-static void lcd_move_x()
-{
-    if (encoderPosition != 0)
-    {
-        refresh_cmd_timeout();
-        current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (min_software_endstops && current_position[X_AXIS] < X_MIN_POS)
-            current_position[X_AXIS] = X_MIN_POS;
-        if (max_software_endstops && current_position[X_AXIS] > X_MAX_POS)
-            current_position[X_AXIS] = X_MAX_POS;
-        encoderPosition = 0;
-        #ifdef DELTA
-        calculate_delta(current_position);
-        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[X_AXIS]/60, active_extruder);
-        #else
-        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[X_AXIS]/60, active_extruder);
-        #endif
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR("X"), ftostr31(current_position[X_AXIS]));
-    }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_move_menu_axis;
-        encoderPosition = 0;
-    }
-}
-static void lcd_move_y()
-{
-    if (encoderPosition != 0)
-    {
-        refresh_cmd_timeout();
-        current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (min_software_endstops && current_position[Y_AXIS] < Y_MIN_POS)
-            current_position[Y_AXIS] = Y_MIN_POS;
-        if (max_software_endstops && current_position[Y_AXIS] > Y_MAX_POS)
-            current_position[Y_AXIS] = Y_MAX_POS;
-        encoderPosition = 0;
-        #ifdef DELTA
-        calculate_delta(current_position);
-        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[Y_AXIS]/60, active_extruder);
-        #else
-        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[Y_AXIS]/60, active_extruder);
-        #endif
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR("Y"), ftostr31(current_position[Y_AXIS]));
-    }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_move_menu_axis;
-        encoderPosition = 0;
-    }
-}
-static void lcd_move_z()
-{
-    if (encoderPosition != 0)
-    {
-        refresh_cmd_timeout();
-        current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;
-        if (min_software_endstops && current_position[Z_AXIS] < Z_MIN_POS)
-            current_position[Z_AXIS] = Z_MIN_POS;
-        if (max_software_endstops && current_position[Z_AXIS] > Z_MAX_POS)
-            current_position[Z_AXIS] = Z_MAX_POS;
-        encoderPosition = 0;
-        #ifdef DELTA
-        calculate_delta(current_position);
-        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[Z_AXIS]/60, active_extruder);
-        #else
-        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[Z_AXIS]/60, active_extruder);
-        #endif
-        lcdDrawUpdate = 1;
-    }
-    if (lcdDrawUpdate)
-    {
-        lcd_implementation_drawedit(PSTR("Z"), ftostr31(current_position[Z_AXIS]));
-    }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_move_menu_axis;
-        encoderPosition = 0;
-    }
+static void _lcd_move(const char *name, int axis, int min, int max) {
+  if (encoderPosition != 0) {
+    refresh_cmd_timeout();
+    current_position[axis] += float((int)encoderPosition) * move_menu_scale;
+    if (min_software_endstops && current_position[axis] < min) current_position[axis] = min;
+    if (max_software_endstops && current_position[axis] > max) current_position[axis] = max;
+    encoderPosition = 0;
+    #ifdef DELTA
+      calculate_delta(current_position);
+      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
+    #else
+      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
+    #endif
+    lcdDrawUpdate = 1;
+  }
+  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
+  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
 }
+static void lcd_move_x() { _lcd_move(PSTR("X"), X_AXIS, X_MIN_POS, X_MAX_POS); }
+static void lcd_move_y() { _lcd_move(PSTR("Y"), Y_AXIS, Y_MIN_POS, Y_MAX_POS); }
+static void lcd_move_z() { _lcd_move(PSTR("Z"), Z_AXIS, Z_MIN_POS, Z_MAX_POS); }
+
 static void lcd_move_e()
 {
     if (encoderPosition != 0)
@@ -752,12 +643,7 @@ static void lcd_move_e()
     {
         lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));
     }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_move_menu_axis;
-        encoderPosition = 0;
-    }
+    if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
 }
 
 static void lcd_move_menu_axis()
@@ -951,12 +837,7 @@ static void lcd_set_contrast()
     {
         lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
     }
-    if (LCD_CLICKED)
-    {
-        lcd_quick_feedback();
-        currentMenu = lcd_control_menu;
-        encoderPosition = 0;
-    }
+    if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);
 }
 #endif
 
@@ -979,7 +860,8 @@ static void lcd_control_retract_menu()
     MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);
     END_MENU();
 }
-#endif
+
+#endif //FWRETRACT
 
 #if SDCARDDETECT == -1
 static void lcd_sd_refresh()
@@ -1052,27 +934,12 @@ void lcd_sdcard_menu()
         if (LCD_CLICKED) \
         { \
             *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
-            lcd_quick_feedback(); \
-            currentMenu = prevMenu; \
-            encoderPosition = prevEncoderPosition; \
+            lcd_goto_menu(prevMenu, prevEncoderPosition); \
         } \
     } \
-    void menu_edit_callback_ ## _name () \
-    { \
-        if ((int32_t)encoderPosition < 0) \
-            encoderPosition = 0; \
-        if ((int32_t)encoderPosition > maxEditValue) \
-            encoderPosition = maxEditValue; \
-        if (lcdDrawUpdate) \
-            lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
-        if (LCD_CLICKED) \
-        { \
-            *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
-            lcd_quick_feedback(); \
-            currentMenu = prevMenu; \
-            encoderPosition = prevEncoderPosition; \
-            (*callbackFunc)();\
-        } \
+    void menu_edit_callback_ ## _name () { \
+        menu_edit_ ## _name (); \
+        if (LCD_CLICKED) (*callbackFunc)(); \
     } \
     static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
     { \
@@ -1157,24 +1024,10 @@ static void lcd_quick_feedback()
 }
 
 /** Menu action functions **/
-static void menu_action_back(menuFunc_t data)
-{
-    currentMenu = data;
-    encoderPosition = 0;
-}
-static void menu_action_submenu(menuFunc_t data)
-{
-    currentMenu = data;
-    encoderPosition = 0;
-}
-static void menu_action_gcode(const char* pgcode)
-{
-    enquecommand_P(pgcode);
-}
-static void menu_action_function(menuFunc_t data)
-{
-    (*data)();
-}
+static void menu_action_back(menuFunc_t data) { lcd_goto_menu(data); }
+static void menu_action_submenu(menuFunc_t data) { lcd_goto_menu(data); }
+static void menu_action_gcode(const char* pgcode) { enquecommand_P(pgcode); }
+static void menu_action_function(menuFunc_t data) { (*data)(); }
 static void menu_action_sdfile(const char* filename, char* longFilename)
 {
     char cmd[30];
@@ -1459,10 +1312,8 @@ void lcd_buttons_update()
 
     //manage encoder rotation
     uint8_t enc=0;
-    if(buttons&EN_A)
-        enc|=(1<<0);
-    if(buttons&EN_B)
-        enc|=(1<<1);
+    if (buttons & EN_A) enc |= B01;
+    if (buttons & EN_B) enc |= B10;
     if(enc != lastEncoderBits)
     {
         switch(enc)
@@ -1611,6 +1462,7 @@ char *itostr31(const int &xx)
   return conv;
 }
 
+// Convert int to rj string with 123 or -12 format
 char *itostr3(const int &x)
 {
   int xx = x;
@@ -1653,47 +1505,25 @@ char *itostr3left(const int &xx)
   return conv;
 }
 
-char *itostr4(const int &xx)
-{
-  if (xx >= 1000)
-    conv[0]=(xx/1000)%10+'0';
-  else
-    conv[0]=' ';
-  if (xx >= 100)
-    conv[1]=(xx/100)%10+'0';
-  else
-    conv[1]=' ';
-  if (xx >= 10)
-    conv[2]=(xx/10)%10+'0';
-  else
-    conv[2]=' ';
-  conv[3]=(xx)%10+'0';
-  conv[4]=0;
+// Convert int to rj string with 1234 format
+char *itostr4(const int &xx) {
+  conv[0] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
+  conv[1] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
+  conv[2] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
+  conv[3] = xx % 10 + '0';
+  conv[4] = 0;
   return conv;
 }
 
-//  convert float to string with 12345 format
-char *ftostr5(const float &x)
-{
-  long xx=abs(x);
-  if (xx >= 10000)
-    conv[0]=(xx/10000)%10+'0';
-  else
-    conv[0]=' ';
-  if (xx >= 1000)
-    conv[1]=(xx/1000)%10+'0';
-  else
-    conv[1]=' ';
-  if (xx >= 100)
-    conv[2]=(xx/100)%10+'0';
-  else
-    conv[2]=' ';
-  if (xx >= 10)
-    conv[3]=(xx/10)%10+'0';
-  else
-    conv[3]=' ';
-  conv[4]=(xx)%10+'0';
-  conv[5]=0;
+//  convert float to rj string with 12345 format
+char *ftostr5(const float &x) {
+  long xx = abs(x);
+  conv[0] = xx >= 10000 ? (xx / 10000) % 10 + '0' : ' ';
+  conv[1] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
+  conv[2] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
+  conv[3] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
+  conv[4] = xx % 10 + '0';
+  conv[5] = 0;
   return conv;
 }
 
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 652693c..339955e 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -105,7 +105,8 @@
 
   #define LCD_MESSAGEPGM(x) 
   #define LCD_ALERTMESSAGEPGM(x) 
-#endif 
+
+#endif //ULTRA_LCD
 
 char *itostr2(const uint8_t &x);
 char *itostr31(const int &xx);
@@ -122,4 +123,4 @@ char *ftostr5(const float &x);
 char *ftostr51(const float &x);
 char *ftostr52(const float &x);
 
-#endif //ULTRALCD
+#endif //ULTRALCD_H

commit a9c334e8bce98110dbb81f2406568e8db50661e1 (from 1857e611d3563acf71fd86d6342aba514344c2a0)
Merge: 842da54 1857e61
Author: Bo Herrmannsen <bo.herrmannsen@gmail.com>
Date:   Thu Dec 18 17:23:11 2014 +0100

    Merge pull request #1191 from thinkyhead/code_shrink
    
    Shrink and Optimize

diff --git a/Marlin/ConfigurationStore.cpp b/Marlin/ConfigurationStore.cpp
index dbbe33a..54e69c0 100644
--- a/Marlin/ConfigurationStore.cpp
+++ b/Marlin/ConfigurationStore.cpp
@@ -116,38 +116,38 @@ void Config_PrintSettings()
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Steps per unit:");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
-    SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
-    SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
-    SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
+    SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[Z_AXIS]);
+    SERIAL_ECHOPAIR(" E",axis_steps_per_unit[E_AXIS]);
     SERIAL_ECHOLN("");
       
     SERIAL_ECHO_START;
 #ifdef SCARA
 SERIAL_ECHOLNPGM("Scaling factors:");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M365 X",axis_scaling[0]);
-    SERIAL_ECHOPAIR(" Y",axis_scaling[1]);
-    SERIAL_ECHOPAIR(" Z",axis_scaling[2]);
+    SERIAL_ECHOPAIR("  M365 X",axis_scaling[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y",axis_scaling[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z",axis_scaling[Z_AXIS]);
     SERIAL_ECHOLN("");
       
     SERIAL_ECHO_START;
 #endif
     SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
-    SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); 
-    SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); 
-    SERIAL_ECHOPAIR(" E", max_feedrate[3]);
+    SERIAL_ECHOPAIR("  M203 X", max_feedrate[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", max_feedrate[Y_AXIS]); 
+    SERIAL_ECHOPAIR(" Z", max_feedrate[Z_AXIS]); 
+    SERIAL_ECHOPAIR(" E", max_feedrate[E_AXIS]);
     SERIAL_ECHOLN("");
 
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); 
-    SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); 
-    SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
-    SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
+    SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[X_AXIS] ); 
+    SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[Y_AXIS] ); 
+    SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[Z_AXIS] );
+    SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[E_AXIS]);
     SERIAL_ECHOLN("");
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");
@@ -170,17 +170,17 @@ SERIAL_ECHOLNPGM("Scaling factors:");
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Home offset (mm):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M206 X",add_homing[0] );
-    SERIAL_ECHOPAIR(" Y" ,add_homing[1] );
-    SERIAL_ECHOPAIR(" Z" ,add_homing[2] );
+    SERIAL_ECHOPAIR("  M206 X",add_homing[X_AXIS] );
+    SERIAL_ECHOPAIR(" Y" ,add_homing[Y_AXIS] );
+    SERIAL_ECHOPAIR(" Z" ,add_homing[Z_AXIS] );
     SERIAL_ECHOLN("");
 #ifdef DELTA
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Endstop adjustement (mm):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("  M666 X",endstop_adj[0] );
-    SERIAL_ECHOPAIR(" Y" ,endstop_adj[1] );
-    SERIAL_ECHOPAIR(" Z" ,endstop_adj[2] );
+    SERIAL_ECHOPAIR("  M666 X",endstop_adj[X_AXIS] );
+    SERIAL_ECHOPAIR(" Y" ,endstop_adj[Y_AXIS] );
+    SERIAL_ECHOPAIR(" Z" ,endstop_adj[Z_AXIS] );
 	SERIAL_ECHOLN("");
 	SERIAL_ECHO_START;
 	SERIAL_ECHOLNPGM("Delta settings: L=delta_diagonal_rod, R=delta_radius, S=delta_segments_per_second");
@@ -303,9 +303,9 @@ void Config_ResetDefault()
     max_xy_jerk=DEFAULT_XYJERK;
     max_z_jerk=DEFAULT_ZJERK;
     max_e_jerk=DEFAULT_EJERK;
-    add_homing[0] = add_homing[1] = add_homing[2] = 0;
+    add_homing[X_AXIS] = add_homing[Y_AXIS] = add_homing[Z_AXIS] = 0;
 #ifdef DELTA
-	endstop_adj[0] = endstop_adj[1] = endstop_adj[2] = 0;
+	endstop_adj[X_AXIS] = endstop_adj[Y_AXIS] = endstop_adj[Z_AXIS] = 0;
 	delta_radius= DELTA_RADIUS;
 	delta_diagonal_rod= DELTA_DIAGONAL_ROD;
 	delta_segments_per_second= DELTA_SEGMENTS_PER_SECOND;
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index d0f988c..5eebec9 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -345,8 +345,8 @@
 
   #define D_FILAMENT 2.85
   #define STEPS_MM_E 836
-  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
-  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+  #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUSION_AREA)
 
 #endif // ADVANCE
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index e8d800e..59b291c 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -429,7 +429,7 @@ void enquecommand(const char *cmd)
     //this is dangerous if a mixing of serial and this happens
     strcpy(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHOPGM(MSG_Enqueing);
     SERIAL_ECHO(cmdbuffer[bufindw]);
     SERIAL_ECHOLNPGM("\"");
     bufindw= (bufindw + 1)%BUFSIZE;
@@ -444,7 +444,7 @@ void enquecommand_P(const char *cmd)
     //this is dangerous if a mixing of serial and this happens
     strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
     SERIAL_ECHO_START;
-    SERIAL_ECHOPGM("enqueing \"");
+    SERIAL_ECHOPGM(MSG_Enqueing);
     SERIAL_ECHO(cmdbuffer[bufindw]);
     SERIAL_ECHOLNPGM("\"");
     bufindw= (bufindw + 1)%BUFSIZE;
@@ -1537,7 +1537,7 @@ void process_commands()
 		#ifdef SCARA
 		   current_position[X_AXIS]=code_value();
 		#else
-		   current_position[X_AXIS]=code_value()+add_homing[0];
+		   current_position[X_AXIS]=code_value()+add_homing[X_AXIS];
 		#endif
         }
       }
@@ -1547,7 +1547,7 @@ void process_commands()
          #ifdef SCARA
 		   current_position[Y_AXIS]=code_value();
 		#else
-		   current_position[Y_AXIS]=code_value()+add_homing[1];
+		   current_position[Y_AXIS]=code_value()+add_homing[Y_AXIS];
 		#endif
         }
       }
@@ -1612,7 +1612,7 @@ void process_commands()
 
       if(code_seen(axis_codes[Z_AXIS])) {
         if(code_value_long() != 0) {
-          current_position[Z_AXIS]=code_value()+add_homing[2];
+          current_position[Z_AXIS]=code_value()+add_homing[Z_AXIS];
         }
       }
       #ifdef ENABLE_AUTO_BED_LEVELING
@@ -2745,9 +2745,9 @@ Sigma_Exit:
       SERIAL_PROTOCOLLN("");
       
       SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");
-      SERIAL_PROTOCOL(delta[X_AXIS]+add_homing[0]);
+      SERIAL_PROTOCOL(delta[X_AXIS]+add_homing[X_AXIS]);
       SERIAL_PROTOCOLPGM("   Psi+Theta (90):");
-      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homing[1]);
+      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homing[Y_AXIS]);
       SERIAL_PROTOCOLLN("");
       
       SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
@@ -2883,11 +2883,11 @@ Sigma_Exit:
 	  #ifdef SCARA
 	   if(code_seen('T'))       // Theta
       {
-        add_homing[0] = code_value() ;
+        add_homing[X_AXIS] = code_value() ;
       }
       if(code_seen('P'))       // Psi
       {
-        add_homing[1] = code_value() ;
+        add_homing[Y_AXIS] = code_value() ;
       }
 	  #endif
       break;
@@ -3275,11 +3275,11 @@ Sigma_Exit:
       //SERIAL_ECHOLN(" Soft endstops disabled ");
       if(Stopped == false) {
         //get_coordinates(); // For X Y Z E F
-        delta[0] = 0;
-        delta[1] = 120;
+        delta[X_AXIS] = 0;
+        delta[Y_AXIS] = 120;
         calculate_SCARA_forward_Transform(delta);
-        destination[0] = delta[0]/axis_scaling[X_AXIS];
-        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
+        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
         
         prepare_move();
         //ClearToSend();
@@ -3293,11 +3293,11 @@ Sigma_Exit:
       //SERIAL_ECHOLN(" Soft endstops disabled ");
       if(Stopped == false) {
         //get_coordinates(); // For X Y Z E F
-        delta[0] = 90;
-        delta[1] = 130;
+        delta[X_AXIS] = 90;
+        delta[Y_AXIS] = 130;
         calculate_SCARA_forward_Transform(delta);
-        destination[0] = delta[0]/axis_scaling[X_AXIS];
-        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
+        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
         
         prepare_move();
         //ClearToSend();
@@ -3310,11 +3310,11 @@ Sigma_Exit:
       //SERIAL_ECHOLN(" Soft endstops disabled ");
       if(Stopped == false) {
         //get_coordinates(); // For X Y Z E F
-        delta[0] = 60;
-        delta[1] = 180;
+        delta[X_AXIS] = 60;
+        delta[Y_AXIS] = 180;
         calculate_SCARA_forward_Transform(delta);
-        destination[0] = delta[0]/axis_scaling[X_AXIS];
-        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
+        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
         
         prepare_move();
         //ClearToSend();
@@ -3327,11 +3327,11 @@ Sigma_Exit:
       //SERIAL_ECHOLN(" Soft endstops disabled ");
       if(Stopped == false) {
         //get_coordinates(); // For X Y Z E F
-        delta[0] = 50;
-        delta[1] = 90;
+        delta[X_AXIS] = 50;
+        delta[Y_AXIS] = 90;
         calculate_SCARA_forward_Transform(delta);
-        destination[0] = delta[0]/axis_scaling[X_AXIS];
-        destination[1] = delta[1]/axis_scaling[Y_AXIS];
+        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
+        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
         
         prepare_move();
         //ClearToSend();
@@ -3344,11 +3344,11 @@ Sigma_Exit:
       //SERIAL_ECHOLN(" Soft endstops disabled ");
       if(Stopped == false) {
         //get_coordinates(); // For X Y Z E F
-        delta[0] = 45;
-        delta[1] = 135;
+        delta[X_AXIS] = 45;
+        delta[Y_AXIS] = 135;
         calculate_SCARA_forward_Transform(delta);
-        destination[0] = delta[0]/axis_scaling[X_AXIS];
-        destination[1] = delta[1]/axis_scaling[Y_AXIS]; 
+        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
+        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS]; 
         
         prepare_move();
         //ClearToSend();
@@ -4020,9 +4020,9 @@ for (int s = 1; s <= steps; s++) {
 
 	
 	calculate_delta(destination);
-         //SERIAL_ECHOPGM("destination[0]="); SERIAL_ECHOLN(destination[0]);
-         //SERIAL_ECHOPGM("destination[1]="); SERIAL_ECHOLN(destination[1]);
-         //SERIAL_ECHOPGM("destination[2]="); SERIAL_ECHOLN(destination[2]);
+         //SERIAL_ECHOPGM("destination[X_AXIS]="); SERIAL_ECHOLN(destination[X_AXIS]);
+         //SERIAL_ECHOPGM("destination[Y_AXIS]="); SERIAL_ECHOLN(destination[Y_AXIS]);
+         //SERIAL_ECHOPGM("destination[Z_AXIS]="); SERIAL_ECHOLN(destination[Z_AXIS]);
          //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);
          //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
          //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);
diff --git a/Marlin/SdFatConfig.h b/Marlin/SdFatConfig.h
index 39ef381..7492c54 100644
--- a/Marlin/SdFatConfig.h
+++ b/Marlin/SdFatConfig.h
@@ -115,6 +115,8 @@ uint8_t const SOFT_SPI_SCK_PIN = 13;
 #define FILENAME_LENGTH 13
 /** Number of VFAT entries used. Every entry has 13 UTF-16 characters */
 #define MAX_VFAT_ENTRIES (2)
+/** Number of UTF-16 characters per entry */
+#define FILENAME_LENGTH 13
 /** Total size of the buffer used to store the long filenames */
 #define LONG_FILENAME_LENGTH (FILENAME_LENGTH*MAX_VFAT_ENTRIES+1)
 #endif  // SdFatConfig_h
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index 10fbe9b..840a1b2 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -353,8 +353,8 @@
 
   #define D_FILAMENT 1.75
   #define STEPS_MM_E 1000
-  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
-  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+  #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUSION_AREA)
 
 #endif // ADVANCE
 
diff --git a/Marlin/example_configurations/delta/Configuration_adv.h b/Marlin/example_configurations/delta/Configuration_adv.h
index 6c9d568..edc6580 100644
--- a/Marlin/example_configurations/delta/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/Configuration_adv.h
@@ -340,8 +340,8 @@
 
   #define D_FILAMENT 2.85
   #define STEPS_MM_E 836
-  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
-  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+  #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUSION_AREA)
 
 #endif // ADVANCE
 
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index 312b2b9..21dbd46 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -344,8 +344,8 @@
 
   #define D_FILAMENT 2.85
   #define STEPS_MM_E 836
-  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
-  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)
+  #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)
+  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUSION_AREA)
 
 #endif // ADVANCE
 
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index fe61750..c894225 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -63,9 +63,9 @@
 //===========================================================================
 
 unsigned long minsegmenttime;
-float max_feedrate[4]; // set the max speeds
-float axis_steps_per_unit[4];
-unsigned long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
+float max_feedrate[NUM_AXIS]; // set the max speeds
+float axis_steps_per_unit[NUM_AXIS];
+unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
 float minimumfeedrate;
 float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
 float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
@@ -85,8 +85,8 @@ matrix_3x3 plan_bed_level_matrix = {
 #endif // #ifdef ENABLE_AUTO_BED_LEVELING
 
 // The current position of the tool in absolute steps
-long position[4];   //rescaled from extern when axis_steps_per_unit are changed by gcode
-static float previous_speed[4]; // Speed of previous path line segment
+long position[NUM_AXIS];   //rescaled from extern when axis_steps_per_unit are changed by gcode
+static float previous_speed[NUM_AXIS]; // Speed of previous path line segment
 static float previous_nominal_speed; // Nominal speed of previous path line segment
 
 #ifdef AUTOTEMP
@@ -989,7 +989,7 @@ block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-positi
   else {
     long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
     float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * 
-      (current_speed[E_AXIS] * current_speed[E_AXIS] * EXTRUTION_AREA * EXTRUTION_AREA)*256;
+      (current_speed[E_AXIS] * current_speed[E_AXIS] * EXTRUSION_AREA * EXTRUSION_AREA)*256;
     block->advance = advance;
     if(acc_dist == 0) {
       block->advance_rate = 0;
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 837199e..0952b9d 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -106,9 +106,9 @@ void check_axes_activity();
 uint8_t movesplanned(); //return the nr of buffered moves
 
 extern unsigned long minsegmenttime;
-extern float max_feedrate[4]; // set the max speeds
-extern float axis_steps_per_unit[4];
-extern unsigned long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software
+extern float max_feedrate[NUM_AXIS]; // set the max speeds
+extern float axis_steps_per_unit[NUM_AXIS];
+extern unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
 extern float minimumfeedrate;
 extern float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
 extern float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
@@ -152,14 +152,7 @@ FORCE_INLINE block_t *plan_get_current_block()
 }
 
 // Returns true if the buffer has a queued block, false otherwise
-FORCE_INLINE bool blocks_queued() 
-{
-  if (block_buffer_head == block_buffer_tail) { 
-    return false; 
-  }
-  else
-    return true;
-}
+FORCE_INLINE bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
 #ifdef PREVENT_DANGEROUS_EXTRUDE
 void set_extrude_min_temp(float temp);
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 11c7e9e..c0bcc8f 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1203,7 +1203,7 @@ void lcd_update()
             lcd_implementation_clear();
         if (lcdDrawUpdate)
             lcdDrawUpdate--;
-        lcd_next_update_millis = millis() + 100;
+        lcd_next_update_millis = millis() + LCD_UPDATE_INTERVAL;
     }
 }
 

