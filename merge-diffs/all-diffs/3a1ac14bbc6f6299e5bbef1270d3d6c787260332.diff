commit 3a1ac14bbc6f6299e5bbef1270d3d6c787260332 (from c5a2ce4366a02ecafea61f5d780400f71cc3c891)
Merge: c5a2ce4 8198cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 11 17:03:23 2016 -0700

    Merge pull request #3437 from thinkyhead/rc_lcd_encoder_movement
    
    More bits when encoderPosition is cast as signed

diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 4650752..652a1d4 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -432,19 +432,19 @@ static void lcd_status_screen() {
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
-      int new_frm = feedrate_multiplier + int(encoderPosition);
+      int new_frm = feedrate_multiplier + (int32_t)encoderPosition;
       // Dead zone at 100% feedrate
       if ((feedrate_multiplier < 100 && new_frm > 100) || (feedrate_multiplier > 100 && new_frm < 100)) {
         feedrate_multiplier = 100;
         encoderPosition = 0;
       }
       else if (feedrate_multiplier == 100) {
-        if (int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE) {
-          feedrate_multiplier += int(encoderPosition) - (ENCODER_FEEDRATE_DEADZONE);
+        if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
+          feedrate_multiplier += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
           encoderPosition = 0;
         }
-        else if (int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE) {
-          feedrate_multiplier += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
+        else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE)) {
+          feedrate_multiplier += (int32_t)encoderPosition + ENCODER_FEEDRATE_DEADZONE;
           encoderPosition = 0;
         }
       }
@@ -554,7 +554,7 @@ void lcd_set_home_offsets() {
   static void _lcd_babystep(const int axis, const char* msg) {
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
-      int distance =  (int)encoderPosition * BABYSTEP_MULTIPLICATOR;
+      int distance =  (int32_t)encoderPosition * BABYSTEP_MULTIPLICATOR;
       encoderPosition = 0;
       lcdDrawUpdate = LCD_DRAW_UPDATE_CALL_REDRAW;
       #if ENABLED(COREXY) || ENABLED(COREXZ)
@@ -903,7 +903,7 @@ void lcd_cooldown() {
     // Encoder wheel adjusts the Z position
     if (encoderPosition && movesplanned() <= 3) {
       refresh_cmd_timeout();
-      current_position[Z_AXIS] += float((int)encoderPosition) * (MBL_Z_STEP);
+      current_position[Z_AXIS] += float((int32_t)encoderPosition) * (MBL_Z_STEP);
       if (min_software_endstops) NOLESS(current_position[Z_AXIS], Z_MIN_POS);
       if (max_software_endstops) NOMORE(current_position[Z_AXIS], Z_MAX_POS);
       encoderPosition = 0;
@@ -1126,7 +1126,7 @@ static void _lcd_move(const char* name, AxisEnum axis, float min, float max) {
   ENCODER_DIRECTION_NORMAL();
   if (encoderPosition && movesplanned() <= 3) {
     refresh_cmd_timeout();
-    current_position[axis] += float((int)encoderPosition) * move_menu_scale;
+    current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
     if (min_software_endstops) NOLESS(current_position[axis], min);
     if (max_software_endstops) NOMORE(current_position[axis], max);
     encoderPosition = 0;
@@ -1157,7 +1157,7 @@ static void lcd_move_e(
     active_extruder = e;
   #endif
   if (encoderPosition && movesplanned() <= 3) {
-    current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;
+    current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
     encoderPosition = 0;
     line_to_current(E_AXIS);
     lcdDrawUpdate = LCD_DRAW_UPDATE_CALL_REDRAW;
@@ -2345,7 +2345,7 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
       #if ENABLED(RIGIDBOT_PANEL)
         if (ELAPSED(now, next_button_update_ms)) {
           if (BUTTON_PRESSED(UP)) {
-            encoderDiff = -1 * (ENCODER_STEPS_PER_MENU_ITEM);
+            encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM);
             next_button_update_ms = now + 300;
           }
           else if (BUTTON_PRESSED(DWN)) {
@@ -2353,7 +2353,7 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
             next_button_update_ms = now + 300;
           }
           else if (BUTTON_PRESSED(LFT)) {
-            encoderDiff = -1 * (ENCODER_PULSES_PER_STEP);
+            encoderDiff = -(ENCODER_PULSES_PER_STEP);
             next_button_update_ms = now + 300;
           }
           else if (BUTTON_PRESSED(RT)) {

commit 3a1ac14bbc6f6299e5bbef1270d3d6c787260332 (from 8198cc30b5d3f875a34e8a8ed48d07211f5f154e)
Merge: c5a2ce4 8198cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 11 17:03:23 2016 -0700

    Merge pull request #3437 from thinkyhead/rc_lcd_encoder_movement
    
    More bits when encoderPosition is cast as signed

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index c8b9090..2ef5706 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -306,7 +306,7 @@ const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
 // Inactivity shutdown
 millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
-static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000L;
+static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 Stopwatch print_job_timer = Stopwatch();
 static uint8_t target_extruder;
 
@@ -435,7 +435,7 @@ static bool send_ok[BUFSIZE];
 #endif
 
 #ifdef CHDK
-  unsigned long chdkHigh = 0;
+  millis_t chdkHigh = 0;
   boolean chdkActive = false;
 #endif
 
@@ -456,7 +456,7 @@ static bool send_ok[BUFSIZE];
   };
 
   static MarlinBusyState busy_state = NOT_BUSY;
-  static millis_t next_busy_signal_ms = -1;
+  static millis_t next_busy_signal_ms = 0;
   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
   #define KEEPALIVE_STATE(n) do{ busy_state = n; }while(0)
 #else
@@ -874,7 +874,7 @@ inline void get_serial_commands() {
   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
     static millis_t last_command_time = 0;
     millis_t ms = millis();
-    if (commands_in_queue == 0 && !MYSERIAL.available() && ms > last_command_time + NO_TIMEOUTS) {
+    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(MSG_WAIT);
       last_command_time = ms;
     }
@@ -1351,8 +1351,14 @@ static void setup_for_endstop_move() {
     #if DISABLED(DELTA)
 
       static void set_bed_level_equation_lsq(double* plane_equation_coefficients) {
+
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("BEFORE set_bed_level_equation_lsq", current_position);
+          plan_bed_level_matrix.set_to_identity();
+          if (DEBUGGING(LEVELING)) {
+            vector_3 uncorrected_position = plan_get_position();
+            DEBUG_POS(">>> set_bed_level_equation_lsq", uncorrected_position);
+            DEBUG_POS(">>> set_bed_level_equation_lsq", current_position);
+          }
         #endif
 
         vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
@@ -1371,7 +1377,7 @@ static void setup_for_endstop_move() {
         current_position[Z_AXIS] = corrected_position.z;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("AFTER set_bed_level_equation_lsq", current_position);
+          if (DEBUGGING(LEVELING)) DEBUG_POS("<<< set_bed_level_equation_lsq", current_position);
         #endif
 
         sync_plan_position();
@@ -2279,8 +2285,8 @@ void unknown_command_error() {
    */
   void host_keepalive() {
     millis_t ms = millis();
-    if (busy_state != NOT_BUSY) {
-      if (ms < next_busy_signal_ms) return;
+    if (host_keepalive_interval && busy_state != NOT_BUSY) {
+      if (PENDING(ms, next_busy_signal_ms)) return;
       switch (busy_state) {
         case IN_HANDLER:
         case IN_PROCESS:
@@ -2299,7 +2305,7 @@ void unknown_command_error() {
           break;
       }
     }
-    next_busy_signal_ms = host_keepalive_interval ? ms + 1000UL * host_keepalive_interval : -1;
+    next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   }
 
 #endif //HOST_KEEPALIVE_FEATURE
@@ -2368,7 +2374,7 @@ inline void gcode_G4() {
   millis_t codenum = 0;
 
   if (code_seen('P')) codenum = code_value_long(); // milliseconds to wait
-  if (code_seen('S')) codenum = code_value() * 1000; // seconds to wait
+  if (code_seen('S')) codenum = code_value() * 1000UL; // seconds to wait
 
   st_synchronize();
   refresh_cmd_timeout();
@@ -2376,7 +2382,7 @@ inline void gcode_G4() {
 
   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
 
-  while (millis() < codenum) idle();
+  while (PENDING(millis(), codenum)) idle();
 }
 
 #if ENABLED(FWRETRACT)
@@ -2841,7 +2847,7 @@ inline void gcode_G28() {
         }
         if (probe_point == 0) {
           // Set Z to a positive value before recording the first Z.
-          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
+          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z + home_offset[Z_AXIS];
           sync_plan_position();
         }
         else {
@@ -2850,7 +2856,7 @@ inline void gcode_G28() {
           iy = (probe_point - 1) / (MESH_NUM_X_POINTS);
           if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
           mbl.set_z(ix, iy, current_position[Z_AXIS]);
-          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
+          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z + home_offset[Z_AXIS];
           plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
           st_synchronize();
         }
@@ -2859,8 +2865,8 @@ inline void gcode_G28() {
           ix = probe_point % (MESH_NUM_X_POINTS);
           iy = probe_point / (MESH_NUM_X_POINTS);
           if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
-          current_position[X_AXIS] = mbl.get_x(ix);
-          current_position[Y_AXIS] = mbl.get_y(iy);
+          current_position[X_AXIS] = mbl.get_x(ix) + home_offset[X_AXIS];
+          current_position[Y_AXIS] = mbl.get_y(iy) + home_offset[Y_AXIS];
           plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
           st_synchronize();
           probe_point++;
@@ -3059,7 +3065,11 @@ inline void gcode_G28() {
       #else //!DELTA
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("BEFORE matrix.set_to_identity", current_position);
+          if (DEBUGGING(LEVELING)) {
+            vector_3 corrected_position = plan_get_position();
+            DEBUG_POS("BEFORE matrix.set_to_identity", corrected_position);
+            DEBUG_POS("BEFORE matrix.set_to_identity", current_position);
+          }
         #endif
 
         //vector_3 corrected_position = plan_get_position();
@@ -3069,12 +3079,13 @@ inline void gcode_G28() {
         current_position[X_AXIS] = uncorrected_position.x;
         current_position[Y_AXIS] = uncorrected_position.y;
         current_position[Z_AXIS] = uncorrected_position.z;
-        sync_plan_position();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("AFTER matrix.set_to_identity", current_position);
+          if (DEBUGGING(LEVELING)) DEBUG_POS("AFTER matrix.set_to_identity", uncorrected_position);
         #endif
 
+        sync_plan_position();
+
       #endif // !DELTA
     }
 
@@ -3144,7 +3155,7 @@ inline void gcode_G28() {
 
           // raise extruder
           float measured_z,
-                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING;
+                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS];
 
           if (probePointCounter) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3157,7 +3168,7 @@ inline void gcode_G28() {
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("z_before = (before) ", Z_RAISE_BEFORE_PROBING);
+                SERIAL_ECHOPAIR("z_before = (before) ", Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS]);
                 SERIAL_EOL;
               }
             #endif
@@ -3318,9 +3329,18 @@ inline void gcode_G28() {
         p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;
 
       // Probe at 3 arbitrary points
-      float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING, p1, verbose_level),
-            z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p2, verbose_level),
-            z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p3, verbose_level);
+      float z_at_pt_1 = probe_pt( ABL_PROBE_PT_1_X + home_offset[X_AXIS],
+                                  ABL_PROBE_PT_1_Y + home_offset[Y_AXIS],
+                                  Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS],
+                                  p1, verbose_level),
+            z_at_pt_2 = probe_pt( ABL_PROBE_PT_2_X + home_offset[X_AXIS],
+                                  ABL_PROBE_PT_2_Y + home_offset[Y_AXIS],
+                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  p2, verbose_level),
+            z_at_pt_3 = probe_pt( ABL_PROBE_PT_3_X + home_offset[X_AXIS],
+                                  ABL_PROBE_PT_3_Y + home_offset[Y_AXIS],
+                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  p3, verbose_level);
       clean_up_after_endstop_move();
       if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
 
@@ -3525,7 +3545,7 @@ inline void gcode_G92() {
       hasP = codenum > 0;
     }
     if (code_seen('S')) {
-      codenum = code_value() * 1000; // seconds to wait
+      codenum = code_value() * 1000UL; // seconds to wait
       hasS = codenum > 0;
     }
 
@@ -3544,7 +3564,7 @@ inline void gcode_G92() {
     if (codenum > 0) {
       codenum += previous_cmd_ms;  // wait until this time for a click
       KEEPALIVE_STATE(PAUSED_FOR_USER);
-      while (millis() < codenum && !lcd_clicked()) idle();
+      while (PENDING(millis(), codenum) && !lcd_clicked()) idle();
       KEEPALIVE_STATE(IN_HANDLER);
       lcd_ignore_click(false);
     }
@@ -4290,9 +4310,9 @@ inline void gcode_M109() {
   if (degTargetHotend(target_extruder) < (EXTRUDE_MINTEMP)/2) return;
 
   #ifdef TEMP_RESIDENCY_TIME
-    long residency_start_ms = -1;
+    millis_t residency_start_ms = 0;
     // Loop until the temperature has stabilized
-    #define TEMP_CONDITIONS (residency_start_ms == -1 || now < residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL)
+    #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
   #else
     // Loop until the temperature is very close target
     #define TEMP_CONDITIONS (isHeatingHotend(target_extruder))
@@ -4302,14 +4322,14 @@ inline void gcode_M109() {
   millis_t now = millis(), next_temp_ms = now + 1000UL;
   while (!cancel_heatup && TEMP_CONDITIONS) {
     now = millis();
-    if (now > next_temp_ms) { //Print temp & remaining time every 1s while waiting
+    if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
       next_temp_ms = now + 1000UL;
       #if HAS_TEMP_HOTEND || HAS_TEMP_BED
         print_heaterstates();
       #endif
       #ifdef TEMP_RESIDENCY_TIME
         SERIAL_PROTOCOLPGM(" W:");
-        if (residency_start_ms != -1) {
+        if (residency_start_ms) {
           long rem = (((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL;
           SERIAL_PROTOCOLLN(rem);
         }
@@ -4328,7 +4348,7 @@ inline void gcode_M109() {
 
       float temp_diff = labs(degHotend(target_extruder) - degTargetHotend(target_extruder));
 
-      if (residency_start_ms == -1) {
+      if (!residency_start_ms) {
         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
         if (temp_diff < TEMP_WINDOW) residency_start_ms = millis();
       }
@@ -4365,7 +4385,7 @@ inline void gcode_M109() {
     millis_t now = millis(), next_temp_ms = now + 1000UL;
     while (!cancel_heatup && isHeatingBed()) {
       millis_t now = millis();
-      if (now > next_temp_ms) { //Print Temp Reading every 1 second while heating up.
+      if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
         next_temp_ms = now + 1000UL;
         print_heaterstates();
         SERIAL_EOL;
@@ -4613,7 +4633,7 @@ inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
  */
 inline void gcode_M18_M84() {
   if (code_seen('S')) {
-    stepper_inactive_time = code_value() * 1000;
+    stepper_inactive_time = code_value() * 1000UL;
   }
   else {
     bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])) || (code_seen(axis_codes[E_AXIS])));
@@ -4641,7 +4661,7 @@ inline void gcode_M18_M84() {
  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
  */
 inline void gcode_M85() {
-  if (code_seen('S')) max_inactive_time = code_value() * 1000;
+  if (code_seen('S')) max_inactive_time = code_value() * 1000UL;
 }
 
 /**
@@ -4975,19 +4995,26 @@ inline void gcode_M205() {
   if (code_seen('E')) max_e_jerk = code_value();
 }
 
+static void set_home_offset(AxisEnum axis, float v) {
+  min_pos[axis] = base_min_pos(axis) + v;
+  max_pos[axis] = base_max_pos(axis) + v;
+  current_position[axis] += v - home_offset[axis];
+  home_offset[axis] = v;
+}
+
 /**
  * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
  */
 inline void gcode_M206() {
-  for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
-    if (code_seen(axis_codes[i])) {
-      home_offset[i] = code_value();
-    }
-  }
+  for (int8_t i = X_AXIS; i <= Z_AXIS; i++)
+    if (code_seen(axis_codes[i]))
+      set_home_offset((AxisEnum)i, code_value());
+
   #if ENABLED(SCARA)
-    if (code_seen('T')) home_offset[X_AXIS] = code_value(); // Theta
-    if (code_seen('P')) home_offset[Y_AXIS] = code_value(); // Psi
+    if (code_seen('T')) set_home_offset(X_AXIS, code_value()); // Theta
+    if (code_seen('P')) set_home_offset(Y_AXIS, code_value()); // Psi
   #endif
+  sync_plan_position();
 }
 
 #if ENABLED(DELTA)
@@ -5674,16 +5701,12 @@ inline void gcode_M410() { quickStop(); }
  */
 inline void gcode_M428() {
   bool err = false;
-  float new_offs[3], new_pos[3];
-  memcpy(new_pos, current_position, sizeof(new_pos));
-  memcpy(new_offs, home_offset, sizeof(new_offs));
   for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
     if (axis_homed[i]) {
-      float base = (new_pos[i] > (min_pos[i] + max_pos[i]) / 2) ? base_home_pos(i) : 0,
-            diff = new_pos[i] - base;
+      float base = (current_position[i] > (min_pos[i] + max_pos[i]) / 2) ? base_home_pos(i) : 0,
+            diff = current_position[i] - base;
       if (diff > -20 && diff < 20) {
-        new_offs[i] -= diff;
-        new_pos[i] = base;
+        set_home_offset((AxisEnum)i, home_offset[i] - diff);
       }
       else {
         SERIAL_ERROR_START;
@@ -5699,8 +5722,6 @@ inline void gcode_M428() {
   }
 
   if (!err) {
-    memcpy(current_position, new_pos, sizeof(new_pos));
-    memcpy(home_offset, new_offs, sizeof(new_offs));
     sync_plan_position();
     LCD_ALERTMESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
     #if HAS_BUZZER
@@ -5868,9 +5889,9 @@ inline void gcode_M503() {
     while (!lcd_clicked()) {
       #if DISABLED(AUTO_FILAMENT_CHANGE)
         millis_t ms = millis();
-        if (ms >= next_tick) {
+        if (ELAPSED(ms, next_tick)) {
           lcd_quick_feedback();
-          next_tick = ms + 2500; // feedback every 2.5s while waiting
+          next_tick = ms + 2500UL; // feedback every 2.5s while waiting
         }
         idle(true);
       #else
@@ -6109,7 +6130,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
         set_destination_to_current();
         #if ENABLED(DUAL_X_CARRIAGE)
           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&
-              (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder))) {
+              (delayed_move_time || current_position[X_AXIS] != x_home_pos(active_extruder))) {
             // Park old head: 1) raise 2) move to park position 3) lower
             plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                              current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
@@ -6416,6 +6437,14 @@ void process_next_command() {
         gcode_M112();
         break;
 
+      #if ENABLED(HOST_KEEPALIVE_FEATURE)
+
+        case 113: // M113: Set Host Keepalive interval
+          gcode_M113();
+          break;
+
+      #endif
+
       case 140: // M140: Set bed temp
         gcode_M140();
         break;
@@ -6961,10 +6990,10 @@ void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_
     set_current_to_destination();
     return;
   }
-  int pix = mbl.select_x_index(current_position[X_AXIS]);
-  int piy = mbl.select_y_index(current_position[Y_AXIS]);
-  int ix = mbl.select_x_index(x);
-  int iy = mbl.select_y_index(y);
+  int pix = mbl.select_x_index(current_position[X_AXIS] - home_offset[X_AXIS]);
+  int piy = mbl.select_y_index(current_position[Y_AXIS] - home_offset[Y_AXIS]);
+  int ix = mbl.select_x_index(x - home_offset[X_AXIS]);
+  int iy = mbl.select_y_index(y - home_offset[Y_AXIS]);
   pix = min(pix, MESH_NUM_X_POINTS - 2);
   piy = min(piy, MESH_NUM_Y_POINTS - 2);
   ix = min(ix, MESH_NUM_X_POINTS - 2);
@@ -6977,7 +7006,7 @@ void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_
   }
   float nx, ny, nz, ne, normalized_dist;
   if (ix > pix && TEST(x_splits, ix)) {
-    nx = mbl.get_x(ix);
+    nx = mbl.get_x(ix) + home_offset[X_AXIS];
     normalized_dist = (nx - current_position[X_AXIS]) / (x - current_position[X_AXIS]);
     ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;
     nz = current_position[Z_AXIS] + (z - current_position[Z_AXIS]) * normalized_dist;
@@ -6985,7 +7014,7 @@ void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_
     CBI(x_splits, ix);
   }
   else if (ix < pix && TEST(x_splits, pix)) {
-    nx = mbl.get_x(pix);
+    nx = mbl.get_x(pix) + home_offset[X_AXIS];
     normalized_dist = (nx - current_position[X_AXIS]) / (x - current_position[X_AXIS]);
     ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;
     nz = current_position[Z_AXIS] + (z - current_position[Z_AXIS]) * normalized_dist;
@@ -6993,7 +7022,7 @@ void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_
     CBI(x_splits, pix);
   }
   else if (iy > piy && TEST(y_splits, iy)) {
-    ny = mbl.get_y(iy);
+    ny = mbl.get_y(iy) + home_offset[Y_AXIS];
     normalized_dist = (ny - current_position[Y_AXIS]) / (y - current_position[Y_AXIS]);
     nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;
     nz = current_position[Z_AXIS] + (z - current_position[Z_AXIS]) * normalized_dist;
@@ -7001,7 +7030,7 @@ void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_
     CBI(y_splits, iy);
   }
   else if (iy < piy && TEST(y_splits, piy)) {
-    ny = mbl.get_y(piy);
+    ny = mbl.get_y(piy) + home_offset[Y_AXIS];
     normalized_dist = (ny - current_position[Y_AXIS]) / (y - current_position[Y_AXIS]);
     nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;
     nz = current_position[Z_AXIS] + (z - current_position[Z_AXIS]) * normalized_dist;
@@ -7337,8 +7366,8 @@ void plan_arc(
     static millis_t lastMotorOn = 0; // Last time a motor was turned on
     static millis_t nextMotorCheck = 0; // Last time the state was checked
     millis_t ms = millis();
-    if (ms >= nextMotorCheck) {
-      nextMotorCheck = ms + 2500; // Not a time critical function, so only check every 2.5s
+    if (ELAPSED(ms, nextMotorCheck)) {
+      nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || soft_pwm_bed > 0
           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
           #if EXTRUDERS > 1
@@ -7358,7 +7387,7 @@ void plan_arc(
       }
 
       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
-      uint8_t speed = (lastMotorOn == 0 || ms >= lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL) ? 0 : CONTROLLERFAN_SPEED;
+      uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
 
       // allows digital or PWM fan output to be used (see M42 handling)
       digitalWrite(CONTROLLERFAN_PIN, speed);
@@ -7454,7 +7483,7 @@ void plan_arc(
 
   void handle_status_leds(void) {
     float max_temp = 0.0;
-    if (millis() > next_status_led_update_ms) {
+    if (ELAPSED(millis(), next_status_led_update_ms)) {
       next_status_led_update_ms += 500; // Update every 0.5s
       for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder)
         max_temp = max(max(max_temp, degHotend(cur_extruder)), degTargetHotend(cur_extruder));
@@ -7533,9 +7562,9 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   millis_t ms = millis();
 
-  if (max_inactive_time && ms > previous_cmd_ms + max_inactive_time) kill(PSTR(MSG_KILLED));
+  if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) kill(PSTR(MSG_KILLED));
 
-  if (stepper_inactive_time && ms > previous_cmd_ms + stepper_inactive_time
+  if (stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
       && !ignore_stepper_queue && !blocks_queued()) {
     #if ENABLED(DISABLE_INACTIVE_X)
       disable_x();
@@ -7555,7 +7584,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
-    if (chdkActive && ms > chdkHigh + CHDK_DELAY) {
+    if (chdkActive && PENDING(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }
@@ -7601,7 +7630,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
-    if (ms > previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000)
+    if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL))
       if (degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
         bool oldstatus;
         switch (active_extruder) {
@@ -7662,7 +7691,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
-    if (delayed_move_time && ms > delayed_move_time + 1000 && IsRunning()) {
+    if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       set_destination_to_current();
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index b1a9c7b..901da3b 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -34,8 +34,8 @@
  * release we will stop supporting old IDE versions and will require user
  * action to proceed with compilation in such environments.
  */
-#if !defined(ARDUINO) || ARDUINO < 10500
-  #warning Versions of Arduino IDE prior to 1.5 are no longer supported, please update your toolkit.
+#if !defined(ARDUINO) || ARDUINO < 10600
+  #error Versions of Arduino IDE prior to 1.6.0 are no longer supported, please update your toolkit.
 #endif
 
 /**
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index eabf7b0..fbe4ae7 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -508,7 +508,7 @@ void CardReader::write_command(char *buf) {
 }
 
 void CardReader::checkautostart(bool force) {
-  if (!force && (!autostart_stilltocheck || next_autostart_ms < millis()))
+  if (!force && (!autostart_stilltocheck || ELAPSED(millis(), next_autostart_ms)))
     return;
 
   autostart_stilltocheck = false;
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 4da13cd..90b0e68 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -459,7 +459,7 @@ static void lcd_implementation_status_screen() {
   #if DISABLED(FILAMENT_LCD_DISPLAY)
     lcd_print(lcd_status_message);
   #else
-    if (millis() < previous_lcd_status_ms + 5000) {  //Display both Status message line and Filament display on the last line
+    if (PENDING(millis(), previous_lcd_status_ms + 5000)) {  //Display both Status message line and Filament display on the last line
       lcd_print(lcd_status_message);
     }
     else {
diff --git a/Marlin/language_cn.h b/Marlin/language_cn.h
index 3473d73..c19fa82 100644
--- a/Marlin/language_cn.h
+++ b/Marlin/language_cn.h
@@ -149,7 +149,7 @@
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Endstop abort"
 #define MSG_HEATING_FAILED_LCD              "Heating failed"
-#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
 #define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
 #define MSG_ERR_MAXTEMP                     "Err: MAXTEMP"
 #define MSG_ERR_MINTEMP                     "Err: MINTEMP"
diff --git a/Marlin/language_de.h b/Marlin/language_de.h
index ef8efd7..ccdec82 100644
--- a/Marlin/language_de.h
+++ b/Marlin/language_de.h
@@ -164,6 +164,16 @@
 #define MSG_HEATING_COMPLETE                "Aufgeheizt"
 #define MSG_BED_HEATING                     "Bett aufheizen"
 #define MSG_BED_DONE                        "Bett aufgeheizt"
+#define MSG_EXTRUDE                         "Extrudieren"
+#define MSG_BED_Z                           "Bett Z"
+#define MSG_A_TRAVEL                        "A Rueckzug"
+#define MSG_HEATING_FAILED_LCD              "Heizen fehlgesch."
+#define MSG_ERR_REDUNDANT_TEMP              "Redund. Temperaturabw."
+#define MSG_THERMAL_RUNAWAY                 "Temp. n. erreicht"
+#define MSG_ERR_MAXTEMP                     "Temp. ueberschritten"
+#define MSG_ERR_MAXTEMP                     "Temp. unterschritten"
+#define MSG_ERR_MAXTEMP_BED                 "Temp. Bett ueberschr."
+#define MSG_ERR_MAXTEMP_BED                 "Temp. Bett unterschr."
 
 #define MSG_DELTA_CALIBRATE                 "Delta kalibrieren"
 #define MSG_DELTA_CALIBRATE_X               "Kalibriere X"
diff --git a/Marlin/language_en.h b/Marlin/language_en.h
index dae6ea2..74da3cd 100644
--- a/Marlin/language_en.h
+++ b/Marlin/language_en.h
@@ -452,7 +452,7 @@
   #define MSG_HEATING_FAILED_LCD              "Heating failed"
 #endif
 #ifndef MSG_ERR_REDUNDANT_TEMP
-  #define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"
+  #define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
 #endif
 #ifndef MSG_THERMAL_RUNAWAY
   #define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
diff --git a/Marlin/language_kana.h b/Marlin/language_kana.h
index 6c81019..9827238 100644
--- a/Marlin/language_kana.h
+++ b/Marlin/language_kana.h
@@ -154,7 +154,7 @@
 #define MSG_BABYSTEP_Z                      "Z\xbc\xde\xb8\x20\xcb\xde\xc4\xde\xb3"                         // "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "\xb4\xdd\xc4\xde\xbd\xc4\xaf\xcc\xdf\x20\xbb\xc4\xde\xb3"      // "Endstop abort"
 #define MSG_HEATING_FAILED_LCD              "\xb6\xc8\xc2\xbc\xaf\xca\xde\xb2"                              // "Heating failed"
-#define MSG_ERR_REDUNDANT_TEMP              "\xb4\xd7\xb0:\xbc\xde\xae\xb3\xc1\xae\xb3\xbb\xb0\xd0\xbd\xc0\xb0\xb7\xc9\xb3" // "Err: REDUNDANT TEMP ERROR"
+#define MSG_ERR_REDUNDANT_TEMP              "\xb4\xd7\xb0:\xbc\xde\xae\xb3\xc1\xae\xb3\xbb\xb0\xd0\xbd\xc0\xb0\xb7\xc9\xb3" // "Err: REDUNDANT TEMP"
 #define MSG_THERMAL_RUNAWAY                 "\xc8\xc2\xce\xde\xb3\xbf\xb3"                                                  // "THERMAL RUNAWAY"
 #define MSG_ERR_MAXTEMP                     "\xb4\xd7\xb0:\xbb\xb2\xba\xb3\xb5\xdd\xc1\xae\xb3\xb6"                         // "Err: MAXTEMP"
 #define MSG_ERR_MINTEMP                     "\xb4\xd7\xb0:\xbb\xb2\xc3\xb2\xb5\xdd\xd0\xcf\xdd"                             // "Err: MINTEMP"
diff --git a/Marlin/language_kana_utf8.h b/Marlin/language_kana_utf8.h
index da420a5..cebe621 100644
--- a/Marlin/language_kana_utf8.h
+++ b/Marlin/language_kana_utf8.h
@@ -158,7 +158,7 @@
 #define MSG_BABYSTEP_Z                      "Zジク ビドウ"                  // "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "エンドストップ サドウ"            // "Endstop abort"
 #define MSG_HEATING_FAILED_LCD              "カネツシッパイ"                 // "Heating failed"
-#define MSG_ERR_REDUNDANT_TEMP              "エラー:ジョウチョウサーミスターキノウ"  // "Err: REDUNDANT TEMP ERROR"
+#define MSG_ERR_REDUNDANT_TEMP              "エラー:ジョウチョウサーミスターキノウ"  // "Err: REDUNDANT TEMP"
 #define MSG_THERMAL_RUNAWAY                 "ネツボウソウ"                   // "THERMAL RUNAWAY"
 #define MSG_ERR_MAXTEMP                     "エラー:サイコウオンチョウカ"         // "Err: MAXTEMP"
 #define MSG_ERR_MINTEMP                     "エラー:サイテイオンミマン"          // "Err: MINTEMP"
diff --git a/Marlin/language_pt-br.h b/Marlin/language_pt-br.h
index 38f23d0..6058641 100644
--- a/Marlin/language_pt-br.h
+++ b/Marlin/language_pt-br.h
@@ -151,6 +151,20 @@
 #define MSG_END_HOUR                        "Horas"
 #define MSG_END_MINUTE                      "Minutos"
 
+#define MSG_BED_Z                           "Base Z"
+#define MSG_A_TRAVEL                        "A-movimento"
+#define MSG_HEATING_FAILED_LCD              "Aquecimento falhou"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
+#define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
+#define MSG_ERR_MAXTEMP                     "Err: T Maxima"
+#define MSG_ERR_MINTEMP                     "Err: T Minima"
+#define MSG_ERR_MAXTEMP_BED                 "Err: T Base Maxima"
+#define MSG_ERR_MINTEMP_BED                 "Err: T Base Minima"
+#define MSG_HEATING                         "Aquecendo..."
+#define MSG_HEATING_COMPLETE                "Aquecida."
+#define MSG_BED_HEATING                     "Aquecendo base.."
+#define MSG_BED_DONE                        "Base aquecida."
+
 #if ENABLED(DELTA_CALIBRATION_MENU)
   #define MSG_DELTA_CALIBRATE               "Calibrar Delta"
   #define MSG_DELTA_CALIBRATE_X             "Calibrar X"
diff --git a/Marlin/language_pt-br_utf8.h b/Marlin/language_pt-br_utf8.h
index ea92ab1..ba8076d 100644
--- a/Marlin/language_pt-br_utf8.h
+++ b/Marlin/language_pt-br_utf8.h
@@ -151,6 +151,20 @@
 #define MSG_END_HOUR                        "Horas"
 #define MSG_END_MINUTE                      "Minutos"
 
+#define MSG_BED_Z                           "Base Z"
+#define MSG_A_TRAVEL                        "A-movimento"
+#define MSG_HEATING_FAILED_LCD              "Aquecimento falhou"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
+#define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
+#define MSG_ERR_MAXTEMP                     "Err: T Máxima"
+#define MSG_ERR_MINTEMP                     "Err: T Mínima"
+#define MSG_ERR_MAXTEMP_BED                 "Err: T Base Máxima"
+#define MSG_ERR_MINTEMP_BED                 "Err: T Base Mínima"
+#define MSG_HEATING                         "Aquecendo..."
+#define MSG_HEATING_COMPLETE                "Aquecida."
+#define MSG_BED_HEATING                     "Aquecendo base.."
+#define MSG_BED_DONE                        "Base aquecida."
+
 #if ENABLED(DELTA_CALIBRATION_MENU)
   #define MSG_DELTA_CALIBRATE               "Calibrar Delta"
   #define MSG_DELTA_CALIBRATE_X             "Calibrar X"
diff --git a/Marlin/language_pt.h b/Marlin/language_pt.h
index 07bbd9d..6856341 100644
--- a/Marlin/language_pt.h
+++ b/Marlin/language_pt.h
@@ -155,7 +155,7 @@
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Fim de curso"
 #define MSG_HEATING_FAILED_LCD              "Aquecimento falhou"
-#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
 #define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
 #define MSG_ERR_MAXTEMP                     "Err: T Maxima"
 #define MSG_ERR_MINTEMP                     "Err: T Minima"
diff --git a/Marlin/language_pt_utf8.h b/Marlin/language_pt_utf8.h
index c20069c..d4f9bc2 100644
--- a/Marlin/language_pt_utf8.h
+++ b/Marlin/language_pt_utf8.h
@@ -155,7 +155,7 @@
 #define MSG_BABYSTEP_Z                      "Babystep Z"
 #define MSG_ENDSTOP_ABORT                   "Fim de curso"
 #define MSG_HEATING_FAILED_LCD              "Aquecimento falhou"
-#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"
+#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP"
 #define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"
 #define MSG_ERR_MAXTEMP                     "Err: T Máxima"
 #define MSG_ERR_MINTEMP                     "Err: T Mínima"
diff --git a/Marlin/macros.h b/Marlin/macros.h
index be5e8cf..5f53ee9 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -57,4 +57,7 @@
 
 #define PIN_EXISTS(PN) (defined(PN ##_PIN) && PN ##_PIN >= 0)
 
+#define PENDING(NOW,SOON) ((long)(NOW-(SOON))<0)
+#define ELAPSED(NOW,SOON) (!PENDING(NOW,SOON))
+
 #endif //__MACROS_H
diff --git a/Marlin/pins_MEGATRONICS_3.h b/Marlin/pins_MEGATRONICS_3.h
index c60f3c6..46f9880 100644
--- a/Marlin/pins_MEGATRONICS_3.h
+++ b/Marlin/pins_MEGATRONICS_3.h
@@ -39,7 +39,7 @@
 #define SERVO0_PIN         46 //AUX3-6
 #define SERVO1_PIN         47 //AUX3-5
 #define SERVO2_PIN         48 //AUX3-4
-#define SERVO2_PIN         49 //AUX3-3
+#define SERVO3_PIN         49 //AUX3-3
 
 #define X_STEP_PIN         58
 #define X_DIR_PIN          57
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 318b5bd..ae2b66d 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -491,7 +491,7 @@ void check_axes_activity() {
             fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
             tail_fan_speed[f] = 255; \
           } else { \
-            if (fan_kick_end[f] > ms) { \
+            if (PENDING(ms, fan_kick_end[f])) { \
               tail_fan_speed[f] = 255; \
             } \
           } \
@@ -568,7 +568,7 @@ float junction_deviation = 0.1;
   while (block_buffer_tail == next_buffer_head) idle();
 
   #if ENABLED(MESH_BED_LEVELING)
-    if (mbl.active) z += mbl.get_z(x, y);
+    if (mbl.active) z += mbl.get_z(x - home_offset[X_AXIS], y - home_offset[Y_AXIS]);
   #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
     apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
   #endif
@@ -1090,6 +1090,12 @@ float junction_deviation = 0.1;
 } // plan_buffer_line()
 
 #if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(DELTA)
+
+  /**
+   * Get the XYZ position of the steppers as a vector_3.
+   *
+   * On CORE machines XYZ is derived from ABC.
+   */
   vector_3 plan_get_position() {
     vector_3 position = vector_3(st_get_axis_position_mm(X_AXIS), st_get_axis_position_mm(Y_AXIS), st_get_axis_position_mm(Z_AXIS));
 
@@ -1102,8 +1108,14 @@ float junction_deviation = 0.1;
 
     return position;
   }
+
 #endif // AUTO_BED_LEVELING_FEATURE && !DELTA
 
+/**
+ * Directly set the planner XYZ position (hence the stepper positions).
+ *
+ * On CORE machines stepper ABC will be translated from the given XYZ.
+ */
 #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
   void plan_set_position(float x, float y, float z, const float& e)
 #else
@@ -1111,7 +1123,7 @@ float junction_deviation = 0.1;
 #endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING
   {
     #if ENABLED(MESH_BED_LEVELING)
-      if (mbl.active) z += mbl.get_z(x, y);
+      if (mbl.active) z += mbl.get_z(x - home_offset[X_AXIS], y - home_offset[Y_AXIS]);
     #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
       apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
     #endif
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index a371361..f8f9312 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -1084,11 +1084,36 @@ void st_init() {
  */
 void st_synchronize() { while (blocks_queued()) idle(); }
 
+/**
+ * Set the stepper positions directly in steps
+ *
+ * The input is based on the typical per-axis XYZ steps.
+ * For CORE machines XYZ needs to be translated to ABC.
+ *
+ * This allows st_get_axis_position_mm to correctly
+ * derive the current XYZ position later on.
+ */
 void st_set_position(const long& x, const long& y, const long& z, const long& e) {
   CRITICAL_SECTION_START;
-  count_position[X_AXIS] = x;
-  count_position[Y_AXIS] = y;
-  count_position[Z_AXIS] = z;
+
+  #if ENABLED(COREXY)
+    // corexy positioning
+    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
+    count_position[A_AXIS] = x + y;
+    count_position[B_AXIS] = x - y;
+    count_position[Z_AXIS] = z;
+  #elif ENABLED(COREXZ)
+    // corexz planning
+    count_position[A_AXIS] = x + z;
+    count_position[Y_AXIS] = y;
+    count_position[C_AXIS] = x - z;
+  #else
+    // default non-h-bot planning
+    count_position[X_AXIS] = x;
+    count_position[Y_AXIS] = y;
+    count_position[Z_AXIS] = z;
+  #endif
+
   count_position[E_AXIS] = e;
   CRITICAL_SECTION_END;
 }
@@ -1099,15 +1124,22 @@ void st_set_e_position(const long& e) {
   CRITICAL_SECTION_END;
 }
 
-long st_get_position(uint8_t axis) {
+/**
+ * Get a stepper's position in steps.
+ */
+long st_get_position(AxisEnum axis) {
   CRITICAL_SECTION_START;
   long count_pos = count_position[axis];
   CRITICAL_SECTION_END;
   return count_pos;
 }
 
+/**
+ * Get an axis position according to stepper position(s)
+ * For CORE machines apply translation from ABC to XYZ.
+ */
 float st_get_axis_position_mm(AxisEnum axis) {
-  float axis_pos;
+  float axis_steps;
   #if ENABLED(COREXY) | ENABLED(COREXZ)
     if (axis == X_AXIS || axis == CORE_AXIS_2) {
       CRITICAL_SECTION_START;
@@ -1116,14 +1148,14 @@ float st_get_axis_position_mm(AxisEnum axis) {
       CRITICAL_SECTION_END;
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
-      axis_pos = (pos1 + ((axis == X_AXIS) ? pos2 : -pos2)) / 2.0f;
+      axis_steps = (pos1 + ((axis == X_AXIS) ? pos2 : -pos2)) / 2.0f;
     }
     else
-      axis_pos = st_get_position(axis);
+      axis_steps = st_get_position(axis);
   #else
-    axis_pos = st_get_position(axis);
+    axis_steps = st_get_position(axis);
   #endif
-  return axis_pos / axis_steps_per_unit[axis];
+  return axis_steps / axis_steps_per_unit[axis];
 }
 
 void finishAndDisableSteppers() {
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index aecbf58..b0230b8 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -61,7 +61,7 @@ void st_set_position(const long& x, const long& y, const long& z, const long& e)
 void st_set_e_position(const long& e);
 
 // Get current position in steps
-long st_get_position(uint8_t axis);
+long st_get_position(AxisEnum axis);
 
 // Get current axis position in mm
 float st_get_axis_position_mm(AxisEnum axis);
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index d9a5895..c99eea3 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -235,7 +235,7 @@ void PID_autotune(float temp, int extruder, int ncycles, bool set_result/*=false
   float max = 0, min = 10000;
 
   #if HAS_AUTO_FAN
-    millis_t next_auto_fan_check_ms = temp_ms + 2500;
+    millis_t next_auto_fan_check_ms = temp_ms + 2500UL;
   #endif
 
   if (extruder >= EXTRUDERS
@@ -270,14 +270,14 @@ void PID_autotune(float temp, int extruder, int ncycles, bool set_result/*=false
       min = min(min, input);
 
       #if HAS_AUTO_FAN
-        if (ms > next_auto_fan_check_ms) {
+        if (ELAPSED(ms, next_auto_fan_check_ms)) {
           checkExtruderAutoFans();
-          next_auto_fan_check_ms = ms + 2500;
+          next_auto_fan_check_ms = ms + 2500UL;
         }
       #endif
 
       if (heating && input > temp) {
-        if (ms > t2 + 5000) {
+        if (ELAPSED(ms, t2 + 5000UL)) {
           heating = false;
           if (extruder < 0)
             soft_pwm_bed = (bias - d) >> 1;
@@ -290,7 +290,7 @@ void PID_autotune(float temp, int extruder, int ncycles, bool set_result/*=false
       }
 
       if (!heating && input < temp) {
-        if (ms > t1 + 5000) {
+        if (ELAPSED(ms, t1 + 5000UL)) {
           heating = true;
           t2 = ms;
           t_low = t2 - t1;
@@ -349,7 +349,7 @@ void PID_autotune(float temp, int extruder, int ncycles, bool set_result/*=false
       return;
     }
     // Every 2 seconds...
-    if (ms > temp_ms + 2000) {
+    if (ELAPSED(ms, temp_ms + 2000UL)) {
       #if HAS_TEMP_HOTEND || HAS_TEMP_BED
         print_heaterstates();
         SERIAL_EOL;
@@ -673,7 +673,7 @@ void manage_heater() {
     #if ENABLED(THERMAL_PROTECTION_HOTENDS)
 
       // Is it time to check this extruder's heater?
-      if (watch_heater_next_ms[e] && ms > watch_heater_next_ms[e]) {
+      if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) {
         // Has it failed to increase enough?
         if (degHotend(e) < watch_target_temp[e]) {
           // Stop!
@@ -696,9 +696,9 @@ void manage_heater() {
   } // Extruders Loop
 
   #if HAS_AUTO_FAN
-    if (ms > next_auto_fan_check_ms) { // only need to check fan state very infrequently
+    if (ELAPSED(ms > next_auto_fan_check_ms)) { // only need to check fan state very infrequently
       checkExtruderAutoFans();
-      next_auto_fan_check_ms = ms + 2500;
+      next_auto_fan_check_ms = ms + 2500UL;
     }
   #endif
 
@@ -718,7 +718,7 @@ void manage_heater() {
   #endif //FILAMENT_WIDTH_SENSOR
 
   #if DISABLED(PIDTEMPBED)
-    if (ms < next_bed_check_ms) return;
+    if (PENDING(ms, next_bed_check_ms)) return;
     next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   #endif
 
@@ -1105,7 +1105,7 @@ void tp_init() {
   void start_watching_heater(int e) {
     if (degHotend(e) < degTargetHotend(e) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
       watch_target_temp[e] = degHotend(e) + WATCH_TEMP_INCREASE;
-      watch_heater_next_ms[e] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
+      watch_heater_next_ms[e] = millis() + (WATCH_TEMP_PERIOD) * 1000;
     }
     else
       watch_heater_next_ms[e] = 0;
@@ -1160,7 +1160,7 @@ void tp_init() {
         if (temperature >= tr_target_temperature[heater_index] - hysteresis_degc)
           *timer = millis();
         // If the timer goes too long without a reset, trigger shutdown
-        else if (millis() > *timer + period_seconds * 1000UL)
+        else if (ELAPSED(millis(), *timer + period_seconds * 1000UL))
           *state = TRRunaway;
         break;
       case TRRunaway:
@@ -1232,7 +1232,7 @@ void disable_all_heaters() {
 
     millis_t ms = millis();
 
-    if (ms < next_max6675_ms) return (int)max6675_temp;
+    if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
 
     next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
 
diff --git a/Marlin/twibus.cpp b/Marlin/twibus.cpp
index 3131060..84d69df 100644
--- a/Marlin/twibus.cpp
+++ b/Marlin/twibus.cpp
@@ -77,12 +77,12 @@ void TWIBus::reqbytes(uint8_t bytes) {
     SERIAL_EOL;
   }
 
-  millis_t t = millis();
+  millis_t t = millis() + this->timeout;
   Wire.requestFrom(this->addr, bytes);
 
     // requestFrom() is a blocking function
   while (Wire.available() < bytes) {
-    if (millis() - t >= this->timeout) break;
+    if (ELAPSED(millis(), t)) break;
     else continue;
   }
 
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 7a9273f..652a1d4 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -369,7 +369,7 @@ static void lcd_status_screen() {
   #if ENABLED(LCD_PROGRESS_BAR)
     millis_t ms = millis();
     #if DISABLED(PROGRESS_MSG_ONCE)
-      if (ms > progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {
+      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME)) {
         progress_bar_ms = ms;
       }
     #endif
@@ -380,7 +380,7 @@ static void lcd_status_screen() {
           if (card.isFileOpen()) {
             // Expire the message when printing is active
             if (IS_SD_PRINTING) {
-              if (ms >= expire_status_ms) {
+              if (ELAPSED(ms, expire_status_ms)) {
                 lcd_status_message[0] = '\0';
                 expire_status_ms = 0;
               }
@@ -2025,7 +2025,7 @@ bool lcd_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
-  if (ms >= next_blink_ms) {
+  if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - LCD_UPDATE_INTERVAL / 2;
   }
@@ -2094,7 +2094,7 @@ void lcd_update() {
   #endif //SDSUPPORT && SD_DETECT_PIN
 
   millis_t ms = millis();
-  if (ms > next_lcd_update_ms) {
+  if (ELAPSED(ms, next_lcd_update_ms)) {
 
     #if ENABLED(LCD_HAS_SLOW_BUTTONS)
       slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
@@ -2343,7 +2343,7 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
         millis_t now = millis();
       #endif
       #if ENABLED(RIGIDBOT_PANEL)
-        if (now > next_button_update_ms) {
+        if (ELAPSED(now, next_button_update_ms)) {
           if (BUTTON_PRESSED(UP)) {
             encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM);
             next_button_update_ms = now + 300;
@@ -2363,7 +2363,7 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
         }
       #endif
       #if BUTTON_EXISTS(ENC)
-        if (now > next_button_update_ms && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+        if (ELAPSED(now, next_button_update_ms) && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
       #endif
       buttons = newbutton;
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index 26399fb..a0efa4b 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -741,7 +741,7 @@ static void lcd_implementation_status_screen() {
     if (card.isFileOpen()) {
       // Draw the progress bar if the message has shown long enough
       // or if there is no message set.
-      if (millis() >= progress_bar_ms + PROGRESS_BAR_MSG_TIME || !lcd_status_message[0]) {
+      if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !lcd_status_message[0]) {
         int tix = (int)(card.percentDone() * (LCD_WIDTH) * 3) / 100,
           cel = tix / 3, rem = tix % 3, i = LCD_WIDTH;
         char msg[LCD_WIDTH + 1], b = ' ';
@@ -762,7 +762,7 @@ static void lcd_implementation_status_screen() {
 
     // Show Filament Diameter and Volumetric Multiplier %
     // After allowing lcd_status_message to show for 5 seconds
-    if (millis() >= previous_lcd_status_ms + 5000) {
+    if (ELAPSED(millis(), previous_lcd_status_ms + 5000)) {
       lcd_printPGM(PSTR("Dia "));
       lcd.print(ftostr12ns(filament_width_meas));
       lcd_printPGM(PSTR(" V"));
@@ -930,7 +930,7 @@ void lcd_implementation_drawedit(const char* pstr, const char* value) {
       // so they are called during normal lcd_update
       uint8_t slow_bits = lcd.readButtons() << B_I2C_BTN_OFFSET;
       #if ENABLED(LCD_I2C_VIKI)
-        if ((slow_bits & (B_MI | B_RI)) && millis() < next_button_update_ms) // LCD clicked
+        if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
           slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
       #endif // LCD_I2C_VIKI
       return slow_bits;

