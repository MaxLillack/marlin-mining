commit b2a9ccdb9783f2c6b0408f712daede0e06ab490c (from d459fb41b7eba70cb51841fb793baee6d67d2e52)
Merge: d459fb4 b51c06e
Author: ErikZalm <erik@vdzalm.eu>
Date:   Wed May 16 12:32:35 2012 -0700

    Merge pull request #159 from MaikStohn/Marlin_v1
    
    Marlin v1 - BUG FIXES / CORRECTIONS

diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index 1f29087..c9cff67 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -300,6 +300,8 @@ void setup()
   st_init();    // Initialize stepper;
   wd_init();
   setup_photpin();
+  
+  LCD_INIT;
 }
 
 
@@ -687,7 +689,6 @@ void process_commands()
         st_synchronize();
       for(int8_t i=0; i < NUM_AXIS; i++) {
         if(code_seen(axis_codes[i])) { 
-           current_position[i] = code_value()+add_homeing[i];  
            if(i == E_AXIS) {
              current_position[i] = code_value();  
              plan_set_e_position(current_position[E_AXIS]);
@@ -1246,7 +1247,7 @@ void process_commands()
      }
     break;
       
-    case 302: // finish all moves
+    case 302: // allow cold extrudes
     {
       allow_cold_extrudes(true);
     }
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 253149c..b01368b 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -7,6 +7,7 @@
   void lcd_init();
   void lcd_status(const char* message);
   void beep();
+  void buttons_init();
   void buttons_check();
 
   #define LCD_UPDATE_INTERVAL 100
@@ -69,7 +70,7 @@
     void showAxisMove();
     void showSD();
     bool force_lcd_update;
-    int lastencoderpos;
+    long lastencoderpos;
     int8_t lineoffset;
     int8_t lastlineoffset;
     
@@ -78,11 +79,11 @@
     bool tune;
     
   private:
-    FORCE_INLINE void updateActiveLines(const uint8_t &maxlines,volatile int &encoderpos)
+    FORCE_INLINE void updateActiveLines(const uint8_t &maxlines,volatile long &encoderpos)
     {
       if(linechanging) return; // an item is changint its value, do not switch lines hence
       lastlineoffset=lineoffset; 
-      int curencoderpos=encoderpos;  
+      long curencoderpos=encoderpos;  
       force_lcd_update=false;
       if(  (abs(curencoderpos-lastencoderpos)<lcdslow) ) 
       { 
@@ -134,11 +135,12 @@
   char *ftostr3(const float &x);
 
 
-
+  #define LCD_INIT lcd_init();
   #define LCD_MESSAGE(x) lcd_status(x);
   #define LCD_MESSAGEPGM(x) lcd_statuspgm(MYPGM(x));
   #define LCD_STATUS lcd_status()
 #else //no lcd
+  #define LCD_INIT
   #define LCD_STATUS
   #define LCD_MESSAGE(x)
   #define LCD_MESSAGEPGM(x)
diff --git a/Marlin/ultralcd.pde b/Marlin/ultralcd.pde
index c6cd15b..69364ac 100644
--- a/Marlin/ultralcd.pde
+++ b/Marlin/ultralcd.pde
@@ -1,6 +1,9 @@
 #include "ultralcd.h"
 #ifdef ULTRA_LCD
 #include "Marlin.h"
+#include "language.h"
+#include "temperature.h"
+#include "EEPROMwrite.h"
 #include <LiquidCrystal.h>
 //===========================================================================
 //=============================imported variables============================
@@ -13,6 +16,7 @@ extern volatile int extrudemultiply;
 
 extern long position[4];   
 #ifdef SDSUPPORT
+#include "cardreader.h"
 extern CardReader card;
 #endif
 
@@ -20,7 +24,7 @@ extern CardReader card;
 //=============================public variables============================
 //===========================================================================
 volatile char buttons=0;  //the last checked buttons in a bit array.
-int encoderpos=0;
+long encoderpos=0;
 short lastenc=0;
 
 
@@ -95,6 +99,9 @@ FORCE_INLINE void clear()
 void lcd_init()
 {
   //beep();
+  #ifdef ULTIPANEL
+    buttons_init();
+  #endif
   
   byte Degree[8] =
   {
@@ -302,10 +309,6 @@ MainMenu::MainMenu()
   displayStartingRow=0;
   activeline=0;
   force_lcd_update=true;
-  #ifdef ULTIPANEL
-    buttons_init();
-  #endif
-  lcd_init();
   linechanging=false;
   tune=false;
 }
@@ -881,7 +884,7 @@ void MainMenu::showTune()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(MSG_FLOW);
-          lcd.setCursor(13,line);lcd.print(itostr4(axis_steps_per_unit[3]));
+          lcd.setCursor(13,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
         }
         
         if((activeline!=line) )
@@ -892,14 +895,14 @@ void MainMenu::showTune()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)axis_steps_per_unit[3];
+              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
           }
           else
           {
-            float factor=float(encoderpos)/float(axis_steps_per_unit[3]);
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
             position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[3]*=factor;
-            axis_steps_per_unit[E_AXIS]= encoderpos;
+            //current_position[E_AXIS]*=factor;
+            axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
             encoderpos=activeline*lcdslow;
               
           }
@@ -909,8 +912,8 @@ void MainMenu::showTune()
         if(linechanging)
         {
           if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
-          lcd.setCursor(13,line);lcd.print(itostr4(encoderpos));
+          if(encoderpos>999999) encoderpos=999999;
+          lcd.setCursor(13,line);lcd.print(ftostr52(encoderpos/100.0));
         }
         
       }break; 
@@ -1293,7 +1296,7 @@ void MainMenu::showControlTemp()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)Kp;
+              encoderpos=(long)Kp;
           }
           else
           {
@@ -1328,7 +1331,7 @@ void MainMenu::showControlTemp()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(Ki*10/PID_dT);
+              encoderpos=(long)(Ki*10/PID_dT);
           }
           else
           {
@@ -1364,7 +1367,7 @@ void MainMenu::showControlTemp()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(Kd/5./PID_dT);
+              encoderpos=(long)(Kd/5./PID_dT);
           }
           else
           {
@@ -1400,7 +1403,7 @@ void MainMenu::showControlTemp()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)Kc;
+              encoderpos=(long)Kc;
           }
           else
           {
@@ -1473,7 +1476,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)acceleration/100;
+              encoderpos=(long)acceleration/100;
           }
           else
           {
@@ -1507,7 +1510,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)max_xy_jerk;
+              encoderpos=(long)max_xy_jerk;
           }
           else
           {
@@ -1550,7 +1553,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)max_feedrate[i-ItemCM_vmaxx];
+              encoderpos=(long)max_feedrate[i-ItemCM_vmaxx];
           }
           else
           {
@@ -1586,7 +1589,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(minimumfeedrate);
+              encoderpos=(long)(minimumfeedrate);
           }
           else
           {
@@ -1621,7 +1624,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)mintravelfeedrate;
+              encoderpos=(long)mintravelfeedrate;
           }
           else
           {
@@ -1664,7 +1667,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
+              encoderpos=(long)max_acceleration_units_per_sq_second[i-ItemCM_amaxx]/100;
           }
           else
           {
@@ -1698,7 +1701,7 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)retract_acceleration/100;
+              encoderpos=(long)retract_acceleration/100;
           }
           else
           {
@@ -1722,7 +1725,7 @@ void MainMenu::showControlMotion()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(MSG_XSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[0]));
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[X_AXIS]));
         }
         
         if((activeline!=line) )
@@ -1733,13 +1736,13 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(axis_steps_per_unit[0]*100.0);
+              encoderpos=(long)(axis_steps_per_unit[X_AXIS]*100.0);
           }
           else
           {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[0]);
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[X_AXIS]);
             position[X_AXIS]=lround(position[X_AXIS]*factor);
-            //current_position[3]*=factor;
+            //current_position[X_AXIS]*=factor;
             axis_steps_per_unit[X_AXIS]= encoderpos/100.0;
             encoderpos=activeline*lcdslow;
           }
@@ -1749,7 +1752,7 @@ void MainMenu::showControlMotion()
         if(linechanging)
         {
           if(encoderpos<5) encoderpos=5;
-          if(encoderpos>32000) encoderpos=32000;//TODO: This is a problem, encoderpos is 16bit, but steps_per_unit for e can be wel over 800
+          if(encoderpos>999999) encoderpos=999999;
           lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
         }
         
@@ -1759,7 +1762,7 @@ void MainMenu::showControlMotion()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(MSG_YSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[1]));
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Y_AXIS]));
         }
         
         if((activeline!=line) )
@@ -1770,13 +1773,13 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(axis_steps_per_unit[1]*100.0);
+              encoderpos=(long)(axis_steps_per_unit[Y_AXIS]*100.0);
           }
           else
           {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[1]);
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Y_AXIS]);
             position[Y_AXIS]=lround(position[Y_AXIS]*factor);
-            //current_position[3]*=factor;
+            //current_position[Y_AXIS]*=factor;
             axis_steps_per_unit[Y_AXIS]= encoderpos/100.0;
             encoderpos=activeline*lcdslow;
               
@@ -1787,7 +1790,7 @@ void MainMenu::showControlMotion()
         if(linechanging)
         {
           if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
+          if(encoderpos>999999) encoderpos=999999;
           lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
         }
         
@@ -1797,7 +1800,7 @@ void MainMenu::showControlMotion()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(MSG_ZSTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[2]));
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[Z_AXIS]));
         }
         
         if((activeline!=line) )
@@ -1808,13 +1811,13 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(axis_steps_per_unit[2]*100.0);
+              encoderpos=(long)(axis_steps_per_unit[Z_AXIS]*100.0);
           }
           else
           {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[2]);
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[Z_AXIS]);
             position[Z_AXIS]=lround(position[Z_AXIS]*factor);
-            //current_position[3]*=factor;
+            //current_position[Z_AXIS]*=factor;
             axis_steps_per_unit[Z_AXIS]= encoderpos/100.0;
             encoderpos=activeline*lcdslow;
               
@@ -1825,7 +1828,7 @@ void MainMenu::showControlMotion()
         if(linechanging)
         {
           if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
+          if(encoderpos>999999) encoderpos=999999;
           lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
         }
         
@@ -1836,7 +1839,7 @@ void MainMenu::showControlMotion()
       if(force_lcd_update)
         {
           lcd.setCursor(0,line);lcdprintPGM(MSG_ESTEPS);
-          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[3]));
+          lcd.setCursor(11,line);lcd.print(ftostr52(axis_steps_per_unit[E_AXIS]));
         }
         
         if((activeline!=line) )
@@ -1847,13 +1850,13 @@ void MainMenu::showControlMotion()
           linechanging=!linechanging;
           if(linechanging)
           {
-              encoderpos=(int)(axis_steps_per_unit[3]*100.0);
+              encoderpos=(long)(axis_steps_per_unit[E_AXIS]*100.0);
           }
           else
           {
-            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[3]);
+            float factor=float(encoderpos)/100.0/float(axis_steps_per_unit[E_AXIS]);
             position[E_AXIS]=lround(position[E_AXIS]*factor);
-            //current_position[3]*=factor;
+            //current_position[E_AXIS]*=factor;
             axis_steps_per_unit[E_AXIS]= encoderpos/100.0;
             encoderpos=activeline*lcdslow;
               
@@ -1864,7 +1867,7 @@ void MainMenu::showControlMotion()
         if(linechanging)
         {
           if(encoderpos<5) encoderpos=5;
-          if(encoderpos>9999) encoderpos=9999;
+          if(encoderpos>999999) encoderpos=999999;
           lcd.setCursor(11,line);lcd.print(ftostr52(encoderpos/100.0));
         }
         
@@ -2105,9 +2108,10 @@ void MainMenu::showMainMenu()
     }
   } 
   clearIfNecessary();
-  for(int8_t line=0;line<LCD_HEIGHT;line++)
+  uint8_t line=0;
+  for(int8_t i=lineoffset;i<lineoffset+LCD_HEIGHT;i++)
   {
-    switch(line)
+    switch(i)
     { 
       case ItemM_watch:
         MENUITEM(  lcdprintPGM(MSG_WATCH)  ,  BLOCK;status=Main_Status;beepshort(); ) ;
@@ -2161,6 +2165,7 @@ void MainMenu::showMainMenu()
         SERIAL_ERRORLNPGM(MSG_SERIAL_ERROR_MENU_STRUCTURE);
       break;
     }
+    line++;
   }
   updateActiveLines(3,encoderpos);
 }
@@ -2378,4 +2383,4 @@ char *ftostr52(const float &x)
 
 #endif //ULTRA_LCD
 
-
+

commit b2a9ccdb9783f2c6b0408f712daede0e06ab490c (from b51c06e2b3a6dde6ea26ce141daf848463d9ff0c)
Merge: d459fb4 b51c06e
Author: ErikZalm <erik@vdzalm.eu>
Date:   Wed May 16 12:32:35 2012 -0700

    Merge pull request #159 from MaikStohn/Marlin_v1
    
    Marlin v1 - BUG FIXES / CORRECTIONS

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index f158767..6c5b974 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -26,6 +26,7 @@
 // Gen6 = 5
 // Gen6 deluxe = 51
 // Sanguinololu 1.2 and above = 62
+// Melzi = 63
 // Ultimaker = 7
 // Teensylu = 8
 // Gen3+ =9
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 0d6b602..95a0369 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -554,7 +554,10 @@
 * Sanguinololu pin assignment
 *
 ****************************************************************************************/
-#if MOTHERBOARD == 62
+#if MOTHERBOARD == 63
+#define MELZI
+#endif
+#if MOTHERBOARD == 62 || MOTHERBOARD == 63
 #undef MOTHERBOARD
 #define MOTHERBOARD 6
 #define SANGUINOLOLU_V_1_2 
@@ -589,6 +592,11 @@
 
 #define FAN_PIN            -1 
 
+#ifdef MELZI
+#define LED_PIN            28
+#define FAN_PIN            4
+#endif
+
 #define PS_ON_PIN          -1
 #define KILL_PIN           -1
 
@@ -621,6 +629,10 @@
 #define SDPOWER            -1
 #define SDSS               31
 
+#ifdef MELZI
+#define SDSS               24
+#endif
+
 #endif
 
 
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index cfb503d..ac9ff19 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -554,8 +554,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;
-  if ( block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0 ) {
-    block->millimeters = abs(delta_mm[E_AXIS]);
+  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments ) {
+    block->millimeters = fabs(delta_mm[E_AXIS]);
   } else {
     block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));
   }
@@ -591,8 +591,8 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
   float speed_factor = 1.0; //factor <=1 do decrease speed
   for(int i=0; i < 4; i++) {
     current_speed[i] = delta_mm[i] * inverse_second;
-    if(abs(current_speed[i]) > max_feedrate[i])
-      speed_factor = min(speed_factor, max_feedrate[i] / abs(current_speed[i]));
+    if(fabs(current_speed[i]) > max_feedrate[i])
+      speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));
   }
 
 // Max segement time in us.
@@ -696,25 +696,25 @@ void plan_buffer_line(const float &x, const float &y, const float &z, const floa
 #endif
   // Start with a safe speed
   float vmax_junction = max_xy_jerk/2;  
-  if(abs(current_speed[Z_AXIS]) > max_z_jerk/2) 
+  if(fabs(current_speed[Z_AXIS]) > max_z_jerk/2) 
     vmax_junction = max_z_jerk/2;
   vmax_junction = min(vmax_junction, block->nominal_speed);
-  if(abs(current_speed[E_AXIS]) > max_e_jerk/2) 
+  if(fabs(current_speed[E_AXIS]) > max_e_jerk/2) 
     vmax_junction = min(vmax_junction, max_e_jerk/2);
     
   if ((moves_queued > 1) && (previous_nominal_speed > 0.0001)) {
     float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));
-    if((abs(previous_speed[X_AXIS]) > 0.0001) || (abs(previous_speed[Y_AXIS]) > 0.0001)) {
+    if((fabs(previous_speed[X_AXIS]) > 0.0001) || (fabs(previous_speed[Y_AXIS]) > 0.0001)) {
       vmax_junction = block->nominal_speed;
     }
     if (jerk > max_xy_jerk) {
       vmax_junction *= (max_xy_jerk/jerk);
     } 
-    if(abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
-      vmax_junction *= (max_z_jerk/abs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
+    if(fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
+      vmax_junction *= (max_z_jerk/fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]));
     } 
-    if(abs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
-      vmax_junction *= (max_e_jerk/abs(current_speed[E_AXIS] - previous_speed[E_AXIS]));
+    if(fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
+      vmax_junction *= (max_e_jerk/fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]));
     } 
   }
   block->max_entry_speed = vmax_junction;

