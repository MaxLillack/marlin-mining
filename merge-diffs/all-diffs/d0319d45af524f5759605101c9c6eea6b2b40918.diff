commit d0319d45af524f5759605101c9c6eea6b2b40918 (from 724f5aa36bcd5e59db7b7eebede16488dba654c4)
Merge: 724f5aa ca409e5
Author: daid <daid303@gmail.com>
Date:   Tue Dec 11 02:59:58 2012 -0800

    Merge pull request #335 from jcrocholl/Marlin_v1
    
    Fix endstop pins for Printrboard

diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 9db8dee..842b060 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -256,8 +256,8 @@ const bool Z_ENDSTOPS_INVERTING = true; // set to true to invert the logic of th
 #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)
 
 // The position of the homing switches
-//#define MANUAL_HOME_POSITIONS  // If defined, manualy programed locations will be used
-//#define BED_CENTER_AT_0_0  // If defined the center of the bed is defined as (0,0)
+//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used
+//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)
 
 //Manual homing switch locations:
 #define MANUAL_X_HOME_POS 0
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index be66d18..b74f74a 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -78,7 +78,7 @@
 
 //// AUTOSET LOCATIONS OF LIMIT SWITCHES
 //// Added by ZetaPhoenix 09-15-2012
-#ifdef MANUAL_HOME_POSITION  //Use manual limit switch locations
+#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations
   #define X_HOME_POS MANUAL_X_HOME_POS
   #define Y_HOME_POS MANUAL_Y_HOME_POS
   #define Z_HOME_POS MANUAL_Z_HOME_POS
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 59f86a5..8e9680b 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -973,19 +973,16 @@
 #define X_STEP_PIN          0
 #define X_DIR_PIN           1
 #define X_ENABLE_PIN       39
-#define X_MIN_PIN          13
 #define X_MAX_PIN          -1
 
 #define Y_STEP_PIN          2
 #define Y_DIR_PIN           3
 #define Y_ENABLE_PIN       38
-#define Y_MIN_PIN          14
 #define Y_MAX_PIN          -1
 
 #define Z_STEP_PIN          4
 #define Z_DIR_PIN           5
 #define Z_ENABLE_PIN       23
-#define Z_MIN_PIN          15
 #define Z_MAX_PIN          -1
 
 #define E0_STEP_PIN         6
@@ -997,11 +994,19 @@
 #define HEATER_2_PIN       -1
 #define HEATER_BED_PIN     20  // Bed
 #define FAN_PIN            22  // Fan
+// You may need to change FAN_PIN to 16 because Marlin isn't using fastio.h
+// for the fan and Teensyduino uses a different pin mapping.
 
-#if MOTHERBOARD == 8
+#if MOTHERBOARD == 8  // Teensylu
+  #define X_MIN_PIN          13
+  #define Y_MIN_PIN          14
+  #define Z_MIN_PIN          15
   #define TEMP_0_PIN          7  // Extruder / Analog pin numbering
   #define TEMP_BED_PIN        6  // Bed / Analog pin numbering
-#else
+#else  // Printrboard
+  #define X_MIN_PIN          35
+  #define Y_MIN_PIN           8
+  #define Z_MIN_PIN          36
   #define TEMP_0_PIN          1  // Extruder / Analog pin numbering
   #define TEMP_BED_PIN        0  // Bed / Analog pin numbering
 #endif

commit d0319d45af524f5759605101c9c6eea6b2b40918 (from ca409e5531d6f96b54ce919aaf41cfad9e565dda)
Merge: 724f5aa ca409e5
Author: daid <daid303@gmail.com>
Date:   Tue Dec 11 02:59:58 2012 -0800

    Merge pull request #335 from jcrocholl/Marlin_v1
    
    Fix endstop pins for Printrboard

diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt b/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt
new file mode 100644
index 0000000..d6fbaee
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/boards.txt
@@ -0,0 +1,101 @@
+##############################################################
+
+Gen7-644-16.name=Gen7 with ATmega644 and 16 MHz
+Gen7-644-16.upload.protocol=stk500v2
+Gen7-644-16.upload.maximum_size=63488
+Gen7-644-16.upload.speed=115200
+Gen7-644-16.bootloader.low_fuses=0xF7
+Gen7-644-16.bootloader.high_fuses=0xD4
+Gen7-644-16.bootloader.extended_fuses=0xFD
+Gen7-644-16.bootloader.path=Gen7
+Gen7-644-16.bootloader.file=bootloader-644-16MHz.hex
+Gen7-644-16.bootloader.unlock_bits=0x3F
+Gen7-644-16.bootloader.lock_bits=0x0F
+Gen7-644-16.build.mcu=atmega644
+Gen7-644-16.build.f_cpu=16000000L
+Gen7-644-16.build.core=arduino
+
+##############################################################
+
+Gen7-644-20.name=Gen7 with ATmega644 and 20 MHz
+Gen7-644-20.upload.protocol=stk500v2
+Gen7-644-20.upload.maximum_size=63488
+Gen7-644-20.upload.speed=115200
+Gen7-644-20.bootloader.low_fuses=0xF7
+Gen7-644-20.bootloader.high_fuses=0xD4
+Gen7-644-20.bootloader.extended_fuses=0xFD
+Gen7-644-20.bootloader.path=Gen7
+Gen7-644-20.bootloader.file=bootloader-644-20MHz.hex
+Gen7-644-20.bootloader.unlock_bits=0x3F
+Gen7-644-20.bootloader.lock_bits=0x0F
+Gen7-644-20.build.mcu=atmega644
+Gen7-644-20.build.f_cpu=20000000L
+Gen7-644-20.build.core=arduino
+
+##############################################################
+
+Gen7-644P-16.name=Gen7 with ATmega644P and 16 MHz
+Gen7-644P-16.upload.protocol=stk500v2
+Gen7-644P-16.upload.maximum_size=63488
+Gen7-644P-16.upload.speed=115200
+Gen7-644P-16.bootloader.low_fuses=0xF7
+Gen7-644P-16.bootloader.high_fuses=0xD4
+Gen7-644P-16.bootloader.extended_fuses=0xFD
+Gen7-644P-16.bootloader.path=Gen7
+Gen7-644P-16.bootloader.file=bootloader-644P-16MHz.hex
+Gen7-644P-16.bootloader.unlock_bits=0x3F
+Gen7-644P-16.bootloader.lock_bits=0x0F
+Gen7-644P-16.build.mcu=atmega644p
+Gen7-644P-16.build.f_cpu=16000000L
+Gen7-644P-16.build.core=arduino
+
+##############################################################
+
+Gen7-644P-20.name=Gen7 with ATmega644P and 20 MHz
+Gen7-644P-20.upload.protocol=stk500v2
+Gen7-644P-20.upload.maximum_size=63488
+Gen7-644P-20.upload.speed=115200
+Gen7-644P-20.bootloader.low_fuses=0xF7
+Gen7-644P-20.bootloader.high_fuses=0xD4
+Gen7-644P-20.bootloader.extended_fuses=0xFD
+Gen7-644P-20.bootloader.path=Gen7
+Gen7-644P-20.bootloader.file=bootloader-644P-20MHz.hex
+Gen7-644P-20.bootloader.unlock_bits=0x3F
+Gen7-644P-20.bootloader.lock_bits=0x0F
+Gen7-644P-20.build.mcu=atmega644p
+Gen7-644P-20.build.f_cpu=20000000L
+Gen7-644P-20.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-16.name=Gen7 with ATmega1284 and 16 MHz
+Gen7-1284p-16.upload.protocol=stk500v2
+Gen7-1284p-16.upload.maximum_size=129024
+Gen7-1284p-16.upload.speed=115200
+Gen7-1284p-16.bootloader.low_fuses=0xF7
+Gen7-1284p-16.bootloader.high_fuses=0xD4
+Gen7-1284p-16.bootloader.extended_fuses=0xFD
+Gen7-1284p-16.bootloader.path=Gen7
+Gen7-1284p-16.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-16.bootloader.unlock_bits=0x3F
+Gen7-1284p-16.bootloader.lock_bits=0x2F
+Gen7-1284p-16.build.mcu=atmega1284p
+Gen7-1284p-16.build.f_cpu=16000000L
+Gen7-1284p-16.build.core=arduino
+
+##############################################################
+
+Gen7-1284p-20.name=Gen7 with ATmega1284 and 20 MHz
+Gen7-1284p-20.upload.protocol=stk500v2
+Gen7-1284p-20.upload.maximum_size=129024
+Gen7-1284p-20.upload.speed=115200
+Gen7-1284p-20.bootloader.low_fuses=0xF7
+Gen7-1284p-20.bootloader.high_fuses=0xD4
+Gen7-1284p-20.bootloader.extended_fuses=0xFD
+Gen7-1284p-20.bootloader.path=Gen7
+Gen7-1284p-20.bootloader.file=bootloader-1284P-16MHz.hex
+Gen7-1284p-20.bootloader.unlock_bits=0x3F
+Gen7-1284p-20.bootloader.lock_bits=0x2F
+Gen7-1284p-20.build.mcu=atmega1284p
+Gen7-1284p-20.build.f_cpu=20000000L
+Gen7-1284p-20.build.core=arduino
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
new file mode 100644
index 0000000..93df372
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
@@ -0,0 +1,113 @@
+:020000021000EC
+:10F8000011241FBE8FEF90E49EBF8DBF01C32F92C6
+:10F810003F924F925F926F927F928F929F92AF92A0
+:10F82000BF92CF92DF92EF92FF920F931F93DF93DD
+:10F83000CF93CDB7DEB7C252D1400FB6F894DEBF3A
+:10F840000FBECDBF44245524DD24C25EDE4F188296
+:10F85000CE51D1408824992454013AC20E9428FFF5
+:10F86000282F133059F1143028F4113081F0123060
+:10F8700000F507C0153081F1153030F1163071F701
+:10F880003DC08B3159F711E05BE1D52EE7CF8130D8
+:10F8900041F0C25EDE4F3881CE51D140831709F06E
+:10F8A00019C2D226C25EDE4F2883CE51D14012E06B
+:10F8B000D5CFF82EEE24D82613E0D0CF90E0E82A5A
+:10F8C000F92AD22614E0CACF8E3009F003C2D82616
+:10F8D00015E044245524C2CFE1E0F0E0EC0FFD1F19
+:10F8E000E40DF51D80830894411C511CD8264E144C
+:10F8F0005F0409F0B3CF720116E0B0CF8D1509F0A7
+:10F90000E9C1EAC1CC2447C08D81803311F090E079
+:10F910000AC08F81882311F49EE105C0813011F067
+:10F9200095E001C097E91A821B828D818C838E81BC
+:10F930008D839E831F8247E0E42EF12C88C11A82BA
+:10F9400068E06B8383E58C8394E59D83EBE4EE8331
+:10F9500085E38F8380E3888789878FE58A8782E3C1
+:10F960008B873BE0E32EF12C72C18A81813941F013
+:10F97000823941F0803911F48FE005C080E003C086
+:10F9800082E001C08AE01A828B8323E0E22EF12C10
+:10F990005EC1CC24C3941A8292E0E92EF12C58C1A6
+:10F9A0008D81882311F48EE128C0813011F085E02B
+:10F9B00024C087E922C01A8229E0E1E0F0E0209328
+:10F9C000570084911BC08B81803589F48C818830ED
+:10F9D00039F439E0E2E0F0E03093570084910DC053
+:10F9E00069E0E0E0F0E060935700849106C099E0A0
+:10F9F000E3E0F0E09093570084911A828B831C829D
+:10FA000084E0E82EF12C23C18A8190E0A0E0B0E0F0
+:10FA1000B82EAA24992488248B8190E0A0E0B0E03D
+:10FA2000DC0199278827882A992AAA2ABB2A8D814E
+:10FA300090E0A0E0B0E0882A992AAA2ABB2A8C810B
+:10FA400090E0A0E0B0E0BA2FA92F982F8827882A4D
+:10FA5000992AAA2ABB2A88C0EA81C05EDE4FE883C1
+:10FA6000C052D140C15EDE4F1882CF51D1408B8150
+:10FA7000A82FB0E0C15EDE4F28813981CF51D1403F
+:10FA8000A22BB32B933109F042C075016401CC0C59
+:10FA9000DD1CEE1CFF1C33E0F601E0925B003093AE
+:10FAA0005700E89507B600FCFDCF8E01055F1F4F9C
+:10FAB000F801808161810E5F1F4FA5019401220F23
+:10FAC000331F441F551F362E222490E0822993298C
+:10FAD00061E00C01F90140935B0060935700E895E9
+:10FAE00011240894811C911CA11CB11C129701F7D0
+:10FAF00085E0F601E0925B0080935700E89507B639
+:10FB000000FCFDCF81E180935700E8952DC0FE01F8
+:10FB10003B9620E030E040E050E011977D0100E0AE
+:10FB200010E00894E11CF11C011D111D6081F99980
+:10FB3000FECF1FBAC901880D991D92BD81BD60BD60
+:10FB40000FB6F894FA9AF99A0FBE2F5F3F4F4F4FB6
+:10FB50005F4F2E153F054007510711F03196E6CF54
+:10FB6000820E931EA41EB51E1A826EC09A81CE5DAF
+:10FB7000DE4F9883C252D140CF5DDE4F1882C15212
+:10FB8000D1408B81C82EDD24CF5DDE4FE881F98125
+:10FB9000C152D140CE2ADF2A1A8289818431E1F410
+:10FBA0009601BE016D5F7F4FD501C401880F991F7B
+:10FBB000AA1FBB1FABBFFC0187919691FB018083FD
+:10FBC00091836E5F7F4F0894811C911CA11CB11C16
+:10FBD0002250304049F72EC0BE016D5F7F4F20E0BC
+:10FBE00030E040E050E00894C108D108760100E020
+:10FBF00010E00894C11CD11C0894E11CF11C011DEB
+:10FC0000111DF999FECFC901880D991D92BD81BDC5
+:10FC1000F89A80B5FB018193BF012F5F3F4F4F4F93
+:10FC20005F4F2E153F054007510759F7820E931E6F
+:10FC3000A41EB51E23E0E22EF12CEC0CFD1CFB01F2
+:10FC4000108205C080EC8A8392E0E92EF12CCC244E
+:10FC50008BE10E94C7FEC25EDE4F8881CE51D1404B
+:10FC60000E94C7FE8F2D0E94C7FE8E2D0E94C7FEE8
+:10FC70008EE00E94C7FE85E1D82EC25EDE4FF8817D
+:10FC8000CE51D140DF26DE24DF243E010894611CE2
+:10FC9000711C0AC0F30111913F01812F0E94C7FE20
+:10FCA000D1260894E108F108E114F10499F78D2DAB
+:10FCB0000E94C7FECC2009F044C0C25EDE4FF8812E
+:10FCC000CE51D140FF5FC25EDE4FF883CE51D140AE
+:10FCD000EE24FF2410E0C2CD9981933109F4BCCE0B
+:10FCE0009431B0F4933009F440CE943038F491302C
+:10FCF00009F425CE923009F0A5CF04CE903109F455
+:10FD000001CE913109F445CE963009F09BCF7CCEDF
+:10FD1000983109F458CE993150F4953109F49CCEBC
+:10FD2000953108F423CF963109F08CCF1FCF9B314A
+:10FD300009F436CE9D3109F4E7CD9A3109F082CF2E
+:10FD40003ACECE5DDE4F0FB6F894DEBF0FBECDBF0C
+:10FD5000CF91DF911F910F91FF90EF90DF90CF90A7
+:10FD6000BF90AF909F908F907F906F905F904F90DB
+:10FD70003F902F9008958091C00087FFFCCF089599
+:10FD80008091C00087FFFCCF8091C6000895982F16
+:10FD90008091C00085FFFCCF9093C60008959B0121
+:10FDA000AC0197FF11C08091C00082608093C000B9
+:10FDB00050954095309521953F4F4F4F5F4F60E0F4
+:10FDC00074E284EF90E009C08091C0008D7F809341
+:10FDD000C00060E072E18AE790E00E9447FF2C5F7C
+:10FDE0003F4F4F4F5F4F83E0569547953795279587
+:10FDF0008A95D1F7215030403093C5002093C4003C
+:10FE0000089518B817B81F921F921F920895FFCF38
+:10FE100084B714BE90E083709070892B39F418B8C1
+:10FE200017B81F921F921F920895FFCF88E1809309
+:10FE3000C10060E07EE38EEF9FEF0E94CFFE0E9444
+:10FE400007FC18B817B81F921F921F920895FFCF92
+:10FE500020E030E040E050E013C02F5F3F4F4F4FB5
+:10FE60005F4F21308AE6380788E1480780E058076D
+:10FE700039F418B817B81F921F921F920895FFCF38
+:10FE80008091C00087FFE9CF0E94C0FE0895A1E2E3
+:10FE90001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F04
+:10FEA000FF1FA217B307E407F50720F0A21BB30B4F
+:10FEB000E40BF50B661F771F881F991F1A9469F7CB
+:10FEC00060957095809590959B01AC01BD01CF0127
+:02FED000089593
+:040000031000F800F1
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
new file mode 100644
index 0000000..5809869
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E044E755E962E470E0ACCF90E061
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539444E755E962E470E090E0C6
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
new file mode 100644
index 0000000..d216c65
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E9BE0292E23
+:10F84000312C2C0E3D1ECFC14150504060407040C5
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983BBC1313011F0351559F52327532E6B
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F099E001C096E933
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F4C01A8288E08B8381E48C8336
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DEC08A81813941F0823941F0803911F459
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0CBC091E01A8242E050E02C
+:10F99000C7C08D81882311F48EE124C0813011F01D
+:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E097C0B8
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A828AC09A8088248B81682F70E027
+:10FA100068297929933109F033C0F7EF0F3F1F07A9
+:10FA200010F0A8013FC023E0F80120935700E895AB
+:10FA300007B600FCFDCFA801D1018C9111962C9145
+:10FA400011971296D22ECC2490E08C299D2921E08A
+:10FA5000FA010C0120935700E89511244E5F5F4F87
+:10FA60006250704051F725E0F80120935700E89567
+:10FA700007B600FCFDCF81E180935700E89512C0E6
+:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
+:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
+:10FAA000460F571F1A828A0138C07A8066248B81DC
+:10FAB000A82FB0E0A629B7291A828981843191F450
+:10FAC000BD019E012D5F3F4FF80185919491F90191
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
+:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
+:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
+:10FB1000F901108204C080EC8A8342E050E090E05A
+:10FB2000FBE1F093C6008091C00086FFFCCF80917E
+:10FB3000C00080648093C0005092C6008091C000D5
+:10FB400086FFFCCF8091C00080648093C000652F49
+:10FB50005093C6008091C00086FFFCCF8091C0000A
+:10FB600080648093C000342F4093C6008091C00011
+:10FB700086FFFCCF8091C00080648093C0008EE03F
+:10FB80008093C6008091C00086FFFCCF8091C000AA
+:10FB900080648093C00025E1252523272627FE01C8
+:10FBA000319610C030813093C6008091C00086FF2E
+:10FBB000FCCF31968091C00080648093C0002327E1
+:10FBC000415050404115510569F72093C60080917E
+:10FBD000C00086FFFCCF8091C00080648093C0008D
+:10FBE000992349F4539441ED5AE363E570E090E0C2
+:10FBF000A0E0B0E030CE5A9881E180935700E895BC
+:10FC000011241F921F920895FFCF9981933109F417
+:10FC1000FACE9431C8F4963009F4EACE973050F415
+:10FC2000923009F46CCE933009F49BCE913009F0F8
+:10FC300072CF81CE913109F4A7CE923108F0E1CE96
+:10FC4000903109F068CF5BCE983109F4B4CE993188
+:10FC500050F4953109F4D7CE953108F426CF96317A
+:10FC600009F059CF22CF9B3109F493CE9C3120F477
+:10FC70009A3109F050CF98CE9D3109F442CE9F328F
+:06FC800009F049CFB8CFE6
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
new file mode 100644
index 0000000..a9105a2
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F8200088E08093C40088E18093C100EE24FF2427
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E044E755E962E470E0ACCF90E063
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539444E755E962E470E090E0A0E0B0E0AF
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
new file mode 100644
index 0000000..4ee0c6b
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
@@ -0,0 +1,75 @@
+:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
+:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
+:10F820008AE08093C40088E18093C100EE24FF2425
+:10F8300020E0552400E010E039E0432E93E0292E2B
+:10F84000312C2C0E3D1ECDC14150504060407040C7
+:10F8500011F43FE206C08091C00087FFF5CF3091E0
+:10F86000C600933021F1943028F4913099F0923011
+:10F87000C8F407C0953049F1953000F19630D1F5C4
+:10F8800035C03B3119F491E02BE134C03F3291F5A2
+:10F890003983B9C1313011F0351559F52327532E6D
+:10F8A00092E028C0B32FA0E0232793E023C0832F4A
+:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
+:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
+:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
+:10F8E000EA16FB0639F4D70196E004C0321709F492
+:10F8F0008AC190E041ED5AE363E570E0ACCF90E05F
+:10F9000044C08D81803311F090E00AC08F8188233C
+:10F9100011F49EE105C0813011F09AE001C096E932
+:10F920001A821B828D818C838E818D839E831F82A0
+:10F9300047E050E0F2C01A8288E08B8381E48C8338
+:10F9400086E58D8382E58E8389E48F8383E58887CE
+:10F9500080E589878FE58A8782E38B874BE050E0DB
+:10F96000DCC08A81813941F0823941F0803911F45B
+:10F970008FE005C080E003C082E001C08AE01A8207
+:10F980008B8343E050E0C9C091E01A8242E050E02E
+:10F99000C5C08D81882311F48EE124C0813011F01F
+:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
+:10F9B0005700849118C08B81803579F48C81883010
+:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
+:10F9D000F0E040925700849105C0E3E0F0E04092EF
+:10F9E000570084911A828B831C8244E050E095C0BA
+:10F9F000BC80AA248D81082F10E00A291B29000F42
+:10FA0000111F1A8288C09A8088248B81682F70E029
+:10FA100068297929933109F034C0F7EF0F3F1F07A8
+:10FA200010F0A80141C023E0F80120935700E895A9
+:10FA300007B600FCFDCFA801DE011B968C91119644
+:10FA40002C9111971296D22ECC2490E08C299D29CE
+:10FA500021E0FA010C0120935700E89511244E5F34
+:10FA60005F4F6250704051F725E0F8012093570036
+:10FA7000E89507B600FCFDCF81E180935700E8953B
+:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
+:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
+:10FAA000A1F7A801460F571F1A828A0134C07A8035
+:10FAB00066248B81A82FB0E0A629B7291A828981F4
+:10FAC000843181F4BD019101F80185919491F9018E
+:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
+:10FAE00099F711C0A801BD01910141BD52BD4F5F01
+:10FAF0005F4FF89A80B5F90181939F016150704082
+:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
+:10FB100004C080EC8A8342E050E090E0FBE1F09387
+:10FB2000C6008091C00086FFFCCF8091C000806439
+:10FB30008093C0005092C6008091C00086FFFCCF29
+:10FB40008091C00080648093C000652F5093C600F0
+:10FB50008091C00086FFFCCF8091C00080648093BC
+:10FB6000C000342F4093C6008091C00086FFFCCFB8
+:10FB70008091C00080648093C0008EE08093C600B6
+:10FB80008091C00086FFFCCF8091C000806480938C
+:10FB9000C00025E1252523272627FE01319610C028
+:10FBA00030813093C6008091C00086FFFCCF319633
+:10FBB0008091C00080648093C00023274150504052
+:10FBC0004115510569F72093C6008091C00086FF5A
+:10FBD000FCCF8091C00080648093C000992349F4D9
+:10FBE000539441ED5AE363E570E090E0A0E0B0E0AB
+:10FBF00032CE5A9881E180935700E89511241F92E4
+:10FC00001F920895FFCF9981933109F4FCCE94316E
+:10FC1000C8F4963009F4ECCE973050F4923009F4E1
+:10FC20006ECE933009F49DCE913009F072CF83CE21
+:10FC3000913109F4A9CE923108F0E3CE903109F068
+:10FC400068CF5DCE983109F4B6CE993150F4953134
+:10FC500009F4D9CE953108F42ACF963109F059CF5D
+:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
+:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
+:02FC8000B8CFFB
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..8b1fcc6
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,239 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer {
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer = { { 0 }, 0, 0 };
+
+#ifdef UDR1
+ring_buffer rx_buffer1 = { { 0 }, 0, 0 };
+#endif
+
+#ifdef UDR2
+ring_buffer rx_buffer2 = { { 0 }, 0, 0 };
+#endif
+#ifdef UDR3
+ring_buffer rx_buffer3 = { { 0 }, 0, 0 };
+#endif
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+ISR(USART0_RX_vect)
+{
+  unsigned char c = UDR0;
+  store_char(c, &rx_buffer);
+}
+
+#ifdef UDR1
+ISR(USART1_RX_vect)
+{
+  unsigned char c = UDR1;
+  store_char(c, &rx_buffer1);
+}
+
+#ifdef UDR2
+ISR(USART2_RX_vect)
+{
+  unsigned char c = UDR2;
+  store_char(c, &rx_buffer2);
+}
+
+#ifdef UDR2
+ISR(USART3_RX_vect)
+{
+  unsigned char c = UDR3;
+  store_char(c, &rx_buffer3);
+}
+#endif
+#endif
+
+#else
+
+#if defined(__AVR_ATmega8__)
+SIGNAL(SIG_UART_RECV)
+#else
+SIGNAL(USART_RX_vect)
+#endif
+{
+#if defined(__AVR_ATmega8__)
+  unsigned char c = UDR;
+#else
+  unsigned char c = UDR0;
+#endif
+  store_char(c, &rx_buffer);
+}
+
+#endif
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x;
+
+  // U2X mode is needed for baud rates higher than (CPU Hz / 16)
+  if (baud > F_CPU / 16) {
+    use_u2x = true;
+  } else {
+    // figure out if U2X mode would allow for a better connection
+    
+    // calculate the percent difference between the baud-rate specified and
+    // the real baud rate for both U2X and non-U2X mode (0-255 error percent)
+    uint8_t nonu2x_baud_error = abs((int)(255-((F_CPU/(16*(((F_CPU/8/baud-1)/2)+1))*255)/baud)));
+    uint8_t u2x_baud_error = abs((int)(255-((F_CPU/(8*(((F_CPU/4/baud-1)/2)+1))*255)/baud)));
+    
+    // prefer non-U2X mode because it handles clock skew better
+    use_u2x = (nonu2x_baud_error > u2x_baud_error);
+  }
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+uint8_t HardwareSerial::available(void)
+{
+  return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+void HardwareSerial::write(uint8_t c)
+{
+  while (!((*_ucsra) & (1 << _udre)))
+    ;
+
+  *_udr = c;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+
+#if defined(__AVR_ATmega8__)
+HardwareSerial Serial(&rx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
+#else
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+#endif
+
+#ifdef UDR1
+HardwareSerial Serial1(&rx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRE1, U2X1);
+#endif
+
+#ifdef UDR2
+HardwareSerial Serial2(&rx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRE2, U2X2);
+#endif
+#ifdef UDR3
+HardwareSerial Serial3(&rx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRE3, U2X3);
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..f609f73
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/HardwareSerial.h
@@ -0,0 +1,69 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Print.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Print
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    uint8_t available(void);
+    int read(void);
+    void flush(void);
+    virtual void write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+extern HardwareSerial Serial;
+
+#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial1;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+extern HardwareSerial Serial2;
+extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile
new file mode 100644
index 0000000..571687d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Makefile
@@ -0,0 +1,243 @@
+# Arduino 0011 Makefile
+# Arduino adaptation by mellis, eighthave, oli.keller
+#
+# This makefile allows you to build sketches from the command line
+# without the Arduino environment (or Java).
+#
+# Detailed instructions for using the makefile:
+#
+#  1. Copy this file into the folder with your sketch. There should be a
+#     file with the same name as the folder and with the extension .pde
+#     (e.g. foo.pde in the foo/ folder).
+#
+#  2. Modify the line containg "INSTALL_DIR" to point to the directory that
+#     contains the Arduino installation (for example, under Mac OS X, this
+#     might be /Applications/arduino-0012).
+#
+#  3. Modify the line containing "PORT" to refer to the filename
+#     representing the USB or serial connection to your Arduino board
+#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
+#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
+#
+#  4. Set the line containing "MCU" to match your board's processor. 
+#     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
+#     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
+#     change F_CPU to 8000000.
+#
+#  5. At the command line, change to the directory containing your
+#     program's file and the makefile.
+#
+#  6. Type "make" and press enter to compile/verify your program.
+#
+#  7. Type "make upload", reset your Arduino board, and press enter to
+#     upload your program to the Arduino board.
+#
+# $Id$
+
+TARGET = $(notdir $(CURDIR))
+INSTALL_DIR = /Users/dmellis/Source/arduino/trunk/build/macosx/build/work
+PORT = /dev/tty.usb*
+UPLOAD_RATE = 19200
+AVRDUDE_PROGRAMMER = stk500v1
+MCU = atmega168
+F_CPU = 16000000
+
+############################################################################
+# Below here nothing should be changed...
+
+ARDUINO = $(INSTALL_DIR)/hardware/cores/arduino
+AVR_TOOLS_PATH = $(INSTALL_DIR)/hardware/tools/avr/bin
+SRC =  $(ARDUINO)/pins_arduino.c $(ARDUINO)/wiring.c \
+$(ARDUINO)/wiring_analog.c $(ARDUINO)/wiring_digital.c \
+$(ARDUINO)/wiring_pulse.c $(ARDUINO)/wiring_serial.c \
+$(ARDUINO)/wiring_shift.c $(ARDUINO)/WInterrupts.c
+CXXSRC = $(ARDUINO)/HardwareSerial.cpp $(ARDUINO)/WMath.cpp
+FORMAT = ihex
+
+
+# Name of this Makefile (used for "make depend").
+MAKEFILE = Makefile
+
+# Debugging format.
+# Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.
+# AVR (extended) COFF requires stabs, plus an avr-objcopy run.
+DEBUG = stabs
+
+OPT = s
+
+# Place -D or -U options here
+CDEFS = -DF_CPU=$(F_CPU)
+CXXDEFS = -DF_CPU=$(F_CPU)
+
+# Place -I options here
+CINCS = -I$(ARDUINO)
+CXXINCS = -I$(ARDUINO)
+
+# Compiler flag to set the C Standard level.
+# c89   - "ANSI" C
+# gnu89 - c89 plus GCC extensions
+# c99   - ISO C99 standard (not yet fully implemented)
+# gnu99 - c99 plus GCC extensions
+CSTANDARD = -std=gnu99
+CDEBUG = -g$(DEBUG)
+CWARN = -Wall -Wstrict-prototypes
+CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
+#CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
+
+CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CSTANDARD) $(CEXTRA)
+CXXFLAGS = $(CDEFS) $(CINCS) -O$(OPT)
+#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
+LDFLAGS = -lm
+
+
+# Programming support using avrdude. Settings and variables.
+AVRDUDE_PORT = $(PORT)
+AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex
+AVRDUDE_FLAGS = -V -F -C $(INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
+-p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
+-b $(UPLOAD_RATE)
+
+# Program settings
+CC = $(AVR_TOOLS_PATH)/avr-gcc
+CXX = $(AVR_TOOLS_PATH)/avr-g++
+OBJCOPY = $(AVR_TOOLS_PATH)/avr-objcopy
+OBJDUMP = $(AVR_TOOLS_PATH)/avr-objdump
+AR  = $(AVR_TOOLS_PATH)/avr-ar
+SIZE = $(AVR_TOOLS_PATH)/avr-size
+NM = $(AVR_TOOLS_PATH)/avr-nm
+AVRDUDE = $(AVR_TOOLS_PATH)/avrdude
+REMOVE = rm -f
+MV = mv -f
+
+# Define all object files.
+OBJ = $(SRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.S=.o) 
+
+# Define all listing files.
+LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
+
+# Combine all necessary flags and optional flags.
+# Add target processor to flags.
+ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
+ALL_CXXFLAGS = -mmcu=$(MCU) -I. $(CXXFLAGS)
+ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
+
+
+# Default target.
+all: applet_files build sizeafter
+
+build: elf hex 
+
+applet_files: $(TARGET).pde
+	# Here is the "preprocessing".
+	# It creates a .cpp file based with the same name as the .pde file.
+	# On top of the new .cpp file comes the WProgram.h header.
+	# At the end there is a generic main() function attached.
+	# Then the .cpp file will be compiled. Errors during compile will
+	# refer to this new, automatically generated, file. 
+	# Not the original .pde file you actually edit...
+	test -d applet || mkdir applet
+	echo '#include "WProgram.h"' > applet/$(TARGET).cpp
+	cat $(TARGET).pde >> applet/$(TARGET).cpp
+	cat $(ARDUINO)/main.cxx >> applet/$(TARGET).cpp
+
+elf: applet/$(TARGET).elf
+hex: applet/$(TARGET).hex
+eep: applet/$(TARGET).eep
+lss: applet/$(TARGET).lss 
+sym: applet/$(TARGET).sym
+
+# Program the device.  
+upload: applet/$(TARGET).hex
+	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
+
+
+	# Display size of file.
+HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
+ELFSIZE = $(SIZE)  applet/$(TARGET).elf
+sizebefore:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
+
+sizeafter:
+	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(HEXSIZE); echo; fi
+
+
+# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
+COFFCONVERT=$(OBJCOPY) --debugging \
+--change-section-address .data-0x800000 \
+--change-section-address .bss-0x800000 \
+--change-section-address .noinit-0x800000 \
+--change-section-address .eeprom-0x810000 
+
+
+coff: applet/$(TARGET).elf
+	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+extcoff: $(TARGET).elf
+	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
+
+
+.SUFFIXES: .elf .hex .eep .lss .sym
+
+.elf.hex:
+	$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
+
+.elf.eep:
+	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
+	--change-section-lma .eeprom=0 -O $(FORMAT) $< $@
+
+# Create extended listing file from ELF output file.
+.elf.lss:
+	$(OBJDUMP) -h -S $< > $@
+
+# Create a symbol table from ELF output file.
+.elf.sym:
+	$(NM) -n $< > $@
+
+	# Link: create ELF output file from library.
+applet/$(TARGET).elf: $(TARGET).pde applet/core.a 
+	$(CC) $(ALL_CFLAGS) -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
+
+applet/core.a: $(OBJ)
+	@for i in $(OBJ); do echo $(AR) rcs applet/core.a $$i; $(AR) rcs applet/core.a $$i; done
+
+
+
+# Compile: create object files from C++ source files.
+.cpp.o:
+	$(CXX) -c $(ALL_CXXFLAGS) $< -o $@ 
+
+# Compile: create object files from C source files.
+.c.o:
+	$(CC) -c $(ALL_CFLAGS) $< -o $@ 
+
+
+# Compile: create assembler files from C source files.
+.c.s:
+	$(CC) -S $(ALL_CFLAGS) $< -o $@
+
+
+# Assemble: create object files from assembler source files.
+.S.o:
+	$(CC) -c $(ALL_ASFLAGS) $< -o $@
+
+
+
+# Target: clean project.
+clean:
+	$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
+	applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/core.a \
+	$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
+
+depend:
+	if grep '^# DO NOT DELETE' $(MAKEFILE) >/dev/null; \
+	then \
+		sed -e '/^# DO NOT DELETE/,$$d' $(MAKEFILE) > \
+			$(MAKEFILE).$$$$ && \
+		$(MV) $(MAKEFILE).$$$$ $(MAKEFILE); \
+	fi
+	echo '# DO NOT DELETE THIS LINE -- make depend depends on it.' \
+		>> $(MAKEFILE); \
+	$(CC) -M -mmcu=$(MCU) $(CDEFS) $(CINCS) $(SRC) $(ASRC) >> $(MAKEFILE)
+
+.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp
new file mode 100644
index 0000000..d4833da
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.cpp
@@ -0,0 +1,203 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void Print::print(uint8_t b)
+{
+  this->write(b);
+}
+
+void Print::print(char c)
+{
+  print((byte) c);
+}
+
+void Print::print(const char c[])
+{
+  while (*c)
+    print(*c++);
+}
+
+void Print::print(int n)
+{
+  print((long) n);
+}
+
+void Print::print(unsigned int n)
+{
+  print((unsigned long) n);
+}
+
+void Print::print(long n)
+{
+  if (n < 0) {
+    print('-');
+    n = -n;
+  }
+  printNumber(n, 10);
+}
+
+void Print::print(unsigned long n)
+{
+  printNumber(n, 10);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0)
+    print((char) n);
+  else if (base == 10)
+    print(n);
+  else
+    printNumber(n, base);
+}
+
+void Print::print(double n)
+{
+  printFloat(n, 2);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(char c)
+{
+  print(c);
+  println();  
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(uint8_t b)
+{
+  print(b);
+  println();
+}
+
+void Print::println(int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(unsigned int n)
+{
+  print(n);
+  println();
+}
+
+void Print::println(long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(unsigned long n)
+{
+  print(n);
+  println();  
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n)
+{
+  print(n);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h
new file mode 100644
index 0000000..c95a0dc
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Print.h
@@ -0,0 +1,59 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+    virtual void write(uint8_t);
+    void print(char);
+    void print(const char[]);
+    void print(uint8_t);
+    void print(int);
+    void print(unsigned int);
+    void print(long);
+    void print(unsigned long);
+    void print(long, int);
+    void print(double);
+    void println(void);
+    void println(char);
+    void println(const char[]);
+    void println(uint8_t);
+    void println(int);
+    void println(unsigned int);
+    void println(long);
+    void println(unsigned long);
+    void println(long, int);
+    void println(double);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..827fe49
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/Tone.cpp
@@ -0,0 +1,515 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <wiring.h>
+#include <pins_arduino.h>
+
+#if defined(__AVR_ATmega8__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(__AVR_ATmega1280__)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+#if defined(__AVR_ATmega1280__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        bitWrite(TCCR4B, WGM42, 1);
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+#endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if !defined(__AVR_ATmega8__)
+      if (_timer == 0)
+        TCCR0B = prescalarbits;
+      else
+#endif
+        TCCR2B = prescalarbits;
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#if defined(__AVR_ATmega1280__)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if !defined(__AVR_ATmega8__)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+        break;
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+
+#if defined(__AVR_ATmega1280__)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  switch (_timer)
+  {
+#if defined(__AVR_ATmega8__)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+    case 2:
+      bitWrite(TIMSK2, OCIE2A, 0);
+      break;
+
+#else
+    case 0:
+      TIMSK0 = 0;
+      break;
+    case 1:
+      TIMSK1 = 0;
+      break;
+    case 2:
+      TIMSK2 = 0;
+      break;
+#endif
+
+#if defined(__AVR_ATmega1280__)
+    case 3:
+      TIMSK3 = 0;
+      break;
+    case 4:
+      TIMSK4 = 0;
+      break;
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    TIMSK0 = 0;   // disable the interrupt
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    TIMSK1 = 0;   // disable the interrupt
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    TIMSK2 = 0;   // disable the interrupt
+    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    TIMSK3 = 0;   // disable the interrupt
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    TIMSK4 = 0;   // disable the interrupt
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    TIMSK5 = 0;   // disable the interrupt
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..6f3f0b1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WInterrupts.c
@@ -0,0 +1,87 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		intFunc[interruptNum] = userFunc;
+
+		//clear the config for the change settings
+		EICRA &= ~(B00000011 << (interruptNum * 2));
+
+		//set our mode.
+		EICRA |= (mode << (interruptNum * 2));
+
+		// Enable the interrupt.
+		EIMSK |= (1 << interruptNum);
+	}
+}
+
+void detachInterrupt(uint8_t interruptNum)
+{
+	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
+	{
+		// Disable the interrupt.
+		EIMSK &= ~(1 << interruptNum);
+
+		intFunc[interruptNum] = 0;
+	}
+}
+
+ISR(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+ISR(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+ISR(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..7a230f5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0){
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h
new file mode 100644
index 0000000..2c7ed16
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WProgram.h
@@ -0,0 +1,34 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx
new file mode 100644
index 0000000..52351e4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/main.cxx
@@ -0,0 +1,12 @@
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..c67ab73
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+        (uint8_t) &DDRA,
+	(uint8_t) &DDRB,
+	(uint8_t) &DDRC,
+	(uint8_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) &PORTA,
+	(uint8_t) &PORTB,
+	(uint8_t) &PORTC,
+	(uint8_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) &PINA,
+	(uint8_t) &PINB,
+	(uint8_t) &PINC,
+	(uint8_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..e0b7add
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c
new file mode 100644
index 0000000..1a102ae
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.c
@@ -0,0 +1,203 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 388 2008-03-08 22:05:23Z mellis $
+*/
+
+#include "wiring_private.h"
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_clock_cycles = 0;
+volatile unsigned long timer0_millis = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	timer0_overflow_count++;
+	// timer 0 prescale factor is 64 and the timer overflows at 256
+	timer0_clock_cycles += 64UL * 256UL;
+	while (timer0_clock_cycles > clockCyclesPerMicrosecond() * 1000UL) {
+		timer0_clock_cycles -= clockCyclesPerMicrosecond() * 1000UL;
+		timer0_millis++;
+	}
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+	
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of the timer0_millis++)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+	
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m, t;
+	uint8_t oldSREG = SREG;
+	
+	cli();	
+	t = TCNT0;
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t == 0))
+		t = 256;
+#else
+	if ((TIFR & _BV(TOV0)) && (t == 0))
+		t = 256;
+#endif
+
+	m = timer0_overflow_count;
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	unsigned long start = millis();
+	
+	while (millis() - start <= ms)
+		;
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. 
+ * Disables interrupts, which will disrupt the millis() function if used
+ * too frequently. */
+void delayMicroseconds(unsigned int us)
+{
+	uint8_t oldSREG;
+
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// disable interrupts, otherwise the timer 0 overflow interrupt that
+	// tracks milliseconds will make us delay longer than we want.
+	oldSREG = SREG;
+	cli();
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+
+	// reenable interrupts.
+	SREG = oldSREG;
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+
+	// set timer 0 prescale factor to 64
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+
+	// enable timer 0 overflow interrupt
+	sbi(TIMSK0, TOIE0);
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	// set timer 1 prescale factor to 64
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+
+	// put timer 1 in 8-bit phase correct pwm mode
+	sbi(TCCR1A, WGM10);
+
+	// set timer 2 prescale factor to 64
+	sbi(TCCR2B, CS22);
+
+	// configure timer 2 for phase correct pwm (8-bit)
+	sbi(TCCR2A, WGM20);
+
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+	UCSR0B = 0;
+	#if defined(__AVR_ATmega644P__)
+	//TODO: test to see if disabling this helps?
+	//UCSR1B = 0;
+	#endif
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h
new file mode 100644
index 0000000..48ff04a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring.h
@@ -0,0 +1,135 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 387 2008-03-08 21:30:00Z mellis $
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.14159265
+#define HALF_PI 1.57079
+#define TWO_PI 6.283185
+#define DEG_TO_RAD 0.01745329
+#define RAD_TO_DEG 57.2957786
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#define INTERNAL 3
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#if __AVR_LIBC_VERSION__ < 10701UL
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#endif
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
+#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
+
+#define lowByte(w) ((w) & 0xff)
+#define highByte(w) ((w) >> 8)
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+typedef unsigned int word;
+
+#define bit(b) (1 << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+void beginSerial(uint8_t, long);
+void serialWrite(uint8_t, unsigned char);
+int serialAvailable(uint8_t);
+int serialRead(uint8_t);
+void serialFlush(uint8_t);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..b98bb1a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_analog.c
@@ -0,0 +1,116 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high, ch = analogInPinToBit(pin);
+
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+	// the final AND is to clear the pos/neg reference bits
+	ADMUX = ((analog_reference << 6) | (pin & 0x0f)) & B11000111;
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low = ADCL;
+	high = ADCH;
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	
+	if (digitalPinToTimer(pin) == TIMER1A) {
+		// connect pwm to pin on timer 1, channel A
+		sbi(TCCR1A, COM1A1);
+		// set pwm duty
+		OCR1A = val;
+	} else if (digitalPinToTimer(pin) == TIMER1B) {
+		// connect pwm to pin on timer 1, channel B
+		sbi(TCCR1A, COM1B1);
+		// set pwm duty
+		OCR1B = val;
+	} else if (digitalPinToTimer(pin) == TIMER0A) {
+		// connect pwm to pin on timer 0, channel A
+		sbi(TCCR0A, COM0A1);
+		// set pwm duty
+		OCR0A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER0B) {
+		// connect pwm to pin on timer 0, channel B
+		sbi(TCCR0A, COM0B1);
+		// set pwm duty
+		OCR0B = val;
+	} else if (digitalPinToTimer(pin) == TIMER2A) {
+		// connect pwm to pin on timer 2, channel A
+		sbi(TCCR2A, COM2A1);
+		// set pwm duty
+		OCR2A = val;	
+	} else if (digitalPinToTimer(pin) == TIMER2B) {
+		// connect pwm to pin on timer 2, channel B
+		sbi(TCCR2A, COM2B1);
+		// set pwm duty
+		OCR2B = val;
+	} else if (val < 128)
+	//fail semi-intelligently
+		digitalWrite(pin, LOW);
+	else
+		digitalWrite(pin, HIGH);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..3d4b4eb
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_digital.c
@@ -0,0 +1,95 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) *reg &= ~bit;
+	else *reg |= bit;
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+static inline void turnOffPWM(uint8_t timer)
+{
+	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
+	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
+	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
+	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
+	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
+	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) *out &= ~bit;
+	else *out |= bit;
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..14394a0
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_private.h
@@ -0,0 +1,60 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/signal.h>
+#include <avr/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+
+#define EXTERNAL_NUM_INTERRUPTS 3
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..8f232f1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_pulse.c
@@ -0,0 +1,66 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask)
+		width++;
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 10 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 10 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c
new file mode 100644
index 0000000..a3314fa
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_serial.c
@@ -0,0 +1,138 @@
+/*
+  wiring_serial.c - serial functions.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+  Modified 29 January 2009, Marius Kintel for Sanguino - http://www.sanguino.cc/
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+
+#include "wiring_private.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+#if defined(__AVR_ATmega644P__)
+unsigned char rx_buffer[2][RX_BUFFER_SIZE];
+int rx_buffer_head[2] = {0, 0};
+int rx_buffer_tail[2] = {0, 0};
+#else
+unsigned char rx_buffer[1][RX_BUFFER_SIZE];
+int rx_buffer_head[1] = {0};
+int rx_buffer_tail[1] = {0};
+#endif
+
+
+#define BEGIN_SERIAL(uart_, baud_) \
+{ \
+    UBRR##uart_##H = ((F_CPU / 16 + baud / 2) / baud - 1) >> 8; \
+    UBRR##uart_##L = ((F_CPU / 16 + baud / 2) / baud - 1); \
+    \
+    /* reset config for UART */ \
+    UCSR##uart_##A = 0; \
+    UCSR##uart_##B = 0; \
+    UCSR##uart_##C = 0; \
+    \
+    /* enable rx and tx */ \
+    sbi(UCSR##uart_##B, RXEN##uart_);\
+    sbi(UCSR##uart_##B, TXEN##uart_);\
+    \
+    /* enable interrupt on complete reception of a byte */ \
+    sbi(UCSR##uart_##B, RXCIE##uart_); \
+    UCSR##uart_##C = _BV(UCSZ##uart_##1)|_BV(UCSZ##uart_##0); \
+    /* defaults to 8-bit, no parity, 1 stop bit */ \
+}
+
+void beginSerial(uint8_t uart, long baud)
+{
+  if (uart == 0) BEGIN_SERIAL(0, baud)
+#if defined(__AVR_ATmega644P__)
+  else BEGIN_SERIAL(1, baud)
+#endif
+}
+
+#define SERIAL_WRITE(uart_, c_) \
+    while (!(UCSR##uart_##A & (1 << UDRE##uart_))) \
+      ; \
+    UDR##uart_ = c
+
+void serialWrite(uint8_t uart, unsigned char c)
+{
+  if (uart == 0) {
+    SERIAL_WRITE(0, c);
+  }
+#if defined(__AVR_ATmega644P__)
+  else {
+    SERIAL_WRITE(1, c);
+  }
+#endif
+}
+
+int serialAvailable(uint8_t uart)
+{
+  return (RX_BUFFER_SIZE + rx_buffer_head[uart] - rx_buffer_tail[uart]) % RX_BUFFER_SIZE;
+}
+
+int serialRead(uint8_t uart)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (rx_buffer_head[uart] == rx_buffer_tail[uart]) {
+    return -1;
+  } else {
+    unsigned char c = rx_buffer[uart][rx_buffer_tail[uart]];
+    rx_buffer_tail[uart] = (rx_buffer_tail[uart] + 1) % RX_BUFFER_SIZE;
+    return c;
+  }
+}
+
+void serialFlush(uint8_t uart)
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  rx_buffer_head[uart] = rx_buffer_tail[uart];
+}
+
+#define UART_ISR(uart_) \
+ISR(USART##uart_##_RX_vect) \
+{ \
+  unsigned char c = UDR##uart_; \
+  \
+  int i = (rx_buffer_head[uart_] + 1) % RX_BUFFER_SIZE; \
+  \  
+  /* if we should be storing the received character into the location \
+     just before the tail (meaning that the head would advance to the \
+     current location of the tail), we're about to overflow the buffer \
+     and so we don't write the character or advance the head. */ \
+  if (i != rx_buffer_tail[uart_]) { \
+    rx_buffer[uart_][rx_buffer_head[uart_]] = c; \
+    rx_buffer_head[uart_] = i; \
+  } \
+}
+
+UART_ISR(0)
+#if defined(__AVR_ATmega644P__) 
+UART_ISR(1)
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..956f864
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Gen7/cores/arduino/wiring_shift.c
@@ -0,0 +1,40 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
+{
+	int i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
new file mode 100644
index 0000000..4f71b8a
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/boards.txt
@@ -0,0 +1,16 @@
+##############################################################
+
+sanguino.name=Sanguino
+sanguino.upload.protocol=stk500
+sanguino.upload.maximum_size=63488
+sanguino.upload.speed=38400
+sanguino.bootloader.low_fuses=0xFF
+sanguino.bootloader.high_fuses=0xDC
+sanguino.bootloader.extended_fuses=0xFD
+sanguino.bootloader.path=atmega644p
+sanguino.bootloader.file=ATmegaBOOT_644P.hex
+sanguino.bootloader.unlock_bits=0x3F
+sanguino.bootloader.lock_bits=0x0F
+sanguino.build.mcu=atmega644p
+sanguino.build.f_cpu=16000000L
+sanguino.build.core=arduino
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
new file mode 100644
index 0000000..1711014
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
@@ -0,0 +1,713 @@
+/**********************************************************/
+/* Serial Bootloader for Atmel megaAVR Controllers        */
+/*                                                        */
+/* tested with ATmega644 and ATmega644P                   */
+/* should work with other mega's, see code for details    */
+/*                                                        */
+/* ATmegaBOOT.c                                           */
+/*                                                        */
+/* 20090131: Added 324P support from Alex Leone           */
+/*           Marius Kintel                                */
+/* 20080915: applied ADABoot mods for Sanguino 644P       */
+/*           Brian Riley                                  */
+/* 20080711: hacked for Sanguino by Zach Smith            */
+/*           and Justin Day                               */
+/* 20070626: hacked for Arduino Diecimila (which auto-    */
+/*           resets when a USB connection is made to it)  */
+/*           by D. Mellis                                 */
+/* 20060802: hacked for Arduino by D. Cuartielles         */
+/*           based on a previous hack by D. Mellis        */
+/*           and D. Cuartielles                           */
+/*                                                        */
+/* Monitor and debug functions were added to the original */
+/* code by Dr. Erik Lins, chip45.com. (See below)         */
+/*                                                        */
+/* Thanks to Karl Pitrich for fixing a bootloader pin     */
+/* problem and more informative LED blinking!             */
+/*                                                        */
+/* For the latest version see:                            */
+/* http://www.chip45.com/                                 */
+/*                                                        */
+/* ------------------------------------------------------ */
+/*                                                        */
+/* based on stk500boot.c                                  */
+/* Copyright (c) 2003, Jason P. Kyle                      */
+/* All rights reserved.                                   */
+/* see avr1.org for original file and information         */
+/*                                                        */
+/* This program is free software; you can redistribute it */
+/* and/or modify it under the terms of the GNU General    */
+/* Public License as published by the Free Software       */
+/* Foundation; either version 2 of the License, or        */
+/* (at your option) any later version.                    */
+/*                                                        */
+/* This program is distributed in the hope that it will   */
+/* be useful, but WITHOUT ANY WARRANTY; without even the  */
+/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
+/* PARTICULAR PURPOSE.  See the GNU General Public        */
+/* License for more details.                              */
+/*                                                        */
+/* You should have received a copy of the GNU General     */
+/* Public License along with this program; if not, write  */
+/* to the Free Software Foundation, Inc.,                 */
+/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
+/*                                                        */
+/* Licence can be viewed at                               */
+/* http://www.fsf.org/licenses/gpl.txt                    */
+/*                                                        */
+/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
+/* m8515,m8535. ATmega161 has a very small boot block so  */
+/* isn't supported.                                       */
+/*                                                        */
+/* Tested with m168                                       */
+/**********************************************************/
+
+/* $Id$ */
+
+
+/* some includes */
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/wdt.h>
+#include <avr/boot.h>
+
+#ifdef ADABOOT
+    #define NUM_LED_FLASHES 3
+    #define ADABOOT_VER	1
+#endif
+
+
+/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
+#define MAX_ERROR_COUNT 5
+
+/* set the UART baud rate */
+/* 20080711: hack by Zach Hoeken */
+#define BAUD_RATE   38400
+
+/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
+/* never allow AVR Studio to do an update !!!! */
+#define HW_VER	 0x02
+#define SW_MAJOR 0x01
+#define SW_MINOR 0x10
+
+/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
+/* if monitor functions are included, LED goes on after monitor was entered */
+#define LED_DDR  DDRB
+#define LED_PORT PORTB
+#define LED_PIN  PINB
+#define LED      PINB0
+
+/* define various device id's */
+/* manufacturer byte is always the same */
+#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
+#if defined(__AVR_ATmega644P__)
+#define SIG2	0x96
+#define SIG3	0x0A
+#elif defined(__AVR_ATmega644__)
+#define SIG2	0x96
+#define SIG3	0x09
+#elif defined(__AVR_ATmega324P__)
+#define SIG2	0x95
+#define SIG3	0x08
+#endif
+#define PAGE_SIZE		0x080U   //128 words
+#define PAGE_SIZE_BYTES	0x100U   //256 bytes
+
+/* function prototypes */
+void putch(char);
+char getch(void);
+void getNch(uint8_t);
+void byte_response(uint8_t);
+void nothing_response(void);
+char gethex(void);
+void puthex(char);
+void flash_led(uint8_t);
+
+/* some variables */
+union address_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} address;
+
+union length_union
+{
+    uint16_t word;
+    uint8_t  byte[2];
+} length;
+
+struct flags_struct
+{
+    unsigned eeprom : 1;
+    unsigned rampz  : 1;
+} flags;
+
+uint8_t buff[256];
+
+uint8_t error_count = 0;
+uint8_t sreg;
+
+void (*app_start)(void) = 0x0000;
+
+/* main program starts here */
+int main(void)
+{
+    uint8_t ch,ch2;
+    uint16_t w;
+	uint16_t i;
+	
+    asm volatile("nop\n\t");
+
+#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
+    ch = MCUSR;
+    MCUSR = 0;
+
+    WDTCSR |= _BV(WDCE) | _BV(WDE);
+    WDTCSR = 0;
+
+    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
+    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
+      app_start();  // skip bootloader
+#endif
+
+
+	//initialize our serial port.
+    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
+    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
+    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
+    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
+
+    /* Enable internal pull-up resistor on pin D0 (RX), in order
+    to supress line noise that prevents the bootloader from
+    timing out (DAM: 20070509) */
+    DDRD &= ~_BV(PIND0);
+    PORTD |= _BV(PIND0);
+
+    /* set LED pin as output */
+    LED_DDR |= _BV(LED);
+
+	    /* flash onboard LED to signal entering of bootloader                   */
+	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
+	    /* then a pause and another flash series signifying ADABOOT sub-version */
+
+
+	flash_led(NUM_LED_FLASHES);
+
+	#ifdef	ADABOOT
+		flash_led(ADABOOT_VER);		// BBR 9/13/2008
+	#endif 
+
+    /* forever loop */
+    for (;;)
+	{
+		/* get character from UART */
+		ch = getch();
+
+		/* A bunch of if...else if... gives smaller code than switch...case ! */
+
+		/* Hello is anyone home ? */ 
+		if(ch=='0')
+		    nothing_response();
+
+
+		/* Request programmer ID */
+		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
+		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
+		else if(ch=='1')
+		{
+		    if (getch() == ' ')
+			{
+				putch(0x14);
+				putch('A');
+				putch('V');
+				putch('R');
+				putch(' ');
+				putch('I');
+				putch('S');
+				putch('P');
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }
+		}
+
+
+		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
+		else if(ch=='@')
+		{
+		    ch2 = getch();
+		    if (ch2 > 0x85)
+				getch();
+		    nothing_response();
+		}
+
+
+		/* AVR ISP/STK500 board requests */
+		else if(ch=='A')
+		{
+		    ch2 = getch();
+		    if(ch2 == 0x80)
+				byte_response(HW_VER);		// Hardware version
+		    else if(ch2==0x81)
+				byte_response(SW_MAJOR);	// Software major version
+		    else if(ch2==0x82)
+				byte_response(SW_MINOR);	// Software minor version
+		    else if(ch2==0x98)
+				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
+		    else
+				byte_response(0x00);		// Covers various unnecessary responses we don't care about
+		}
+
+
+		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
+		else if(ch=='B')
+		{
+		    getNch(20);
+		    nothing_response();
+		}
+
+
+		/* Parallel programming stuff  DON'T CARE  */
+		else if(ch=='E')
+		{
+		    getNch(5);
+		    nothing_response();
+		}
+
+
+		/* Enter programming mode  */
+		else if(ch=='P')
+		{
+		    nothing_response();
+		}
+
+
+		/* Leave programming mode  */
+		else if(ch=='Q')
+		{
+		    nothing_response();
+#ifdef ADABOOT		
+			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
+	  		WDTCSR = _BV(WDE);
+	  		while (1); // 16 ms
+#endif		
+		}
+
+
+		/* Erase device, don't care as we will erase one page at a time anyway.  */
+		else if(ch=='R')
+		{
+		    nothing_response();
+		}
+
+
+		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
+		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
+		/* This might explain why little endian was used here, big endian used everywhere else.  */
+		else if(ch=='U')
+		{
+		    address.byte[0] = getch();
+		    address.byte[1] = getch();
+		    nothing_response();
+		}
+
+
+		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
+		else if(ch=='V')
+		{
+		    getNch(4);
+		    byte_response(0x00);
+		}
+
+
+		/* Write memory, length is big endian and is in bytes  */
+		else if(ch=='d')
+		{
+		    length.byte[1] = getch();
+		    length.byte[0] = getch();
+	
+		    flags.eeprom = 0;
+		    if (getch() == 'E')
+				flags.eeprom = 1;
+
+			for (i=0; i<PAGE_SIZE; i++)
+				buff[i] = 0;
+		
+		    for (w = 0; w < length.word; w++)
+			{
+				// Store data in buffer, can't keep up with serial data stream whilst programming pages
+				buff[w] = getch();
+		    }
+	
+		    if (getch() == ' ')
+			{
+				if (flags.eeprom)
+				{		                
+					//Write to EEPROM one byte at a time
+				    for(w=0;w<length.word;w++)
+					{
+						while(EECR & (1<<EEPE));
+					
+						EEAR = (uint16_t)(void *)address.word;
+						EEDR = buff[w];
+						EECR |= (1<<EEMPE);
+						EECR |= (1<<EEPE);
+
+						address.word++;
+				    }			
+				}
+				else
+				{
+					//address * 2 -> byte location
+				    address.word = address.word << 1;
+			    
+					//Even up an odd number of bytes
+					if ((length.byte[0] & 0x01))
+						length.word++;
+				
+					// HACKME: EEPE used to be EEWE
+				    //Wait for previous EEPROM writes to complete
+					//while(bit_is_set(EECR,EEPE));
+					while(EECR & (1<<EEPE));
+				
+				    asm volatile(
+						 "clr	r17		\n\t"	//page_word_count
+						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
+						 "lds	r31,address+1	\n\t"
+						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
+						 "ldi	r29,hi8(buff)	\n\t"
+						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
+						 "lds	r25,length+1	\n\t"
+						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
+						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
+						 "brne	no_page_erase	\n\t"						 
+						 "wait_spm1:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm1       \n\t"
+						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"							 
+						 "wait_spm2:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm2       \n\t"									 
+
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"
+						 "no_page_erase:		\n\t"							 
+						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
+						 "ld	r1,Y+		\n\t"							 
+							 
+						 "wait_spm3:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm3       \n\t"
+						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+							 
+						 "inc	r17		\n\t"	//page_word_count++
+						 "cpi r17,%1	        \n\t"
+						 "brlo	same_page	\n\t"	//Still same page in FLASH
+						 "write_page:		\n\t"
+						 "clr	r17		\n\t"	//New page, write current one first
+						 "wait_spm4:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm4       \n\t"						 							 
+						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
+						 "sts	%0,r16		\n\t"
+						 "spm			\n\t"
+						 "wait_spm5:		\n\t"
+						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
+						 "andi	r16,1           \n\t"
+						 "cpi	r16,1           \n\t"
+						 "breq	wait_spm5       \n\t"									 
+						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
+						 "sts	%0,r16		\n\t"						 			 
+						 "spm			\n\t"					 		 
+						 "same_page:		\n\t"							 
+						 "adiw	r30,2		\n\t"	//Next word in FLASH
+						 "sbiw	r24,2		\n\t"	//length-2
+						 "breq	final_write	\n\t"	//Finished
+						 "rjmp	length_loop	\n\t"
+						 "final_write:		\n\t"
+						 "cpi	r17,0		\n\t"
+						 "breq	block_done	\n\t"
+						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
+						 "rjmp	write_page	\n\t"
+						 "block_done:		\n\t"
+						 "clr	__zero_reg__	\n\t"	//restore zero register
+						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
+
+						 );
+				}
+				putch(0x14);
+				putch(0x10);
+		    }
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+				    app_start();
+		    }		
+		}
+    
+		/* Read memory block mode, length is big endian.  */
+		else if(ch=='t')
+		{
+			length.byte[1] = getch();
+			length.byte[0] = getch();
+
+			if (getch() == 'E')
+				flags.eeprom = 1;
+			else
+			{
+				flags.eeprom = 0;
+				address.word = address.word << 1;	        // address * 2 -> byte location
+			}
+
+			// Command terminator
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				for (w=0; w<length.word; w++)
+				{
+					// Can handle odd and even lengths okay
+				    if (flags.eeprom) 
+					{
+						// Byte access EEPROM read
+						while(EECR & (1<<EEPE));
+						EEAR = (uint16_t)(void *)address.word;
+						EECR |= (1<<EERE);
+						putch(EEDR);
+
+						address.word++;
+				    }
+				    else
+					{
+						if (!flags.rampz)
+							putch(pgm_read_byte_near(address.word));
+
+						address.word++;
+				    }
+				}
+				putch(0x10);
+		    }
+		}
+
+
+		/* Get device signature bytes  */
+		else if(ch=='u')
+		{
+			if (getch() == ' ')
+			{
+				putch(0x14);
+				putch(SIG1);
+				putch(SIG2);
+				putch(SIG3);
+				putch(0x10);
+			}
+			else
+			{
+				if (++error_count == MAX_ERROR_COUNT)
+					app_start();
+			}
+		}
+
+
+		/* Read oscillator calibration byte */
+		else if(ch=='v')
+			byte_response(0x00);
+
+		else if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+
+	}
+    /* end of forever loop */
+}
+
+
+char gethex(void)
+{
+    char ah,al;
+
+    ah = getch();
+	putch(ah);
+    al = getch();
+	putch(al);
+    
+	if(ah >= 'a')
+		ah = ah - 'a' + 0x0a;
+	else if(ah >= '0')
+		ah -= '0';
+    if(al >= 'a')
+		al = al - 'a' + 0x0a;
+	else if(al >= '0')
+		al -= '0';
+
+    return (ah << 4) + al;
+}
+
+
+void puthex(char ch)
+{
+    char ah,al;
+
+    ah = (ch & 0xf0) >> 4;
+	if(ah >= 0x0a)
+		ah = ah - 0x0a + 'a';
+	else
+		ah += '0';
+
+    al = (ch & 0x0f);
+	if(al >= 0x0a)
+		al = al - 0x0a + 'a';
+	else
+		al += '0';
+
+    putch(ah);
+    putch(al);
+}
+
+
+void putch(char ch)
+{
+    while (!(UCSR0A & _BV(UDRE0)));
+    UDR0 = ch;
+}
+
+
+
+
+char getch(void)
+{
+    uint32_t count = 0;
+
+#ifdef ADABOOT
+	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    while(!(UCSR0A & _BV(RXC0)))
+	{
+    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
+    	/* HACKME:: here is a good place to count times*/
+    	count++;
+    	if (count > MAX_TIME_COUNT)
+    		app_start();
+     }
+
+#ifdef ADABOOT
+	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
+#endif
+
+    return UDR0;
+}
+
+
+void getNch(uint8_t count)
+{
+    uint8_t i;
+    for(i=0;i<count;i++)
+	{
+		while(!(UCSR0A & _BV(RXC0)));
+		UDR0;
+    }
+}
+
+
+void byte_response(uint8_t val)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(val);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+
+void nothing_response(void)
+{
+    if (getch() == ' ')
+	{
+		putch(0x14);
+		putch(0x10);
+    }
+	else
+	{
+		if (++error_count == MAX_ERROR_COUNT)
+		    app_start();
+    }
+}
+
+#ifdef ADABOOT
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED count times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get      */
+	/* optimized away if compiling with optimizations (DAM).          */
+	
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = ADABOOT;
+    }
+    
+
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);					// LED on
+		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
+		LED_PORT &= ~_BV(LED);					// LED off
+		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
+	}
+
+	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
+		
+}
+
+#else
+
+void flash_led(uint8_t count)
+{
+    /* flash onboard LED three times to signal entering of bootloader */
+	/* l needs to be volatile or the delay loops below might get
+	optimized away if compiling with optimizations (DAM). */
+    volatile uint32_t l;
+
+    if (count == 0) {
+      count = 3;
+    }
+    
+	int8_t i;
+    for (i = 0; i < count; ++i) {
+		LED_PORT |= _BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l);
+		LED_PORT &= ~_BV(LED);
+		for(l = 0; l < (F_CPU / 1000); ++l); 
+	}
+		
+}
+
+
+#endif
+
+
+/* end of file ATmegaBOOT.c */
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
new file mode 100644
index 0000000..e67fe88
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D85E90E94067D88E0F2
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
new file mode 100644
index 0000000..d5557de
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
@@ -0,0 +1,120 @@
+:10F800000C94387C0C94557C0C94557C0C94557C51
+:10F810000C94557C0C94557C0C94557C0C94557C24
+:10F820000C94557C0C94557C0C94557C0C94557C14
+:10F830000C94557C0C94557C0C94557C0C94557C04
+:10F840000C94557C0C94557C0C94557C0C94557CF4
+:10F850000C94557C0C94557C0C94557C0C94557CE4
+:10F860000C94557C0C94557C0C94557C0C94557CD4
+:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
+:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
+:10F89000D9F712E0A0E0B1E001C01D92A930B10794
+:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
+:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
+:10F8C000CDBF882309F481E020E0482F552741155A
+:10F8D000510509F43DC0289A19821A821B821C82A4
+:10F8E0000BC089819A81AB81BC810196A11DB11D9C
+:10F8F00089839A83AB83BC8389819A81AB81BC81E4
+:10F9000080589E43A040B04060F3289819821A8224
+:10F910001B821C820BC089819A81AB81BC810196BC
+:10F92000A11DB11D89839A83AB83BC8389819A8190
+:10F93000AB81BC8180509A4FA040B04060F32F5FF4
+:10F94000822F992787FD9095841795070CF4C3CFD4
+:10F9500019821A821B821C8289819A81AB81BC81A7
+:10F9600080509147A240B040A0F489819A81AB8138
+:10F97000BC810196A11DB11D89839A83AB83BC8391
+:10F9800089819A81AB81BC8180509147A240B0406F
+:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
+:10F9A000CF910895EF92FF920F931F93EE24FF24BF
+:10F9B000870128988091C00087FD17C00894E11C3A
+:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
+:10F9D000080780E0180770F3E0910001F091010141
+:10F9E00009958091C00087FFE9CF289A8091C600D1
+:10F9F000992787FD90951F910F91FF90EF900895A3
+:10FA0000982F8091C00085FFFCCF9093C600089589
+:10FA10000E94D27C803271F0809102018F5F8093CE
+:10FA20000201853009F00895E0910001F091010193
+:10FA30000995089584E10E94007D80E10E94007D87
+:10FA40000895CF93C82F0E94D27C803241F08091DC
+:10FA500002018F5F80930201853081F40AC084E146
+:10FA60000E94007D8C2F0E94007D80E10E94007D1D
+:10FA700005C0E0910001F09101010995CF91089531
+:10FA8000282F90E007C08091C0008823E4F7809180
+:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
+:10FAA000CDBF000094B714BE809160008861809340
+:10FAB00060001092600091FF74C189E18093C400DE
+:10FAC0001092C50088E18093C10086E08093C20057
+:10FAD0005098589A209A83E00E94577C81E00E94B7
+:10FAE000577C0E94D27C8033B9F18133C1F18034DC
+:10FAF00009F456C0813409F45CC0823409F46EC044
+:10FB0000853409F471C0803539F1813509F4F3C0C9
+:10FB1000823511F1853509F4D3C0863509F4CBC09F
+:10FB2000843609F465C0843709F4EBC0853709F4DD
+:10FB3000D2C0863709F44AC0809102018F5F80935A
+:10FB40000201853071F6E0910001F0910101099503
+:10FB50000E94D27C803349F60E94087DC2CF0E9469
+:10FB6000D27CC82F803241F784E10E94007D81E47D
+:10FB70000E94007D86E50E94007D82E50E94007D56
+:10FB80008C2F0E94007D89E40E94007D83E50E9405
+:10FB9000007D80E50E94007D80E10E94007DA1CF74
+:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
+:10FBB00098CF0E94D27C803809F407C1813809F4BB
+:10FBC00000C1823809F4F9C0883921F080E00E9430
+:10FBD000217D87CF83E00E94217D83CF84E10E9435
+:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
+:10FBF0000E94D27C809306020E94D27C80930502F0
+:10FC0000809108028E7F809308020E94D27C853406
+:10FC100009F44BC0E5E0F1E0119281E0E438F80727
+:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
+:10FC30001816190678F405E011E00E94D27CF8014C
+:10FC400081938F0121968091050290910602C81739
+:10FC5000D90798F30E94D27C803209F06DCF809151
+:10FC6000080280FFB6C0C0E0D0E0209105023091CC
+:10FC7000060212161306B8F4E0910301F091040194
+:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
+:10FC9000FA9AF99A31962196C217D30798F3F093FE
+:10FCA0000401E093030184E175CF80910802816033
+:10FCB00080930802AFCF84E00E94407D80E087CF30
+:10FCC0000E94D27C809303010E94D27C8093040125
+:10FCD0000E94087D06CF0E94D27C803209F02CCF92
+:10FCE00084E10E94007D8EE10E94007D86E90E94F1
+:10FCF000007D89E04FCF0E94087D88E080936000FE
+:10FD0000FFCF0E94D27C809306020E94D27C809317
+:10FD100005020E94D27C853409F449C08091080212
+:10FD20008E7F809308028091030190910401880FD7
+:10FD3000991F90930401809303010E94D27C80322A
+:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
+:10FD50000502309106021216130608F01DCFE0913D
+:10FD60000301F09104018091080280FF96C0F99987
+:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
+:10FD80000301F09104013196F0930401E093030123
+:10FD900020910502309106022196C217D30718F36D
+:10FDA000FBCEE0910001F0910101099586CE809192
+:10FDB0000802816080930802C0CF80E10E94217D0B
+:10FDC00090CE81E00E94217D8CCE82E00E94217D38
+:10FDD00088CE8091030190910401880F991F909320
+:10FDE0000401809303018091050280FF09C0809186
+:10FDF00005029091060201969093060280930502F7
+:10FE0000F999FECF1127E0910301F0910401C5E0BB
+:10FE1000D1E08091050290910602103091F400919A
+:10FE2000570001700130D9F303E000935700E895C3
+:10FE30000091570001700130D9F301E100935700A0
+:10FE4000E895099019900091570001700130D9F39D
+:10FE500001E000935700E8951395103898F01127AA
+:10FE60000091570001700130D9F305E0009357006D
+:10FE7000E8950091570001700130D9F301E100933A
+:10FE80005700E8953296029709F0C7CF103011F06D
+:10FE90000296E5CF112484E17DCE869580FF06C0D1
+:10FEA0003196F0930401E093030176CF84910E9490
+:10FEB000007D2091050230910602E0910301F0914E
+:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
+:10FED000007D0E94D27C182F0E94007DC1362CF03C
+:10FEE000C75511363CF0175508C0C033D4F3C05382
+:10FEF0001136CCF710330CF01053C295C07FC10FF0
+:10FF00008C2F992787FD9095CF911F910895CF93BE
+:10FF1000282F992787FD9095807F907095958795DC
+:10FF20009595879595958795959587958A303CF019
+:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
+:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
+:0AFF50000E94007DCF910895FFCFBD
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
new file mode 100644
index 0000000..99a6ae1
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
@@ -0,0 +1,121 @@
+:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
+:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
+:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
+:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
+:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
+:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
+:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
+:10F870000C945B7C0C945B7C0C945B7C11241FBE11
+:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
+:10F89000FFEF02C005900D92A030B107D9F712E03A
+:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
+:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
+:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
+:10F8D00009F481E020E0482F55274115510509F42E
+:10F8E0003DC0289A19821A821B821C820BC0898112
+:10F8F0009A81AB81BC810196A11DB11D89839A8338
+:10F90000AB83BC8389819A81AB81BC8180589E4343
+:10F91000A040B04060F3289819821A821B821C8292
+:10F920000BC089819A81AB81BC810196A11DB11D5B
+:10F9300089839A83AB83BC8389819A81AB81BC81A3
+:10F9400080509A4FA040B04060F32F5F822F9927DC
+:10F9500087FD9095841795070CF4C3CF19821A82FE
+:10F960001B821C8289819A81AB81BC818050914726
+:10F97000A240B040A0F489819A81AB81BC810196FC
+:10F98000A11DB11D89839A83AB83BC8389819A8130
+:10F99000AB81BC8180509147A240B04060F3249677
+:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
+:10F9B000EF92FF920F931F93EE24FF248701289864
+:10F9C0008091C00087FD17C00894E11CF11C011D47
+:10F9D000111D81E0E81689E0F8068DE3080780E054
+:10F9E000180770F3E0910001F091010109958091F1
+:10F9F000C00087FFE9CF289A8091C600992787FD2C
+:10FA000090951F910F91FF90EF900895982F8091FE
+:10FA1000C00085FFFCCF9093C60008950E94D87C5B
+:10FA2000803271F0809102018F5F809302018530F6
+:10FA300009F00895E0910001F09101010995089500
+:10FA400084E10E94067D80E10E94067D0895CF93A7
+:10FA5000C82F0E94D87C803241F0809102018F5FD4
+:10FA600080930201853081F40AC084E10E94067D02
+:10FA70008C2F0E94067D80E10E94067D05C0E091EA
+:10FA80000001F09101010995CF910895282F90E090
+:10FA900007C08091C0008823E4F78091C6009F5F73
+:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
+:10FAB00094B714BE809160008861809360001092BA
+:10FAC000600091FF74C189E18093C4001092C50069
+:10FAD00088E18093C10086E08093C2005098589AD4
+:10FAE000209A83E00E945D7C81E00E945D7C0E9400
+:10FAF000D87C8033B9F18133C1F1803409F456C028
+:10FB0000813409F45CC0823409F46EC0853409F490
+:10FB100071C0803539F1813509F4F3C0823511F1B6
+:10FB2000853509F4D3C0863509F4CBC0843609F491
+:10FB300065C0843709F4EBC0853709F4D2C0863735
+:10FB400009F44AC0809102018F5F809302018530E1
+:10FB500071F6E0910001F091010109950E94D87CB5
+:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
+:10FB7000803241F784E10E94067D81E40E94067D87
+:10FB800086E50E94067D82E50E94067D8C2F0E94FC
+:10FB9000067D89E40E94067D83E50E94067D80E55E
+:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
+:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
+:10FBC000D87C803809F407C1813809F400C1823833
+:10FBD00009F4F9C0883921F080E00E94277D87CFA1
+:10FBE00083E00E94277D83CF84E10E94467D0E94AE
+:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
+:10FC0000809306020E94D87C8093050280910802AE
+:10FC10008E7F809308020E94D87C853409F44BC003
+:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
+:10FC3000C0E0D0E0809105029091060218161906E6
+:10FC400078F405E011E00E94D87CF80181938F01DF
+:10FC500021968091050290910602C817D90798F362
+:10FC60000E94D87C803209F06DCF8091080280FF1D
+:10FC7000B6C0C0E0D0E02091050230910602121615
+:10FC80001306B8F4E0910301F0910401A5E0B1E09E
+:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
+:10FCA00031962196C217D30798F3F0930401E0939D
+:10FCB000030184E175CF809108028160809308027E
+:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
+:10FCD000809303010E94D87C809304010E940E7DD2
+:10FCE00006CF0E94D87C803209F02CCF84E10E949C
+:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
+:10FD00004FCF0E940E7D88E080936000FFCF0E945D
+:10FD1000D87C809306020E94D87C809305020E94C2
+:10FD2000D87C853409F449C0809108028E7F809385
+:10FD300008028091030190910401880F991F90930C
+:10FD40000401809303010E94D87C803209F0CFCE59
+:10FD500084E10E94067DC0E0D0E020910502309150
+:10FD600006021216130608F01DCFE0910301F09170
+:10FD700004018091080280FF96C0F999FECFF2BD80
+:10FD8000E1BDF89A80B50E94067DE0910301F091F3
+:10FD900004013196F0930401E093030120910502E0
+:10FDA000309106022196C217D30718F3FBCEE091DB
+:10FDB0000001F0910101099586CE809108028160D1
+:10FDC00080930802C0CF80E10E94277D90CE81E021
+:10FDD0000E94277D8CCE82E00E94277D88CE809174
+:10FDE000030190910401880F991F9093040180935F
+:10FDF00003018091050280FF09C080910502909166
+:10FE0000060201969093060280930502F999FECFAF
+:10FE10001127E0910301F0910401C5E0D1E0809148
+:10FE2000050290910602103091F400915700017084
+:10FE30000130D9F303E000935700E8950091570093
+:10FE400001700130D9F301E100935700E895099062
+:10FE500019900091570001700130D9F301E000932F
+:10FE60005700E8951395103898F011270091570026
+:10FE700001700130D9F305E000935700E895009137
+:10FE8000570001700130D9F301E100935700E89564
+:10FE90003296029709F0C7CF103011F00296E5CFE5
+:10FEA000112484E17DCE869580FF06C03196F093C3
+:10FEB0000401E093030176CF84910E94067D209196
+:10FEC000050230910602E0910301F0910401EECFAA
+:10FED0001F93CF930E94D87CC82F0E94067D0E945A
+:10FEE000D87C182F0E94067DC1362CF0C7551136DC
+:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
+:10FF000010330CF01053C295C07FC10F8C2F99276E
+:10FF100087FD9095CF911F910895CF93282F992712
+:10FF200087FD9095807F907095958795959587959D
+:10FF300095958795959587958A303CF0895AC22F7B
+:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
+:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
+:06FF6000CF910895FFCFD0
+:040000030000F80001
+:00000001FF
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile
new file mode 100644
index 0000000..5714395
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/Makefile
@@ -0,0 +1,56 @@
+# Makefile for ATmegaBOOT
+# E.Lins, 18.7.2005
+# $Id$
+
+
+# program name should not be changed...
+PROGRAM    = ATmegaBOOT_644P
+
+# enter the target CPU frequency
+AVR_FREQ   = 16000000L
+
+MCU_TARGET = atmega644p
+LDSECTION  = --section-start=.text=0xF800
+
+OBJ        = $(PROGRAM).o
+OPTIMIZE   = -O2
+
+DEFS       = 
+LIBS       = 
+
+CC         = avr-gcc
+
+
+# Override is only needed by avr-lib build system.
+
+override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
+override LDFLAGS       = -Wl,$(LDSECTION)
+#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
+
+OBJCOPY        = avr-objcopy
+OBJDUMP        = avr-objdump
+
+all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
+all: $(PROGRAM).hex
+
+$(PROGRAM).hex: $(PROGRAM).elf
+	$(OBJCOPY) -j .text -j .data -O ihex $< $@
+	
+$(PROGRAM).elf: $(OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
+	
+$(OBJ): ATmegaBOOT.c
+	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
+
+%.lst: %.elf
+	$(OBJDUMP) -h -S $< > $@
+
+%.srec: %.elf
+	$(OBJCOPY) -j .text -j .data -O srec $< $@
+
+%.bin: %.elf
+	$(OBJCOPY) -j .text -j .data -O binary $< $@
+
+clean:
+	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
+	
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt
new file mode 100644
index 0000000..8286007
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/bootloaders/atmega644p/README.txt
@@ -0,0 +1,3 @@
+Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
+To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h
new file mode 100644
index 0000000..e29959b
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Copy of wiring.h	
@@ -0,0 +1,135 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp
new file mode 100644
index 0000000..d4931b4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.cpp
@@ -0,0 +1,187 @@
+/*
+  HardwareSerial.cpp - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+  
+  Modified 23 November 2006 by David A. Mellis
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "wiring.h"
+#include "wiring_private.h"
+
+// this next line disables the entire HardwareSerial.cpp, 
+// this is so I can support Attiny series and any other chip without a uart
+#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
+
+#include "HardwareSerial.h"
+
+// Define constants and variables for buffering incoming serial data.  We're
+// using a ring buffer (I think), in which rx_buffer_head is the index of the
+// location to which to write the next incoming character and rx_buffer_tail
+// is the index of the location from which to read.
+#define RX_BUFFER_SIZE 128
+
+struct ring_buffer
+{
+  unsigned char buffer[RX_BUFFER_SIZE];
+  int head;
+  int tail;
+};
+
+ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
+
+inline void store_char(unsigned char c, ring_buffer *rx_buffer)
+{
+  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
+
+  // if we should be storing the received character into the location
+  // just before the tail (meaning that the head would advance to the
+  // current location of the tail), we're about to overflow the buffer
+  // and so we don't write the character or advance the head.
+  if (i != rx_buffer->tail) {
+    rx_buffer->buffer[rx_buffer->head] = c;
+    rx_buffer->head = i;
+  }
+}
+
+// fixed by Mark Sproul this is on the 644/644p
+//SIGNAL(SIG_USART_RECV)
+SIGNAL(USART0_RX_vect)
+{
+  unsigned char c  =  UDR0;
+  store_char(c, &rx_buffer);
+}
+
+
+// Constructors ////////////////////////////////////////////////////////////////
+
+HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
+  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+  volatile uint8_t *udr,
+  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
+{
+  _rx_buffer = rx_buffer;
+  _ubrrh = ubrrh;
+  _ubrrl = ubrrl;
+  _ucsra = ucsra;
+  _ucsrb = ucsrb;
+  _udr = udr;
+  _rxen = rxen;
+  _txen = txen;
+  _rxcie = rxcie;
+  _udre = udre;
+  _u2x = u2x;
+}
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+void HardwareSerial::begin(long baud)
+{
+  uint16_t baud_setting;
+  bool use_u2x = true;
+
+#if F_CPU == 16000000UL
+  // hardcoded exception for compatibility with the bootloader shipped
+  // with the Duemilanove and previous boards and the firmware on the 8U2
+  // on the Uno and Mega 2560.
+  if (baud == 57600) {
+    use_u2x = false;
+  }
+#endif
+  
+  if (use_u2x) {
+    *_ucsra = 1 << _u2x;
+    baud_setting = (F_CPU / 4 / baud - 1) / 2;
+  } else {
+    *_ucsra = 0;
+    baud_setting = (F_CPU / 8 / baud - 1) / 2;
+  }
+
+  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
+  *_ubrrh = baud_setting >> 8;
+  *_ubrrl = baud_setting;
+
+  sbi(*_ucsrb, _rxen);
+  sbi(*_ucsrb, _txen);
+  sbi(*_ucsrb, _rxcie);
+}
+
+void HardwareSerial::end()
+{
+  cbi(*_ucsrb, _rxen);
+  cbi(*_ucsrb, _txen);
+  cbi(*_ucsrb, _rxcie);  
+}
+
+int HardwareSerial::available(void)
+{
+  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
+}
+
+int HardwareSerial::peek(void)
+{
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    return _rx_buffer->buffer[_rx_buffer->tail];
+  }
+}
+
+int HardwareSerial::read(void)
+{
+  // if the head isn't ahead of the tail, we don't have any characters
+  if (_rx_buffer->head == _rx_buffer->tail) {
+    return -1;
+  } else {
+    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
+    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
+    return c;
+  }
+}
+
+void HardwareSerial::flush()
+{
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // don't reverse this or there may be problems if the RX interrupt
+  // occurs after reading the value of rx_buffer_head but before writing
+  // the value to rx_buffer_tail; the previous value of rx_buffer_head
+  // may be written to rx_buffer_tail, making it appear as if the buffer
+  // were full, not empty.
+  _rx_buffer->head = _rx_buffer->tail;
+}
+
+void HardwareSerial::write(uint8_t c)
+{
+  while (!((*_ucsra) & (1 << _udre)))
+    ;
+
+  *_udr = c;
+}
+
+// Preinstantiate Objects //////////////////////////////////////////////////////
+HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
+
+#endif // whole file
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h
new file mode 100644
index 0000000..3efa775
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/HardwareSerial.h
@@ -0,0 +1,76 @@
+/*
+  HardwareSerial.h - Hardware serial library for Wiring
+  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+  Modified 28 September 2010 by Mark Sproul
+*/
+
+#ifndef HardwareSerial_h
+#define HardwareSerial_h
+
+#include <inttypes.h>
+
+#include "Stream.h"
+
+struct ring_buffer;
+
+class HardwareSerial : public Stream
+{
+  private:
+    ring_buffer *_rx_buffer;
+    volatile uint8_t *_ubrrh;
+    volatile uint8_t *_ubrrl;
+    volatile uint8_t *_ucsra;
+    volatile uint8_t *_ucsrb;
+    volatile uint8_t *_udr;
+    uint8_t _rxen;
+    uint8_t _txen;
+    uint8_t _rxcie;
+    uint8_t _udre;
+    uint8_t _u2x;
+  public:
+    HardwareSerial(ring_buffer *rx_buffer,
+      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
+      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
+      volatile uint8_t *udr,
+      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
+    void begin(long);
+    void end();
+    virtual int available(void);
+    virtual int peek(void);
+    virtual int read(void);
+    virtual void flush(void);
+    virtual void write(uint8_t);
+    using Print::write; // pull in write(str) and write(buf, size) from Print
+};
+
+#if defined(UBRRH) || defined(UBRR0H)
+  extern HardwareSerial Serial;
+#elif defined(USBCON)
+  #include "usb_api.h"
+#endif
+#if defined(UBRR1H)
+  extern HardwareSerial Serial1;
+#endif
+#if defined(UBRR2H)
+  extern HardwareSerial Serial2;
+#endif
+#if defined(UBRR3H)
+  extern HardwareSerial Serial3;
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp
new file mode 100644
index 0000000..4ee556d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.cpp
@@ -0,0 +1,220 @@
+/*
+ Print.cpp - Base class that provides print() and println()
+ Copyright (c) 2008 David A. Mellis.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 
+ Modified 23 November 2006 by David A. Mellis
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include "wiring.h"
+
+#include "Print.h"
+
+// Public Methods //////////////////////////////////////////////////////////////
+
+/* default implementation: may be overridden */
+void Print::write(const char *str)
+{
+  while (*str)
+    write(*str++);
+}
+
+/* default implementation: may be overridden */
+void Print::write(const uint8_t *buffer, size_t size)
+{
+  while (size--)
+    write(*buffer++);
+}
+
+void Print::print(const String &s)
+{
+  for (int i = 0; i < s.length(); i++) {
+    write(s[i]);
+  }
+}
+
+void Print::print(const char str[])
+{
+  write(str);
+}
+
+void Print::print(char c, int base)
+{
+  print((long) c, base);
+}
+
+void Print::print(unsigned char b, int base)
+{
+  print((unsigned long) b, base);
+}
+
+void Print::print(int n, int base)
+{
+  print((long) n, base);
+}
+
+void Print::print(unsigned int n, int base)
+{
+  print((unsigned long) n, base);
+}
+
+void Print::print(long n, int base)
+{
+  if (base == 0) {
+    write(n);
+  } else if (base == 10) {
+    if (n < 0) {
+      print('-');
+      n = -n;
+    }
+    printNumber(n, 10);
+  } else {
+    printNumber(n, base);
+  }
+}
+
+void Print::print(unsigned long n, int base)
+{
+  if (base == 0) write(n);
+  else printNumber(n, base);
+}
+
+void Print::print(double n, int digits)
+{
+  printFloat(n, digits);
+}
+
+void Print::println(void)
+{
+  print('\r');
+  print('\n');  
+}
+
+void Print::println(const String &s)
+{
+  print(s);
+  println();
+}
+
+void Print::println(const char c[])
+{
+  print(c);
+  println();
+}
+
+void Print::println(char c, int base)
+{
+  print(c, base);
+  println();
+}
+
+void Print::println(unsigned char b, int base)
+{
+  print(b, base);
+  println();
+}
+
+void Print::println(int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned int n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(unsigned long n, int base)
+{
+  print(n, base);
+  println();
+}
+
+void Print::println(double n, int digits)
+{
+  print(n, digits);
+  println();
+}
+
+// Private Methods /////////////////////////////////////////////////////////////
+
+void Print::printNumber(unsigned long n, uint8_t base)
+{
+  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
+  unsigned long i = 0;
+
+  if (n == 0) {
+    print('0');
+    return;
+  } 
+
+  while (n > 0) {
+    buf[i++] = n % base;
+    n /= base;
+  }
+
+  for (; i > 0; i--)
+    print((char) (buf[i - 1] < 10 ?
+      '0' + buf[i - 1] :
+      'A' + buf[i - 1] - 10));
+}
+
+void Print::printFloat(double number, uint8_t digits) 
+{ 
+  // Handle negative numbers
+  if (number < 0.0)
+  {
+     print('-');
+     number = -number;
+  }
+
+  // Round correctly so that print(1.999, 2) prints as "2.00"
+  double rounding = 0.5;
+  for (uint8_t i=0; i<digits; ++i)
+    rounding /= 10.0;
+  
+  number += rounding;
+
+  // Extract the integer part of the number and print it
+  unsigned long int_part = (unsigned long)number;
+  double remainder = number - (double)int_part;
+  print(int_part);
+
+  // Print the decimal point, but only if there are digits beyond
+  if (digits > 0)
+    print("."); 
+
+  // Extract digits from the remainder one at a time
+  while (digits-- > 0)
+  {
+    remainder *= 10.0;
+    int toPrint = int(remainder);
+    print(toPrint);
+    remainder -= toPrint; 
+  } 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h
new file mode 100644
index 0000000..b092ae5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Print.h
@@ -0,0 +1,66 @@
+/*
+  Print.h - Base class that provides print() and println()
+  Copyright (c) 2008 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Print_h
+#define Print_h
+
+#include <inttypes.h>
+#include <stdio.h> // for size_t
+
+#include "WString.h"
+
+#define DEC 10
+#define HEX 16
+#define OCT 8
+#define BIN 2
+#define BYTE 0
+
+class Print
+{
+  private:
+    void printNumber(unsigned long, uint8_t);
+    void printFloat(double, uint8_t);
+  public:
+    virtual void write(uint8_t) = 0;
+    virtual void write(const char *str);
+    virtual void write(const uint8_t *buffer, size_t size);
+    
+    void print(const String &);
+    void print(const char[]);
+    void print(char, int = BYTE);
+    void print(unsigned char, int = BYTE);
+    void print(int, int = DEC);
+    void print(unsigned int, int = DEC);
+    void print(long, int = DEC);
+    void print(unsigned long, int = DEC);
+    void print(double, int = 2);
+
+    void println(const String &s);
+    void println(const char[]);
+    void println(char, int = BYTE);
+    void println(unsigned char, int = BYTE);
+    void println(int, int = DEC);
+    void println(unsigned int, int = DEC);
+    void println(long, int = DEC);
+    void println(unsigned long, int = DEC);
+    void println(double, int = 2);
+    void println(void);
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h
new file mode 100644
index 0000000..93d8275
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Stream.h
@@ -0,0 +1,35 @@
+/*
+  Stream.h - base class for character-based streams.
+  Copyright (c) 2010 David A. Mellis.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef Stream_h
+#define Stream_h
+
+#include <inttypes.h>
+#include "Print.h"
+
+class Stream : public Print
+{
+  public:
+    virtual int available() = 0;
+    virtual int read() = 0;
+    virtual int peek() = 0;
+    virtual void flush() = 0;
+};
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp
new file mode 100644
index 0000000..c3910e7
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/Tone.cpp
@@ -0,0 +1,601 @@
+/* Tone.cpp
+
+  A Tone Generator Library
+
+  Written by Brett Hagman
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Version Modified By Date     Comments
+------- ----------- -------- --------
+0001    B Hagman    09/08/02 Initial coding
+0002    B Hagman    09/08/18 Multiple pins
+0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
+0004    B Hagman    09/09/26 Fixed problems with ATmega8
+0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
+                    09/11/25 Changed pin toggle method to XOR
+                    09/11/25 Fixed timer0 from being excluded
+0006    D Mellis    09/12/29 Replaced objects with functions
+0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
+*************************************************/
+
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include "wiring.h"
+#include "pins_arduino.h"
+
+#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
+#define TCCR2A TCCR2
+#define TCCR2B TCCR2
+#define COM2A1 COM21
+#define COM2A0 COM20
+#define OCR2A OCR2
+#define TIMSK2 TIMSK
+#define OCIE2A OCIE2
+#define TIMER2_COMPA_vect TIMER2_COMP_vect
+#define TIMSK1 TIMSK
+#endif
+
+// timerx_toggle_count:
+//  > 0 - duration specified
+//  = 0 - stopped
+//  < 0 - infinitely (until stop() method called, or new play() called)
+
+#if !defined(__AVR_ATmega8__)
+volatile long timer0_toggle_count;
+volatile uint8_t *timer0_pin_port;
+volatile uint8_t timer0_pin_mask;
+#endif
+
+volatile long timer1_toggle_count;
+volatile uint8_t *timer1_pin_port;
+volatile uint8_t timer1_pin_mask;
+volatile long timer2_toggle_count;
+volatile uint8_t *timer2_pin_port;
+volatile uint8_t timer2_pin_mask;
+
+#if defined(TIMSK3)
+volatile long timer3_toggle_count;
+volatile uint8_t *timer3_pin_port;
+volatile uint8_t timer3_pin_mask;
+#endif
+
+#if defined(TIMSK4)
+volatile long timer4_toggle_count;
+volatile uint8_t *timer4_pin_port;
+volatile uint8_t timer4_pin_mask;
+#endif
+
+#if defined(TIMSK5)
+volatile long timer5_toggle_count;
+volatile uint8_t *timer5_pin_port;
+volatile uint8_t timer5_pin_mask;
+#endif
+
+
+// MLS: This does not make sense, the 3 options are the same
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
+
+#elif defined(__AVR_ATmega8__)
+
+#define AVAILABLE_TONE_PINS 1
+
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
+
+#else
+
+#define AVAILABLE_TONE_PINS 1
+
+// Leave timer 0 to last.
+const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
+static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
+
+#endif
+
+
+
+static int8_t toneBegin(uint8_t _pin)
+{
+  int8_t _timer = -1;
+
+  // if we're already using the pin, the timer should be configured.  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      return pgm_read_byte(tone_pin_to_timer_PGM + i);
+    }
+  }
+  
+  // search for an unused timer.
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == 255) {
+      tone_pins[i] = _pin;
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      break;
+    }
+  }
+  
+  if (_timer != -1)
+  {
+    // Set timer specific stuff
+    // All timers in CTC mode
+    // 8 bit timers will require changing prescalar values,
+    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
+    switch (_timer)
+    {
+      #if defined(TCCR0A) && defined(TCCR0B)
+      case 0:
+        // 8 bit timer
+        TCCR0A = 0;
+        TCCR0B = 0;
+        bitWrite(TCCR0A, WGM01, 1);
+        bitWrite(TCCR0B, CS00, 1);
+        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer0_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
+      case 1:
+        // 16 bit timer
+        TCCR1A = 0;
+        TCCR1B = 0;
+        bitWrite(TCCR1B, WGM12, 1);
+        bitWrite(TCCR1B, CS10, 1);
+        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer1_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR2A) && defined(TCCR2B)
+      case 2:
+        // 8 bit timer
+        TCCR2A = 0;
+        TCCR2B = 0;
+        bitWrite(TCCR2A, WGM21, 1);
+        bitWrite(TCCR2B, CS20, 1);
+        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer2_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
+      case 3:
+        // 16 bit timer
+        TCCR3A = 0;
+        TCCR3B = 0;
+        bitWrite(TCCR3B, WGM32, 1);
+        bitWrite(TCCR3B, CS30, 1);
+        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer3_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
+      case 4:
+        // 16 bit timer
+        TCCR4A = 0;
+        TCCR4B = 0;
+        #if defined(WGM42)
+          bitWrite(TCCR4B, WGM42, 1);
+        #elif defined(CS43)
+          #warning this may not be correct
+          // atmega32u4
+          bitWrite(TCCR4B, CS43, 1);
+        #endif
+        bitWrite(TCCR4B, CS40, 1);
+        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer4_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+
+      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
+      case 5:
+        // 16 bit timer
+        TCCR5A = 0;
+        TCCR5B = 0;
+        bitWrite(TCCR5B, WGM52, 1);
+        bitWrite(TCCR5B, CS50, 1);
+        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
+        timer5_pin_mask = digitalPinToBitMask(_pin);
+        break;
+      #endif
+    }
+  }
+
+  return _timer;
+}
+
+
+
+// frequency (in hertz) and duration (in milliseconds).
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
+{
+  uint8_t prescalarbits = 0b001;
+  long toggle_count = 0;
+  uint32_t ocr = 0;
+  int8_t _timer;
+
+  _timer = toneBegin(_pin);
+
+  if (_timer >= 0)
+  {
+    // Set the pinMode as OUTPUT
+    pinMode(_pin, OUTPUT);
+    
+    // if we are using an 8 bit timer, scan through prescalars to find the best fit
+    if (_timer == 0 || _timer == 2)
+    {
+      ocr = F_CPU / frequency / 2 - 1;
+      prescalarbits = 0b001;  // ck/1: same for both timers
+      if (ocr > 255)
+      {
+        ocr = F_CPU / frequency / 2 / 8 - 1;
+        prescalarbits = 0b010;  // ck/8: same for both timers
+
+        if (_timer == 2 && ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 32 - 1;
+          prescalarbits = 0b011;
+        }
+
+        if (ocr > 255)
+        {
+          ocr = F_CPU / frequency / 2 / 64 - 1;
+          prescalarbits = _timer == 0 ? 0b011 : 0b100;
+
+          if (_timer == 2 && ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 128 - 1;
+            prescalarbits = 0b101;
+          }
+
+          if (ocr > 255)
+          {
+            ocr = F_CPU / frequency / 2 / 256 - 1;
+            prescalarbits = _timer == 0 ? 0b100 : 0b110;
+            if (ocr > 255)
+            {
+              // can't do any better than /1024
+              ocr = F_CPU / frequency / 2 / 1024 - 1;
+              prescalarbits = _timer == 0 ? 0b101 : 0b111;
+            }
+          }
+        }
+      }
+
+#if defined(TCCR0B)
+      if (_timer == 0)
+      {
+        TCCR0B = prescalarbits;
+      }
+      else
+#endif
+#if defined(TCCR2B)
+      {
+        TCCR2B = prescalarbits;
+      }
+#else
+      {
+        // dummy place holder to make the above ifdefs work
+      }
+#endif
+    }
+    else
+    {
+      // two choices for the 16 bit timers: ck/1 or ck/64
+      ocr = F_CPU / frequency / 2 - 1;
+
+      prescalarbits = 0b001;
+      if (ocr > 0xffff)
+      {
+        ocr = F_CPU / frequency / 2 / 64 - 1;
+        prescalarbits = 0b011;
+      }
+
+      if (_timer == 1)
+      {
+#if defined(TCCR1B)
+        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
+#endif
+      }
+#if defined(TCCR3B)
+      else if (_timer == 3)
+        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR4B)
+      else if (_timer == 4)
+        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
+#endif
+#if defined(TCCR5B)
+      else if (_timer == 5)
+        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
+#endif
+
+    }
+    
+
+    // Calculate the toggle count
+    if (duration > 0)
+    {
+      toggle_count = 2 * frequency * duration / 1000;
+    }
+    else
+    {
+      toggle_count = -1;
+    }
+
+    // Set the OCR for the given timer,
+    // set the toggle count,
+    // then turn on the interrupts
+    switch (_timer)
+    {
+
+#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
+      case 0:
+        OCR0A = ocr;
+        timer0_toggle_count = toggle_count;
+        bitWrite(TIMSK0, OCIE0A, 1);
+        break;
+#endif
+
+      case 1:
+#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK1, OCIE1A, 1);
+#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
+        // this combination is for at least the ATmega32
+        OCR1A = ocr;
+        timer1_toggle_count = toggle_count;
+        bitWrite(TIMSK, OCIE1A, 1);
+#endif
+        break;
+
+#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
+      case 2:
+        OCR2A = ocr;
+        timer2_toggle_count = toggle_count;
+        bitWrite(TIMSK2, OCIE2A, 1);
+        break;
+#endif
+
+#if defined(TIMSK3)
+      case 3:
+        OCR3A = ocr;
+        timer3_toggle_count = toggle_count;
+        bitWrite(TIMSK3, OCIE3A, 1);
+        break;
+#endif
+
+#if defined(TIMSK4)
+      case 4:
+        OCR4A = ocr;
+        timer4_toggle_count = toggle_count;
+        bitWrite(TIMSK4, OCIE4A, 1);
+        break;
+#endif
+
+#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
+      case 5:
+        OCR5A = ocr;
+        timer5_toggle_count = toggle_count;
+        bitWrite(TIMSK5, OCIE5A, 1);
+        break;
+#endif
+
+    }
+  }
+}
+
+
+// XXX: this function only works properly for timer 2 (the only one we use
+// currently).  for the others, it should end the tone, but won't restore
+// proper PWM functionality for the timer.
+void disableTimer(uint8_t _timer)
+{
+  switch (_timer)
+  {
+    case 0:
+      #if defined(TIMSK0)
+        TIMSK0 = 0;
+      #elif defined(TIMSK)
+        TIMSK = 0; // atmega32
+      #endif
+      break;
+
+#if defined(TIMSK1) && defined(OCIE1A)
+    case 1:
+      bitWrite(TIMSK1, OCIE1A, 0);
+      break;
+#endif
+
+    case 2:
+      #if defined(TIMSK2) && defined(OCIE2A)
+        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
+      #endif
+      #if defined(TCCR2A) && defined(WGM20)
+        TCCR2A = (1 << WGM20);
+      #endif
+      #if defined(TCCR2B) && defined(CS22)
+        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
+      #endif
+      #if defined(OCR2A)
+        OCR2A = 0;
+      #endif
+      break;
+
+#if defined(TIMSK3)
+    case 3:
+      TIMSK3 = 0;
+      break;
+#endif
+
+#if defined(TIMSK4)
+    case 4:
+      TIMSK4 = 0;
+      break;
+#endif
+
+#if defined(TIMSK5)
+    case 5:
+      TIMSK5 = 0;
+      break;
+#endif
+  }
+}
+
+
+void noTone(uint8_t _pin)
+{
+  int8_t _timer = -1;
+  
+  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
+    if (tone_pins[i] == _pin) {
+      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
+      tone_pins[i] = 255;
+    }
+  }
+  
+  disableTimer(_timer);
+
+  digitalWrite(_pin, 0);
+}
+
+#if 0
+#if !defined(__AVR_ATmega8__)
+ISR(TIMER0_COMPA_vect)
+{
+  if (timer0_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer0_pin_port ^= timer0_pin_mask;
+
+    if (timer0_toggle_count > 0)
+      timer0_toggle_count--;
+  }
+  else
+  {
+    disableTimer(0);
+    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER1_COMPA_vect)
+{
+  if (timer1_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer1_pin_port ^= timer1_pin_mask;
+
+    if (timer1_toggle_count > 0)
+      timer1_toggle_count--;
+  }
+  else
+  {
+    disableTimer(1);
+    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
+  }
+}
+#endif
+
+
+ISR(TIMER2_COMPA_vect)
+{
+
+  if (timer2_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer2_pin_port ^= timer2_pin_mask;
+
+    if (timer2_toggle_count > 0)
+      timer2_toggle_count--;
+  }
+  else
+  {
+    // need to call noTone() so that the tone_pins[] entry is reset, so the
+    // timer gets initialized next time we call tone().
+    // XXX: this assumes timer 2 is always the first one used.
+    noTone(tone_pins[0]);
+//    disableTimer(2);
+//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
+  }
+}
+
+
+
+//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#if 0
+
+ISR(TIMER3_COMPA_vect)
+{
+  if (timer3_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer3_pin_port ^= timer3_pin_mask;
+
+    if (timer3_toggle_count > 0)
+      timer3_toggle_count--;
+  }
+  else
+  {
+    disableTimer(3);
+    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER4_COMPA_vect)
+{
+  if (timer4_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer4_pin_port ^= timer4_pin_mask;
+
+    if (timer4_toggle_count > 0)
+      timer4_toggle_count--;
+  }
+  else
+  {
+    disableTimer(4);
+    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
+  }
+}
+
+ISR(TIMER5_COMPA_vect)
+{
+  if (timer5_toggle_count != 0)
+  {
+    // toggle the pin
+    *timer5_pin_port ^= timer5_pin_mask;
+
+    if (timer5_toggle_count > 0)
+      timer5_toggle_count--;
+  }
+  else
+  {
+    disableTimer(5);
+    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
+  }
+}
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h
new file mode 100644
index 0000000..79733b5
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WCharacter.h
@@ -0,0 +1,168 @@
+/*
+ WCharacter.h - Character utility functions for Wiring & Arduino
+ Copyright (c) 2010 Hernando Barragan.  All right reserved.
+ 
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ 
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ 
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef Character_h
+#define Character_h
+
+#include <ctype.h>
+
+// WCharacter.h prototypes
+inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
+inline boolean isAlpha(int c) __attribute__((always_inline));
+inline boolean isAscii(int c) __attribute__((always_inline));
+inline boolean isWhitespace(int c) __attribute__((always_inline));
+inline boolean isControl(int c) __attribute__((always_inline));
+inline boolean isDigit(int c) __attribute__((always_inline));
+inline boolean isGraph(int c) __attribute__((always_inline));
+inline boolean isLowerCase(int c) __attribute__((always_inline));
+inline boolean isPrintable(int c) __attribute__((always_inline));
+inline boolean isPunct(int c) __attribute__((always_inline));
+inline boolean isSpace(int c) __attribute__((always_inline));
+inline boolean isUpperCase(int c) __attribute__((always_inline));
+inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
+inline int toAscii(int c) __attribute__((always_inline));
+inline int toLowerCase(int c) __attribute__((always_inline));
+inline int toUpperCase(int c)__attribute__((always_inline));
+
+
+// Checks for an alphanumeric character. 
+// It is equivalent to (isalpha(c) || isdigit(c)).
+inline boolean isAlphaNumeric(int c) 
+{
+  return ( isalnum(c) == 0 ? false : true);
+}
+
+
+// Checks for an alphabetic character. 
+// It is equivalent to (isupper(c) || islower(c)).
+inline boolean isAlpha(int c)
+{
+  return ( isalpha(c) == 0 ? false : true);
+}
+
+
+// Checks whether c is a 7-bit unsigned char value 
+// that fits into the ASCII character set.
+inline boolean isAscii(int c)
+{
+  return ( isascii (c) == 0 ? false : true);
+}
+
+
+// Checks for a blank character, that is, a space or a tab.
+inline boolean isWhitespace(int c)
+{
+  return ( isblank (c) == 0 ? false : true);
+}
+
+
+// Checks for a control character.
+inline boolean isControl(int c)
+{
+  return ( iscntrl (c) == 0 ? false : true);
+}
+
+
+// Checks for a digit (0 through 9).
+inline boolean isDigit(int c)
+{
+  return ( isdigit (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character except space.
+inline boolean isGraph(int c)
+{
+  return ( isgraph (c) == 0 ? false : true);
+}
+
+
+// Checks for a lower-case character.
+inline boolean isLowerCase(int c)
+{
+  return (islower (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character including space.
+inline boolean isPrintable(int c)
+{
+  return ( isprint (c) == 0 ? false : true);
+}
+
+
+// Checks for any printable character which is not a space 
+// or an alphanumeric character.
+inline boolean isPunct(int c)
+{
+  return ( ispunct (c) == 0 ? false : true);
+}
+
+
+// Checks for white-space characters. For the avr-libc library, 
+// these are: space, formfeed ('\f'), newline ('\n'), carriage 
+// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
+inline boolean isSpace(int c)
+{
+  return ( isspace (c) == 0 ? false : true);
+}
+
+
+// Checks for an uppercase letter.
+inline boolean isUpperCase(int c)
+{
+  return ( isupper (c) == 0 ? false : true);
+}
+
+
+// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
+// 8 9 a b c d e f A B C D E F.
+inline boolean isHexadecimalDigit(int c)
+{
+  return ( isxdigit (c) == 0 ? false : true);
+}
+
+
+// Converts c to a 7-bit unsigned char value that fits into the 
+// ASCII character set, by clearing the high-order bits.
+inline int toAscii(int c)
+{
+  return toascii (c);
+}
+
+
+// Warning:
+// Many people will be unhappy if you use this function. 
+// This function will convert accented letters into random 
+// characters.
+
+// Converts the letter c to lower case, if possible.
+inline int toLowerCase(int c)
+{
+  return tolower (c);
+}
+
+
+// Converts the letter c to upper case, if possible.
+inline int toUpperCase(int c)
+{
+  return toupper (c);
+}
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h
new file mode 100644
index 0000000..3e19ac4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WConstants.h
@@ -0,0 +1 @@
+#include "wiring.h"
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c
new file mode 100644
index 0000000..3b3e0c9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WInterrupts.c
@@ -0,0 +1,249 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.uniandes.edu.co
+
+  Copyright (c) 2004-05 Hernando Barragan
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  Modified 24 November 2006 by David A. Mellis
+  Modified 1 August 2010 by Mark Sproul
+*/
+
+#include <inttypes.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <avr/pgmspace.h>
+#include <stdio.h>
+
+#include "WConstants.h"
+#include "wiring_private.h"
+
+volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
+// volatile static voidFuncPtr twiIntFunc;
+
+void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    intFunc[interruptNum] = userFunc;
+    
+    // Configure the interrupt mode (trigger on low input, any change, rising
+    // edge, or falling edge).  The mode constants were chosen to correspond
+    // to the configuration bits in the hardware register, so we simply shift
+    // the mode into place.
+      
+    // Enable the interrupt.
+      
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+      break;
+    case 3:
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+      break;
+    case 4:
+      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
+      EIMSK |= (1 << INT2);
+      break;
+    case 5:
+      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
+      EIMSK |= (1 << INT3);
+      break;
+    case 0:
+      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
+      EIMSK |= (1 << INT4);
+      break;
+    case 1:
+      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
+      EIMSK |= (1 << INT5);
+      break;
+    case 6:
+      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
+      EIMSK |= (1 << INT6);
+      break;
+    case 7:
+      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
+      EIMSK |= (1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      EIMSK |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GICR |= (1 << INT0);
+    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
+      GIMSK |= (1 << INT0);
+    #else
+      #error attachInterrupt not finished for this CPU (case 0)
+    #endif
+      break;
+
+    case 1:
+    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
+      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      EIMSK |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GICR |= (1 << INT1);
+    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
+      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
+      GIMSK |= (1 << INT1);
+    #else
+      #warning attachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+  }
+}
+
+void detachInterrupt(uint8_t interruptNum) {
+  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
+    // Disable the interrupt.  (We can't assume that interruptNum is equal
+    // to the number of the EIMSK bit to clear, as this isn't true on the 
+    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
+    switch (interruptNum) {
+#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
+    case 2:
+      EIMSK &= ~(1 << INT0);
+      break;
+    case 3:
+      EIMSK &= ~(1 << INT1);
+      break;
+    case 4:
+      EIMSK &= ~(1 << INT2);
+      break;
+    case 5:
+      EIMSK &= ~(1 << INT3);
+      break;
+    case 0:
+      EIMSK &= ~(1 << INT4);
+      break;
+    case 1:
+      EIMSK &= ~(1 << INT5);
+      break;
+    case 6:
+      EIMSK &= ~(1 << INT6);
+      break;
+    case 7:
+      EIMSK &= ~(1 << INT7);
+      break;
+#else
+    case 0:
+    #if defined(EIMSK) && defined(INT0)
+      EIMSK &= ~(1 << INT0);
+    #elif defined(GICR) && defined(ISC00)
+      GICR &= ~(1 << INT0); // atmega32
+    #elif defined(GIMSK) && defined(INT0)
+      GIMSK &= ~(1 << INT0);
+    #else
+      #error detachInterrupt not finished for this cpu
+    #endif
+      break;
+
+    case 1:
+    #if defined(EIMSK) && defined(INT1)
+      EIMSK &= ~(1 << INT1);
+    #elif defined(GICR) && defined(INT1)
+      GICR &= ~(1 << INT1); // atmega32
+    #elif defined(GIMSK) && defined(INT1)
+      GIMSK &= ~(1 << INT1);
+    #else
+      #warning detachInterrupt may need some more work for this cpu (case 1)
+    #endif
+      break;
+#endif
+    }
+      
+    intFunc[interruptNum] = 0;
+  }
+}
+
+/*
+void attachInterruptTwi(void (*userFunc)(void) ) {
+  twiIntFunc = userFunc;
+}
+*/
+
+#if defined(EICRA) && defined(EICRB)
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_2])
+    intFunc[EXTERNAL_INT_2]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_3])
+    intFunc[EXTERNAL_INT_3]();
+}
+
+SIGNAL(INT2_vect) {
+  if(intFunc[EXTERNAL_INT_4])
+    intFunc[EXTERNAL_INT_4]();
+}
+
+SIGNAL(INT3_vect) {
+  if(intFunc[EXTERNAL_INT_5])
+    intFunc[EXTERNAL_INT_5]();
+}
+
+SIGNAL(INT4_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT5_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+SIGNAL(INT6_vect) {
+  if(intFunc[EXTERNAL_INT_6])
+    intFunc[EXTERNAL_INT_6]();
+}
+
+SIGNAL(INT7_vect) {
+  if(intFunc[EXTERNAL_INT_7])
+    intFunc[EXTERNAL_INT_7]();
+}
+
+#else
+
+SIGNAL(INT0_vect) {
+  if(intFunc[EXTERNAL_INT_0])
+    intFunc[EXTERNAL_INT_0]();
+}
+
+SIGNAL(INT1_vect) {
+  if(intFunc[EXTERNAL_INT_1])
+    intFunc[EXTERNAL_INT_1]();
+}
+
+#endif
+
+/*
+SIGNAL(SIG_2WIRE_SERIAL) {
+  if(twiIntFunc)
+    twiIntFunc();
+}
+*/
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp
new file mode 100644
index 0000000..2120c4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WMath.cpp
@@ -0,0 +1,60 @@
+/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
+
+/*
+  Part of the Wiring project - http://wiring.org.co
+  Copyright (c) 2004-06 Hernando Barragan
+  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
+  
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+  
+  $Id$
+*/
+
+extern "C" {
+  #include "stdlib.h"
+}
+
+void randomSeed(unsigned int seed)
+{
+  if (seed != 0) {
+    srandom(seed);
+  }
+}
+
+long random(long howbig)
+{
+  if (howbig == 0) {
+    return 0;
+  }
+  return random() % howbig;
+}
+
+long random(long howsmall, long howbig)
+{
+  if (howsmall >= howbig) {
+    return howsmall;
+  }
+  long diff = howbig - howsmall;
+  return random(diff) + howsmall;
+}
+
+long map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+
+unsigned int makeWord(unsigned int w) { return w; }
+unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h
new file mode 100644
index 0000000..f73e760
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WProgram.h
@@ -0,0 +1,63 @@
+#ifndef WProgram_h
+#define WProgram_h
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include <avr/interrupt.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+#include "WCharacter.h"
+#include "WString.h"
+#include "HardwareSerial.h"
+
+uint16_t makeWord(uint16_t w);
+uint16_t makeWord(byte h, byte l);
+
+#define word(...) makeWord(__VA_ARGS__)
+
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
+
+void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
+void noTone(uint8_t _pin);
+
+// WMath prototypes
+long random(long);
+long random(long, long);
+void randomSeed(unsigned int);
+long map(long, long, long, long, long);
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+const static uint8_t A0 = 54;
+const static uint8_t A1 = 55;
+const static uint8_t A2 = 56;
+const static uint8_t A3 = 57;
+const static uint8_t A4 = 58;
+const static uint8_t A5 = 59;
+const static uint8_t A6 = 60;
+const static uint8_t A7 = 61;
+const static uint8_t A8 = 62;
+const static uint8_t A9 = 63;
+const static uint8_t A10 = 64;
+const static uint8_t A11 = 65;
+const static uint8_t A12 = 66;
+const static uint8_t A13 = 67;
+const static uint8_t A14 = 68;
+const static uint8_t A15 = 69;
+#else
+const static uint8_t A0 = 14;
+const static uint8_t A1 = 15;
+const static uint8_t A2 = 16;
+const static uint8_t A3 = 17;
+const static uint8_t A4 = 18;
+const static uint8_t A5 = 19;
+const static uint8_t A6 = 20;
+const static uint8_t A7 = 21;
+#endif
+
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp
new file mode 100644
index 0000000..db5a441
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.cpp
@@ -0,0 +1,443 @@
+/*
+  WString.cpp - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdlib.h>
+#include "WProgram.h"
+#include "WString.h"
+
+
+String::String( const char *value )
+{
+  if ( value == NULL )
+    value = "";
+  getBuffer( _length = strlen( value ) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value );
+}
+
+String::String( const String &value )
+{
+  getBuffer( _length = value._length );
+  if ( _buffer != NULL )
+    strcpy( _buffer, value._buffer );
+}
+
+String::String( const char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL ) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const unsigned char value )
+{
+  _length = 1;
+  getBuffer(1);
+  if ( _buffer != NULL) {
+    _buffer[0] = value;
+    _buffer[1] = 0;
+  }
+}
+
+String::String( const int value, const int base )
+{
+  char buf[33];   
+  itoa((signed long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned int value, const int base )
+{
+  char buf[33];   
+  ultoa((unsigned long)value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const long value, const int base )
+{
+  char buf[33];   
+  ltoa(value, buf, base);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+String::String( const unsigned long value, const int base )
+{
+  char buf[33];   
+  ultoa(value, buf, 10);
+  getBuffer( _length = strlen(buf) );
+  if ( _buffer != NULL )
+    strcpy( _buffer, buf );
+}
+
+char String::charAt( unsigned int loc ) const
+{
+  return operator[]( loc );
+}
+
+void String::setCharAt( unsigned int loc, const char aChar ) 
+{
+  if(_buffer == NULL) return;
+  if(_length > loc) {
+    _buffer[loc] = aChar;
+  }
+}
+
+int String::compareTo( const String &s2 ) const
+{
+  return strcmp( _buffer, s2._buffer );
+}
+
+const String & String::concat( const String &s2 )
+{
+  return (*this) += s2;
+}
+
+const String & String::operator=( const String &rhs )
+{
+  if ( this == &rhs )
+    return *this;
+
+  if ( rhs._length > _length )
+  {
+    free(_buffer);
+    getBuffer( rhs._length );
+  }
+  
+  if ( _buffer != NULL ) {
+    _length = rhs._length;
+    strcpy( _buffer, rhs._buffer );
+  }
+  return *this;
+}
+
+//const String & String::operator+=( const char aChar )
+//{
+//  if ( _length == _capacity )
+//    doubleBuffer();
+//
+//  _buffer[ _length++ ] = aChar;
+//  _buffer[ _length ] = '\0';
+//  return *this;
+//}
+
+const String & String::operator+=( const String &other )
+{
+  _length += other._length;
+  if ( _length > _capacity )
+  {
+    char *temp = (char *)realloc(_buffer, _length + 1);
+    if ( temp != NULL ) {
+      _buffer = temp;
+      _capacity = _length;
+    } else {
+      _length -= other._length;
+      return *this;
+    }
+  }
+  strcat( _buffer, other._buffer );
+  return *this;
+}
+
+
+int String::operator==( const String &rhs ) const
+{
+  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
+}
+
+int String::operator!=( const String &rhs ) const
+{
+  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
+}
+
+int String::operator<( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) < 0;
+}
+
+int String::operator>( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) > 0;
+}
+
+int String::operator<=( const String &rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) <= 0;
+}
+
+int String::operator>=( const String & rhs ) const
+{
+  return strcmp( _buffer, rhs._buffer ) >= 0;
+}
+
+char & String::operator[]( unsigned int index )
+{
+  static char dummy_writable_char;
+  if (index >= _length || !_buffer) {
+    dummy_writable_char = 0;
+    return dummy_writable_char;
+  }
+  return _buffer[ index ];
+}
+
+char String::operator[]( unsigned int index ) const
+{
+  // need to check for valid index, to do later
+  return _buffer[ index ];
+}
+
+boolean String::endsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
+}
+
+boolean String::equals( const String &s2 ) const
+{
+  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
+}
+
+boolean String::equalsIgnoreCase( const String &s2 ) const
+{
+  if ( this == &s2 )
+    return true; //1;
+  else if ( _length != s2._length )
+    return false; //0;
+
+  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
+}
+
+String String::replace( char findChar, char replaceChar )
+{
+  if ( _buffer == NULL ) return *this;
+  String theReturn = _buffer;
+  char* temp = theReturn._buffer;
+  while( (temp = strchr( temp, findChar )) != 0 )
+    *temp = replaceChar;
+
+  return theReturn;
+}
+
+String String::replace( const String& match, const String& replace )
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer, newString;
+
+  int loc;
+  while ( (loc = temp.indexOf( match )) != -1 )
+  {
+    newString += temp.substring( 0, loc );
+    newString += replace;
+    temp = temp.substring( loc + match._length );
+  }
+  newString += temp;  
+  return newString;
+}
+
+int String::indexOf( char temp ) const
+{
+  return indexOf( temp, 0 );
+}
+
+int String::indexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char* temp = strchr( &_buffer[fromIndex], ch );
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::indexOf( const String &s2 ) const
+{
+  return indexOf( s2, 0 );
+}
+
+int String::indexOf( const String &s2, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
+
+  if ( theFind == NULL )
+    return -1;
+
+  return theFind - _buffer; // pointer subtraction
+}
+
+int String::lastIndexOf( char theChar ) const
+{
+  return lastIndexOf( theChar, _length - 1 );
+}
+
+int String::lastIndexOf( char ch, unsigned int fromIndex ) const
+{
+  if ( fromIndex >= _length )
+    return -1;
+
+  char tempchar = _buffer[fromIndex + 1];
+  _buffer[fromIndex + 1] = '\0';
+  char* temp = strrchr( _buffer, ch );
+  _buffer[fromIndex + 1] = tempchar;
+
+  if ( temp == NULL )
+    return -1;
+
+  return temp - _buffer;
+}
+
+int String::lastIndexOf( const String &s2 ) const
+{
+  return lastIndexOf( s2, _length - s2._length );
+}
+
+int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
+{
+  // check for empty strings
+  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
+    return -1;
+
+  // matching first character
+  char temp = s2[ 0 ];
+
+  for ( int i = fromIndex; i >= 0; i-- )
+  {
+    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
+    return i;
+  }
+  return -1;
+}
+
+boolean String::startsWith( const String &s2 ) const
+{
+  if ( _length < s2._length )
+    return 0;
+
+  return startsWith( s2, 0 );
+}
+
+boolean String::startsWith( const String &s2, unsigned int offset ) const
+{
+  if ( offset > _length - s2._length )
+    return 0;
+
+  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
+}
+
+String String::substring( unsigned int left ) const
+{
+  return substring( left, _length );
+}
+
+String String::substring( unsigned int left, unsigned int right ) const
+{
+  if ( left > right )
+  {
+    int temp = right;
+    right = left;
+    left = temp;
+  }
+
+  if ( right > _length )
+  {
+    right = _length;
+  } 
+
+  char temp = _buffer[ right ];  // save the replaced character
+  _buffer[ right ] = '\0';	
+  String outPut = ( _buffer + left );  // pointer arithmetic
+  _buffer[ right ] = temp;  //restore character
+  return outPut;
+}
+
+String String::toLowerCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::toUpperCase() const
+{
+  String temp = _buffer;
+
+  for ( unsigned int i = 0; i < _length; i++ )
+    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
+  return temp;
+}
+
+String String::trim() const
+{
+  if ( _buffer == NULL ) return *this;
+  String temp = _buffer;
+  unsigned int i,j;
+
+  for ( i = 0; i < _length; i++ )
+  {
+    if ( !isspace(_buffer[i]) )
+      break;
+  }
+
+  for ( j = temp._length - 1; j > i; j-- )
+  {
+    if ( !isspace(_buffer[j]) )
+      break;
+  }
+
+  return temp.substring( i, j + 1);
+}
+
+void String::getBytes(unsigned char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy((char *)buf, _buffer, len);
+  buf[len] = 0;
+}
+
+void String::toCharArray(char *buf, unsigned int bufsize)
+{
+  if (!bufsize || !buf) return;
+  unsigned int len = bufsize - 1;
+  if (len > _length) len = _length;
+  strncpy(buf, _buffer, len);
+  buf[len] = 0;
+}
+
+
+long String::toInt() {
+  return atol(_buffer);
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h
new file mode 100644
index 0000000..cadddb9
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/WString.h
@@ -0,0 +1,112 @@
+/*
+  WString.h - String library for Wiring & Arduino
+  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef String_h
+#define String_h
+
+//#include "WProgram.h"
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+class String
+{
+  public:
+    // constructors
+    String( const char *value = "" );
+    String( const String &value );
+    String( const char );
+    String( const unsigned char );
+    String( const int, const int base=10);
+    String( const unsigned int, const int base=10 );
+    String( const long, const int base=10 );
+    String( const unsigned long, const int base=10 );
+    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
+
+    // operators
+    const String & operator = ( const String &rhs );
+    const String & operator +=( const String &rhs );
+    //const String & operator +=( const char );
+    int operator ==( const String &rhs ) const;
+    int	operator !=( const String &rhs ) const;
+    int	operator < ( const String &rhs ) const;
+    int	operator > ( const String &rhs ) const;
+    int	operator <=( const String &rhs ) const;
+    int	operator >=( const String &rhs ) const;
+    char operator []( unsigned int index ) const;
+    char& operator []( unsigned int index );
+    //operator const char *() const { return _buffer; }
+    
+    // general methods
+    char charAt( unsigned int index ) const;
+    int	compareTo( const String &anotherString ) const;
+    unsigned char endsWith( const String &suffix ) const;
+    unsigned char equals( const String &anObject ) const;
+    unsigned char equalsIgnoreCase( const String &anotherString ) const;
+    int	indexOf( char ch ) const;
+    int	indexOf( char ch, unsigned int fromIndex ) const;
+    int	indexOf( const String &str ) const;
+    int	indexOf( const String &str, unsigned int fromIndex ) const;
+    int	lastIndexOf( char ch ) const;
+    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
+    int	lastIndexOf( const String &str ) const;
+    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
+    const unsigned int length( ) const { return _length; }
+    void setCharAt(unsigned int index, const char ch);
+    unsigned char startsWith( const String &prefix ) const;
+    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
+    String substring( unsigned int beginIndex ) const;
+    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
+    String toLowerCase( ) const;
+    String toUpperCase( ) const;
+    String trim( ) const;
+    void getBytes(unsigned char *buf, unsigned int bufsize);
+    void toCharArray(char *buf, unsigned int bufsize);
+    long toInt( );
+    const String& concat( const String &str );
+    String replace( char oldChar, char newChar );
+    String replace( const String& match, const String& replace );
+    friend String operator + ( String lhs, const String &rhs );
+
+  protected:
+    char *_buffer;	     // the actual char array
+    unsigned int _capacity;  // the array length minus one (for the '\0')
+    unsigned int _length;    // the String length (not counting the '\0')
+
+    void getBuffer(unsigned int maxStrLen);
+
+  private:
+
+};
+
+// allocate buffer space
+inline void String::getBuffer(unsigned int maxStrLen)
+{
+  _capacity = maxStrLen;
+  _buffer = (char *) malloc(_capacity + 1);
+  if (_buffer == NULL) _length = _capacity = 0;
+}
+
+inline String operator+( String lhs, const String &rhs )
+{
+  return lhs += rhs;
+}
+
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h
new file mode 100644
index 0000000..af14980
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/binary.h
@@ -0,0 +1,515 @@
+#ifndef Binary_h
+#define Binary_h
+
+#define B0 0
+#define B00 0
+#define B000 0
+#define B0000 0
+#define B00000 0
+#define B000000 0
+#define B0000000 0
+#define B00000000 0
+#define B1 1
+#define B01 1
+#define B001 1
+#define B0001 1
+#define B00001 1
+#define B000001 1
+#define B0000001 1
+#define B00000001 1
+#define B10 2
+#define B010 2
+#define B0010 2
+#define B00010 2
+#define B000010 2
+#define B0000010 2
+#define B00000010 2
+#define B11 3
+#define B011 3
+#define B0011 3
+#define B00011 3
+#define B000011 3
+#define B0000011 3
+#define B00000011 3
+#define B100 4
+#define B0100 4
+#define B00100 4
+#define B000100 4
+#define B0000100 4
+#define B00000100 4
+#define B101 5
+#define B0101 5
+#define B00101 5
+#define B000101 5
+#define B0000101 5
+#define B00000101 5
+#define B110 6
+#define B0110 6
+#define B00110 6
+#define B000110 6
+#define B0000110 6
+#define B00000110 6
+#define B111 7
+#define B0111 7
+#define B00111 7
+#define B000111 7
+#define B0000111 7
+#define B00000111 7
+#define B1000 8
+#define B01000 8
+#define B001000 8
+#define B0001000 8
+#define B00001000 8
+#define B1001 9
+#define B01001 9
+#define B001001 9
+#define B0001001 9
+#define B00001001 9
+#define B1010 10
+#define B01010 10
+#define B001010 10
+#define B0001010 10
+#define B00001010 10
+#define B1011 11
+#define B01011 11
+#define B001011 11
+#define B0001011 11
+#define B00001011 11
+#define B1100 12
+#define B01100 12
+#define B001100 12
+#define B0001100 12
+#define B00001100 12
+#define B1101 13
+#define B01101 13
+#define B001101 13
+#define B0001101 13
+#define B00001101 13
+#define B1110 14
+#define B01110 14
+#define B001110 14
+#define B0001110 14
+#define B00001110 14
+#define B1111 15
+#define B01111 15
+#define B001111 15
+#define B0001111 15
+#define B00001111 15
+#define B10000 16
+#define B010000 16
+#define B0010000 16
+#define B00010000 16
+#define B10001 17
+#define B010001 17
+#define B0010001 17
+#define B00010001 17
+#define B10010 18
+#define B010010 18
+#define B0010010 18
+#define B00010010 18
+#define B10011 19
+#define B010011 19
+#define B0010011 19
+#define B00010011 19
+#define B10100 20
+#define B010100 20
+#define B0010100 20
+#define B00010100 20
+#define B10101 21
+#define B010101 21
+#define B0010101 21
+#define B00010101 21
+#define B10110 22
+#define B010110 22
+#define B0010110 22
+#define B00010110 22
+#define B10111 23
+#define B010111 23
+#define B0010111 23
+#define B00010111 23
+#define B11000 24
+#define B011000 24
+#define B0011000 24
+#define B00011000 24
+#define B11001 25
+#define B011001 25
+#define B0011001 25
+#define B00011001 25
+#define B11010 26
+#define B011010 26
+#define B0011010 26
+#define B00011010 26
+#define B11011 27
+#define B011011 27
+#define B0011011 27
+#define B00011011 27
+#define B11100 28
+#define B011100 28
+#define B0011100 28
+#define B00011100 28
+#define B11101 29
+#define B011101 29
+#define B0011101 29
+#define B00011101 29
+#define B11110 30
+#define B011110 30
+#define B0011110 30
+#define B00011110 30
+#define B11111 31
+#define B011111 31
+#define B0011111 31
+#define B00011111 31
+#define B100000 32
+#define B0100000 32
+#define B00100000 32
+#define B100001 33
+#define B0100001 33
+#define B00100001 33
+#define B100010 34
+#define B0100010 34
+#define B00100010 34
+#define B100011 35
+#define B0100011 35
+#define B00100011 35
+#define B100100 36
+#define B0100100 36
+#define B00100100 36
+#define B100101 37
+#define B0100101 37
+#define B00100101 37
+#define B100110 38
+#define B0100110 38
+#define B00100110 38
+#define B100111 39
+#define B0100111 39
+#define B00100111 39
+#define B101000 40
+#define B0101000 40
+#define B00101000 40
+#define B101001 41
+#define B0101001 41
+#define B00101001 41
+#define B101010 42
+#define B0101010 42
+#define B00101010 42
+#define B101011 43
+#define B0101011 43
+#define B00101011 43
+#define B101100 44
+#define B0101100 44
+#define B00101100 44
+#define B101101 45
+#define B0101101 45
+#define B00101101 45
+#define B101110 46
+#define B0101110 46
+#define B00101110 46
+#define B101111 47
+#define B0101111 47
+#define B00101111 47
+#define B110000 48
+#define B0110000 48
+#define B00110000 48
+#define B110001 49
+#define B0110001 49
+#define B00110001 49
+#define B110010 50
+#define B0110010 50
+#define B00110010 50
+#define B110011 51
+#define B0110011 51
+#define B00110011 51
+#define B110100 52
+#define B0110100 52
+#define B00110100 52
+#define B110101 53
+#define B0110101 53
+#define B00110101 53
+#define B110110 54
+#define B0110110 54
+#define B00110110 54
+#define B110111 55
+#define B0110111 55
+#define B00110111 55
+#define B111000 56
+#define B0111000 56
+#define B00111000 56
+#define B111001 57
+#define B0111001 57
+#define B00111001 57
+#define B111010 58
+#define B0111010 58
+#define B00111010 58
+#define B111011 59
+#define B0111011 59
+#define B00111011 59
+#define B111100 60
+#define B0111100 60
+#define B00111100 60
+#define B111101 61
+#define B0111101 61
+#define B00111101 61
+#define B111110 62
+#define B0111110 62
+#define B00111110 62
+#define B111111 63
+#define B0111111 63
+#define B00111111 63
+#define B1000000 64
+#define B01000000 64
+#define B1000001 65
+#define B01000001 65
+#define B1000010 66
+#define B01000010 66
+#define B1000011 67
+#define B01000011 67
+#define B1000100 68
+#define B01000100 68
+#define B1000101 69
+#define B01000101 69
+#define B1000110 70
+#define B01000110 70
+#define B1000111 71
+#define B01000111 71
+#define B1001000 72
+#define B01001000 72
+#define B1001001 73
+#define B01001001 73
+#define B1001010 74
+#define B01001010 74
+#define B1001011 75
+#define B01001011 75
+#define B1001100 76
+#define B01001100 76
+#define B1001101 77
+#define B01001101 77
+#define B1001110 78
+#define B01001110 78
+#define B1001111 79
+#define B01001111 79
+#define B1010000 80
+#define B01010000 80
+#define B1010001 81
+#define B01010001 81
+#define B1010010 82
+#define B01010010 82
+#define B1010011 83
+#define B01010011 83
+#define B1010100 84
+#define B01010100 84
+#define B1010101 85
+#define B01010101 85
+#define B1010110 86
+#define B01010110 86
+#define B1010111 87
+#define B01010111 87
+#define B1011000 88
+#define B01011000 88
+#define B1011001 89
+#define B01011001 89
+#define B1011010 90
+#define B01011010 90
+#define B1011011 91
+#define B01011011 91
+#define B1011100 92
+#define B01011100 92
+#define B1011101 93
+#define B01011101 93
+#define B1011110 94
+#define B01011110 94
+#define B1011111 95
+#define B01011111 95
+#define B1100000 96
+#define B01100000 96
+#define B1100001 97
+#define B01100001 97
+#define B1100010 98
+#define B01100010 98
+#define B1100011 99
+#define B01100011 99
+#define B1100100 100
+#define B01100100 100
+#define B1100101 101
+#define B01100101 101
+#define B1100110 102
+#define B01100110 102
+#define B1100111 103
+#define B01100111 103
+#define B1101000 104
+#define B01101000 104
+#define B1101001 105
+#define B01101001 105
+#define B1101010 106
+#define B01101010 106
+#define B1101011 107
+#define B01101011 107
+#define B1101100 108
+#define B01101100 108
+#define B1101101 109
+#define B01101101 109
+#define B1101110 110
+#define B01101110 110
+#define B1101111 111
+#define B01101111 111
+#define B1110000 112
+#define B01110000 112
+#define B1110001 113
+#define B01110001 113
+#define B1110010 114
+#define B01110010 114
+#define B1110011 115
+#define B01110011 115
+#define B1110100 116
+#define B01110100 116
+#define B1110101 117
+#define B01110101 117
+#define B1110110 118
+#define B01110110 118
+#define B1110111 119
+#define B01110111 119
+#define B1111000 120
+#define B01111000 120
+#define B1111001 121
+#define B01111001 121
+#define B1111010 122
+#define B01111010 122
+#define B1111011 123
+#define B01111011 123
+#define B1111100 124
+#define B01111100 124
+#define B1111101 125
+#define B01111101 125
+#define B1111110 126
+#define B01111110 126
+#define B1111111 127
+#define B01111111 127
+#define B10000000 128
+#define B10000001 129
+#define B10000010 130
+#define B10000011 131
+#define B10000100 132
+#define B10000101 133
+#define B10000110 134
+#define B10000111 135
+#define B10001000 136
+#define B10001001 137
+#define B10001010 138
+#define B10001011 139
+#define B10001100 140
+#define B10001101 141
+#define B10001110 142
+#define B10001111 143
+#define B10010000 144
+#define B10010001 145
+#define B10010010 146
+#define B10010011 147
+#define B10010100 148
+#define B10010101 149
+#define B10010110 150
+#define B10010111 151
+#define B10011000 152
+#define B10011001 153
+#define B10011010 154
+#define B10011011 155
+#define B10011100 156
+#define B10011101 157
+#define B10011110 158
+#define B10011111 159
+#define B10100000 160
+#define B10100001 161
+#define B10100010 162
+#define B10100011 163
+#define B10100100 164
+#define B10100101 165
+#define B10100110 166
+#define B10100111 167
+#define B10101000 168
+#define B10101001 169
+#define B10101010 170
+#define B10101011 171
+#define B10101100 172
+#define B10101101 173
+#define B10101110 174
+#define B10101111 175
+#define B10110000 176
+#define B10110001 177
+#define B10110010 178
+#define B10110011 179
+#define B10110100 180
+#define B10110101 181
+#define B10110110 182
+#define B10110111 183
+#define B10111000 184
+#define B10111001 185
+#define B10111010 186
+#define B10111011 187
+#define B10111100 188
+#define B10111101 189
+#define B10111110 190
+#define B10111111 191
+#define B11000000 192
+#define B11000001 193
+#define B11000010 194
+#define B11000011 195
+#define B11000100 196
+#define B11000101 197
+#define B11000110 198
+#define B11000111 199
+#define B11001000 200
+#define B11001001 201
+#define B11001010 202
+#define B11001011 203
+#define B11001100 204
+#define B11001101 205
+#define B11001110 206
+#define B11001111 207
+#define B11010000 208
+#define B11010001 209
+#define B11010010 210
+#define B11010011 211
+#define B11010100 212
+#define B11010101 213
+#define B11010110 214
+#define B11010111 215
+#define B11011000 216
+#define B11011001 217
+#define B11011010 218
+#define B11011011 219
+#define B11011100 220
+#define B11011101 221
+#define B11011110 222
+#define B11011111 223
+#define B11100000 224
+#define B11100001 225
+#define B11100010 226
+#define B11100011 227
+#define B11100100 228
+#define B11100101 229
+#define B11100110 230
+#define B11100111 231
+#define B11101000 232
+#define B11101001 233
+#define B11101010 234
+#define B11101011 235
+#define B11101100 236
+#define B11101101 237
+#define B11101110 238
+#define B11101111 239
+#define B11110000 240
+#define B11110001 241
+#define B11110010 242
+#define B11110011 243
+#define B11110100 244
+#define B11110101 245
+#define B11110110 246
+#define B11110111 247
+#define B11111000 248
+#define B11111001 249
+#define B11111010 250
+#define B11111011 251
+#define B11111100 252
+#define B11111101 253
+#define B11111110 254
+#define B11111111 255
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp
new file mode 100644
index 0000000..cc6e81d
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/main.cpp
@@ -0,0 +1,14 @@
+#include <WProgram.h>
+
+int main(void)
+{
+	init();
+
+	setup();
+    
+	for (;;)
+		loop();
+        
+	return 0;
+}
+
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c
new file mode 100644
index 0000000..d5fa6fe
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.c
@@ -0,0 +1,200 @@
+/*
+  pins_arduino.c - pin definitions for the Arduino board
+  Part of Arduino / Wiring Lite
+
+  Copyright (c) 2005 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
+*/
+
+#include <avr/io.h>
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+// On the Sanguino board, digital pins are also used
+// for the analog output (software PWM).  Analog input
+// pins are a separate set.
+
+// ATMEL ATMEGA644P / SANGUINO
+//
+//                   +---\/---+
+//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
+//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
+//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
+//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
+//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
+//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
+//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
+//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
+//             RST  9|        |32  AREF
+//             VCC 10|        |31  GND 
+//             GND 11|        |30  AVCC
+//           XTAL2 12|        |29  PC7 (D 23)
+//           XTAL1 13|        |28  PC6 (D 22)
+//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
+//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
+//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
+//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
+//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
+//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
+//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
+//                   +--------+
+//
+
+#define PA 1
+#define PB 2
+#define PC 3
+#define PD 4
+
+// these arrays map port names (e.g. port B) to the
+// appropriate addresses for various functions (e.g. reading
+// and writing)
+const uint8_t PROGMEM port_to_mode_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &DDRA,
+	(uint8_t) (uint16_t) &DDRB,
+	(uint8_t) (uint16_t) &DDRC,
+	(uint8_t) (uint16_t) &DDRD,
+};
+
+const uint8_t PROGMEM port_to_output_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PORTA,
+	(uint8_t) (uint16_t) &PORTB,
+	(uint8_t) (uint16_t) &PORTC,
+	(uint8_t) (uint16_t) &PORTD,
+};
+
+const uint8_t PROGMEM port_to_input_PGM[] =
+{
+	NOT_A_PORT,
+	(uint8_t) (uint16_t) &PINA,
+	(uint8_t) (uint16_t) &PINB,
+	(uint8_t) (uint16_t) &PINC,
+	(uint8_t) (uint16_t) &PIND,
+};
+
+const uint8_t PROGMEM digital_pin_to_port_PGM[] =
+{
+	PB, /* 0 */
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PB,
+	PD, /* 8 */
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PD,
+	PC, /* 16 */
+	PC,
+	PC,
+	PC,
+	PC,
+	PC,
+   	PC,
+	PC,
+	PA, /* 24 */
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA,
+	PA  /* 31 */
+};
+
+const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
+{
+	_BV(0), /* 0, port B */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 8, port D */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(0), /* 16, port C */
+	_BV(1),
+	_BV(2),
+	_BV(3),
+	_BV(4),
+	_BV(5),
+	_BV(6),
+	_BV(7),
+	_BV(7), /* 24, port A */
+	_BV(6),
+	_BV(5),
+	_BV(4),
+	_BV(3),
+	_BV(2),
+	_BV(1),
+	_BV(0)
+};
+
+const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
+{
+	NOT_ON_TIMER, 	/* 0  - PB0 */
+	NOT_ON_TIMER, 	/* 1  - PB1 */
+	NOT_ON_TIMER, 	/* 2  - PB2 */
+	TIMER0A,     	/* 3  - PB3 */
+	TIMER0B, 		/* 4  - PB4 */
+	NOT_ON_TIMER, 	/* 5  - PB5 */
+	NOT_ON_TIMER, 	/* 6  - PB6 */
+	NOT_ON_TIMER,	/* 7  - PB7 */
+	NOT_ON_TIMER, 	/* 8  - PD0 */
+	NOT_ON_TIMER, 	/* 9  - PD1 */
+	NOT_ON_TIMER, 	/* 10 - PD2 */
+	NOT_ON_TIMER, 	/* 11 - PD3 */
+	TIMER1B,     	/* 12 - PD4 */
+	TIMER1A,     	/* 13 - PD5 */
+	TIMER2B,     	/* 14 - PD6 */
+	TIMER2A,     	/* 15 - PD7 */
+	NOT_ON_TIMER, 	/* 16 - PC0 */
+	NOT_ON_TIMER,   /* 17 - PC1 */
+	NOT_ON_TIMER,   /* 18 - PC2 */
+	NOT_ON_TIMER,   /* 19 - PC3 */
+	NOT_ON_TIMER,   /* 20 - PC4 */
+	NOT_ON_TIMER,   /* 21 - PC5 */
+	NOT_ON_TIMER,   /* 22 - PC6 */
+	NOT_ON_TIMER,   /* 23 - PC7 */
+	NOT_ON_TIMER,   /* 24 - PA0 */
+	NOT_ON_TIMER,   /* 25 - PA1 */
+	NOT_ON_TIMER,   /* 26 - PA2 */
+	NOT_ON_TIMER,   /* 27 - PA3 */
+	NOT_ON_TIMER,   /* 28 - PA4 */
+	NOT_ON_TIMER,   /* 29 - PA5 */
+	NOT_ON_TIMER,   /* 30 - PA6 */
+	NOT_ON_TIMER   /* 31 - PA7 */
+};
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h
new file mode 100644
index 0000000..fd7ee5c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/pins_arduino.h
@@ -0,0 +1,65 @@
+/*
+  pins_arduino.h - Pin definition functions for Arduino
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2007 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
+*/
+
+#ifndef Pins_Arduino_h
+#define Pins_Arduino_h
+
+#include <avr/pgmspace.h>
+
+#define NOT_A_PIN 0
+#define NOT_A_PORT 0
+
+#define NOT_ON_TIMER 0
+#define TIMER0A 1
+#define TIMER0B 2
+#define TIMER1A 3
+#define TIMER1B 4
+#define TIMER2  5
+#define TIMER2A 6
+#define TIMER2B 7
+
+extern const uint8_t PROGMEM port_to_mode_PGM[];
+extern const uint8_t PROGMEM port_to_input_PGM[];
+extern const uint8_t PROGMEM port_to_output_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
+extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
+
+extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
+
+// Get the bit location within the hardware port of the given virtual pin.
+// This comes from the pins_*.c file for the active board configuration.
+// 
+// These perform slightly better as macros compared to inline functions
+//
+#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
+#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
+#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
+#define analogInPinToBit(P) (P)
+#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
+#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
+#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c
new file mode 100644
index 0000000..b90d07e
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.c
@@ -0,0 +1,289 @@
+/*
+  wiring.c - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#include "wiring_private.h"
+
+// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
+// the overflow handler is called every 256 ticks.
+#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
+
+// the whole number of milliseconds per timer0 overflow
+#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
+
+// the fractional number of milliseconds per timer0 overflow. we shift right
+// by three to fit these numbers into a byte. (for the clock speeds we care
+// about - 8 and 16 MHz - this doesn't lose precision.)
+#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
+#define FRACT_MAX (1000 >> 3)
+
+volatile unsigned long timer0_overflow_count = 0;
+volatile unsigned long timer0_millis = 0;
+static unsigned char timer0_fract = 0;
+
+SIGNAL(TIMER0_OVF_vect)
+{
+	// copy these to local variables so they can be stored in registers
+	// (volatile variables must be read from memory on every access)
+	unsigned long m = timer0_millis;
+	unsigned char f = timer0_fract;
+
+	m += MILLIS_INC;
+	f += FRACT_INC;
+	if (f >= FRACT_MAX) {
+		f -= FRACT_MAX;
+		m += 1;
+	}
+
+	timer0_fract = f;
+	timer0_millis = m;
+	timer0_overflow_count++;
+}
+
+unsigned long millis()
+{
+	unsigned long m;
+	uint8_t oldSREG = SREG;
+
+	// disable interrupts while we read timer0_millis or we might get an
+	// inconsistent value (e.g. in the middle of a write to timer0_millis)
+	cli();
+	m = timer0_millis;
+	SREG = oldSREG;
+
+	return m;
+}
+
+unsigned long micros() {
+	unsigned long m;
+	uint8_t oldSREG = SREG, t;
+	
+	cli();
+	m = timer0_overflow_count;
+#if defined(TCNT0)
+	t = TCNT0;
+#elif defined(TCNT0L)
+	t = TCNT0L;
+#else
+	#error TIMER 0 not defined
+#endif
+
+  
+#ifdef TIFR0
+	if ((TIFR0 & _BV(TOV0)) && (t < 255))
+		m++;
+#else
+	if ((TIFR & _BV(TOV0)) && (t < 255))
+		m++;
+#endif
+
+	SREG = oldSREG;
+	
+	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
+}
+
+void delay(unsigned long ms)
+{
+	uint16_t start = (uint16_t)micros();
+
+	while (ms > 0) {
+		if (((uint16_t)micros() - start) >= 1000) {
+			ms--;
+			start += 1000;
+		}
+	}
+}
+
+/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
+void delayMicroseconds(unsigned int us)
+{
+	// calling avrlib's delay_us() function with low values (e.g. 1 or
+	// 2 microseconds) gives delays longer than desired.
+	//delay_us(us);
+
+#if F_CPU >= 16000000L
+	// for the 16 MHz clock on most Arduino boards
+
+	// for a one-microsecond delay, simply return.  the overhead
+	// of the function call yields a delay of approximately 1 1/8 us.
+	if (--us == 0)
+		return;
+
+	// the following loop takes a quarter of a microsecond (4 cycles)
+	// per iteration, so execute it four times for each microsecond of
+	// delay requested.
+	us <<= 2;
+
+	// account for the time taken in the preceeding commands.
+	us -= 2;
+#else
+	// for the 8 MHz internal clock on the ATmega168
+
+	// for a one- or two-microsecond delay, simply return.  the overhead of
+	// the function calls takes more than two microseconds.  can't just
+	// subtract two, since us is unsigned; we'd overflow.
+	if (--us == 0)
+		return;
+	if (--us == 0)
+		return;
+
+	// the following loop takes half of a microsecond (4 cycles)
+	// per iteration, so execute it twice for each microsecond of
+	// delay requested.
+	us <<= 1;
+    
+	// partially compensate for the time taken by the preceeding commands.
+	// we can't subtract any more than this or we'd overflow w/ small delays.
+	us--;
+#endif
+
+	// busy wait
+	__asm__ __volatile__ (
+		"1: sbiw %0,1" "\n\t" // 2 cycles
+		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
+	);
+}
+
+void init()
+{
+	// this needs to be called before setup() or some functions won't
+	// work there
+	sei();
+	
+	// on the ATmega168, timer 0 is also used for fast hardware pwm
+	// (using phase-correct PWM would mean that timer 0 overflowed half as often
+	// resulting in different millis() behavior on the ATmega8 and ATmega168)
+#if defined(TCCR0A) && defined(WGM01)
+	sbi(TCCR0A, WGM01);
+	sbi(TCCR0A, WGM00);
+#endif  
+
+	// set timer 0 prescale factor to 64
+#if defined(__AVR_ATmega128__)
+	// CPU specific: different values for the ATmega128
+	sbi(TCCR0, CS02);
+#elif defined(TCCR0) && defined(CS01) && defined(CS00)
+	// this combination is for the standard atmega8
+	sbi(TCCR0, CS01);
+	sbi(TCCR0, CS00);
+#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
+	// this combination is for the standard 168/328/1280/2560
+	sbi(TCCR0B, CS01);
+	sbi(TCCR0B, CS00);
+#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
+	// this combination is for the __AVR_ATmega645__ series
+	sbi(TCCR0A, CS01);
+	sbi(TCCR0A, CS00);
+#else
+	#error Timer 0 prescale factor 64 not set correctly
+#endif
+
+	// enable timer 0 overflow interrupt
+#if defined(TIMSK) && defined(TOIE0)
+	sbi(TIMSK, TOIE0);
+#elif defined(TIMSK0) && defined(TOIE0)
+	sbi(TIMSK0, TOIE0);
+#else
+	#error	Timer 0 overflow interrupt not set correctly
+#endif
+
+	// timers 1 and 2 are used for phase-correct hardware pwm
+	// this is better for motors as it ensures an even waveform
+	// note, however, that fast pwm mode can achieve a frequency of up
+	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
+
+	TCCR1B = 0;
+
+	// set timer 1 prescale factor to 64
+#if defined(TCCR1B) && defined(CS11) && defined(CS10)
+	sbi(TCCR1B, CS11);
+	sbi(TCCR1B, CS10);
+#elif defined(TCCR1) && defined(CS11) && defined(CS10)
+	sbi(TCCR1, CS11);
+	sbi(TCCR1, CS10);
+#endif
+	// put timer 1 in 8-bit phase correct pwm mode
+#if defined(TCCR1A) && defined(WGM10)
+	sbi(TCCR1A, WGM10);
+#elif defined(TCCR1)
+	#warning this needs to be finished
+#endif
+
+	// set timer 2 prescale factor to 64
+#if defined(TCCR2) && defined(CS22)
+	sbi(TCCR2, CS22);
+#elif defined(TCCR2B) && defined(CS22)
+	sbi(TCCR2B, CS22);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+	// configure timer 2 for phase correct pwm (8-bit)
+#if defined(TCCR2) && defined(WGM20)
+	sbi(TCCR2, WGM20);
+#elif defined(TCCR2A) && defined(WGM20)
+	sbi(TCCR2A, WGM20);
+#else
+	#warning Timer 2 not finished (may not be present on this CPU)
+#endif
+
+#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
+	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
+	sbi(TCCR3B, CS30);
+	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
+#endif
+	
+#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
+	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
+	sbi(TCCR4B, CS40);
+	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
+	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
+	sbi(TCCR5B, CS50);
+	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
+#endif
+
+#if defined(ADCSRA)
+	// set a2d prescale factor to 128
+	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
+	// XXX: this will not work properly for other clock speeds, and
+	// this code should use F_CPU to determine the prescale factor.
+	sbi(ADCSRA, ADPS2);
+	sbi(ADCSRA, ADPS1);
+	sbi(ADCSRA, ADPS0);
+
+	// enable a2d conversions
+	sbi(ADCSRA, ADEN);
+#endif
+
+	// the bootloader connects pins 0 and 1 to the USART; disconnect them
+	// here so they can be used as normal digital i/o; they will be
+	// reconnected in Serial.begin()
+#if defined(UCSRB)
+	UCSRB = 0;
+#elif defined(UCSR0B)
+	UCSR0B = 0;
+#endif
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h
new file mode 100644
index 0000000..0a93678
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring.h
@@ -0,0 +1,136 @@
+/*
+  wiring.h - Partial implementation of the Wiring API for the ATmega8.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id$
+*/
+
+#ifndef Wiring_h
+#define Wiring_h
+
+#include <math.h>
+#include <avr/io.h>
+#include <stdlib.h>
+#include "binary.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#define HIGH 0x1
+#define LOW  0x0
+
+#define INPUT 0x0
+#define OUTPUT 0x1
+
+#define true 0x1
+#define false 0x0
+
+#define PI 3.1415926535897932384626433832795
+#define HALF_PI 1.5707963267948966192313216916398
+#define TWO_PI 6.283185307179586476925286766559
+#define DEG_TO_RAD 0.017453292519943295769236907684886
+#define RAD_TO_DEG 57.295779513082320876798154814105
+
+#define SERIAL  0x0
+#define DISPLAY 0x1
+
+#define LSBFIRST 0
+#define MSBFIRST 1
+
+#define CHANGE 1
+#define FALLING 2
+#define RISING 3
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define INTERNAL1V1 2
+#define INTERNAL2V56 3
+#else
+#define INTERNAL 3
+#endif
+#define DEFAULT 1
+#define EXTERNAL 0
+
+// undefine stdlib's abs if encountered
+#ifdef abs
+#undef abs
+#endif
+
+#define min(a,b) ((a)<(b)?(a):(b))
+#define max(a,b) ((a)>(b)?(a):(b))
+#define abs(x) ((x)>0?(x):-(x))
+#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
+#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
+#define radians(deg) ((deg)*DEG_TO_RAD)
+#define degrees(rad) ((rad)*RAD_TO_DEG)
+#define sq(x) ((x)*(x))
+
+#define interrupts() sei()
+#define noInterrupts() cli()
+
+#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
+#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
+#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
+
+#define lowByte(w) ((uint8_t) ((w) & 0xff))
+#define highByte(w) ((uint8_t) ((w) >> 8))
+
+#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
+#define bitSet(value, bit) ((value) |= (1UL << (bit)))
+#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
+#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
+
+
+typedef unsigned int word;
+
+#define bit(b) (1UL << (b))
+
+typedef uint8_t boolean;
+typedef uint8_t byte;
+
+void init(void);
+
+void pinMode(uint8_t, uint8_t);
+void digitalWrite(uint8_t, uint8_t);
+int digitalRead(uint8_t);
+int analogRead(uint8_t);
+void analogReference(uint8_t mode);
+void analogWrite(uint8_t, int);
+
+unsigned long millis(void);
+unsigned long micros(void);
+void delay(unsigned long);
+void delayMicroseconds(unsigned int us);
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
+
+void attachInterrupt(uint8_t, void (*)(void), int mode);
+void detachInterrupt(uint8_t);
+
+void setup(void);
+void loop(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c
new file mode 100644
index 0000000..d248f4c
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_analog.c
@@ -0,0 +1,259 @@
+/*
+  wiring_analog.c - analog input and output
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+uint8_t analog_reference = DEFAULT;
+
+void analogReference(uint8_t mode)
+{
+	// can't actually set the register here because the default setting
+	// will connect AVCC and the AREF pin, which would cause a short if
+	// there's something connected to AREF.
+	analog_reference = mode;
+}
+
+int analogRead(uint8_t pin)
+{
+	uint8_t low, high;
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
+#else
+	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
+#endif
+
+#if defined(ADCSRB) && defined(MUX5)
+	// the MUX5 bit of ADCSRB selects whether we're reading from channels
+	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
+	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
+#endif
+  
+	// set the analog reference (high two bits of ADMUX) and select the
+	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
+	// to 0 (the default).
+#if defined(ADMUX)
+	ADMUX = (analog_reference << 6) | (pin & 0x07);
+#endif
+
+	// without a delay, we seem to read from the wrong channel
+	//delay(1);
+
+#if defined(ADCSRA) && defined(ADCL)
+	// start the conversion
+	sbi(ADCSRA, ADSC);
+
+	// ADSC is cleared when the conversion finishes
+	while (bit_is_set(ADCSRA, ADSC));
+
+	// we have to read ADCL first; doing so locks both ADCL
+	// and ADCH until ADCH is read.  reading ADCL second would
+	// cause the results of each conversion to be discarded,
+	// as ADCL and ADCH would be locked when it completed.
+	low  = ADCL;
+	high = ADCH;
+#else
+	// we dont have an ADC, return 0
+	low  = 0;
+	high = 0;
+#endif
+
+	// combine the two bytes
+	return (high << 8) | low;
+}
+
+// Right now, PWM output only works on the pins with
+// hardware support.  These are defined in the appropriate
+// pins_*.c file.  For the rest of the pins, we default
+// to digital output.
+void analogWrite(uint8_t pin, int val)
+{
+	// We need to make sure the PWM output is enabled for those pins
+	// that support it, as we turn it off when digitally reading or
+	// writing with them.  Also, make sure the pin is in output mode
+	// for consistenty with Wiring, which doesn't require a pinMode
+	// call for the analog output pins.
+	pinMode(pin, OUTPUT);
+	if (val == 0)
+	{
+		digitalWrite(pin, LOW);
+	}
+	else if (val == 255)
+	{
+		digitalWrite(pin, HIGH);
+	}
+	else
+	{
+		switch(digitalPinToTimer(pin))
+		{
+			// XXX fix needed for atmega8
+			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
+			case TIMER0A:
+				// connect pwm to pin on timer 0
+				sbi(TCCR0, COM00);
+				OCR0 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0A1)
+			case TIMER0A:
+				// connect pwm to pin on timer 0, channel A
+				sbi(TCCR0A, COM0A1);
+				OCR0A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR0A) && defined(COM0B1)
+			case TIMER0B:
+				// connect pwm to pin on timer 0, channel B
+				sbi(TCCR0A, COM0B1);
+				OCR0B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1A1)
+			case TIMER1A:
+				// connect pwm to pin on timer 1, channel A
+				sbi(TCCR1A, COM1A1);
+				OCR1A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR1A) && defined(COM1B1)
+			case TIMER1B:
+				// connect pwm to pin on timer 1, channel B
+				sbi(TCCR1A, COM1B1);
+				OCR1B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2) && defined(COM21)
+			case TIMER2:
+				// connect pwm to pin on timer 2
+				sbi(TCCR2, COM21);
+				OCR2 = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2A1)
+			case TIMER2A:
+				// connect pwm to pin on timer 2, channel A
+				sbi(TCCR2A, COM2A1);
+				OCR2A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR2A) && defined(COM2B1)
+			case TIMER2B:
+				// connect pwm to pin on timer 2, channel B
+				sbi(TCCR2A, COM2B1);
+				OCR2B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3A1)
+			case TIMER3A:
+				// connect pwm to pin on timer 3, channel A
+				sbi(TCCR3A, COM3A1);
+				OCR3A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3B1)
+			case TIMER3B:
+				// connect pwm to pin on timer 3, channel B
+				sbi(TCCR3A, COM3B1);
+				OCR3B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR3A) && defined(COM3C1)
+			case TIMER3C:
+				// connect pwm to pin on timer 3, channel C
+				sbi(TCCR3A, COM3C1);
+				OCR3C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4A1)
+			case TIMER4A:
+				// connect pwm to pin on timer 4, channel A
+				sbi(TCCR4A, COM4A1);
+				OCR4A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4B1)
+			case TIMER4B:
+				// connect pwm to pin on timer 4, channel B
+				sbi(TCCR4A, COM4B1);
+				OCR4B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR4A) && defined(COM4C1)
+			case TIMER4C:
+				// connect pwm to pin on timer 4, channel C
+				sbi(TCCR4A, COM4C1);
+				OCR4C = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5A1)
+			case TIMER5A:
+				// connect pwm to pin on timer 5, channel A
+				sbi(TCCR5A, COM5A1);
+				OCR5A = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5B1)
+			case TIMER5B:
+				// connect pwm to pin on timer 5, channel B
+				sbi(TCCR5A, COM5B1);
+				OCR5B = val; // set pwm duty
+				break;
+			#endif
+
+			#if defined(TCCR5A) && defined(COM5C1)
+			case TIMER5C:
+				// connect pwm to pin on timer 5, channel C
+				sbi(TCCR5A, COM5C1);
+				OCR5C = val; // set pwm duty
+				break;
+			#endif
+
+			case NOT_ON_TIMER:
+			default:
+				if (val < 128) {
+					digitalWrite(pin, LOW);
+				} else {
+					digitalWrite(pin, HIGH);
+				}
+		}
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c
new file mode 100644
index 0000000..0949da4
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_digital.c
@@ -0,0 +1,166 @@
+/*
+  wiring_digital.c - digital input and output functions
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  Modified 28 September 2010 by Mark Sproul
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+void pinMode(uint8_t pin, uint8_t mode)
+{
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *reg;
+
+	if (port == NOT_A_PIN) return;
+
+	// JWS: can I let the optimizer do this?
+	reg = portModeRegister(port);
+
+	if (mode == INPUT) { 
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*reg |= bit;
+		SREG = oldSREG;
+	}
+}
+
+// Forcing this inline keeps the callers from having to push their own stuff
+// on the stack. It is a good performance win and only takes 1 more byte per
+// user than calling. (It will take more bytes on the 168.)
+//
+// But shouldn't this be moved into pinMode? Seems silly to check and do on
+// each digitalread or write.
+//
+// Mark Sproul:
+// - Removed inline. Save 170 bytes on atmega1280
+// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
+// - Added more #ifdefs, now compiles for atmega645
+//
+//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
+//static inline void turnOffPWM(uint8_t timer)
+static void turnOffPWM(uint8_t timer)
+{
+	switch (timer)
+	{
+		#if defined(TCCR1A) && defined(COM1A1)
+		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
+		#endif
+		#if defined(TCCR1A) && defined(COM1B1)
+		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
+		#endif
+		
+		#if defined(TCCR2) && defined(COM21)
+		case  TIMER2:   cbi(TCCR2, COM21);      break;
+		#endif
+		
+		#if defined(TCCR0A) && defined(COM0A1)
+		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
+		#endif
+		
+		#if defined(TIMER0B) && defined(COM0B1)
+		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2A1)
+		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
+		#endif
+		#if defined(TCCR2A) && defined(COM2B1)
+		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
+		#endif
+		
+		#if defined(TCCR3A) && defined(COM3A1)
+		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3B1)
+		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
+		#endif
+		#if defined(TCCR3A) && defined(COM3C1)
+		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
+		#endif
+
+		#if defined(TCCR4A) && defined(COM4A1)
+		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4B1)
+		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
+		#endif
+		#if defined(TCCR4A) && defined(COM4C1)
+		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
+		#endif
+		#if defined(TCCR5A)
+		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
+		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
+		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
+		#endif
+	}
+}
+
+void digitalWrite(uint8_t pin, uint8_t val)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	volatile uint8_t *out;
+
+	if (port == NOT_A_PIN) return;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before doing a digital write.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	out = portOutputRegister(port);
+
+	if (val == LOW) {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out &= ~bit;
+		SREG = oldSREG;
+	} else {
+		uint8_t oldSREG = SREG;
+                cli();
+		*out |= bit;
+		SREG = oldSREG;
+	}
+}
+
+int digitalRead(uint8_t pin)
+{
+	uint8_t timer = digitalPinToTimer(pin);
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+
+	if (port == NOT_A_PIN) return LOW;
+
+	// If the pin that support PWM output, we need to turn it off
+	// before getting a digital reading.
+	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
+
+	if (*portInputRegister(port) & bit) return HIGH;
+	return LOW;
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h
new file mode 100644
index 0000000..7449c76
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_private.h
@@ -0,0 +1,68 @@
+/*
+  wiring_private.h - Internal header file.
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
+*/
+
+#ifndef WiringPrivate_h
+#define WiringPrivate_h
+#include <math.h>
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include <util/delay.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "wiring.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif
+
+#ifndef cbi
+#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
+#endif
+#ifndef sbi
+#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
+#endif
+
+#define EXTERNAL_INT_0 0
+#define EXTERNAL_INT_1 1
+#define EXTERNAL_INT_2 2
+#define EXTERNAL_INT_3 3
+#define EXTERNAL_INT_4 4
+#define EXTERNAL_INT_5 5
+#define EXTERNAL_INT_6 6
+#define EXTERNAL_INT_7 7
+
+#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+#define EXTERNAL_NUM_INTERRUPTS 8
+#else
+#define EXTERNAL_NUM_INTERRUPTS 2
+#endif
+
+typedef void (*voidFuncPtr)(void);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif
+
+#endif
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c
new file mode 100644
index 0000000..0d96886
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_pulse.c
@@ -0,0 +1,69 @@
+/*
+  wiring_pulse.c - pulseIn() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+#include "pins_arduino.h"
+
+/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
+ * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
+ * to 3 minutes in length, but must be called at least a few dozen microseconds
+ * before the start of the pulse. */
+unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
+{
+	// cache the port and bit of the pin in order to speed up the
+	// pulse width measuring loop and achieve finer resolution.  calling
+	// digitalRead() instead yields much coarser resolution.
+	uint8_t bit = digitalPinToBitMask(pin);
+	uint8_t port = digitalPinToPort(pin);
+	uint8_t stateMask = (state ? bit : 0);
+	unsigned long width = 0; // keep initialization out of time critical area
+	
+	// convert the timeout from microseconds to a number of times through
+	// the initial loop; it takes 16 clock cycles per iteration.
+	unsigned long numloops = 0;
+	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
+	
+	// wait for any previous pulse to end
+	while ((*portInputRegister(port) & bit) == stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to start
+	while ((*portInputRegister(port) & bit) != stateMask)
+		if (numloops++ == maxloops)
+			return 0;
+	
+	// wait for the pulse to stop
+	while ((*portInputRegister(port) & bit) == stateMask) {
+		if (numloops++ == maxloops)
+			return 0;
+		width++;
+	}
+
+	// convert the reading to microseconds. The loop has been determined
+	// to be 20 clock cycles long and have about 16 clocks between the edge
+	// and the start of the loop. There will be some error introduced by
+	// the interrupt handlers.
+	return clockCyclesToMicroseconds(width * 21 + 16); 
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c
new file mode 100644
index 0000000..cfe7867
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/cores/arduino/wiring_shift.c
@@ -0,0 +1,55 @@
+/*
+  wiring_shift.c - shiftOut() function
+  Part of Arduino - http://www.arduino.cc/
+
+  Copyright (c) 2005-2006 David A. Mellis
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General
+  Public License along with this library; if not, write to the
+  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+  Boston, MA  02111-1307  USA
+
+  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
+*/
+
+#include "wiring_private.h"
+
+uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
+	uint8_t value = 0;
+	uint8_t i;
+
+	for (i = 0; i < 8; ++i) {
+		digitalWrite(clockPin, HIGH);
+		if (bitOrder == LSBFIRST)
+			value |= digitalRead(dataPin) << i;
+		else
+			value |= digitalRead(dataPin) << (7 - i);
+		digitalWrite(clockPin, LOW);
+	}
+	return value;
+}
+
+void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < 8; i++)  {
+		if (bitOrder == LSBFIRST)
+			digitalWrite(dataPin, !!(val & (1 << i)));
+		else	
+			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
+			
+		digitalWrite(clockPin, HIGH);
+		digitalWrite(clockPin, LOW);		
+	}
+}
diff --git a/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt b/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt
new file mode 100644
index 0000000..466f602
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/Sanguino/programmers.txt
@@ -0,0 +1,20 @@
+avrisp.name=AVR ISP
+avrisp.communication=serial
+avrisp.protocol=stk500v1
+
+avrispmkii.name=AVRISP mkII
+avrispmkii.communication=usb
+avrispmkii.protocol=stk500v2
+
+usbtinyisp.name=USBtinyISP
+usbtinyisp.protocol=usbtiny
+
+parallel.name=Parallel Programmer
+parallel.protocol=dapa
+parallel.force=true
+# parallel.delay=200
+
+arduinoisp.name=Arduino as ISP
+arduinoisp.communication=serial
+arduinoisp.protocol=stk500v1
+arduinoisp.speed=19200
diff --git a/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf b/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf
new file mode 100644
index 0000000..ec921df
--- /dev/null
+++ b/ArduinoAddons/Arduino_0.xx/hardware/tools/avr/etc/avrdude.conf
@@ -0,0 +1,12104 @@
+# $Id: avrdude.conf.in,v 1.122 2007/05/16 21:29:36 joerg_wunsch Exp $
+#
+# AVRDUDE Configuration File
+#
+# This file contains configuration data used by AVRDUDE which describes
+# the programming hardware pinouts and also provides part definitions.
+# AVRDUDE's "-C" command line option specifies the location of the
+# configuration file.  The "-c" option names the programmer configuration
+# which must match one of the entry's "id" parameter.  The "-p" option
+# identifies which part AVRDUDE is going to be programming and must match
+# one of the parts' "id" parameter.
+#
+# Possible entry formats are:
+#
+#   programmer
+#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
+#       desc     = <description> ;                  # quoted string
+#       type     = par | stk500 | stk500v2 | stk500pp | stk500hvsp | stk500generic |
+#                  avr910 | butterfly | usbasp |
+#                  jtagmki | jtagmkii | jtagmkii_isp | jtagmkii_dw |
+#                  dragon_dw | dragon_jtag | dragon_isp | dragon_pp |
+#                  dragon_hvsp; # programmer type
+#       baudrate = <num> ;                          # baudrate for avr910-programmer
+#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
+#       reset    = <num> ;                          # pin number
+#       sck      = <num> ;                          # pin number
+#       mosi     = <num> ;                          # pin number
+#       miso     = <num> ;                          # pin number
+#       errled   = <num> ;                          # pin number
+#       rdyled   = <num> ;                          # pin number
+#       pgmled   = <num> ;                          # pin number
+#       vfyled   = <num> ;                          # pin number
+#     ;
+#
+#   part
+#       id               = <id> ;                 # quoted string
+#       desc             = <description> ;        # quoted string
+#       has_jtag         = <yes/no> ;             # part has JTAG i/f
+#       has_debugwire    = <yes/no> ;             # part has debugWire i/f
+#       devicecode       = <num> ;            # deprecated, use stk500_devcode
+#       stk500_devcode   = <num> ;                # numeric
+#       avr910_devcode   = <num> ;                # numeric
+#       signature        = <num> <num> <num> ;    # signature bytes
+#       chip_erase_delay = <num> ;                # micro-seconds
+#       reset            = dedicated | io;
+#       retry_pulse      = reset | sck;
+#       pgm_enable       = <instruction format> ;
+#       chip_erase       = <instruction format> ;
+#       chip_erase_delay = <num> ;                # chip erase delay (us)
+#       # STK500 parameters (parallel programming IO lines)
+#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
+#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
+#       serial           = <yes/no> ;             # can use serial downloading
+#       parallel         = <yes/no/pseudo>;       # can use par. programming
+#       # STK500v2 parameters, to be taken from Atmel's XML files
+#       timeout          = <num> ;
+#       stabdelay        = <num> ;
+#       cmdexedelay      = <num> ;
+#       synchloops       = <num> ;
+#       bytedelay        = <num> ;
+#       pollvalue        = <num> ;
+#       pollindex        = <num> ;
+#       predelay         = <num> ;
+#       postdelay        = <num> ;
+#       pollmethod       = <num> ;
+#       mode             = <num> ;
+#       delay            = <num> ;
+#       blocksize        = <num> ;
+#       readsize         = <num> ;
+#       hvspcmdexedelay  = <num> ;
+#       # STK500v2 HV programming parameters, from XML
+#       pp_controlstack  = <num>, <num>, ...;   # PP only
+#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
+#       hventerstabdelay = <num>;
+#       progmodedelay    = <num>;               # PP only
+#       latchcycles      = <num>;
+#       togglevtg        = <num>;
+#       poweroffdelay    = <num>;
+#       resetdelayms     = <num>;
+#       resetdelayus     = <num>;
+#       hvleavestabdelay = <num>;
+#       resetdelay       = <num>;
+#       synchcycles      = <num>;               # HVSP only
+#       chiperasepulsewidth = <num>;            # PP only
+#       chiperasepolltimeout = <num>;
+#       chiperasetime    = <num>;               # HVSP only
+#       programfusepulsewidth = <num>;          # PP only
+#       programfusepolltimeout = <num>;
+#       programlockpulsewidth = <num>;          # PP only
+#       programlockpolltimeout = <num>;
+#       # JTAG ICE mkII parameters, also from XML files
+#       allowfullpagebitstream = <yes/no> ;
+#       enablepageprogramming = <yes/no> ;
+#       idr              = <num> ;                # IO addr of IDR (OCD) reg.
+#       rampz            = <num> ;                # IO addr of RAMPZ reg.
+#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
+#       eecr             = <num> ;                # mem addr of EECR reg.
+#                                                 # (only when != 0x3c)
+#
+#       memory <memtype>
+#           paged           = <yes/no> ;          # yes / no
+#           size            = <num> ;             # bytes
+#           page_size       = <num> ;             # bytes
+#           num_pages       = <num> ;             # numeric
+#           min_write_delay = <num> ;             # micro-seconds
+#           max_write_delay = <num> ;             # micro-seconds
+#           readback_p1     = <num> ;             # byte value
+#           readback_p2     = <num> ;             # byte value
+#           pwroff_after_write = <yes/no> ;       # yes / no
+#           read            = <instruction format> ;
+#           write           = <instruction format> ;
+#           read_lo         = <instruction format> ;
+#           read_hi         = <instruction format> ;
+#           write_lo        = <instruction format> ;
+#           write_hi        = <instruction format> ;
+#           loadpage_lo     = <instruction format> ;
+#           loadpage_hi     = <instruction format> ;
+#           writepage       = <instruction format> ;
+#         ;
+#     ;
+#
+# If any of the above parameters are not specified, the default value
+# of 0 is used for numerics or the empty string ("") for string
+# values.  If a required parameter is left empty, AVRDUDE will
+# complain.
+#
+# NOTES:
+#   * 'devicecode' is the device code used by the STK500 (see codes 
+#       listed below)
+#   * Not all memory types will implement all instructions.
+#   * AVR Fuse bits and Lock bits are implemented as a type of memory.
+#   * Example memory types are:
+#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
+#       fuse), "signature", "calibration", "lock"
+#   * The memory type specified on the avrdude command line must match
+#     one of the memory types defined for the specified chip.
+#   * The pwroff_after_write flag causes avrdude to attempt to
+#     power the device off and back on after an unsuccessful write to
+#     the affected memory area if VCC programmer pins are defined.  If
+#     VCC pins are not defined for the programmer, a message
+#     indicating that the device needs a power-cycle is printed out.
+#     This flag was added to work around a problem with the
+#     at90s4433/2333's; see the at90s4433 errata at:
+#
+#         http://www.atmel.com/atmel/acrobat/doc1280.pdf
+#
+# INSTRUCTION FORMATS
+#
+#    Instruction formats are specified as a comma seperated list of
+#    string values containing information (bit specifiers) about each
+#    of the 32 bits of the instruction.  Bit specifiers may be one of
+#    the following formats:
+#
+#       '1'  = the bit is always set on input as well as output
+#
+#       '0'  = the bit is always clear on input as well as output
+#
+#       'x'  = the bit is ignored on input and output
+#
+#       'a'  = the bit is an address bit, the bit-number matches this bit
+#              specifier's position within the current instruction byte
+#
+#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
+#              is address bit 12 on input, a0 is address bit 0.
+#
+#       'i'  = the bit is an input data bit
+#
+#       'o'  = the bit is an output data bit
+#
+#    Each instruction must be composed of 32 bit specifiers.  The
+#    instruction specification closely follows the instruction data
+#    provided in Atmel's data sheets for their parts.
+#
+# See below for some examples.
+#
+#
+# The following are STK500 part device codes to use for the
+# "devicecode" field of the part.  These came from Atmel's software
+# section avr061.zip which accompanies the application note
+# AVR061 available from:
+#
+#      http://www.atmel.com/atmel/acrobat/doc2525.pdf
+#
+
+#define ATTINY10    0x10
+#define ATTINY11    0x11
+#define ATTINY12    0x12
+#define ATTINY15    0x13
+#define ATTINY13    0x14
+
+#define ATTINY22    0x20
+#define ATTINY26    0x21
+#define ATTINY28    0x22
+#define ATTINY2313  0x23
+
+#define AT90S1200   0x33
+
+#define AT90S2313   0x40
+#define AT90S2323   0x41
+#define AT90S2333   0x42
+#define AT90S2343   0x43
+
+#define AT90S4414   0x50
+#define AT90S4433   0x51
+#define AT90S4434   0x52
+#define ATMEGA48    0x59
+
+#define AT90S8515   0x60
+#define AT90S8535   0x61
+#define AT90C8534   0x62
+#define ATMEGA8515  0x63
+#define ATMEGA8535  0x64
+
+#define ATMEGA8     0x70
+#define ATMEGA88    0x73
+#define ATMEGA168   0x86
+
+#define ATMEGA161   0x80
+#define ATMEGA163   0x81
+#define ATMEGA16    0x82
+#define ATMEGA162   0x83
+#define ATMEGA169   0x84
+
+#define ATMEGA323   0x90
+#define ATMEGA32    0x91
+
+#define ATMEGA64    0xA0
+
+#define ATMEGA103   0xB1
+#define ATMEGA128   0xB2
+#define AT90CAN128  0xB3
+
+#define AT86RF401   0xD0
+
+#define AT89START   0xE0
+#define AT89S51	    0xE0
+#define AT89S52	    0xE1
+
+# The following table lists the devices in the original AVR910
+# appnote:
+# |Device |Signature | Code |
+# +-------+----------+------+
+# |tiny12 | 1E 90 05 | 0x55 |
+# |tiny15 | 1E 90 06 | 0x56 |
+# |       |          |      |
+# | S1200 | 1E 90 01 | 0x13 |
+# |       |          |      |
+# | S2313 | 1E 91 01 | 0x20 |
+# | S2323 | 1E 91 02 | 0x48 |
+# | S2333 | 1E 91 05 | 0x34 |
+# | S2343 | 1E 91 03 | 0x4C |
+# |       |          |      |
+# | S4414 | 1E 92 01 | 0x28 |
+# | S4433 | 1E 92 03 | 0x30 |
+# | S4434 | 1E 92 02 | 0x6C |
+# |       |          |      |
+# | S8515 | 1E 93 01 | 0x38 |
+# | S8535 | 1E 93 03 | 0x68 |
+# |       |          |      |
+# |mega32 | 1E 95 01 | 0x72 |
+# |mega83 | 1E 93 05 | 0x65 |
+# |mega103| 1E 97 01 | 0x41 |
+# |mega161| 1E 94 01 | 0x60 |
+# |mega163| 1E 94 02 | 0x64 |
+
+# Appnote AVR109 also has a table of AVR910 device codes, which
+# lists:
+# dev         avr910   signature
+# ATmega8     0x77     0x1E 0x93 0x07
+# ATmega8515  0x3B     0x1E 0x93 0x06
+# ATmega8535  0x6A     0x1E 0x93 0x08
+# ATmega16    0x75     0x1E 0x94 0x03
+# ATmega162   0x63     0x1E 0x94 0x04
+# ATmega163   0x66     0x1E 0x94 0x02
+# ATmega169   0x79     0x1E 0x94 0x05
+# ATmega32    0x7F     0x1E 0x95 0x02
+# ATmega323   0x73     0x1E 0x95 0x01
+# ATmega64    0x46     0x1E 0x96 0x02
+# ATmega128   0x44     0x1E 0x97 0x02
+#
+# These codes refer to "BOOT" device codes which are apparently
+# different than standard device codes, for whatever reasons
+# (often one above the standard code).
+
+# There are several extended versions of AVR910 implementations around
+# in the Internet.  These add the following codes (only devices that
+# actually exist are listed):
+
+# ATmega8515	0x3A
+# ATmega128	0x43
+# ATmega64	0x45
+# ATtiny26	0x5E
+# ATmega8535	0x69
+# ATmega32	0x72
+# ATmega16	0x74
+# ATmega8	0x76
+# ATmega169	0x78
+
+#
+# Overall avrdude defaults
+#
+default_parallel   = "lpt1";
+default_serial     = "com1";
+
+
+#
+# PROGRAMMER DEFINITIONS
+#
+
+programmer
+  id    = "avrisp";
+  desc  = "Atmel AVR ISP";
+  type  = stk500;
+;
+
+programmer
+  id    = "avrispv2";
+  desc  = "Atmel AVR ISP V2";
+  type  =  stk500v2;
+;
+
+programmer
+  id    = "avrispmkII";
+  desc  = "Atmel AVR ISP mkII";
+  type  =  stk500v2;
+;
+
+programmer
+  id    = "avrisp2";
+  desc  = "Atmel AVR ISP mkII";
+  type  =  stk500v2;
+;
+
+# This is supposed to be the "default" STK500 entry.
+# Attempts to select the correct firmware version
+# by probing for it.  Better use one of the entries
+# below instead.
+programmer
+  id    = "stk500";
+  desc  = "Atmel STK500";
+  type  = stk500generic;
+;
+
+programmer
+  id    = "stk500v1";
+  desc  = "Atmel STK500 Version 1.x firmware";
+  type  = stk500;
+;
+
+programmer
+  id    = "stk500v2";
+  desc  = "Atmel STK500 Version 2.x firmware";
+  type  = stk500v2;
+;
+
+programmer
+  id    = "stk500pp";
+  desc  = "Atmel STK500 V2 in parallel programming mode";
+  type  = stk500pp;
+;
+
+programmer
+  id    = "stk500hvsp";
+  desc  = "Atmel STK500 V2 in high-voltage serial programming mode";
+  type  = stk500hvsp;
+;
+
+programmer
+  id    = "avr910";
+  desc  = "Atmel Low Cost Serial Programmer";
+  type  = avr910;
+;
+
+programmer
+  id    = "usbasp";
+  desc  = "USBasp, http://www.fischl.de/usbasp/";
+  type  = usbasp;
+;
+
+programmer
+  id    = "usbtiny";
+  desc  = "USBtiny simple USB programmer";
+  type  = usbtiny;
+;
+
+programmer
+  id    = "butterfly";
+  desc  = "Atmel Butterfly Development Board";
+  type  = butterfly;
+;
+
+programmer
+  id    = "avr109";
+  desc  = "Atmel AppNote AVR109 Boot Loader";
+  type  = butterfly;
+;
+
+programmer
+  id    = "avr911";
+  desc  = "Atmel AppNote AVR911 AVROSP";
+  type  = butterfly;
+;
+
+programmer
+  id    = "jtagmkI";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 115200;    # default is 115200
+  type  = jtagmki;
+;
+
+# easier to type
+programmer
+  id    = "jtag1";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 115200;    # default is 115200
+  type  = jtagmki;
+;
+
+# easier to type
+programmer
+  id    = "jtag1slow";
+  desc  = "Atmel JTAG ICE (mkI)";
+  baudrate = 19200;
+  type  = jtagmki;
+;
+
+programmer
+  id    = "jtagmkII";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 19200;    # default is 19200
+  type  = jtagmkii;
+;
+
+# easier to type
+programmer
+  id    = "jtag2slow";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 19200;    # default is 19200
+  type  = jtagmkii;
+;
+
+# JTAG ICE mkII @ 115200 Bd
+programmer
+  id    = "jtag2fast";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 115200;
+  type  = jtagmkii;
+;
+
+# make the fast one the default, people will love that
+programmer
+  id    = "jtag2";
+  desc  = "Atmel JTAG ICE mkII";
+  baudrate = 115200;
+  type  = jtagmkii;
+;
+
+# JTAG ICE mkII in ISP mode
+programmer
+  id    = "jtag2isp";
+  desc  = "Atmel JTAG ICE mkII in ISP mode";
+  baudrate = 115200;
+  type  = jtagmkii_isp;
+;
+
+# JTAG ICE mkII in debugWire mode
+programmer
+  id    = "jtag2dw";
+  desc  = "Atmel JTAG ICE mkII in debugWire mode";
+  baudrate = 115200;
+  type  = jtagmkii_dw;
+;
+
+# AVR Dragon in JTAG mode
+programmer
+  id    = "dragon_jtag";
+  desc  = "Atmel AVR Dragon in JTAG mode";
+  baudrate = 115200;
+  type  = dragon_jtag;
+;
+
+# AVR Dragon in ISP mode
+programmer
+  id    = "dragon_isp";
+  desc  = "Atmel AVR Dragon in ISP mode";
+  baudrate = 115200;
+  type  = dragon_isp;
+;
+
+# AVR Dragon in PP mode
+programmer
+  id    = "dragon_pp";
+  desc  = "Atmel AVR Dragon in PP mode";
+  baudrate = 115200;
+  type  = dragon_pp;
+;
+
+# AVR Dragon in HVSP mode
+programmer
+  id    = "dragon_hvsp";
+  desc  = "Atmel AVR Dragon in HVSP mode";
+  baudrate = 115200;
+  type  = dragon_hvsp;
+;
+
+# AVR Dragon in debugWire mode
+programmer
+  id    = "dragon_dw";
+  desc  = "Atmel AVR Dragon in debugWire mode";
+  baudrate = 115200;
+  type  = dragon_dw;
+;
+
+programmer
+  id    = "pavr";
+  desc  = "Jason Kyle's pAVR Serial Programmer";
+  type  = avr910;
+;
+
+# Parallel port programmers.
+
+programmer
+  id    = "bsd";
+  desc  = "Brian Dean's Programmer, http://www.bsdhome.com/avrdude/";
+  type  = par;
+  vcc   = 2, 3, 4, 5;
+  reset = 7;
+  sck   = 8;
+  mosi  = 9;
+  miso  = 10;
+;
+
+programmer
+  id    = "stk200";
+  desc  = "STK200";
+  type  = par;
+  buff  = 4, 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+;
+
+# The programming dongle used by the popular Ponyprog
+# utility.  It is almost similar to the STK200 one,
+# except that there is a LED indicating that the
+# programming is currently in progress.
+
+programmer
+  id    = "pony-stk200";
+  desc  = "Pony Prog STK200";
+  type  = par;
+  buff  = 4, 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+  pgmled = 8; 
+;
+
+programmer
+  id    = "dt006";
+  desc  = "Dontronics DT006";
+  type  = par;
+  reset = 4;
+  sck   = 5;
+  mosi  = 2;
+  miso  = 11;
+;
+
+programmer
+  id    = "bascom";
+  desc  = "Bascom SAMPLE programming cable";
+  type  = par;
+  reset = 4;
+  sck   = 5;
+  mosi  = 2;
+  miso  = 11;
+;
+
+programmer
+  id     = "alf";
+  desc   = "Nightshade ALF-PgmAVR, http://nightshade.homeip.net/";
+  type   = par;
+  vcc    = 2, 3, 4, 5;
+  buff   = 6;
+  reset  = 7;
+  sck    = 8;
+  mosi   = 9;
+  miso   = 10;
+  errled = 1;
+  rdyled = 14;
+  pgmled = 16;
+  vfyled = 17;
+;
+
+programmer
+  id    = "sp12";
+  desc  = "Steve Bolt's Programmer";
+  type  = par;
+  vcc   = 4,5,6,7,8;
+  reset = 3;
+  sck   = 2;
+  mosi  = 9;
+  miso  = 11;
+;
+
+programmer
+  id     = "picoweb";
+  desc   = "Picoweb Programming Cable, http://www.picoweb.net/";
+  type   = par;
+  reset  = 2;
+  sck    = 3;
+  mosi   = 4;
+  miso   = 13;
+;
+
+programmer
+  id    = "abcmini";
+  desc  = "ABCmini Board, aka Dick Smith HOTCHIP";
+  type  = par;
+  reset = 4;
+  sck   = 3;
+  mosi  = 2;
+  miso  = 10;
+;
+
+programmer
+  id    = "futurlec";
+  desc  = "Futurlec.com programming cable.";
+  type  = par;
+  reset = 3;
+  sck   = 2;
+  mosi  = 1;
+  miso  = 10;
+;
+
+
+# From the contributor of the "xil" jtag cable:
+# The "vcc" definition isn't really vcc (the cable gets its power from
+# the programming circuit) but is necessary to switch one of the
+# buffer lines (trying to add it to the "buff" lines doesn't work).
+# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK
+# to SCK (plus vcc/gnd of course)
+programmer
+  id    = "xil";
+  desc  = "Xilinx JTAG cable";
+  type  = par;
+  mosi  = 2;
+  sck   = 3;
+  reset = 4;
+  buff  = 5;
+  miso  = 13;
+  vcc   = 6;
+;
+
+
+programmer
+  id = "dapa";
+  desc = "Direct AVR Parallel Access cable";
+  type = par;
+  vcc   = 3;
+  reset = 16;
+  sck = 1;
+  mosi = 2;
+  miso = 11;
+;
+
+programmer
+  id    = "atisp";
+  desc  = "AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th";
+  type  = par;
+  reset = ~6;
+  sck   = ~8;
+  mosi  = ~7;
+  miso  = ~10;
+;
+
+programmer
+  id    = "ere-isp-avr";
+  desc  = "ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>";
+  type  = par;
+  reset = ~4;
+  sck   = 3;
+  mosi  = 2;
+  miso  = 10;
+;
+
+programmer
+  id    = "blaster";
+  desc  = "Altera ByteBlaster";
+  type  = par;
+  sck   = 2;
+  miso  = 11;
+  reset = 3;
+  mosi  = 8;
+  buff  = 14;
+;
+
+# It is almost same as pony-stk200, except vcc on pin 5 to auto
+# disconnect port (download on http://electropol.free.fr)
+programmer
+  id    = "frank-stk200";
+  desc  = "Frank STK200";
+  type  = par;
+  vcc   = 5;
+  sck   = 6;
+  mosi  = 7;
+  reset = 9;
+  miso  = 10;
+  pgmled = 8;
+;
+
+
+#
+# some ultra cheap programmers use bitbanging on the 
+# serialport.
+#
+# PC - DB9 - Pins for RS232:
+#
+# GND   5   -- |O
+#              |   O| <-   9   RI
+# DTR   4   <- |O   |
+#              |   O| <-   8   CTS
+# TXD   3   <- |O   |
+#              |   O| ->   7   RTS
+# RXD   2   -> |O   |
+#              |   O| <-   6   DSR
+# DCD   1   -> |O
+#
+# Using RXD is currently not supported.
+# Using RI is not supported under Win32 but is supported under Posix.
+
+# serial ponyprog design (dasa2 in uisp)
+# reset=!txd sck=rts mosi=dtr miso=cts
+
+programmer
+  id    = "ponyser";
+  desc  = "design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts";
+  type  = serbb;
+  reset = ~3;
+  sck   = 7;
+  mosi  = 4;
+  miso  = 8;
+;
+
+# Same as above, different name
+# reset=!txd sck=rts mosi=dtr miso=cts
+
+programmer
+  id    = "siprog";
+  desc  = "Lancos SI-Prog <http://www.lancos.com/siprogsch.html>";
+  type  = serbb;
+  reset = ~3;
+  sck   = 7;
+  mosi  = 4;
+  miso  = 8;
+;
+
+# unknown (dasa in uisp)
+# reset=rts sck=dtr mosi=txd miso=cts
+
+programmer
+  id    = "dasa";
+  desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
+  type  = serbb;
+  reset = 7;
+  sck   = 4;
+  mosi  = 3;
+  miso  = 8;
+;
+
+# unknown (dasa3 in uisp)
+# reset=!dtr sck=rts mosi=txd miso=cts
+
+programmer
+  id    = "dasa3";
+  desc  = "serial port banging, reset=!dtr sck=rts mosi=txd miso=cts";
+  type  = serbb;
+  reset = ~4;
+  sck   = 7;
+  mosi  = 3;
+  miso  = 8;
+;
+
+#
+# PART DEFINITIONS
+#
+
+#------------------------------------------------------------
+# ATtiny11
+#------------------------------------------------------------
+
+# This is an HVSP-only device.
+
+part
+    id                  = "t11";
+    desc                = "ATtiny11";
+    stk500_devcode      = 0x11;
+    signature           = 0x1e 0x90 0x04;
+    chip_erase_delay    = 20000;
+
+    timeout		= 200;
+    hvsp_controlstack     =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+	blocksize	= 64;
+	readsize	= 256;
+	delay		= 5;
+    ;
+
+    memory "flash"
+        size            = 1024;
+	blocksize	= 128;
+	readsize	= 256;
+	delay		= 3;
+    ;
+
+    memory "signature"
+        size            = 3;
+    ;
+
+    memory "lock"
+        size            = 1;
+    ;
+
+    memory "calibration"
+        size            = 1;
+    ;
+
+    memory "fuse"
+        size            = 1;
+    ;
+;
+
+#------------------------------------------------------------
+# ATtiny12
+#------------------------------------------------------------
+
+part
+    id                  = "t12";
+    desc                = "ATtiny12";
+    stk500_devcode      = 0x12;
+    avr910_devcode      = 0x55;
+    signature           = 0x1e 0x90 0x05;
+    chip_erase_delay    = 20000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 8;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        write_lo        = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        write_hi        = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    o o o o  o o o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+;
+
+#------------------------------------------------------------
+# ATtiny13
+#------------------------------------------------------------
+
+part
+    id                  = "t13";
+    desc                = "ATtiny13";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x0E, 0x1E;
+     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x0E, 0xB4, 0x0E, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+    stk500_devcode      = 0x14;
+    signature           = 0x1e 0x90 0x07;
+    chip_erase_delay    = 4000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack     =
+	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 90;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        page_size       = 4;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x   x  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 1024;
+        page_size       = 32;
+        num_pages       = 32;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  0  0  0  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  0  0  0  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  0  0  0  0   0  0  0 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    0 0 0 x  x x x x",
+                          "x  x  x  x   x  x a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+	read            = "0  1  0  1   1  0  0  0    0 0 0 0  0 0 0 0",
+                          "x  x  x  x   x  x  x  x    x x o o  o o o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    1 1 i i  i i i i";
+    ;
+
+    memory "calibration"
+        size            = 2;
+        read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                          "0  0  0  0   0  0  0 a0    o o o o  o o o o";
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny15
+#------------------------------------------------------------
+
+part
+    id                  = "t15";
+    desc                = "ATtiny15";
+    stk500_devcode      = 0x13;
+    avr910_devcode      = 0x56;
+    signature           = 0x1e 0x90 0x06;
+    chip_erase_delay    = 8200;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 5;
+    synchcycles         = 6;
+    latchcycles         = 16;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 8200;
+        max_write_delay = 8200;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4100;
+        max_write_delay = 4100;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        write_lo        = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        write_hi        = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    o o o o  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
+                          "x  x  x  x   x  x  x  x    i i i i  1 1 i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+;
+
+#------------------------------------------------------------
+# AT90s1200
+#------------------------------------------------------------
+
+part
+    id               = "1200";
+    desc             = "AT90S1200";
+    stk500_devcode   = 0x33;
+    avr910_devcode   = 0x13;
+    signature        = 0x1e 0x90 0x01;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 1;
+    bytedelay		= 0;
+    pollindex		= 0;
+    pollvalue		= 0xFF;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 64;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1 0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x x a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1 1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x x a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 32;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 1024;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x   x  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x02;
+	delay		= 15;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s4414
+#------------------------------------------------------------
+
+part
+    id               = "4414";
+    desc             = "AT90S4414";
+    stk500_devcode   = 0x50;
+    avr910_devcode   = 0x28;
+    signature        = 0x1e 0x92 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
+                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+      ;
+    memory "lock"
+	size		= 1;
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2313
+#------------------------------------------------------------
+
+part
+    id               = "2313";
+    desc             = "AT90S2313";
+    stk500_devcode   = 0x40;
+    avr910_devcode   = 0x20;
+    signature        = 0x1e 0x91 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+      ;
+    memory "lock"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 1 1 x  x i i x",
+                          "x x x x  x x x x  x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2333
+#------------------------------------------------------------
+
+part
+    id               = "2333";
+##### WARNING: No XML file for device 'AT90S2333'! #####
+    desc             = "AT90S2333";
+    stk500_devcode   = 0x42;
+    avr910_devcode   = 0x34;
+    signature        = 0x1e 0x91 0x05;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        pwroff_after_write = yes;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1284P
+#------------------------------------------------------------
+
+# similar to ATmega164p
+
+part
+    id               = "m1284p";
+    desc             = "ATMEGA1284P";
+    has_jtag         = yes;
+    stk500_devcode   = 0x82; # no STK500v1 support, use the ATmega16 one
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x97 0x05;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# AT90s2343 (also AT90s2323 and ATtiny22)
+#------------------------------------------------------------
+
+part
+    id               = "2343";
+    desc             = "AT90S2343";
+    stk500_devcode   = 0x43;
+    avr910_devcode   = 0x4c;
+    signature        = 0x1e 0x91 0x03;
+    chip_erase_delay = 18000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
+        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
+        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 0;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 50;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0   0 0 0 0  0 0 0 0", 
+                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0   0 0 0 0  0 0 0 0",
+                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x   x  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 128;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   o o o x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 1  1 1 1 i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   o o o x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# AT90s4433
+#------------------------------------------------------------
+
+part
+    id               = "4433";
+    desc             = "AT90S4433";
+    stk500_devcode   = 0x51;
+    avr910_devcode   = 0x30;
+    signature        = 0x1e 0x92 0x03;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        pwroff_after_write = yes;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s4434
+#------------------------------------------------------------
+
+part
+    id               = "4434";
+##### WARNING: No XML file for device 'AT90S4434'! #####
+    desc             = "AT90S4434";
+    stk500_devcode   = 0x52;
+    avr910_devcode   = 0x6c;
+    signature        = 0x1e 0x92 0x02;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "eeprom"
+        size            = 256;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+      ;
+    memory "flash"
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x    x a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+    memory "lock"
+        size            = 1;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s8515
+#------------------------------------------------------------
+
+part
+    id               = "8515";
+    desc             = "AT90S8515";
+    stk500_devcode   = 0x60;
+    avr910_devcode   = 0x38;
+    signature        = 0x1e 0x93 0x01;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
+                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 8192;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x7f;
+        readback_p2     = 0x7f;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+      ;
+    memory "lock"
+	size		= 1;
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90s8535
+#------------------------------------------------------------
+
+part
+    id               = "8535";
+    desc             = "AT90S8535";
+    stk500_devcode   = 0x61;
+    avr910_devcode   = 0x68;
+    signature        = 0x1e 0x93 0x03;
+    chip_erase_delay = 20000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 1;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0x00;
+        readback_p2     = 0xff;
+        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x a8", 
+                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        size            = 8192;
+        min_write_delay = 9000;
+        max_write_delay = 20000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        write_lo        = "  0   1   0   0    0   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+        write_hi        = "  0   1   0   0    1   0   0   0",
+                          "  x   x   x   x  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  i   i   i   i    i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "fuse"
+	size		= 1;
+	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  o";
+	write		= "1  0  1  0   1  1  0  0   1  0  1  1   1  1  1  i",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+    memory "lock"
+	size		= 1;
+	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
+			  "x  x  x  x   x  x  x  x   o  o  x  x   x  x  x  x";
+	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
+			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega103
+#------------------------------------------------------------
+
+part
+    id               = "m103";
+    desc             = "ATMEGA103";
+    stk500_devcode   = 0xB1;
+    avr910_devcode   = 0x41;
+    signature        = 0x1e 0x97 0x01;
+    chip_erase_delay = 112000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x8E, 0x9E, 0x2E, 0x3E, 0xAE, 0xBE,
+        0x4E, 0x5E, 0xCE, 0xDE, 0x6E, 0x7E, 0xEE, 0xDE,
+        0x66, 0x76, 0xE6, 0xF6, 0x6A, 0x7A, 0xEA, 0x7A,
+        0x7F, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 15;
+    chiperasepolltimeout = 0;
+    programfusepulsewidth = 2;
+    programfusepolltimeout = 0;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 10;
+
+    memory "eeprom"
+        size            = 4096;
+        min_write_delay = 4000;
+        max_write_delay = 9000;
+        readback_p1     = 0x80;
+        readback_p2     = 0x7f;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 22000;
+        max_write_delay = 56000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x11;
+	delay		= 70;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "fuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0  x x x x  x x x x",
+                          "x x x x  x x x x  x x o x  o 1 o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 1  i 1 i i",
+                          "x x x x  x x x x  x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x x x x  x o o x";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega64
+#------------------------------------------------------------
+
+part
+    id               = "m64";
+    desc             = "ATMEGA64";
+    has_jtag         = yes;
+    stk500_devcode   = 0xA0;
+    avr910_devcode   = 0x45;
+    signature        = 0x1e 0x96 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x22;
+    spmcr               = 0x68;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x x i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+
+#------------------------------------------------------------
+# ATmega128
+#------------------------------------------------------------
+
+part
+    id               = "m128";
+    desc             = "ATMEGA128";
+    has_jtag         = yes;
+    stk500_devcode   = 0xB2;
+    avr910_devcode   = 0x43;
+    signature        = 0x1e 0x97 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x22;
+    spmcr               = 0x68;
+    rampz               = 0x3b;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 12;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x x i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90CAN128
+#------------------------------------------------------------
+
+part
+    id               = "c128";
+    desc             = "AT90CAN128";
+    has_jtag         = yes;
+    stk500_devcode   = 0xB3;
+#    avr910_devcode   = 0x43;
+    signature        = 0x1e 0x97 0x81;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    eecr                = 0x3f;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0  0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega16
+#------------------------------------------------------------
+
+part
+    id               = "m16";
+    desc             = "ATMEGA16";
+    has_jtag         = yes;
+    stk500_devcode   = 0x82;
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x94 0x03;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 100;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = yes;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+    memory "calibration"
+        size            = 4;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega164P
+#------------------------------------------------------------
+
+# close to ATmega16
+
+part
+    id               = "m164p";
+    desc             = "ATMEGA164P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x94 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega324P
+#------------------------------------------------------------
+
+# similar to ATmega164P
+
+part
+    id               = "m324p";
+    desc             = "ATMEGA324P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x95 0x08;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega644
+#------------------------------------------------------------
+
+# similar to ATmega164
+
+part
+    id               = "m644";
+    desc             = "ATMEGA644";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x96 0x09;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega644P
+#------------------------------------------------------------
+
+# similar to ATmega164p
+
+part
+    id               = "m644p";
+    desc             = "ATMEGA644P";
+    has_jtag         = yes;
+#   stk500_devcode   = 0x82; # no STK500v1 support
+#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
+    avr910_devcode   = 0x74;
+    signature        = 0x1e 0x96 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+
+
+#------------------------------------------------------------
+# ATmega162
+#------------------------------------------------------------
+
+part
+    id               = "m162";
+    desc             = "ATMEGA162";
+    has_jtag         = yes;
+    stk500_devcode   = 0x83;
+    avr910_devcode   = 0x63;
+    signature        = 0x1e 0x94 0x04;
+    chip_erase_delay = 9000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+
+    idr              = 0x04;
+    spmcr            = 0x57;
+    allowfullpagebitstream = yes;
+
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+       mode        = 0x41;
+    delay       = 10;
+    blocksize   = 128;
+    readsize    = 256;  
+
+        ;
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+                read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+                write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+        ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  1 1 1 1  1 i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        ;
+
+    memory "signature"
+        size            = 3;
+
+        read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+        ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+;
+
+
+
+#------------------------------------------------------------
+# ATmega163
+#------------------------------------------------------------
+
+part
+    id               = "m163";
+    desc             = "ATMEGA163";
+    stk500_devcode   = 0x81;
+    avr910_devcode   = 0x64;
+    signature        = 0x1e 0x94 0x02;
+    chip_erase_delay = 32000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 30;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 2;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 2;
+
+
+   memory "eeprom"
+        size            = 512;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 16000;
+        max_write_delay = 16000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o x x  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i 1 1  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  1 o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   1 1 1 1  1 i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  0 x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega169
+#------------------------------------------------------------
+
+part
+    id               = "m169";
+    desc             = "ATMEGA169";
+    has_jtag         = yes;
+    stk500_devcode   = 0x85;
+    avr910_devcode   = 0x78;
+    signature        = 0x1e 0x94 0x05;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega329
+#------------------------------------------------------------
+
+part
+    id               = "m329";
+    desc             = "ATMEGA329";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x95 0x03;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega3290
+#------------------------------------------------------------
+
+# identical to ATmega329
+
+part
+    id               = "m3290";
+    desc             = "ATMEGA3290";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x95 0x04;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a3   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega649
+#------------------------------------------------------------
+
+part
+    id               = "m649";
+    desc             = "ATMEGA649";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x96 0x03;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega6490
+#------------------------------------------------------------
+
+# identical to ATmega649
+
+part
+    id               = "m6490";
+    desc             = "ATMEGA6490";
+    has_jtag         = yes;
+#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
+#    avr910_devcode   = 0x?;  # try the ATmega169 one:
+    avr910_devcode   = 0x75;
+    signature        = 0x1e 0x96 0x04;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+
+   memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 20;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega32
+#------------------------------------------------------------
+
+part
+    id               = "m32";
+    desc             = "ATMEGA32";
+    has_jtag         = yes;
+    stk500_devcode   = 0x91;
+    avr910_devcode   = 0x72;
+    signature        = 0x1e 0x95 0x02;
+    chip_erase_delay = 9000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = yes;
+
+   memory "eeprom"
+        paged           = no;   /* leave this "no" */
+        page_size       = 4;    /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x  a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0 a13 a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o o";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0    0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega161
+#------------------------------------------------------------
+
+part
+    id               = "m161";
+    desc             = "ATMEGA161";
+    stk500_devcode   = 0x80;
+    avr910_devcode   = 0x60;
+    signature        = 0x1e 0x94 0x01;
+    chip_erase_delay = 28000;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 0;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 30;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 2;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 2;
+
+   memory "eeprom"
+        size            = 512;
+        min_write_delay = 3400;
+        max_write_delay = 3400;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 5;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 14000;
+        max_write_delay = 14000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x   x  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  x   x   x a12    a11 a10  a9  a8",
+                          " a7  a6   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 16;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+
+    memory "fuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
+                          "x x x x  x x x x   x o x o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 x  x x x x",
+                          "x x x x  x x x x   1 i 1 i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega8
+#------------------------------------------------------------
+
+part
+    id               = "m8";
+    desc             = "ATMEGA8";
+    stk500_devcode   = 0x70;
+    avr910_devcode   = 0x76;
+    signature        = 0x1e 0x93 0x07;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 10000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 20;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0  0  1  1   1  0  0  0   0  0  x  x   x  x  x  x",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+#------------------------------------------------------------
+# ATmega8515
+#------------------------------------------------------------
+
+part
+    id               = "m8515";
+    desc             = "ATMEGA8515";
+    stk500_devcode   = 0x63;
+    avr910_devcode   = 0x3A;
+    signature        = 0x1e 0x93 0x06;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+ read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+ write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0     0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0   o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+
+
+#------------------------------------------------------------
+# ATmega8535
+#------------------------------------------------------------
+
+part
+    id               = "m8535";
+    desc             = "ATMEGA8535";
+    stk500_devcode   = 0x64;
+    avr910_devcode   = 0x69;
+    signature        = 0x1e 0x93 0x08;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 6;
+    togglevtg           = 0;
+    poweroffdelay       = 0;
+    resetdelayms        = 0;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 512;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   x   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 128;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 2000;
+        max_write_delay = 2000;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
+                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATtiny26
+#------------------------------------------------------------
+
+part
+    id                  = "t26";
+    desc                = "ATTINY26";
+    stk500_devcode      = 0x21;
+    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x91 0x09;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 9000;
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        size            = 128;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	mode		= 0x04;
+	delay		= 10;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 2048;
+        page_size       = 32;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x21;
+	delay		= 6;
+	blocksize	= 16;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  x x x i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  x x x o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 4;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny261
+#------------------------------------------------------------
+# Close to ATtiny26
+
+part
+    id                  = "t261";
+    desc                = "ATTINY261";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x91 0x0c;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 128;
+        page_size       = 4;
+        num_pages       = 32;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 2048;
+        page_size       = 32;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        read_hi         = "  0  0  1  0   1  0  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4  a3 a2 a1 a0",
+                          "  o  o  o  o   o  o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x  x  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1  1  0  0",
+                          "  x  x  x  x   x  x a9 a8",
+                          " a7 a6 a5 a4   x  x  x  x",
+                          "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny461
+#------------------------------------------------------------
+# Close to ATtiny261
+
+part
+    id                  = "t461";
+    desc                = "ATTINY461";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x92 0x08;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 256;
+        page_size       = 4;
+        num_pages       = 64;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
+
+        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x x",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 4096;
+        page_size       = 64;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0   0  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        read_hi         = "  0  0  1  0   1   0  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1   1  0  0",
+                          "  x  x  x  x   x a10 a9 a8",
+                          " a7 a6 a5  x   x   x  x  x",
+                          "  x  x  x  x   x   x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATtiny861
+#------------------------------------------------------------
+# Close to ATtiny461
+
+part
+    id                  = "t861";
+    desc                = "ATTINY861";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x00, 0x10;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+#    stk500_devcode      = 0x21;
+#    avr910_devcode      = 0x5e;
+    signature           = 0x1e 0x93 0x0d;
+    pagel               = 0xb3;
+    bs2                 = 0xb2;
+    chip_erase_delay    = 4000;
+
+    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
+                          "x x x x  x x x x   x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 0;
+
+    pp_controlstack     =
+        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
+        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
+        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
+        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 2;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        size            = 512;
+        num_pages       = 128;
+        page_size       = 4;
+        min_write_delay = 4000;
+        max_write_delay = 4000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o";
+
+        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x a8",
+                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 4;
+	readsize	= 256;
+    ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+
+        read_lo         = "  0  0  1  0   0   0  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        read_hi         = "  0  0  1  0   1   0  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5 a4  a3  a2 a1 a0",
+                          "  o  o  o  o   o   o  o  o";
+
+        loadpage_lo     = "  0  1  0  0   0  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        loadpage_hi     = "  0  1  0  0   1  0  0  0",
+                          "  x  x  x  x   x  x  x  x",
+                          "  x  x  x a4  a3 a2 a1 a0",
+                          "  i  i  i  i   i  i  i  i";
+
+        writepage       = "  0  1  0  0   1   1  0  0",
+                          "  x  x  x  x a11 a10 a9 a8",
+                          " a7 a6 a5  x   x   x  x  x",
+                          "  x  x  x  x   x   x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+    ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
+    ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
+                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
+
+        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
+                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+    ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
+                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
+    ;
+
+;
+
+
+#------------------------------------------------------------
+# ATmega48
+#------------------------------------------------------------
+
+part
+    id               = "m48";
+    desc             = "ATMEGA48";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode   = 0x59;
+#    avr910_devcode   = 0x;
+    signature        = 0x1e 0x92 0x05;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 45000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 256;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 4096;
+        page_size       = 64;
+        num_pages       = 64;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0    0 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0    0 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x x x o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x x x i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
+                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+
+#------------------------------------------------------------
+# ATmega88
+#------------------------------------------------------------
+
+part
+    id               = "m88";
+    desc             = "ATMEGA88";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode   = 0x73;
+#    avr910_devcode   = 0x;
+    signature        = 0x1e 0x93 0x0a;
+    pagel            = 0xd7;
+    bs2              = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 512;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+	read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+	write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+      ;
+    memory "flash"
+        paged           = yes;
+        size            = 8192;
+        page_size       = 64;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0    0   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        read_hi         = "  0   0   1   0    1   0   0   0",
+                          "  0   0   0   0  a11 a10  a9  a8",
+                          " a7  a6  a5  a4   a3  a2  a1  a0",
+                          "  o   o   o   o    o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   x      x   x   x   x",
+                          "  x   x   x  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0   0   0   0    a11 a10  a9  a8",
+                          " a7  a6  a5   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x   i i i i  i i i i";
+      ;
+
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x   x x x x  x o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x   x x x x  x i i i";
+      ;
+
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
+                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega168
+#------------------------------------------------------------
+
+part
+    id              = "m168";
+    desc            = "ATMEGA168";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode  = 0x86;
+    # avr910_devcode = 0x;
+    signature       = 0x1e 0x94 0x06;
+    pagel           = 0xd7;
+    bs2             = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
+                       "x x x x x x x x x x x x x x x x";
+
+    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
+                       "x x x x x x x x x x x x x x x x";
+
+    timeout         = 200;
+    stabdelay       = 100;
+    cmdexedelay     = 25;
+    synchloops      = 32;
+    bytedelay       = 0;
+    pollindex       = 3;
+    pollvalue       = 0x53;
+    predelay        = 1;
+    postdelay       = 1;
+    pollmethod      = 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 512;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = " 1 0 1 0 0 0 0 0",
+                          " 0 0 0 x x x x a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+    
+        write           = " 1 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 16384;
+        page_size       = 128;
+        num_pages       = 128;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = " 0 0 1 0 0 0 0 0",
+                          " 0 0 0 a12 a11 a10 a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+        
+        read_hi          = " 0 0 1 0 1 0 0 0",
+                           " 0 0 0 a12 a11 a10 a9 a8",
+                           " a7 a6 a5 a4 a3 a2 a1 a0",
+                           " o o o o o o o o";
+        
+        loadpage_lo     = " 0 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        loadpage_hi     = " 0 1 0 0 1 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        writepage       = " 0 1 0 0 1 1 0 0",
+                          " 0 0 0 a12 a11 a10 a9 a8",
+                          " a7 a6 x x x x x x",
+                          " x x x x x x x x";
+
+        mode        = 0x41;
+        delay       = 6;
+        blocksize   = 128;
+        readsize    = 256;
+
+        ;
+        
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x x x x x x o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
+                          "x x x x x x x x x x x x x i i i";
+        ;
+    
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x x x o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
+                          "x x x x x x x x 1 1 i i i i i i";
+        ;
+    
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
+                          "0 0 0 0 0 0 0 0 o o o o o o o o";
+        ;
+    
+    memory "signature"
+        size            = 3;
+        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
+                          "x x x x x x a1 a0 o o o o o o o o";
+        ;
+;
+
+#------------------------------------------------------------
+# ATmega328
+#------------------------------------------------------------
+
+part
+    id              = "m328p";
+    desc            = "ATMEGA328P";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+    stk500_devcode  = 0x86;
+    # avr910_devcode = 0x;
+    signature       = 0x1e 0x95 0x0F;
+    pagel           = 0xd7;
+    bs2             = 0xc2;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
+                       "x x x x x x x x x x x x x x x x";
+
+    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
+                       "x x x x x x x x x x x x x x x x";
+
+    timeout         = 200;
+    stabdelay       = 100;
+    cmdexedelay     = 25;
+    synchloops      = 32;
+    bytedelay       = 0;
+    pollindex       = 3;
+    pollvalue       = 0x53;
+    predelay        = 1;
+    postdelay       = 1;
+    pollmethod      = 1;
+
+    pp_controlstack     =
+	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    resetdelay          = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    memory "eeprom"
+        paged           = no;
+        page_size       = 4;
+        size            = 1024;
+        min_write_delay = 3600;
+        max_write_delay = 3600;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = " 1 0 1 0 0 0 0 0",
+                          " 0 0 0 x x x a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+    
+        write           = " 1 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   a9  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 5;
+	blocksize	= 4;
+	readsize	= 256;
+        ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = " 0 0 1 0 0 0 0 0",
+                          " 0 0 a13 a12 a11 a10 a9 a8",
+                          " a7 a6 a5 a4 a3 a2 a1 a0",
+                          " o o o o o o o o";
+        
+        read_hi          = " 0 0 1 0 1 0 0 0",
+                           " 0 0 a13 a12 a11 a10 a9 a8",
+                           " a7 a6 a5 a4 a3 a2 a1 a0",
+                           " o o o o o o o o";
+        
+        loadpage_lo     = " 0 1 0 0 0 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        loadpage_hi     = " 0 1 0 0 1 0 0 0",
+                          " 0 0 0 x x x x x",
+                          " x x a5 a4 a3 a2 a1 a0",
+                          " i i i i i i i i";
+        
+        writepage       = " 0 1 0 0 1 1 0 0",
+                          " 0 0 a13 a12 a11 a10 a9 a8",
+                          " a7 a6 x x x x x x",
+                          " x x x x x x x x";
+
+        mode        = 0x41;
+        delay       = 6;
+        blocksize   = 128;
+        readsize    = 256;
+
+        ;
+        
+    memory "lfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "hfuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x o o o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
+                          "x x x x x x x x i i i i i i i i";
+        ;
+    
+    memory "efuse"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
+                          "x x x x x x x x x x x x x o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
+                          "x x x x x x x x x x x x x i i i";
+        ;
+    
+    memory "lock"
+        size            = 1;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
+                          "x x x x x x x x x x o o o o o o";
+        
+        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
+                          "x x x x x x x x 1 1 i i i i i i";
+        ;
+    
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
+                          "0 0 0 0 0 0 0 0 o o o o o o o o";
+        ;
+    
+    memory "signature"
+        size            = 3;
+        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
+                          "x x x x x x a1 a0 o o o o o o o o";
+        ;
+;
+
+#------------------------------------------------------------
+# ATtiny2313
+#------------------------------------------------------------
+
+part
+     id            = "t2313";
+     desc          = "ATtiny2313";
+     has_debugwire = yes;
+     flash_instr   = 0xB2, 0x0F, 0x1F;
+     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+     stk500_devcode   = 0x23;
+##   Use the ATtiny26 devcode:
+     avr910_devcode   = 0x5e;
+     signature        = 0x1e 0x91 0x0a;
+     pagel            = 0xD4;
+     bs2              = 0xD6;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
+        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
+        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
+        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+# The information in the data sheet of April/2004 is wrong, this works:
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
+# The information in the data sheet of April/2004 is wrong, this works:
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM2
+#------------------------------------------------------------
+
+part
+     id            = "pwm2";
+     desc          = "AT90PWM2";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x81;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM3
+#------------------------------------------------------------
+
+# Completely identical to AT90PWM2 (including the signature!)
+
+part
+     id            = "pwm3";
+     desc          = "AT90PWM3";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x81;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM2B
+#------------------------------------------------------------
+# Same as AT90PWM2 but different signature.
+
+part
+     id            = "pwm2b";
+     desc          = "AT90PWM2B";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x83;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90PWM3B
+#------------------------------------------------------------
+
+# Completely identical to AT90PWM2B (including the signature!)
+
+part
+     id            = "pwm3b";
+     desc          = "AT90PWM3B";
+     has_debugwire = yes;
+     flash_instr   = 0xB6, 0x01, 0x11;
+     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
+	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
+	             0x99, 0xF9, 0xBB, 0xAF;
+     stk500_devcode   = 0x65;
+##  avr910_devcode   = ?;
+     signature        = 0x1e 0x93 0x83;
+     pagel            = 0xD8;
+     bs2              = 0xE2;
+     reset            = io;
+     chip_erase_delay = 9000;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0   a11 a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0   0",
+                           "  0  0  0  0   a11 a10 a9  a8",
+                           " a7 a6 a5  x   x   x   x   x",
+                           "  x  x  x  x   x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 64;
+	readsize	= 256;
+       ;
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  x x o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny25
+#------------------------------------------------------------
+
+part
+     id            = "t25";
+     desc          = "ATtiny25";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x91 0x08;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny45
+#------------------------------------------------------------
+
+part
+     id            = "t45";
+     desc          = "ATtiny45";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x92 0x06;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack     =
+	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 256;
+         page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 4096;
+         page_size       = 64;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny85
+#------------------------------------------------------------
+
+part
+     id            = "t85";
+     desc          = "ATtiny85";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x02, 0x12;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x93 0x0b;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x  a8",
+			  " a7  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0  0",
+                           "  0  0  0  0  a11 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 2;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATmega640
+#------------------------------------------------------------
+# Almost same as ATmega1280, except for different memory sizes
+
+part
+    id               = "m640";
+    desc             = "ATMEGA640";
+    signature        = 0x1e 0x96 0x08;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1280
+#------------------------------------------------------------
+
+part
+    id               = "m1280";
+    desc             = "ATMEGA1280";
+    signature        = 0x1e 0x97 0x03;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega1281
+#------------------------------------------------------------
+# Identical to ATmega1280
+
+part
+    id               = "m1281";
+    desc             = "ATMEGA1281";
+    signature        = 0x1e 0x97 0x04;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega2560
+#------------------------------------------------------------
+
+part
+    id               = "m2560";
+    desc             = "ATMEGA2560";
+    signature        = 0x1e 0x98 0x01;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 262144;
+        page_size       = 256;
+        num_pages       = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+        load_ext_addr   = "  0   1   0   0      1   1   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0 a16",
+                          "  0   0   0   0      0   0   0   0";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega2561
+#------------------------------------------------------------
+
+part
+    id               = "m2561";
+    desc             = "ATMEGA2561";
+    signature        = 0x1e 0x98 0x02;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x    a11 a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 262144;
+        page_size       = 256;
+        num_pages       = 1024;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+        load_ext_addr   = "  0   1   0   0      1   1   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0 a16",
+                          "  0   0   0   0      0   0   0   0";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  x i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny24
+#------------------------------------------------------------
+
+part
+     id            = "t24";
+     desc          = "ATtiny24";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x91 0x0b;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 128;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
+                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 2048;
+         page_size       = 32;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0   0  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x   x   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0  0 a9 a8",
+                           " a7 a6 a5 a4   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny44
+#------------------------------------------------------------
+
+part
+     id            = "t44";
+     desc          = "ATtiny44";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+                     0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x92 0x07;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 256;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 4096;
+         page_size       = 64;
+         num_pages       = 64;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0    0  a10 a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1  1  0  0",
+                           "  0  0  0  0   0 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# ATtiny84
+#------------------------------------------------------------
+
+part
+     id            = "t84";
+     desc          = "ATtiny84";
+     has_debugwire = yes;
+     flash_instr   = 0xB4, 0x07, 0x17;
+     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
+	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
+	             0x99, 0xE1, 0xBB, 0xAC;
+## no STK500 devcode in XML file, use the ATtiny45 one
+     stk500_devcode   = 0x14;
+##  avr910_devcode   = ?;
+##  Try the AT90S2313 devcode:
+     avr910_devcode   = 0x20;
+     signature        = 0x1e 0x93 0x0c;
+     reset            = io;
+     chip_erase_delay = 4500;
+
+     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
+                        "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    hvsp_controlstack   =
+        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
+        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
+        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
+        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
+    hventerstabdelay    = 100;
+    hvspcmdexedelay     = 0;
+    synchcycles         = 6;
+    latchcycles         = 1;
+    togglevtg           = 1;
+    poweroffdelay       = 25;
+    resetdelayms        = 0;
+    resetdelayus        = 70;
+    hvleavestabdelay    = 100;
+    resetdelay          = 25;
+    chiperasepolltimeout = 40;
+    chiperasetime       = 0;
+    programfusepolltimeout = 25;
+    programlockpolltimeout = 25;
+
+     memory "eeprom"
+         size            = 512;
+        paged           = no;
+        page_size       = 4;
+         min_write_delay = 4000;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
+
+         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
+                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0   0  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x   x   x   x",
+			  "  x  a6  a5  a4     a3  a2   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 4;
+	readsize	= 256;
+       ;
+     memory "flash"
+         paged           = yes;
+         size            = 8192;
+         page_size       = 64;
+         num_pages       = 128;
+         min_write_delay = 4500;
+         max_write_delay = 4500;
+         readback_p1     = 0xff;
+         readback_p2     = 0xff;
+         read_lo         = "  0   0   1   0    0   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         read_hi         = "  0   0   1   0    1   0   0   0",
+                           "  0   0   0   0  a11 a10  a9  a8",
+                           " a7  a6  a5  a4   a3  a2  a1  a0",
+                           "  o   o   o   o    o   o   o   o";
+
+         loadpage_lo     = "  0   1   0   0    0   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         loadpage_hi     = "  0   1   0   0    1   0   0   0",
+                           "  0   0   0   x    x   x   x   x",
+                           "  x   x   x  a4   a3  a2  a1  a0",
+                           "  i   i   i   i    i   i   i   i";
+
+         writepage       = "  0  1  0  0   1   1   0  0",
+                           "  0  0  0  0  a11 a10 a9 a8",
+                           " a7 a6 a5  x   x  x  x  x",
+                           "  x  x  x  x   x  x  x  x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 32;
+	readsize	= 256;
+       ;
+#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.
+     memory "signature"
+         size            = 3;
+         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
+                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+       ;
+
+     memory "lock"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
+                           "x x x x  x x x x  x x x x  x x i i";
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
+                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "lfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "hfuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                           "x x x x  x x x x  i i i i  i i i i";
+
+         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+       ;
+
+     memory "efuse"
+         size            = 1;
+         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                           "x x x x  x x x x  x x x x  x x x i";
+
+         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                           "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+     ;
+
+     memory "calibration"
+         size            = 1;
+         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
+                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
+     ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB646
+#------------------------------------------------------------
+
+part
+    id               = "usb646";
+    desc             = "AT90USB646";
+#    signature        = 0x1e 0x96 0x82; ?
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB647
+#------------------------------------------------------------
+# identical to AT90USB646
+
+part
+    id               = "usb647";
+    desc             = "AT90USB647";
+#    signature        = 0x1e 0x96 0x82; ?
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB1286
+#------------------------------------------------------------
+
+part
+    id               = "usb1286";
+    desc             = "AT90USB1286";
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# AT90USB1287
+#------------------------------------------------------------
+# identical to AT90USB1286
+
+part
+    id               = "usb1287";
+    desc             = "AT90USB1287";
+    signature        = 0x1e 0x97 0x82;
+    has_jtag         = yes;
+#    stk500_devcode   = 0xB2;
+#    avr910_devcode   = 0x43;
+    chip_erase_delay = 9000;
+    pagel            = 0xD7;
+    bs2              = 0xA0;
+    reset            = dedicated;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "x x x x  x x x x    x x x x  x x x x";
+
+    timeout		= 200;
+    stabdelay		= 100;
+    cmdexedelay		= 25;
+    synchloops		= 32;
+    bytedelay		= 0;
+    pollindex		= 3;
+    pollvalue		= 0x53;
+    predelay		= 1;
+    postdelay		= 1;
+    pollmethod		= 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    rampz               = 0x3b;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 4096;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  x   x   x   x    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0", 
+                          "  i   i   i   i      i   i   i   i";
+
+	loadpage_lo	= "  1   1   0   0      0   0   0   1",
+			  "  0   0   0   0      0   0   0   0",
+			  "  0   0   0   0      0  a2  a1  a0",
+			  "  i   i   i   i      i   i   i   i";
+
+	writepage	= "  1   1   0   0      0   0   1   0",
+			  "  0   0   x   x      x a10  a9  a8",
+			  " a7  a6  a5  a4     a3   0   0   0",
+			  "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 10;
+	blocksize	= 8;
+	readsize	= 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 131072;
+        page_size       = 256;
+        num_pages       = 512;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0x00;
+        readback_p2     = 0x00;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  x   x   x   x      x   x   x   x",
+                          "  x  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "a15 a14 a13 a12    a11 a10  a9  a8",
+                          " a7   x   x   x      x   x   x   x",
+                          "  x   x   x   x      x   x   x   x";
+
+	mode		= 0x41;
+	delay		= 6;
+	blocksize	= 256;
+	readsize	= 256;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
+                          "x x x x  x x x x  i i i i  i i i i";
+
+        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "x x x x  x x x x  x x x x  i i i i";
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "x x x x  x x x x  o o o o  o o o o";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
+                          "x x x x  x x x x   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "calibration"
+        size            = 1;
+        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
+                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
+                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
+      ;
+  ;
+
+#------------------------------------------------------------
+# ATmega325
+#------------------------------------------------------------
+
+part
+    id               = "m325";
+    desc             = "ATMEGA325";
+    signature        = 0x1e 0x95 0x05;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega645
+#------------------------------------------------------------
+
+part
+    id               = "m645";
+    desc             = "ATMEGA645";
+    signature        = 0x1E 0x96 0x05;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3   0   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 8;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "   0   0   1   0      0   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        read_hi         = "   0   0   1   0      1   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "   0   1   0   0      1   1   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   0   0   0   0      0   0   0   0";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega3250
+#------------------------------------------------------------
+
+part
+    id               = "m3250";
+    desc             = "ATMEGA3250";
+    signature        = 0x1E 0x95 0x06;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 4;  /* for parallel programming */
+        size            = 1024;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0   0  a9  a8",
+                          " a7  a6  a5  a4     a3  a2   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 32768;
+        page_size       = 128;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "  0   0   1   0      0   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        read_hi         = "  0   0   1   0      1   0   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  0   1   0   0      1   1   0   0",
+                          "  0 a14 a13 a12    a11 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
+
+#------------------------------------------------------------
+# ATmega6450
+#------------------------------------------------------------
+
+part
+    id               = "m6450";
+    desc             = "ATMEGA6450";
+    signature        = 0x1E 0x96 0x06;
+    has_jtag         = yes;
+#   stk500_devcode   = 0x??; # No STK500v1 support?
+#   avr910_devcode   = 0x??; # Try the ATmega16 one
+    avr910_devcode   = 0x74;
+    pagel            = 0xd7;
+    bs2              = 0xa0;
+    chip_erase_delay = 9000;
+    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
+                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
+
+    timeout             = 200;
+    stabdelay           = 100;
+    cmdexedelay         = 25;
+    synchloops          = 32;
+    bytedelay           = 0;
+    pollindex           = 3;
+    pollvalue           = 0x53;
+    predelay            = 1;
+    postdelay           = 1;
+    pollmethod          = 1;
+
+    pp_controlstack     =
+        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
+        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
+        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
+        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
+    hventerstabdelay    = 100;
+    progmodedelay       = 0;
+    latchcycles         = 5;
+    togglevtg           = 1;
+    poweroffdelay       = 15;
+    resetdelayms        = 1;
+    resetdelayus        = 0;
+    hvleavestabdelay    = 15;
+    chiperasepulsewidth = 0;
+    chiperasepolltimeout = 10;
+    programfusepulsewidth = 0;
+    programfusepolltimeout = 5;
+    programlockpulsewidth = 0;
+    programlockpolltimeout = 5;
+
+    idr                 = 0x31;
+    spmcr               = 0x57;
+    allowfullpagebitstream = no;
+
+    memory "eeprom"
+        paged           = no; /* leave this "no" */
+        page_size       = 8;  /* for parallel programming */
+        size            = 2048;
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read            = "  1   0   1   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  o   o   o   o      o   o   o   o";
+
+        write           = "  1   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_lo     = "  1   1   0   0      0   0   0   1",
+                          "  0   0   0   0      0   0   0   0",
+                          "  0   0   0   0      0  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "  1   1   0   0      0   0   1   0",
+                          "  0   0   0   0      0 a10  a9  a8",
+                          " a7  a6  a5  a4     a3   0   0   0",
+                          "  x   x   x   x      x   x   x   x";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 4;
+        readsize        = 256;
+      ;
+
+    memory "flash"
+        paged           = yes;
+        size            = 65536;
+        page_size       = 256;
+        num_pages       = 256;
+        min_write_delay = 4500;
+        max_write_delay = 4500;
+        readback_p1     = 0xff;
+        readback_p2     = 0xff;
+        read_lo         = "   0   0   1   0      0   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        read_hi         = "   0   0   1   0      1   0   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   o   o   o   o      o   o   o   o";
+
+        loadpage_lo     = "  0   1   0   0      0   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        loadpage_hi     = "  0   1   0   0      1   0   0   0",
+                          "  0   0   0   0      0   0   0   0",
+                          "  a7 a6  a5  a4     a3  a2  a1  a0",
+                          "  i   i   i   i      i   i   i   i";
+
+        writepage       = "   0   1   0   0      1   1   0   0",
+                          " a15 a14 a13 a12    a11 a10  a9  a8",
+                          "  a7  a6  a5  a4     a3  a2  a1  a0",
+                          "   0   0   0   0      0   0   0   0";
+
+        mode            = 0x41;
+        delay           = 10;
+        blocksize       = 128;
+        readsize        = 256;
+      ;
+
+    memory "lock"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "x x x x  x x x x   x x o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "lfuse"
+        size            = 1;
+        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "hfuse"
+        size            = 1;
+        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "efuse"
+        size            = 1;
+
+        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
+                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
+
+        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
+                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
+        min_write_delay = 9000;
+        max_write_delay = 9000;
+      ;
+
+    memory "signature"
+        size            = 3;
+        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
+                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
+      ;
+
+    memory "calibration"
+        size            = 1;
+
+        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
+                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
+        ;
+  ;
diff --git a/Marlin/Gen7/boards.txt b/Marlin/Gen7/boards.txt
deleted file mode 100644
index d6fbaee..0000000
--- a/Marlin/Gen7/boards.txt
+++ /dev/null
@@ -1,101 +0,0 @@
-##############################################################
-
-Gen7-644-16.name=Gen7 with ATmega644 and 16 MHz
-Gen7-644-16.upload.protocol=stk500v2
-Gen7-644-16.upload.maximum_size=63488
-Gen7-644-16.upload.speed=115200
-Gen7-644-16.bootloader.low_fuses=0xF7
-Gen7-644-16.bootloader.high_fuses=0xD4
-Gen7-644-16.bootloader.extended_fuses=0xFD
-Gen7-644-16.bootloader.path=Gen7
-Gen7-644-16.bootloader.file=bootloader-644-16MHz.hex
-Gen7-644-16.bootloader.unlock_bits=0x3F
-Gen7-644-16.bootloader.lock_bits=0x0F
-Gen7-644-16.build.mcu=atmega644
-Gen7-644-16.build.f_cpu=16000000L
-Gen7-644-16.build.core=arduino
-
-##############################################################
-
-Gen7-644-20.name=Gen7 with ATmega644 and 20 MHz
-Gen7-644-20.upload.protocol=stk500v2
-Gen7-644-20.upload.maximum_size=63488
-Gen7-644-20.upload.speed=115200
-Gen7-644-20.bootloader.low_fuses=0xF7
-Gen7-644-20.bootloader.high_fuses=0xD4
-Gen7-644-20.bootloader.extended_fuses=0xFD
-Gen7-644-20.bootloader.path=Gen7
-Gen7-644-20.bootloader.file=bootloader-644-20MHz.hex
-Gen7-644-20.bootloader.unlock_bits=0x3F
-Gen7-644-20.bootloader.lock_bits=0x0F
-Gen7-644-20.build.mcu=atmega644
-Gen7-644-20.build.f_cpu=20000000L
-Gen7-644-20.build.core=arduino
-
-##############################################################
-
-Gen7-644P-16.name=Gen7 with ATmega644P and 16 MHz
-Gen7-644P-16.upload.protocol=stk500v2
-Gen7-644P-16.upload.maximum_size=63488
-Gen7-644P-16.upload.speed=115200
-Gen7-644P-16.bootloader.low_fuses=0xF7
-Gen7-644P-16.bootloader.high_fuses=0xD4
-Gen7-644P-16.bootloader.extended_fuses=0xFD
-Gen7-644P-16.bootloader.path=Gen7
-Gen7-644P-16.bootloader.file=bootloader-644P-16MHz.hex
-Gen7-644P-16.bootloader.unlock_bits=0x3F
-Gen7-644P-16.bootloader.lock_bits=0x0F
-Gen7-644P-16.build.mcu=atmega644p
-Gen7-644P-16.build.f_cpu=16000000L
-Gen7-644P-16.build.core=arduino
-
-##############################################################
-
-Gen7-644P-20.name=Gen7 with ATmega644P and 20 MHz
-Gen7-644P-20.upload.protocol=stk500v2
-Gen7-644P-20.upload.maximum_size=63488
-Gen7-644P-20.upload.speed=115200
-Gen7-644P-20.bootloader.low_fuses=0xF7
-Gen7-644P-20.bootloader.high_fuses=0xD4
-Gen7-644P-20.bootloader.extended_fuses=0xFD
-Gen7-644P-20.bootloader.path=Gen7
-Gen7-644P-20.bootloader.file=bootloader-644P-20MHz.hex
-Gen7-644P-20.bootloader.unlock_bits=0x3F
-Gen7-644P-20.bootloader.lock_bits=0x0F
-Gen7-644P-20.build.mcu=atmega644p
-Gen7-644P-20.build.f_cpu=20000000L
-Gen7-644P-20.build.core=arduino
-
-##############################################################
-
-Gen7-1284p-16.name=Gen7 with ATmega1284 and 16 MHz
-Gen7-1284p-16.upload.protocol=stk500v2
-Gen7-1284p-16.upload.maximum_size=129024
-Gen7-1284p-16.upload.speed=115200
-Gen7-1284p-16.bootloader.low_fuses=0xF7
-Gen7-1284p-16.bootloader.high_fuses=0xD4
-Gen7-1284p-16.bootloader.extended_fuses=0xFD
-Gen7-1284p-16.bootloader.path=Gen7
-Gen7-1284p-16.bootloader.file=bootloader-1284P-16MHz.hex
-Gen7-1284p-16.bootloader.unlock_bits=0x3F
-Gen7-1284p-16.bootloader.lock_bits=0x2F
-Gen7-1284p-16.build.mcu=atmega1284p
-Gen7-1284p-16.build.f_cpu=16000000L
-Gen7-1284p-16.build.core=arduino
-
-##############################################################
-
-Gen7-1284p-20.name=Gen7 with ATmega1284 and 20 MHz
-Gen7-1284p-20.upload.protocol=stk500v2
-Gen7-1284p-20.upload.maximum_size=129024
-Gen7-1284p-20.upload.speed=115200
-Gen7-1284p-20.bootloader.low_fuses=0xF7
-Gen7-1284p-20.bootloader.high_fuses=0xD4
-Gen7-1284p-20.bootloader.extended_fuses=0xFD
-Gen7-1284p-20.bootloader.path=Gen7
-Gen7-1284p-20.bootloader.file=bootloader-1284P-16MHz.hex
-Gen7-1284p-20.bootloader.unlock_bits=0x3F
-Gen7-1284p-20.bootloader.lock_bits=0x2F
-Gen7-1284p-20.build.mcu=atmega1284p
-Gen7-1284p-20.build.f_cpu=20000000L
-Gen7-1284p-20.build.core=arduino
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
deleted file mode 100644
index 93df372..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-1284P-16MHz.hex
+++ /dev/null
@@ -1,113 +0,0 @@
-:020000021000EC
-:10F8000011241FBE8FEF90E49EBF8DBF01C32F92C6
-:10F810003F924F925F926F927F928F929F92AF92A0
-:10F82000BF92CF92DF92EF92FF920F931F93DF93DD
-:10F83000CF93CDB7DEB7C252D1400FB6F894DEBF3A
-:10F840000FBECDBF44245524DD24C25EDE4F188296
-:10F85000CE51D1408824992454013AC20E9428FFF5
-:10F86000282F133059F1143028F4113081F0123060
-:10F8700000F507C0153081F1153030F1163071F701
-:10F880003DC08B3159F711E05BE1D52EE7CF8130D8
-:10F8900041F0C25EDE4F3881CE51D140831709F06E
-:10F8A00019C2D226C25EDE4F2883CE51D14012E06B
-:10F8B000D5CFF82EEE24D82613E0D0CF90E0E82A5A
-:10F8C000F92AD22614E0CACF8E3009F003C2D82616
-:10F8D00015E044245524C2CFE1E0F0E0EC0FFD1F19
-:10F8E000E40DF51D80830894411C511CD8264E144C
-:10F8F0005F0409F0B3CF720116E0B0CF8D1509F0A7
-:10F90000E9C1EAC1CC2447C08D81803311F090E079
-:10F910000AC08F81882311F49EE105C0813011F067
-:10F9200095E001C097E91A821B828D818C838E81BC
-:10F930008D839E831F8247E0E42EF12C88C11A82BA
-:10F9400068E06B8383E58C8394E59D83EBE4EE8331
-:10F9500085E38F8380E3888789878FE58A8782E3C1
-:10F960008B873BE0E32EF12C72C18A81813941F013
-:10F97000823941F0803911F48FE005C080E003C086
-:10F9800082E001C08AE01A828B8323E0E22EF12C10
-:10F990005EC1CC24C3941A8292E0E92EF12C58C1A6
-:10F9A0008D81882311F48EE128C0813011F085E02B
-:10F9B00024C087E922C01A8229E0E1E0F0E0209328
-:10F9C000570084911BC08B81803589F48C818830ED
-:10F9D00039F439E0E2E0F0E03093570084910DC053
-:10F9E00069E0E0E0F0E060935700849106C099E0A0
-:10F9F000E3E0F0E09093570084911A828B831C829D
-:10FA000084E0E82EF12C23C18A8190E0A0E0B0E0F0
-:10FA1000B82EAA24992488248B8190E0A0E0B0E03D
-:10FA2000DC0199278827882A992AAA2ABB2A8D814E
-:10FA300090E0A0E0B0E0882A992AAA2ABB2A8C810B
-:10FA400090E0A0E0B0E0BA2FA92F982F8827882A4D
-:10FA5000992AAA2ABB2A88C0EA81C05EDE4FE883C1
-:10FA6000C052D140C15EDE4F1882CF51D1408B8150
-:10FA7000A82FB0E0C15EDE4F28813981CF51D1403F
-:10FA8000A22BB32B933109F042C075016401CC0C59
-:10FA9000DD1CEE1CFF1C33E0F601E0925B003093AE
-:10FAA0005700E89507B600FCFDCF8E01055F1F4F9C
-:10FAB000F801808161810E5F1F4FA5019401220F23
-:10FAC000331F441F551F362E222490E0822993298C
-:10FAD00061E00C01F90140935B0060935700E895E9
-:10FAE00011240894811C911CA11CB11C129701F7D0
-:10FAF00085E0F601E0925B0080935700E89507B639
-:10FB000000FCFDCF81E180935700E8952DC0FE01F8
-:10FB10003B9620E030E040E050E011977D0100E0AE
-:10FB200010E00894E11CF11C011D111D6081F99980
-:10FB3000FECF1FBAC901880D991D92BD81BD60BD60
-:10FB40000FB6F894FA9AF99A0FBE2F5F3F4F4F4FB6
-:10FB50005F4F2E153F054007510711F03196E6CF54
-:10FB6000820E931EA41EB51E1A826EC09A81CE5DAF
-:10FB7000DE4F9883C252D140CF5DDE4F1882C15212
-:10FB8000D1408B81C82EDD24CF5DDE4FE881F98125
-:10FB9000C152D140CE2ADF2A1A8289818431E1F410
-:10FBA0009601BE016D5F7F4FD501C401880F991F7B
-:10FBB000AA1FBB1FABBFFC0187919691FB018083FD
-:10FBC00091836E5F7F4F0894811C911CA11CB11C16
-:10FBD0002250304049F72EC0BE016D5F7F4F20E0BC
-:10FBE00030E040E050E00894C108D108760100E020
-:10FBF00010E00894C11CD11C0894E11CF11C011DEB
-:10FC0000111DF999FECFC901880D991D92BD81BDC5
-:10FC1000F89A80B5FB018193BF012F5F3F4F4F4F93
-:10FC20005F4F2E153F054007510759F7820E931E6F
-:10FC3000A41EB51E23E0E22EF12CEC0CFD1CFB01F2
-:10FC4000108205C080EC8A8392E0E92EF12CCC244E
-:10FC50008BE10E94C7FEC25EDE4F8881CE51D1404B
-:10FC60000E94C7FE8F2D0E94C7FE8E2D0E94C7FEE8
-:10FC70008EE00E94C7FE85E1D82EC25EDE4FF8817D
-:10FC8000CE51D140DF26DE24DF243E010894611CE2
-:10FC9000711C0AC0F30111913F01812F0E94C7FE20
-:10FCA000D1260894E108F108E114F10499F78D2DAB
-:10FCB0000E94C7FECC2009F044C0C25EDE4FF8812E
-:10FCC000CE51D140FF5FC25EDE4FF883CE51D140AE
-:10FCD000EE24FF2410E0C2CD9981933109F4BCCE0B
-:10FCE0009431B0F4933009F440CE943038F491302C
-:10FCF00009F425CE923009F0A5CF04CE903109F455
-:10FD000001CE913109F445CE963009F09BCF7CCEDF
-:10FD1000983109F458CE993150F4953109F49CCEBC
-:10FD2000953108F423CF963109F08CCF1FCF9B314A
-:10FD300009F436CE9D3109F4E7CD9A3109F082CF2E
-:10FD40003ACECE5DDE4F0FB6F894DEBF0FBECDBF0C
-:10FD5000CF91DF911F910F91FF90EF90DF90CF90A7
-:10FD6000BF90AF909F908F907F906F905F904F90DB
-:10FD70003F902F9008958091C00087FFFCCF089599
-:10FD80008091C00087FFFCCF8091C6000895982F16
-:10FD90008091C00085FFFCCF9093C60008959B0121
-:10FDA000AC0197FF11C08091C00082608093C000B9
-:10FDB00050954095309521953F4F4F4F5F4F60E0F4
-:10FDC00074E284EF90E009C08091C0008D7F809341
-:10FDD000C00060E072E18AE790E00E9447FF2C5F7C
-:10FDE0003F4F4F4F5F4F83E0569547953795279587
-:10FDF0008A95D1F7215030403093C5002093C4003C
-:10FE0000089518B817B81F921F921F920895FFCF38
-:10FE100084B714BE90E083709070892B39F418B8C1
-:10FE200017B81F921F921F920895FFCF88E1809309
-:10FE3000C10060E07EE38EEF9FEF0E94CFFE0E9444
-:10FE400007FC18B817B81F921F921F920895FFCF92
-:10FE500020E030E040E050E013C02F5F3F4F4F4FB5
-:10FE60005F4F21308AE6380788E1480780E058076D
-:10FE700039F418B817B81F921F921F920895FFCF38
-:10FE80008091C00087FFE9CF0E94C0FE0895A1E2E3
-:10FE90001A2EAA1BBB1BFD010DC0AA1FBB1FEE1F04
-:10FEA000FF1FA217B307E407F50720F0A21BB30B4F
-:10FEB000E40BF50B661F771F881F991F1A9469F7CB
-:10FEC00060957095809590959B01AC01BD01CF0127
-:02FED000089593
-:040000031000F800F1
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
deleted file mode 100644
index 5809869..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-16MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F8200088E08093C40088E18093C100EE24FF2427
-:10F8300020E0552400E010E039E0432E9BE0292E23
-:10F84000312C2C0E3D1ECFC14150504060407040C5
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983BBC1313011F0351559F52327532E6B
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008CC190E044E755E962E470E0ACCF90E061
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F099E001C096E933
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F4C01A8288E08B8381E48C8336
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DEC08A81813941F0823941F0803911F459
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0CBC091E01A8242E050E02C
-:10F99000C7C08D81882311F48EE124C0813011F01D
-:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E097C0B8
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A828AC09A8088248B81682F70E027
-:10FA100068297929933109F033C0F7EF0F3F1F07A9
-:10FA200010F0A8013FC023E0F80120935700E895AB
-:10FA300007B600FCFDCFA801D1018C9111962C9145
-:10FA400011971296D22ECC2490E08C299D2921E08A
-:10FA5000FA010C0120935700E89511244E5F5F4F87
-:10FA60006250704051F725E0F80120935700E89567
-:10FA700007B600FCFDCF81E180935700E89512C0E6
-:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
-:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
-:10FAA000460F571F1A828A0138C07A8066248B81DC
-:10FAB000A82FB0E0A629B7291A828981843191F450
-:10FAC000BD019E012D5F3F4FF80185919491F90191
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
-:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
-:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
-:10FB1000F901108204C080EC8A8342E050E090E05A
-:10FB2000FBE1F093C6008091C00086FFFCCF80917E
-:10FB3000C00080648093C0005092C6008091C000D5
-:10FB400086FFFCCF8091C00080648093C000652F49
-:10FB50005093C6008091C00086FFFCCF8091C0000A
-:10FB600080648093C000342F4093C6008091C00011
-:10FB700086FFFCCF8091C00080648093C0008EE03F
-:10FB80008093C6008091C00086FFFCCF8091C000AA
-:10FB900080648093C00025E1252523272627FE01C8
-:10FBA000319610C030813093C6008091C00086FF2E
-:10FBB000FCCF31968091C00080648093C0002327E1
-:10FBC000415050404115510569F72093C60080917E
-:10FBD000C00086FFFCCF8091C00080648093C0008D
-:10FBE000992349F4539444E755E962E470E090E0C6
-:10FBF000A0E0B0E030CE5A9881E180935700E895BC
-:10FC000011241F921F920895FFCF9981933109F417
-:10FC1000FACE9431C8F4963009F4EACE973050F415
-:10FC2000923009F46CCE933009F49BCE913009F0F8
-:10FC300072CF81CE913109F4A7CE923108F0E1CE96
-:10FC4000903109F068CF5BCE983109F4B4CE993188
-:10FC500050F4953109F4D7CE953108F426CF96317A
-:10FC600009F059CF22CF9B3109F493CE9C3120F477
-:10FC70009A3109F050CF98CE9D3109F442CE9F328F
-:06FC800009F049CFB8CFE6
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
deleted file mode 100644
index d216c65..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644-20MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F820008AE08093C40088E18093C100EE24FF2425
-:10F8300020E0552400E010E039E0432E9BE0292E23
-:10F84000312C2C0E3D1ECFC14150504060407040C5
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983BBC1313011F0351559F52327532E6B
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008CC190E041ED5AE363E570E0ACCF90E05D
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F099E001C096E933
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F4C01A8288E08B8381E48C8336
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DEC08A81813941F0823941F0803911F459
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0CBC091E01A8242E050E02C
-:10F99000C7C08D81882311F48EE124C0813011F01D
-:10F9A00089E020C086E91EC01A82E1E0F0E04092C2
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E097C0B8
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A828AC09A8088248B81682F70E027
-:10FA100068297929933109F033C0F7EF0F3F1F07A9
-:10FA200010F0A8013FC023E0F80120935700E895AB
-:10FA300007B600FCFDCFA801D1018C9111962C9145
-:10FA400011971296D22ECC2490E08C299D2921E08A
-:10FA5000FA010C0120935700E89511244E5F5F4F87
-:10FA60006250704051F725E0F80120935700E89567
-:10FA700007B600FCFDCF81E180935700E89512C0E6
-:10FA8000A801FB01D10141BD52BD4F5F5F4F8D9178
-:10FA900080BDFA9AF99AF999FECF3197A1F7A8019A
-:10FAA000460F571F1A828A0138C07A8066248B81DC
-:10FAB000A82FB0E0A629B7291A828981843191F450
-:10FAC000BD019E012D5F3F4FF80185919491F90191
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F713C0A801BD019E012D5F3F4F41BD95
-:10FAF00052BD4F5F5F4FF89A80B5F90181939F0126
-:10FB000061507040A1F70A0F1B1FAD014D5F5F4FA1
-:10FB1000F901108204C080EC8A8342E050E090E05A
-:10FB2000FBE1F093C6008091C00086FFFCCF80917E
-:10FB3000C00080648093C0005092C6008091C000D5
-:10FB400086FFFCCF8091C00080648093C000652F49
-:10FB50005093C6008091C00086FFFCCF8091C0000A
-:10FB600080648093C000342F4093C6008091C00011
-:10FB700086FFFCCF8091C00080648093C0008EE03F
-:10FB80008093C6008091C00086FFFCCF8091C000AA
-:10FB900080648093C00025E1252523272627FE01C8
-:10FBA000319610C030813093C6008091C00086FF2E
-:10FBB000FCCF31968091C00080648093C0002327E1
-:10FBC000415050404115510569F72093C60080917E
-:10FBD000C00086FFFCCF8091C00080648093C0008D
-:10FBE000992349F4539441ED5AE363E570E090E0C2
-:10FBF000A0E0B0E030CE5A9881E180935700E895BC
-:10FC000011241F921F920895FFCF9981933109F417
-:10FC1000FACE9431C8F4963009F4EACE973050F415
-:10FC2000923009F46CCE933009F49BCE913009F0F8
-:10FC300072CF81CE913109F4A7CE923108F0E1CE96
-:10FC4000903109F068CF5BCE983109F4B4CE993188
-:10FC500050F4953109F4D7CE953108F426CF96317A
-:10FC600009F059CF22CF9B3109F493CE9C3120F477
-:10FC70009A3109F050CF98CE9D3109F442CE9F328F
-:06FC800009F049CFB8CFE6
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
deleted file mode 100644
index a9105a2..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-16MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F8200088E08093C40088E18093C100EE24FF2427
-:10F8300020E0552400E010E039E0432E93E0292E2B
-:10F84000312C2C0E3D1ECDC14150504060407040C7
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983B9C1313011F0351559F52327532E6D
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008AC190E044E755E962E470E0ACCF90E063
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F09AE001C096E932
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F2C01A8288E08B8381E48C8338
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DCC08A81813941F0823941F0803911F45B
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0C9C091E01A8242E050E02E
-:10F99000C5C08D81882311F48EE124C0813011F01F
-:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E095C0BA
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A8288C09A8088248B81682F70E029
-:10FA100068297929933109F034C0F7EF0F3F1F07A8
-:10FA200010F0A80141C023E0F80120935700E895A9
-:10FA300007B600FCFDCFA801DE011B968C91119644
-:10FA40002C9111971296D22ECC2490E08C299D29CE
-:10FA500021E0FA010C0120935700E89511244E5F34
-:10FA60005F4F6250704051F725E0F8012093570036
-:10FA7000E89507B600FCFDCF81E180935700E8953B
-:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
-:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
-:10FAA000A1F7A801460F571F1A828A0134C07A8035
-:10FAB00066248B81A82FB0E0A629B7291A828981F4
-:10FAC000843181F4BD019101F80185919491F9018E
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F711C0A801BD01910141BD52BD4F5F01
-:10FAF0005F4FF89A80B5F90181939F016150704082
-:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
-:10FB100004C080EC8A8342E050E090E0FBE1F09387
-:10FB2000C6008091C00086FFFCCF8091C000806439
-:10FB30008093C0005092C6008091C00086FFFCCF29
-:10FB40008091C00080648093C000652F5093C600F0
-:10FB50008091C00086FFFCCF8091C00080648093BC
-:10FB6000C000342F4093C6008091C00086FFFCCFB8
-:10FB70008091C00080648093C0008EE08093C600B6
-:10FB80008091C00086FFFCCF8091C000806480938C
-:10FB9000C00025E1252523272627FE01319610C028
-:10FBA00030813093C6008091C00086FFFCCF319633
-:10FBB0008091C00080648093C00023274150504052
-:10FBC0004115510569F72093C6008091C00086FF5A
-:10FBD000FCCF8091C00080648093C000992349F4D9
-:10FBE000539444E755E962E470E090E0A0E0B0E0AF
-:10FBF00032CE5A9881E180935700E89511241F92E4
-:10FC00001F920895FFCF9981933109F4FCCE94316E
-:10FC1000C8F4963009F4ECCE973050F4923009F4E1
-:10FC20006ECE933009F49DCE913009F072CF83CE21
-:10FC3000913109F4A9CE923108F0E3CE903109F068
-:10FC400068CF5DCE983109F4B6CE993150F4953134
-:10FC500009F4D9CE953108F42ACF963109F059CF5D
-:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
-:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
-:02FC8000B8CFFB
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex b/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
deleted file mode 100644
index 4ee0c6b..0000000
--- a/Marlin/Gen7/bootloaders/Gen7/bootloader-644P-20MHz.hex
+++ /dev/null
@@ -1,75 +0,0 @@
-:10F800008FEF90E19EBF8DBF11241FBE5A9A00C09A
-:10F81000CDB7DEB7CD51D140DEBFCDBF1092C50010
-:10F820008AE08093C40088E18093C100EE24FF2425
-:10F8300020E0552400E010E039E0432E93E0292E2B
-:10F84000312C2C0E3D1ECDC14150504060407040C7
-:10F8500011F43FE206C08091C00087FFF5CF3091E0
-:10F86000C600933021F1943028F4913099F0923011
-:10F87000C8F407C0953049F1953000F19630D1F5C4
-:10F8800035C03B3119F491E02BE134C03F3291F5A2
-:10F890003983B9C1313011F0351559F52327532E6D
-:10F8A00092E028C0B32FA0E0232793E023C0832F4A
-:10F8B00090E0A82BB92B232794E01CC03E30C9F45C
-:10F8C000232795E0EE24FF2415C0E1E0F0E0EC0FE3
-:10F8D000FD1FEE0DFF1D30830894E11CF11C232752
-:10F8E000EA16FB0639F4D70196E004C0321709F492
-:10F8F0008AC190E041ED5AE363E570E0ACCF90E05F
-:10F9000044C08D81803311F090E00AC08F8188233C
-:10F9100011F49EE105C0813011F09AE001C096E932
-:10F920001A821B828D818C838E818D839E831F82A0
-:10F9300047E050E0F2C01A8288E08B8381E48C8338
-:10F9400086E58D8382E58E8389E48F8383E58887CE
-:10F9500080E589878FE58A8782E38B874BE050E0DB
-:10F96000DCC08A81813941F0823941F0803911F45B
-:10F970008FE005C080E003C082E001C08AE01A8207
-:10F980008B8343E050E0C9C091E01A8242E050E02E
-:10F99000C5C08D81882311F48EE124C0813011F01F
-:10F9A0008AE020C086E91EC01A82E1E0F0E04092C1
-:10F9B0005700849118C08B81803579F48C81883010
-:10F9C00031F4E2E0F0E04092570084910BC0E0E0B7
-:10F9D000F0E040925700849105C0E3E0F0E04092EF
-:10F9E000570084911A828B831C8244E050E095C0BA
-:10F9F000BC80AA248D81082F10E00A291B29000F42
-:10FA0000111F1A8288C09A8088248B81682F70E029
-:10FA100068297929933109F034C0F7EF0F3F1F07A8
-:10FA200010F0A80141C023E0F80120935700E895A9
-:10FA300007B600FCFDCFA801DE011B968C91119644
-:10FA40002C9111971296D22ECC2490E08C299D29CE
-:10FA500021E0FA010C0120935700E89511244E5F34
-:10FA60005F4F6250704051F725E0F8012093570036
-:10FA7000E89507B600FCFDCF81E180935700E8953B
-:10FA800013C0A801FB01DE011B9641BD52BD4F5FB3
-:10FA90005F4F8D9180BDFA9AF99AF999FECF31970F
-:10FAA000A1F7A801460F571F1A828A0134C07A8035
-:10FAB00066248B81A82FB0E0A629B7291A828981F4
-:10FAC000843181F4BD019101F80185919491F9018E
-:10FAD000808391832E5F3F4F0E5F1F4F62507040B7
-:10FAE00099F711C0A801BD01910141BD52BD4F5F01
-:10FAF0005F4FF89A80B5F90181939F016150704082
-:10FB0000A1F70A0F1B1FAD014D5F5F4FF901108276
-:10FB100004C080EC8A8342E050E090E0FBE1F09387
-:10FB2000C6008091C00086FFFCCF8091C000806439
-:10FB30008093C0005092C6008091C00086FFFCCF29
-:10FB40008091C00080648093C000652F5093C600F0
-:10FB50008091C00086FFFCCF8091C00080648093BC
-:10FB6000C000342F4093C6008091C00086FFFCCFB8
-:10FB70008091C00080648093C0008EE08093C600B6
-:10FB80008091C00086FFFCCF8091C000806480938C
-:10FB9000C00025E1252523272627FE01319610C028
-:10FBA00030813093C6008091C00086FFFCCF319633
-:10FBB0008091C00080648093C00023274150504052
-:10FBC0004115510569F72093C6008091C00086FF5A
-:10FBD000FCCF8091C00080648093C000992349F4D9
-:10FBE000539441ED5AE363E570E090E0A0E0B0E0AB
-:10FBF00032CE5A9881E180935700E89511241F92E4
-:10FC00001F920895FFCF9981933109F4FCCE94316E
-:10FC1000C8F4963009F4ECCE973050F4923009F4E1
-:10FC20006ECE933009F49DCE913009F072CF83CE21
-:10FC3000913109F4A9CE923108F0E3CE903109F068
-:10FC400068CF5DCE983109F4B6CE993150F4953134
-:10FC500009F4D9CE953108F42ACF963109F059CF5D
-:10FC600026CF9B3109F495CE9C3120F49A3109F0CE
-:10FC700050CF9ACE9D3109F444CE9F3209F049CF3E
-:02FC8000B8CFFB
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.cpp b/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index 8b1fcc6..0000000
--- a/Marlin/Gen7/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "wiring.h"
-#include "wiring_private.h"
-
-#include "HardwareSerial.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-struct ring_buffer {
-  unsigned char buffer[RX_BUFFER_SIZE];
-  int head;
-  int tail;
-};
-
-ring_buffer rx_buffer = { { 0 }, 0, 0 };
-
-#ifdef UDR1
-ring_buffer rx_buffer1 = { { 0 }, 0, 0 };
-#endif
-
-#ifdef UDR2
-ring_buffer rx_buffer2 = { { 0 }, 0, 0 };
-#endif
-#ifdef UDR3
-ring_buffer rx_buffer3 = { { 0 }, 0, 0 };
-#endif
-
-inline void store_char(unsigned char c, ring_buffer *rx_buffer)
-{
-  int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != rx_buffer->tail) {
-    rx_buffer->buffer[rx_buffer->head] = c;
-    rx_buffer->head = i;
-  }
-}
-
-ISR(USART0_RX_vect)
-{
-  unsigned char c = UDR0;
-  store_char(c, &rx_buffer);
-}
-
-#ifdef UDR1
-ISR(USART1_RX_vect)
-{
-  unsigned char c = UDR1;
-  store_char(c, &rx_buffer1);
-}
-
-#ifdef UDR2
-ISR(USART2_RX_vect)
-{
-  unsigned char c = UDR2;
-  store_char(c, &rx_buffer2);
-}
-
-#ifdef UDR2
-ISR(USART3_RX_vect)
-{
-  unsigned char c = UDR3;
-  store_char(c, &rx_buffer3);
-}
-#endif
-#endif
-
-#else
-
-#if defined(__AVR_ATmega8__)
-SIGNAL(SIG_UART_RECV)
-#else
-SIGNAL(USART_RX_vect)
-#endif
-{
-#if defined(__AVR_ATmega8__)
-  unsigned char c = UDR;
-#else
-  unsigned char c = UDR0;
-#endif
-  store_char(c, &rx_buffer);
-}
-
-#endif
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udre = udre;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x;
-
-  // U2X mode is needed for baud rates higher than (CPU Hz / 16)
-  if (baud > F_CPU / 16) {
-    use_u2x = true;
-  } else {
-    // figure out if U2X mode would allow for a better connection
-    
-    // calculate the percent difference between the baud-rate specified and
-    // the real baud rate for both U2X and non-U2X mode (0-255 error percent)
-    uint8_t nonu2x_baud_error = abs((int)(255-((F_CPU/(16*(((F_CPU/8/baud-1)/2)+1))*255)/baud)));
-    uint8_t u2x_baud_error = abs((int)(255-((F_CPU/(8*(((F_CPU/4/baud-1)/2)+1))*255)/baud)));
-    
-    // prefer non-U2X mode because it handles clock skew better
-    use_u2x = (nonu2x_baud_error > u2x_baud_error);
-  }
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-}
-
-void HardwareSerial::end()
-{
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-}
-
-uint8_t HardwareSerial::available(void)
-{
-  return (RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % RX_BUFFER_SIZE;
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (_rx_buffer->tail + 1) % RX_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-void HardwareSerial::write(uint8_t c)
-{
-  while (!((*_ucsra) & (1 << _udre)))
-    ;
-
-  *_udr = c;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-
-#if defined(__AVR_ATmega8__)
-HardwareSerial Serial(&rx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRE, U2X);
-#else
-HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
-#endif
-
-#ifdef UDR1
-HardwareSerial Serial1(&rx_buffer1, &UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UDR1, RXEN1, TXEN1, RXCIE1, UDRE1, U2X1);
-#endif
-
-#ifdef UDR2
-HardwareSerial Serial2(&rx_buffer2, &UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UDR2, RXEN2, TXEN2, RXCIE2, UDRE2, U2X2);
-#endif
-#ifdef UDR3
-HardwareSerial Serial3(&rx_buffer3, &UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UDR3, RXEN3, TXEN3, RXCIE3, UDRE3, U2X3);
-#endif
diff --git a/Marlin/Gen7/cores/arduino/HardwareSerial.h b/Marlin/Gen7/cores/arduino/HardwareSerial.h
deleted file mode 100644
index f609f73..0000000
--- a/Marlin/Gen7/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Print.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Print
-{
-  private:
-    ring_buffer *_rx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udre;
-    uint8_t _u2x;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
-    void begin(long);
-    void end();
-    uint8_t available(void);
-    int read(void);
-    void flush(void);
-    virtual void write(uint8_t);
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-};
-
-extern HardwareSerial Serial;
-
-#if defined(__AVR_ATmega644P__) || defined(__AVR_ATmega1280__)
-extern HardwareSerial Serial1;
-#endif
-
-#if defined(__AVR_ATmega1280__)
-extern HardwareSerial Serial2;
-extern HardwareSerial Serial3;
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/Makefile b/Marlin/Gen7/cores/arduino/Makefile
deleted file mode 100644
index 571687d..0000000
--- a/Marlin/Gen7/cores/arduino/Makefile
+++ /dev/null
@@ -1,243 +0,0 @@
-# Arduino 0011 Makefile
-# Arduino adaptation by mellis, eighthave, oli.keller
-#
-# This makefile allows you to build sketches from the command line
-# without the Arduino environment (or Java).
-#
-# Detailed instructions for using the makefile:
-#
-#  1. Copy this file into the folder with your sketch. There should be a
-#     file with the same name as the folder and with the extension .pde
-#     (e.g. foo.pde in the foo/ folder).
-#
-#  2. Modify the line containg "INSTALL_DIR" to point to the directory that
-#     contains the Arduino installation (for example, under Mac OS X, this
-#     might be /Applications/arduino-0012).
-#
-#  3. Modify the line containing "PORT" to refer to the filename
-#     representing the USB or serial connection to your Arduino board
-#     (e.g. PORT = /dev/tty.USB0).  If the exact name of this file
-#     changes, you can use * as a wildcard (e.g. PORT = /dev/tty.usb*).
-#
-#  4. Set the line containing "MCU" to match your board's processor. 
-#     Older one's are atmega8 based, newer ones like Arduino Mini, Bluetooth
-#     or Diecimila have the atmega168.  If you're using a LilyPad Arduino,
-#     change F_CPU to 8000000.
-#
-#  5. At the command line, change to the directory containing your
-#     program's file and the makefile.
-#
-#  6. Type "make" and press enter to compile/verify your program.
-#
-#  7. Type "make upload", reset your Arduino board, and press enter to
-#     upload your program to the Arduino board.
-#
-# $Id$
-
-TARGET = $(notdir $(CURDIR))
-INSTALL_DIR = /Users/dmellis/Source/arduino/trunk/build/macosx/build/work
-PORT = /dev/tty.usb*
-UPLOAD_RATE = 19200
-AVRDUDE_PROGRAMMER = stk500v1
-MCU = atmega168
-F_CPU = 16000000
-
-############################################################################
-# Below here nothing should be changed...
-
-ARDUINO = $(INSTALL_DIR)/hardware/cores/arduino
-AVR_TOOLS_PATH = $(INSTALL_DIR)/hardware/tools/avr/bin
-SRC =  $(ARDUINO)/pins_arduino.c $(ARDUINO)/wiring.c \
-$(ARDUINO)/wiring_analog.c $(ARDUINO)/wiring_digital.c \
-$(ARDUINO)/wiring_pulse.c $(ARDUINO)/wiring_serial.c \
-$(ARDUINO)/wiring_shift.c $(ARDUINO)/WInterrupts.c
-CXXSRC = $(ARDUINO)/HardwareSerial.cpp $(ARDUINO)/WMath.cpp
-FORMAT = ihex
-
-
-# Name of this Makefile (used for "make depend").
-MAKEFILE = Makefile
-
-# Debugging format.
-# Native formats for AVR-GCC's -g are stabs [default], or dwarf-2.
-# AVR (extended) COFF requires stabs, plus an avr-objcopy run.
-DEBUG = stabs
-
-OPT = s
-
-# Place -D or -U options here
-CDEFS = -DF_CPU=$(F_CPU)
-CXXDEFS = -DF_CPU=$(F_CPU)
-
-# Place -I options here
-CINCS = -I$(ARDUINO)
-CXXINCS = -I$(ARDUINO)
-
-# Compiler flag to set the C Standard level.
-# c89   - "ANSI" C
-# gnu89 - c89 plus GCC extensions
-# c99   - ISO C99 standard (not yet fully implemented)
-# gnu99 - c99 plus GCC extensions
-CSTANDARD = -std=gnu99
-CDEBUG = -g$(DEBUG)
-CWARN = -Wall -Wstrict-prototypes
-CTUNING = -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
-#CEXTRA = -Wa,-adhlns=$(<:.c=.lst)
-
-CFLAGS = $(CDEBUG) $(CDEFS) $(CINCS) -O$(OPT) $(CWARN) $(CSTANDARD) $(CEXTRA)
-CXXFLAGS = $(CDEFS) $(CINCS) -O$(OPT)
-#ASFLAGS = -Wa,-adhlns=$(<:.S=.lst),-gstabs 
-LDFLAGS = -lm
-
-
-# Programming support using avrdude. Settings and variables.
-AVRDUDE_PORT = $(PORT)
-AVRDUDE_WRITE_FLASH = -U flash:w:applet/$(TARGET).hex
-AVRDUDE_FLAGS = -V -F -C $(INSTALL_DIR)/hardware/tools/avr/etc/avrdude.conf \
--p $(MCU) -P $(AVRDUDE_PORT) -c $(AVRDUDE_PROGRAMMER) \
--b $(UPLOAD_RATE)
-
-# Program settings
-CC = $(AVR_TOOLS_PATH)/avr-gcc
-CXX = $(AVR_TOOLS_PATH)/avr-g++
-OBJCOPY = $(AVR_TOOLS_PATH)/avr-objcopy
-OBJDUMP = $(AVR_TOOLS_PATH)/avr-objdump
-AR  = $(AVR_TOOLS_PATH)/avr-ar
-SIZE = $(AVR_TOOLS_PATH)/avr-size
-NM = $(AVR_TOOLS_PATH)/avr-nm
-AVRDUDE = $(AVR_TOOLS_PATH)/avrdude
-REMOVE = rm -f
-MV = mv -f
-
-# Define all object files.
-OBJ = $(SRC:.c=.o) $(CXXSRC:.cpp=.o) $(ASRC:.S=.o) 
-
-# Define all listing files.
-LST = $(ASRC:.S=.lst) $(CXXSRC:.cpp=.lst) $(SRC:.c=.lst)
-
-# Combine all necessary flags and optional flags.
-# Add target processor to flags.
-ALL_CFLAGS = -mmcu=$(MCU) -I. $(CFLAGS)
-ALL_CXXFLAGS = -mmcu=$(MCU) -I. $(CXXFLAGS)
-ALL_ASFLAGS = -mmcu=$(MCU) -I. -x assembler-with-cpp $(ASFLAGS)
-
-
-# Default target.
-all: applet_files build sizeafter
-
-build: elf hex 
-
-applet_files: $(TARGET).pde
-	# Here is the "preprocessing".
-	# It creates a .cpp file based with the same name as the .pde file.
-	# On top of the new .cpp file comes the WProgram.h header.
-	# At the end there is a generic main() function attached.
-	# Then the .cpp file will be compiled. Errors during compile will
-	# refer to this new, automatically generated, file. 
-	# Not the original .pde file you actually edit...
-	test -d applet || mkdir applet
-	echo '#include "WProgram.h"' > applet/$(TARGET).cpp
-	cat $(TARGET).pde >> applet/$(TARGET).cpp
-	cat $(ARDUINO)/main.cxx >> applet/$(TARGET).cpp
-
-elf: applet/$(TARGET).elf
-hex: applet/$(TARGET).hex
-eep: applet/$(TARGET).eep
-lss: applet/$(TARGET).lss 
-sym: applet/$(TARGET).sym
-
-# Program the device.  
-upload: applet/$(TARGET).hex
-	$(AVRDUDE) $(AVRDUDE_FLAGS) $(AVRDUDE_WRITE_FLASH)
-
-
-	# Display size of file.
-HEXSIZE = $(SIZE) --target=$(FORMAT) applet/$(TARGET).hex
-ELFSIZE = $(SIZE)  applet/$(TARGET).elf
-sizebefore:
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_BEFORE); $(HEXSIZE); echo; fi
-
-sizeafter:
-	@if [ -f applet/$(TARGET).elf ]; then echo; echo $(MSG_SIZE_AFTER); $(HEXSIZE); echo; fi
-
-
-# Convert ELF to COFF for use in debugging / simulating in AVR Studio or VMLAB.
-COFFCONVERT=$(OBJCOPY) --debugging \
---change-section-address .data-0x800000 \
---change-section-address .bss-0x800000 \
---change-section-address .noinit-0x800000 \
---change-section-address .eeprom-0x810000 
-
-
-coff: applet/$(TARGET).elf
-	$(COFFCONVERT) -O coff-avr applet/$(TARGET).elf $(TARGET).cof
-
-
-extcoff: $(TARGET).elf
-	$(COFFCONVERT) -O coff-ext-avr applet/$(TARGET).elf $(TARGET).cof
-
-
-.SUFFIXES: .elf .hex .eep .lss .sym
-
-.elf.hex:
-	$(OBJCOPY) -O $(FORMAT) -R .eeprom $< $@
-
-.elf.eep:
-	-$(OBJCOPY) -j .eeprom --set-section-flags=.eeprom="alloc,load" \
-	--change-section-lma .eeprom=0 -O $(FORMAT) $< $@
-
-# Create extended listing file from ELF output file.
-.elf.lss:
-	$(OBJDUMP) -h -S $< > $@
-
-# Create a symbol table from ELF output file.
-.elf.sym:
-	$(NM) -n $< > $@
-
-	# Link: create ELF output file from library.
-applet/$(TARGET).elf: $(TARGET).pde applet/core.a 
-	$(CC) $(ALL_CFLAGS) -o $@ applet/$(TARGET).cpp -L. applet/core.a $(LDFLAGS)
-
-applet/core.a: $(OBJ)
-	@for i in $(OBJ); do echo $(AR) rcs applet/core.a $$i; $(AR) rcs applet/core.a $$i; done
-
-
-
-# Compile: create object files from C++ source files.
-.cpp.o:
-	$(CXX) -c $(ALL_CXXFLAGS) $< -o $@ 
-
-# Compile: create object files from C source files.
-.c.o:
-	$(CC) -c $(ALL_CFLAGS) $< -o $@ 
-
-
-# Compile: create assembler files from C source files.
-.c.s:
-	$(CC) -S $(ALL_CFLAGS) $< -o $@
-
-
-# Assemble: create object files from assembler source files.
-.S.o:
-	$(CC) -c $(ALL_ASFLAGS) $< -o $@
-
-
-
-# Target: clean project.
-clean:
-	$(REMOVE) applet/$(TARGET).hex applet/$(TARGET).eep applet/$(TARGET).cof applet/$(TARGET).elf \
-	applet/$(TARGET).map applet/$(TARGET).sym applet/$(TARGET).lss applet/core.a \
-	$(OBJ) $(LST) $(SRC:.c=.s) $(SRC:.c=.d) $(CXXSRC:.cpp=.s) $(CXXSRC:.cpp=.d)
-
-depend:
-	if grep '^# DO NOT DELETE' $(MAKEFILE) >/dev/null; \
-	then \
-		sed -e '/^# DO NOT DELETE/,$$d' $(MAKEFILE) > \
-			$(MAKEFILE).$$$$ && \
-		$(MV) $(MAKEFILE).$$$$ $(MAKEFILE); \
-	fi
-	echo '# DO NOT DELETE THIS LINE -- make depend depends on it.' \
-		>> $(MAKEFILE); \
-	$(CC) -M -mmcu=$(MCU) $(CDEFS) $(CINCS) $(SRC) $(ASRC) >> $(MAKEFILE)
-
-.PHONY:	all build elf hex eep lss sym program coff extcoff clean depend applet_files sizebefore sizeafter
diff --git a/Marlin/Gen7/cores/arduino/Print.cpp b/Marlin/Gen7/cores/arduino/Print.cpp
deleted file mode 100644
index d4833da..0000000
--- a/Marlin/Gen7/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-#include "wiring.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void Print::print(uint8_t b)
-{
-  this->write(b);
-}
-
-void Print::print(char c)
-{
-  print((byte) c);
-}
-
-void Print::print(const char c[])
-{
-  while (*c)
-    print(*c++);
-}
-
-void Print::print(int n)
-{
-  print((long) n);
-}
-
-void Print::print(unsigned int n)
-{
-  print((unsigned long) n);
-}
-
-void Print::print(long n)
-{
-  if (n < 0) {
-    print('-');
-    n = -n;
-  }
-  printNumber(n, 10);
-}
-
-void Print::print(unsigned long n)
-{
-  printNumber(n, 10);
-}
-
-void Print::print(long n, int base)
-{
-  if (base == 0)
-    print((char) n);
-  else if (base == 10)
-    print(n);
-  else
-    printNumber(n, base);
-}
-
-void Print::print(double n)
-{
-  printFloat(n, 2);
-}
-
-void Print::println(void)
-{
-  print('\r');
-  print('\n');  
-}
-
-void Print::println(char c)
-{
-  print(c);
-  println();  
-}
-
-void Print::println(const char c[])
-{
-  print(c);
-  println();
-}
-
-void Print::println(uint8_t b)
-{
-  print(b);
-  println();
-}
-
-void Print::println(int n)
-{
-  print(n);
-  println();
-}
-
-void Print::println(unsigned int n)
-{
-  print(n);
-  println();
-}
-
-void Print::println(long n)
-{
-  print(n);
-  println();  
-}
-
-void Print::println(unsigned long n)
-{
-  print(n);
-  println();  
-}
-
-void Print::println(long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(double n)
-{
-  print(n);
-  println();
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-void Print::printNumber(unsigned long n, uint8_t base)
-{
-  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
-  unsigned long i = 0;
-
-  if (n == 0) {
-    print('0');
-    return;
-  } 
-
-  while (n > 0) {
-    buf[i++] = n % base;
-    n /= base;
-  }
-
-  for (; i > 0; i--)
-    print((char) (buf[i - 1] < 10 ?
-      '0' + buf[i - 1] :
-      'A' + buf[i - 1] - 10));
-}
-
-void Print::printFloat(double number, uint8_t digits) 
-{ 
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0)
-    print("."); 
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    print(toPrint);
-    remainder -= toPrint; 
-  } 
-}
diff --git a/Marlin/Gen7/cores/arduino/Print.h b/Marlin/Gen7/cores/arduino/Print.h
deleted file mode 100644
index c95a0dc..0000000
--- a/Marlin/Gen7/cores/arduino/Print.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-#define BYTE 0
-
-class Print
-{
-  private:
-    void printNumber(unsigned long, uint8_t);
-    void printFloat(double, uint8_t);
-  public:
-    virtual void write(uint8_t);
-    void print(char);
-    void print(const char[]);
-    void print(uint8_t);
-    void print(int);
-    void print(unsigned int);
-    void print(long);
-    void print(unsigned long);
-    void print(long, int);
-    void print(double);
-    void println(void);
-    void println(char);
-    void println(const char[]);
-    void println(uint8_t);
-    void println(int);
-    void println(unsigned int);
-    void println(long);
-    void println(unsigned long);
-    void println(long, int);
-    void println(double);
-};
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/Tone.cpp b/Marlin/Gen7/cores/arduino/Tone.cpp
deleted file mode 100644
index 827fe49..0000000
--- a/Marlin/Gen7/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,515 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <wiring.h>
-#include <pins_arduino.h>
-
-#if defined(__AVR_ATmega8__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(__AVR_ATmega1280__)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-#if defined(__AVR_ATmega1280__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#else
-
-#define AVAILABLE_TONE_PINS 1
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-#if !defined(__AVR_ATmega8__)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-#endif
-
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-
-#if defined(__AVR_ATmega1280__)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        bitWrite(TCCR4B, WGM42, 1);
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-#endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if !defined(__AVR_ATmega8__)
-      if (_timer == 0)
-        TCCR0B = prescalarbits;
-      else
-#endif
-        TCCR2B = prescalarbits;
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#if defined(__AVR_ATmega1280__)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if !defined(__AVR_ATmega8__)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-        break;
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-
-#if defined(__AVR_ATmega1280__)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  switch (_timer)
-  {
-#if defined(__AVR_ATmega8__)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-    case 2:
-      bitWrite(TIMSK2, OCIE2A, 0);
-      break;
-
-#else
-    case 0:
-      TIMSK0 = 0;
-      break;
-    case 1:
-      TIMSK1 = 0;
-      break;
-    case 2:
-      TIMSK2 = 0;
-      break;
-#endif
-
-#if defined(__AVR_ATmega1280__)
-    case 3:
-      TIMSK3 = 0;
-      break;
-    case 4:
-      TIMSK4 = 0;
-      break;
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-
-  digitalWrite(_pin, 0);
-}
-
-#if 0
-#if !defined(__AVR_ATmega8__)
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    TIMSK0 = 0;   // disable the interrupt
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    TIMSK1 = 0;   // disable the interrupt
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    TIMSK2 = 0;   // disable the interrupt
-    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-
-
-
-//#if defined(__AVR_ATmega1280__)
-#if 0
-
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    TIMSK3 = 0;   // disable the interrupt
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    TIMSK4 = 0;   // disable the interrupt
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    TIMSK5 = 0;   // disable the interrupt
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/WCharacter.h b/Marlin/Gen7/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/Marlin/Gen7/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Gen7/cores/arduino/WConstants.h b/Marlin/Gen7/cores/arduino/WConstants.h
deleted file mode 100644
index 3e19ac4..0000000
--- a/Marlin/Gen7/cores/arduino/WConstants.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "wiring.h"
diff --git a/Marlin/Gen7/cores/arduino/WInterrupts.c b/Marlin/Gen7/cores/arduino/WInterrupts.c
deleted file mode 100644
index 6f3f0b1..0000000
--- a/Marlin/Gen7/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "WConstants.h"
-#include "wiring_private.h"
-
-volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode)
-{
-	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
-	{
-		intFunc[interruptNum] = userFunc;
-
-		//clear the config for the change settings
-		EICRA &= ~(B00000011 << (interruptNum * 2));
-
-		//set our mode.
-		EICRA |= (mode << (interruptNum * 2));
-
-		// Enable the interrupt.
-		EIMSK |= (1 << interruptNum);
-	}
-}
-
-void detachInterrupt(uint8_t interruptNum)
-{
-	if(interruptNum < EXTERNAL_NUM_INTERRUPTS)
-	{
-		// Disable the interrupt.
-		EIMSK &= ~(1 << interruptNum);
-
-		intFunc[interruptNum] = 0;
-	}
-}
-
-ISR(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-ISR(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-ISR(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/Marlin/Gen7/cores/arduino/WMath.cpp b/Marlin/Gen7/cores/arduino/WMath.cpp
deleted file mode 100644
index 7a230f5..0000000
--- a/Marlin/Gen7/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0){
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
diff --git a/Marlin/Gen7/cores/arduino/WProgram.h b/Marlin/Gen7/cores/arduino/WProgram.h
deleted file mode 100644
index 2c7ed16..0000000
--- a/Marlin/Gen7/cores/arduino/WProgram.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef WProgram_h
-#define WProgram_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/interrupt.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/WString.cpp b/Marlin/Gen7/cores/arduino/WString.cpp
deleted file mode 100644
index db5a441..0000000
--- a/Marlin/Gen7/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <stdlib.h>
-#include "WProgram.h"
-#include "WString.h"
-
-
-String::String( const char *value )
-{
-  if ( value == NULL )
-    value = "";
-  getBuffer( _length = strlen( value ) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value );
-}
-
-String::String( const String &value )
-{
-  getBuffer( _length = value._length );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value._buffer );
-}
-
-String::String( const char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL ) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const unsigned char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const int value, const int base )
-{
-  char buf[33];   
-  itoa((signed long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned int value, const int base )
-{
-  char buf[33];   
-  ultoa((unsigned long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const long value, const int base )
-{
-  char buf[33];   
-  ltoa(value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned long value, const int base )
-{
-  char buf[33];   
-  ultoa(value, buf, 10);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-char String::charAt( unsigned int loc ) const
-{
-  return operator[]( loc );
-}
-
-void String::setCharAt( unsigned int loc, const char aChar ) 
-{
-  if(_buffer == NULL) return;
-  if(_length > loc) {
-    _buffer[loc] = aChar;
-  }
-}
-
-int String::compareTo( const String &s2 ) const
-{
-  return strcmp( _buffer, s2._buffer );
-}
-
-const String & String::concat( const String &s2 )
-{
-  return (*this) += s2;
-}
-
-const String & String::operator=( const String &rhs )
-{
-  if ( this == &rhs )
-    return *this;
-
-  if ( rhs._length > _length )
-  {
-    free(_buffer);
-    getBuffer( rhs._length );
-  }
-  
-  if ( _buffer != NULL ) {
-    _length = rhs._length;
-    strcpy( _buffer, rhs._buffer );
-  }
-  return *this;
-}
-
-//const String & String::operator+=( const char aChar )
-//{
-//  if ( _length == _capacity )
-//    doubleBuffer();
-//
-//  _buffer[ _length++ ] = aChar;
-//  _buffer[ _length ] = '\0';
-//  return *this;
-//}
-
-const String & String::operator+=( const String &other )
-{
-  _length += other._length;
-  if ( _length > _capacity )
-  {
-    char *temp = (char *)realloc(_buffer, _length + 1);
-    if ( temp != NULL ) {
-      _buffer = temp;
-      _capacity = _length;
-    } else {
-      _length -= other._length;
-      return *this;
-    }
-  }
-  strcat( _buffer, other._buffer );
-  return *this;
-}
-
-
-int String::operator==( const String &rhs ) const
-{
-  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
-}
-
-int String::operator!=( const String &rhs ) const
-{
-  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
-}
-
-int String::operator<( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) < 0;
-}
-
-int String::operator>( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) > 0;
-}
-
-int String::operator<=( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) <= 0;
-}
-
-int String::operator>=( const String & rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) >= 0;
-}
-
-char & String::operator[]( unsigned int index )
-{
-  static char dummy_writable_char;
-  if (index >= _length || !_buffer) {
-    dummy_writable_char = 0;
-    return dummy_writable_char;
-  }
-  return _buffer[ index ];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-  // need to check for valid index, to do later
-  return _buffer[ index ];
-}
-
-boolean String::endsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
-}
-
-boolean String::equals( const String &s2 ) const
-{
-  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
-}
-
-boolean String::equalsIgnoreCase( const String &s2 ) const
-{
-  if ( this == &s2 )
-    return true; //1;
-  else if ( _length != s2._length )
-    return false; //0;
-
-  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
-}
-
-String String::replace( char findChar, char replaceChar )
-{
-  if ( _buffer == NULL ) return *this;
-  String theReturn = _buffer;
-  char* temp = theReturn._buffer;
-  while( (temp = strchr( temp, findChar )) != 0 )
-    *temp = replaceChar;
-
-  return theReturn;
-}
-
-String String::replace( const String& match, const String& replace )
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer, newString;
-
-  int loc;
-  while ( (loc = temp.indexOf( match )) != -1 )
-  {
-    newString += temp.substring( 0, loc );
-    newString += replace;
-    temp = temp.substring( loc + match._length );
-  }
-  newString += temp;  
-  return newString;
-}
-
-int String::indexOf( char temp ) const
-{
-  return indexOf( temp, 0 );
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char* temp = strchr( &_buffer[fromIndex], ch );
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::indexOf( const String &s2 ) const
-{
-  return indexOf( s2, 0 );
-}
-
-int String::indexOf( const String &s2, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
-
-  if ( theFind == NULL )
-    return -1;
-
-  return theFind - _buffer; // pointer subtraction
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-  return lastIndexOf( theChar, _length - 1 );
-}
-
-int String::lastIndexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  char tempchar = _buffer[fromIndex + 1];
-  _buffer[fromIndex + 1] = '\0';
-  char* temp = strrchr( _buffer, ch );
-  _buffer[fromIndex + 1] = tempchar;
-
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::lastIndexOf( const String &s2 ) const
-{
-  return lastIndexOf( s2, _length - s2._length );
-}
-
-int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
-{
-  // check for empty strings
-  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
-    return -1;
-
-  // matching first character
-  char temp = s2[ 0 ];
-
-  for ( int i = fromIndex; i >= 0; i-- )
-  {
-    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
-    return i;
-  }
-  return -1;
-}
-
-boolean String::startsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return startsWith( s2, 0 );
-}
-
-boolean String::startsWith( const String &s2, unsigned int offset ) const
-{
-  if ( offset > _length - s2._length )
-    return 0;
-
-  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
-}
-
-String String::substring( unsigned int left ) const
-{
-  return substring( left, _length );
-}
-
-String String::substring( unsigned int left, unsigned int right ) const
-{
-  if ( left > right )
-  {
-    int temp = right;
-    right = left;
-    left = temp;
-  }
-
-  if ( right > _length )
-  {
-    right = _length;
-  } 
-
-  char temp = _buffer[ right ];  // save the replaced character
-  _buffer[ right ] = '\0';	
-  String outPut = ( _buffer + left );  // pointer arithmetic
-  _buffer[ right ] = temp;  //restore character
-  return outPut;
-}
-
-String String::toLowerCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::toUpperCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::trim() const
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer;
-  unsigned int i,j;
-
-  for ( i = 0; i < _length; i++ )
-  {
-    if ( !isspace(_buffer[i]) )
-      break;
-  }
-
-  for ( j = temp._length - 1; j > i; j-- )
-  {
-    if ( !isspace(_buffer[j]) )
-      break;
-  }
-
-  return temp.substring( i, j + 1);
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy((char *)buf, _buffer, len);
-  buf[len] = 0;
-}
-
-void String::toCharArray(char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy(buf, _buffer, len);
-  buf[len] = 0;
-}
-
-
-long String::toInt() {
-  return atol(_buffer);
-}
diff --git a/Marlin/Gen7/cores/arduino/WString.h b/Marlin/Gen7/cores/arduino/WString.h
deleted file mode 100644
index cadddb9..0000000
--- a/Marlin/Gen7/cores/arduino/WString.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_h
-#define String_h
-
-//#include "WProgram.h"
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-class String
-{
-  public:
-    // constructors
-    String( const char *value = "" );
-    String( const String &value );
-    String( const char );
-    String( const unsigned char );
-    String( const int, const int base=10);
-    String( const unsigned int, const int base=10 );
-    String( const long, const int base=10 );
-    String( const unsigned long, const int base=10 );
-    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
-
-    // operators
-    const String & operator = ( const String &rhs );
-    const String & operator +=( const String &rhs );
-    //const String & operator +=( const char );
-    int operator ==( const String &rhs ) const;
-    int	operator !=( const String &rhs ) const;
-    int	operator < ( const String &rhs ) const;
-    int	operator > ( const String &rhs ) const;
-    int	operator <=( const String &rhs ) const;
-    int	operator >=( const String &rhs ) const;
-    char operator []( unsigned int index ) const;
-    char& operator []( unsigned int index );
-    //operator const char *() const { return _buffer; }
-    
-    // general methods
-    char charAt( unsigned int index ) const;
-    int	compareTo( const String &anotherString ) const;
-    unsigned char endsWith( const String &suffix ) const;
-    unsigned char equals( const String &anObject ) const;
-    unsigned char equalsIgnoreCase( const String &anotherString ) const;
-    int	indexOf( char ch ) const;
-    int	indexOf( char ch, unsigned int fromIndex ) const;
-    int	indexOf( const String &str ) const;
-    int	indexOf( const String &str, unsigned int fromIndex ) const;
-    int	lastIndexOf( char ch ) const;
-    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
-    int	lastIndexOf( const String &str ) const;
-    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
-    const unsigned int length( ) const { return _length; }
-    void setCharAt(unsigned int index, const char ch);
-    unsigned char startsWith( const String &prefix ) const;
-    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
-    String substring( unsigned int beginIndex ) const;
-    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-    String toLowerCase( ) const;
-    String toUpperCase( ) const;
-    String trim( ) const;
-    void getBytes(unsigned char *buf, unsigned int bufsize);
-    void toCharArray(char *buf, unsigned int bufsize);
-    long toInt( );
-    const String& concat( const String &str );
-    String replace( char oldChar, char newChar );
-    String replace( const String& match, const String& replace );
-    friend String operator + ( String lhs, const String &rhs );
-
-  protected:
-    char *_buffer;	     // the actual char array
-    unsigned int _capacity;  // the array length minus one (for the '\0')
-    unsigned int _length;    // the String length (not counting the '\0')
-
-    void getBuffer(unsigned int maxStrLen);
-
-  private:
-
-};
-
-// allocate buffer space
-inline void String::getBuffer(unsigned int maxStrLen)
-{
-  _capacity = maxStrLen;
-  _buffer = (char *) malloc(_capacity + 1);
-  if (_buffer == NULL) _length = _capacity = 0;
-}
-
-inline String operator+( String lhs, const String &rhs )
-{
-  return lhs += rhs;
-}
-
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/binary.h b/Marlin/Gen7/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/Marlin/Gen7/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/main.cpp b/Marlin/Gen7/cores/arduino/main.cpp
deleted file mode 100644
index cc6e81d..0000000
--- a/Marlin/Gen7/cores/arduino/main.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <WProgram.h>
-
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Gen7/cores/arduino/main.cxx b/Marlin/Gen7/cores/arduino/main.cxx
deleted file mode 100644
index 52351e4..0000000
--- a/Marlin/Gen7/cores/arduino/main.cxx
+++ /dev/null
@@ -1,12 +0,0 @@
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.c b/Marlin/Gen7/cores/arduino/pins_arduino.c
deleted file mode 100644
index c67ab73..0000000
--- a/Marlin/Gen7/cores/arduino/pins_arduino.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-  pins_arduino.c - pin definitions for the Arduino board
-  Part of Arduino / Wiring Lite
-
-  Copyright (c) 2005 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
-*/
-
-#include <avr/io.h>
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-// On the Sanguino board, digital pins are also used
-// for the analog output (software PWM).  Analog input
-// pins are a separate set.
-
-// ATMEL ATMEGA644P / SANGUINO
-//
-//                   +---\/---+
-//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-//             RST  9|        |32  AREF
-//             VCC 10|        |31  GND 
-//             GND 11|        |30  AVCC
-//           XTAL2 12|        |29  PC7 (D 23)
-//           XTAL1 13|        |28  PC6 (D 22)
-//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-//                   +--------+
-//
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-
-// these arrays map port names (e.g. port B) to the
-// appropriate addresses for various functions (e.g. reading
-// and writing)
-const uint8_t PROGMEM port_to_mode_PGM[] =
-{
-	NOT_A_PORT,
-        (uint8_t) &DDRA,
-	(uint8_t) &DDRB,
-	(uint8_t) &DDRC,
-	(uint8_t) &DDRD,
-};
-
-const uint8_t PROGMEM port_to_output_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) &PORTA,
-	(uint8_t) &PORTB,
-	(uint8_t) &PORTC,
-	(uint8_t) &PORTD,
-};
-
-const uint8_t PROGMEM port_to_input_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) &PINA,
-	(uint8_t) &PINB,
-	(uint8_t) &PINC,
-	(uint8_t) &PIND,
-};
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] =
-{
-	PB, /* 0 */
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PD, /* 8 */
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PC, /* 16 */
-	PC,
-	PC,
-	PC,
-	PC,
-	PC,
-   	PC,
-	PC,
-	PA, /* 24 */
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA  /* 31 */
-};
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
-{
-	_BV(0), /* 0, port B */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 8, port D */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 16, port C */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(7), /* 24, port A */
-	_BV(6),
-	_BV(5),
-	_BV(4),
-	_BV(3),
-	_BV(2),
-	_BV(1),
-	_BV(0)
-};
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
-{
-	NOT_ON_TIMER, 	/* 0  - PB0 */
-	NOT_ON_TIMER, 	/* 1  - PB1 */
-	NOT_ON_TIMER, 	/* 2  - PB2 */
-	TIMER0A,     	/* 3  - PB3 */
-	TIMER0B, 		/* 4  - PB4 */
-	NOT_ON_TIMER, 	/* 5  - PB5 */
-	NOT_ON_TIMER, 	/* 6  - PB6 */
-	NOT_ON_TIMER,	/* 7  - PB7 */
-	NOT_ON_TIMER, 	/* 8  - PD0 */
-	NOT_ON_TIMER, 	/* 9  - PD1 */
-	NOT_ON_TIMER, 	/* 10 - PD2 */
-	NOT_ON_TIMER, 	/* 11 - PD3 */
-	TIMER1B,     	/* 12 - PD4 */
-	TIMER1A,     	/* 13 - PD5 */
-	TIMER2B,     	/* 14 - PD6 */
-	TIMER2A,     	/* 15 - PD7 */
-	NOT_ON_TIMER, 	/* 16 - PC0 */
-	NOT_ON_TIMER,   /* 17 - PC1 */
-	NOT_ON_TIMER,   /* 18 - PC2 */
-	NOT_ON_TIMER,   /* 19 - PC3 */
-	NOT_ON_TIMER,   /* 20 - PC4 */
-	NOT_ON_TIMER,   /* 21 - PC5 */
-	NOT_ON_TIMER,   /* 22 - PC6 */
-	NOT_ON_TIMER,   /* 23 - PC7 */
-	NOT_ON_TIMER,   /* 24 - PA0 */
-	NOT_ON_TIMER,   /* 25 - PA1 */
-	NOT_ON_TIMER,   /* 26 - PA2 */
-	NOT_ON_TIMER,   /* 27 - PA3 */
-	NOT_ON_TIMER,   /* 28 - PA4 */
-	NOT_ON_TIMER,   /* 29 - PA5 */
-	NOT_ON_TIMER,   /* 30 - PA6 */
-	NOT_ON_TIMER   /* 31 - PA7 */
-};
diff --git a/Marlin/Gen7/cores/arduino/pins_arduino.h b/Marlin/Gen7/cores/arduino/pins_arduino.h
deleted file mode 100644
index e0b7add..0000000
--- a/Marlin/Gen7/cores/arduino/pins_arduino.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-extern const uint8_t PROGMEM port_to_mode_PGM[];
-extern const uint8_t PROGMEM port_to_input_PGM[];
-extern const uint8_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_byte( port_to_mode_PGM + (P))) )
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring.c b/Marlin/Gen7/cores/arduino/wiring.c
deleted file mode 100644
index 1a102ae..0000000
--- a/Marlin/Gen7/cores/arduino/wiring.c
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 388 2008-03-08 22:05:23Z mellis $
-*/
-
-#include "wiring_private.h"
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_clock_cycles = 0;
-volatile unsigned long timer0_millis = 0;
-
-SIGNAL(TIMER0_OVF_vect)
-{
-	timer0_overflow_count++;
-	// timer 0 prescale factor is 64 and the timer overflows at 256
-	timer0_clock_cycles += 64UL * 256UL;
-	while (timer0_clock_cycles > clockCyclesPerMicrosecond() * 1000UL) {
-		timer0_clock_cycles -= clockCyclesPerMicrosecond() * 1000UL;
-		timer0_millis++;
-	}
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-	
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of the timer0_millis++)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-	
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m, t;
-	uint8_t oldSREG = SREG;
-	
-	cli();	
-	t = TCNT0;
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t == 0))
-		t = 256;
-#else
-	if ((TIFR & _BV(TOV0)) && (t == 0))
-		t = 256;
-#endif
-
-	m = timer0_overflow_count;
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	unsigned long start = millis();
-	
-	while (millis() - start <= ms)
-		;
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. 
- * Disables interrupts, which will disrupt the millis() function if used
- * too frequently. */
-void delayMicroseconds(unsigned int us)
-{
-	uint8_t oldSREG;
-
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-
-#if F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// disable interrupts, otherwise the timer 0 overflow interrupt that
-	// tracks milliseconds will make us delay longer than we want.
-	oldSREG = SREG;
-	cli();
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-
-	// reenable interrupts.
-	SREG = oldSREG;
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-
-	// set timer 0 prescale factor to 64
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-
-	// enable timer 0 overflow interrupt
-	sbi(TIMSK0, TOIE0);
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-	// set timer 1 prescale factor to 64
-	sbi(TCCR1B, CS11);
-	sbi(TCCR1B, CS10);
-
-	// put timer 1 in 8-bit phase correct pwm mode
-	sbi(TCCR1A, WGM10);
-
-	// set timer 2 prescale factor to 64
-	sbi(TCCR2B, CS22);
-
-	// configure timer 2 for phase correct pwm (8-bit)
-	sbi(TCCR2A, WGM20);
-
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-	UCSR0B = 0;
-	#if defined(__AVR_ATmega644P__)
-	//TODO: test to see if disabling this helps?
-	//UCSR1B = 0;
-	#endif
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring.h b/Marlin/Gen7/cores/arduino/wiring.h
deleted file mode 100644
index 48ff04a..0000000
--- a/Marlin/Gen7/cores/arduino/wiring.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 387 2008-03-08 21:30:00Z mellis $
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <avr/io.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.14159265
-#define HALF_PI 1.57079
-#define TWO_PI 6.283185
-#define DEG_TO_RAD 0.01745329
-#define RAD_TO_DEG 57.2957786
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#define INTERNAL 3
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#if __AVR_LIBC_VERSION__ < 10701UL
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#endif
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( (a) / clockCyclesPerMicrosecond() )
-#define microsecondsToClockCycles(a) ( (a) * clockCyclesPerMicrosecond() )
-
-#define lowByte(w) ((w) & 0xff)
-#define highByte(w) ((w) >> 8)
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-typedef unsigned int word;
-
-#define bit(b) (1 << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-void beginSerial(uint8_t, long);
-void serialWrite(uint8_t, unsigned char);
-int serialAvailable(uint8_t);
-int serialRead(uint8_t);
-void serialFlush(uint8_t);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_analog.c b/Marlin/Gen7/cores/arduino/wiring_analog.c
deleted file mode 100644
index b98bb1a..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high, ch = analogInPinToBit(pin);
-
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-	// the final AND is to clear the pos/neg reference bits
-	ADMUX = ((analog_reference << 6) | (pin & 0x0f)) & B11000111;
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low = ADCL;
-	high = ADCH;
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	
-	if (digitalPinToTimer(pin) == TIMER1A) {
-		// connect pwm to pin on timer 1, channel A
-		sbi(TCCR1A, COM1A1);
-		// set pwm duty
-		OCR1A = val;
-	} else if (digitalPinToTimer(pin) == TIMER1B) {
-		// connect pwm to pin on timer 1, channel B
-		sbi(TCCR1A, COM1B1);
-		// set pwm duty
-		OCR1B = val;
-	} else if (digitalPinToTimer(pin) == TIMER0A) {
-		// connect pwm to pin on timer 0, channel A
-		sbi(TCCR0A, COM0A1);
-		// set pwm duty
-		OCR0A = val;	
-	} else if (digitalPinToTimer(pin) == TIMER0B) {
-		// connect pwm to pin on timer 0, channel B
-		sbi(TCCR0A, COM0B1);
-		// set pwm duty
-		OCR0B = val;
-	} else if (digitalPinToTimer(pin) == TIMER2A) {
-		// connect pwm to pin on timer 2, channel A
-		sbi(TCCR2A, COM2A1);
-		// set pwm duty
-		OCR2A = val;	
-	} else if (digitalPinToTimer(pin) == TIMER2B) {
-		// connect pwm to pin on timer 2, channel B
-		sbi(TCCR2A, COM2B1);
-		// set pwm duty
-		OCR2B = val;
-	} else if (val < 128)
-	//fail semi-intelligently
-		digitalWrite(pin, LOW);
-	else
-		digitalWrite(pin, HIGH);
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_digital.c b/Marlin/Gen7/cores/arduino/wiring_digital.c
deleted file mode 100644
index 3d4b4eb..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-
-	if (mode == INPUT) *reg &= ~bit;
-	else *reg |= bit;
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-static inline void turnOffPWM(uint8_t timer)
-{
-	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
-	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
-	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
-	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
-	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
-	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	if (val == LOW) *out &= ~bit;
-	else *out |= bit;
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	
-	return LOW;
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_private.h b/Marlin/Gen7/cores/arduino/wiring_private.h
deleted file mode 100644
index 14394a0..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/signal.h>
-#include <avr/delay.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-
-#define EXTERNAL_NUM_INTERRUPTS 3
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_pulse.c b/Marlin/Gen7/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 8f232f1..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask)
-		width++;
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 10 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 10 + 16); 
-}
diff --git a/Marlin/Gen7/cores/arduino/wiring_serial.c b/Marlin/Gen7/cores/arduino/wiring_serial.c
deleted file mode 100644
index a3314fa..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_serial.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
-  wiring_serial.c - serial functions.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-  Modified 29 January 2009, Marius Kintel for Sanguino - http://www.sanguino.cc/
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-
-#include "wiring_private.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-#if defined(__AVR_ATmega644P__)
-unsigned char rx_buffer[2][RX_BUFFER_SIZE];
-int rx_buffer_head[2] = {0, 0};
-int rx_buffer_tail[2] = {0, 0};
-#else
-unsigned char rx_buffer[1][RX_BUFFER_SIZE];
-int rx_buffer_head[1] = {0};
-int rx_buffer_tail[1] = {0};
-#endif
-
-
-#define BEGIN_SERIAL(uart_, baud_) \
-{ \
-    UBRR##uart_##H = ((F_CPU / 16 + baud / 2) / baud - 1) >> 8; \
-    UBRR##uart_##L = ((F_CPU / 16 + baud / 2) / baud - 1); \
-    \
-    /* reset config for UART */ \
-    UCSR##uart_##A = 0; \
-    UCSR##uart_##B = 0; \
-    UCSR##uart_##C = 0; \
-    \
-    /* enable rx and tx */ \
-    sbi(UCSR##uart_##B, RXEN##uart_);\
-    sbi(UCSR##uart_##B, TXEN##uart_);\
-    \
-    /* enable interrupt on complete reception of a byte */ \
-    sbi(UCSR##uart_##B, RXCIE##uart_); \
-    UCSR##uart_##C = _BV(UCSZ##uart_##1)|_BV(UCSZ##uart_##0); \
-    /* defaults to 8-bit, no parity, 1 stop bit */ \
-}
-
-void beginSerial(uint8_t uart, long baud)
-{
-  if (uart == 0) BEGIN_SERIAL(0, baud)
-#if defined(__AVR_ATmega644P__)
-  else BEGIN_SERIAL(1, baud)
-#endif
-}
-
-#define SERIAL_WRITE(uart_, c_) \
-    while (!(UCSR##uart_##A & (1 << UDRE##uart_))) \
-      ; \
-    UDR##uart_ = c
-
-void serialWrite(uint8_t uart, unsigned char c)
-{
-  if (uart == 0) {
-    SERIAL_WRITE(0, c);
-  }
-#if defined(__AVR_ATmega644P__)
-  else {
-    SERIAL_WRITE(1, c);
-  }
-#endif
-}
-
-int serialAvailable(uint8_t uart)
-{
-  return (RX_BUFFER_SIZE + rx_buffer_head[uart] - rx_buffer_tail[uart]) % RX_BUFFER_SIZE;
-}
-
-int serialRead(uint8_t uart)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (rx_buffer_head[uart] == rx_buffer_tail[uart]) {
-    return -1;
-  } else {
-    unsigned char c = rx_buffer[uart][rx_buffer_tail[uart]];
-    rx_buffer_tail[uart] = (rx_buffer_tail[uart] + 1) % RX_BUFFER_SIZE;
-    return c;
-  }
-}
-
-void serialFlush(uint8_t uart)
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  rx_buffer_head[uart] = rx_buffer_tail[uart];
-}
-
-#define UART_ISR(uart_) \
-ISR(USART##uart_##_RX_vect) \
-{ \
-  unsigned char c = UDR##uart_; \
-  \
-  int i = (rx_buffer_head[uart_] + 1) % RX_BUFFER_SIZE; \
-  \  
-  /* if we should be storing the received character into the location \
-     just before the tail (meaning that the head would advance to the \
-     current location of the tail), we're about to overflow the buffer \
-     and so we don't write the character or advance the head. */ \
-  if (i != rx_buffer_tail[uart_]) { \
-    rx_buffer[uart_][rx_buffer_head[uart_]] = c; \
-    rx_buffer_head[uart_] = i; \
-  } \
-}
-
-UART_ISR(0)
-#if defined(__AVR_ATmega644P__) 
-UART_ISR(1)
-#endif
diff --git a/Marlin/Gen7/cores/arduino/wiring_shift.c b/Marlin/Gen7/cores/arduino/wiring_shift.c
deleted file mode 100644
index 956f864..0000000
--- a/Marlin/Gen7/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
-{
-	int i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/Marlin/Makefile b/Marlin/Makefile
index dee6ecc..930a200 100644
--- a/Marlin/Makefile
+++ b/Marlin/Makefile
@@ -173,7 +173,11 @@ F_CPU ?= 16000000
 ifeq ($(HARDWARE_VARIANT), arduino)
 HARDWARE_SRC = $(ARDUINO_INSTALL_DIR)/hardware/arduino/cores/arduino
 else
-HARDWARE_SRC = $(HARDWARE_VARIANT)/cores/arduino
+ifeq ($(shell [ $(ARDUINO_VERSION) -ge 100 ] && echo true), true)
+HARDWARE_SRC = ../ArduinoAddons/Arduino_1.x.x/$(HARDWARE_VARIANT)/cores/arduino
+else
+HARDWARE_SRC = ../ArduinoAddons/Arduino_0.xx/$(HARDWARE_VARIANT)/cores/arduino
+endif
 endif
 
 TARGET = $(notdir $(CURDIR))
diff --git a/Marlin/Sanguino/boards.txt b/Marlin/Sanguino/boards.txt
deleted file mode 100644
index 4f71b8a..0000000
--- a/Marlin/Sanguino/boards.txt
+++ /dev/null
@@ -1,16 +0,0 @@
-##############################################################
-
-sanguino.name=Sanguino
-sanguino.upload.protocol=stk500
-sanguino.upload.maximum_size=63488
-sanguino.upload.speed=38400
-sanguino.bootloader.low_fuses=0xFF
-sanguino.bootloader.high_fuses=0xDC
-sanguino.bootloader.extended_fuses=0xFD
-sanguino.bootloader.path=atmega644p
-sanguino.bootloader.file=ATmegaBOOT_644P.hex
-sanguino.bootloader.unlock_bits=0x3F
-sanguino.bootloader.lock_bits=0x0F
-sanguino.build.mcu=atmega644p
-sanguino.build.f_cpu=16000000L
-sanguino.build.core=arduino
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
deleted file mode 100644
index 1711014..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT.c
+++ /dev/null
@@ -1,713 +0,0 @@
-/**********************************************************/
-/* Serial Bootloader for Atmel megaAVR Controllers        */
-/*                                                        */
-/* tested with ATmega644 and ATmega644P                   */
-/* should work with other mega's, see code for details    */
-/*                                                        */
-/* ATmegaBOOT.c                                           */
-/*                                                        */
-/* 20090131: Added 324P support from Alex Leone           */
-/*           Marius Kintel                                */
-/* 20080915: applied ADABoot mods for Sanguino 644P       */
-/*           Brian Riley                                  */
-/* 20080711: hacked for Sanguino by Zach Smith            */
-/*           and Justin Day                               */
-/* 20070626: hacked for Arduino Diecimila (which auto-    */
-/*           resets when a USB connection is made to it)  */
-/*           by D. Mellis                                 */
-/* 20060802: hacked for Arduino by D. Cuartielles         */
-/*           based on a previous hack by D. Mellis        */
-/*           and D. Cuartielles                           */
-/*                                                        */
-/* Monitor and debug functions were added to the original */
-/* code by Dr. Erik Lins, chip45.com. (See below)         */
-/*                                                        */
-/* Thanks to Karl Pitrich for fixing a bootloader pin     */
-/* problem and more informative LED blinking!             */
-/*                                                        */
-/* For the latest version see:                            */
-/* http://www.chip45.com/                                 */
-/*                                                        */
-/* ------------------------------------------------------ */
-/*                                                        */
-/* based on stk500boot.c                                  */
-/* Copyright (c) 2003, Jason P. Kyle                      */
-/* All rights reserved.                                   */
-/* see avr1.org for original file and information         */
-/*                                                        */
-/* This program is free software; you can redistribute it */
-/* and/or modify it under the terms of the GNU General    */
-/* Public License as published by the Free Software       */
-/* Foundation; either version 2 of the License, or        */
-/* (at your option) any later version.                    */
-/*                                                        */
-/* This program is distributed in the hope that it will   */
-/* be useful, but WITHOUT ANY WARRANTY; without even the  */
-/* implied warranty of MERCHANTABILITY or FITNESS FOR A   */
-/* PARTICULAR PURPOSE.  See the GNU General Public        */
-/* License for more details.                              */
-/*                                                        */
-/* You should have received a copy of the GNU General     */
-/* Public License along with this program; if not, write  */
-/* to the Free Software Foundation, Inc.,                 */
-/* 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA */
-/*                                                        */
-/* Licence can be viewed at                               */
-/* http://www.fsf.org/licenses/gpl.txt                    */
-/*                                                        */
-/* Target = Atmel AVR m128,m64,m32,m16,m8,m162,m163,m169, */
-/* m8515,m8535. ATmega161 has a very small boot block so  */
-/* isn't supported.                                       */
-/*                                                        */
-/* Tested with m168                                       */
-/**********************************************************/
-
-/* $Id$ */
-
-
-/* some includes */
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/pgmspace.h>
-#include <avr/interrupt.h>
-#include <avr/wdt.h>
-#include <avr/boot.h>
-
-#ifdef ADABOOT
-    #define NUM_LED_FLASHES 3
-    #define ADABOOT_VER	1
-#endif
-
-
-/* 20070707: hacked by David A. Mellis - after this many errors give up and launch application */
-#define MAX_ERROR_COUNT 5
-
-/* set the UART baud rate */
-/* 20080711: hack by Zach Hoeken */
-#define BAUD_RATE   38400
-
-/* SW_MAJOR and MINOR needs to be updated from time to time to avoid warning message from AVR Studio */
-/* never allow AVR Studio to do an update !!!! */
-#define HW_VER	 0x02
-#define SW_MAJOR 0x01
-#define SW_MINOR 0x10
-
-/* onboard LED is used to indicate, that the bootloader was entered (3x flashing) */
-/* if monitor functions are included, LED goes on after monitor was entered */
-#define LED_DDR  DDRB
-#define LED_PORT PORTB
-#define LED_PIN  PINB
-#define LED      PINB0
-
-/* define various device id's */
-/* manufacturer byte is always the same */
-#define SIG1	0x1E	// Yep, Atmel is the only manufacturer of AVR micros.  Single source :(
-#if defined(__AVR_ATmega644P__)
-#define SIG2	0x96
-#define SIG3	0x0A
-#elif defined(__AVR_ATmega644__)
-#define SIG2	0x96
-#define SIG3	0x09
-#elif defined(__AVR_ATmega324P__)
-#define SIG2	0x95
-#define SIG3	0x08
-#endif
-#define PAGE_SIZE		0x080U   //128 words
-#define PAGE_SIZE_BYTES	0x100U   //256 bytes
-
-/* function prototypes */
-void putch(char);
-char getch(void);
-void getNch(uint8_t);
-void byte_response(uint8_t);
-void nothing_response(void);
-char gethex(void);
-void puthex(char);
-void flash_led(uint8_t);
-
-/* some variables */
-union address_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} address;
-
-union length_union
-{
-    uint16_t word;
-    uint8_t  byte[2];
-} length;
-
-struct flags_struct
-{
-    unsigned eeprom : 1;
-    unsigned rampz  : 1;
-} flags;
-
-uint8_t buff[256];
-
-uint8_t error_count = 0;
-uint8_t sreg;
-
-void (*app_start)(void) = 0x0000;
-
-/* main program starts here */
-int main(void)
-{
-    uint8_t ch,ch2;
-    uint16_t w;
-	uint16_t i;
-	
-    asm volatile("nop\n\t");
-
-#ifdef ADABOOT		// BBR/LF 10/8/2007 & 9/13/2008
-    ch = MCUSR;
-    MCUSR = 0;
-
-    WDTCSR |= _BV(WDCE) | _BV(WDE);
-    WDTCSR = 0;
-
-    // Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
-    if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
-      app_start();  // skip bootloader
-#endif
-
-
-	//initialize our serial port.
-    UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L)-1);
-    UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
-    UCSR0B = (1<<RXEN0) | (1<<TXEN0);
-    UCSR0C = (1<<UCSZ00) | (1<<UCSZ01);
-
-    /* Enable internal pull-up resistor on pin D0 (RX), in order
-    to supress line noise that prevents the bootloader from
-    timing out (DAM: 20070509) */
-    DDRD &= ~_BV(PIND0);
-    PORTD |= _BV(PIND0);
-
-    /* set LED pin as output */
-    LED_DDR |= _BV(LED);
-
-	    /* flash onboard LED to signal entering of bootloader                   */
-	    /* ADABOOT will do two series of flashes. first 4 - signifying ADABOOT  */
-	    /* then a pause and another flash series signifying ADABOOT sub-version */
-
-
-	flash_led(NUM_LED_FLASHES);
-
-	#ifdef	ADABOOT
-		flash_led(ADABOOT_VER);		// BBR 9/13/2008
-	#endif 
-
-    /* forever loop */
-    for (;;)
-	{
-		/* get character from UART */
-		ch = getch();
-
-		/* A bunch of if...else if... gives smaller code than switch...case ! */
-
-		/* Hello is anyone home ? */ 
-		if(ch=='0')
-		    nothing_response();
-
-
-		/* Request programmer ID */
-		/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
-		/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
-		else if(ch=='1')
-		{
-		    if (getch() == ' ')
-			{
-				putch(0x14);
-				putch('A');
-				putch('V');
-				putch('R');
-				putch(' ');
-				putch('I');
-				putch('S');
-				putch('P');
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }
-		}
-
-
-		/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
-		else if(ch=='@')
-		{
-		    ch2 = getch();
-		    if (ch2 > 0x85)
-				getch();
-		    nothing_response();
-		}
-
-
-		/* AVR ISP/STK500 board requests */
-		else if(ch=='A')
-		{
-		    ch2 = getch();
-		    if(ch2 == 0x80)
-				byte_response(HW_VER);		// Hardware version
-		    else if(ch2==0x81)
-				byte_response(SW_MAJOR);	// Software major version
-		    else if(ch2==0x82)
-				byte_response(SW_MINOR);	// Software minor version
-		    else if(ch2==0x98)
-				byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
-		    else
-				byte_response(0x00);		// Covers various unnecessary responses we don't care about
-		}
-
-
-		/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
-		else if(ch=='B')
-		{
-		    getNch(20);
-		    nothing_response();
-		}
-
-
-		/* Parallel programming stuff  DON'T CARE  */
-		else if(ch=='E')
-		{
-		    getNch(5);
-		    nothing_response();
-		}
-
-
-		/* Enter programming mode  */
-		else if(ch=='P')
-		{
-		    nothing_response();
-		}
-
-
-		/* Leave programming mode  */
-		else if(ch=='Q')
-		{
-		    nothing_response();
-#ifdef ADABOOT		
-			// autoreset via watchdog (sneaky!) BBR/LF 9/13/2008
-	  		WDTCSR = _BV(WDE);
-	  		while (1); // 16 ms
-#endif		
-		}
-
-
-		/* Erase device, don't care as we will erase one page at a time anyway.  */
-		else if(ch=='R')
-		{
-		    nothing_response();
-		}
-
-
-		/* Set address, little endian. EEPROM in bytes, FLASH in words  */
-		/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
-		/* This might explain why little endian was used here, big endian used everywhere else.  */
-		else if(ch=='U')
-		{
-		    address.byte[0] = getch();
-		    address.byte[1] = getch();
-		    nothing_response();
-		}
-
-
-		/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
-		else if(ch=='V')
-		{
-		    getNch(4);
-		    byte_response(0x00);
-		}
-
-
-		/* Write memory, length is big endian and is in bytes  */
-		else if(ch=='d')
-		{
-		    length.byte[1] = getch();
-		    length.byte[0] = getch();
-	
-		    flags.eeprom = 0;
-		    if (getch() == 'E')
-				flags.eeprom = 1;
-
-			for (i=0; i<PAGE_SIZE; i++)
-				buff[i] = 0;
-		
-		    for (w = 0; w < length.word; w++)
-			{
-				// Store data in buffer, can't keep up with serial data stream whilst programming pages
-				buff[w] = getch();
-		    }
-	
-		    if (getch() == ' ')
-			{
-				if (flags.eeprom)
-				{		                
-					//Write to EEPROM one byte at a time
-				    for(w=0;w<length.word;w++)
-					{
-						while(EECR & (1<<EEPE));
-					
-						EEAR = (uint16_t)(void *)address.word;
-						EEDR = buff[w];
-						EECR |= (1<<EEMPE);
-						EECR |= (1<<EEPE);
-
-						address.word++;
-				    }			
-				}
-				else
-				{
-					//address * 2 -> byte location
-				    address.word = address.word << 1;
-			    
-					//Even up an odd number of bytes
-					if ((length.byte[0] & 0x01))
-						length.word++;
-				
-					// HACKME: EEPE used to be EEWE
-				    //Wait for previous EEPROM writes to complete
-					//while(bit_is_set(EECR,EEPE));
-					while(EECR & (1<<EEPE));
-				
-				    asm volatile(
-						 "clr	r17		\n\t"	//page_word_count
-						 "lds	r30,address	\n\t"	//Address of FLASH location (in bytes)
-						 "lds	r31,address+1	\n\t"
-						 "ldi	r28,lo8(buff)	\n\t"	//Start of buffer array in RAM
-						 "ldi	r29,hi8(buff)	\n\t"
-						 "lds	r24,length	\n\t"	//Length of data to be written (in bytes)
-						 "lds	r25,length+1	\n\t"
-						 "length_loop:		\n\t"	//Main loop, repeat for number of words in block							 							 
-						 "cpi	r17,0x00	\n\t"	//If page_word_count=0 then erase page
-						 "brne	no_page_erase	\n\t"						 
-						 "wait_spm1:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm1       \n\t"
-						 "ldi	r16,0x03	\n\t"	//Erase page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"							 
-						 "wait_spm2:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm2       \n\t"									 
-
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"
-						 "no_page_erase:		\n\t"							 
-						 "ld	r0,Y+		\n\t"	//Write 2 bytes into page buffer
-						 "ld	r1,Y+		\n\t"							 
-							 
-						 "wait_spm3:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm3       \n\t"
-						 "ldi	r16,0x01	\n\t"	//Load r0,r1 into FLASH page buffer
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-							 
-						 "inc	r17		\n\t"	//page_word_count++
-						 "cpi r17,%1	        \n\t"
-						 "brlo	same_page	\n\t"	//Still same page in FLASH
-						 "write_page:		\n\t"
-						 "clr	r17		\n\t"	//New page, write current one first
-						 "wait_spm4:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm4       \n\t"						 							 
-						 "ldi	r16,0x05	\n\t"	//Write page pointed to by Z
-						 "sts	%0,r16		\n\t"
-						 "spm			\n\t"
-						 "wait_spm5:		\n\t"
-						 "lds	r16,%0		\n\t"	//Wait for previous spm to complete
-						 "andi	r16,1           \n\t"
-						 "cpi	r16,1           \n\t"
-						 "breq	wait_spm5       \n\t"									 
-						 "ldi	r16,0x11	\n\t"	//Re-enable RWW section
-						 "sts	%0,r16		\n\t"						 			 
-						 "spm			\n\t"					 		 
-						 "same_page:		\n\t"							 
-						 "adiw	r30,2		\n\t"	//Next word in FLASH
-						 "sbiw	r24,2		\n\t"	//length-2
-						 "breq	final_write	\n\t"	//Finished
-						 "rjmp	length_loop	\n\t"
-						 "final_write:		\n\t"
-						 "cpi	r17,0		\n\t"
-						 "breq	block_done	\n\t"
-						 "adiw	r24,2		\n\t"	//length+2, fool above check on length after short page write
-						 "rjmp	write_page	\n\t"
-						 "block_done:		\n\t"
-						 "clr	__zero_reg__	\n\t"	//restore zero register
-						 : "=m" (SPMCSR) : "M" (PAGE_SIZE) : "r0","r16","r17","r24","r25","r28","r29","r30","r31"
-
-						 );
-				}
-				putch(0x14);
-				putch(0x10);
-		    }
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-				    app_start();
-		    }		
-		}
-    
-		/* Read memory block mode, length is big endian.  */
-		else if(ch=='t')
-		{
-			length.byte[1] = getch();
-			length.byte[0] = getch();
-
-			if (getch() == 'E')
-				flags.eeprom = 1;
-			else
-			{
-				flags.eeprom = 0;
-				address.word = address.word << 1;	        // address * 2 -> byte location
-			}
-
-			// Command terminator
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				for (w=0; w<length.word; w++)
-				{
-					// Can handle odd and even lengths okay
-				    if (flags.eeprom) 
-					{
-						// Byte access EEPROM read
-						while(EECR & (1<<EEPE));
-						EEAR = (uint16_t)(void *)address.word;
-						EECR |= (1<<EERE);
-						putch(EEDR);
-
-						address.word++;
-				    }
-				    else
-					{
-						if (!flags.rampz)
-							putch(pgm_read_byte_near(address.word));
-
-						address.word++;
-				    }
-				}
-				putch(0x10);
-		    }
-		}
-
-
-		/* Get device signature bytes  */
-		else if(ch=='u')
-		{
-			if (getch() == ' ')
-			{
-				putch(0x14);
-				putch(SIG1);
-				putch(SIG2);
-				putch(SIG3);
-				putch(0x10);
-			}
-			else
-			{
-				if (++error_count == MAX_ERROR_COUNT)
-					app_start();
-			}
-		}
-
-
-		/* Read oscillator calibration byte */
-		else if(ch=='v')
-			byte_response(0x00);
-
-		else if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-
-	}
-    /* end of forever loop */
-}
-
-
-char gethex(void)
-{
-    char ah,al;
-
-    ah = getch();
-	putch(ah);
-    al = getch();
-	putch(al);
-    
-	if(ah >= 'a')
-		ah = ah - 'a' + 0x0a;
-	else if(ah >= '0')
-		ah -= '0';
-    if(al >= 'a')
-		al = al - 'a' + 0x0a;
-	else if(al >= '0')
-		al -= '0';
-
-    return (ah << 4) + al;
-}
-
-
-void puthex(char ch)
-{
-    char ah,al;
-
-    ah = (ch & 0xf0) >> 4;
-	if(ah >= 0x0a)
-		ah = ah - 0x0a + 'a';
-	else
-		ah += '0';
-
-    al = (ch & 0x0f);
-	if(al >= 0x0a)
-		al = al - 0x0a + 'a';
-	else
-		al += '0';
-
-    putch(ah);
-    putch(al);
-}
-
-
-void putch(char ch)
-{
-    while (!(UCSR0A & _BV(UDRE0)));
-    UDR0 = ch;
-}
-
-
-
-
-char getch(void)
-{
-    uint32_t count = 0;
-
-#ifdef ADABOOT
-	LED_PORT &= ~_BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    while(!(UCSR0A & _BV(RXC0)))
-	{
-    	/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
-    	/* HACKME:: here is a good place to count times*/
-    	count++;
-    	if (count > MAX_TIME_COUNT)
-    		app_start();
-     }
-
-#ifdef ADABOOT
-	LED_PORT |= _BV(LED);          // toggle LED to show activity - BBR/LF 10/3/2007 & 9/13/2008
-#endif
-
-    return UDR0;
-}
-
-
-void getNch(uint8_t count)
-{
-    uint8_t i;
-    for(i=0;i<count;i++)
-	{
-		while(!(UCSR0A & _BV(RXC0)));
-		UDR0;
-    }
-}
-
-
-void byte_response(uint8_t val)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(val);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-
-void nothing_response(void)
-{
-    if (getch() == ' ')
-	{
-		putch(0x14);
-		putch(0x10);
-    }
-	else
-	{
-		if (++error_count == MAX_ERROR_COUNT)
-		    app_start();
-    }
-}
-
-#ifdef ADABOOT
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED count times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get      */
-	/* optimized away if compiling with optimizations (DAM).          */
-	
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = ADABOOT;
-    }
-    
-
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);					// LED on
-		for(l = 0; l < (F_CPU / 1000); ++l);		// delay NGvalue was 1000 for both loops - BBR
-		LED_PORT &= ~_BV(LED);					// LED off
-		for(l = 0; l < (F_CPU / 250); ++l);		// delay asymmteric for ADA BOOT BBR 
-	}
-
-	for(l = 0; l < (F_CPU / 100); ++l);		    // pause ADA BOOT BBR 
-		
-}
-
-#else
-
-void flash_led(uint8_t count)
-{
-    /* flash onboard LED three times to signal entering of bootloader */
-	/* l needs to be volatile or the delay loops below might get
-	optimized away if compiling with optimizations (DAM). */
-    volatile uint32_t l;
-
-    if (count == 0) {
-      count = 3;
-    }
-    
-	int8_t i;
-    for (i = 0; i < count; ++i) {
-		LED_PORT |= _BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l);
-		LED_PORT &= ~_BV(LED);
-		for(l = 0; l < (F_CPU / 1000); ++l); 
-	}
-		
-}
-
-
-#endif
-
-
-/* end of file ATmegaBOOT.c */
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
deleted file mode 100644
index e67fe88..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_324P.hex
+++ /dev/null
@@ -1,121 +0,0 @@
-:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
-:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
-:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
-:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
-:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
-:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
-:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
-:10F870000C945B7C0C945B7C0C945B7C11241FBE11
-:10F88000CFEFD8E0DEBFCDBF11E0A0E0B1E0E6E60B
-:10F89000FFEF02C005900D92A030B107D9F712E03A
-:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
-:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
-:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
-:10F8D00009F481E020E0482F55274115510509F42E
-:10F8E0003DC0289A19821A821B821C820BC0898112
-:10F8F0009A81AB81BC810196A11DB11D89839A8338
-:10F90000AB83BC8389819A81AB81BC8180589E4343
-:10F91000A040B04060F3289819821A821B821C8292
-:10F920000BC089819A81AB81BC810196A11DB11D5B
-:10F9300089839A83AB83BC8389819A81AB81BC81A3
-:10F9400080509A4FA040B04060F32F5F822F9927DC
-:10F9500087FD9095841795070CF4C3CF19821A82FE
-:10F960001B821C8289819A81AB81BC818050914726
-:10F97000A240B040A0F489819A81AB81BC810196FC
-:10F98000A11DB11D89839A83AB83BC8389819A8130
-:10F99000AB81BC8180509147A240B04060F3249677
-:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
-:10F9B000EF92FF920F931F93EE24FF248701289864
-:10F9C0008091C00087FD17C00894E11CF11C011D47
-:10F9D000111D81E0E81689E0F8068DE3080780E054
-:10F9E000180770F3E0910001F091010109958091F1
-:10F9F000C00087FFE9CF289A8091C600992787FD2C
-:10FA000090951F910F91FF90EF900895982F8091FE
-:10FA1000C00085FFFCCF9093C60008950E94D87C5B
-:10FA2000803271F0809102018F5F809302018530F6
-:10FA300009F00895E0910001F09101010995089500
-:10FA400084E10E94067D80E10E94067D0895CF93A7
-:10FA5000C82F0E94D87C803241F0809102018F5FD4
-:10FA600080930201853081F40AC084E10E94067D02
-:10FA70008C2F0E94067D80E10E94067D05C0E091EA
-:10FA80000001F09101010995CF910895282F90E090
-:10FA900007C08091C0008823E4F78091C6009F5F73
-:10FAA0009217B8F30895CFEFD8E0DEBFCDBF0000C6
-:10FAB00094B714BE809160008861809360001092BA
-:10FAC000600091FF74C189E18093C4001092C50069
-:10FAD00088E18093C10086E08093C2005098589AD4
-:10FAE000209A83E00E945D7C81E00E945D7C0E9400
-:10FAF000D87C8033B9F18133C1F1803409F456C028
-:10FB0000813409F45CC0823409F46EC0853409F490
-:10FB100071C0803539F1813509F4F3C0823511F1B6
-:10FB2000853509F4D3C0863509F4CBC0843609F491
-:10FB300065C0843709F4EBC0853709F4D2C0863735
-:10FB400009F44AC0809102018F5F809302018530E1
-:10FB500071F6E0910001F091010109950E94D87CB5
-:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
-:10FB7000803241F784E10E94067D81E40E94067D87
-:10FB800086E50E94067D82E50E94067D8C2F0E94FC
-:10FB9000067D89E40E94067D83E50E94067D80E55E
-:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
-:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
-:10FBC000D87C803809F407C1813809F400C1823833
-:10FBD00009F4F9C0883921F080E00E94277D87CFA1
-:10FBE00083E00E94277D83CF84E10E94467D0E94AE
-:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
-:10FC0000809306020E94D87C8093050280910802AE
-:10FC10008E7F809308020E94D87C853409F44BC003
-:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
-:10FC3000C0E0D0E0809105029091060218161906E6
-:10FC400078F405E011E00E94D87CF80181938F01DF
-:10FC500021968091050290910602C817D90798F362
-:10FC60000E94D87C803209F06DCF8091080280FF1D
-:10FC7000B6C0C0E0D0E02091050230910602121615
-:10FC80001306B8F4E0910301F0910401A5E0B1E09E
-:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
-:10FCA00031962196C217D30798F3F0930401E0939D
-:10FCB000030184E175CF809108028160809308027E
-:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
-:10FCD000809303010E94D87C809304010E940E7DD2
-:10FCE00006CF0E94D87C803209F02CCF84E10E949C
-:10FCF000067D8EE10E94067D85E90E94067D88E0F2
-:10FD00004FCF0E940E7D88E080936000FFCF0E945D
-:10FD1000D87C809306020E94D87C809305020E94C2
-:10FD2000D87C853409F449C0809108028E7F809385
-:10FD300008028091030190910401880F991F90930C
-:10FD40000401809303010E94D87C803209F0CFCE59
-:10FD500084E10E94067DC0E0D0E020910502309150
-:10FD600006021216130608F01DCFE0910301F09170
-:10FD700004018091080280FF96C0F999FECFF2BD80
-:10FD8000E1BDF89A80B50E94067DE0910301F091F3
-:10FD900004013196F0930401E093030120910502E0
-:10FDA000309106022196C217D30718F3FBCEE091DB
-:10FDB0000001F0910101099586CE809108028160D1
-:10FDC00080930802C0CF80E10E94277D90CE81E021
-:10FDD0000E94277D8CCE82E00E94277D88CE809174
-:10FDE000030190910401880F991F9093040180935F
-:10FDF00003018091050280FF09C080910502909166
-:10FE0000060201969093060280930502F999FECFAF
-:10FE10001127E0910301F0910401C5E0D1E0809148
-:10FE2000050290910602103091F400915700017084
-:10FE30000130D9F303E000935700E8950091570093
-:10FE400001700130D9F301E100935700E895099062
-:10FE500019900091570001700130D9F301E000932F
-:10FE60005700E8951395103898F011270091570026
-:10FE700001700130D9F305E000935700E895009137
-:10FE8000570001700130D9F301E100935700E89564
-:10FE90003296029709F0C7CF103011F00296E5CFE5
-:10FEA000112484E17DCE869580FF06C03196F093C3
-:10FEB0000401E093030176CF84910E94067D209196
-:10FEC000050230910602E0910301F0910401EECFAA
-:10FED0001F93CF930E94D87CC82F0E94067D0E945A
-:10FEE000D87C182F0E94067DC1362CF0C7551136DC
-:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
-:10FF000010330CF01053C295C07FC10F8C2F99276E
-:10FF100087FD9095CF911F910895CF93282F992712
-:10FF200087FD9095807F907095958795959587959D
-:10FF300095958795959587958A303CF0895AC22F7B
-:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
-:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
-:06FF6000CF910895FFCFD0
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
deleted file mode 100644
index d5557de..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644.hex
+++ /dev/null
@@ -1,120 +0,0 @@
-:10F800000C94387C0C94557C0C94557C0C94557C51
-:10F810000C94557C0C94557C0C94557C0C94557C24
-:10F820000C94557C0C94557C0C94557C0C94557C14
-:10F830000C94557C0C94557C0C94557C0C94557C04
-:10F840000C94557C0C94557C0C94557C0C94557CF4
-:10F850000C94557C0C94557C0C94557C0C94557CE4
-:10F860000C94557C0C94557C0C94557C0C94557CD4
-:10F8700011241FBECFEFD0E1DEBFCDBF11E0A0E06D
-:10F88000B1E0EAE5FFEF02C005900D92A030B107AC
-:10F89000D9F712E0A0E0B1E001C01D92A930B10794
-:10F8A000E1F70E944D7D0C94AC7F0C94007CCF93CB
-:10F8B000DF93CDB7DEB724970FB6F894DEBF0FBE47
-:10F8C000CDBF882309F481E020E0482F552741155A
-:10F8D000510509F43DC0289A19821A821B821C82A4
-:10F8E0000BC089819A81AB81BC810196A11DB11D9C
-:10F8F00089839A83AB83BC8389819A81AB81BC81E4
-:10F9000080589E43A040B04060F3289819821A8224
-:10F910001B821C820BC089819A81AB81BC810196BC
-:10F92000A11DB11D89839A83AB83BC8389819A8190
-:10F93000AB81BC8180509A4FA040B04060F32F5FF4
-:10F94000822F992787FD9095841795070CF4C3CFD4
-:10F9500019821A821B821C8289819A81AB81BC81A7
-:10F9600080509147A240B040A0F489819A81AB8138
-:10F97000BC810196A11DB11D89839A83AB83BC8391
-:10F9800089819A81AB81BC8180509147A240B0406F
-:10F9900060F324960FB6F894DEBF0FBECDBFDF91A3
-:10F9A000CF910895EF92FF920F931F93EE24FF24BF
-:10F9B000870128988091C00087FD17C00894E11C3A
-:10F9C000F11C011D111D81E0E81689E0F8068DE3A8
-:10F9D000080780E0180770F3E0910001F091010141
-:10F9E00009958091C00087FFE9CF289A8091C600D1
-:10F9F000992787FD90951F910F91FF90EF900895A3
-:10FA0000982F8091C00085FFFCCF9093C600089589
-:10FA10000E94D27C803271F0809102018F5F8093CE
-:10FA20000201853009F00895E0910001F091010193
-:10FA30000995089584E10E94007D80E10E94007D87
-:10FA40000895CF93C82F0E94D27C803241F08091DC
-:10FA500002018F5F80930201853081F40AC084E146
-:10FA60000E94007D8C2F0E94007D80E10E94007D1D
-:10FA700005C0E0910001F09101010995CF91089531
-:10FA8000282F90E007C08091C0008823E4F7809180
-:10FA9000C6009F5F9217B8F30895CFEFD0E1DEBFA5
-:10FAA000CDBF000094B714BE809160008861809340
-:10FAB00060001092600091FF74C189E18093C400DE
-:10FAC0001092C50088E18093C10086E08093C20057
-:10FAD0005098589A209A83E00E94577C81E00E94B7
-:10FAE000577C0E94D27C8033B9F18133C1F18034DC
-:10FAF00009F456C0813409F45CC0823409F46EC044
-:10FB0000853409F471C0803539F1813509F4F3C0C9
-:10FB1000823511F1853509F4D3C0863509F4CBC09F
-:10FB2000843609F465C0843709F4EBC0853709F4DD
-:10FB3000D2C0863709F44AC0809102018F5F80935A
-:10FB40000201853071F6E0910001F0910101099503
-:10FB50000E94D27C803349F60E94087DC2CF0E9469
-:10FB6000D27CC82F803241F784E10E94007D81E47D
-:10FB70000E94007D86E50E94007D82E50E94007D56
-:10FB80008C2F0E94007D89E40E94007D83E50E9405
-:10FB9000007D80E50E94007D80E10E94007DA1CF74
-:10FBA0000E94D27C8638C0F20E94D27C0E94087DDE
-:10FBB00098CF0E94D27C803809F407C1813809F4BB
-:10FBC00000C1823809F4F9C0883921F080E00E9430
-:10FBD000217D87CF83E00E94217D83CF84E10E9435
-:10FBE000407D0E94087D7DCF85E00E94407DF9CF59
-:10FBF0000E94D27C809306020E94D27C80930502F0
-:10FC0000809108028E7F809308020E94D27C853406
-:10FC100009F44BC0E5E0F1E0119281E0E438F80727
-:10FC2000D9F3D0F3C0E0D0E08091050290910602B4
-:10FC30001816190678F405E011E00E94D27CF8014C
-:10FC400081938F0121968091050290910602C81739
-:10FC5000D90798F30E94D27C803209F06DCF809151
-:10FC6000080280FFB6C0C0E0D0E0209105023091CC
-:10FC7000060212161306B8F4E0910301F091040194
-:10FC8000A5E0B1E0F999FECFF2BDE1BD8D9180BD57
-:10FC9000FA9AF99A31962196C217D30798F3F093FE
-:10FCA0000401E093030184E175CF80910802816033
-:10FCB00080930802AFCF84E00E94407D80E087CF30
-:10FCC0000E94D27C809303010E94D27C8093040125
-:10FCD0000E94087D06CF0E94D27C803209F02CCF92
-:10FCE00084E10E94007D8EE10E94007D86E90E94F1
-:10FCF000007D89E04FCF0E94087D88E080936000FE
-:10FD0000FFCF0E94D27C809306020E94D27C809317
-:10FD100005020E94D27C853409F449C08091080212
-:10FD20008E7F809308028091030190910401880FD7
-:10FD3000991F90930401809303010E94D27C80322A
-:10FD400009F0CFCE84E10E94007DC0E0D0E0209198
-:10FD50000502309106021216130608F01DCFE0913D
-:10FD60000301F09104018091080280FF96C0F99987
-:10FD7000FECFF2BDE1BDF89A80B50E94007DE09112
-:10FD80000301F09104013196F0930401E093030123
-:10FD900020910502309106022196C217D30718F36D
-:10FDA000FBCEE0910001F0910101099586CE809192
-:10FDB0000802816080930802C0CF80E10E94217D0B
-:10FDC00090CE81E00E94217D8CCE82E00E94217D38
-:10FDD00088CE8091030190910401880F991F909320
-:10FDE0000401809303018091050280FF09C0809186
-:10FDF00005029091060201969093060280930502F7
-:10FE0000F999FECF1127E0910301F0910401C5E0BB
-:10FE1000D1E08091050290910602103091F400919A
-:10FE2000570001700130D9F303E000935700E895C3
-:10FE30000091570001700130D9F301E100935700A0
-:10FE4000E895099019900091570001700130D9F39D
-:10FE500001E000935700E8951395103898F01127AA
-:10FE60000091570001700130D9F305E0009357006D
-:10FE7000E8950091570001700130D9F301E100933A
-:10FE80005700E8953296029709F0C7CF103011F06D
-:10FE90000296E5CF112484E17DCE869580FF06C0D1
-:10FEA0003196F0930401E093030176CF84910E9490
-:10FEB000007D2091050230910602E0910301F0914E
-:10FEC0000401EECF1F93CF930E94D27CC82F0E94D3
-:10FED000007D0E94D27C182F0E94007DC1362CF03C
-:10FEE000C75511363CF0175508C0C033D4F3C05382
-:10FEF0001136CCF710330CF01053C295C07FC10FF0
-:10FF00008C2F992787FD9095CF911F910895CF93BE
-:10FF1000282F992787FD9095807F907095958795DC
-:10FF20009595879595958795959587958A303CF019
-:10FF3000895AC22FCF70CA303CF0C95A06C0805DC2
-:10FF4000C22FCF70CA30CCF7C05D0E94007D8C2FCD
-:0AFF50000E94007DCF910895FFCFBD
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex b/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
deleted file mode 100644
index 99a6ae1..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/ATmegaBOOT_644P.hex
+++ /dev/null
@@ -1,121 +0,0 @@
-:10F800000C943E7C0C945B7C0C945B7C0C945B7C39
-:10F810000C945B7C0C945B7C0C945B7C0C945B7C0C
-:10F820000C945B7C0C945B7C0C945B7C0C945B7CFC
-:10F830000C945B7C0C945B7C0C945B7C0C945B7CEC
-:10F840000C945B7C0C945B7C0C945B7C0C945B7CDC
-:10F850000C945B7C0C945B7C0C945B7C0C945B7CCC
-:10F860000C945B7C0C945B7C0C945B7C0C945B7CBC
-:10F870000C945B7C0C945B7C0C945B7C11241FBE11
-:10F88000CFEFD0E1DEBFCDBF11E0A0E0B1E0E6E612
-:10F89000FFEF02C005900D92A030B107D9F712E03A
-:10F8A000A0E0B1E001C01D92A930B107E1F70E94CC
-:10F8B000537D0C94B27F0C94007CCF93DF93CDB733
-:10F8C000DEB724970FB6F894DEBF0FBECDBF8823F6
-:10F8D00009F481E020E0482F55274115510509F42E
-:10F8E0003DC0289A19821A821B821C820BC0898112
-:10F8F0009A81AB81BC810196A11DB11D89839A8338
-:10F90000AB83BC8389819A81AB81BC8180589E4343
-:10F91000A040B04060F3289819821A821B821C8292
-:10F920000BC089819A81AB81BC810196A11DB11D5B
-:10F9300089839A83AB83BC8389819A81AB81BC81A3
-:10F9400080509A4FA040B04060F32F5F822F9927DC
-:10F9500087FD9095841795070CF4C3CF19821A82FE
-:10F960001B821C8289819A81AB81BC818050914726
-:10F97000A240B040A0F489819A81AB81BC810196FC
-:10F98000A11DB11D89839A83AB83BC8389819A8130
-:10F99000AB81BC8180509147A240B04060F3249677
-:10F9A0000FB6F894DEBF0FBECDBFDF91CF910895A3
-:10F9B000EF92FF920F931F93EE24FF248701289864
-:10F9C0008091C00087FD17C00894E11CF11C011D47
-:10F9D000111D81E0E81689E0F8068DE3080780E054
-:10F9E000180770F3E0910001F091010109958091F1
-:10F9F000C00087FFE9CF289A8091C600992787FD2C
-:10FA000090951F910F91FF90EF900895982F8091FE
-:10FA1000C00085FFFCCF9093C60008950E94D87C5B
-:10FA2000803271F0809102018F5F809302018530F6
-:10FA300009F00895E0910001F09101010995089500
-:10FA400084E10E94067D80E10E94067D0895CF93A7
-:10FA5000C82F0E94D87C803241F0809102018F5FD4
-:10FA600080930201853081F40AC084E10E94067D02
-:10FA70008C2F0E94067D80E10E94067D05C0E091EA
-:10FA80000001F09101010995CF910895282F90E090
-:10FA900007C08091C0008823E4F78091C6009F5F73
-:10FAA0009217B8F30895CFEFD0E1DEBFCDBF0000CD
-:10FAB00094B714BE809160008861809360001092BA
-:10FAC000600091FF74C189E18093C4001092C50069
-:10FAD00088E18093C10086E08093C2005098589AD4
-:10FAE000209A83E00E945D7C81E00E945D7C0E9400
-:10FAF000D87C8033B9F18133C1F1803409F456C028
-:10FB0000813409F45CC0823409F46EC0853409F490
-:10FB100071C0803539F1813509F4F3C0823511F1B6
-:10FB2000853509F4D3C0863509F4CBC0843609F491
-:10FB300065C0843709F4EBC0853709F4D2C0863735
-:10FB400009F44AC0809102018F5F809302018530E1
-:10FB500071F6E0910001F091010109950E94D87CB5
-:10FB6000803349F60E940E7DC2CF0E94D87CC82FF8
-:10FB7000803241F784E10E94067D81E40E94067D87
-:10FB800086E50E94067D82E50E94067D8C2F0E94FC
-:10FB9000067D89E40E94067D83E50E94067D80E55E
-:10FBA0000E94067D80E10E94067DA1CF0E94D87C44
-:10FBB0008638C0F20E94D87C0E940E7D98CF0E94A9
-:10FBC000D87C803809F407C1813809F400C1823833
-:10FBD00009F4F9C0883921F080E00E94277D87CFA1
-:10FBE00083E00E94277D83CF84E10E94467D0E94AE
-:10FBF0000E7D7DCF85E00E94467DF9CF0E94D87CA6
-:10FC0000809306020E94D87C8093050280910802AE
-:10FC10008E7F809308020E94D87C853409F44BC003
-:10FC2000E5E0F1E0119281E0E438F807D9F3D0F390
-:10FC3000C0E0D0E0809105029091060218161906E6
-:10FC400078F405E011E00E94D87CF80181938F01DF
-:10FC500021968091050290910602C817D90798F362
-:10FC60000E94D87C803209F06DCF8091080280FF1D
-:10FC7000B6C0C0E0D0E02091050230910602121615
-:10FC80001306B8F4E0910301F0910401A5E0B1E09E
-:10FC9000F999FECFF2BDE1BD8D9180BDFA9AF99A36
-:10FCA00031962196C217D30798F3F0930401E0939D
-:10FCB000030184E175CF809108028160809308027E
-:10FCC000AFCF84E00E94467D80E087CF0E94D87C41
-:10FCD000809303010E94D87C809304010E940E7DD2
-:10FCE00006CF0E94D87C803209F02CCF84E10E949C
-:10FCF000067D8EE10E94067D86E90E94067D8AE0EF
-:10FD00004FCF0E940E7D88E080936000FFCF0E945D
-:10FD1000D87C809306020E94D87C809305020E94C2
-:10FD2000D87C853409F449C0809108028E7F809385
-:10FD300008028091030190910401880F991F90930C
-:10FD40000401809303010E94D87C803209F0CFCE59
-:10FD500084E10E94067DC0E0D0E020910502309150
-:10FD600006021216130608F01DCFE0910301F09170
-:10FD700004018091080280FF96C0F999FECFF2BD80
-:10FD8000E1BDF89A80B50E94067DE0910301F091F3
-:10FD900004013196F0930401E093030120910502E0
-:10FDA000309106022196C217D30718F3FBCEE091DB
-:10FDB0000001F0910101099586CE809108028160D1
-:10FDC00080930802C0CF80E10E94277D90CE81E021
-:10FDD0000E94277D8CCE82E00E94277D88CE809174
-:10FDE000030190910401880F991F9093040180935F
-:10FDF00003018091050280FF09C080910502909166
-:10FE0000060201969093060280930502F999FECFAF
-:10FE10001127E0910301F0910401C5E0D1E0809148
-:10FE2000050290910602103091F400915700017084
-:10FE30000130D9F303E000935700E8950091570093
-:10FE400001700130D9F301E100935700E895099062
-:10FE500019900091570001700130D9F301E000932F
-:10FE60005700E8951395103898F011270091570026
-:10FE700001700130D9F305E000935700E895009137
-:10FE8000570001700130D9F301E100935700E89564
-:10FE90003296029709F0C7CF103011F00296E5CFE5
-:10FEA000112484E17DCE869580FF06C03196F093C3
-:10FEB0000401E093030176CF84910E94067D209196
-:10FEC000050230910602E0910301F0910401EECFAA
-:10FED0001F93CF930E94D87CC82F0E94067D0E945A
-:10FEE000D87C182F0E94067DC1362CF0C7551136DC
-:10FEF0003CF0175508C0C033D4F3C0531136CCF7CB
-:10FF000010330CF01053C295C07FC10F8C2F99276E
-:10FF100087FD9095CF911F910895CF93282F992712
-:10FF200087FD9095807F907095958795959587959D
-:10FF300095958795959587958A303CF0895AC22F7B
-:10FF4000CF70CA303CF0C95A06C0805DC22FCF7056
-:10FF5000CA30CCF7C05D0E94067D8C2F0E94067DC2
-:06FF6000CF910895FFCFD0
-:040000030000F80001
-:00000001FF
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/Makefile b/Marlin/Sanguino/bootloaders/atmega644p/Makefile
deleted file mode 100644
index 5714395..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/Makefile
+++ /dev/null
@@ -1,56 +0,0 @@
-# Makefile for ATmegaBOOT
-# E.Lins, 18.7.2005
-# $Id$
-
-
-# program name should not be changed...
-PROGRAM    = ATmegaBOOT_644P
-
-# enter the target CPU frequency
-AVR_FREQ   = 16000000L
-
-MCU_TARGET = atmega644p
-LDSECTION  = --section-start=.text=0xF800
-
-OBJ        = $(PROGRAM).o
-OPTIMIZE   = -O2
-
-DEFS       = 
-LIBS       = 
-
-CC         = avr-gcc
-
-
-# Override is only needed by avr-lib build system.
-
-override CFLAGS        = -g -Wall $(OPTIMIZE) -mmcu=$(MCU_TARGET) -DF_CPU=$(AVR_FREQ) $(DEFS)
-override LDFLAGS       = -Wl,$(LDSECTION)
-#override LDFLAGS       = -Wl,-Map,$(PROGRAM).map,$(LDSECTION)
-
-OBJCOPY        = avr-objcopy
-OBJDUMP        = avr-objdump
-
-all: CFLAGS += '-DMAX_TIME_COUNT=8000000L>>1' -DADABOOT
-all: $(PROGRAM).hex
-
-$(PROGRAM).hex: $(PROGRAM).elf
-	$(OBJCOPY) -j .text -j .data -O ihex $< $@
-	
-$(PROGRAM).elf: $(OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LIBS)
-	
-$(OBJ): ATmegaBOOT.c
-	avr-gcc $(CFLAGS) $(LDFLAGS) -c -g -O2 -Wall -mmcu=$(MCU_TARGET) ATmegaBOOT.c -o $(PROGRAM).o
-
-%.lst: %.elf
-	$(OBJDUMP) -h -S $< > $@
-
-%.srec: %.elf
-	$(OBJCOPY) -j .text -j .data -O srec $< $@
-
-%.bin: %.elf
-	$(OBJCOPY) -j .text -j .data -O binary $< $@
-
-clean:
-	rm -rf *.o *.elf *.lst *.map *.sym *.lss *.eep *.srec *.bin *.hex
-	
\ No newline at end of file
diff --git a/Marlin/Sanguino/bootloaders/atmega644p/README.txt b/Marlin/Sanguino/bootloaders/atmega644p/README.txt
deleted file mode 100644
index 8286007..0000000
--- a/Marlin/Sanguino/bootloaders/atmega644p/README.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-Note: This bootloader support ATmega644, ATmega644P and ATmega324P.
-To build, set PROGRAM and MCU_TARGET in the Makefile according to your target device.
-
diff --git a/Marlin/Sanguino/cores/arduino/Copy of wiring.h b/Marlin/Sanguino/cores/arduino/Copy of wiring.h
deleted file mode 100644
index e29959b..0000000
--- a/Marlin/Sanguino/cores/arduino/Copy of wiring.h	
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <avr/io.h>
-#include <stdlib.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
-#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp b/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp
deleted file mode 100644
index d4931b4..0000000
--- a/Marlin/Sanguino/cores/arduino/HardwareSerial.cpp
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
-  HardwareSerial.cpp - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-  
-  Modified 23 November 2006 by David A. Mellis
-  Modified 28 September 2010 by Mark Sproul
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <inttypes.h>
-#include "wiring.h"
-#include "wiring_private.h"
-
-// this next line disables the entire HardwareSerial.cpp, 
-// this is so I can support Attiny series and any other chip without a uart
-#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)
-
-#include "HardwareSerial.h"
-
-// Define constants and variables for buffering incoming serial data.  We're
-// using a ring buffer (I think), in which rx_buffer_head is the index of the
-// location to which to write the next incoming character and rx_buffer_tail
-// is the index of the location from which to read.
-#define RX_BUFFER_SIZE 128
-
-struct ring_buffer
-{
-  unsigned char buffer[RX_BUFFER_SIZE];
-  int head;
-  int tail;
-};
-
-ring_buffer rx_buffer  =  { { 0 }, 0, 0 };
-
-inline void store_char(unsigned char c, ring_buffer *rx_buffer)
-{
-  int i = (unsigned int)(rx_buffer->head + 1) & (RX_BUFFER_SIZE -1);
-
-  // if we should be storing the received character into the location
-  // just before the tail (meaning that the head would advance to the
-  // current location of the tail), we're about to overflow the buffer
-  // and so we don't write the character or advance the head.
-  if (i != rx_buffer->tail) {
-    rx_buffer->buffer[rx_buffer->head] = c;
-    rx_buffer->head = i;
-  }
-}
-
-// fixed by Mark Sproul this is on the 644/644p
-//SIGNAL(SIG_USART_RECV)
-SIGNAL(USART0_RX_vect)
-{
-  unsigned char c  =  UDR0;
-  store_char(c, &rx_buffer);
-}
-
-
-// Constructors ////////////////////////////////////////////////////////////////
-
-HardwareSerial::HardwareSerial(ring_buffer *rx_buffer,
-  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-  volatile uint8_t *udr,
-  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x)
-{
-  _rx_buffer = rx_buffer;
-  _ubrrh = ubrrh;
-  _ubrrl = ubrrl;
-  _ucsra = ucsra;
-  _ucsrb = ucsrb;
-  _udr = udr;
-  _rxen = rxen;
-  _txen = txen;
-  _rxcie = rxcie;
-  _udre = udre;
-  _u2x = u2x;
-}
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-void HardwareSerial::begin(long baud)
-{
-  uint16_t baud_setting;
-  bool use_u2x = true;
-
-#if F_CPU == 16000000UL
-  // hardcoded exception for compatibility with the bootloader shipped
-  // with the Duemilanove and previous boards and the firmware on the 8U2
-  // on the Uno and Mega 2560.
-  if (baud == 57600) {
-    use_u2x = false;
-  }
-#endif
-  
-  if (use_u2x) {
-    *_ucsra = 1 << _u2x;
-    baud_setting = (F_CPU / 4 / baud - 1) / 2;
-  } else {
-    *_ucsra = 0;
-    baud_setting = (F_CPU / 8 / baud - 1) / 2;
-  }
-
-  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
-  *_ubrrh = baud_setting >> 8;
-  *_ubrrl = baud_setting;
-
-  sbi(*_ucsrb, _rxen);
-  sbi(*_ucsrb, _txen);
-  sbi(*_ucsrb, _rxcie);
-}
-
-void HardwareSerial::end()
-{
-  cbi(*_ucsrb, _rxen);
-  cbi(*_ucsrb, _txen);
-  cbi(*_ucsrb, _rxcie);  
-}
-
-int HardwareSerial::available(void)
-{
-  return (unsigned int)(RX_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) & (RX_BUFFER_SIZE-1);
-}
-
-int HardwareSerial::peek(void)
-{
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    return _rx_buffer->buffer[_rx_buffer->tail];
-  }
-}
-
-int HardwareSerial::read(void)
-{
-  // if the head isn't ahead of the tail, we don't have any characters
-  if (_rx_buffer->head == _rx_buffer->tail) {
-    return -1;
-  } else {
-    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
-    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) & (RX_BUFFER_SIZE-1);
-    return c;
-  }
-}
-
-void HardwareSerial::flush()
-{
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // don't reverse this or there may be problems if the RX interrupt
-  // occurs after reading the value of rx_buffer_head but before writing
-  // the value to rx_buffer_tail; the previous value of rx_buffer_head
-  // may be written to rx_buffer_tail, making it appear as if the buffer
-  // were full, not empty.
-  _rx_buffer->head = _rx_buffer->tail;
-}
-
-void HardwareSerial::write(uint8_t c)
-{
-  while (!((*_ucsra) & (1 << _udre)))
-    ;
-
-  *_udr = c;
-}
-
-// Preinstantiate Objects //////////////////////////////////////////////////////
-HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRE0, U2X0);
-
-#endif // whole file
-
diff --git a/Marlin/Sanguino/cores/arduino/HardwareSerial.h b/Marlin/Sanguino/cores/arduino/HardwareSerial.h
deleted file mode 100644
index 3efa775..0000000
--- a/Marlin/Sanguino/cores/arduino/HardwareSerial.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  HardwareSerial.h - Hardware serial library for Wiring
-  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-  Modified 28 September 2010 by Mark Sproul
-*/
-
-#ifndef HardwareSerial_h
-#define HardwareSerial_h
-
-#include <inttypes.h>
-
-#include "Stream.h"
-
-struct ring_buffer;
-
-class HardwareSerial : public Stream
-{
-  private:
-    ring_buffer *_rx_buffer;
-    volatile uint8_t *_ubrrh;
-    volatile uint8_t *_ubrrl;
-    volatile uint8_t *_ucsra;
-    volatile uint8_t *_ucsrb;
-    volatile uint8_t *_udr;
-    uint8_t _rxen;
-    uint8_t _txen;
-    uint8_t _rxcie;
-    uint8_t _udre;
-    uint8_t _u2x;
-  public:
-    HardwareSerial(ring_buffer *rx_buffer,
-      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
-      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
-      volatile uint8_t *udr,
-      uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udre, uint8_t u2x);
-    void begin(long);
-    void end();
-    virtual int available(void);
-    virtual int peek(void);
-    virtual int read(void);
-    virtual void flush(void);
-    virtual void write(uint8_t);
-    using Print::write; // pull in write(str) and write(buf, size) from Print
-};
-
-#if defined(UBRRH) || defined(UBRR0H)
-  extern HardwareSerial Serial;
-#elif defined(USBCON)
-  #include "usb_api.h"
-#endif
-#if defined(UBRR1H)
-  extern HardwareSerial Serial1;
-#endif
-#if defined(UBRR2H)
-  extern HardwareSerial Serial2;
-#endif
-#if defined(UBRR3H)
-  extern HardwareSerial Serial3;
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Print.cpp b/Marlin/Sanguino/cores/arduino/Print.cpp
deleted file mode 100644
index 4ee556d..0000000
--- a/Marlin/Sanguino/cores/arduino/Print.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- Print.cpp - Base class that provides print() and println()
- Copyright (c) 2008 David A. Mellis.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- 
- Modified 23 November 2006 by David A. Mellis
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-#include "wiring.h"
-
-#include "Print.h"
-
-// Public Methods //////////////////////////////////////////////////////////////
-
-/* default implementation: may be overridden */
-void Print::write(const char *str)
-{
-  while (*str)
-    write(*str++);
-}
-
-/* default implementation: may be overridden */
-void Print::write(const uint8_t *buffer, size_t size)
-{
-  while (size--)
-    write(*buffer++);
-}
-
-void Print::print(const String &s)
-{
-  for (int i = 0; i < s.length(); i++) {
-    write(s[i]);
-  }
-}
-
-void Print::print(const char str[])
-{
-  write(str);
-}
-
-void Print::print(char c, int base)
-{
-  print((long) c, base);
-}
-
-void Print::print(unsigned char b, int base)
-{
-  print((unsigned long) b, base);
-}
-
-void Print::print(int n, int base)
-{
-  print((long) n, base);
-}
-
-void Print::print(unsigned int n, int base)
-{
-  print((unsigned long) n, base);
-}
-
-void Print::print(long n, int base)
-{
-  if (base == 0) {
-    write(n);
-  } else if (base == 10) {
-    if (n < 0) {
-      print('-');
-      n = -n;
-    }
-    printNumber(n, 10);
-  } else {
-    printNumber(n, base);
-  }
-}
-
-void Print::print(unsigned long n, int base)
-{
-  if (base == 0) write(n);
-  else printNumber(n, base);
-}
-
-void Print::print(double n, int digits)
-{
-  printFloat(n, digits);
-}
-
-void Print::println(void)
-{
-  print('\r');
-  print('\n');  
-}
-
-void Print::println(const String &s)
-{
-  print(s);
-  println();
-}
-
-void Print::println(const char c[])
-{
-  print(c);
-  println();
-}
-
-void Print::println(char c, int base)
-{
-  print(c, base);
-  println();
-}
-
-void Print::println(unsigned char b, int base)
-{
-  print(b, base);
-  println();
-}
-
-void Print::println(int n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(unsigned int n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(unsigned long n, int base)
-{
-  print(n, base);
-  println();
-}
-
-void Print::println(double n, int digits)
-{
-  print(n, digits);
-  println();
-}
-
-// Private Methods /////////////////////////////////////////////////////////////
-
-void Print::printNumber(unsigned long n, uint8_t base)
-{
-  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. 
-  unsigned long i = 0;
-
-  if (n == 0) {
-    print('0');
-    return;
-  } 
-
-  while (n > 0) {
-    buf[i++] = n % base;
-    n /= base;
-  }
-
-  for (; i > 0; i--)
-    print((char) (buf[i - 1] < 10 ?
-      '0' + buf[i - 1] :
-      'A' + buf[i - 1] - 10));
-}
-
-void Print::printFloat(double number, uint8_t digits) 
-{ 
-  // Handle negative numbers
-  if (number < 0.0)
-  {
-     print('-');
-     number = -number;
-  }
-
-  // Round correctly so that print(1.999, 2) prints as "2.00"
-  double rounding = 0.5;
-  for (uint8_t i=0; i<digits; ++i)
-    rounding /= 10.0;
-  
-  number += rounding;
-
-  // Extract the integer part of the number and print it
-  unsigned long int_part = (unsigned long)number;
-  double remainder = number - (double)int_part;
-  print(int_part);
-
-  // Print the decimal point, but only if there are digits beyond
-  if (digits > 0)
-    print("."); 
-
-  // Extract digits from the remainder one at a time
-  while (digits-- > 0)
-  {
-    remainder *= 10.0;
-    int toPrint = int(remainder);
-    print(toPrint);
-    remainder -= toPrint; 
-  } 
-}
diff --git a/Marlin/Sanguino/cores/arduino/Print.h b/Marlin/Sanguino/cores/arduino/Print.h
deleted file mode 100644
index b092ae5..0000000
--- a/Marlin/Sanguino/cores/arduino/Print.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-  Print.h - Base class that provides print() and println()
-  Copyright (c) 2008 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Print_h
-#define Print_h
-
-#include <inttypes.h>
-#include <stdio.h> // for size_t
-
-#include "WString.h"
-
-#define DEC 10
-#define HEX 16
-#define OCT 8
-#define BIN 2
-#define BYTE 0
-
-class Print
-{
-  private:
-    void printNumber(unsigned long, uint8_t);
-    void printFloat(double, uint8_t);
-  public:
-    virtual void write(uint8_t) = 0;
-    virtual void write(const char *str);
-    virtual void write(const uint8_t *buffer, size_t size);
-    
-    void print(const String &);
-    void print(const char[]);
-    void print(char, int = BYTE);
-    void print(unsigned char, int = BYTE);
-    void print(int, int = DEC);
-    void print(unsigned int, int = DEC);
-    void print(long, int = DEC);
-    void print(unsigned long, int = DEC);
-    void print(double, int = 2);
-
-    void println(const String &s);
-    void println(const char[]);
-    void println(char, int = BYTE);
-    void println(unsigned char, int = BYTE);
-    void println(int, int = DEC);
-    void println(unsigned int, int = DEC);
-    void println(long, int = DEC);
-    void println(unsigned long, int = DEC);
-    void println(double, int = 2);
-    void println(void);
-};
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Stream.h b/Marlin/Sanguino/cores/arduino/Stream.h
deleted file mode 100644
index 93d8275..0000000
--- a/Marlin/Sanguino/cores/arduino/Stream.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-  Stream.h - base class for character-based streams.
-  Copyright (c) 2010 David A. Mellis.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef Stream_h
-#define Stream_h
-
-#include <inttypes.h>
-#include "Print.h"
-
-class Stream : public Print
-{
-  public:
-    virtual int available() = 0;
-    virtual int read() = 0;
-    virtual int peek() = 0;
-    virtual void flush() = 0;
-};
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/Tone.cpp b/Marlin/Sanguino/cores/arduino/Tone.cpp
deleted file mode 100644
index c3910e7..0000000
--- a/Marlin/Sanguino/cores/arduino/Tone.cpp
+++ /dev/null
@@ -1,601 +0,0 @@
-/* Tone.cpp
-
-  A Tone Generator Library
-
-  Written by Brett Hagman
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Version Modified By Date     Comments
-------- ----------- -------- --------
-0001    B Hagman    09/08/02 Initial coding
-0002    B Hagman    09/08/18 Multiple pins
-0003    B Hagman    09/08/18 Moved initialization from constructor to begin()
-0004    B Hagman    09/09/26 Fixed problems with ATmega8
-0005    B Hagman    09/11/23 Scanned prescalars for best fit on 8 bit timers
-                    09/11/25 Changed pin toggle method to XOR
-                    09/11/25 Fixed timer0 from being excluded
-0006    D Mellis    09/12/29 Replaced objects with functions
-0007    M Sproul    10/08/29 Changed #ifdefs from cpu to register
-*************************************************/
-
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include "wiring.h"
-#include "pins_arduino.h"
-
-#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega128__)
-#define TCCR2A TCCR2
-#define TCCR2B TCCR2
-#define COM2A1 COM21
-#define COM2A0 COM20
-#define OCR2A OCR2
-#define TIMSK2 TIMSK
-#define OCIE2A OCIE2
-#define TIMER2_COMPA_vect TIMER2_COMP_vect
-#define TIMSK1 TIMSK
-#endif
-
-// timerx_toggle_count:
-//  > 0 - duration specified
-//  = 0 - stopped
-//  < 0 - infinitely (until stop() method called, or new play() called)
-
-#if !defined(__AVR_ATmega8__)
-volatile long timer0_toggle_count;
-volatile uint8_t *timer0_pin_port;
-volatile uint8_t timer0_pin_mask;
-#endif
-
-volatile long timer1_toggle_count;
-volatile uint8_t *timer1_pin_port;
-volatile uint8_t timer1_pin_mask;
-volatile long timer2_toggle_count;
-volatile uint8_t *timer2_pin_port;
-volatile uint8_t timer2_pin_mask;
-
-#if defined(TIMSK3)
-volatile long timer3_toggle_count;
-volatile uint8_t *timer3_pin_port;
-volatile uint8_t timer3_pin_mask;
-#endif
-
-#if defined(TIMSK4)
-volatile long timer4_toggle_count;
-volatile uint8_t *timer4_pin_port;
-volatile uint8_t timer4_pin_mask;
-#endif
-
-#if defined(TIMSK5)
-volatile long timer5_toggle_count;
-volatile uint8_t *timer5_pin_port;
-volatile uint8_t timer5_pin_mask;
-#endif
-
-
-// MLS: This does not make sense, the 3 options are the same
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 3, 4, 5, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255, 255, 255, 255 */ };
-
-#elif defined(__AVR_ATmega8__)
-
-#define AVAILABLE_TONE_PINS 1
-
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255 */ };
-
-#else
-
-#define AVAILABLE_TONE_PINS 1
-
-// Leave timer 0 to last.
-const uint8_t PROGMEM tone_pin_to_timer_PGM[] = { 2 /*, 1, 0 */ };
-static uint8_t tone_pins[AVAILABLE_TONE_PINS] = { 255 /*, 255, 255 */ };
-
-#endif
-
-
-
-static int8_t toneBegin(uint8_t _pin)
-{
-  int8_t _timer = -1;
-
-  // if we're already using the pin, the timer should be configured.  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      return pgm_read_byte(tone_pin_to_timer_PGM + i);
-    }
-  }
-  
-  // search for an unused timer.
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == 255) {
-      tone_pins[i] = _pin;
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      break;
-    }
-  }
-  
-  if (_timer != -1)
-  {
-    // Set timer specific stuff
-    // All timers in CTC mode
-    // 8 bit timers will require changing prescalar values,
-    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
-    switch (_timer)
-    {
-      #if defined(TCCR0A) && defined(TCCR0B)
-      case 0:
-        // 8 bit timer
-        TCCR0A = 0;
-        TCCR0B = 0;
-        bitWrite(TCCR0A, WGM01, 1);
-        bitWrite(TCCR0B, CS00, 1);
-        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer0_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
-      case 1:
-        // 16 bit timer
-        TCCR1A = 0;
-        TCCR1B = 0;
-        bitWrite(TCCR1B, WGM12, 1);
-        bitWrite(TCCR1B, CS10, 1);
-        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer1_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR2A) && defined(TCCR2B)
-      case 2:
-        // 8 bit timer
-        TCCR2A = 0;
-        TCCR2B = 0;
-        bitWrite(TCCR2A, WGM21, 1);
-        bitWrite(TCCR2B, CS20, 1);
-        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer2_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
-      case 3:
-        // 16 bit timer
-        TCCR3A = 0;
-        TCCR3B = 0;
-        bitWrite(TCCR3B, WGM32, 1);
-        bitWrite(TCCR3B, CS30, 1);
-        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer3_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
-      case 4:
-        // 16 bit timer
-        TCCR4A = 0;
-        TCCR4B = 0;
-        #if defined(WGM42)
-          bitWrite(TCCR4B, WGM42, 1);
-        #elif defined(CS43)
-          #warning this may not be correct
-          // atmega32u4
-          bitWrite(TCCR4B, CS43, 1);
-        #endif
-        bitWrite(TCCR4B, CS40, 1);
-        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer4_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-
-      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
-      case 5:
-        // 16 bit timer
-        TCCR5A = 0;
-        TCCR5B = 0;
-        bitWrite(TCCR5B, WGM52, 1);
-        bitWrite(TCCR5B, CS50, 1);
-        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
-        timer5_pin_mask = digitalPinToBitMask(_pin);
-        break;
-      #endif
-    }
-  }
-
-  return _timer;
-}
-
-
-
-// frequency (in hertz) and duration (in milliseconds).
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
-{
-  uint8_t prescalarbits = 0b001;
-  long toggle_count = 0;
-  uint32_t ocr = 0;
-  int8_t _timer;
-
-  _timer = toneBegin(_pin);
-
-  if (_timer >= 0)
-  {
-    // Set the pinMode as OUTPUT
-    pinMode(_pin, OUTPUT);
-    
-    // if we are using an 8 bit timer, scan through prescalars to find the best fit
-    if (_timer == 0 || _timer == 2)
-    {
-      ocr = F_CPU / frequency / 2 - 1;
-      prescalarbits = 0b001;  // ck/1: same for both timers
-      if (ocr > 255)
-      {
-        ocr = F_CPU / frequency / 2 / 8 - 1;
-        prescalarbits = 0b010;  // ck/8: same for both timers
-
-        if (_timer == 2 && ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 32 - 1;
-          prescalarbits = 0b011;
-        }
-
-        if (ocr > 255)
-        {
-          ocr = F_CPU / frequency / 2 / 64 - 1;
-          prescalarbits = _timer == 0 ? 0b011 : 0b100;
-
-          if (_timer == 2 && ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 128 - 1;
-            prescalarbits = 0b101;
-          }
-
-          if (ocr > 255)
-          {
-            ocr = F_CPU / frequency / 2 / 256 - 1;
-            prescalarbits = _timer == 0 ? 0b100 : 0b110;
-            if (ocr > 255)
-            {
-              // can't do any better than /1024
-              ocr = F_CPU / frequency / 2 / 1024 - 1;
-              prescalarbits = _timer == 0 ? 0b101 : 0b111;
-            }
-          }
-        }
-      }
-
-#if defined(TCCR0B)
-      if (_timer == 0)
-      {
-        TCCR0B = prescalarbits;
-      }
-      else
-#endif
-#if defined(TCCR2B)
-      {
-        TCCR2B = prescalarbits;
-      }
-#else
-      {
-        // dummy place holder to make the above ifdefs work
-      }
-#endif
-    }
-    else
-    {
-      // two choices for the 16 bit timers: ck/1 or ck/64
-      ocr = F_CPU / frequency / 2 - 1;
-
-      prescalarbits = 0b001;
-      if (ocr > 0xffff)
-      {
-        ocr = F_CPU / frequency / 2 / 64 - 1;
-        prescalarbits = 0b011;
-      }
-
-      if (_timer == 1)
-      {
-#if defined(TCCR1B)
-        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
-#endif
-      }
-#if defined(TCCR3B)
-      else if (_timer == 3)
-        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR4B)
-      else if (_timer == 4)
-        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
-#endif
-#if defined(TCCR5B)
-      else if (_timer == 5)
-        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
-#endif
-
-    }
-    
-
-    // Calculate the toggle count
-    if (duration > 0)
-    {
-      toggle_count = 2 * frequency * duration / 1000;
-    }
-    else
-    {
-      toggle_count = -1;
-    }
-
-    // Set the OCR for the given timer,
-    // set the toggle count,
-    // then turn on the interrupts
-    switch (_timer)
-    {
-
-#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
-      case 0:
-        OCR0A = ocr;
-        timer0_toggle_count = toggle_count;
-        bitWrite(TIMSK0, OCIE0A, 1);
-        break;
-#endif
-
-      case 1:
-#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK1, OCIE1A, 1);
-#elif defined(OCR1A) && defined(TIMSK) && defined(OCIE1A)
-        // this combination is for at least the ATmega32
-        OCR1A = ocr;
-        timer1_toggle_count = toggle_count;
-        bitWrite(TIMSK, OCIE1A, 1);
-#endif
-        break;
-
-#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
-      case 2:
-        OCR2A = ocr;
-        timer2_toggle_count = toggle_count;
-        bitWrite(TIMSK2, OCIE2A, 1);
-        break;
-#endif
-
-#if defined(TIMSK3)
-      case 3:
-        OCR3A = ocr;
-        timer3_toggle_count = toggle_count;
-        bitWrite(TIMSK3, OCIE3A, 1);
-        break;
-#endif
-
-#if defined(TIMSK4)
-      case 4:
-        OCR4A = ocr;
-        timer4_toggle_count = toggle_count;
-        bitWrite(TIMSK4, OCIE4A, 1);
-        break;
-#endif
-
-#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
-      case 5:
-        OCR5A = ocr;
-        timer5_toggle_count = toggle_count;
-        bitWrite(TIMSK5, OCIE5A, 1);
-        break;
-#endif
-
-    }
-  }
-}
-
-
-// XXX: this function only works properly for timer 2 (the only one we use
-// currently).  for the others, it should end the tone, but won't restore
-// proper PWM functionality for the timer.
-void disableTimer(uint8_t _timer)
-{
-  switch (_timer)
-  {
-    case 0:
-      #if defined(TIMSK0)
-        TIMSK0 = 0;
-      #elif defined(TIMSK)
-        TIMSK = 0; // atmega32
-      #endif
-      break;
-
-#if defined(TIMSK1) && defined(OCIE1A)
-    case 1:
-      bitWrite(TIMSK1, OCIE1A, 0);
-      break;
-#endif
-
-    case 2:
-      #if defined(TIMSK2) && defined(OCIE2A)
-        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
-      #endif
-      #if defined(TCCR2A) && defined(WGM20)
-        TCCR2A = (1 << WGM20);
-      #endif
-      #if defined(TCCR2B) && defined(CS22)
-        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
-      #endif
-      #if defined(OCR2A)
-        OCR2A = 0;
-      #endif
-      break;
-
-#if defined(TIMSK3)
-    case 3:
-      TIMSK3 = 0;
-      break;
-#endif
-
-#if defined(TIMSK4)
-    case 4:
-      TIMSK4 = 0;
-      break;
-#endif
-
-#if defined(TIMSK5)
-    case 5:
-      TIMSK5 = 0;
-      break;
-#endif
-  }
-}
-
-
-void noTone(uint8_t _pin)
-{
-  int8_t _timer = -1;
-  
-  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
-    if (tone_pins[i] == _pin) {
-      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
-      tone_pins[i] = 255;
-    }
-  }
-  
-  disableTimer(_timer);
-
-  digitalWrite(_pin, 0);
-}
-
-#if 0
-#if !defined(__AVR_ATmega8__)
-ISR(TIMER0_COMPA_vect)
-{
-  if (timer0_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer0_pin_port ^= timer0_pin_mask;
-
-    if (timer0_toggle_count > 0)
-      timer0_toggle_count--;
-  }
-  else
-  {
-    disableTimer(0);
-    *timer0_pin_port &= ~(timer0_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER1_COMPA_vect)
-{
-  if (timer1_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer1_pin_port ^= timer1_pin_mask;
-
-    if (timer1_toggle_count > 0)
-      timer1_toggle_count--;
-  }
-  else
-  {
-    disableTimer(1);
-    *timer1_pin_port &= ~(timer1_pin_mask);  // keep pin low after stop
-  }
-}
-#endif
-
-
-ISR(TIMER2_COMPA_vect)
-{
-
-  if (timer2_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer2_pin_port ^= timer2_pin_mask;
-
-    if (timer2_toggle_count > 0)
-      timer2_toggle_count--;
-  }
-  else
-  {
-    // need to call noTone() so that the tone_pins[] entry is reset, so the
-    // timer gets initialized next time we call tone().
-    // XXX: this assumes timer 2 is always the first one used.
-    noTone(tone_pins[0]);
-//    disableTimer(2);
-//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
-  }
-}
-
-
-
-//#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#if 0
-
-ISR(TIMER3_COMPA_vect)
-{
-  if (timer3_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer3_pin_port ^= timer3_pin_mask;
-
-    if (timer3_toggle_count > 0)
-      timer3_toggle_count--;
-  }
-  else
-  {
-    disableTimer(3);
-    *timer3_pin_port &= ~(timer3_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER4_COMPA_vect)
-{
-  if (timer4_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer4_pin_port ^= timer4_pin_mask;
-
-    if (timer4_toggle_count > 0)
-      timer4_toggle_count--;
-  }
-  else
-  {
-    disableTimer(4);
-    *timer4_pin_port &= ~(timer4_pin_mask);  // keep pin low after stop
-  }
-}
-
-ISR(TIMER5_COMPA_vect)
-{
-  if (timer5_toggle_count != 0)
-  {
-    // toggle the pin
-    *timer5_pin_port ^= timer5_pin_mask;
-
-    if (timer5_toggle_count > 0)
-      timer5_toggle_count--;
-  }
-  else
-  {
-    disableTimer(5);
-    *timer5_pin_port &= ~(timer5_pin_mask);  // keep pin low after stop
-  }
-}
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/WCharacter.h b/Marlin/Sanguino/cores/arduino/WCharacter.h
deleted file mode 100644
index 79733b5..0000000
--- a/Marlin/Sanguino/cores/arduino/WCharacter.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- WCharacter.h - Character utility functions for Wiring & Arduino
- Copyright (c) 2010 Hernando Barragan.  All right reserved.
- 
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Lesser General Public
- License as published by the Free Software Foundation; either
- version 2.1 of the License, or (at your option) any later version.
- 
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Lesser General Public License for more details.
- 
- You should have received a copy of the GNU Lesser General Public
- License along with this library; if not, write to the Free Software
- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#ifndef Character_h
-#define Character_h
-
-#include <ctype.h>
-
-// WCharacter.h prototypes
-inline boolean isAlphaNumeric(int c) __attribute__((always_inline));
-inline boolean isAlpha(int c) __attribute__((always_inline));
-inline boolean isAscii(int c) __attribute__((always_inline));
-inline boolean isWhitespace(int c) __attribute__((always_inline));
-inline boolean isControl(int c) __attribute__((always_inline));
-inline boolean isDigit(int c) __attribute__((always_inline));
-inline boolean isGraph(int c) __attribute__((always_inline));
-inline boolean isLowerCase(int c) __attribute__((always_inline));
-inline boolean isPrintable(int c) __attribute__((always_inline));
-inline boolean isPunct(int c) __attribute__((always_inline));
-inline boolean isSpace(int c) __attribute__((always_inline));
-inline boolean isUpperCase(int c) __attribute__((always_inline));
-inline boolean isHexadecimalDigit(int c) __attribute__((always_inline));
-inline int toAscii(int c) __attribute__((always_inline));
-inline int toLowerCase(int c) __attribute__((always_inline));
-inline int toUpperCase(int c)__attribute__((always_inline));
-
-
-// Checks for an alphanumeric character. 
-// It is equivalent to (isalpha(c) || isdigit(c)).
-inline boolean isAlphaNumeric(int c) 
-{
-  return ( isalnum(c) == 0 ? false : true);
-}
-
-
-// Checks for an alphabetic character. 
-// It is equivalent to (isupper(c) || islower(c)).
-inline boolean isAlpha(int c)
-{
-  return ( isalpha(c) == 0 ? false : true);
-}
-
-
-// Checks whether c is a 7-bit unsigned char value 
-// that fits into the ASCII character set.
-inline boolean isAscii(int c)
-{
-  return ( isascii (c) == 0 ? false : true);
-}
-
-
-// Checks for a blank character, that is, a space or a tab.
-inline boolean isWhitespace(int c)
-{
-  return ( isblank (c) == 0 ? false : true);
-}
-
-
-// Checks for a control character.
-inline boolean isControl(int c)
-{
-  return ( iscntrl (c) == 0 ? false : true);
-}
-
-
-// Checks for a digit (0 through 9).
-inline boolean isDigit(int c)
-{
-  return ( isdigit (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character except space.
-inline boolean isGraph(int c)
-{
-  return ( isgraph (c) == 0 ? false : true);
-}
-
-
-// Checks for a lower-case character.
-inline boolean isLowerCase(int c)
-{
-  return (islower (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character including space.
-inline boolean isPrintable(int c)
-{
-  return ( isprint (c) == 0 ? false : true);
-}
-
-
-// Checks for any printable character which is not a space 
-// or an alphanumeric character.
-inline boolean isPunct(int c)
-{
-  return ( ispunct (c) == 0 ? false : true);
-}
-
-
-// Checks for white-space characters. For the avr-libc library, 
-// these are: space, formfeed ('\f'), newline ('\n'), carriage 
-// return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').
-inline boolean isSpace(int c)
-{
-  return ( isspace (c) == 0 ? false : true);
-}
-
-
-// Checks for an uppercase letter.
-inline boolean isUpperCase(int c)
-{
-  return ( isupper (c) == 0 ? false : true);
-}
-
-
-// Checks for a hexadecimal digits, i.e. one of 0 1 2 3 4 5 6 7 
-// 8 9 a b c d e f A B C D E F.
-inline boolean isHexadecimalDigit(int c)
-{
-  return ( isxdigit (c) == 0 ? false : true);
-}
-
-
-// Converts c to a 7-bit unsigned char value that fits into the 
-// ASCII character set, by clearing the high-order bits.
-inline int toAscii(int c)
-{
-  return toascii (c);
-}
-
-
-// Warning:
-// Many people will be unhappy if you use this function. 
-// This function will convert accented letters into random 
-// characters.
-
-// Converts the letter c to lower case, if possible.
-inline int toLowerCase(int c)
-{
-  return tolower (c);
-}
-
-
-// Converts the letter c to upper case, if possible.
-inline int toUpperCase(int c)
-{
-  return toupper (c);
-}
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WConstants.h b/Marlin/Sanguino/cores/arduino/WConstants.h
deleted file mode 100644
index 3e19ac4..0000000
--- a/Marlin/Sanguino/cores/arduino/WConstants.h
+++ /dev/null
@@ -1 +0,0 @@
-#include "wiring.h"
diff --git a/Marlin/Sanguino/cores/arduino/WInterrupts.c b/Marlin/Sanguino/cores/arduino/WInterrupts.c
deleted file mode 100644
index 3b3e0c9..0000000
--- a/Marlin/Sanguino/cores/arduino/WInterrupts.c
+++ /dev/null
@@ -1,249 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.uniandes.edu.co
-
-  Copyright (c) 2004-05 Hernando Barragan
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  Modified 24 November 2006 by David A. Mellis
-  Modified 1 August 2010 by Mark Sproul
-*/
-
-#include <inttypes.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <avr/pgmspace.h>
-#include <stdio.h>
-
-#include "WConstants.h"
-#include "wiring_private.h"
-
-volatile static voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
-// volatile static voidFuncPtr twiIntFunc;
-
-void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    intFunc[interruptNum] = userFunc;
-    
-    // Configure the interrupt mode (trigger on low input, any change, rising
-    // edge, or falling edge).  The mode constants were chosen to correspond
-    // to the configuration bits in the hardware register, so we simply shift
-    // the mode into place.
-      
-    // Enable the interrupt.
-      
-    switch (interruptNum) {
-#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-      break;
-    case 3:
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-      break;
-    case 4:
-      EICRA = (EICRA & ~((1 << ISC20) | (1 << ISC21))) | (mode << ISC20);
-      EIMSK |= (1 << INT2);
-      break;
-    case 5:
-      EICRA = (EICRA & ~((1 << ISC30) | (1 << ISC31))) | (mode << ISC30);
-      EIMSK |= (1 << INT3);
-      break;
-    case 0:
-      EICRB = (EICRB & ~((1 << ISC40) | (1 << ISC41))) | (mode << ISC40);
-      EIMSK |= (1 << INT4);
-      break;
-    case 1:
-      EICRB = (EICRB & ~((1 << ISC50) | (1 << ISC51))) | (mode << ISC50);
-      EIMSK |= (1 << INT5);
-      break;
-    case 6:
-      EICRB = (EICRB & ~((1 << ISC60) | (1 << ISC61))) | (mode << ISC60);
-      EIMSK |= (1 << INT6);
-      break;
-    case 7:
-      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
-      EIMSK |= (1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      EIMSK |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GICR |= (1 << INT0);
-    #elif defined(MCUCR) && defined(ISC00) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
-      GIMSK |= (1 << INT0);
-    #else
-      #error attachInterrupt not finished for this CPU (case 0)
-    #endif
-      break;
-
-    case 1:
-    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
-      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      EIMSK |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(ISC11) && defined(GICR)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GICR |= (1 << INT1);
-    #elif defined(MCUCR) && defined(ISC10) && defined(GIMSK) && defined(GIMSK)
-      MCUCR = (MCUCR & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
-      GIMSK |= (1 << INT1);
-    #else
-      #warning attachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-  }
-}
-
-void detachInterrupt(uint8_t interruptNum) {
-  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
-    // Disable the interrupt.  (We can't assume that interruptNum is equal
-    // to the number of the EIMSK bit to clear, as this isn't true on the 
-    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
-    switch (interruptNum) {
-#if defined(EICRA) && defined(EICRB) && defined(EIMSK)
-    case 2:
-      EIMSK &= ~(1 << INT0);
-      break;
-    case 3:
-      EIMSK &= ~(1 << INT1);
-      break;
-    case 4:
-      EIMSK &= ~(1 << INT2);
-      break;
-    case 5:
-      EIMSK &= ~(1 << INT3);
-      break;
-    case 0:
-      EIMSK &= ~(1 << INT4);
-      break;
-    case 1:
-      EIMSK &= ~(1 << INT5);
-      break;
-    case 6:
-      EIMSK &= ~(1 << INT6);
-      break;
-    case 7:
-      EIMSK &= ~(1 << INT7);
-      break;
-#else
-    case 0:
-    #if defined(EIMSK) && defined(INT0)
-      EIMSK &= ~(1 << INT0);
-    #elif defined(GICR) && defined(ISC00)
-      GICR &= ~(1 << INT0); // atmega32
-    #elif defined(GIMSK) && defined(INT0)
-      GIMSK &= ~(1 << INT0);
-    #else
-      #error detachInterrupt not finished for this cpu
-    #endif
-      break;
-
-    case 1:
-    #if defined(EIMSK) && defined(INT1)
-      EIMSK &= ~(1 << INT1);
-    #elif defined(GICR) && defined(INT1)
-      GICR &= ~(1 << INT1); // atmega32
-    #elif defined(GIMSK) && defined(INT1)
-      GIMSK &= ~(1 << INT1);
-    #else
-      #warning detachInterrupt may need some more work for this cpu (case 1)
-    #endif
-      break;
-#endif
-    }
-      
-    intFunc[interruptNum] = 0;
-  }
-}
-
-/*
-void attachInterruptTwi(void (*userFunc)(void) ) {
-  twiIntFunc = userFunc;
-}
-*/
-
-#if defined(EICRA) && defined(EICRB)
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_2])
-    intFunc[EXTERNAL_INT_2]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_3])
-    intFunc[EXTERNAL_INT_3]();
-}
-
-SIGNAL(INT2_vect) {
-  if(intFunc[EXTERNAL_INT_4])
-    intFunc[EXTERNAL_INT_4]();
-}
-
-SIGNAL(INT3_vect) {
-  if(intFunc[EXTERNAL_INT_5])
-    intFunc[EXTERNAL_INT_5]();
-}
-
-SIGNAL(INT4_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT5_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-SIGNAL(INT6_vect) {
-  if(intFunc[EXTERNAL_INT_6])
-    intFunc[EXTERNAL_INT_6]();
-}
-
-SIGNAL(INT7_vect) {
-  if(intFunc[EXTERNAL_INT_7])
-    intFunc[EXTERNAL_INT_7]();
-}
-
-#else
-
-SIGNAL(INT0_vect) {
-  if(intFunc[EXTERNAL_INT_0])
-    intFunc[EXTERNAL_INT_0]();
-}
-
-SIGNAL(INT1_vect) {
-  if(intFunc[EXTERNAL_INT_1])
-    intFunc[EXTERNAL_INT_1]();
-}
-
-#endif
-
-/*
-SIGNAL(SIG_2WIRE_SERIAL) {
-  if(twiIntFunc)
-    twiIntFunc();
-}
-*/
-
diff --git a/Marlin/Sanguino/cores/arduino/WMath.cpp b/Marlin/Sanguino/cores/arduino/WMath.cpp
deleted file mode 100644
index 2120c4c..0000000
--- a/Marlin/Sanguino/cores/arduino/WMath.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- mode: jde; c-basic-offset: 2; indent-tabs-mode: nil -*- */
-
-/*
-  Part of the Wiring project - http://wiring.org.co
-  Copyright (c) 2004-06 Hernando Barragan
-  Modified 13 August 2006, David A. Mellis for Arduino - http://www.arduino.cc/
-  
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-  
-  $Id$
-*/
-
-extern "C" {
-  #include "stdlib.h"
-}
-
-void randomSeed(unsigned int seed)
-{
-  if (seed != 0) {
-    srandom(seed);
-  }
-}
-
-long random(long howbig)
-{
-  if (howbig == 0) {
-    return 0;
-  }
-  return random() % howbig;
-}
-
-long random(long howsmall, long howbig)
-{
-  if (howsmall >= howbig) {
-    return howsmall;
-  }
-  long diff = howbig - howsmall;
-  return random(diff) + howsmall;
-}
-
-long map(long x, long in_min, long in_max, long out_min, long out_max)
-{
-  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
-}
-
-unsigned int makeWord(unsigned int w) { return w; }
-unsigned int makeWord(unsigned char h, unsigned char l) { return (h << 8) | l; }
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WProgram.h b/Marlin/Sanguino/cores/arduino/WProgram.h
deleted file mode 100644
index f73e760..0000000
--- a/Marlin/Sanguino/cores/arduino/WProgram.h
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifndef WProgram_h
-#define WProgram_h
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include <avr/interrupt.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-#include "WCharacter.h"
-#include "WString.h"
-#include "HardwareSerial.h"
-
-uint16_t makeWord(uint16_t w);
-uint16_t makeWord(byte h, byte l);
-
-#define word(...) makeWord(__VA_ARGS__)
-
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout = 1000000L);
-
-void tone(uint8_t _pin, unsigned int frequency, unsigned long duration = 0);
-void noTone(uint8_t _pin);
-
-// WMath prototypes
-long random(long);
-long random(long, long);
-void randomSeed(unsigned int);
-long map(long, long, long, long, long);
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-const static uint8_t A0 = 54;
-const static uint8_t A1 = 55;
-const static uint8_t A2 = 56;
-const static uint8_t A3 = 57;
-const static uint8_t A4 = 58;
-const static uint8_t A5 = 59;
-const static uint8_t A6 = 60;
-const static uint8_t A7 = 61;
-const static uint8_t A8 = 62;
-const static uint8_t A9 = 63;
-const static uint8_t A10 = 64;
-const static uint8_t A11 = 65;
-const static uint8_t A12 = 66;
-const static uint8_t A13 = 67;
-const static uint8_t A14 = 68;
-const static uint8_t A15 = 69;
-#else
-const static uint8_t A0 = 14;
-const static uint8_t A1 = 15;
-const static uint8_t A2 = 16;
-const static uint8_t A3 = 17;
-const static uint8_t A4 = 18;
-const static uint8_t A5 = 19;
-const static uint8_t A6 = 20;
-const static uint8_t A7 = 21;
-#endif
-
-#endif
-
-#endif
\ No newline at end of file
diff --git a/Marlin/Sanguino/cores/arduino/WString.cpp b/Marlin/Sanguino/cores/arduino/WString.cpp
deleted file mode 100644
index db5a441..0000000
--- a/Marlin/Sanguino/cores/arduino/WString.cpp
+++ /dev/null
@@ -1,443 +0,0 @@
-/*
-  WString.cpp - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All rights reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <stdlib.h>
-#include "WProgram.h"
-#include "WString.h"
-
-
-String::String( const char *value )
-{
-  if ( value == NULL )
-    value = "";
-  getBuffer( _length = strlen( value ) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value );
-}
-
-String::String( const String &value )
-{
-  getBuffer( _length = value._length );
-  if ( _buffer != NULL )
-    strcpy( _buffer, value._buffer );
-}
-
-String::String( const char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL ) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const unsigned char value )
-{
-  _length = 1;
-  getBuffer(1);
-  if ( _buffer != NULL) {
-    _buffer[0] = value;
-    _buffer[1] = 0;
-  }
-}
-
-String::String( const int value, const int base )
-{
-  char buf[33];   
-  itoa((signed long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned int value, const int base )
-{
-  char buf[33];   
-  ultoa((unsigned long)value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const long value, const int base )
-{
-  char buf[33];   
-  ltoa(value, buf, base);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-String::String( const unsigned long value, const int base )
-{
-  char buf[33];   
-  ultoa(value, buf, 10);
-  getBuffer( _length = strlen(buf) );
-  if ( _buffer != NULL )
-    strcpy( _buffer, buf );
-}
-
-char String::charAt( unsigned int loc ) const
-{
-  return operator[]( loc );
-}
-
-void String::setCharAt( unsigned int loc, const char aChar ) 
-{
-  if(_buffer == NULL) return;
-  if(_length > loc) {
-    _buffer[loc] = aChar;
-  }
-}
-
-int String::compareTo( const String &s2 ) const
-{
-  return strcmp( _buffer, s2._buffer );
-}
-
-const String & String::concat( const String &s2 )
-{
-  return (*this) += s2;
-}
-
-const String & String::operator=( const String &rhs )
-{
-  if ( this == &rhs )
-    return *this;
-
-  if ( rhs._length > _length )
-  {
-    free(_buffer);
-    getBuffer( rhs._length );
-  }
-  
-  if ( _buffer != NULL ) {
-    _length = rhs._length;
-    strcpy( _buffer, rhs._buffer );
-  }
-  return *this;
-}
-
-//const String & String::operator+=( const char aChar )
-//{
-//  if ( _length == _capacity )
-//    doubleBuffer();
-//
-//  _buffer[ _length++ ] = aChar;
-//  _buffer[ _length ] = '\0';
-//  return *this;
-//}
-
-const String & String::operator+=( const String &other )
-{
-  _length += other._length;
-  if ( _length > _capacity )
-  {
-    char *temp = (char *)realloc(_buffer, _length + 1);
-    if ( temp != NULL ) {
-      _buffer = temp;
-      _capacity = _length;
-    } else {
-      _length -= other._length;
-      return *this;
-    }
-  }
-  strcat( _buffer, other._buffer );
-  return *this;
-}
-
-
-int String::operator==( const String &rhs ) const
-{
-  return ( _length == rhs._length && strcmp( _buffer, rhs._buffer ) == 0 );
-}
-
-int String::operator!=( const String &rhs ) const
-{
-  return ( _length != rhs.length() || strcmp( _buffer, rhs._buffer ) != 0 );
-}
-
-int String::operator<( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) < 0;
-}
-
-int String::operator>( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) > 0;
-}
-
-int String::operator<=( const String &rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) <= 0;
-}
-
-int String::operator>=( const String & rhs ) const
-{
-  return strcmp( _buffer, rhs._buffer ) >= 0;
-}
-
-char & String::operator[]( unsigned int index )
-{
-  static char dummy_writable_char;
-  if (index >= _length || !_buffer) {
-    dummy_writable_char = 0;
-    return dummy_writable_char;
-  }
-  return _buffer[ index ];
-}
-
-char String::operator[]( unsigned int index ) const
-{
-  // need to check for valid index, to do later
-  return _buffer[ index ];
-}
-
-boolean String::endsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return strcmp( &_buffer[ _length - s2._length], s2._buffer ) == 0;
-}
-
-boolean String::equals( const String &s2 ) const
-{
-  return ( _length == s2._length && strcmp( _buffer,s2._buffer ) == 0 );
-}
-
-boolean String::equalsIgnoreCase( const String &s2 ) const
-{
-  if ( this == &s2 )
-    return true; //1;
-  else if ( _length != s2._length )
-    return false; //0;
-
-  return strcmp(toLowerCase()._buffer, s2.toLowerCase()._buffer) == 0;
-}
-
-String String::replace( char findChar, char replaceChar )
-{
-  if ( _buffer == NULL ) return *this;
-  String theReturn = _buffer;
-  char* temp = theReturn._buffer;
-  while( (temp = strchr( temp, findChar )) != 0 )
-    *temp = replaceChar;
-
-  return theReturn;
-}
-
-String String::replace( const String& match, const String& replace )
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer, newString;
-
-  int loc;
-  while ( (loc = temp.indexOf( match )) != -1 )
-  {
-    newString += temp.substring( 0, loc );
-    newString += replace;
-    temp = temp.substring( loc + match._length );
-  }
-  newString += temp;  
-  return newString;
-}
-
-int String::indexOf( char temp ) const
-{
-  return indexOf( temp, 0 );
-}
-
-int String::indexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char* temp = strchr( &_buffer[fromIndex], ch );
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::indexOf( const String &s2 ) const
-{
-  return indexOf( s2, 0 );
-}
-
-int String::indexOf( const String &s2, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  const char *theFind = strstr( &_buffer[ fromIndex ], s2._buffer );
-
-  if ( theFind == NULL )
-    return -1;
-
-  return theFind - _buffer; // pointer subtraction
-}
-
-int String::lastIndexOf( char theChar ) const
-{
-  return lastIndexOf( theChar, _length - 1 );
-}
-
-int String::lastIndexOf( char ch, unsigned int fromIndex ) const
-{
-  if ( fromIndex >= _length )
-    return -1;
-
-  char tempchar = _buffer[fromIndex + 1];
-  _buffer[fromIndex + 1] = '\0';
-  char* temp = strrchr( _buffer, ch );
-  _buffer[fromIndex + 1] = tempchar;
-
-  if ( temp == NULL )
-    return -1;
-
-  return temp - _buffer;
-}
-
-int String::lastIndexOf( const String &s2 ) const
-{
-  return lastIndexOf( s2, _length - s2._length );
-}
-
-int String::lastIndexOf( const String &s2, unsigned int fromIndex ) const
-{
-  // check for empty strings
-  if ( s2._length == 0 || s2._length - 1 > fromIndex || fromIndex >= _length )
-    return -1;
-
-  // matching first character
-  char temp = s2[ 0 ];
-
-  for ( int i = fromIndex; i >= 0; i-- )
-  {
-    if ( _buffer[ i ] == temp && (*this).substring( i, i + s2._length ).equals( s2 ) )
-    return i;
-  }
-  return -1;
-}
-
-boolean String::startsWith( const String &s2 ) const
-{
-  if ( _length < s2._length )
-    return 0;
-
-  return startsWith( s2, 0 );
-}
-
-boolean String::startsWith( const String &s2, unsigned int offset ) const
-{
-  if ( offset > _length - s2._length )
-    return 0;
-
-  return strncmp( &_buffer[offset], s2._buffer, s2._length ) == 0;
-}
-
-String String::substring( unsigned int left ) const
-{
-  return substring( left, _length );
-}
-
-String String::substring( unsigned int left, unsigned int right ) const
-{
-  if ( left > right )
-  {
-    int temp = right;
-    right = left;
-    left = temp;
-  }
-
-  if ( right > _length )
-  {
-    right = _length;
-  } 
-
-  char temp = _buffer[ right ];  // save the replaced character
-  _buffer[ right ] = '\0';	
-  String outPut = ( _buffer + left );  // pointer arithmetic
-  _buffer[ right ] = temp;  //restore character
-  return outPut;
-}
-
-String String::toLowerCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)tolower( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::toUpperCase() const
-{
-  String temp = _buffer;
-
-  for ( unsigned int i = 0; i < _length; i++ )
-    temp._buffer[ i ] = (char)toupper( temp._buffer[ i ] );
-  return temp;
-}
-
-String String::trim() const
-{
-  if ( _buffer == NULL ) return *this;
-  String temp = _buffer;
-  unsigned int i,j;
-
-  for ( i = 0; i < _length; i++ )
-  {
-    if ( !isspace(_buffer[i]) )
-      break;
-  }
-
-  for ( j = temp._length - 1; j > i; j-- )
-  {
-    if ( !isspace(_buffer[j]) )
-      break;
-  }
-
-  return temp.substring( i, j + 1);
-}
-
-void String::getBytes(unsigned char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy((char *)buf, _buffer, len);
-  buf[len] = 0;
-}
-
-void String::toCharArray(char *buf, unsigned int bufsize)
-{
-  if (!bufsize || !buf) return;
-  unsigned int len = bufsize - 1;
-  if (len > _length) len = _length;
-  strncpy(buf, _buffer, len);
-  buf[len] = 0;
-}
-
-
-long String::toInt() {
-  return atol(_buffer);
-}
diff --git a/Marlin/Sanguino/cores/arduino/WString.h b/Marlin/Sanguino/cores/arduino/WString.h
deleted file mode 100644
index cadddb9..0000000
--- a/Marlin/Sanguino/cores/arduino/WString.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  WString.h - String library for Wiring & Arduino
-  Copyright (c) 2009-10 Hernando Barragan.  All right reserved.
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with this library; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#ifndef String_h
-#define String_h
-
-//#include "WProgram.h"
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-class String
-{
-  public:
-    // constructors
-    String( const char *value = "" );
-    String( const String &value );
-    String( const char );
-    String( const unsigned char );
-    String( const int, const int base=10);
-    String( const unsigned int, const int base=10 );
-    String( const long, const int base=10 );
-    String( const unsigned long, const int base=10 );
-    ~String() { free(_buffer); _length = _capacity = 0;}     //added _length = _capacity = 0;
-
-    // operators
-    const String & operator = ( const String &rhs );
-    const String & operator +=( const String &rhs );
-    //const String & operator +=( const char );
-    int operator ==( const String &rhs ) const;
-    int	operator !=( const String &rhs ) const;
-    int	operator < ( const String &rhs ) const;
-    int	operator > ( const String &rhs ) const;
-    int	operator <=( const String &rhs ) const;
-    int	operator >=( const String &rhs ) const;
-    char operator []( unsigned int index ) const;
-    char& operator []( unsigned int index );
-    //operator const char *() const { return _buffer; }
-    
-    // general methods
-    char charAt( unsigned int index ) const;
-    int	compareTo( const String &anotherString ) const;
-    unsigned char endsWith( const String &suffix ) const;
-    unsigned char equals( const String &anObject ) const;
-    unsigned char equalsIgnoreCase( const String &anotherString ) const;
-    int	indexOf( char ch ) const;
-    int	indexOf( char ch, unsigned int fromIndex ) const;
-    int	indexOf( const String &str ) const;
-    int	indexOf( const String &str, unsigned int fromIndex ) const;
-    int	lastIndexOf( char ch ) const;
-    int	lastIndexOf( char ch, unsigned int fromIndex ) const;
-    int	lastIndexOf( const String &str ) const;
-    int	lastIndexOf( const String &str, unsigned int fromIndex ) const;
-    const unsigned int length( ) const { return _length; }
-    void setCharAt(unsigned int index, const char ch);
-    unsigned char startsWith( const String &prefix ) const;
-    unsigned char startsWith( const String &prefix, unsigned int toffset ) const;
-    String substring( unsigned int beginIndex ) const;
-    String substring( unsigned int beginIndex, unsigned int endIndex ) const;
-    String toLowerCase( ) const;
-    String toUpperCase( ) const;
-    String trim( ) const;
-    void getBytes(unsigned char *buf, unsigned int bufsize);
-    void toCharArray(char *buf, unsigned int bufsize);
-    long toInt( );
-    const String& concat( const String &str );
-    String replace( char oldChar, char newChar );
-    String replace( const String& match, const String& replace );
-    friend String operator + ( String lhs, const String &rhs );
-
-  protected:
-    char *_buffer;	     // the actual char array
-    unsigned int _capacity;  // the array length minus one (for the '\0')
-    unsigned int _length;    // the String length (not counting the '\0')
-
-    void getBuffer(unsigned int maxStrLen);
-
-  private:
-
-};
-
-// allocate buffer space
-inline void String::getBuffer(unsigned int maxStrLen)
-{
-  _capacity = maxStrLen;
-  _buffer = (char *) malloc(_capacity + 1);
-  if (_buffer == NULL) _length = _capacity = 0;
-}
-
-inline String operator+( String lhs, const String &rhs )
-{
-  return lhs += rhs;
-}
-
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/binary.h b/Marlin/Sanguino/cores/arduino/binary.h
deleted file mode 100644
index af14980..0000000
--- a/Marlin/Sanguino/cores/arduino/binary.h
+++ /dev/null
@@ -1,515 +0,0 @@
-#ifndef Binary_h
-#define Binary_h
-
-#define B0 0
-#define B00 0
-#define B000 0
-#define B0000 0
-#define B00000 0
-#define B000000 0
-#define B0000000 0
-#define B00000000 0
-#define B1 1
-#define B01 1
-#define B001 1
-#define B0001 1
-#define B00001 1
-#define B000001 1
-#define B0000001 1
-#define B00000001 1
-#define B10 2
-#define B010 2
-#define B0010 2
-#define B00010 2
-#define B000010 2
-#define B0000010 2
-#define B00000010 2
-#define B11 3
-#define B011 3
-#define B0011 3
-#define B00011 3
-#define B000011 3
-#define B0000011 3
-#define B00000011 3
-#define B100 4
-#define B0100 4
-#define B00100 4
-#define B000100 4
-#define B0000100 4
-#define B00000100 4
-#define B101 5
-#define B0101 5
-#define B00101 5
-#define B000101 5
-#define B0000101 5
-#define B00000101 5
-#define B110 6
-#define B0110 6
-#define B00110 6
-#define B000110 6
-#define B0000110 6
-#define B00000110 6
-#define B111 7
-#define B0111 7
-#define B00111 7
-#define B000111 7
-#define B0000111 7
-#define B00000111 7
-#define B1000 8
-#define B01000 8
-#define B001000 8
-#define B0001000 8
-#define B00001000 8
-#define B1001 9
-#define B01001 9
-#define B001001 9
-#define B0001001 9
-#define B00001001 9
-#define B1010 10
-#define B01010 10
-#define B001010 10
-#define B0001010 10
-#define B00001010 10
-#define B1011 11
-#define B01011 11
-#define B001011 11
-#define B0001011 11
-#define B00001011 11
-#define B1100 12
-#define B01100 12
-#define B001100 12
-#define B0001100 12
-#define B00001100 12
-#define B1101 13
-#define B01101 13
-#define B001101 13
-#define B0001101 13
-#define B00001101 13
-#define B1110 14
-#define B01110 14
-#define B001110 14
-#define B0001110 14
-#define B00001110 14
-#define B1111 15
-#define B01111 15
-#define B001111 15
-#define B0001111 15
-#define B00001111 15
-#define B10000 16
-#define B010000 16
-#define B0010000 16
-#define B00010000 16
-#define B10001 17
-#define B010001 17
-#define B0010001 17
-#define B00010001 17
-#define B10010 18
-#define B010010 18
-#define B0010010 18
-#define B00010010 18
-#define B10011 19
-#define B010011 19
-#define B0010011 19
-#define B00010011 19
-#define B10100 20
-#define B010100 20
-#define B0010100 20
-#define B00010100 20
-#define B10101 21
-#define B010101 21
-#define B0010101 21
-#define B00010101 21
-#define B10110 22
-#define B010110 22
-#define B0010110 22
-#define B00010110 22
-#define B10111 23
-#define B010111 23
-#define B0010111 23
-#define B00010111 23
-#define B11000 24
-#define B011000 24
-#define B0011000 24
-#define B00011000 24
-#define B11001 25
-#define B011001 25
-#define B0011001 25
-#define B00011001 25
-#define B11010 26
-#define B011010 26
-#define B0011010 26
-#define B00011010 26
-#define B11011 27
-#define B011011 27
-#define B0011011 27
-#define B00011011 27
-#define B11100 28
-#define B011100 28
-#define B0011100 28
-#define B00011100 28
-#define B11101 29
-#define B011101 29
-#define B0011101 29
-#define B00011101 29
-#define B11110 30
-#define B011110 30
-#define B0011110 30
-#define B00011110 30
-#define B11111 31
-#define B011111 31
-#define B0011111 31
-#define B00011111 31
-#define B100000 32
-#define B0100000 32
-#define B00100000 32
-#define B100001 33
-#define B0100001 33
-#define B00100001 33
-#define B100010 34
-#define B0100010 34
-#define B00100010 34
-#define B100011 35
-#define B0100011 35
-#define B00100011 35
-#define B100100 36
-#define B0100100 36
-#define B00100100 36
-#define B100101 37
-#define B0100101 37
-#define B00100101 37
-#define B100110 38
-#define B0100110 38
-#define B00100110 38
-#define B100111 39
-#define B0100111 39
-#define B00100111 39
-#define B101000 40
-#define B0101000 40
-#define B00101000 40
-#define B101001 41
-#define B0101001 41
-#define B00101001 41
-#define B101010 42
-#define B0101010 42
-#define B00101010 42
-#define B101011 43
-#define B0101011 43
-#define B00101011 43
-#define B101100 44
-#define B0101100 44
-#define B00101100 44
-#define B101101 45
-#define B0101101 45
-#define B00101101 45
-#define B101110 46
-#define B0101110 46
-#define B00101110 46
-#define B101111 47
-#define B0101111 47
-#define B00101111 47
-#define B110000 48
-#define B0110000 48
-#define B00110000 48
-#define B110001 49
-#define B0110001 49
-#define B00110001 49
-#define B110010 50
-#define B0110010 50
-#define B00110010 50
-#define B110011 51
-#define B0110011 51
-#define B00110011 51
-#define B110100 52
-#define B0110100 52
-#define B00110100 52
-#define B110101 53
-#define B0110101 53
-#define B00110101 53
-#define B110110 54
-#define B0110110 54
-#define B00110110 54
-#define B110111 55
-#define B0110111 55
-#define B00110111 55
-#define B111000 56
-#define B0111000 56
-#define B00111000 56
-#define B111001 57
-#define B0111001 57
-#define B00111001 57
-#define B111010 58
-#define B0111010 58
-#define B00111010 58
-#define B111011 59
-#define B0111011 59
-#define B00111011 59
-#define B111100 60
-#define B0111100 60
-#define B00111100 60
-#define B111101 61
-#define B0111101 61
-#define B00111101 61
-#define B111110 62
-#define B0111110 62
-#define B00111110 62
-#define B111111 63
-#define B0111111 63
-#define B00111111 63
-#define B1000000 64
-#define B01000000 64
-#define B1000001 65
-#define B01000001 65
-#define B1000010 66
-#define B01000010 66
-#define B1000011 67
-#define B01000011 67
-#define B1000100 68
-#define B01000100 68
-#define B1000101 69
-#define B01000101 69
-#define B1000110 70
-#define B01000110 70
-#define B1000111 71
-#define B01000111 71
-#define B1001000 72
-#define B01001000 72
-#define B1001001 73
-#define B01001001 73
-#define B1001010 74
-#define B01001010 74
-#define B1001011 75
-#define B01001011 75
-#define B1001100 76
-#define B01001100 76
-#define B1001101 77
-#define B01001101 77
-#define B1001110 78
-#define B01001110 78
-#define B1001111 79
-#define B01001111 79
-#define B1010000 80
-#define B01010000 80
-#define B1010001 81
-#define B01010001 81
-#define B1010010 82
-#define B01010010 82
-#define B1010011 83
-#define B01010011 83
-#define B1010100 84
-#define B01010100 84
-#define B1010101 85
-#define B01010101 85
-#define B1010110 86
-#define B01010110 86
-#define B1010111 87
-#define B01010111 87
-#define B1011000 88
-#define B01011000 88
-#define B1011001 89
-#define B01011001 89
-#define B1011010 90
-#define B01011010 90
-#define B1011011 91
-#define B01011011 91
-#define B1011100 92
-#define B01011100 92
-#define B1011101 93
-#define B01011101 93
-#define B1011110 94
-#define B01011110 94
-#define B1011111 95
-#define B01011111 95
-#define B1100000 96
-#define B01100000 96
-#define B1100001 97
-#define B01100001 97
-#define B1100010 98
-#define B01100010 98
-#define B1100011 99
-#define B01100011 99
-#define B1100100 100
-#define B01100100 100
-#define B1100101 101
-#define B01100101 101
-#define B1100110 102
-#define B01100110 102
-#define B1100111 103
-#define B01100111 103
-#define B1101000 104
-#define B01101000 104
-#define B1101001 105
-#define B01101001 105
-#define B1101010 106
-#define B01101010 106
-#define B1101011 107
-#define B01101011 107
-#define B1101100 108
-#define B01101100 108
-#define B1101101 109
-#define B01101101 109
-#define B1101110 110
-#define B01101110 110
-#define B1101111 111
-#define B01101111 111
-#define B1110000 112
-#define B01110000 112
-#define B1110001 113
-#define B01110001 113
-#define B1110010 114
-#define B01110010 114
-#define B1110011 115
-#define B01110011 115
-#define B1110100 116
-#define B01110100 116
-#define B1110101 117
-#define B01110101 117
-#define B1110110 118
-#define B01110110 118
-#define B1110111 119
-#define B01110111 119
-#define B1111000 120
-#define B01111000 120
-#define B1111001 121
-#define B01111001 121
-#define B1111010 122
-#define B01111010 122
-#define B1111011 123
-#define B01111011 123
-#define B1111100 124
-#define B01111100 124
-#define B1111101 125
-#define B01111101 125
-#define B1111110 126
-#define B01111110 126
-#define B1111111 127
-#define B01111111 127
-#define B10000000 128
-#define B10000001 129
-#define B10000010 130
-#define B10000011 131
-#define B10000100 132
-#define B10000101 133
-#define B10000110 134
-#define B10000111 135
-#define B10001000 136
-#define B10001001 137
-#define B10001010 138
-#define B10001011 139
-#define B10001100 140
-#define B10001101 141
-#define B10001110 142
-#define B10001111 143
-#define B10010000 144
-#define B10010001 145
-#define B10010010 146
-#define B10010011 147
-#define B10010100 148
-#define B10010101 149
-#define B10010110 150
-#define B10010111 151
-#define B10011000 152
-#define B10011001 153
-#define B10011010 154
-#define B10011011 155
-#define B10011100 156
-#define B10011101 157
-#define B10011110 158
-#define B10011111 159
-#define B10100000 160
-#define B10100001 161
-#define B10100010 162
-#define B10100011 163
-#define B10100100 164
-#define B10100101 165
-#define B10100110 166
-#define B10100111 167
-#define B10101000 168
-#define B10101001 169
-#define B10101010 170
-#define B10101011 171
-#define B10101100 172
-#define B10101101 173
-#define B10101110 174
-#define B10101111 175
-#define B10110000 176
-#define B10110001 177
-#define B10110010 178
-#define B10110011 179
-#define B10110100 180
-#define B10110101 181
-#define B10110110 182
-#define B10110111 183
-#define B10111000 184
-#define B10111001 185
-#define B10111010 186
-#define B10111011 187
-#define B10111100 188
-#define B10111101 189
-#define B10111110 190
-#define B10111111 191
-#define B11000000 192
-#define B11000001 193
-#define B11000010 194
-#define B11000011 195
-#define B11000100 196
-#define B11000101 197
-#define B11000110 198
-#define B11000111 199
-#define B11001000 200
-#define B11001001 201
-#define B11001010 202
-#define B11001011 203
-#define B11001100 204
-#define B11001101 205
-#define B11001110 206
-#define B11001111 207
-#define B11010000 208
-#define B11010001 209
-#define B11010010 210
-#define B11010011 211
-#define B11010100 212
-#define B11010101 213
-#define B11010110 214
-#define B11010111 215
-#define B11011000 216
-#define B11011001 217
-#define B11011010 218
-#define B11011011 219
-#define B11011100 220
-#define B11011101 221
-#define B11011110 222
-#define B11011111 223
-#define B11100000 224
-#define B11100001 225
-#define B11100010 226
-#define B11100011 227
-#define B11100100 228
-#define B11100101 229
-#define B11100110 230
-#define B11100111 231
-#define B11101000 232
-#define B11101001 233
-#define B11101010 234
-#define B11101011 235
-#define B11101100 236
-#define B11101101 237
-#define B11101110 238
-#define B11101111 239
-#define B11110000 240
-#define B11110001 241
-#define B11110010 242
-#define B11110011 243
-#define B11110100 244
-#define B11110101 245
-#define B11110110 246
-#define B11110111 247
-#define B11111000 248
-#define B11111001 249
-#define B11111010 250
-#define B11111011 251
-#define B11111100 252
-#define B11111101 253
-#define B11111110 254
-#define B11111111 255
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/main.cpp b/Marlin/Sanguino/cores/arduino/main.cpp
deleted file mode 100644
index cc6e81d..0000000
--- a/Marlin/Sanguino/cores/arduino/main.cpp
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <WProgram.h>
-
-int main(void)
-{
-	init();
-
-	setup();
-    
-	for (;;)
-		loop();
-        
-	return 0;
-}
-
diff --git a/Marlin/Sanguino/cores/arduino/pins_arduino.c b/Marlin/Sanguino/cores/arduino/pins_arduino.c
deleted file mode 100644
index d5fa6fe..0000000
--- a/Marlin/Sanguino/cores/arduino/pins_arduino.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
-  pins_arduino.c - pin definitions for the Arduino board
-  Part of Arduino / Wiring Lite
-
-  Copyright (c) 2005 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: pins_arduino.c 254 2007-04-20 23:17:38Z mellis $
-*/
-
-#include <avr/io.h>
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-// On the Sanguino board, digital pins are also used
-// for the analog output (software PWM).  Analog input
-// pins are a separate set.
-
-// ATMEL ATMEGA644P / SANGUINO
-//
-//                   +---\/---+
-//  INT0 (D 0) PB0  1|        |40  PA0 (AI 0 / D31)
-//  INT1 (D 1) PB1  2|        |39  PA1 (AI 1 / D30)
-//  INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)
-//   PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)
-//   PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)
-//  MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)
-//  MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)
-//   SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)
-//             RST  9|        |32  AREF
-//             VCC 10|        |31  GND 
-//             GND 11|        |30  AVCC
-//           XTAL2 12|        |29  PC7 (D 23)
-//           XTAL1 13|        |28  PC6 (D 22)
-//  RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI
-//  TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO
-//  RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS
-//  TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK
-//  PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA
-//  PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL
-//  PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM
-//                   +--------+
-//
-
-#define PA 1
-#define PB 2
-#define PC 3
-#define PD 4
-
-// these arrays map port names (e.g. port B) to the
-// appropriate addresses for various functions (e.g. reading
-// and writing)
-const uint8_t PROGMEM port_to_mode_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &DDRA,
-	(uint8_t) (uint16_t) &DDRB,
-	(uint8_t) (uint16_t) &DDRC,
-	(uint8_t) (uint16_t) &DDRD,
-};
-
-const uint8_t PROGMEM port_to_output_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &PORTA,
-	(uint8_t) (uint16_t) &PORTB,
-	(uint8_t) (uint16_t) &PORTC,
-	(uint8_t) (uint16_t) &PORTD,
-};
-
-const uint8_t PROGMEM port_to_input_PGM[] =
-{
-	NOT_A_PORT,
-	(uint8_t) (uint16_t) &PINA,
-	(uint8_t) (uint16_t) &PINB,
-	(uint8_t) (uint16_t) &PINC,
-	(uint8_t) (uint16_t) &PIND,
-};
-
-const uint8_t PROGMEM digital_pin_to_port_PGM[] =
-{
-	PB, /* 0 */
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PB,
-	PD, /* 8 */
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PD,
-	PC, /* 16 */
-	PC,
-	PC,
-	PC,
-	PC,
-	PC,
-   	PC,
-	PC,
-	PA, /* 24 */
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA,
-	PA  /* 31 */
-};
-
-const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] =
-{
-	_BV(0), /* 0, port B */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 8, port D */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(0), /* 16, port C */
-	_BV(1),
-	_BV(2),
-	_BV(3),
-	_BV(4),
-	_BV(5),
-	_BV(6),
-	_BV(7),
-	_BV(7), /* 24, port A */
-	_BV(6),
-	_BV(5),
-	_BV(4),
-	_BV(3),
-	_BV(2),
-	_BV(1),
-	_BV(0)
-};
-
-const uint8_t PROGMEM digital_pin_to_timer_PGM[] =
-{
-	NOT_ON_TIMER, 	/* 0  - PB0 */
-	NOT_ON_TIMER, 	/* 1  - PB1 */
-	NOT_ON_TIMER, 	/* 2  - PB2 */
-	TIMER0A,     	/* 3  - PB3 */
-	TIMER0B, 		/* 4  - PB4 */
-	NOT_ON_TIMER, 	/* 5  - PB5 */
-	NOT_ON_TIMER, 	/* 6  - PB6 */
-	NOT_ON_TIMER,	/* 7  - PB7 */
-	NOT_ON_TIMER, 	/* 8  - PD0 */
-	NOT_ON_TIMER, 	/* 9  - PD1 */
-	NOT_ON_TIMER, 	/* 10 - PD2 */
-	NOT_ON_TIMER, 	/* 11 - PD3 */
-	TIMER1B,     	/* 12 - PD4 */
-	TIMER1A,     	/* 13 - PD5 */
-	TIMER2B,     	/* 14 - PD6 */
-	TIMER2A,     	/* 15 - PD7 */
-	NOT_ON_TIMER, 	/* 16 - PC0 */
-	NOT_ON_TIMER,   /* 17 - PC1 */
-	NOT_ON_TIMER,   /* 18 - PC2 */
-	NOT_ON_TIMER,   /* 19 - PC3 */
-	NOT_ON_TIMER,   /* 20 - PC4 */
-	NOT_ON_TIMER,   /* 21 - PC5 */
-	NOT_ON_TIMER,   /* 22 - PC6 */
-	NOT_ON_TIMER,   /* 23 - PC7 */
-	NOT_ON_TIMER,   /* 24 - PA0 */
-	NOT_ON_TIMER,   /* 25 - PA1 */
-	NOT_ON_TIMER,   /* 26 - PA2 */
-	NOT_ON_TIMER,   /* 27 - PA3 */
-	NOT_ON_TIMER,   /* 28 - PA4 */
-	NOT_ON_TIMER,   /* 29 - PA5 */
-	NOT_ON_TIMER,   /* 30 - PA6 */
-	NOT_ON_TIMER   /* 31 - PA7 */
-};
diff --git a/Marlin/Sanguino/cores/arduino/pins_arduino.h b/Marlin/Sanguino/cores/arduino/pins_arduino.h
deleted file mode 100644
index fd7ee5c..0000000
--- a/Marlin/Sanguino/cores/arduino/pins_arduino.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
-  pins_arduino.h - Pin definition functions for Arduino
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2007 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
-*/
-
-#ifndef Pins_Arduino_h
-#define Pins_Arduino_h
-
-#include <avr/pgmspace.h>
-
-#define NOT_A_PIN 0
-#define NOT_A_PORT 0
-
-#define NOT_ON_TIMER 0
-#define TIMER0A 1
-#define TIMER0B 2
-#define TIMER1A 3
-#define TIMER1B 4
-#define TIMER2  5
-#define TIMER2A 6
-#define TIMER2B 7
-
-extern const uint8_t PROGMEM port_to_mode_PGM[];
-extern const uint8_t PROGMEM port_to_input_PGM[];
-extern const uint8_t PROGMEM port_to_output_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_port_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];
-extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];
-
-extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];
-
-// Get the bit location within the hardware port of the given virtual pin.
-// This comes from the pins_*.c file for the active board configuration.
-// 
-// These perform slightly better as macros compared to inline functions
-//
-#define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )
-#define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )
-#define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )
-#define analogInPinToBit(P) (P)
-#define portOutputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_output_PGM + (P))) )
-#define portInputRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_input_PGM + (P))) )
-#define portModeRegister(P) ( (volatile uint8_t *)( (uint16_t) pgm_read_byte( port_to_mode_PGM + (P))) )
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring.c b/Marlin/Sanguino/cores/arduino/wiring.c
deleted file mode 100644
index b90d07e..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
-  wiring.c - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#include "wiring_private.h"
-
-// the prescaler is set so that timer0 ticks every 64 clock cycles, and the
-// the overflow handler is called every 256 ticks.
-#define MICROSECONDS_PER_TIMER0_OVERFLOW (clockCyclesToMicroseconds(64 * 256))
-
-// the whole number of milliseconds per timer0 overflow
-#define MILLIS_INC (MICROSECONDS_PER_TIMER0_OVERFLOW / 1000)
-
-// the fractional number of milliseconds per timer0 overflow. we shift right
-// by three to fit these numbers into a byte. (for the clock speeds we care
-// about - 8 and 16 MHz - this doesn't lose precision.)
-#define FRACT_INC ((MICROSECONDS_PER_TIMER0_OVERFLOW % 1000) >> 3)
-#define FRACT_MAX (1000 >> 3)
-
-volatile unsigned long timer0_overflow_count = 0;
-volatile unsigned long timer0_millis = 0;
-static unsigned char timer0_fract = 0;
-
-SIGNAL(TIMER0_OVF_vect)
-{
-	// copy these to local variables so they can be stored in registers
-	// (volatile variables must be read from memory on every access)
-	unsigned long m = timer0_millis;
-	unsigned char f = timer0_fract;
-
-	m += MILLIS_INC;
-	f += FRACT_INC;
-	if (f >= FRACT_MAX) {
-		f -= FRACT_MAX;
-		m += 1;
-	}
-
-	timer0_fract = f;
-	timer0_millis = m;
-	timer0_overflow_count++;
-}
-
-unsigned long millis()
-{
-	unsigned long m;
-	uint8_t oldSREG = SREG;
-
-	// disable interrupts while we read timer0_millis or we might get an
-	// inconsistent value (e.g. in the middle of a write to timer0_millis)
-	cli();
-	m = timer0_millis;
-	SREG = oldSREG;
-
-	return m;
-}
-
-unsigned long micros() {
-	unsigned long m;
-	uint8_t oldSREG = SREG, t;
-	
-	cli();
-	m = timer0_overflow_count;
-#if defined(TCNT0)
-	t = TCNT0;
-#elif defined(TCNT0L)
-	t = TCNT0L;
-#else
-	#error TIMER 0 not defined
-#endif
-
-  
-#ifdef TIFR0
-	if ((TIFR0 & _BV(TOV0)) && (t < 255))
-		m++;
-#else
-	if ((TIFR & _BV(TOV0)) && (t < 255))
-		m++;
-#endif
-
-	SREG = oldSREG;
-	
-	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
-}
-
-void delay(unsigned long ms)
-{
-	uint16_t start = (uint16_t)micros();
-
-	while (ms > 0) {
-		if (((uint16_t)micros() - start) >= 1000) {
-			ms--;
-			start += 1000;
-		}
-	}
-}
-
-/* Delay for the given number of microseconds.  Assumes a 8 or 16 MHz clock. */
-void delayMicroseconds(unsigned int us)
-{
-	// calling avrlib's delay_us() function with low values (e.g. 1 or
-	// 2 microseconds) gives delays longer than desired.
-	//delay_us(us);
-
-#if F_CPU >= 16000000L
-	// for the 16 MHz clock on most Arduino boards
-
-	// for a one-microsecond delay, simply return.  the overhead
-	// of the function call yields a delay of approximately 1 1/8 us.
-	if (--us == 0)
-		return;
-
-	// the following loop takes a quarter of a microsecond (4 cycles)
-	// per iteration, so execute it four times for each microsecond of
-	// delay requested.
-	us <<= 2;
-
-	// account for the time taken in the preceeding commands.
-	us -= 2;
-#else
-	// for the 8 MHz internal clock on the ATmega168
-
-	// for a one- or two-microsecond delay, simply return.  the overhead of
-	// the function calls takes more than two microseconds.  can't just
-	// subtract two, since us is unsigned; we'd overflow.
-	if (--us == 0)
-		return;
-	if (--us == 0)
-		return;
-
-	// the following loop takes half of a microsecond (4 cycles)
-	// per iteration, so execute it twice for each microsecond of
-	// delay requested.
-	us <<= 1;
-    
-	// partially compensate for the time taken by the preceeding commands.
-	// we can't subtract any more than this or we'd overflow w/ small delays.
-	us--;
-#endif
-
-	// busy wait
-	__asm__ __volatile__ (
-		"1: sbiw %0,1" "\n\t" // 2 cycles
-		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
-	);
-}
-
-void init()
-{
-	// this needs to be called before setup() or some functions won't
-	// work there
-	sei();
-	
-	// on the ATmega168, timer 0 is also used for fast hardware pwm
-	// (using phase-correct PWM would mean that timer 0 overflowed half as often
-	// resulting in different millis() behavior on the ATmega8 and ATmega168)
-#if defined(TCCR0A) && defined(WGM01)
-	sbi(TCCR0A, WGM01);
-	sbi(TCCR0A, WGM00);
-#endif  
-
-	// set timer 0 prescale factor to 64
-#if defined(__AVR_ATmega128__)
-	// CPU specific: different values for the ATmega128
-	sbi(TCCR0, CS02);
-#elif defined(TCCR0) && defined(CS01) && defined(CS00)
-	// this combination is for the standard atmega8
-	sbi(TCCR0, CS01);
-	sbi(TCCR0, CS00);
-#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
-	// this combination is for the standard 168/328/1280/2560
-	sbi(TCCR0B, CS01);
-	sbi(TCCR0B, CS00);
-#elif defined(TCCR0A) && defined(CS01) && defined(CS00)
-	// this combination is for the __AVR_ATmega645__ series
-	sbi(TCCR0A, CS01);
-	sbi(TCCR0A, CS00);
-#else
-	#error Timer 0 prescale factor 64 not set correctly
-#endif
-
-	// enable timer 0 overflow interrupt
-#if defined(TIMSK) && defined(TOIE0)
-	sbi(TIMSK, TOIE0);
-#elif defined(TIMSK0) && defined(TOIE0)
-	sbi(TIMSK0, TOIE0);
-#else
-	#error	Timer 0 overflow interrupt not set correctly
-#endif
-
-	// timers 1 and 2 are used for phase-correct hardware pwm
-	// this is better for motors as it ensures an even waveform
-	// note, however, that fast pwm mode can achieve a frequency of up
-	// 8 MHz (with a 16 MHz clock) at 50% duty cycle
-
-	TCCR1B = 0;
-
-	// set timer 1 prescale factor to 64
-#if defined(TCCR1B) && defined(CS11) && defined(CS10)
-	sbi(TCCR1B, CS11);
-	sbi(TCCR1B, CS10);
-#elif defined(TCCR1) && defined(CS11) && defined(CS10)
-	sbi(TCCR1, CS11);
-	sbi(TCCR1, CS10);
-#endif
-	// put timer 1 in 8-bit phase correct pwm mode
-#if defined(TCCR1A) && defined(WGM10)
-	sbi(TCCR1A, WGM10);
-#elif defined(TCCR1)
-	#warning this needs to be finished
-#endif
-
-	// set timer 2 prescale factor to 64
-#if defined(TCCR2) && defined(CS22)
-	sbi(TCCR2, CS22);
-#elif defined(TCCR2B) && defined(CS22)
-	sbi(TCCR2B, CS22);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-	// configure timer 2 for phase correct pwm (8-bit)
-#if defined(TCCR2) && defined(WGM20)
-	sbi(TCCR2, WGM20);
-#elif defined(TCCR2A) && defined(WGM20)
-	sbi(TCCR2A, WGM20);
-#else
-	#warning Timer 2 not finished (may not be present on this CPU)
-#endif
-
-#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
-	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
-	sbi(TCCR3B, CS30);
-	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
-#endif
-	
-#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
-	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
-	sbi(TCCR4B, CS40);
-	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
-	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
-	sbi(TCCR5B, CS50);
-	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
-#endif
-
-#if defined(ADCSRA)
-	// set a2d prescale factor to 128
-	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
-	// XXX: this will not work properly for other clock speeds, and
-	// this code should use F_CPU to determine the prescale factor.
-	sbi(ADCSRA, ADPS2);
-	sbi(ADCSRA, ADPS1);
-	sbi(ADCSRA, ADPS0);
-
-	// enable a2d conversions
-	sbi(ADCSRA, ADEN);
-#endif
-
-	// the bootloader connects pins 0 and 1 to the USART; disconnect them
-	// here so they can be used as normal digital i/o; they will be
-	// reconnected in Serial.begin()
-#if defined(UCSRB)
-	UCSRB = 0;
-#elif defined(UCSR0B)
-	UCSR0B = 0;
-#endif
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring.h b/Marlin/Sanguino/cores/arduino/wiring.h
deleted file mode 100644
index 0a93678..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
-  wiring.h - Partial implementation of the Wiring API for the ATmega8.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id$
-*/
-
-#ifndef Wiring_h
-#define Wiring_h
-
-#include <math.h>
-#include <avr/io.h>
-#include <stdlib.h>
-#include "binary.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#define HIGH 0x1
-#define LOW  0x0
-
-#define INPUT 0x0
-#define OUTPUT 0x1
-
-#define true 0x1
-#define false 0x0
-
-#define PI 3.1415926535897932384626433832795
-#define HALF_PI 1.5707963267948966192313216916398
-#define TWO_PI 6.283185307179586476925286766559
-#define DEG_TO_RAD 0.017453292519943295769236907684886
-#define RAD_TO_DEG 57.295779513082320876798154814105
-
-#define SERIAL  0x0
-#define DISPLAY 0x1
-
-#define LSBFIRST 0
-#define MSBFIRST 1
-
-#define CHANGE 1
-#define FALLING 2
-#define RISING 3
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define INTERNAL1V1 2
-#define INTERNAL2V56 3
-#else
-#define INTERNAL 3
-#endif
-#define DEFAULT 1
-#define EXTERNAL 0
-
-// undefine stdlib's abs if encountered
-#ifdef abs
-#undef abs
-#endif
-
-#define min(a,b) ((a)<(b)?(a):(b))
-#define max(a,b) ((a)>(b)?(a):(b))
-#define abs(x) ((x)>0?(x):-(x))
-#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))
-#define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))
-#define radians(deg) ((deg)*DEG_TO_RAD)
-#define degrees(rad) ((rad)*RAD_TO_DEG)
-#define sq(x) ((x)*(x))
-
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#define clockCyclesPerMicrosecond() ( F_CPU / 1000000L )
-#define clockCyclesToMicroseconds(a) ( ((a) * 1000L) / (F_CPU / 1000L) )
-#define microsecondsToClockCycles(a) ( ((a) * (F_CPU / 1000L)) / 1000L )
-
-#define lowByte(w) ((uint8_t) ((w) & 0xff))
-#define highByte(w) ((uint8_t) ((w) >> 8))
-
-#define bitRead(value, bit) (((value) >> (bit)) & 0x01)
-#define bitSet(value, bit) ((value) |= (1UL << (bit)))
-#define bitClear(value, bit) ((value) &= ~(1UL << (bit)))
-#define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit))
-
-
-typedef unsigned int word;
-
-#define bit(b) (1UL << (b))
-
-typedef uint8_t boolean;
-typedef uint8_t byte;
-
-void init(void);
-
-void pinMode(uint8_t, uint8_t);
-void digitalWrite(uint8_t, uint8_t);
-int digitalRead(uint8_t);
-int analogRead(uint8_t);
-void analogReference(uint8_t mode);
-void analogWrite(uint8_t, int);
-
-unsigned long millis(void);
-unsigned long micros(void);
-void delay(unsigned long);
-void delayMicroseconds(unsigned int us);
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout);
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val);
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder);
-
-void attachInterrupt(uint8_t, void (*)(void), int mode);
-void detachInterrupt(uint8_t);
-
-void setup(void);
-void loop(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring_analog.c b/Marlin/Sanguino/cores/arduino/wiring_analog.c
deleted file mode 100644
index d248f4c..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_analog.c
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
-  wiring_analog.c - analog input and output
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-uint8_t analog_reference = DEFAULT;
-
-void analogReference(uint8_t mode)
-{
-	// can't actually set the register here because the default setting
-	// will connect AVCC and the AREF pin, which would cause a short if
-	// there's something connected to AREF.
-	analog_reference = mode;
-}
-
-int analogRead(uint8_t pin)
-{
-	uint8_t low, high;
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-	if (pin >= 54) pin -= 54; // allow for channel or pin numbers
-#else
-	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
-#endif
-
-#if defined(ADCSRB) && defined(MUX5)
-	// the MUX5 bit of ADCSRB selects whether we're reading from channels
-	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
-	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
-#endif
-  
-	// set the analog reference (high two bits of ADMUX) and select the
-	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
-	// to 0 (the default).
-#if defined(ADMUX)
-	ADMUX = (analog_reference << 6) | (pin & 0x07);
-#endif
-
-	// without a delay, we seem to read from the wrong channel
-	//delay(1);
-
-#if defined(ADCSRA) && defined(ADCL)
-	// start the conversion
-	sbi(ADCSRA, ADSC);
-
-	// ADSC is cleared when the conversion finishes
-	while (bit_is_set(ADCSRA, ADSC));
-
-	// we have to read ADCL first; doing so locks both ADCL
-	// and ADCH until ADCH is read.  reading ADCL second would
-	// cause the results of each conversion to be discarded,
-	// as ADCL and ADCH would be locked when it completed.
-	low  = ADCL;
-	high = ADCH;
-#else
-	// we dont have an ADC, return 0
-	low  = 0;
-	high = 0;
-#endif
-
-	// combine the two bytes
-	return (high << 8) | low;
-}
-
-// Right now, PWM output only works on the pins with
-// hardware support.  These are defined in the appropriate
-// pins_*.c file.  For the rest of the pins, we default
-// to digital output.
-void analogWrite(uint8_t pin, int val)
-{
-	// We need to make sure the PWM output is enabled for those pins
-	// that support it, as we turn it off when digitally reading or
-	// writing with them.  Also, make sure the pin is in output mode
-	// for consistenty with Wiring, which doesn't require a pinMode
-	// call for the analog output pins.
-	pinMode(pin, OUTPUT);
-	if (val == 0)
-	{
-		digitalWrite(pin, LOW);
-	}
-	else if (val == 255)
-	{
-		digitalWrite(pin, HIGH);
-	}
-	else
-	{
-		switch(digitalPinToTimer(pin))
-		{
-			// XXX fix needed for atmega8
-			#if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)
-			case TIMER0A:
-				// connect pwm to pin on timer 0
-				sbi(TCCR0, COM00);
-				OCR0 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0A1)
-			case TIMER0A:
-				// connect pwm to pin on timer 0, channel A
-				sbi(TCCR0A, COM0A1);
-				OCR0A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR0A) && defined(COM0B1)
-			case TIMER0B:
-				// connect pwm to pin on timer 0, channel B
-				sbi(TCCR0A, COM0B1);
-				OCR0B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1A1)
-			case TIMER1A:
-				// connect pwm to pin on timer 1, channel A
-				sbi(TCCR1A, COM1A1);
-				OCR1A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR1A) && defined(COM1B1)
-			case TIMER1B:
-				// connect pwm to pin on timer 1, channel B
-				sbi(TCCR1A, COM1B1);
-				OCR1B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2) && defined(COM21)
-			case TIMER2:
-				// connect pwm to pin on timer 2
-				sbi(TCCR2, COM21);
-				OCR2 = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2A1)
-			case TIMER2A:
-				// connect pwm to pin on timer 2, channel A
-				sbi(TCCR2A, COM2A1);
-				OCR2A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR2A) && defined(COM2B1)
-			case TIMER2B:
-				// connect pwm to pin on timer 2, channel B
-				sbi(TCCR2A, COM2B1);
-				OCR2B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3A1)
-			case TIMER3A:
-				// connect pwm to pin on timer 3, channel A
-				sbi(TCCR3A, COM3A1);
-				OCR3A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3B1)
-			case TIMER3B:
-				// connect pwm to pin on timer 3, channel B
-				sbi(TCCR3A, COM3B1);
-				OCR3B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR3A) && defined(COM3C1)
-			case TIMER3C:
-				// connect pwm to pin on timer 3, channel C
-				sbi(TCCR3A, COM3C1);
-				OCR3C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4A1)
-			case TIMER4A:
-				// connect pwm to pin on timer 4, channel A
-				sbi(TCCR4A, COM4A1);
-				OCR4A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4B1)
-			case TIMER4B:
-				// connect pwm to pin on timer 4, channel B
-				sbi(TCCR4A, COM4B1);
-				OCR4B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR4A) && defined(COM4C1)
-			case TIMER4C:
-				// connect pwm to pin on timer 4, channel C
-				sbi(TCCR4A, COM4C1);
-				OCR4C = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5A1)
-			case TIMER5A:
-				// connect pwm to pin on timer 5, channel A
-				sbi(TCCR5A, COM5A1);
-				OCR5A = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5B1)
-			case TIMER5B:
-				// connect pwm to pin on timer 5, channel B
-				sbi(TCCR5A, COM5B1);
-				OCR5B = val; // set pwm duty
-				break;
-			#endif
-
-			#if defined(TCCR5A) && defined(COM5C1)
-			case TIMER5C:
-				// connect pwm to pin on timer 5, channel C
-				sbi(TCCR5A, COM5C1);
-				OCR5C = val; // set pwm duty
-				break;
-			#endif
-
-			case NOT_ON_TIMER:
-			default:
-				if (val < 128) {
-					digitalWrite(pin, LOW);
-				} else {
-					digitalWrite(pin, HIGH);
-				}
-		}
-	}
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_digital.c b/Marlin/Sanguino/cores/arduino/wiring_digital.c
deleted file mode 100644
index 0949da4..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_digital.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-  wiring_digital.c - digital input and output functions
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  Modified 28 September 2010 by Mark Sproul
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-void pinMode(uint8_t pin, uint8_t mode)
-{
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *reg;
-
-	if (port == NOT_A_PIN) return;
-
-	// JWS: can I let the optimizer do this?
-	reg = portModeRegister(port);
-
-	if (mode == INPUT) { 
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg &= ~bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*reg |= bit;
-		SREG = oldSREG;
-	}
-}
-
-// Forcing this inline keeps the callers from having to push their own stuff
-// on the stack. It is a good performance win and only takes 1 more byte per
-// user than calling. (It will take more bytes on the 168.)
-//
-// But shouldn't this be moved into pinMode? Seems silly to check and do on
-// each digitalread or write.
-//
-// Mark Sproul:
-// - Removed inline. Save 170 bytes on atmega1280
-// - changed to a switch statment; added 32 bytes but much easier to read and maintain.
-// - Added more #ifdefs, now compiles for atmega645
-//
-//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
-//static inline void turnOffPWM(uint8_t timer)
-static void turnOffPWM(uint8_t timer)
-{
-	switch (timer)
-	{
-		#if defined(TCCR1A) && defined(COM1A1)
-		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
-		#endif
-		#if defined(TCCR1A) && defined(COM1B1)
-		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
-		#endif
-		
-		#if defined(TCCR2) && defined(COM21)
-		case  TIMER2:   cbi(TCCR2, COM21);      break;
-		#endif
-		
-		#if defined(TCCR0A) && defined(COM0A1)
-		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
-		#endif
-		
-		#if defined(TIMER0B) && defined(COM0B1)
-		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2A1)
-		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
-		#endif
-		#if defined(TCCR2A) && defined(COM2B1)
-		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
-		#endif
-		
-		#if defined(TCCR3A) && defined(COM3A1)
-		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3B1)
-		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
-		#endif
-		#if defined(TCCR3A) && defined(COM3C1)
-		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
-		#endif
-
-		#if defined(TCCR4A) && defined(COM4A1)
-		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4B1)
-		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
-		#endif
-		#if defined(TCCR4A) && defined(COM4C1)
-		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
-		#endif
-		#if defined(TCCR5A)
-		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
-		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
-		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
-		#endif
-	}
-}
-
-void digitalWrite(uint8_t pin, uint8_t val)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	volatile uint8_t *out;
-
-	if (port == NOT_A_PIN) return;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before doing a digital write.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	out = portOutputRegister(port);
-
-	if (val == LOW) {
-		uint8_t oldSREG = SREG;
-                cli();
-		*out &= ~bit;
-		SREG = oldSREG;
-	} else {
-		uint8_t oldSREG = SREG;
-                cli();
-		*out |= bit;
-		SREG = oldSREG;
-	}
-}
-
-int digitalRead(uint8_t pin)
-{
-	uint8_t timer = digitalPinToTimer(pin);
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-
-	if (port == NOT_A_PIN) return LOW;
-
-	// If the pin that support PWM output, we need to turn it off
-	// before getting a digital reading.
-	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
-
-	if (*portInputRegister(port) & bit) return HIGH;
-	return LOW;
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_private.h b/Marlin/Sanguino/cores/arduino/wiring_private.h
deleted file mode 100644
index 7449c76..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_private.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
-  wiring_private.h - Internal header file.
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.h 239 2007-01-12 17:58:39Z mellis $
-*/
-
-#ifndef WiringPrivate_h
-#define WiringPrivate_h
-#include <math.h>
-#include <avr/io.h>
-#include <avr/interrupt.h>
-#include <util/delay.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "wiring.h"
-
-#ifdef __cplusplus
-extern "C"{
-#endif
-
-#ifndef cbi
-#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
-#endif
-#ifndef sbi
-#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
-#endif
-
-#define EXTERNAL_INT_0 0
-#define EXTERNAL_INT_1 1
-#define EXTERNAL_INT_2 2
-#define EXTERNAL_INT_3 3
-#define EXTERNAL_INT_4 4
-#define EXTERNAL_INT_5 5
-#define EXTERNAL_INT_6 6
-#define EXTERNAL_INT_7 7
-
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#define EXTERNAL_NUM_INTERRUPTS 8
-#else
-#define EXTERNAL_NUM_INTERRUPTS 2
-#endif
-
-typedef void (*voidFuncPtr)(void);
-
-#ifdef __cplusplus
-} // extern "C"
-#endif
-
-#endif
diff --git a/Marlin/Sanguino/cores/arduino/wiring_pulse.c b/Marlin/Sanguino/cores/arduino/wiring_pulse.c
deleted file mode 100644
index 0d96886..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_pulse.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  wiring_pulse.c - pulseIn() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-#include "pins_arduino.h"
-
-/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
- * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
- * to 3 minutes in length, but must be called at least a few dozen microseconds
- * before the start of the pulse. */
-unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
-{
-	// cache the port and bit of the pin in order to speed up the
-	// pulse width measuring loop and achieve finer resolution.  calling
-	// digitalRead() instead yields much coarser resolution.
-	uint8_t bit = digitalPinToBitMask(pin);
-	uint8_t port = digitalPinToPort(pin);
-	uint8_t stateMask = (state ? bit : 0);
-	unsigned long width = 0; // keep initialization out of time critical area
-	
-	// convert the timeout from microseconds to a number of times through
-	// the initial loop; it takes 16 clock cycles per iteration.
-	unsigned long numloops = 0;
-	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
-	
-	// wait for any previous pulse to end
-	while ((*portInputRegister(port) & bit) == stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to start
-	while ((*portInputRegister(port) & bit) != stateMask)
-		if (numloops++ == maxloops)
-			return 0;
-	
-	// wait for the pulse to stop
-	while ((*portInputRegister(port) & bit) == stateMask) {
-		if (numloops++ == maxloops)
-			return 0;
-		width++;
-	}
-
-	// convert the reading to microseconds. The loop has been determined
-	// to be 20 clock cycles long and have about 16 clocks between the edge
-	// and the start of the loop. There will be some error introduced by
-	// the interrupt handlers.
-	return clockCyclesToMicroseconds(width * 21 + 16); 
-}
diff --git a/Marlin/Sanguino/cores/arduino/wiring_shift.c b/Marlin/Sanguino/cores/arduino/wiring_shift.c
deleted file mode 100644
index cfe7867..0000000
--- a/Marlin/Sanguino/cores/arduino/wiring_shift.c
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-  wiring_shift.c - shiftOut() function
-  Part of Arduino - http://www.arduino.cc/
-
-  Copyright (c) 2005-2006 David A. Mellis
-
-  This library is free software; you can redistribute it and/or
-  modify it under the terms of the GNU Lesser General Public
-  License as published by the Free Software Foundation; either
-  version 2.1 of the License, or (at your option) any later version.
-
-  This library is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  Lesser General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General
-  Public License along with this library; if not, write to the
-  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
-  Boston, MA  02111-1307  USA
-
-  $Id: wiring.c 248 2007-02-03 15:36:30Z mellis $
-*/
-
-#include "wiring_private.h"
-
-uint8_t shiftIn(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder) {
-	uint8_t value = 0;
-	uint8_t i;
-
-	for (i = 0; i < 8; ++i) {
-		digitalWrite(clockPin, HIGH);
-		if (bitOrder == LSBFIRST)
-			value |= digitalRead(dataPin) << i;
-		else
-			value |= digitalRead(dataPin) << (7 - i);
-		digitalWrite(clockPin, LOW);
-	}
-	return value;
-}
-
-void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
-{
-	uint8_t i;
-
-	for (i = 0; i < 8; i++)  {
-		if (bitOrder == LSBFIRST)
-			digitalWrite(dataPin, !!(val & (1 << i)));
-		else	
-			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
-			
-		digitalWrite(clockPin, HIGH);
-		digitalWrite(clockPin, LOW);		
-	}
-}
diff --git a/Marlin/Sanguino/programmers.txt b/Marlin/Sanguino/programmers.txt
deleted file mode 100644
index 466f602..0000000
--- a/Marlin/Sanguino/programmers.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-avrisp.name=AVR ISP
-avrisp.communication=serial
-avrisp.protocol=stk500v1
-
-avrispmkii.name=AVRISP mkII
-avrispmkii.communication=usb
-avrispmkii.protocol=stk500v2
-
-usbtinyisp.name=USBtinyISP
-usbtinyisp.protocol=usbtiny
-
-parallel.name=Parallel Programmer
-parallel.protocol=dapa
-parallel.force=true
-# parallel.delay=200
-
-arduinoisp.name=Arduino as ISP
-arduinoisp.communication=serial
-arduinoisp.protocol=stk500v1
-arduinoisp.speed=19200
diff --git a/Marlin/hardware/tools/avr/etc/avrdude.conf b/Marlin/hardware/tools/avr/etc/avrdude.conf
deleted file mode 100644
index ec921df..0000000
--- a/Marlin/hardware/tools/avr/etc/avrdude.conf
+++ /dev/null
@@ -1,12104 +0,0 @@
-# $Id: avrdude.conf.in,v 1.122 2007/05/16 21:29:36 joerg_wunsch Exp $
-#
-# AVRDUDE Configuration File
-#
-# This file contains configuration data used by AVRDUDE which describes
-# the programming hardware pinouts and also provides part definitions.
-# AVRDUDE's "-C" command line option specifies the location of the
-# configuration file.  The "-c" option names the programmer configuration
-# which must match one of the entry's "id" parameter.  The "-p" option
-# identifies which part AVRDUDE is going to be programming and must match
-# one of the parts' "id" parameter.
-#
-# Possible entry formats are:
-#
-#   programmer
-#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
-#       desc     = <description> ;                  # quoted string
-#       type     = par | stk500 | stk500v2 | stk500pp | stk500hvsp | stk500generic |
-#                  avr910 | butterfly | usbasp |
-#                  jtagmki | jtagmkii | jtagmkii_isp | jtagmkii_dw |
-#                  dragon_dw | dragon_jtag | dragon_isp | dragon_pp |
-#                  dragon_hvsp; # programmer type
-#       baudrate = <num> ;                          # baudrate for avr910-programmer
-#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
-#       reset    = <num> ;                          # pin number
-#       sck      = <num> ;                          # pin number
-#       mosi     = <num> ;                          # pin number
-#       miso     = <num> ;                          # pin number
-#       errled   = <num> ;                          # pin number
-#       rdyled   = <num> ;                          # pin number
-#       pgmled   = <num> ;                          # pin number
-#       vfyled   = <num> ;                          # pin number
-#     ;
-#
-#   part
-#       id               = <id> ;                 # quoted string
-#       desc             = <description> ;        # quoted string
-#       has_jtag         = <yes/no> ;             # part has JTAG i/f
-#       has_debugwire    = <yes/no> ;             # part has debugWire i/f
-#       devicecode       = <num> ;            # deprecated, use stk500_devcode
-#       stk500_devcode   = <num> ;                # numeric
-#       avr910_devcode   = <num> ;                # numeric
-#       signature        = <num> <num> <num> ;    # signature bytes
-#       chip_erase_delay = <num> ;                # micro-seconds
-#       reset            = dedicated | io;
-#       retry_pulse      = reset | sck;
-#       pgm_enable       = <instruction format> ;
-#       chip_erase       = <instruction format> ;
-#       chip_erase_delay = <num> ;                # chip erase delay (us)
-#       # STK500 parameters (parallel programming IO lines)
-#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7
-#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0
-#       serial           = <yes/no> ;             # can use serial downloading
-#       parallel         = <yes/no/pseudo>;       # can use par. programming
-#       # STK500v2 parameters, to be taken from Atmel's XML files
-#       timeout          = <num> ;
-#       stabdelay        = <num> ;
-#       cmdexedelay      = <num> ;
-#       synchloops       = <num> ;
-#       bytedelay        = <num> ;
-#       pollvalue        = <num> ;
-#       pollindex        = <num> ;
-#       predelay         = <num> ;
-#       postdelay        = <num> ;
-#       pollmethod       = <num> ;
-#       mode             = <num> ;
-#       delay            = <num> ;
-#       blocksize        = <num> ;
-#       readsize         = <num> ;
-#       hvspcmdexedelay  = <num> ;
-#       # STK500v2 HV programming parameters, from XML
-#       pp_controlstack  = <num>, <num>, ...;   # PP only
-#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only
-#       hventerstabdelay = <num>;
-#       progmodedelay    = <num>;               # PP only
-#       latchcycles      = <num>;
-#       togglevtg        = <num>;
-#       poweroffdelay    = <num>;
-#       resetdelayms     = <num>;
-#       resetdelayus     = <num>;
-#       hvleavestabdelay = <num>;
-#       resetdelay       = <num>;
-#       synchcycles      = <num>;               # HVSP only
-#       chiperasepulsewidth = <num>;            # PP only
-#       chiperasepolltimeout = <num>;
-#       chiperasetime    = <num>;               # HVSP only
-#       programfusepulsewidth = <num>;          # PP only
-#       programfusepolltimeout = <num>;
-#       programlockpulsewidth = <num>;          # PP only
-#       programlockpolltimeout = <num>;
-#       # JTAG ICE mkII parameters, also from XML files
-#       allowfullpagebitstream = <yes/no> ;
-#       enablepageprogramming = <yes/no> ;
-#       idr              = <num> ;                # IO addr of IDR (OCD) reg.
-#       rampz            = <num> ;                # IO addr of RAMPZ reg.
-#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.
-#       eecr             = <num> ;                # mem addr of EECR reg.
-#                                                 # (only when != 0x3c)
-#
-#       memory <memtype>
-#           paged           = <yes/no> ;          # yes / no
-#           size            = <num> ;             # bytes
-#           page_size       = <num> ;             # bytes
-#           num_pages       = <num> ;             # numeric
-#           min_write_delay = <num> ;             # micro-seconds
-#           max_write_delay = <num> ;             # micro-seconds
-#           readback_p1     = <num> ;             # byte value
-#           readback_p2     = <num> ;             # byte value
-#           pwroff_after_write = <yes/no> ;       # yes / no
-#           read            = <instruction format> ;
-#           write           = <instruction format> ;
-#           read_lo         = <instruction format> ;
-#           read_hi         = <instruction format> ;
-#           write_lo        = <instruction format> ;
-#           write_hi        = <instruction format> ;
-#           loadpage_lo     = <instruction format> ;
-#           loadpage_hi     = <instruction format> ;
-#           writepage       = <instruction format> ;
-#         ;
-#     ;
-#
-# If any of the above parameters are not specified, the default value
-# of 0 is used for numerics or the empty string ("") for string
-# values.  If a required parameter is left empty, AVRDUDE will
-# complain.
-#
-# NOTES:
-#   * 'devicecode' is the device code used by the STK500 (see codes 
-#       listed below)
-#   * Not all memory types will implement all instructions.
-#   * AVR Fuse bits and Lock bits are implemented as a type of memory.
-#   * Example memory types are:
-#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
-#       fuse), "signature", "calibration", "lock"
-#   * The memory type specified on the avrdude command line must match
-#     one of the memory types defined for the specified chip.
-#   * The pwroff_after_write flag causes avrdude to attempt to
-#     power the device off and back on after an unsuccessful write to
-#     the affected memory area if VCC programmer pins are defined.  If
-#     VCC pins are not defined for the programmer, a message
-#     indicating that the device needs a power-cycle is printed out.
-#     This flag was added to work around a problem with the
-#     at90s4433/2333's; see the at90s4433 errata at:
-#
-#         http://www.atmel.com/atmel/acrobat/doc1280.pdf
-#
-# INSTRUCTION FORMATS
-#
-#    Instruction formats are specified as a comma seperated list of
-#    string values containing information (bit specifiers) about each
-#    of the 32 bits of the instruction.  Bit specifiers may be one of
-#    the following formats:
-#
-#       '1'  = the bit is always set on input as well as output
-#
-#       '0'  = the bit is always clear on input as well as output
-#
-#       'x'  = the bit is ignored on input and output
-#
-#       'a'  = the bit is an address bit, the bit-number matches this bit
-#              specifier's position within the current instruction byte
-#
-#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
-#              is address bit 12 on input, a0 is address bit 0.
-#
-#       'i'  = the bit is an input data bit
-#
-#       'o'  = the bit is an output data bit
-#
-#    Each instruction must be composed of 32 bit specifiers.  The
-#    instruction specification closely follows the instruction data
-#    provided in Atmel's data sheets for their parts.
-#
-# See below for some examples.
-#
-#
-# The following are STK500 part device codes to use for the
-# "devicecode" field of the part.  These came from Atmel's software
-# section avr061.zip which accompanies the application note
-# AVR061 available from:
-#
-#      http://www.atmel.com/atmel/acrobat/doc2525.pdf
-#
-
-#define ATTINY10    0x10
-#define ATTINY11    0x11
-#define ATTINY12    0x12
-#define ATTINY15    0x13
-#define ATTINY13    0x14
-
-#define ATTINY22    0x20
-#define ATTINY26    0x21
-#define ATTINY28    0x22
-#define ATTINY2313  0x23
-
-#define AT90S1200   0x33
-
-#define AT90S2313   0x40
-#define AT90S2323   0x41
-#define AT90S2333   0x42
-#define AT90S2343   0x43
-
-#define AT90S4414   0x50
-#define AT90S4433   0x51
-#define AT90S4434   0x52
-#define ATMEGA48    0x59
-
-#define AT90S8515   0x60
-#define AT90S8535   0x61
-#define AT90C8534   0x62
-#define ATMEGA8515  0x63
-#define ATMEGA8535  0x64
-
-#define ATMEGA8     0x70
-#define ATMEGA88    0x73
-#define ATMEGA168   0x86
-
-#define ATMEGA161   0x80
-#define ATMEGA163   0x81
-#define ATMEGA16    0x82
-#define ATMEGA162   0x83
-#define ATMEGA169   0x84
-
-#define ATMEGA323   0x90
-#define ATMEGA32    0x91
-
-#define ATMEGA64    0xA0
-
-#define ATMEGA103   0xB1
-#define ATMEGA128   0xB2
-#define AT90CAN128  0xB3
-
-#define AT86RF401   0xD0
-
-#define AT89START   0xE0
-#define AT89S51	    0xE0
-#define AT89S52	    0xE1
-
-# The following table lists the devices in the original AVR910
-# appnote:
-# |Device |Signature | Code |
-# +-------+----------+------+
-# |tiny12 | 1E 90 05 | 0x55 |
-# |tiny15 | 1E 90 06 | 0x56 |
-# |       |          |      |
-# | S1200 | 1E 90 01 | 0x13 |
-# |       |          |      |
-# | S2313 | 1E 91 01 | 0x20 |
-# | S2323 | 1E 91 02 | 0x48 |
-# | S2333 | 1E 91 05 | 0x34 |
-# | S2343 | 1E 91 03 | 0x4C |
-# |       |          |      |
-# | S4414 | 1E 92 01 | 0x28 |
-# | S4433 | 1E 92 03 | 0x30 |
-# | S4434 | 1E 92 02 | 0x6C |
-# |       |          |      |
-# | S8515 | 1E 93 01 | 0x38 |
-# | S8535 | 1E 93 03 | 0x68 |
-# |       |          |      |
-# |mega32 | 1E 95 01 | 0x72 |
-# |mega83 | 1E 93 05 | 0x65 |
-# |mega103| 1E 97 01 | 0x41 |
-# |mega161| 1E 94 01 | 0x60 |
-# |mega163| 1E 94 02 | 0x64 |
-
-# Appnote AVR109 also has a table of AVR910 device codes, which
-# lists:
-# dev         avr910   signature
-# ATmega8     0x77     0x1E 0x93 0x07
-# ATmega8515  0x3B     0x1E 0x93 0x06
-# ATmega8535  0x6A     0x1E 0x93 0x08
-# ATmega16    0x75     0x1E 0x94 0x03
-# ATmega162   0x63     0x1E 0x94 0x04
-# ATmega163   0x66     0x1E 0x94 0x02
-# ATmega169   0x79     0x1E 0x94 0x05
-# ATmega32    0x7F     0x1E 0x95 0x02
-# ATmega323   0x73     0x1E 0x95 0x01
-# ATmega64    0x46     0x1E 0x96 0x02
-# ATmega128   0x44     0x1E 0x97 0x02
-#
-# These codes refer to "BOOT" device codes which are apparently
-# different than standard device codes, for whatever reasons
-# (often one above the standard code).
-
-# There are several extended versions of AVR910 implementations around
-# in the Internet.  These add the following codes (only devices that
-# actually exist are listed):
-
-# ATmega8515	0x3A
-# ATmega128	0x43
-# ATmega64	0x45
-# ATtiny26	0x5E
-# ATmega8535	0x69
-# ATmega32	0x72
-# ATmega16	0x74
-# ATmega8	0x76
-# ATmega169	0x78
-
-#
-# Overall avrdude defaults
-#
-default_parallel   = "lpt1";
-default_serial     = "com1";
-
-
-#
-# PROGRAMMER DEFINITIONS
-#
-
-programmer
-  id    = "avrisp";
-  desc  = "Atmel AVR ISP";
-  type  = stk500;
-;
-
-programmer
-  id    = "avrispv2";
-  desc  = "Atmel AVR ISP V2";
-  type  =  stk500v2;
-;
-
-programmer
-  id    = "avrispmkII";
-  desc  = "Atmel AVR ISP mkII";
-  type  =  stk500v2;
-;
-
-programmer
-  id    = "avrisp2";
-  desc  = "Atmel AVR ISP mkII";
-  type  =  stk500v2;
-;
-
-# This is supposed to be the "default" STK500 entry.
-# Attempts to select the correct firmware version
-# by probing for it.  Better use one of the entries
-# below instead.
-programmer
-  id    = "stk500";
-  desc  = "Atmel STK500";
-  type  = stk500generic;
-;
-
-programmer
-  id    = "stk500v1";
-  desc  = "Atmel STK500 Version 1.x firmware";
-  type  = stk500;
-;
-
-programmer
-  id    = "stk500v2";
-  desc  = "Atmel STK500 Version 2.x firmware";
-  type  = stk500v2;
-;
-
-programmer
-  id    = "stk500pp";
-  desc  = "Atmel STK500 V2 in parallel programming mode";
-  type  = stk500pp;
-;
-
-programmer
-  id    = "stk500hvsp";
-  desc  = "Atmel STK500 V2 in high-voltage serial programming mode";
-  type  = stk500hvsp;
-;
-
-programmer
-  id    = "avr910";
-  desc  = "Atmel Low Cost Serial Programmer";
-  type  = avr910;
-;
-
-programmer
-  id    = "usbasp";
-  desc  = "USBasp, http://www.fischl.de/usbasp/";
-  type  = usbasp;
-;
-
-programmer
-  id    = "usbtiny";
-  desc  = "USBtiny simple USB programmer";
-  type  = usbtiny;
-;
-
-programmer
-  id    = "butterfly";
-  desc  = "Atmel Butterfly Development Board";
-  type  = butterfly;
-;
-
-programmer
-  id    = "avr109";
-  desc  = "Atmel AppNote AVR109 Boot Loader";
-  type  = butterfly;
-;
-
-programmer
-  id    = "avr911";
-  desc  = "Atmel AppNote AVR911 AVROSP";
-  type  = butterfly;
-;
-
-programmer
-  id    = "jtagmkI";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 115200;    # default is 115200
-  type  = jtagmki;
-;
-
-# easier to type
-programmer
-  id    = "jtag1";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 115200;    # default is 115200
-  type  = jtagmki;
-;
-
-# easier to type
-programmer
-  id    = "jtag1slow";
-  desc  = "Atmel JTAG ICE (mkI)";
-  baudrate = 19200;
-  type  = jtagmki;
-;
-
-programmer
-  id    = "jtagmkII";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 19200;    # default is 19200
-  type  = jtagmkii;
-;
-
-# easier to type
-programmer
-  id    = "jtag2slow";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 19200;    # default is 19200
-  type  = jtagmkii;
-;
-
-# JTAG ICE mkII @ 115200 Bd
-programmer
-  id    = "jtag2fast";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 115200;
-  type  = jtagmkii;
-;
-
-# make the fast one the default, people will love that
-programmer
-  id    = "jtag2";
-  desc  = "Atmel JTAG ICE mkII";
-  baudrate = 115200;
-  type  = jtagmkii;
-;
-
-# JTAG ICE mkII in ISP mode
-programmer
-  id    = "jtag2isp";
-  desc  = "Atmel JTAG ICE mkII in ISP mode";
-  baudrate = 115200;
-  type  = jtagmkii_isp;
-;
-
-# JTAG ICE mkII in debugWire mode
-programmer
-  id    = "jtag2dw";
-  desc  = "Atmel JTAG ICE mkII in debugWire mode";
-  baudrate = 115200;
-  type  = jtagmkii_dw;
-;
-
-# AVR Dragon in JTAG mode
-programmer
-  id    = "dragon_jtag";
-  desc  = "Atmel AVR Dragon in JTAG mode";
-  baudrate = 115200;
-  type  = dragon_jtag;
-;
-
-# AVR Dragon in ISP mode
-programmer
-  id    = "dragon_isp";
-  desc  = "Atmel AVR Dragon in ISP mode";
-  baudrate = 115200;
-  type  = dragon_isp;
-;
-
-# AVR Dragon in PP mode
-programmer
-  id    = "dragon_pp";
-  desc  = "Atmel AVR Dragon in PP mode";
-  baudrate = 115200;
-  type  = dragon_pp;
-;
-
-# AVR Dragon in HVSP mode
-programmer
-  id    = "dragon_hvsp";
-  desc  = "Atmel AVR Dragon in HVSP mode";
-  baudrate = 115200;
-  type  = dragon_hvsp;
-;
-
-# AVR Dragon in debugWire mode
-programmer
-  id    = "dragon_dw";
-  desc  = "Atmel AVR Dragon in debugWire mode";
-  baudrate = 115200;
-  type  = dragon_dw;
-;
-
-programmer
-  id    = "pavr";
-  desc  = "Jason Kyle's pAVR Serial Programmer";
-  type  = avr910;
-;
-
-# Parallel port programmers.
-
-programmer
-  id    = "bsd";
-  desc  = "Brian Dean's Programmer, http://www.bsdhome.com/avrdude/";
-  type  = par;
-  vcc   = 2, 3, 4, 5;
-  reset = 7;
-  sck   = 8;
-  mosi  = 9;
-  miso  = 10;
-;
-
-programmer
-  id    = "stk200";
-  desc  = "STK200";
-  type  = par;
-  buff  = 4, 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-;
-
-# The programming dongle used by the popular Ponyprog
-# utility.  It is almost similar to the STK200 one,
-# except that there is a LED indicating that the
-# programming is currently in progress.
-
-programmer
-  id    = "pony-stk200";
-  desc  = "Pony Prog STK200";
-  type  = par;
-  buff  = 4, 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-  pgmled = 8; 
-;
-
-programmer
-  id    = "dt006";
-  desc  = "Dontronics DT006";
-  type  = par;
-  reset = 4;
-  sck   = 5;
-  mosi  = 2;
-  miso  = 11;
-;
-
-programmer
-  id    = "bascom";
-  desc  = "Bascom SAMPLE programming cable";
-  type  = par;
-  reset = 4;
-  sck   = 5;
-  mosi  = 2;
-  miso  = 11;
-;
-
-programmer
-  id     = "alf";
-  desc   = "Nightshade ALF-PgmAVR, http://nightshade.homeip.net/";
-  type   = par;
-  vcc    = 2, 3, 4, 5;
-  buff   = 6;
-  reset  = 7;
-  sck    = 8;
-  mosi   = 9;
-  miso   = 10;
-  errled = 1;
-  rdyled = 14;
-  pgmled = 16;
-  vfyled = 17;
-;
-
-programmer
-  id    = "sp12";
-  desc  = "Steve Bolt's Programmer";
-  type  = par;
-  vcc   = 4,5,6,7,8;
-  reset = 3;
-  sck   = 2;
-  mosi  = 9;
-  miso  = 11;
-;
-
-programmer
-  id     = "picoweb";
-  desc   = "Picoweb Programming Cable, http://www.picoweb.net/";
-  type   = par;
-  reset  = 2;
-  sck    = 3;
-  mosi   = 4;
-  miso   = 13;
-;
-
-programmer
-  id    = "abcmini";
-  desc  = "ABCmini Board, aka Dick Smith HOTCHIP";
-  type  = par;
-  reset = 4;
-  sck   = 3;
-  mosi  = 2;
-  miso  = 10;
-;
-
-programmer
-  id    = "futurlec";
-  desc  = "Futurlec.com programming cable.";
-  type  = par;
-  reset = 3;
-  sck   = 2;
-  mosi  = 1;
-  miso  = 10;
-;
-
-
-# From the contributor of the "xil" jtag cable:
-# The "vcc" definition isn't really vcc (the cable gets its power from
-# the programming circuit) but is necessary to switch one of the
-# buffer lines (trying to add it to the "buff" lines doesn't work).
-# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK
-# to SCK (plus vcc/gnd of course)
-programmer
-  id    = "xil";
-  desc  = "Xilinx JTAG cable";
-  type  = par;
-  mosi  = 2;
-  sck   = 3;
-  reset = 4;
-  buff  = 5;
-  miso  = 13;
-  vcc   = 6;
-;
-
-
-programmer
-  id = "dapa";
-  desc = "Direct AVR Parallel Access cable";
-  type = par;
-  vcc   = 3;
-  reset = 16;
-  sck = 1;
-  mosi = 2;
-  miso = 11;
-;
-
-programmer
-  id    = "atisp";
-  desc  = "AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th";
-  type  = par;
-  reset = ~6;
-  sck   = ~8;
-  mosi  = ~7;
-  miso  = ~10;
-;
-
-programmer
-  id    = "ere-isp-avr";
-  desc  = "ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>";
-  type  = par;
-  reset = ~4;
-  sck   = 3;
-  mosi  = 2;
-  miso  = 10;
-;
-
-programmer
-  id    = "blaster";
-  desc  = "Altera ByteBlaster";
-  type  = par;
-  sck   = 2;
-  miso  = 11;
-  reset = 3;
-  mosi  = 8;
-  buff  = 14;
-;
-
-# It is almost same as pony-stk200, except vcc on pin 5 to auto
-# disconnect port (download on http://electropol.free.fr)
-programmer
-  id    = "frank-stk200";
-  desc  = "Frank STK200";
-  type  = par;
-  vcc   = 5;
-  sck   = 6;
-  mosi  = 7;
-  reset = 9;
-  miso  = 10;
-  pgmled = 8;
-;
-
-
-#
-# some ultra cheap programmers use bitbanging on the 
-# serialport.
-#
-# PC - DB9 - Pins for RS232:
-#
-# GND   5   -- |O
-#              |   O| <-   9   RI
-# DTR   4   <- |O   |
-#              |   O| <-   8   CTS
-# TXD   3   <- |O   |
-#              |   O| ->   7   RTS
-# RXD   2   -> |O   |
-#              |   O| <-   6   DSR
-# DCD   1   -> |O
-#
-# Using RXD is currently not supported.
-# Using RI is not supported under Win32 but is supported under Posix.
-
-# serial ponyprog design (dasa2 in uisp)
-# reset=!txd sck=rts mosi=dtr miso=cts
-
-programmer
-  id    = "ponyser";
-  desc  = "design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts";
-  type  = serbb;
-  reset = ~3;
-  sck   = 7;
-  mosi  = 4;
-  miso  = 8;
-;
-
-# Same as above, different name
-# reset=!txd sck=rts mosi=dtr miso=cts
-
-programmer
-  id    = "siprog";
-  desc  = "Lancos SI-Prog <http://www.lancos.com/siprogsch.html>";
-  type  = serbb;
-  reset = ~3;
-  sck   = 7;
-  mosi  = 4;
-  miso  = 8;
-;
-
-# unknown (dasa in uisp)
-# reset=rts sck=dtr mosi=txd miso=cts
-
-programmer
-  id    = "dasa";
-  desc  = "serial port banging, reset=rts sck=dtr mosi=txd miso=cts";
-  type  = serbb;
-  reset = 7;
-  sck   = 4;
-  mosi  = 3;
-  miso  = 8;
-;
-
-# unknown (dasa3 in uisp)
-# reset=!dtr sck=rts mosi=txd miso=cts
-
-programmer
-  id    = "dasa3";
-  desc  = "serial port banging, reset=!dtr sck=rts mosi=txd miso=cts";
-  type  = serbb;
-  reset = ~4;
-  sck   = 7;
-  mosi  = 3;
-  miso  = 8;
-;
-
-#
-# PART DEFINITIONS
-#
-
-#------------------------------------------------------------
-# ATtiny11
-#------------------------------------------------------------
-
-# This is an HVSP-only device.
-
-part
-    id                  = "t11";
-    desc                = "ATtiny11";
-    stk500_devcode      = 0x11;
-    signature           = 0x1e 0x90 0x04;
-    chip_erase_delay    = 20000;
-
-    timeout		= 200;
-    hvsp_controlstack     =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-	blocksize	= 64;
-	readsize	= 256;
-	delay		= 5;
-    ;
-
-    memory "flash"
-        size            = 1024;
-	blocksize	= 128;
-	readsize	= 256;
-	delay		= 3;
-    ;
-
-    memory "signature"
-        size            = 3;
-    ;
-
-    memory "lock"
-        size            = 1;
-    ;
-
-    memory "calibration"
-        size            = 1;
-    ;
-
-    memory "fuse"
-        size            = 1;
-    ;
-;
-
-#------------------------------------------------------------
-# ATtiny12
-#------------------------------------------------------------
-
-part
-    id                  = "t12";
-    desc                = "ATtiny12";
-    stk500_devcode      = 0x12;
-    avr910_devcode      = 0x55;
-    signature           = 0x1e 0x90 0x05;
-    chip_erase_delay    = 20000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 8;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        write_lo        = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        write_hi        = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    o o o o  o o o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-;
-
-#------------------------------------------------------------
-# ATtiny13
-#------------------------------------------------------------
-
-part
-    id                  = "t13";
-    desc                = "ATtiny13";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x0E, 0x1E;
-     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x0E, 0xB4, 0x0E, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-    stk500_devcode      = 0x14;
-    signature           = 0x1e 0x90 0x07;
-    chip_erase_delay    = 4000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack     =
-	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 90;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        page_size       = 4;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x   x  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 1024;
-        page_size       = 32;
-        num_pages       = 32;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  0  0  0  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  0  0  0  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  0  0  0  0   0  0  0 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    0 0 0 x  x x x x",
-                          "x  x  x  x   x  x a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-	read            = "0  1  0  1   1  0  0  0    0 0 0 0  0 0 0 0",
-                          "x  x  x  x   x  x  x  x    x x o o  o o o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    1 1 i i  i i i i";
-    ;
-
-    memory "calibration"
-        size            = 2;
-        read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                          "0  0  0  0   0  0  0 a0    o o o o  o o o o";
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny15
-#------------------------------------------------------------
-
-part
-    id                  = "t15";
-    desc                = "ATtiny15";
-    stk500_devcode      = 0x13;
-    avr910_devcode      = 0x56;
-    signature           = 0x1e 0x90 0x06;
-    chip_erase_delay    = 8200;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 5;
-    synchcycles         = 6;
-    latchcycles         = 16;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 8200;
-        max_write_delay = 8200;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x  x a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4100;
-        max_write_delay = 4100;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        write_lo        = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        write_hi        = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x o o x";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 i i 1",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0  1  0  1   0  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    o o o o  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 0 1 x  x x x x",
-                          "x  x  x  x   x  x  x  x    i i i i  1 1 i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-;
-
-#------------------------------------------------------------
-# AT90s1200
-#------------------------------------------------------------
-
-part
-    id               = "1200";
-    desc             = "AT90S1200";
-    stk500_devcode   = 0x33;
-    avr910_devcode   = 0x13;
-    signature        = 0x1e 0x90 0x01;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 1;
-    bytedelay		= 0;
-    pollindex		= 0;
-    pollvalue		= 0xFF;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 64;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1 0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x x a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1 1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x x a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 32;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 1024;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x   x  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x02;
-	delay		= 15;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s4414
-#------------------------------------------------------------
-
-part
-    id               = "4414";
-    desc             = "AT90S4414";
-    stk500_devcode   = 0x50;
-    avr910_devcode   = 0x28;
-    signature        = 0x1e 0x92 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
-                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-      ;
-    memory "lock"
-	size		= 1;
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2313
-#------------------------------------------------------------
-
-part
-    id               = "2313";
-    desc             = "AT90S2313";
-    stk500_devcode   = 0x40;
-    avr910_devcode   = 0x20;
-    signature        = 0x1e 0x91 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-      ;
-    memory "lock"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 1 1 x  x i i x",
-                          "x x x x  x x x x  x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2333
-#------------------------------------------------------------
-
-part
-    id               = "2333";
-##### WARNING: No XML file for device 'AT90S2333'! #####
-    desc             = "AT90S2333";
-    stk500_devcode   = 0x42;
-    avr910_devcode   = 0x34;
-    signature        = 0x1e 0x91 0x05;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        pwroff_after_write = yes;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1284P
-#------------------------------------------------------------
-
-# similar to ATmega164p
-
-part
-    id               = "m1284p";
-    desc             = "ATMEGA1284P";
-    has_jtag         = yes;
-    stk500_devcode   = 0x82; # no STK500v1 support, use the ATmega16 one
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x97 0x05;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# AT90s2343 (also AT90s2323 and ATtiny22)
-#------------------------------------------------------------
-
-part
-    id               = "2343";
-    desc             = "AT90S2343";
-    stk500_devcode   = 0x43;
-    avr910_devcode   = 0x4c;
-    signature        = 0x1e 0x91 0x03;
-    chip_erase_delay = 18000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x00,
-        0x68, 0x78, 0x68, 0x68, 0x00, 0x00, 0x68, 0x78,
-        0x78, 0x00, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 0;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 50;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0   0 0 0 0  0 0 0 0", 
-                          "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0   0 0 0 0  0 0 0 0",
-                          "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x   x  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 128;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   o o o x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 1  1 1 1 i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   o o o x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# AT90s4433
-#------------------------------------------------------------
-
-part
-    id               = "4433";
-    desc             = "AT90S4433";
-    stk500_devcode   = 0x51;
-    avr910_devcode   = 0x30;
-    signature        = 0x1e 0x92 0x03;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        pwroff_after_write = yes;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s4434
-#------------------------------------------------------------
-
-part
-    id               = "4434";
-##### WARNING: No XML file for device 'AT90S4434'! #####
-    desc             = "AT90S4434";
-    stk500_devcode   = 0x52;
-    avr910_devcode   = 0x6c;
-    signature        = 0x1e 0x92 0x02;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "eeprom"
-        size            = 256;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x x", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-      ;
-    memory "flash"
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x    x a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 i  i i i i",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-    memory "lock"
-        size            = 1;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s8515
-#------------------------------------------------------------
-
-part
-    id               = "8515";
-    desc             = "AT90S8515";
-    stk500_devcode   = 0x60;
-    avr910_devcode   = 0x38;
-    signature        = 0x1e 0x93 0x01;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-        read            = " 1  0  1  0   0  0  0  0  x x x x  x x x a8", 
-                          "a7 a6 a5 a4 a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 8192;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x7f;
-        readback_p2     = 0x7f;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-      ;
-    memory "lock"
-	size		= 1;
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90s8535
-#------------------------------------------------------------
-
-part
-    id               = "8535";
-    desc             = "AT90S8535";
-    stk500_devcode   = 0x61;
-    avr910_devcode   = 0x68;
-    signature        = 0x1e 0x93 0x03;
-    chip_erase_delay = 20000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 1;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0x00;
-        readback_p2     = 0xff;
-        read            = " 1  0  1  0   0  0  0  0   x x x x  x x x a8", 
-                          "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0   x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        size            = 8192;
-        min_write_delay = 9000;
-        max_write_delay = 20000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        write_lo        = "  0   1   0   0    0   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-        write_hi        = "  0   1   0   0    1   0   0   0",
-                          "  x   x   x   x  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  i   i   i   i    i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "fuse"
-	size		= 1;
-	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  o";
-	write		= "1  0  1  0   1  1  0  0   1  0  1  1   1  1  1  i",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-    memory "lock"
-	size		= 1;
-	read		= "0  1  0  1   1  0  0  0   x  x  x  x   x  x  x  x",
-			  "x  x  x  x   x  x  x  x   o  o  x  x   x  x  x  x";
-	write		= "1  0  1  0   1  1  0  0   1  1  1  1   1  i  i  1",
-			  "x  x  x  x   x  x  x  x   x  x  x  x   x  x  x  x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega103
-#------------------------------------------------------------
-
-part
-    id               = "m103";
-    desc             = "ATMEGA103";
-    stk500_devcode   = 0xB1;
-    avr910_devcode   = 0x41;
-    signature        = 0x1e 0x97 0x01;
-    chip_erase_delay = 112000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x8E, 0x9E, 0x2E, 0x3E, 0xAE, 0xBE,
-        0x4E, 0x5E, 0xCE, 0xDE, 0x6E, 0x7E, 0xEE, 0xDE,
-        0x66, 0x76, 0xE6, 0xF6, 0x6A, 0x7A, 0xEA, 0x7A,
-        0x7F, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 15;
-    chiperasepolltimeout = 0;
-    programfusepulsewidth = 2;
-    programfusepolltimeout = 0;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 10;
-
-    memory "eeprom"
-        size            = 4096;
-        min_write_delay = 4000;
-        max_write_delay = 9000;
-        readback_p1     = 0x80;
-        readback_p2     = 0x7f;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 22000;
-        max_write_delay = 56000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x11;
-	delay		= 70;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "fuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0  x x x x  x x x x",
-                          "x x x x  x x x x  x x o x  o 1 o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 1  i 1 i i",
-                          "x x x x  x x x x  x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x x x x  x o o x";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 1  1 i i 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega64
-#------------------------------------------------------------
-
-part
-    id               = "m64";
-    desc             = "ATMEGA64";
-    has_jtag         = yes;
-    stk500_devcode   = 0xA0;
-    avr910_devcode   = 0x45;
-    signature        = 0x1e 0x96 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x22;
-    spmcr               = 0x68;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x x i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-
-#------------------------------------------------------------
-# ATmega128
-#------------------------------------------------------------
-
-part
-    id               = "m128";
-    desc             = "ATMEGA128";
-    has_jtag         = yes;
-    stk500_devcode   = 0xB2;
-    avr910_devcode   = 0x43;
-    signature        = 0x1e 0x97 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x22;
-    spmcr               = 0x68;
-    rampz               = 0x3b;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 12;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x x i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90CAN128
-#------------------------------------------------------------
-
-part
-    id               = "c128";
-    desc             = "AT90CAN128";
-    has_jtag         = yes;
-    stk500_devcode   = 0xB3;
-#    avr910_devcode   = 0x43;
-    signature        = 0x1e 0x97 0x81;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    eecr                = 0x3f;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0  0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega16
-#------------------------------------------------------------
-
-part
-    id               = "m16";
-    desc             = "ATMEGA16";
-    has_jtag         = yes;
-    stk500_devcode   = 0x82;
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x94 0x03;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 100;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = yes;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-    memory "calibration"
-        size            = 4;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega164P
-#------------------------------------------------------------
-
-# close to ATmega16
-
-part
-    id               = "m164p";
-    desc             = "ATMEGA164P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x94 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega324P
-#------------------------------------------------------------
-
-# similar to ATmega164P
-
-part
-    id               = "m324p";
-    desc             = "ATMEGA324P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x95 0x08;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega644
-#------------------------------------------------------------
-
-# similar to ATmega164
-
-part
-    id               = "m644";
-    desc             = "ATMEGA644";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x96 0x09;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega644P
-#------------------------------------------------------------
-
-# similar to ATmega164p
-
-part
-    id               = "m644p";
-    desc             = "ATMEGA644P";
-    has_jtag         = yes;
-#   stk500_devcode   = 0x82; # no STK500v1 support
-#   avr910_devcode   = 0x?;  # try the ATmega16 one:^
-    avr910_devcode   = 0x74;
-    signature        = 0x1e 0x96 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-
-
-#------------------------------------------------------------
-# ATmega162
-#------------------------------------------------------------
-
-part
-    id               = "m162";
-    desc             = "ATMEGA162";
-    has_jtag         = yes;
-    stk500_devcode   = 0x83;
-    avr910_devcode   = 0x63;
-    signature        = 0x1e 0x94 0x04;
-    chip_erase_delay = 9000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-
-    idr              = 0x04;
-    spmcr            = 0x57;
-    allowfullpagebitstream = yes;
-
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-       mode        = 0x41;
-    delay       = 10;
-    blocksize   = 128;
-    readsize    = 256;  
-
-        ;
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-                read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-                write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-        ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  1 1 1 1  1 i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        ;
-
-    memory "signature"
-        size            = 3;
-
-        read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-        ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-;
-
-
-
-#------------------------------------------------------------
-# ATmega163
-#------------------------------------------------------------
-
-part
-    id               = "m163";
-    desc             = "ATMEGA163";
-    stk500_devcode   = 0x81;
-    avr910_devcode   = 0x64;
-    signature        = 0x1e 0x94 0x02;
-    chip_erase_delay = 32000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 30;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 2;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 2;
-
-
-   memory "eeprom"
-        size            = 512;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 16000;
-        max_write_delay = 16000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o x x  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i 1 1  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  1 o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   1 1 1 1  1 i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  0 x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega169
-#------------------------------------------------------------
-
-part
-    id               = "m169";
-    desc             = "ATMEGA169";
-    has_jtag         = yes;
-    stk500_devcode   = 0x85;
-    avr910_devcode   = 0x78;
-    signature        = 0x1e 0x94 0x05;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega329
-#------------------------------------------------------------
-
-part
-    id               = "m329";
-    desc             = "ATMEGA329";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x95 0x03;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega3290
-#------------------------------------------------------------
-
-# identical to ATmega329
-
-part
-    id               = "m3290";
-    desc             = "ATMEGA3290";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x95 0x04;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a3   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega649
-#------------------------------------------------------------
-
-part
-    id               = "m649";
-    desc             = "ATMEGA649";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x96 0x03;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega6490
-#------------------------------------------------------------
-
-# identical to ATmega649
-
-part
-    id               = "m6490";
-    desc             = "ATMEGA6490";
-    has_jtag         = yes;
-#    stk500_devcode   = 0x85; # no STK500 support, only STK500v2
-#    avr910_devcode   = 0x?;  # try the ATmega169 one:
-    avr910_devcode   = 0x75;
-    signature        = 0x1e 0x96 0x04;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-
-   memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 20;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0   0 0 0 x  x x x x",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega32
-#------------------------------------------------------------
-
-part
-    id               = "m32";
-    desc             = "ATMEGA32";
-    has_jtag         = yes;
-    stk500_devcode   = 0x91;
-    avr910_devcode   = 0x72;
-    signature        = 0x1e 0x95 0x02;
-    chip_erase_delay = 9000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = yes;
-
-   memory "eeprom"
-        paged           = no;   /* leave this "no" */
-        page_size       = 4;    /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x  a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0 a13 a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o o";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0    0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0  o o o o  o o o o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega161
-#------------------------------------------------------------
-
-part
-    id               = "m161";
-    desc             = "ATMEGA161";
-    stk500_devcode   = 0x80;
-    avr910_devcode   = 0x60;
-    signature        = 0x1e 0x94 0x01;
-    chip_erase_delay = 28000;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 0;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 30;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 2;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 2;
-
-   memory "eeprom"
-        size            = 512;
-        min_write_delay = 3400;
-        max_write_delay = 3400;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 5;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 14000;
-        max_write_delay = 14000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x   x  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  x   x   x a12    a11 a10  a9  a8",
-                          " a7  a6   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 16;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-
-    memory "fuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   x x x x  x x x x",
-                          "x x x x  x x x x   x o x o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 x  x x x x",
-                          "x x x x  x x x x   1 i 1 i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega8
-#------------------------------------------------------------
-
-part
-    id               = "m8";
-    desc             = "ATMEGA8";
-    stk500_devcode   = 0x70;
-    avr910_devcode   = 0x76;
-    signature        = 0x1e 0x93 0x07;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 10000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 20;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0  0  1  1   1  0  0  0   0  0  x  x   x  x  x  x",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-#------------------------------------------------------------
-# ATmega8515
-#------------------------------------------------------------
-
-part
-    id               = "m8515";
-    desc             = "ATMEGA8515";
-    stk500_devcode   = 0x63;
-    avr910_devcode   = 0x3A;
-    signature        = 0x1e 0x93 0x06;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
- read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
- write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0     0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0   o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-
-
-#------------------------------------------------------------
-# ATmega8535
-#------------------------------------------------------------
-
-part
-    id               = "m8535";
-    desc             = "ATMEGA8535";
-    stk500_devcode   = 0x64;
-    avr910_devcode   = 0x69;
-    signature        = 0x1e 0x93 0x08;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 6;
-    togglevtg           = 0;
-    poweroffdelay       = 0;
-    resetdelayms        = 0;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 512;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   x   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 128;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 2000;
-        max_write_delay = 2000;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0 0 1 1  1 0 0 0   0 0 x x  x x x x",
-                          "0 0 0 0  0 0 a1 a0 o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATtiny26
-#------------------------------------------------------------
-
-part
-    id                  = "t26";
-    desc                = "ATTINY26";
-    stk500_devcode      = 0x21;
-    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x91 0x09;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 9000;
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        size            = 128;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	mode		= 0x04;
-	delay		= 10;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 2048;
-        page_size       = 32;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x21;
-	delay		= 6;
-	blocksize	= 16;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  x x x i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  x x x o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 4;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny261
-#------------------------------------------------------------
-# Close to ATtiny26
-
-part
-    id                  = "t261";
-    desc                = "ATTINY261";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x91 0x0c;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 128;
-        page_size       = 4;
-        num_pages       = 32;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = "1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = "1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 2048;
-        page_size       = 32;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        read_hi         = "  0  0  1  0   1  0  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4  a3 a2 a1 a0",
-                          "  o  o  o  o   o  o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x  x  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1  1  0  0",
-                          "  x  x  x  x   x  x a9 a8",
-                          " a7 a6 a5 a4   x  x  x  x",
-                          "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny461
-#------------------------------------------------------------
-# Close to ATtiny261
-
-part
-    id                  = "t461";
-    desc                = "ATTINY461";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x92 0x08;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 256;
-        page_size       = 4;
-        num_pages       = 64;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o";
-
-        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x x",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 4096;
-        page_size       = 64;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0   0  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        read_hi         = "  0  0  1  0   1   0  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1   1  0  0",
-                          "  x  x  x  x   x a10 a9 a8",
-                          " a7 a6 a5  x   x   x  x  x",
-                          "  x  x  x  x   x   x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATtiny861
-#------------------------------------------------------------
-# Close to ATtiny461
-
-part
-    id                  = "t861";
-    desc                = "ATTINY861";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x00, 0x10;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-#    stk500_devcode      = 0x21;
-#    avr910_devcode      = 0x5e;
-    signature           = 0x1e 0x93 0x0d;
-    pagel               = 0xb3;
-    bs2                 = 0xb2;
-    chip_erase_delay    = 4000;
-
-    pgm_enable          = "1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    chip_erase          = "1 0 1 0  1 1 0 0   1 0 0 x  x x x x",
-                          "x x x x  x x x x   x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 0;
-
-    pp_controlstack     =
-        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,
-        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,
-        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,
-        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 2;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        size            = 512;
-        num_pages       = 128;
-        page_size       = 4;
-        min_write_delay = 4000;
-        max_write_delay = 4000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read            = " 1  0  1  0   0  0  0  0    x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o";
-
-        write           = " 1  1  0  0   0  0  0  0    x x x x  x x x a8",
-                          "a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 4;
-	readsize	= 256;
-    ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-
-        read_lo         = "  0  0  1  0   0   0  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        read_hi         = "  0  0  1  0   1   0  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5 a4  a3  a2 a1 a0",
-                          "  o  o  o  o   o   o  o  o";
-
-        loadpage_lo     = "  0  1  0  0   0  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        loadpage_hi     = "  0  1  0  0   1  0  0  0",
-                          "  x  x  x  x   x  x  x  x",
-                          "  x  x  x a4  a3 a2 a1 a0",
-                          "  i  i  i  i   i  i  i  i";
-
-        writepage       = "  0  1  0  0   1   1  0  0",
-                          "  x  x  x  x a11 a10 a9 a8",
-                          " a7 a6 a5  x   x   x  x  x",
-                          "  x  x  x  x   x   x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-    ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0 a1 a0    o o o o  o o o o";
-    ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0  1  0  1   1  0  0  0    x x x x  x x x x",
-                          "x  x  x  x   x  x  x  x    x x x x  x x o o";
-
-        write           = "1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i",
-                          "x  x  x  x   x  x  x  x    x x x x  x x x x";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-    ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0    x x x x  x x x x",
-                          "0  0  0  0   0  0  0  0    o o o o  o o o o";
-    ;
-
-;
-
-
-#------------------------------------------------------------
-# ATmega48
-#------------------------------------------------------------
-
-part
-    id               = "m48";
-    desc             = "ATMEGA48";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode   = 0x59;
-#    avr910_devcode   = 0x;
-    signature        = 0x1e 0x92 0x05;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 45000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 256;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 4096;
-        page_size       = 64;
-        num_pages       = 64;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0    0 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0    0 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x x x o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x x x i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
-                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-
-#------------------------------------------------------------
-# ATmega88
-#------------------------------------------------------------
-
-part
-    id               = "m88";
-    desc             = "ATMEGA88";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode   = 0x73;
-#    avr910_devcode   = 0x;
-    signature        = 0x1e 0x93 0x0a;
-    pagel            = 0xd7;
-    bs2              = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 512;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-	read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-	write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-      ;
-    memory "flash"
-        paged           = yes;
-        size            = 8192;
-        page_size       = 64;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0    0   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        read_hi         = "  0   0   1   0    1   0   0   0",
-                          "  0   0   0   0  a11 a10  a9  a8",
-                          " a7  a6  a5  a4   a3  a2  a1  a0",
-                          "  o   o   o   o    o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   x      x   x   x   x",
-                          "  x   x   x  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0   0   0   0    a11 a10  a9  a8",
-                          " a7  a6  a5   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x   i i i i  i i i i";
-      ;
-
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x   x x x x  x o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x   x x x x  x i i i";
-      ;
-
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x",
-                          "0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega168
-#------------------------------------------------------------
-
-part
-    id              = "m168";
-    desc            = "ATMEGA168";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode  = 0x86;
-    # avr910_devcode = 0x;
-    signature       = 0x1e 0x94 0x06;
-    pagel           = 0xd7;
-    bs2             = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
-                       "x x x x x x x x x x x x x x x x";
-
-    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
-                       "x x x x x x x x x x x x x x x x";
-
-    timeout         = 200;
-    stabdelay       = 100;
-    cmdexedelay     = 25;
-    synchloops      = 32;
-    bytedelay       = 0;
-    pollindex       = 3;
-    pollvalue       = 0x53;
-    predelay        = 1;
-    postdelay       = 1;
-    pollmethod      = 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 512;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = " 1 0 1 0 0 0 0 0",
-                          " 0 0 0 x x x x a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-    
-        write           = " 1 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 16384;
-        page_size       = 128;
-        num_pages       = 128;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = " 0 0 1 0 0 0 0 0",
-                          " 0 0 0 a12 a11 a10 a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-        
-        read_hi          = " 0 0 1 0 1 0 0 0",
-                           " 0 0 0 a12 a11 a10 a9 a8",
-                           " a7 a6 a5 a4 a3 a2 a1 a0",
-                           " o o o o o o o o";
-        
-        loadpage_lo     = " 0 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        loadpage_hi     = " 0 1 0 0 1 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        writepage       = " 0 1 0 0 1 1 0 0",
-                          " 0 0 0 a12 a11 a10 a9 a8",
-                          " a7 a6 x x x x x x",
-                          " x x x x x x x x";
-
-        mode        = 0x41;
-        delay       = 6;
-        blocksize   = 128;
-        readsize    = 256;
-
-        ;
-        
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x x x x x x o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
-                          "x x x x x x x x x x x x x i i i";
-        ;
-    
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x x x o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
-                          "x x x x x x x x 1 1 i i i i i i";
-        ;
-    
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
-                          "0 0 0 0 0 0 0 0 o o o o o o o o";
-        ;
-    
-    memory "signature"
-        size            = 3;
-        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
-                          "x x x x x x a1 a0 o o o o o o o o";
-        ;
-;
-
-#------------------------------------------------------------
-# ATmega328
-#------------------------------------------------------------
-
-part
-    id              = "m328p";
-    desc            = "ATMEGA328P";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-    stk500_devcode  = 0x86;
-    # avr910_devcode = 0x;
-    signature       = 0x1e 0x95 0x0F;
-    pagel           = 0xd7;
-    bs2             = 0xc2;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1",
-                       "x x x x x x x x x x x x x x x x";
-
-    chip_erase       = "1 0 1 0 1 1 0 0 1 0 0 x x x x x",
-                       "x x x x x x x x x x x x x x x x";
-
-    timeout         = 200;
-    stabdelay       = 100;
-    cmdexedelay     = 25;
-    synchloops      = 32;
-    bytedelay       = 0;
-    pollindex       = 3;
-    pollvalue       = 0x53;
-    predelay        = 1;
-    postdelay       = 1;
-    pollmethod      = 1;
-
-    pp_controlstack     =
-	0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-	0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-	0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-	0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    resetdelay          = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    memory "eeprom"
-        paged           = no;
-        page_size       = 4;
-        size            = 1024;
-        min_write_delay = 3600;
-        max_write_delay = 3600;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = " 1 0 1 0 0 0 0 0",
-                          " 0 0 0 x x x a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-    
-        write           = " 1 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   a9  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 5;
-	blocksize	= 4;
-	readsize	= 256;
-        ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = " 0 0 1 0 0 0 0 0",
-                          " 0 0 a13 a12 a11 a10 a9 a8",
-                          " a7 a6 a5 a4 a3 a2 a1 a0",
-                          " o o o o o o o o";
-        
-        read_hi          = " 0 0 1 0 1 0 0 0",
-                           " 0 0 a13 a12 a11 a10 a9 a8",
-                           " a7 a6 a5 a4 a3 a2 a1 a0",
-                           " o o o o o o o o";
-        
-        loadpage_lo     = " 0 1 0 0 0 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        loadpage_hi     = " 0 1 0 0 1 0 0 0",
-                          " 0 0 0 x x x x x",
-                          " x x a5 a4 a3 a2 a1 a0",
-                          " i i i i i i i i";
-        
-        writepage       = " 0 1 0 0 1 1 0 0",
-                          " 0 0 a13 a12 a11 a10 a9 a8",
-                          " a7 a6 x x x x x x",
-                          " x x x x x x x x";
-
-        mode        = 0x41;
-        delay       = 6;
-        blocksize   = 128;
-        readsize    = 256;
-
-        ;
-        
-    memory "lfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "hfuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x o o o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0",
-                          "x x x x x x x x i i i i i i i i";
-        ;
-    
-    memory "efuse"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0",
-                          "x x x x x x x x x x x x x o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0",
-                          "x x x x x x x x x x x x x i i i";
-        ;
-    
-    memory "lock"
-        size            = 1;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        read            = "0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0",
-                          "x x x x x x x x x x o o o o o o";
-        
-        write           = "1 0 1 0 1 1 0 0 1 1 1 x x x x x",
-                          "x x x x x x x x 1 1 i i i i i i";
-        ;
-    
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1 1 0 0 0 0 0 0 x x x x x",
-                          "0 0 0 0 0 0 0 0 o o o o o o o o";
-        ;
-    
-    memory "signature"
-        size            = 3;
-        read            = "0 0 1 1 0 0 0 0 0 0 0 x x x x x",
-                          "x x x x x x a1 a0 o o o o o o o o";
-        ;
-;
-
-#------------------------------------------------------------
-# ATtiny2313
-#------------------------------------------------------------
-
-part
-     id            = "t2313";
-     desc          = "ATtiny2313";
-     has_debugwire = yes;
-     flash_instr   = 0xB2, 0x0F, 0x1F;
-     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-     stk500_devcode   = 0x23;
-##   Use the ATtiny26 devcode:
-     avr910_devcode   = 0x5e;
-     signature        = 0x1e 0x91 0x0a;
-     pagel            = 0xD4;
-     bs2              = 0xD6;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,
-        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,
-        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,
-        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-# The information in the data sheet of April/2004 is wrong, this works:
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-         read           = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.
-# The information in the data sheet of April/2004 is wrong, this works:
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM2
-#------------------------------------------------------------
-
-part
-     id            = "pwm2";
-     desc          = "AT90PWM2";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x81;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM3
-#------------------------------------------------------------
-
-# Completely identical to AT90PWM2 (including the signature!)
-
-part
-     id            = "pwm3";
-     desc          = "AT90PWM3";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x81;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-#   AT90PWM2 has Signature Bytes: 0x1E 0x93 0x81.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM2B
-#------------------------------------------------------------
-# Same as AT90PWM2 but different signature.
-
-part
-     id            = "pwm2b";
-     desc          = "AT90PWM2B";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x83;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90PWM3B
-#------------------------------------------------------------
-
-# Completely identical to AT90PWM2B (including the signature!)
-
-part
-     id            = "pwm3b";
-     desc          = "AT90PWM3B";
-     has_debugwire = yes;
-     flash_instr   = 0xB6, 0x01, 0x11;
-     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,
-	             0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,
-	             0x99, 0xF9, 0xBB, 0xAF;
-     stk500_devcode   = 0x65;
-##  avr910_devcode   = ?;
-     signature        = 0x1e 0x93 0x83;
-     pagel            = 0xD8;
-     bs2              = 0xE2;
-     reset            = io;
-     chip_erase_delay = 9000;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0  i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0   a11 a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0   0",
-                           "  0  0  0  0   a11 a10 a9  a8",
-                           " a7 a6 a5  x   x   x   x   x",
-                           "  x  x  x  x   x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 64;
-	readsize	= 256;
-       ;
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  x  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  x x o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  0    o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny25
-#------------------------------------------------------------
-
-part
-     id            = "t25";
-     desc          = "ATtiny25";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x91 0x08;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny45
-#------------------------------------------------------------
-
-part
-     id            = "t45";
-     desc          = "ATtiny45";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x92 0x06;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack     =
-	0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 256;
-         page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 4096;
-         page_size       = 64;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny85
-#------------------------------------------------------------
-
-part
-     id            = "t85";
-     desc          = "ATtiny85";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x02, 0x12;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x93 0x0b;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x  a8",
-			  " a7  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0  0",
-                           "  0  0  0  0  a11 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 2;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATmega640
-#------------------------------------------------------------
-# Almost same as ATmega1280, except for different memory sizes
-
-part
-    id               = "m640";
-    desc             = "ATMEGA640";
-    signature        = 0x1e 0x96 0x08;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1280
-#------------------------------------------------------------
-
-part
-    id               = "m1280";
-    desc             = "ATMEGA1280";
-    signature        = 0x1e 0x97 0x03;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega1281
-#------------------------------------------------------------
-# Identical to ATmega1280
-
-part
-    id               = "m1281";
-    desc             = "ATMEGA1281";
-    signature        = 0x1e 0x97 0x04;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega2560
-#------------------------------------------------------------
-
-part
-    id               = "m2560";
-    desc             = "ATMEGA2560";
-    signature        = 0x1e 0x98 0x01;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 262144;
-        page_size       = 256;
-        num_pages       = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-        load_ext_addr   = "  0   1   0   0      1   1   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0 a16",
-                          "  0   0   0   0      0   0   0   0";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega2561
-#------------------------------------------------------------
-
-part
-    id               = "m2561";
-    desc             = "ATMEGA2561";
-    signature        = 0x1e 0x98 0x02;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x    a11 a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 262144;
-        page_size       = 256;
-        num_pages       = 1024;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-        load_ext_addr   = "  0   1   0   0      1   1   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0 a16",
-                          "  0   0   0   0      0   0   0   0";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  x i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny24
-#------------------------------------------------------------
-
-part
-     id            = "t24";
-     desc          = "ATtiny24";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x91 0x0b;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 128;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0   0 0 0 x  x x x x",
-                           "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 2048;
-         page_size       = 32;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0   0  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x   x   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0  0 a9 a8",
-                           " a7 a6 a5 a4   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny44
-#------------------------------------------------------------
-
-part
-     id            = "t44";
-     desc          = "ATtiny44";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-                     0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x92 0x07;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 256;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x x",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 4096;
-         page_size       = 64;
-         num_pages       = 64;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0    0  a10 a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1  1  0  0",
-                           "  0  0  0  0   0 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# ATtiny84
-#------------------------------------------------------------
-
-part
-     id            = "t84";
-     desc          = "ATtiny84";
-     has_debugwire = yes;
-     flash_instr   = 0xB4, 0x07, 0x17;
-     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,
-	             0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,
-	             0x99, 0xE1, 0xBB, 0xAC;
-## no STK500 devcode in XML file, use the ATtiny45 one
-     stk500_devcode   = 0x14;
-##  avr910_devcode   = ?;
-##  Try the AT90S2313 devcode:
-     avr910_devcode   = 0x20;
-     signature        = 0x1e 0x93 0x0c;
-     reset            = io;
-     chip_erase_delay = 4500;
-
-     pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-     chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 x  x x x x",
-                        "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    hvsp_controlstack   =
-        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,
-        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,
-        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,
-        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;
-    hventerstabdelay    = 100;
-    hvspcmdexedelay     = 0;
-    synchcycles         = 6;
-    latchcycles         = 1;
-    togglevtg           = 1;
-    poweroffdelay       = 25;
-    resetdelayms        = 0;
-    resetdelayus        = 70;
-    hvleavestabdelay    = 100;
-    resetdelay          = 25;
-    chiperasepolltimeout = 40;
-    chiperasetime       = 0;
-    programfusepolltimeout = 25;
-    programlockpolltimeout = 25;
-
-     memory "eeprom"
-         size            = 512;
-        paged           = no;
-        page_size       = 4;
-         min_write_delay = 4000;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read            = "1  0  1  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";
-
-         write           = "1  1  0  0   0  0  0  0    0 0 0 x  x x x a8",
-                           "a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0   0  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x   x   x   x",
-			  "  x  a6  a5  a4     a3  a2   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 4;
-	readsize	= 256;
-       ;
-     memory "flash"
-         paged           = yes;
-         size            = 8192;
-         page_size       = 64;
-         num_pages       = 128;
-         min_write_delay = 4500;
-         max_write_delay = 4500;
-         readback_p1     = 0xff;
-         readback_p2     = 0xff;
-         read_lo         = "  0   0   1   0    0   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         read_hi         = "  0   0   1   0    1   0   0   0",
-                           "  0   0   0   0  a11 a10  a9  a8",
-                           " a7  a6  a5  a4   a3  a2  a1  a0",
-                           "  o   o   o   o    o   o   o   o";
-
-         loadpage_lo     = "  0   1   0   0    0   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         loadpage_hi     = "  0   1   0   0    1   0   0   0",
-                           "  0   0   0   x    x   x   x   x",
-                           "  x   x   x  a4   a3  a2  a1  a0",
-                           "  i   i   i   i    i   i   i   i";
-
-         writepage       = "  0  1  0  0   1   1   0  0",
-                           "  0  0  0  0  a11 a10 a9 a8",
-                           " a7 a6 a5  x   x  x  x  x",
-                           "  x  x  x  x   x  x  x  x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 32;
-	readsize	= 256;
-       ;
-#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.
-     memory "signature"
-         size            = 3;
-         read            = "0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x",
-                           "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-       ;
-
-     memory "lock"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 1 1 x  x x x x",
-                           "x x x x  x x x x  x x x x  x x i i";
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0",
-                           "0 0 0 0  0 0 0 0  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "lfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "hfuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                           "x x x x  x x x x  i i i i  i i i i";
-
-         read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-       ;
-
-     memory "efuse"
-         size            = 1;
-         write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                           "x x x x  x x x x  x x x x  x x x i";
-
-         read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                           "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-     ;
-
-     memory "calibration"
-         size            = 1;
-         read            = "0  0  1  1   1  0  0  0    0 0 0 x  x x x x",
-                           "0  0  0  0   0  0  0  a0   o o o o  o o o o";
-     ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB646
-#------------------------------------------------------------
-
-part
-    id               = "usb646";
-    desc             = "AT90USB646";
-#    signature        = 0x1e 0x96 0x82; ?
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB647
-#------------------------------------------------------------
-# identical to AT90USB646
-
-part
-    id               = "usb647";
-    desc             = "AT90USB647";
-#    signature        = 0x1e 0x96 0x82; ?
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB1286
-#------------------------------------------------------------
-
-part
-    id               = "usb1286";
-    desc             = "AT90USB1286";
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# AT90USB1287
-#------------------------------------------------------------
-# identical to AT90USB1286
-
-part
-    id               = "usb1287";
-    desc             = "AT90USB1287";
-    signature        = 0x1e 0x97 0x82;
-    has_jtag         = yes;
-#    stk500_devcode   = 0xB2;
-#    avr910_devcode   = 0x43;
-    chip_erase_delay = 9000;
-    pagel            = 0xD7;
-    bs2              = 0xA0;
-    reset            = dedicated;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "x x x x  x x x x    x x x x  x x x x";
-
-    timeout		= 200;
-    stabdelay		= 100;
-    cmdexedelay		= 25;
-    synchloops		= 32;
-    bytedelay		= 0;
-    pollindex		= 3;
-    pollvalue		= 0x53;
-    predelay		= 1;
-    postdelay		= 1;
-    pollmethod		= 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    rampz               = 0x3b;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 4096;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  x   x   x   x    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0", 
-                          "  i   i   i   i      i   i   i   i";
-
-	loadpage_lo	= "  1   1   0   0      0   0   0   1",
-			  "  0   0   0   0      0   0   0   0",
-			  "  0   0   0   0      0  a2  a1  a0",
-			  "  i   i   i   i      i   i   i   i";
-
-	writepage	= "  1   1   0   0      0   0   1   0",
-			  "  0   0   x   x      x a10  a9  a8",
-			  " a7  a6  a5  a4     a3   0   0   0",
-			  "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 10;
-	blocksize	= 8;
-	readsize	= 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 131072;
-        page_size       = 256;
-        num_pages       = 512;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0x00;
-        readback_p2     = 0x00;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  x   x   x   x      x   x   x   x",
-                          "  x  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "a15 a14 a13 a12    a11 a10  a9  a8",
-                          " a7   x   x   x      x   x   x   x",
-                          "  x   x   x   x      x   x   x   x";
-
-	mode		= 0x41;
-	delay		= 6;
-	blocksize	= 256;
-	readsize	= 256;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
-                          "x x x x  x x x x  i i i i  i i i i";
-
-        read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "x x x x  x x x x  x x x x  i i i i";
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "x x x x  x x x x  o o o o  o o o o";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
-                          "x x x x  x x x x   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "calibration"
-        size            = 1;
-        read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
-                          "0 0 0 0  0 0 0 0    o o o o  o o o o";
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
-                          "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
-      ;
-  ;
-
-#------------------------------------------------------------
-# ATmega325
-#------------------------------------------------------------
-
-part
-    id               = "m325";
-    desc             = "ATMEGA325";
-    signature        = 0x1e 0x95 0x05;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega645
-#------------------------------------------------------------
-
-part
-    id               = "m645";
-    desc             = "ATMEGA645";
-    signature        = 0x1E 0x96 0x05;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3   0   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 8;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "   0   0   1   0      0   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        read_hi         = "   0   0   1   0      1   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "   0   1   0   0      1   1   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   0   0   0   0      0   0   0   0";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega3250
-#------------------------------------------------------------
-
-part
-    id               = "m3250";
-    desc             = "ATMEGA3250";
-    signature        = 0x1E 0x95 0x06;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 4;  /* for parallel programming */
-        size            = 1024;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0   0  a9  a8",
-                          " a7  a6  a5  a4     a3  a2   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 32768;
-        page_size       = 128;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "  0   0   1   0      0   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        read_hi         = "  0   0   1   0      1   0   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  0   1   0   0      1   1   0   0",
-                          "  0 a14 a13 a12    a11 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
-
-#------------------------------------------------------------
-# ATmega6450
-#------------------------------------------------------------
-
-part
-    id               = "m6450";
-    desc             = "ATMEGA6450";
-    signature        = 0x1E 0x96 0x06;
-    has_jtag         = yes;
-#   stk500_devcode   = 0x??; # No STK500v1 support?
-#   avr910_devcode   = 0x??; # Try the ATmega16 one
-    avr910_devcode   = 0x74;
-    pagel            = 0xd7;
-    bs2              = 0xa0;
-    chip_erase_delay = 9000;
-    pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
-                       "0 0 0 0  0 0 0 0    0 0 0 0  0 0 0 0";
-
-    timeout             = 200;
-    stabdelay           = 100;
-    cmdexedelay         = 25;
-    synchloops          = 32;
-    bytedelay           = 0;
-    pollindex           = 3;
-    pollvalue           = 0x53;
-    predelay            = 1;
-    postdelay           = 1;
-    pollmethod          = 1;
-
-    pp_controlstack     =
-        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
-        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
-        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
-        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
-    hventerstabdelay    = 100;
-    progmodedelay       = 0;
-    latchcycles         = 5;
-    togglevtg           = 1;
-    poweroffdelay       = 15;
-    resetdelayms        = 1;
-    resetdelayus        = 0;
-    hvleavestabdelay    = 15;
-    chiperasepulsewidth = 0;
-    chiperasepolltimeout = 10;
-    programfusepulsewidth = 0;
-    programfusepolltimeout = 5;
-    programlockpulsewidth = 0;
-    programlockpolltimeout = 5;
-
-    idr                 = 0x31;
-    spmcr               = 0x57;
-    allowfullpagebitstream = no;
-
-    memory "eeprom"
-        paged           = no; /* leave this "no" */
-        page_size       = 8;  /* for parallel programming */
-        size            = 2048;
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read            = "  1   0   1   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  o   o   o   o      o   o   o   o";
-
-        write           = "  1   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_lo     = "  1   1   0   0      0   0   0   1",
-                          "  0   0   0   0      0   0   0   0",
-                          "  0   0   0   0      0  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "  1   1   0   0      0   0   1   0",
-                          "  0   0   0   0      0 a10  a9  a8",
-                          " a7  a6  a5  a4     a3   0   0   0",
-                          "  x   x   x   x      x   x   x   x";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 4;
-        readsize        = 256;
-      ;
-
-    memory "flash"
-        paged           = yes;
-        size            = 65536;
-        page_size       = 256;
-        num_pages       = 256;
-        min_write_delay = 4500;
-        max_write_delay = 4500;
-        readback_p1     = 0xff;
-        readback_p2     = 0xff;
-        read_lo         = "   0   0   1   0      0   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        read_hi         = "   0   0   1   0      1   0   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   o   o   o   o      o   o   o   o";
-
-        loadpage_lo     = "  0   1   0   0      0   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        loadpage_hi     = "  0   1   0   0      1   0   0   0",
-                          "  0   0   0   0      0   0   0   0",
-                          "  a7 a6  a5  a4     a3  a2  a1  a0",
-                          "  i   i   i   i      i   i   i   i";
-
-        writepage       = "   0   1   0   0      1   1   0   0",
-                          " a15 a14 a13 a12    a11 a10  a9  a8",
-                          "  a7  a6  a5  a4     a3  a2  a1  a0",
-                          "   0   0   0   0      0   0   0   0";
-
-        mode            = 0x41;
-        delay           = 10;
-        blocksize       = 128;
-        readsize        = 256;
-      ;
-
-    memory "lock"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "x x x x  x x x x   x x o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 1 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   1 1 i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "lfuse"
-        size            = 1;
-        read            = "0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "hfuse"
-        size            = 1;
-        read            = "0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0   i i i i  i i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "efuse"
-        size            = 1;
-
-        read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
-                          "0 0 0 0  0 0 0 0  o o o o  o o o o";
-
-        write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
-                          "0 0 0 0  0 0 0 0  1 1 1 1  1 i i i";
-        min_write_delay = 9000;
-        max_write_delay = 9000;
-      ;
-
-    memory "signature"
-        size            = 3;
-        read            = "0  0  1  1   0  0  0  0   0  0  0  0   0  0  0  0",
-                          "0  0  0  0   0  0 a1 a0   o  o  o  o   o  o  o  o";
-      ;
-
-    memory "calibration"
-        size            = 1;
-
-        read            = "0 0 1 1  1 0 0 0   0 0 0 0  0 0 0 0",
-                          "0 0 0 0  0 0 0 0   o o o o  o o o o";
-        ;
-  ;
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 81f26f6..81b2ab7 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -824,38 +824,36 @@ void st_init()
   #if (X_STEP_PIN > -1) 
     SET_OUTPUT(X_STEP_PIN);
     WRITE(X_STEP_PIN,INVERT_X_STEP_PIN);
-    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);
+    disable_x();
   #endif  
   #if (Y_STEP_PIN > -1) 
     SET_OUTPUT(Y_STEP_PIN);
     WRITE(Y_STEP_PIN,INVERT_Y_STEP_PIN);
-    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);
+    disable_y();
   #endif  
   #if (Z_STEP_PIN > -1) 
     SET_OUTPUT(Z_STEP_PIN);
     WRITE(Z_STEP_PIN,INVERT_Z_STEP_PIN);
-    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);
-    
     #if defined(Z_DUAL_STEPPER_DRIVERS) && (Z2_STEP_PIN > -1)
       SET_OUTPUT(Z2_STEP_PIN);
       WRITE(Z2_STEP_PIN,INVERT_Z_STEP_PIN);
-      if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);
     #endif
+    disable_z();
   #endif  
   #if (E0_STEP_PIN > -1) 
     SET_OUTPUT(E0_STEP_PIN);
     WRITE(E0_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);
+    disable_e0();
   #endif  
   #if defined(E1_STEP_PIN) && (E1_STEP_PIN > -1) 
     SET_OUTPUT(E1_STEP_PIN);
     WRITE(E1_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E1_ENABLE_PIN,HIGH);
+    disable_e1();
   #endif  
   #if defined(E2_STEP_PIN) && (E2_STEP_PIN > -1) 
     SET_OUTPUT(E2_STEP_PIN);
     WRITE(E2_STEP_PIN,INVERT_E_STEP_PIN);
-    if(!E_ENABLE_ON) WRITE(E2_ENABLE_PIN,HIGH);
+    disable_e2();
   #endif  
 
   #ifdef CONTROLLERFAN_PIN
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 9226f6e..e925456 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -37,19 +37,14 @@
 //===========================================================================
 //=============================public variables============================
 //===========================================================================
-int target_raw[EXTRUDERS] = { 0 };
-int target_raw_bed = 0;
-#ifdef BED_LIMIT_SWITCHING
-int target_bed_low_temp =0;  
-int target_bed_high_temp =0;
-#endif
-int current_raw[EXTRUDERS] = { 0 };
-int current_raw_bed = 0;
+int target_temperature[EXTRUDERS] = { 0 };
+int target_temperature_bed = 0;
+int current_temperature_raw[EXTRUDERS] = { 0 };
+float current_temperature[EXTRUDERS] = { 0 };
+int current_temperature_bed_raw = 0;
+float current_temperature_bed = 0;
 
 #ifdef PIDTEMP
-  // used external
-  float pid_setpoint[EXTRUDERS] = { 0.0 };
-  
   float Kp=DEFAULT_Kp;
   float Ki=(DEFAULT_Ki*PID_dT);
   float Kd=(DEFAULT_Kd/PID_dT);
@@ -59,9 +54,6 @@ int current_raw_bed = 0;
 #endif //PIDTEMP
 
 #ifdef PIDTEMPBED
-  // used external
-  float pid_setpoint_bed = { 0.0 };
-  
   float bedKp=DEFAULT_bedKp;
   float bedKi=(DEFAULT_bedKi*PID_dT);
   float bedKd=(DEFAULT_bedKd/PID_dT);
@@ -116,12 +108,20 @@ static volatile bool temp_meas_ready = false;
 #endif
 
 // Init min and max temp with extreme values to prevent false errors during startup
-static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0, 0, 0);
-static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(16383, 16383, 16383); // the first value used for all
-static int bed_minttemp = 0;
-static int bed_maxttemp = 16383;
-static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS((void *)heater_0_temptable, (void *)heater_1_temptable, (void *)heater_2_temptable);
-static int heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS(heater_0_temptable_len, heater_1_temptable_len, heater_2_temptable_len);
+static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP );
+static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP );
+static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 0, 0, 0 );
+static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
+//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */
+#ifdef BED_MAXTEMP
+static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
+#endif
+static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
+static int heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
+
+static float analog2temp(int raw, uint8_t e);
+static float analog2tempBed(int raw);
+static void updateTemperaturesFromRawValues();
 
 #ifdef WATCH_TEMP_PERIOD
 int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
@@ -179,13 +179,9 @@ void PID_autotune(float temp, int extruder, int ncycles)
  for(;;) {
 
     if(temp_meas_ready == true) { // temp sample ready
-      //Reset the watchdog after we know we have a temperature measurement.
-      watchdog_reset();
-      
-      CRITICAL_SECTION_START;
-      temp_meas_ready = false;
-      CRITICAL_SECTION_END;
-      input = (extruder<0)?analog2tempBed(current_raw_bed):analog2temp(current_raw[extruder], extruder);
+      updateTemperaturesFromRawValues();
+
+      input = (extruder<0)?current_temperature_bed:current_temperature[extruder];
 
       max=max(max,input);
       min=min(min,input);
@@ -313,21 +309,16 @@ void manage_heater()
   if(temp_meas_ready != true)   //better readability
     return; 
 
-  //Reset the watchdog after we know we have a temperature measurement.
-  watchdog_reset();
-
-  CRITICAL_SECTION_START;
-  temp_meas_ready = false;
-  CRITICAL_SECTION_END;
+  updateTemperaturesFromRawValues();
 
   for(int e = 0; e < EXTRUDERS; e++) 
   {
 
   #ifdef PIDTEMP
-    pid_input = analog2temp(current_raw[e], e);
+    pid_input = current_temperature[e];
 
     #ifndef PID_OPENLOOP
-        pid_error[e] = pid_setpoint[e] - pid_input;
+        pid_error[e] = target_temperature[e] - pid_input;
         if(pid_error[e] > 10) {
           pid_output = PID_MAX;
           pid_reset[e] = true;
@@ -354,20 +345,31 @@ void manage_heater()
           pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);
         }
     #else 
-          pid_output = constrain(pid_setpoint[e], 0, PID_MAX);
+          pid_output = constrain(target_temperature[e], 0, PID_MAX);
     #endif //PID_OPENLOOP
     #ifdef PID_DEBUG
-    SERIAL_ECHOLN(" PIDDEBUG "<<e<<": Input "<<pid_input<<" Output "<<pid_output" pTerm "<<pTerm[e]<<" iTerm "<<iTerm[e]<<" dTerm "<<dTerm[e]);  
+    SERIAL_ECHO_START(" PIDDEBUG ");
+    SERIAL_ECHO(e);
+    SERIAL_ECHO(": Input ");
+    SERIAL_ECHO(pid_input);
+    SERIAL_ECHO(" Output ");
+    SERIAL_ECHO(pid_output);
+    SERIAL_ECHO(" pTerm ");
+    SERIAL_ECHO(pTerm[e]);
+    SERIAL_ECHO(" iTerm ");
+    SERIAL_ECHO(iTerm[e]);
+    SERIAL_ECHO(" dTerm ");
+    SERIAL_ECHOLN(dTerm[e]);  
     #endif //PID_DEBUG
   #else /* PID off */
     pid_output = 0;
-    if(current_raw[e] < target_raw[e]) {
+    if(current_temperature[e] < target_temperature[e]) {
       pid_output = PID_MAX;
     }
   #endif
 
     // Check if temperature is within the correct range
-    if((current_raw[e] > minttemp[e]) && (current_raw[e] < maxttemp[e])) 
+    if((current_temperature[e] > minttemp[e]) && (current_temperature[e] < maxttemp[e])) 
     {
       soft_pwm[e] = (int)pid_output >> 1;
     }
@@ -393,19 +395,19 @@ void manage_heater()
   } // End extruder for loop
   
 
-		#ifndef PIDTEMPBED
+  #ifndef PIDTEMPBED
   if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
     return;
   previous_millis_bed_heater = millis();
-    #endif
+  #endif
 
-  #if TEMP_BED_PIN > -1
+  #if TEMP_SENSOR_BED != 0
   
-		#ifdef PIDTEMPBED
-    pid_input = analog2tempBed(current_raw_bed);
+  #ifdef PIDTEMPBED
+    pid_input = current_temperature_bed;
 
     #ifndef PID_OPENLOOP
-		  pid_error_bed = pid_setpoint_bed - pid_input;
+		  pid_error_bed = target_temperature_bed - pid_input;
 		  pTerm_bed = bedKp * pid_error_bed;
 		  temp_iState_bed += pid_error_bed;
 		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
@@ -419,10 +421,10 @@ void manage_heater()
 		  pid_output = constrain(pTerm_bed + iTerm_bed - dTerm_bed, 0, MAX_BED_POWER);
 
     #else 
-      pid_output = constrain(pid_setpoint_bed, 0, MAX_BED_POWER);
+      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
     #endif //PID_OPENLOOP
 
-	  if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) 
+	  if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP)) 
 	  {
 	    soft_pwm_bed = (int)pid_output >> 1;
 	  }
@@ -432,35 +434,38 @@ void manage_heater()
 
     #elif not defined BED_LIMIT_SWITCHING
       // Check if temperature is within the correct range
-      if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
-        if(current_raw_bed >= target_raw_bed)
+      if((current_temperature_bed > BED_MAXTEMP) && (current_temperature_bed < BED_MINTEMP))
+      {
+        if(current_temperature_bed >= target_temperature_bed)
         {
-					soft_pwm_bed = 0;
+          soft_pwm_bed = 0;
         }
         else 
         {
-					soft_pwm_bed = MAX_BED_POWER>>1;
+          soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
-      else {
-					soft_pwm_bed = 0;
+      else
+      {
+        soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #else //#ifdef BED_LIMIT_SWITCHING
       // Check if temperature is within the correct band
-      if((current_raw_bed > bed_minttemp) && (current_raw_bed < bed_maxttemp)) {
-        if(current_raw_bed > target_bed_high_temp)
+      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
+      {
+        if(current_temperature_bed > target_temperature_bed + BED_HYSTERESIS)
         {
-					soft_pwm_bed = 0;
+          soft_pwm_bed = 0;
         }
-        else 
-          if(current_raw_bed <= target_bed_low_temp)
+        else if(current_temperature_bed <= target_temperature_bed - BED_HYSTERESIS)
         {
-					soft_pwm_bed = MAX_BED_POWER>>1;
+          soft_pwm_bed = MAX_BED_POWER>>1;
         }
       }
-      else {
-					soft_pwm_bed = 0;
+      else
+      {
+        soft_pwm_bed = 0;
         WRITE(HEATER_BED_PIN,LOW);
       }
     #endif
@@ -468,86 +473,9 @@ void manage_heater()
 }
 
 #define PGM_RD_W(x)   (short)pgm_read_word(&x)
-// Takes hot end temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analog(int celsius, uint8_t e) {
-  if(e >= EXTRUDERS)
-  {
-      SERIAL_ERROR_START;
-      SERIAL_ERROR((int)e);
-      SERIAL_ERRORLNPGM(" - Invalid extruder number!");
-      kill();
-  }
-  #ifdef HEATER_0_USES_MAX6675
-    if (e == 0)
-    {
-      return celsius * 4;
-    }
-  #endif
-  if(heater_ttbl_map[e] != 0)
-  {
-    int raw = 0;
-    byte i;
-    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
-
-    for (i=1; i<heater_ttbllen_map[e]; i++)
-    {
-      if (PGM_RD_W((*tt)[i][1]) < celsius)
-      {
-        raw = PGM_RD_W((*tt)[i-1][0]) + 
-          (celsius - PGM_RD_W((*tt)[i-1][1])) * 
-          (PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0])) /
-          (PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1]));  
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == heater_ttbllen_map[e]) raw = PGM_RD_W((*tt)[i-1][0]);
-
-    return (1023 * OVERSAMPLENR) - raw;
-  }
-  return ((celsius-TEMP_SENSOR_AD595_OFFSET)/TEMP_SENSOR_AD595_GAIN) * (1024.0 / (5.0 * 100.0) ) * OVERSAMPLENR;
-}
-
-// Takes bed temperature value as input and returns corresponding raw value. 
-// For a thermistor, it uses the RepRap thermistor temp table.
-// This is needed because PID in hydra firmware hovers around a given analog value, not a temp value.
-// This function is derived from inversing the logic from a portion of getTemperature() in FiveD RepRap firmware.
-int temp2analogBed(int celsius) {
-#ifdef BED_USES_THERMISTOR
-    int raw = 0;
-    byte i;
-    
-    for (i=1; i<bedtemptable_len; i++)
-    {
-      if (PGM_RD_W(bedtemptable[i][1]) < celsius)
-      {
-        raw = PGM_RD_W(bedtemptable[i-1][0]) + 
-          (celsius - PGM_RD_W(bedtemptable[i-1][1])) * 
-          (PGM_RD_W(bedtemptable[i][0]) - PGM_RD_W(bedtemptable[i-1][0])) /
-          (PGM_RD_W(bedtemptable[i][1]) - PGM_RD_W(bedtemptable[i-1][1]));
-      
-        break;
-      }
-    }
-
-    // Overflow: Set to last value in the table
-    if (i == bedtemptable_len) raw = PGM_RD_W(bedtemptable[i-1][0]);
-
-    return (1023 * OVERSAMPLENR) - raw;
-#elif defined BED_USES_AD595
-    return lround(((celsius-TEMP_SENSOR_AD595_OFFSET)/TEMP_SENSOR_AD595_GAIN) * (1024.0 * OVERSAMPLENR/ (5.0 * 100.0) ) );
-#else
-    return 0;
-#endif
-}
-
 // Derived from RepRap FiveD extruder::getTemperature()
 // For hot end temperature measurement.
-float analog2temp(int raw, uint8_t e) {
+static float analog2temp(int raw, uint8_t e) {
   if(e >= EXTRUDERS)
   {
       SERIAL_ERROR_START;
@@ -565,10 +493,9 @@ float analog2temp(int raw, uint8_t e) {
   if(heater_ttbl_map[e] != NULL)
   {
     float celsius = 0;
-    byte i;  
+    byte i;
     short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);
 
-    raw = (1023 * OVERSAMPLENR) - raw;
     for (i=1; i<heater_ttbllen_map[e]; i++)
     {
       if (PGM_RD_W((*tt)[i][0]) > raw)
@@ -591,13 +518,11 @@ float analog2temp(int raw, uint8_t e) {
 
 // Derived from RepRap FiveD extruder::getTemperature()
 // For bed temperature measurement.
-float analog2tempBed(int raw) {
+static float analog2tempBed(int raw) {
   #ifdef BED_USES_THERMISTOR
     float celsius = 0;
     byte i;
 
-    raw = (1023 * OVERSAMPLENR) - raw;
-
     for (i=1; i<bedtemptable_len; i++)
     {
       if (PGM_RD_W(bedtemptable[i][0]) > raw)
@@ -621,6 +546,24 @@ float analog2tempBed(int raw) {
   #endif
 }
 
+/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,
+    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */
+static void updateTemperaturesFromRawValues()
+{
+    for(uint8_t e=0;e<EXTRUDERS;e++)
+    {
+        current_temperature[e] = analog2temp(current_temperature_raw[e], e);
+    }
+    current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
+
+    //Reset the watchdog after we know we have a temperature measurement.
+    watchdog_reset();
+
+    CRITICAL_SECTION_START;
+    temp_meas_ready = false;
+    CRITICAL_SECTION_END;
+}
+
 void tp_init()
 {
   // Finish init of mult extruder arrays 
@@ -716,31 +659,87 @@ void tp_init()
   delay(250);
 
 #ifdef HEATER_0_MINTEMP
-  minttemp[0] = temp2analog(HEATER_0_MINTEMP, 0);
+  minttemp[0] = HEATER_0_MINTEMP;
+  while(analog2temp(minttemp_raw[0], 0) < HEATER_0_MINTEMP) {
+#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
+    minttemp_raw[0] += OVERSAMPLENR;
+#else
+    minttemp_raw[0] -= OVERSAMPLENR;
+#endif
+  }
 #endif //MINTEMP
 #ifdef HEATER_0_MAXTEMP
-  maxttemp[0] = temp2analog(HEATER_0_MAXTEMP, 0);
+  maxttemp[0] = HEATER_0_MAXTEMP;
+  while(analog2temp(maxttemp_raw[0], 0) > HEATER_0_MAXTEMP) {
+#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
+    maxttemp_raw[0] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[0] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP
 
 #if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
-  minttemp[1] = temp2analog(HEATER_1_MINTEMP, 1);
+  minttemp[1] = HEATER_1_MINTEMP;
+  while(analog2temp(minttemp_raw[1], 1) > HEATER_1_MINTEMP) {
+#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
+    minttemp_raw[1] += OVERSAMPLENR;
+#else
+    minttemp_raw[1] -= OVERSAMPLENR;
+#endif
+  }
 #endif // MINTEMP 1
 #if (EXTRUDERS > 1) && defined(HEATER_1_MAXTEMP)
-  maxttemp[1] = temp2analog(HEATER_1_MAXTEMP, 1);
+  maxttemp[1] = HEATER_1_MAXTEMP;
+  while(analog2temp(maxttemp_raw[1], 1) > HEATER_1_MAXTEMP) {
+#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
+    maxttemp_raw[1] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[1] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP 1
 
 #if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
-  minttemp[2] = temp2analog(HEATER_2_MINTEMP, 2);
+  minttemp[2] = HEATER_2_MINTEMP;
+  while(analog2temp(minttemp_raw[2], 2) > HEATER_2_MINTEMP) {
+#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
+    minttemp_raw[2] += OVERSAMPLENR;
+#else
+    minttemp_raw[2] -= OVERSAMPLENR;
+#endif
+  }
 #endif //MINTEMP 2
 #if (EXTRUDERS > 2) && defined(HEATER_2_MAXTEMP)
-  maxttemp[2] = temp2analog(HEATER_2_MAXTEMP, 2);
+  maxttemp[2] = HEATER_2_MAXTEMP;
+  while(analog2temp(maxttemp_raw[2], 2) > HEATER_2_MAXTEMP) {
+#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
+    maxttemp_raw[2] -= OVERSAMPLENR;
+#else
+    maxttemp_raw[2] += OVERSAMPLENR;
+#endif
+  }
 #endif //MAXTEMP 2
 
 #ifdef BED_MINTEMP
-  bed_minttemp = temp2analogBed(BED_MINTEMP);
+  /* No bed MINTEMP error implemented?!? */ /*
+  while(analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
+#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+    bed_minttemp_raw += OVERSAMPLENR;
+#else
+    bed_minttemp_raw -= OVERSAMPLENR;
+#endif
+  }
+  */
 #endif //BED_MINTEMP
 #ifdef BED_MAXTEMP
-  bed_maxttemp = temp2analogBed(BED_MAXTEMP);
+  while(analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
+#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
+    bed_maxttemp_raw -= OVERSAMPLENR;
+#else
+    bed_maxttemp_raw += OVERSAMPLENR;
+#endif
+  }
 #endif //BED_MAXTEMP
 }
 
@@ -765,7 +764,7 @@ void disable_heater()
     setTargetHotend(0,i);
   setTargetBed(0);
   #if TEMP_0_PIN > -1
-  target_raw[0]=0;
+  target_temperature[0]=0;
   soft_pwm[0]=0;
    #if HEATER_0_PIN > -1  
      WRITE(HEATER_0_PIN,LOW);
@@ -773,7 +772,7 @@ void disable_heater()
   #endif
      
   #if TEMP_1_PIN > -1
-    target_raw[1]=0;
+    target_temperature[1]=0;
     soft_pwm[1]=0;
     #if HEATER_1_PIN > -1 
       WRITE(HEATER_1_PIN,LOW);
@@ -781,7 +780,7 @@ void disable_heater()
   #endif
       
   #if TEMP_2_PIN > -1
-    target_raw[2]=0;
+    target_temperature[2]=0;
     soft_pwm[2]=0;
     #if HEATER_2_PIN > -1  
       WRITE(HEATER_2_PIN,LOW);
@@ -789,7 +788,7 @@ void disable_heater()
   #endif 
 
   #if TEMP_BED_PIN > -1
-    target_raw_bed=0;
+    target_temperature_bed=0;
     soft_pwm_bed=0;
     #if HEATER_BED_PIN > -1  
       WRITE(HEATER_BED_PIN,LOW);
@@ -803,6 +802,7 @@ void max_temp_error(uint8_t e) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLN((int)e);
     SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");
+    LCD_ALERTMESSAGEPGM("Err: MAXTEMP");
   }
   #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
   Stop();
@@ -815,6 +815,7 @@ void min_temp_error(uint8_t e) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLN((int)e);
     SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");
+    LCD_ALERTMESSAGEPGM("Err: MINTEMP");
   }
   #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
   Stop();
@@ -828,6 +829,7 @@ void bed_max_temp_error(void) {
   if(IsStopped() == false) {
     SERIAL_ERROR_START;
     SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
+    LCD_ALERTMESSAGEPGM("Err: MAXTEMP BED");
   }
   #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
   Stop();
@@ -1031,33 +1033,16 @@ ISR(TIMER0_COMPB_vect)
     
   if(temp_count >= 16) // 8 ms * 16 = 128ms.
   {
-    #if defined(HEATER_0_USES_AD595) || defined(HEATER_0_USES_MAX6675)
-      current_raw[0] = raw_temp_0_value;
-    #else
-      current_raw[0] = 16383 - raw_temp_0_value;
-    #endif
-
-#if EXTRUDERS > 1    
-    #ifdef HEATER_1_USES_AD595
-      current_raw[1] = raw_temp_1_value;
-    #else
-      current_raw[1] = 16383 - raw_temp_1_value;
-    #endif
+    if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.
+    {
+      current_temperature_raw[0] = raw_temp_0_value;
+#if EXTRUDERS > 1
+      current_temperature_raw[1] = raw_temp_1_value;
 #endif
-    
 #if EXTRUDERS > 2
-    #ifdef HEATER_2_USES_AD595
-      current_raw[2] = raw_temp_2_value;
-    #else
-      current_raw[2] = 16383 - raw_temp_2_value;
-    #endif
+      current_temperature_raw[2] = raw_temp_2_value;
 #endif
-    
-    #ifdef BED_USES_AD595
-      current_raw_bed = raw_temp_bed_value;
-    #else
-      current_raw_bed = 16383 - raw_temp_bed_value;
-    #endif
+    }
     
     temp_meas_ready = true;
     temp_count = 0;
@@ -1066,23 +1051,63 @@ ISR(TIMER0_COMPB_vect)
     raw_temp_2_value = 0;
     raw_temp_bed_value = 0;
 
-    for(unsigned char e = 0; e < EXTRUDERS; e++) {
-       if(current_raw[e] >= maxttemp[e]) {
-          target_raw[e] = 0;
-          max_temp_error(e);
-       }
-       if(current_raw[e] <= minttemp[e]) {
-          target_raw[e] = 0;
-          min_temp_error(e);
-       }
+#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
+    if(current_temperature_raw[0] <= maxttemp_raw[0]) {
+#else
+    if(current_temperature_raw[0] >= maxttemp_raw[0]) {
+#endif
+        max_temp_error(0);
+    }
+#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
+    if(current_temperature_raw[0] >= minttemp_raw[0]) {
+#else
+    if(current_temperature_raw[0] <= minttemp_raw[0]) {
+#endif
+        min_temp_error(0);
+    }
+#if EXTRUDERS > 1
+#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
+    if(current_temperature_raw[1] <= maxttemp_raw[1]) {
+#else
+    if(current_temperature_raw[1] >= maxttemp_raw[1]) {
+#endif
+        max_temp_error(1);
     }
+#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
+    if(current_temperature_raw[1] >= minttemp_raw[1]) {
+#else
+    if(current_temperature_raw[1] <= minttemp_raw[1]) {
+#endif
+        min_temp_error(1);
+    }
+#endif
+#if EXTRUDERS > 2
+#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
+    if(current_temperature_raw[2] <= maxttemp_raw[2]) {
+#else
+    if(current_temperature_raw[2] >= maxttemp_raw[2]) {
+#endif
+        max_temp_error(2);
+    }
+#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
+    if(current_temperature_raw[2] >= minttemp_raw[2]) {
+#else
+    if(current_temperature_raw[2] <= minttemp_raw[2]) {
+#endif
+        min_temp_error(2);
+    }
+#endif
   
-#if defined(BED_MAXTEMP) && (HEATER_BED_PIN > -1)
-    if(current_raw_bed >= bed_maxttemp) {
-       target_raw_bed = 0;
+  /* No bed MINTEMP error? */
+#if defined(BED_MAXTEMP) && (TEMP_SENSOR_BED != 0)
+# if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
+    if(current_temperature_bed <= bed_maxttemp_raw) {
+#else
+    if(current_temperature_bed >= bed_maxttemp_raw) {
+#endif
+       target_temperature_bed = 0;
        bed_max_temp_error();
     }
 #endif
-  }
+  }  
 }
-
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 6f45917..feffcbd 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -33,27 +33,16 @@ void manage_heater(); //it is critical that this is called periodically.
 
 //low leven conversion routines
 // do not use this routines and variables outsie of temperature.cpp
-int temp2analog(int celsius, uint8_t e);
-int temp2analogBed(int celsius);
-float analog2temp(int raw, uint8_t e);
-float analog2tempBed(int raw);
-extern int target_raw[EXTRUDERS];  
-extern int heatingtarget_raw[EXTRUDERS];  
-extern int current_raw[EXTRUDERS];
-extern int target_raw_bed;
-extern int current_raw_bed;
-#ifdef BED_LIMIT_SWITCHING
-  extern int target_bed_low_temp ;  
-  extern int target_bed_high_temp ;
-#endif
+extern int target_temperature[EXTRUDERS];  
+extern float current_temperature[EXTRUDERS];
+extern int target_temperature_bed;
+extern float current_temperature_bed;
 
 #ifdef PIDTEMP
   extern float Kp,Ki,Kd,Kc;
-  extern float pid_setpoint[EXTRUDERS];
 #endif
 #ifdef PIDTEMPBED
   extern float bedKp,bedKi,bedKd;
-  extern float pid_setpoint_bed;
 #endif
   
 //high level conversion routines, for use outside of temperature.cpp
@@ -61,61 +50,43 @@ extern int current_raw_bed;
 //deg=degreeCelsius
 
 FORCE_INLINE float degHotend(uint8_t extruder) {  
-  return analog2temp(current_raw[extruder], extruder);
+  return current_temperature[extruder];
 };
 
 FORCE_INLINE float degBed() {
-  return analog2tempBed(current_raw_bed);
+  return current_temperature_bed;
 };
 
 FORCE_INLINE float degTargetHotend(uint8_t extruder) {  
-  return analog2temp(target_raw[extruder], extruder);
+  return target_temperature[extruder];
 };
 
 FORCE_INLINE float degTargetBed() {   
-  return analog2tempBed(target_raw_bed);
+  return target_temperature_bed;
 };
 
 FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  
-  target_raw[extruder] = temp2analog(celsius, extruder);
-#ifdef PIDTEMP
-  pid_setpoint[extruder] = celsius;
-#endif //PIDTEMP
+  target_temperature[extruder] = celsius;
 };
 
 FORCE_INLINE void setTargetBed(const float &celsius) {  
-  
-  target_raw_bed = temp2analogBed(celsius);
-	#ifdef PIDTEMPBED
-  pid_setpoint_bed = celsius;
-  #elif defined BED_LIMIT_SWITCHING
-    if(celsius>BED_HYSTERESIS)
-    {
-    target_bed_low_temp= temp2analogBed(celsius-BED_HYSTERESIS);
-    target_bed_high_temp= temp2analogBed(celsius+BED_HYSTERESIS);
-    }
-    else
-    { 
-      target_bed_low_temp=0;
-      target_bed_high_temp=0;
-    }
-  #endif
+  target_temperature_bed = celsius;
 };
 
 FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  
-  return target_raw[extruder] > current_raw[extruder];
+  return target_temperature[extruder] > current_temperature[extruder];
 };
 
 FORCE_INLINE bool isHeatingBed() {
-  return target_raw_bed > current_raw_bed;
+  return target_temperature_bed > current_temperature_bed;
 };
 
 FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  
-  return target_raw[extruder] < current_raw[extruder];
+  return target_temperature[extruder] < current_temperature[extruder];
 };
 
 FORCE_INLINE bool isCoolingBed() {
-  return target_raw_bed < current_raw_bed;
+  return target_temperature_bed < current_temperature_bed;
 };
 
 #define degHotend0() degHotend(0)
diff --git a/Marlin/thermistortables.h b/Marlin/thermistortables.h
index 698506f..d963aff 100644
--- a/Marlin/thermistortables.h
+++ b/Marlin/thermistortables.h
@@ -461,49 +461,92 @@ const short temptable_55[][2] PROGMEM = {
 #define TT_NAME(_N) _TT_NAME(_N)
 
 #ifdef THERMISTORHEATER_0
-  #define heater_0_temptable TT_NAME(THERMISTORHEATER_0)
-  #define heater_0_temptable_len (sizeof(heater_0_temptable)/sizeof(*heater_0_temptable))
+# define HEATER_0_TEMPTABLE TT_NAME(THERMISTORHEATER_0)
+# define HEATER_0_TEMPTABLE_LEN (sizeof(HEATER_0_TEMPTABLE)/sizeof(*HEATER_0_TEMPTABLE))
 #else
-#ifdef HEATER_0_USES_THERMISTOR
-  #error No heater 0 thermistor table specified
-#else  // HEATER_0_USES_THERMISTOR
-  #define heater_0_temptable 0
-  #define heater_0_temptable_len 0
-#endif // HEATER_0_USES_THERMISTOR
+# ifdef HEATER_0_USES_THERMISTOR
+#  error No heater 0 thermistor table specified
+# else  // HEATER_0_USES_THERMISTOR
+#  define HEATER_0_TEMPTABLE NULL
+#  define HEATER_0_TEMPTABLE_LEN 0
+# endif // HEATER_0_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_0_RAW_HI_TEMP
+# if HEATER_0_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_0_RAW_HI_TEMP 0
+#  define HEATER_0_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_0_RAW_HI_TEMP 16383
+#  define HEATER_0_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORHEATER_1
-  #define heater_1_temptable TT_NAME(THERMISTORHEATER_1)
-  #define heater_1_temptable_len (sizeof(heater_1_temptable)/sizeof(*heater_1_temptable))
+# define HEATER_1_TEMPTABLE TT_NAME(THERMISTORHEATER_1)
+# define HEATER_1_TEMPTABLE_LEN (sizeof(HEATER_1_TEMPTABLE)/sizeof(*HEATER_1_TEMPTABLE))
 #else
-#ifdef HEATER_1_USES_THERMISTOR
-  #error No heater 1 thermistor table specified
-#else  // HEATER_1_USES_THERMISTOR
-  #define heater_1_temptable 0
-  #define heater_1_temptable_len 0
-#endif // HEATER_1_USES_THERMISTOR
+# ifdef HEATER_1_USES_THERMISTOR
+#  error No heater 1 thermistor table specified
+# else  // HEATER_1_USES_THERMISTOR
+#  define HEATER_1_TEMPTABLE NULL
+#  define HEATER_1_TEMPTABLE_LEN 0
+# endif // HEATER_1_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_1_RAW_HI_TEMP
+# if HEATER_1_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_1_RAW_HI_TEMP 0
+#  define HEATER_1_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_1_RAW_HI_TEMP 16383
+#  define HEATER_1_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORHEATER_2
-  #define heater_2_temptable TT_NAME(THERMISTORHEATER_2)
-  #define heater_2_temptable_len (sizeof(heater_2_temptable)/sizeof(*heater_2_temptable))
+# define HEATER_2_TEMPTABLE TT_NAME(THERMISTORHEATER_2)
+# define HEATER_2_TEMPTABLE_LEN (sizeof(HEATER_2_TEMPTABLE)/sizeof(*HEATER_2_TEMPTABLE))
 #else
-#ifdef HEATER_2_USES_THERMISTOR
-  #error No heater 2 thermistor table specified
-#else  // HEATER_2_USES_THERMISTOR
-  #define heater_2_temptable 0
-  #define heater_2_temptable_len 0
-#endif // HEATER_2_USES_THERMISTOR
+# ifdef HEATER_2_USES_THERMISTOR
+#  error No heater 2 thermistor table specified
+# else  // HEATER_2_USES_THERMISTOR
+#  define HEATER_2_TEMPTABLE NULL
+#  define HEATER_2_TEMPTABLE_LEN 0
+# endif // HEATER_2_USES_THERMISTOR
+#endif
+
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_2_RAW_HI_TEMP
+# if HEATER_2_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_2_RAW_HI_TEMP 0
+#  define HEATER_2_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_2_RAW_HI_TEMP 16383
+#  define HEATER_2_RAW_LO_TEMP 0
+# endif
 #endif
 
 #ifdef THERMISTORBED
-  #define bedtemptable TT_NAME(THERMISTORBED)
-  #define bedtemptable_len (sizeof(bedtemptable)/sizeof(*bedtemptable))
+# define BEDTEMPTABLE TT_NAME(THERMISTORBED)
+# define BEDTEMPTABLE_LEN (sizeof(BEDTEMPTABLE)/sizeof(*BEDTEMPTABLE))
 #else
-#ifdef BED_USES_THERMISTOR
-  #error No bed thermistor table specified
-#endif // BED_USES_THERMISTOR
+# ifdef BED_USES_THERMISTOR
+#  error No bed thermistor table specified
+# endif // BED_USES_THERMISTOR
 #endif
 
-#endif //THERMISTORTABLES_H_
+//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature
+#ifndef HEATER_BED_RAW_HI_TEMP
+# if BED_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value
+#  define HEATER_BED_RAW_HI_TEMP 0
+#  define HEATER_BED_RAW_LO_TEMP 16383
+# else                          //In case of an thermocouple the highest temperature results in the highest ADC value
+#  define HEATER_BED_RAW_HI_TEMP 16383
+#  define HEATER_BED_RAW_LO_TEMP 0
+# endif
+#endif
 
+#endif //THERMISTORTABLES_H_
diff --git a/README.md b/README.md
index bbc501e..309fdd1 100644
--- a/README.md
+++ b/README.md
@@ -184,11 +184,11 @@ MISC:
 Configuring and compilation:
 ============================
 
-Install the arduino software IDE/toolset v22
+Install the arduino software IDE/toolset v23 (Some configurations also work with 1.x.x)
    http://www.arduino.cc/en/Main/Software
 
-For gen6 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
-  copy Marlin\sanguino <arduino home>\hardware\Sanguino
+For gen6/gen7 and sanguinololu the Sanguino directory in the Marlin dir needs to be copied to the arduino environment.
+  copy ArduinoAddons\Arduino_x.x.x\sanguino <arduino home>\hardware\Sanguino
 
 Install Ultimaker's RepG 25 build
     http://software.ultimaker.com

