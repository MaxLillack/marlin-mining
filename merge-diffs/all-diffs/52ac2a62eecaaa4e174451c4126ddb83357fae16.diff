commit 52ac2a62eecaaa4e174451c4126ddb83357fae16 (from d2a00b74e3736c87ed28b02eb3dcdba0c2bac5d8)
Merge: d2a00b7 7fb69e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 14 20:13:01 2016 -0700

    Merge pull request #4013 from thinkyhead/rc_toolchange_no_move
    
    Use "Tn S1" to change tools without moving

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 343a6a7..7ae1a68 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -6613,6 +6613,7 @@ inline void gcode_M999() {
  * T0-T3: Switch tool, usually switching extruders
  *
  *   F[mm/min] Set the movement feedrate
+ *   S1        Don't move the tool in XY after change
  */
 inline void gcode_T(uint8_t tmp_extruder) {
   if (tmp_extruder >= EXTRUDERS) {
@@ -6639,8 +6640,9 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
   #if HOTENDS > 1
     if (tmp_extruder != active_extruder) {
+      bool no_move = code_seen('S') && code_value_bool();
       // Save current position to return to after applying extruder offset
-      set_destination_to_current();
+      if (!no_move) set_destination_to_current();
       #if ENABLED(DUAL_X_CARRIAGE)
         if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&
             (delayed_move_time || current_position[X_AXIS] != x_home_pos(active_extruder))) {
@@ -6744,7 +6746,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
       #endif
 
       // Move to the "old position" (move the extruder into place)
-      if (IsRunning()) prepare_move_to_destination();
+      if (!no_move && IsRunning()) prepare_move_to_destination();
 
     } // (tmp_extruder != active_extruder)
 

commit 52ac2a62eecaaa4e174451c4126ddb83357fae16 (from 7fb69e24fbb41b71403c9169ab22b511c1e10797)
Merge: d2a00b7 7fb69e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 14 20:13:01 2016 -0700

    Merge pull request #4013 from thinkyhead/rc_toolchange_no_move
    
    Use "Tn S1" to change tools without moving

diff --git a/.travis.yml b/.travis.yml
index ed31e34..496b616 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -76,10 +76,12 @@ script:
   - build_marlin
   #
   # Test 3 extruders on RUMBA (can use any board with >=3 extruders defined)
+  # Include a test for LIN_ADVANCE here also
   #
   - opt_set MOTHERBOARD BOARD_RUMBA
   - opt_set EXTRUDERS 3
   - opt_set TEMP_SENSOR_2 1
+  - opt_enable_adv LIN_ADVANCE
   - build_marlin
   #
   # Test PIDTEMPBED
@@ -134,7 +136,8 @@ script:
   # Enable FILAMENTCHANGEENABLE
   #
   - restore_configs
-  - opt_enable FILAMENTCHANGEENABLE ULTIMAKERCONTROLLER
+  - opt_enable ULTIMAKERCONTROLLER
+  - opt_enable_adv FILAMENTCHANGEENABLE
   - build_marlin
   #
   # Enable filament sensor
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 952da0f..43b5111 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index a9af2c4..7ae1a68 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -333,7 +333,7 @@ const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 
 static int serial_count = 0;
 
-// GCode parameter pointer used by code_seen(), code_value(), etc.
+// GCode parameter pointer used by code_seen(), code_value_float(), etc.
 static char* seen_pointer;
 
 // Next Immediate GCode Command pointer. NULL if none.
@@ -487,6 +487,11 @@ static bool send_ok[BUFSIZE];
 
 #if HAS_SERVOS
   Servo servo[NUM_SERVOS];
+  #define MOVE_SERVO(I, P) servo[I].move(P)
+  #define SERVO_ENDSTOP_EXISTS(I) (servo_endstop_id[I] >= 0)
+  #define MOVE_SERVO_ENDSTOP(I, J) MOVE_SERVO(servo_endstop_id[I], servo_endstop_angle[I][J])
+  #define DEPLOY_SERVO_ENDSTOP(I) MOVE_SERVO_ENDSTOP(I, 0)
+  #define STOW_SERVO_ENDSTOP(I) MOVE_SERVO_ENDSTOP(I, 1)
 #endif
 
 #ifdef CHDK
@@ -760,8 +765,8 @@ void servo_init() {
      *
      */
     for (int i = 0; i < 3; i++)
-      if (servo_endstop_id[i] >= 0)
-        servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);
+      if (SERVO_ENDSTOP_EXISTS(i))
+        STOW_SERVO_ENDSTOP(i);
 
   #endif // HAS_SERVO_ENDSTOPS
 
@@ -852,8 +857,6 @@ void setup() {
   // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
   Config_RetrieveSettings();
 
-  lcd_init();
-
   thermalManager.init();    // Initialize temperature loop
 
   #if ENABLED(DELTA) || ENABLED(SCARA)
@@ -901,6 +904,18 @@ void setup() {
     pinMode(STAT_LED_BLUE, OUTPUT);
     digitalWrite(STAT_LED_BLUE, LOW); // turn it off
   #endif
+
+  lcd_init();
+  #if ENABLED(SHOW_BOOTSCREEN)
+    #if ENABLED(DOGLCD)
+      delay(1000);
+    #elif ENABLED(ULTRA_LCD)
+      bootscreen();
+      lcd_init();
+    #endif
+  #endif
+
+
 }
 
 /**
@@ -1825,7 +1840,8 @@ static void setup_for_endstop_move() {
     #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Engage Z Servo endstop if enabled
-      if (servo_endstop_id[Z_AXIS] >= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);
+      if (SERVO_ENDSTOP_EXISTS(Z_AXIS)
+        DEPLOY_SERVO_ENDSTOP(Z_AXIS);
 
     #elif ENABLED(Z_PROBE_ALLEN_KEY)
       feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;
@@ -1921,7 +1937,7 @@ static void setup_for_endstop_move() {
     #if ENABLED(HAS_SERVO_ENDSTOPS)
 
       // Retract Z Servo endstop if enabled
-      if (servo_endstop_id[Z_AXIS] >= 0) {
+      if (SERVO_ENDSTOP_EXISTS(Z_AXIS)) {
 
         #if Z_RAISE_AFTER_PROBING > 0
           if (doRaise) {
@@ -1931,7 +1947,7 @@ static void setup_for_endstop_move() {
         #endif
 
         // Change the Z servo angle
-        servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);
+        STOW_SERVO_ENDSTOP(Z_AXIS);
       }
 
     #elif ENABLED(Z_PROBE_ALLEN_KEY)
@@ -2288,8 +2304,8 @@ static void homeaxis(AxisEnum axis) {
 
     #if ENABLED(HAS_SERVO_ENDSTOPS)
       // Engage an X, Y (or Z) Servo endstop if enabled
-      if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
-        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);
+      if (_Z_SERVO_TEST && SERVO_ENDSTOP_EXISTS(axis)) {
+        DEPLOY_SERVO_ENDSTOP(axis);
         if (_Z_SERVO_SUBTEST) endstops.z_probe_enabled = true;
       }
     #endif
@@ -2419,7 +2435,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Retract X, Y (or Z) Servo endstop if enabled
     #if ENABLED(HAS_SERVO_ENDSTOPS)
-      if (_Z_SERVO_TEST && servo_endstop_id[axis] >= 0) {
+      if (_Z_SERVO_TEST && SERVO_ENDSTOP_EXISTS(axis)) {
         // Raise the servo probe before stow outside ABL context.
         // This is a workaround to allow use of a Servo Probe without
         // ABL until more global probe handling is implemented.
@@ -2438,7 +2454,7 @@ static void homeaxis(AxisEnum axis) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
         #endif
-        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);
+        STOW_SERVO_ENDSTOP(axis);
         if (_Z_SERVO_SUBTEST) endstops.enable_z_probe(false);
       }
 
@@ -5673,7 +5689,7 @@ inline void gcode_M226() {
     if (code_seen('S')) {
       servo_position = code_value_int();
       if (servo_index >= 0 && servo_index < NUM_SERVOS)
-        servo[servo_index].move(servo_position);
+        MOVE_SERVO(servo_index, servo_position);
       else {
         SERIAL_ERROR_START;
         SERIAL_ERROR("Servo ");
@@ -6469,6 +6485,16 @@ inline void gcode_M503() {
 
 #endif // DUAL_X_CARRIAGE
 
+#if ENABLED(LIN_ADVANCE)
+  /**
+   * M905: Set advance factor
+   */
+  inline void gcode_M905() {
+    stepper.synchronize();
+    stepper.advance_M905(code_seen('K') ? code_value_float() : -1.0);
+  }
+#endif
+
 /**
  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  */
@@ -6601,7 +6627,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
   float stored_feedrate = feedrate;
 
   if (code_seen('F')) {
-    float next_feedrate = code_value_axis_units(E_AXIS);
+    float next_feedrate = code_value_axis_units(X_AXIS);
     if (next_feedrate > 0.0) stored_feedrate = feedrate = next_feedrate;
   }
   else {
@@ -6682,6 +6708,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
 
           offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
 
+          // Adjust the current position
           current_position[X_AXIS] += offset_vec.x;
           current_position[Y_AXIS] += offset_vec.y;
           current_position[Z_AXIS] += offset_vec.z;
@@ -7342,6 +7369,12 @@ void process_next_command() {
           gcode_M605();
           break;
       #endif // DUAL_X_CARRIAGE
+      
+      #if ENABLED(LIN_ADVANCE)
+        case 905: // M905 Set advance factor.
+          gcode_M905();
+          break;
+      #endif
 
       case 907: // M907 Set digital trimpot motor current using axis codes.
         gcode_M907();
@@ -8278,6 +8311,7 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
 void kill(const char* lcd_msg) {
   #if ENABLED(ULTRA_LCD)
+    lcd_init();
     lcd_setalertstatuspgm(lcd_msg);
   #else
     UNUSED(lcd_msg);
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index a913cb1..4110d67 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -352,13 +352,19 @@
 #endif // AUTO_BED_LEVELING_FEATURE
 
 /**
+ * Advance Extrusion
+ */
+#if ENABLED(ADVANCE) && ENABLED(LIN_ADVANCE)
+  #error You can enable ADVANCE or LIN_ADVANCE, but not both.
+#endif
+
+/**
  * Filament Width Sensor
  */
 #if ENABLED(FILAMENT_WIDTH_SENSOR) && !HAS_FILAMENT_WIDTH_SENSOR
   #error "FILAMENT_WIDTH_SENSOR requires a FILWIDTH_PIN to be defined."
 #endif
 
-
 /**
  * ULTIPANEL encoder
  */
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index 2e43625..c87fe84 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -24,8 +24,8 @@
 #define __BUZZER_H__
 
 #include "fastio.h"
-#include "watchdog.h"
 #include "circularqueue.h"
+#include "temperature.h"
 
 #define TONE_QUEUE_LENGTH 4
 
@@ -106,9 +106,7 @@ class Buzzer {
       while (buffer.isFull()) {
         delay(5);
         this->tick();
-        #if ENABLED(USE_WATCHDOG)
-          watchdog_reset();
-        #endif
+        thermalManager.manage_heater();
       }
       this->buffer.enqueue((tone_t) { duration, frequency });
     }
diff --git a/Marlin/dogm_custom_bitmaps.h b/Marlin/dogm_custom_bitmaps.h
new file mode 100644
index 0000000..4f30305
--- /dev/null
+++ b/Marlin/dogm_custom_bitmaps.h
@@ -0,0 +1,77 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * BitMap for custom splashscreen
+ * Generated with: http://www.digole.com/tools/PicturetoC_Hex_converter.php
+ */
+
+//#define CUSTOM_START_BMP
+
+#if ENABLED(CUSTOM_START_BMP)
+  
+  #define CUSTOM_START_BMP_DELAY     2000
+  #define CUSTOM_START_BMPWIDTH      112
+  #define CUSTOM_START_BMPHEIGHT      38
+  #define CUSTOM_START_BMPBYTEWIDTH   14
+  #define CUSTOM_START_BMPBYTES      532 // CUSTOM_START_BMPWIDTH * CUSTOM_START_BMPHEIGHT / 8
+
+  const unsigned char custom_start_bmp[CUSTOM_START_BMPBYTES] PROGMEM = {
+    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
+    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF,
+    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
+    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x3F, 0xFF,
+    0xC0, 0x0F, 0xC0, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x1F, 0xFF,
+    0xC0, 0x3F, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x0F, 0xFF,
+    0xC0, 0x7F, 0xF3, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x07, 0xFF,
+    0xC0, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x03, 0xFF,
+    0xC1, 0xF8, 0x7F, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x01, 0xFF,
+    0xC1, 0xF0, 0x3F, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFF,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x1F, 0x00, 0x03, 0xE0, 0x78, 0x3C, 0x03, 0xF0, 0x7F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0xC0, 0x0F, 0xF8, 0x78, 0x3C, 0x07, 0xFC, 0x3F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0xE0, 0x1F, 0xFC, 0x78, 0x3C, 0x0F, 0xFE, 0x1F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0xF0, 0x3F, 0xFE, 0x78, 0x3C, 0x1F, 0xFE, 0x0F,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xF3, 0xF8, 0x3F, 0x3E, 0x78, 0x3C, 0x3F, 0x3F, 0x07,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xE0, 0xFC, 0x7C, 0x1F, 0x78, 0x3C, 0x3E, 0x1F, 0x07,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x7C, 0x7C, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x7C, 0x78, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xE0, 0x3C, 0x78, 0x00, 0x7C, 0x3C, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0x3F, 0xF8, 0x00, 0x7F, 0xBC, 0x3C, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0x3F, 0xF8, 0x00, 0x3F, 0xBF, 0xFC, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0xFF, 0x3F, 0xF8, 0x00, 0x1F, 0xBF, 0xFC, 0x0F, 0x03,
+    0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0x3F, 0xF8, 0x00, 0x0F, 0xBF, 0xFC, 0x0F, 0x03,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
+    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
+    0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
+    0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
+    0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
+    0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
+    0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80 };
+#endif
diff --git a/Marlin/dogm_lcd_implementation.h b/Marlin/dogm_lcd_implementation.h
index 51ee6e4..08518b6 100644
--- a/Marlin/dogm_lcd_implementation.h
+++ b/Marlin/dogm_lcd_implementation.h
@@ -53,6 +53,8 @@
 
 #include <U8glib.h>
 #include "dogm_bitmaps.h"
+#include "dogm_custom_bitmaps.h"
+
 
 #include "ultralcd.h"
 #include "ultralcd_st7920_u8glib_rrd.h"
@@ -247,6 +249,15 @@ static void lcd_implementation_init() {
   #endif
 
   #if ENABLED(SHOW_BOOTSCREEN)
+    #if ENABLED(CUSTOM_START_BMP)
+      if (show_bootscreen) {
+        u8g.firstPage();
+        do {
+            u8g.drawBitmapP((128-(CUSTOM_START_BMPWIDTH))/2, (64 - (CUSTOM_START_BMPHEIGHT))/2, CUSTOM_START_BMPBYTEWIDTH, CUSTOM_START_BMPHEIGHT, custom_start_bmp);
+        } while (u8g.nextPage());
+        delay(CUSTOM_START_BMP_DELAY);
+      }
+    #endif
     int offx = (u8g.getWidth() - (START_BMPWIDTH)) / 2;
     #if ENABLED(START_BMPHIGH)
       int offy = 0;
@@ -271,10 +282,8 @@ static void lcd_implementation_init() {
       }
     } while (u8g.nextPage());
 
-    if (show_bootscreen) {
-      delay(1000);
-      show_bootscreen = false;
-    }
+    show_bootscreen = false;
+
   #endif
 }
 
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index b22bf95..5925466 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 9a89097..bf7e007 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
index bebd94b..37d00e4 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index c5e9249..17a88f0 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -451,6 +451,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/RigidBot/Configuration_adv.h b/Marlin/example_configurations/RigidBot/Configuration_adv.h
index 50d8cb5..1ab7d61 100644
--- a/Marlin/example_configurations/RigidBot/Configuration_adv.h
+++ b/Marlin/example_configurations/RigidBot/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index f3ba728..18afdbe 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/TAZ4/Configuration_adv.h b/Marlin/example_configurations/TAZ4/Configuration_adv.h
index 5aa9487..58b64c6 100644
--- a/Marlin/example_configurations/TAZ4/Configuration_adv.h
+++ b/Marlin/example_configurations/TAZ4/Configuration_adv.h
@@ -453,6 +453,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 9a89097..bf7e007 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 1.75
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
index 627188d..2d0ec24 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index d64dfd5..b965251 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index f99318e..73d4229 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -446,6 +446,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index 3250e88..c917954 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -451,6 +451,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index f0ccba6..0fd30c1 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -447,6 +447,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index d8ef5d3..2cca1a4 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index af2d22f..589fc19 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -445,6 +445,15 @@
   #define D_FILAMENT 2.85
 #endif
 
+// Implementation of a linear pressure control
+// Assumption: advance = k * (delta velocity)
+// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+//#define LIN_ADVANCE
+
+#if ENABLED(LIN_ADVANCE)
+  #define LIN_ADVANCE_K 75
+#endif
+
 // @section leveling
 
 // Default mesh area is an area with an inset margin on the print area.
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index 7fb0bdc..a0f78ad 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -38,12 +38,17 @@
 #define WELCOME_MSG                         MACHINE_NAME " pronto."
 #define MSG_SD_INSERTED                     "SD Card inserita"
 #define MSG_SD_REMOVED                      "SD Card rimossa"
+#define MSG_LCD_ENDSTOPS                    "Endstop"
 #define MSG_MAIN                            "Menu principale"
 #define MSG_AUTOSTART                       "Autostart"
 #define MSG_DISABLE_STEPPERS                "Disabilita Motori"
 #define MSG_AUTO_HOME                       "Auto Home"
+#define MSG_AUTO_HOME_X                     "Home asse X"
+#define MSG_AUTO_HOME_Y                     "Home asse Y"
+#define MSG_AUTO_HOME_Z                     "Home asse Z"
 #define MSG_LEVEL_BED_HOMING                "Home assi XYZ"
 #define MSG_LEVEL_BED_WAITING               "Premi per Iniziare"
+#define MSG_LEVEL_BED_NEXT_POINT            "Punto successivo"
 #define MSG_LEVEL_BED_DONE                  "Livel. terminato!"
 #define MSG_LEVEL_BED_CANCEL                "Annulla"
 #define MSG_SET_HOME_OFFSETS                "Imp. offset home"
@@ -146,6 +151,7 @@
 #define MSG_CNG_SDCARD                      "Cambia SD-Card"
 #define MSG_ZPROBE_OUT                      "Z probe out. bed"
 #define MSG_YX_UNHOMED                      "Home X/Y prima di Z"
+#define MSG_XYZ_UNHOMED                     "Home XYZ prima"
 #define MSG_ZPROBE_ZOFFSET                  "Z Offset"
 #define MSG_BABYSTEP_X                      "Babystep X"
 #define MSG_BABYSTEP_Y                      "Babystep Y"
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index bd60d75..699987f 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -1050,7 +1050,23 @@ void Planner::check_axes_activity() {
   for (int i = 0; i < NUM_AXIS; i++) previous_speed[i] = current_speed[i];
   previous_nominal_speed = block->nominal_speed;
 
-  #if ENABLED(ADVANCE)
+  #if ENABLED(LIN_ADVANCE)
+
+    // bse == allsteps: A problem occurs when there's a very tiny move before a retract.
+    // In this case, the retract and the move will be executed together.
+    // This leads to an enormous number of advance steps due to a huge e_acceleration.
+    // The math is correct, but you don't want a retract move done with advance!
+    // So this situation is filtered out here.
+    if (!bse || (!bsx && !bsy && !bsz) || stepper.get_advance_k() == 0 || bse == allsteps) {
+      block->use_advance_lead = false;
+    }
+    else {
+      block->use_advance_lead = true;
+      block->e_speed_multiplier8 = (block->steps[E_AXIS] << 8) / block->step_event_count;
+    }
+
+  #elif ENABLED(ADVANCE)
+
     // Calculate advance rate
     if (!bse || (!bsx && !bsy && !bsz)) {
       block->advance_rate = 0;
@@ -1069,7 +1085,8 @@ void Planner::check_axes_activity() {
      SERIAL_ECHOPGM("advance rate :");
      SERIAL_ECHOLN(block->advance_rate/256.0);
      */
-  #endif // ADVANCE
+
+  #endif // ADVANCE or LIN_ADVANCE
 
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 07de371..5121974 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -64,7 +64,11 @@ typedef struct {
 
   unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
-  #if ENABLED(ADVANCE)
+  // Advance extrusion
+  #if ENABLED(LIN_ADVANCE)
+    bool use_advance_lead;
+    int e_speed_multiplier8; // Factorised by 2^8 to avoid float
+  #elif ENABLED(ADVANCE)
     long advance_rate;
     volatile long initial_advance;
     volatile long final_advance;
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index f8e8a85..8d1fe03 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -89,13 +89,24 @@ long  Stepper::counter_X = 0,
 
 volatile unsigned long Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
-#if ENABLED(ADVANCE)
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
   unsigned char Stepper::old_OCR0A;
-  long  Stepper::final_advance = 0,
-        Stepper::old_advance = 0,
-        Stepper::e_steps[EXTRUDERS],
-        Stepper::advance_rate,
-        Stepper::advance;
+  volatile unsigned char Stepper::eISR_Rate = 200; // Keep the ISR at a low rate until needed
+
+  #if ENABLED(LIN_ADVANCE)
+    volatile int Stepper::e_steps[EXTRUDERS];
+    int Stepper::extruder_advance_k = LIN_ADVANCE_K,
+        Stepper::final_estep_rate,
+        Stepper::current_estep_rate[EXTRUDERS],
+        Stepper::current_adv_steps[EXTRUDERS];
+  #else
+    long  Stepper::e_steps[EXTRUDERS],
+          Stepper::final_advance = 0,
+          Stepper::old_advance = 0,
+          Stepper::advance_rate,
+          Stepper::advance;
+  #endif
 #endif
 
 long Stepper::acceleration_time, Stepper::deceleration_time;
@@ -344,14 +355,32 @@ void Stepper::isr() {
         customizedSerial.checkRx(); // Check for serial chars.
       #endif
 
-      #if ENABLED(ADVANCE)
+      #if ENABLED(LIN_ADVANCE)
+
+        counter_E += current_block->steps[E_AXIS];
+        if (counter_E > 0) {
+          counter_E -= current_block->step_event_count;
+          count_position[E_AXIS] += count_direction[E_AXIS];
+          e_steps[current_block->active_extruder] += motor_direction(E_AXIS) ? -1 : 1;
+        }
+
+        if (current_block->use_advance_lead) {
+          int delta_adv_steps; //Maybe a char would be enough?
+          delta_adv_steps = (((long)extruder_advance_k * current_estep_rate[current_block->active_extruder]) >> 9) - current_adv_steps[current_block->active_extruder];
+          e_steps[current_block->active_extruder] += delta_adv_steps;
+          current_adv_steps[current_block->active_extruder] += delta_adv_steps;
+        }
+
+      #elif ENABLED(ADVANCE)
+
         counter_E += current_block->steps[E_AXIS];
         if (counter_E > 0) {
           counter_E -= current_block->step_event_count;
           e_steps[current_block->active_extruder] += motor_direction(E_AXIS) ? -1 : 1;
         }
-      #endif //ADVANCE
 
+      #endif // ADVANCE or LIN_ADVANCE
+      
       #define _COUNTER(AXIS) counter_## AXIS
       #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
       #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
@@ -363,7 +392,7 @@ void Stepper::isr() {
       STEP_ADD(X);
       STEP_ADD(Y);
       STEP_ADD(Z);
-      #if DISABLED(ADVANCE)
+      #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
         STEP_ADD(E);
       #endif
 
@@ -377,13 +406,19 @@ void Stepper::isr() {
       STEP_IF_COUNTER(X);
       STEP_IF_COUNTER(Y);
       STEP_IF_COUNTER(Z);
-      #if DISABLED(ADVANCE)
+      #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
         STEP_IF_COUNTER(E);
       #endif
 
       step_events_completed++;
       if (step_events_completed >= current_block->step_event_count) break;
     }
+
+    #if ENABLED(LIN_ADVANCE)
+      // If we have esteps to execute, fire the next ISR "now"
+      if (e_steps[current_block->active_extruder]) OCR0A = TCNT0 + 2;
+    #endif
+
     // Calculate new timer value
     unsigned short timer, step_rate;
     if (step_events_completed <= (unsigned long)current_block->accelerate_until) {
@@ -399,7 +434,12 @@ void Stepper::isr() {
       OCR1A = timer;
       acceleration_time += timer;
 
-      #if ENABLED(ADVANCE)
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
+
+      #elif ENABLED(ADVANCE)
 
         advance += advance_rate * step_loops;
         //NOLESS(advance, current_block->advance);
@@ -408,7 +448,11 @@ void Stepper::isr() {
         e_steps[current_block->active_extruder] += ((advance >> 8) - old_advance);
         old_advance = advance >> 8;
 
-      #endif //ADVANCE
+      #endif // ADVANCE or LIN_ADVANCE
+
+      #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+        eISR_Rate = (timer >> 2) / abs(e_steps[current_block->active_extruder]);
+      #endif
     }
     else if (step_events_completed > (unsigned long)current_block->decelerate_after) {
       MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
@@ -424,8 +468,14 @@ void Stepper::isr() {
       timer = calc_timer(step_rate);
       OCR1A = timer;
       deceleration_time += timer;
+      
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)step_rate * current_block->e_speed_multiplier8) >> 8;
+
+      #elif ENABLED(ADVANCE)
 
-      #if ENABLED(ADVANCE)
         advance -= advance_rate * step_loops;
         NOLESS(advance, final_advance);
 
@@ -433,9 +483,24 @@ void Stepper::isr() {
         uint32_t advance_whole = advance >> 8;
         e_steps[current_block->active_extruder] += advance_whole - old_advance;
         old_advance = advance_whole;
-      #endif //ADVANCE
+
+      #endif // ADVANCE or LIN_ADVANCE
+
+      #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+        eISR_Rate = (timer >> 2) / abs(e_steps[current_block->active_extruder]);
+      #endif
     }
     else {
+
+      #if ENABLED(LIN_ADVANCE)
+
+        if (current_block->use_advance_lead)
+          current_estep_rate[current_block->active_extruder] = final_estep_rate;
+
+        eISR_Rate = (OCR1A_nominal >> 2) / abs(e_steps[current_block->active_extruder]);
+
+      #endif
+
       OCR1A = OCR1A_nominal;
       // ensure we're running at the correct step rate, even if we just came off an acceleration
       step_loops = step_loops_nominal;
@@ -451,13 +516,15 @@ void Stepper::isr() {
   }
 }
 
-#if ENABLED(ADVANCE)
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
   // Timer interrupt for E. e_steps is set in the main routine;
   // Timer 0 is shared with millies
   ISR(TIMER0_COMPA_vect) { Stepper::advance_isr(); }
 
   void Stepper::advance_isr() {
-    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
+
+    old_OCR0A += eISR_Rate;
     OCR0A = old_OCR0A;
 
     #define STEP_E_ONCE(INDEX) \
@@ -474,22 +541,21 @@ void Stepper::isr() {
         E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); \
       }
 
-    // Step all E steppers that have steps, up to 4 steps per interrupt
-    for (unsigned char i = 0; i < 4; i++) {
-      STEP_E_ONCE(0);
-      #if EXTRUDERS > 1
-        STEP_E_ONCE(1);
-        #if EXTRUDERS > 2
-          STEP_E_ONCE(2);
-          #if EXTRUDERS > 3
-            STEP_E_ONCE(3);
-          #endif
+    // Step all E steppers that have steps
+    STEP_E_ONCE(0);
+    #if EXTRUDERS > 1
+      STEP_E_ONCE(1);
+      #if EXTRUDERS > 2
+        STEP_E_ONCE(2);
+        #if EXTRUDERS > 3
+          STEP_E_ONCE(3);
         #endif
       #endif
-    }
+    #endif
+
   }
 
-#endif // ADVANCE
+#endif // ADVANCE or LIN_ADVANCE
 
 void Stepper::init() {
 
@@ -656,14 +722,28 @@ void Stepper::init() {
   TCNT1 = 0;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  #if ENABLED(ADVANCE)
+  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
+    #if ENABLED(LIN_ADVANCE)
+
+      for (int i = 0; i < EXTRUDERS; i++) {
+        e_steps[i] = 0;
+        current_adv_steps[i] = 0;
+      }
+
+    #elif ENABLED(ADVANCE)
+
+      for (uint8_t i = 0; i < EXTRUDERS; i++) e_steps[i] = 0;
+
+    #endif
+
     #if defined(TCCR0A) && defined(WGM01)
       CBI(TCCR0A, WGM01);
       CBI(TCCR0A, WGM00);
     #endif
-    for (uint8_t i = 0; i < EXTRUDERS; i++) e_steps[i] = 0;
     SBI(TIMSK0, OCIE0A);
-  #endif //ADVANCE
+
+  #endif // ADVANCE or LIN_ADVANCE
 
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
@@ -1040,3 +1120,14 @@ void Stepper::microstep_readings() {
     SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));
   #endif
 }
+
+#if ENABLED(LIN_ADVANCE)
+
+  void Stepper::advance_M905(const float &k) {
+    if (k >= 0) extruder_advance_k = k;
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("Advance factor: ", extruder_advance_k);
+    SERIAL_EOL;
+  }
+
+#endif // LIN_ADVANCE
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 1aebe36..7612e60 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -22,7 +22,7 @@
 
 /**
  * stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
- * Part of Grbl
+ * Derived from Grbl
  *
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  *
@@ -90,10 +90,6 @@ class Stepper {
       static bool performing_homing;
     #endif
 
-    #if ENABLED(ADVANCE)
-      static long e_steps[EXTRUDERS];
-    #endif
-
   private:
 
     static unsigned char last_direction_bits;        // The next stepping-bits to be output
@@ -107,10 +103,23 @@ class Stepper {
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile unsigned long step_events_completed; // The number of step events executed in the current block
 
-    #if ENABLED(ADVANCE)
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
       static unsigned char old_OCR0A;
-      static long advance_rate, advance, old_advance, final_advance;
-    #endif
+      static volatile unsigned char eISR_Rate;
+      #if ENABLED(LIN_ADVANCE)
+        static volatile int e_steps[EXTRUDERS];
+        static int extruder_advance_k;
+        static int final_estep_rate;
+        static int current_estep_rate[EXTRUDERS]; // Actual extruder speed [steps/s]
+        static int current_adv_steps[EXTRUDERS];  // The amount of current added esteps due to advance.
+                                                  // i.e., the current amount of pressure applied
+                                                  // to the spring (=filament).
+      #else
+        static long e_steps[EXTRUDERS];
+        static long advance_rate, advance, final_advance;
+        static long old_advance;
+      #endif
+    #endif // ADVANCE or LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
@@ -156,7 +165,7 @@ class Stepper {
 
     static void isr();
 
-    #if ENABLED(ADVANCE)
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
       static void advance_isr();
     #endif
 
@@ -246,6 +255,11 @@ class Stepper {
       return endstops_trigsteps[axis] / planner.axis_steps_per_mm[axis];
     }
 
+    #if ENABLED(LIN_ADVANCE)
+      void advance_M905(const float &k);
+      FORCE_INLINE int get_advance_k() { return extruder_advance_k; }
+    #endif
+
   private:
 
     static FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
@@ -315,6 +329,13 @@ class Stepper {
       acc_step_rate = current_block->initial_rate;
       acceleration_time = calc_timer(acc_step_rate);
       OCR1A = acceleration_time;
+      
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->use_advance_lead) {
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
+          final_estep_rate = (current_block->nominal_rate * current_block->e_speed_multiplier8) >> 8;
+        }
+      #endif
 
       // SERIAL_ECHO_START;
       // SERIAL_ECHOPGM("advance :");
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 1d6db5c..b80950f 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -1228,7 +1228,7 @@ void Temperature::disable_all_heaters() {
   print_job_timer.stop();
 
   #define DISABLE_HEATER(NR) { \
-    setTargetHotend(NR, 0); \
+    setTargetHotend(0, NR); \
     soft_pwm[NR] = 0; \
     WRITE_HEATER_ ## NR (LOW); \
   }
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 1f58183..0c8ccc0 100644
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -91,8 +91,13 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
 
   int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update
 
-  int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
+  int8_t manual_move_axis = (int8_t)NO_AXIS;
+  #if EXTRUDERS > 1
+    int8_t manual_move_e_index = 0;
+  #else
+    #define manual_move_e_index 0
+  #endif
 
   bool encoderRateMultiplierEnabled;
   int32_t lastEncoderMovementMillis;
@@ -1208,9 +1213,9 @@ static void lcd_status_screen() {
     if (manual_move_axis != (int8_t)NO_AXIS && millis() >= manual_move_start_time && !planner.is_full()) {
       #if ENABLED(DELTA)
         calculate_delta(current_position);
-        planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, active_extruder);
+        planner.buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, manual_move_e_index);
       #else
-        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, active_extruder);
+        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[manual_move_axis]/60, manual_move_e_index);
       #endif
       manual_move_axis = (int8_t)NO_AXIS;
     }
@@ -1220,7 +1225,14 @@ static void lcd_status_screen() {
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */
-  inline void manual_move_to_current(AxisEnum axis) {
+  inline void manual_move_to_current(AxisEnum axis
+    #if EXTRUDERS > 1
+      , int8_t eindex=-1
+    #endif
+  ) {
+    #if EXTRUDERS > 1
+      if (axis == E_AXIS) manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
+    #endif
     manual_move_start_time = millis() + 500UL; // 1/2 second delay
     manual_move_axis = (int8_t)axis;
   }
@@ -1233,7 +1245,7 @@ static void lcd_status_screen() {
 
   float move_menu_scale;
 
-  static void _lcd_move(const char* name, AxisEnum axis, float min, float max) {
+  static void _lcd_move_xyz(const char* name, AxisEnum axis, float min, float max) {
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       refresh_cmd_timeout();
@@ -1250,27 +1262,27 @@ static void lcd_status_screen() {
   #if ENABLED(DELTA)
     static float delta_clip_radius_2 =  (DELTA_PRINTABLE_RADIUS) * (DELTA_PRINTABLE_RADIUS);
     static int delta_clip( float a ) { return sqrt(delta_clip_radius_2 - a*a); }
-    static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, max(sw_endstop_min[X_AXIS], -clip), min(sw_endstop_max[X_AXIS], clip)); }
-    static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, max(sw_endstop_min[Y_AXIS], -clip), min(sw_endstop_max[Y_AXIS], clip)); }
+    static void lcd_move_x() { int clip = delta_clip(current_position[Y_AXIS]); _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS, max(sw_endstop_min[X_AXIS], -clip), min(sw_endstop_max[X_AXIS], clip)); }
+    static void lcd_move_y() { int clip = delta_clip(current_position[X_AXIS]); _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS, max(sw_endstop_min[Y_AXIS], -clip), min(sw_endstop_max[Y_AXIS], clip)); }
   #else
-    static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, sw_endstop_min[X_AXIS], sw_endstop_max[X_AXIS]); }
-    static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, sw_endstop_min[Y_AXIS], sw_endstop_max[Y_AXIS]); }
+    static void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS, sw_endstop_min[X_AXIS], sw_endstop_max[X_AXIS]); }
+    static void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS, sw_endstop_min[Y_AXIS], sw_endstop_max[Y_AXIS]); }
   #endif
-  static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); }
+  static void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); }
   static void lcd_move_e(
     #if EXTRUDERS > 1
-      uint8_t e
+      int8_t eindex = -1
     #endif
   ) {
     ENCODER_DIRECTION_NORMAL();
-    #if EXTRUDERS > 1
-      unsigned short original_active_extruder = active_extruder;
-      active_extruder = e;
-    #endif
     if (encoderPosition) {
       current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
       encoderPosition = 0;
-      manual_move_to_current(E_AXIS);
+      manual_move_to_current(E_AXIS
+        #if EXTRUDERS > 1
+          , eindex
+        #endif
+      );
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     if (lcdDrawUpdate) {
@@ -1292,9 +1304,6 @@ static void lcd_status_screen() {
       lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
     }
     if (LCD_CLICKED) lcd_goto_previous_menu(true);
-    #if EXTRUDERS > 1
-      active_extruder = original_active_extruder;
-    #endif
   }
 
   #if EXTRUDERS > 1
@@ -2311,18 +2320,12 @@ void lcd_update() {
           u8g.setColorIndex(dot_color); // Set color for the alive dot
           u8g.drawPixel(127, 63); // draw alive dot
           u8g.setColorIndex(1); // black on white
-          #if ENABLED(ULTIPANEL)
-            (*currentScreen)();
-          #else
-            lcd_status_screen();
-          #endif
+          (*currentScreen)();
         } while (u8g.nextPage());
+      #elif ENABLED(ULTIPANEL)
+        (*currentScreen)();
       #else
-        #if ENABLED(ULTIPANEL)
-          (*currentScreen)();
-        #else
-          lcd_status_screen();
-        #endif
+        lcd_status_screen();
       #endif
     }
 
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 707ba8f..8e7e2ee 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -52,8 +52,11 @@
   #if ENABLED(DOGLCD)
     extern int lcd_contrast;
     void set_lcd_contrast(int value);
+  #elif ENABLED(SHOW_BOOTSCREEN)
+    void bootscreen();
   #endif
 
+
   #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))
   #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))
 
diff --git a/Marlin/ultralcd_implementation_hitachi_HD44780.h b/Marlin/ultralcd_implementation_hitachi_HD44780.h
index d682bfa..9ca7573 100644
--- a/Marlin/ultralcd_implementation_hitachi_HD44780.h
+++ b/Marlin/ultralcd_implementation_hitachi_HD44780.h
@@ -201,11 +201,6 @@ extern volatile uint8_t buttons;  //an extended version of the last checked butt
 
 #include "utf_mapper.h"
 
-#if ENABLED(SHOW_BOOTSCREEN)
-  static void bootscreen();
-  static bool show_bootscreen = true;
-#endif
-
 #if ENABLED(LCD_PROGRESS_BAR)
   static millis_t progress_bar_ms = 0;
   #if PROGRESS_MSG_EXPIRE > 0
@@ -394,10 +389,6 @@ static void lcd_implementation_init(
     lcd.begin(LCD_WIDTH, LCD_HEIGHT);
   #endif
 
-  #if ENABLED(SHOW_BOOTSCREEN)
-    if (show_bootscreen) bootscreen();
-  #endif
-
   lcd_set_custom_characters(
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_set
@@ -452,8 +443,7 @@ unsigned lcd_print(char c) { return charset_mapper(c); }
     lcd.setCursor(indent, 2); lcd.print('\x02'); lcd_printPGM(PSTR( "------" ));  lcd.print('\x03');
   }
 
-  static void bootscreen() {
-    show_bootscreen = false;
+  void bootscreen() {
     byte top_left[8] = {
       B00000,
       B00000,

