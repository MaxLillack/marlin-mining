commit 8b44413498ed3a5ad9163aa6b8bf1ecd981c636c (from f418e82b15e659d212c489d4dba09e5cf3e2b8bc)
Merge: f418e82 f9bea79
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 1 05:13:17 2016 -0500

    Merge pull request #5124 from Sebastianv650/RCBugFix_LIN_ADV-Patch
    
    BugFix for incorrect E-speed calculation

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index 918bae1..bb89395 100755
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -6988,7 +6988,7 @@ inline void gcode_M503() {
    */
   inline void gcode_M905() {
     stepper.synchronize();
-    stepper.advance_M905(code_seen('K') ? code_value_float() : -1.0);
+    planner.advance_M905(code_seen('K') ? code_value_float() : -1.0);
   }
 #endif
 
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 073179c..5c64c60 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -131,6 +131,11 @@ float Planner::previous_speed[NUM_AXIS],
   long Planner::axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
 #endif
 
+#if ENABLED(LIN_ADVANCE)
+  float Planner::extruder_advance_k = LIN_ADVANCE_K;
+  float Planner::position_float[NUM_AXIS] = { 0 };
+#endif
+
 /**
  * Class and Instance Methods
  */
@@ -140,6 +145,9 @@ Planner::Planner() { init(); }
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   ZERO(position);
+  #if ENABLED(LIN_ADVANCE)
+    ZERO(position_float);
+  #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
@@ -604,6 +612,14 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     lround(c * axis_steps_per_mm[Z_AXIS]),
     lround(e * axis_steps_per_mm[E_AXIS])
   };
+  
+  #if ENABLED(LIN_ADVANCE)
+    float target_float[XYZE] = {a, b, c, e};
+    float de_float = target_float[E_AXIS] - position_float[E_AXIS];
+    float mm_D_float = sqrt(sq(target_float[X_AXIS] - position_float[X_AXIS]) + sq(target_float[Y_AXIS] - position_float[Y_AXIS]));
+    
+    memcpy(position_float, target_float, sizeof(position_float));
+  #endif
 
   long da = target[X_AXIS] - position[X_AXIS],
        db = target[Y_AXIS] - position[Y_AXIS],
@@ -1232,12 +1248,12 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     // This leads to an enormous number of advance steps due to a huge e_acceleration.
     // The math is correct, but you don't want a retract move done with advance!
     // So this situation is filtered out here.
-    if (!esteps || (!block->steps[X_AXIS] && !block->steps[Y_AXIS]) || stepper.get_advance_k() == 0 || (uint32_t)esteps == block->step_event_count) {
+    if (!esteps || (!block->steps[X_AXIS] && !block->steps[Y_AXIS]) || extruder_advance_k == 0.0 || (uint32_t)esteps == block->step_event_count) {
       block->use_advance_lead = false;
     }
     else {
       block->use_advance_lead = true;
-      block->e_speed_multiplier8 = (esteps << 8) / block->step_event_count;
+      block->abs_adv_steps_multiplier8 = lround(extruder_advance_k * (de_float / mm_D_float) * block->nominal_speed / (float)block->nominal_rate * axis_steps_per_mm[Z_AXIS] * 256.0);
     }
 
   #elif ENABLED(ADVANCE)
@@ -1354,3 +1370,14 @@ void Planner::refresh_positioning() {
   }
 
 #endif
+
+#if ENABLED(LIN_ADVANCE)
+
+  void Planner::advance_M905(const float &k) {
+    if (k >= 0.0) extruder_advance_k = k;
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("Advance factor: ", extruder_advance_k);
+    SERIAL_EOL;
+  }
+
+#endif
\ No newline at end of file
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 0d97107..ab691a6 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -95,7 +95,7 @@ typedef struct {
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
-    int16_t e_speed_multiplier8; // Factorised by 2^8 to avoid float
+    uint32_t abs_adv_steps_multiplier8; // Factorised by 2^8 to avoid float
   #elif ENABLED(ADVANCE)
     int32_t advance_rate;
     volatile int32_t initial_advance;
@@ -196,6 +196,11 @@ class Planner {
       // Segment times (in Âµs). Used for speed calculations
       static long axis_segment_time[2][3];
     #endif
+    
+    #if ENABLED(LIN_ADVANCE)
+      static float position_float[NUM_AXIS];
+      static float extruder_advance_k;
+    #endif
 
   public:
 
@@ -245,6 +250,10 @@ class Planner {
       #define ARG_Z const float &lz
 
     #endif
+    
+    #if ENABLED(LIN_ADVANCE)
+      void advance_M905(const float &k);
+    #endif
 
     /**
      * Planner::_buffer_line
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 5b910a3..cb7eb3c 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -96,8 +96,7 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
   #if ENABLED(LIN_ADVANCE)
     volatile int Stepper::e_steps[E_STEPPERS];
-    int Stepper::extruder_advance_k = LIN_ADVANCE_K,
-        Stepper::final_estep_rate,
+    int Stepper::final_estep_rate,
         Stepper::current_estep_rate[E_STEPPERS],
         Stepper::current_adv_steps[E_STEPPERS];
   #else
@@ -534,7 +533,7 @@ void Stepper::isr() {
 
   #if ENABLED(LIN_ADVANCE)
     if (current_block->use_advance_lead) {
-      int delta_adv_steps = (((long)extruder_advance_k * current_estep_rate[TOOL_E_INDEX]) >> 9) - current_adv_steps[TOOL_E_INDEX];
+      int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
       current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
       #if ENABLED(MIXING_EXTRUDER)
         // Mixing extruders apply advance lead proportionally
@@ -572,9 +571,9 @@ void Stepper::isr() {
       if (current_block->use_advance_lead) {
         #if ENABLED(MIXING_EXTRUDER)
           MIXING_STEPPERS_LOOP(j)
-            current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->e_speed_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 8;
+            current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
         #else
-          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
+          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
 
@@ -624,9 +623,9 @@ void Stepper::isr() {
       if (current_block->use_advance_lead) {
         #if ENABLED(MIXING_EXTRUDER)
           MIXING_STEPPERS_LOOP(j)
-            current_estep_rate[j] = ((uint32_t)step_rate * current_block->e_speed_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 8;
+            current_estep_rate[j] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
         #else
-          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->e_speed_multiplier8) >> 8;
+          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
 
@@ -1350,14 +1349,3 @@ void Stepper::report_positions() {
   }
 
 #endif // HAS_MICROSTEPS
-
-#if ENABLED(LIN_ADVANCE)
-
-  void Stepper::advance_M905(const float &k) {
-    if (k >= 0) extruder_advance_k = k;
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("Advance factor: ", extruder_advance_k);
-    SERIAL_EOL;
-  }
-
-#endif // LIN_ADVANCE
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index a722a50..10c5c64 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -109,7 +109,6 @@ class Stepper {
       static volatile unsigned char eISR_Rate;
       #if ENABLED(LIN_ADVANCE)
         static volatile int e_steps[E_STEPPERS];
-        static int extruder_advance_k;
         static int final_estep_rate;
         static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
         static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
@@ -277,11 +276,6 @@ class Stepper {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
-    #if ENABLED(LIN_ADVANCE)
-      void advance_M905(const float &k);
-      FORCE_INLINE int get_advance_k() { return extruder_advance_k; }
-    #endif
-
   private:
 
     static FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {
@@ -367,8 +361,8 @@ class Stepper {
       
       #if ENABLED(LIN_ADVANCE)
         if (current_block->use_advance_lead) {
-          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
-          final_estep_rate = (current_block->nominal_rate * current_block->e_speed_multiplier8) >> 8;
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
+          final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         }
       #endif
 

commit 8b44413498ed3a5ad9163aa6b8bf1ecd981c636c (from f9bea7968f79c474434e6205e5f4a1bf7c6dee1d)
Merge: f418e82 f9bea79
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 1 05:13:17 2016 -0500

    Merge pull request #5124 from Sebastianv650/RCBugFix_LIN_ADV-Patch
    
    BugFix for incorrect E-speed calculation

diff --git a/Marlin/pinsDebug.h b/Marlin/pinsDebug.h
index f116312..d2a2e7e 100644
--- a/Marlin/pinsDebug.h
+++ b/Marlin/pinsDebug.h
@@ -34,8 +34,8 @@ bool endstop_monitor_flag = false;
 #define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && ((P) <= analogInputToDigitalPin(15) || (P) <= analogInputToDigitalPin(5)))
 
 int digitalRead_mod(int8_t pin) { // same as digitalRead except the PWM stop section has been removed
-	uint8_t port = digitalPinToPort(pin);
-	return (port != NOT_A_PIN) && (*portInputRegister(port) & digitalPinToBitMask(pin)) ? HIGH : LOW;
+  uint8_t port = digitalPinToPort(pin);
+  return (port != NOT_A_PIN) && (*portInputRegister(port) & digitalPinToBitMask(pin)) ? HIGH : LOW;
 }
 
 /**
@@ -60,7 +60,7 @@ static bool report_pin_name(int8_t pin, bool &pin_is_analog) {
     if (pin == 1) { sprintf(buffer, NAME_FORMAT, "TXD"); SERIAL_ECHO(buffer); return true; }
   #endif
 
-  // Pin list updated from 7 OCT RCBugfix branch
+  // Pin list updated from 7 OCT RCBugfix branch   - max length of pin name is 24
   #if defined(__FD) && __FD >= 0
     PIN_SAY(__FD)
   #endif
@@ -656,10 +656,10 @@ static bool report_pin_name(int8_t pin, bool &pin_is_analog) {
 } // report_pin_name
 
 #define PWM_PRINT(V) do{ sprintf(buffer, "PWM:  %4d", V); SERIAL_ECHO(buffer); }while(0)
-#define PWM_CASE(N) \
-  case TIMER##N: \
-    if (TCCR##N & (_BV(COM## N ##1) | _BV(COM## N ##0))) { \
-      PWM_PRINT(OCR##N); \
+#define PWM_CASE(N,Z) \
+  case TIMER##N##Z: \
+    if (TCCR##N##A & (_BV(COM##N##Z##1) | _BV(COM##N##Z##0))) { \
+      PWM_PRINT(OCR##N##Z); \
       return true; \
     } else return false
 
@@ -667,43 +667,43 @@ static bool report_pin_name(int8_t pin, bool &pin_is_analog) {
  * Print a pin's PWM status.
  * Return true if it's currently a PWM pin.
  */
-static bool PWM_status(uint8_t pin) {
+static bool pwm_status(uint8_t pin) {
   char buffer[20];   // for the sprintf statements
 
   switch(digitalPinToTimer(pin)) {
 
     #if defined(TCCR0A) && defined(COM0A1)
-      PWM_CASE(0A);
-      PWM_CASE(0B);
+      PWM_CASE(0,A);
+      PWM_CASE(0,B);
     #endif
 
     #if defined(TCCR1A) && defined(COM1A1)
-      PWM_CASE(1A);
-      PWM_CASE(1B);
-      PWM_CASE(1C);
+      PWM_CASE(1,A);
+      PWM_CASE(1,B);
+      PWM_CASE(1,C);
     #endif
 
     #if defined(TCCR2A) && defined(COM2A1)
-      PWM_CASE(2A);
-      PWM_CASE(2B);
+      PWM_CASE(2,A);
+      PWM_CASE(2,B);
     #endif
 
     #if defined(TCCR3A) && defined(COM3A1)
-      PWM_CASE(3A);
-      PWM_CASE(3B);
-      PWM_CASE(3C);
+      PWM_CASE(3,A);
+      PWM_CASE(3,B);
+      PWM_CASE(3,C);
     #endif
 
     #ifdef TCCR4A
-      PWM_CASE(4A);
-      PWM_CASE(4B);
-      PWM_CASE(4C);
+      PWM_CASE(4,A);
+      PWM_CASE(4,B);
+      PWM_CASE(4,C);
     #endif
 
     #if defined(TCCR5A) && defined(COM5A1)
-      PWM_CASE(5A);
-      PWM_CASE(5B);
-      PWM_CASE(5C);
+      PWM_CASE(5,A);
+      PWM_CASE(5,B);
+      PWM_CASE(5,C);
     #endif
 
     case NOT_ON_TIMER:
@@ -711,10 +711,10 @@ static bool PWM_status(uint8_t pin) {
       return false;
   }
   SERIAL_PROTOCOLPGM("  ");
-}  //PWM_status
+} // pwm_status
 
-#define WGM_MAKE3(N) ((TEST(TCCR##N##B, WGM##N##2) >> 1) | (TCCR##N##A & (_BV(WGM##N##0) | _BV(WGM##N##1))))
-#define WGM_MAKE4(N) (WGM_MAKE3(N) | (TEST(TCCR##N##B, WGM##N##3) >> 1))
+#define WGM_MAKE3(N) (((TCCR##N##B & _BV(WGM##N##2)) >> 1) | (TCCR##N##A & (_BV(WGM##N##0) | _BV(WGM##N##1))))
+#define WGM_MAKE4(N) (WGM_MAKE3(N) | (TCCR##N##B & _BV(WGM##N##3)) >> 1)
 #define TIMER_PREFIX(T,L,N) do{ \
     WGM = WGM_MAKE##N(T); \
     SERIAL_PROTOCOLPGM("    TIMER"); \
@@ -745,13 +745,13 @@ static void err_prob_interrupt() {
 }
 static void can_be_used() { SERIAL_PROTOCOLPGM("   can be used as PWM   "); }
 
-static void PWM_details(uint8_t pin) {
+static void pwm_details(uint8_t pin) {
 
   uint8_t WGM;
 
   switch(digitalPinToTimer(pin)) {
 
-  	#if defined(TCCR0A) && defined(COM0A1)
+    #if defined(TCCR0A) && defined(COM0A1)
       case TIMER0A:
         TIMER_PREFIX(0,A,3);
         if (WGM_TEST1) err_is_counter();
@@ -881,13 +881,11 @@ static void PWM_details(uint8_t pin) {
         break;
     #endif
 
-  	case NOT_ON_TIMER: break;
+    case NOT_ON_TIMER: break;
 
-	}
+  }
   SERIAL_PROTOCOLPGM("  ");
-}  // PWM_details
-
-
+} // pwm_details
 
 inline void report_pin_state(int8_t pin) {
   SERIAL_ECHO((int)pin);
@@ -938,7 +936,7 @@ inline void report_pin_state_extended(int8_t pin, bool ignore) {
         pinMode(pin, INPUT_PULLUP);  // make sure input isn't floating
         SERIAL_PROTOCOLPAIR("Input  = ", digitalRead_mod(pin));
       }
-      else if (PWM_status(pin)) {
+      else if (pwm_status(pin)) {
         // do nothing
       }
       else SERIAL_PROTOCOLPAIR("Output = ", digitalRead_mod(pin));
@@ -946,7 +944,7 @@ inline void report_pin_state_extended(int8_t pin, bool ignore) {
   }
 
   // report PWM capabilities
-  PWM_details(pin);
+  pwm_details(pin);
   SERIAL_EOL;
 }
 
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index a89f47c..9c35891 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -73,7 +73,6 @@
     // Encoder click is directly connected
     #if BUTTON_EXISTS(ENC)
       #define BLEN_C 2
-      #define EN_C (_BV(BLEN_C))
     #endif
     #define EN_A (_BV(BLEN_A))
     #define EN_B (_BV(BLEN_B))

