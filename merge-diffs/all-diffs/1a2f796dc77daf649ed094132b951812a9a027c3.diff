commit 1a2f796dc77daf649ed094132b951812a9a027c3 (from ccdb086fc892eb79ceec99aff9f621b47b3f5e42)
Merge: ccdb086 d4880a9
Author: galexander1 <gitgreg@galexander.org>
Date:   Thu Jan 15 18:52:44 2015 -0500

    Merge pull request #1368 from MarlinFirmware/revert-1357-SDlib
    
    Revert "Move Sd library out into library"

diff --git a/.travis.yml b/.travis.yml
index 1453298..8a378c7 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -26,9 +26,6 @@ before_script:
   - cd $TRAVIS_BUILD_DIR
   # ino needs files in src directory
   - ln -s Marlin src
-  - mkdir lib
-  - ln -s ../ArduinoAddons/Arduino_1.0.x/libraries/SdFat lib/SdFat
-  - ls -la lib/SdFat
   # remove Marlin.pde as it confuses ino after it finds Marlin.ino
   - rm Marlin/Marlin.pde
 script:
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.cpp b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.cpp
deleted file mode 100644
index 55bc587..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.cpp
+++ /dev/null
@@ -1,720 +0,0 @@
-/* Arduino Sd2Card Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino Sd2Card Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino Sd2Card Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#include "SdFat.h"
-
-#include "Sd2Card.h"
-//------------------------------------------------------------------------------
-#ifndef SOFTWARE_SPI
-// functions for hardware SPI
-//------------------------------------------------------------------------------
-// make sure SPCR rate is in expected bits
-#if (SPR0 != 0 || SPR1 != 1)
-#error unexpected SPCR bits
-#endif
-/**
- * Initialize hardware SPI
- * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]
- */
-static void spiInit(uint8_t spiRate) {
-  // See avr processor documentation
-  SPCR = (1 << SPE) | (1 << MSTR) | (spiRate >> 1);
-  SPSR = spiRate & 1 || spiRate == 6 ? 0 : 1 << SPI2X;
-}
-//------------------------------------------------------------------------------
-/** SPI receive a byte */
-static uint8_t spiRec() {
-  SPDR = 0XFF;
-  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-  return SPDR;
-}
-//------------------------------------------------------------------------------
-/** SPI read data - only one call so force inline */
-static inline __attribute__((always_inline))
-void spiRead(uint8_t* buf, uint16_t nbyte) {
-  if (nbyte-- == 0) return;
-  SPDR = 0XFF;
-  for (uint16_t i = 0; i < nbyte; i++) {
-    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-    buf[i] = SPDR;
-    SPDR = 0XFF;
-  }
-  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-  buf[nbyte] = SPDR;
-}
-//------------------------------------------------------------------------------
-/** SPI send a byte */
-static void spiSend(uint8_t b) {
-  SPDR = b;
-  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-}
-//------------------------------------------------------------------------------
-/** SPI send block - only one call so force inline */
-static inline __attribute__((always_inline))
-  void spiSendBlock(uint8_t token, const uint8_t* buf) {
-  SPDR = token;
-  for (uint16_t i = 0; i < 512; i += 2) {
-    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-    SPDR = buf[i];
-    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-    SPDR = buf[i + 1];
-  }
-  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
-}
-//------------------------------------------------------------------------------
-#else  // SOFTWARE_SPI
-//------------------------------------------------------------------------------
-/** nop to tune soft SPI timing */
-#define nop asm volatile ("nop\n\t")
-//------------------------------------------------------------------------------
-/** Soft SPI receive byte */
-static uint8_t spiRec() {
-  uint8_t data = 0;
-  // no interrupts during byte receive - about 8 us
-  cli();
-  // output pin high - like sending 0XFF
-  fastDigitalWrite(SPI_MOSI_PIN, HIGH);
-
-  for (uint8_t i = 0; i < 8; i++) {
-    fastDigitalWrite(SPI_SCK_PIN, HIGH);
-
-    // adjust so SCK is nice
-    nop;
-    nop;
-
-    data <<= 1;
-
-    if (fastDigitalRead(SPI_MISO_PIN)) data |= 1;
-
-    fastDigitalWrite(SPI_SCK_PIN, LOW);
-  }
-  // enable interrupts
-  sei();
-  return data;
-}
-//------------------------------------------------------------------------------
-/** Soft SPI read data */
-static void spiRead(uint8_t* buf, uint16_t nbyte) {
-  for (uint16_t i = 0; i < nbyte; i++) {
-    buf[i] = spiRec();
-  }
-}
-//------------------------------------------------------------------------------
-/** Soft SPI send byte */
-static void spiSend(uint8_t data) {
-  // no interrupts during byte send - about 8 us
-  cli();
-  for (uint8_t i = 0; i < 8; i++) {
-    fastDigitalWrite(SPI_SCK_PIN, LOW);
-
-    fastDigitalWrite(SPI_MOSI_PIN, data & 0X80);
-
-    data <<= 1;
-
-    fastDigitalWrite(SPI_SCK_PIN, HIGH);
-  }
-  // hold SCK high for a few ns
-  nop;
-  nop;
-  nop;
-  nop;
-
-  fastDigitalWrite(SPI_SCK_PIN, LOW);
-  // enable interrupts
-  sei();
-}
-//------------------------------------------------------------------------------
-/** Soft SPI send block */
-  void spiSendBlock(uint8_t token, const uint8_t* buf) {
-  spiSend(token);
-  for (uint16_t i = 0; i < 512; i++) {
-    spiSend(buf[i]);
-  }
-}
-#endif  // SOFTWARE_SPI
-//------------------------------------------------------------------------------
-// send command and return error code.  Return zero for OK
-uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
-  // select card
-  chipSelectLow();
-
-  // wait up to 300 ms if busy
-  waitNotBusy(300);
-
-  // send command
-  spiSend(cmd | 0x40);
-
-  // send argument
-  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
-
-  // send CRC
-  uint8_t crc = 0XFF;
-  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
-  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
-  spiSend(crc);
-
-  // skip stuff byte for stop read
-  if (cmd == CMD12) spiRec();
-
-  // wait for response
-  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
-  return status_;
-}
-//------------------------------------------------------------------------------
-/**
- * Determine the size of an SD flash memory card.
- *
- * \return The number of 512 byte data blocks in the card
- *         or zero if an error occurs.
- */
-uint32_t Sd2Card::cardSize() {
-  csd_t csd;
-  if (!readCSD(&csd)) return 0;
-  if (csd.v1.csd_ver == 0) {
-    uint8_t read_bl_len = csd.v1.read_bl_len;
-    uint16_t c_size = (csd.v1.c_size_high << 10)
-                      | (csd.v1.c_size_mid << 2) | csd.v1.c_size_low;
-    uint8_t c_size_mult = (csd.v1.c_size_mult_high << 1)
-                          | csd.v1.c_size_mult_low;
-    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
-  } else if (csd.v2.csd_ver == 1) {
-    uint32_t c_size = ((uint32_t)csd.v2.c_size_high << 16)
-                      | (csd.v2.c_size_mid << 8) | csd.v2.c_size_low;
-    return (c_size + 1) << 10;
-  } else {
-    error(SD_CARD_ERROR_BAD_CSD);
-    return 0;
-  }
-}
-//------------------------------------------------------------------------------
-void Sd2Card::chipSelectHigh() {
-  digitalWrite(chipSelectPin_, HIGH);
-}
-//------------------------------------------------------------------------------
-void Sd2Card::chipSelectLow() {
-#ifndef SOFTWARE_SPI
-  spiInit(spiRate_);
-#endif  // SOFTWARE_SPI
-  digitalWrite(chipSelectPin_, LOW);
-}
-//------------------------------------------------------------------------------
-/** Erase a range of blocks.
- *
- * \param[in] firstBlock The address of the first block in the range.
- * \param[in] lastBlock The address of the last block in the range.
- *
- * \note This function requests the SD card to do a flash erase for a
- * range of blocks.  The data on the card after an erase operation is
- * either 0 or 1, depends on the card vendor.  The card must support
- * single block erase.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
-  csd_t csd;
-  if (!readCSD(&csd)) goto fail;
-  // check for single block erase
-  if (!csd.v1.erase_blk_en) {
-    // erase size mask
-    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
-    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
-      // error card can't erase specified area
-      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
-      goto fail;
-    }
-  }
-  if (type_ != SD_CARD_TYPE_SDHC) {
-    firstBlock <<= 9;
-    lastBlock <<= 9;
-  }
-  if (cardCommand(CMD32, firstBlock)
-    || cardCommand(CMD33, lastBlock)
-    || cardCommand(CMD38, 0)) {
-      error(SD_CARD_ERROR_ERASE);
-      goto fail;
-  }
-  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
-    error(SD_CARD_ERROR_ERASE_TIMEOUT);
-    goto fail;
-  }
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Determine if card supports single block erase.
- *
- * \return The value one, true, is returned if single block erase is supported.
- * The value zero, false, is returned if single block erase is not supported.
- */
-bool Sd2Card::eraseSingleBlockEnable() {
-  csd_t csd;
-  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
-}
-//------------------------------------------------------------------------------
-/**
- * Initialize an SD flash memory card.
- *
- * \param[in] sckRateID SPI clock rate selector. See setSckRate().
- * \param[in] chipSelectPin SD chip select pin number.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.  The reason for failure
- * can be determined by calling errorCode() and errorData().
- */
-bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
-  errorCode_ = type_ = 0;
-  chipSelectPin_ = chipSelectPin;
-  // 16-bit init start time allows over a minute
-  uint16_t t0 = (uint16_t)millis();
-  uint32_t arg;
-
-  // set pin modes
-  pinMode(chipSelectPin_, OUTPUT);
-  chipSelectHigh();
-  pinMode(SPI_MISO_PIN, INPUT);
-  pinMode(SPI_MOSI_PIN, OUTPUT);
-  pinMode(SPI_SCK_PIN, OUTPUT);
-
-#ifndef SOFTWARE_SPI
-  // SS must be in output mode even it is not chip select
-  pinMode(SS_PIN, OUTPUT);
-  // set SS high - may be chip select for another SPI device
-#if SET_SPI_SS_HIGH
-  digitalWrite(SS_PIN, HIGH);
-#endif  // SET_SPI_SS_HIGH
-  // set SCK rate for initialization commands
-  spiRate_ = SPI_SD_INIT_RATE;
-  spiInit(spiRate_);
-#endif  // SOFTWARE_SPI
-
-  // must supply min of 74 clock cycles with CS high.
-  for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
-
-  // command to go idle in SPI mode
-  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
-    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
-      error(SD_CARD_ERROR_CMD0);
-      goto fail;
-    }
-  }
-  // check SD version
-  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
-    type(SD_CARD_TYPE_SD1);
-  } else {
-    // only need last byte of r7 response
-    for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
-    if (status_ != 0XAA) {
-      error(SD_CARD_ERROR_CMD8);
-      goto fail;
-    }
-    type(SD_CARD_TYPE_SD2);
-  }
-  // initialize card and send host supports SDHC if SD2
-  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
-
-  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
-    // check for timeout
-    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
-      error(SD_CARD_ERROR_ACMD41);
-      goto fail;
-    }
-  }
-  // if SD2 read OCR register to check for SDHC card
-  if (type() == SD_CARD_TYPE_SD2) {
-    if (cardCommand(CMD58, 0)) {
-      error(SD_CARD_ERROR_CMD58);
-      goto fail;
-    }
-    if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
-    // discard rest of ocr - contains allowed voltage range
-    for (uint8_t i = 0; i < 3; i++) spiRec();
-  }
-  chipSelectHigh();
-
-#ifndef SOFTWARE_SPI
-  return setSckRate(sckRateID);
-#else  // SOFTWARE_SPI
-  return true;
-#endif  // SOFTWARE_SPI
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/**
- * Read a 512 byte block from an SD card.
- *
- * \param[in] blockNumber Logical block to be read.
- * \param[out] dst Pointer to the location that will receive the data.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
-#ifdef SD_CHECK_AND_RETRY
-  uint8_t retryCnt = 3;
-  // use address if not SDHC card
-  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
- retry2:
-  retryCnt --;
-  if (cardCommand(CMD17, blockNumber)) {
-    error(SD_CARD_ERROR_CMD17);
-    if (retryCnt > 0) goto retry;
-    goto fail;
-  }
-  if (!readData(dst, 512))
-  {
-    if (retryCnt > 0) goto retry;
-    goto fail;
-  }
-  return true;
- retry:
-   chipSelectHigh();
-   cardCommand(CMD12, 0);//Try sending a stop command, but ignore the result.
-   errorCode_ = 0;
-   goto retry2;
-#else
-  // use address if not SDHC card
-  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD17, blockNumber)) {
-    error(SD_CARD_ERROR_CMD17);
-    goto fail;
-  }
-  return readData(dst, 512);
-#endif
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Read one data block in a multiple block read sequence
- *
- * \param[in] dst Pointer to the location for the data to be read.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::readData(uint8_t *dst) {
-  chipSelectLow();
-  return readData(dst, 512);
-}
-
-#ifdef SD_CHECK_AND_RETRY
-static const uint16_t crctab[] PROGMEM = {
-  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
-  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
-  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
-  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
-  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
-  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
-  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
-  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
-  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
-  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
-  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
-  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
-  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
-  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
-  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
-  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
-  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
-  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
-  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
-  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
-  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
-  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
-  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
-  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
-  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
-  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
-  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
-  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
-  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
-  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
-  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
-  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
-};
-static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
-  uint16_t crc = 0;
-  for (size_t i = 0; i < n; i++) {
-    crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0XFF]) ^ (crc << 8);
-  }
-  return crc;
-}
-#endif
-
-//------------------------------------------------------------------------------
-bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
-  // wait for start block token
-  uint16_t t0 = millis();
-  while ((status_ = spiRec()) == 0XFF) {
-    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
-      error(SD_CARD_ERROR_READ_TIMEOUT);
-      goto fail;
-    }
-  }
-  if (status_ != DATA_START_BLOCK) {
-    error(SD_CARD_ERROR_READ);
-    goto fail;
-  }
-  // transfer data
-  spiRead(dst, count);
-
-#ifdef SD_CHECK_AND_RETRY
-  {
-    uint16_t calcCrc = CRC_CCITT(dst, count);
-    uint16_t recvCrc = spiRec() << 8;
-    recvCrc |= spiRec();
-    if (calcCrc != recvCrc)
-    {
-        error(SD_CARD_ERROR_CRC);
-        goto fail;
-    }
-  }
-#else
-  // discard CRC
-  spiRec();
-  spiRec();
-#endif
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** read CID or CSR register */
-bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
-  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
-  if (cardCommand(cmd, 0)) {
-    error(SD_CARD_ERROR_READ_REG);
-    goto fail;
-  }
-  return readData(dst, 16);
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Start a read multiple blocks sequence.
- *
- * \param[in] blockNumber Address of first block in sequence.
- *
- * \note This function is used with readData() and readStop() for optimized
- * multiple block reads.  SPI chipSelect must be low for the entire sequence.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::readStart(uint32_t blockNumber) {
-  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD18, blockNumber)) {
-    error(SD_CARD_ERROR_CMD18);
-    goto fail;
-  }
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** End a read multiple blocks sequence.
- *
-* \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::readStop() {
-  chipSelectLow();
-  if (cardCommand(CMD12, 0)) {
-    error(SD_CARD_ERROR_CMD12);
-    goto fail;
-  }
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/**
- * Set the SPI clock rate.
- *
- * \param[in] sckRateID A value in the range [0, 6].
- *
- * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum
- * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128
- * for \a scsRateID = 6.
- *
- * \return The value one, true, is returned for success and the value zero,
- * false, is returned for an invalid value of \a sckRateID.
- */
-bool Sd2Card::setSckRate(uint8_t sckRateID) {
-  if (sckRateID > 6) {
-    error(SD_CARD_ERROR_SCK_RATE);
-    return false;
-  }
-  spiRate_ = sckRateID;
-  return true;
-}
-//------------------------------------------------------------------------------
-// wait for card to go not busy
-bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
-  uint16_t t0 = millis();
-  while (spiRec() != 0XFF) {
-    if (((uint16_t)millis() - t0) >= timeoutMillis) goto fail;
-  }
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/**
- * Writes a 512 byte block to an SD card.
- *
- * \param[in] blockNumber Logical block to be written.
- * \param[in] src Pointer to the location of the data to be written.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
-  // use address if not SDHC card
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD24, blockNumber)) {
-    error(SD_CARD_ERROR_CMD24);
-    goto fail;
-  }
-  if (!writeData(DATA_START_BLOCK, src)) goto fail;
-
-  // wait for flash programming to complete
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
-    error(SD_CARD_ERROR_WRITE_TIMEOUT);
-    goto fail;
-  }
-  // response is r2 so get and check two bytes for nonzero
-  if (cardCommand(CMD13, 0) || spiRec()) {
-    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
-    goto fail;
-  }
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Write one data block in a multiple block write sequence
- * \param[in] src Pointer to the location of the data to be written.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::writeData(const uint8_t* src) {
-  chipSelectLow();
-  // wait for previous write to finish
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
-  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;
-  chipSelectHigh();
-  return true;
-
- fail:
-  error(SD_CARD_ERROR_WRITE_MULTIPLE);
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-// send one block of data for write block or write multiple blocks
-bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
-  spiSendBlock(token, src);
-
-  spiSend(0xff);  // dummy crc
-  spiSend(0xff);  // dummy crc
-
-  status_ = spiRec();
-  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
-    error(SD_CARD_ERROR_WRITE);
-    goto fail;
-  }
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Start a write multiple blocks sequence.
- *
- * \param[in] blockNumber Address of first block in sequence.
- * \param[in] eraseCount The number of blocks to be pre-erased.
- *
- * \note This function is used with writeData() and writeStop()
- * for optimized multiple block writes.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
-  // send pre-erase count
-  if (cardAcmd(ACMD23, eraseCount)) {
-    error(SD_CARD_ERROR_ACMD23);
-    goto fail;
-  }
-  // use address if not SDHC card
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD25, blockNumber)) {
-    error(SD_CARD_ERROR_CMD25);
-    goto fail;
-  }
-  chipSelectHigh();
-  return true;
-
- fail:
-  chipSelectHigh();
-  return false;
-}
-//------------------------------------------------------------------------------
-/** End a write multiple blocks sequence.
- *
-* \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool Sd2Card::writeStop() {
-  chipSelectLow();
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
-  spiSend(STOP_TRAN_TOKEN);
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
-  chipSelectHigh();
-  return true;
-
- fail:
-  error(SD_CARD_ERROR_STOP_TRAN);
-  chipSelectHigh();
-  return false;
-}
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.h
deleted file mode 100644
index 06dfa1c..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2Card.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/* Arduino Sd2Card Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino Sd2Card Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino Sd2Card Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-#ifndef Sd2Card_h
-#define Sd2Card_h
-/**
- * \file
- * \brief Sd2Card class for V2 SD/SDHC cards
- */
-#include "SdFatConfig.h"
-#include "Sd2PinMap.h"
-#include "SdInfo.h"
-//------------------------------------------------------------------------------
-// SPI speed is F_CPU/2^(1 + index), 0 <= index <= 6
-/** Set SCK to max rate of F_CPU/2. See Sd2Card::setSckRate(). */
-uint8_t const SPI_FULL_SPEED = 0;
-/** Set SCK rate to F_CPU/4. See Sd2Card::setSckRate(). */
-uint8_t const SPI_HALF_SPEED = 1;
-/** Set SCK rate to F_CPU/8. See Sd2Card::setSckRate(). */
-uint8_t const SPI_QUARTER_SPEED = 2;
-/** Set SCK rate to F_CPU/16. See Sd2Card::setSckRate(). */
-uint8_t const SPI_EIGHTH_SPEED = 3;
-/** Set SCK rate to F_CPU/32. See Sd2Card::setSckRate(). */
-uint8_t const SPI_SIXTEENTH_SPEED = 4;
-//------------------------------------------------------------------------------
-/** init timeout ms */
-uint16_t const SD_INIT_TIMEOUT = 2000;
-/** erase timeout ms */
-uint16_t const SD_ERASE_TIMEOUT = 10000;
-/** read timeout ms */
-uint16_t const SD_READ_TIMEOUT = 300;
-/** write time out ms */
-uint16_t const SD_WRITE_TIMEOUT = 600;
-//------------------------------------------------------------------------------
-// SD card errors
-/** timeout error for command CMD0 (initialize card in SPI mode) */
-uint8_t const SD_CARD_ERROR_CMD0 = 0X1;
-/** CMD8 was not accepted - not a valid SD card*/
-uint8_t const SD_CARD_ERROR_CMD8 = 0X2;
-/** card returned an error response for CMD12 (write stop) */
-uint8_t const SD_CARD_ERROR_CMD12 = 0X3;
-/** card returned an error response for CMD17 (read block) */
-uint8_t const SD_CARD_ERROR_CMD17 = 0X4;
-/** card returned an error response for CMD18 (read multiple block) */
-uint8_t const SD_CARD_ERROR_CMD18 = 0X5;
-/** card returned an error response for CMD24 (write block) */
-uint8_t const SD_CARD_ERROR_CMD24 = 0X6;
-/**  WRITE_MULTIPLE_BLOCKS command failed */
-uint8_t const SD_CARD_ERROR_CMD25 = 0X7;
-/** card returned an error response for CMD58 (read OCR) */
-uint8_t const SD_CARD_ERROR_CMD58 = 0X8;
-/** SET_WR_BLK_ERASE_COUNT failed */
-uint8_t const SD_CARD_ERROR_ACMD23 = 0X9;
-/** ACMD41 initialization process timeout */
-uint8_t const SD_CARD_ERROR_ACMD41 = 0XA;
-/** card returned a bad CSR version field */
-uint8_t const SD_CARD_ERROR_BAD_CSD = 0XB;
-/** erase block group command failed */
-uint8_t const SD_CARD_ERROR_ERASE = 0XC;
-/** card not capable of single block erase */
-uint8_t const SD_CARD_ERROR_ERASE_SINGLE_BLOCK = 0XD;
-/** Erase sequence timed out */
-uint8_t const SD_CARD_ERROR_ERASE_TIMEOUT = 0XE;
-/** card returned an error token instead of read data */
-uint8_t const SD_CARD_ERROR_READ = 0XF;
-/** read CID or CSD failed */
-uint8_t const SD_CARD_ERROR_READ_REG = 0X10;
-/** timeout while waiting for start of read data */
-uint8_t const SD_CARD_ERROR_READ_TIMEOUT = 0X11;
-/** card did not accept STOP_TRAN_TOKEN */
-uint8_t const SD_CARD_ERROR_STOP_TRAN = 0X12;
-/** card returned an error token as a response to a write operation */
-uint8_t const SD_CARD_ERROR_WRITE = 0X13;
-/** attempt to write protected block zero */
-uint8_t const SD_CARD_ERROR_WRITE_BLOCK_ZERO = 0X14;  // REMOVE - not used
-/** card did not go ready for a multiple block write */
-uint8_t const SD_CARD_ERROR_WRITE_MULTIPLE = 0X15;
-/** card returned an error to a CMD13 status check after a write */
-uint8_t const SD_CARD_ERROR_WRITE_PROGRAMMING = 0X16;
-/** timeout occurred during write programming */
-uint8_t const SD_CARD_ERROR_WRITE_TIMEOUT = 0X17;
-/** incorrect rate selected */
-uint8_t const SD_CARD_ERROR_SCK_RATE = 0X18;
-/** init() not called */
-uint8_t const SD_CARD_ERROR_INIT_NOT_CALLED = 0X19;
-/** crc check error */
-uint8_t const SD_CARD_ERROR_CRC = 0X20;
-//------------------------------------------------------------------------------
-// card types
-/** Standard capacity V1 SD card */
-uint8_t const SD_CARD_TYPE_SD1  = 1;
-/** Standard capacity V2 SD card */
-uint8_t const SD_CARD_TYPE_SD2  = 2;
-/** High Capacity SD card */
-uint8_t const SD_CARD_TYPE_SDHC = 3;
-/**
- * define SOFTWARE_SPI to use bit-bang SPI
- */
-//------------------------------------------------------------------------------
-#if MEGA_SOFT_SPI && (defined(__AVR_ATmega1280__)||defined(__AVR_ATmega2560__))
-#define SOFTWARE_SPI
-#elif USE_SOFTWARE_SPI
-#define SOFTWARE_SPI
-#endif  // MEGA_SOFT_SPI
-//------------------------------------------------------------------------------
-// SPI pin definitions - do not edit here - change in SdFatConfig.h
-//
-#ifndef SOFTWARE_SPI
-// hardware pin defs
-/** The default chip select pin for the SD card is SS. */
-uint8_t const  SD_CHIP_SELECT_PIN = SS_PIN;
-// The following three pins must not be redefined for hardware SPI.
-/** SPI Master Out Slave In pin */
-uint8_t const  SPI_MOSI_PIN = MOSI_PIN;
-/** SPI Master In Slave Out pin */
-uint8_t const  SPI_MISO_PIN = MISO_PIN;
-/** SPI Clock pin */
-uint8_t const  SPI_SCK_PIN = SCK_PIN;
-
-#else  // SOFTWARE_SPI
-
-/** SPI chip select pin */
-uint8_t const SD_CHIP_SELECT_PIN = SOFT_SPI_CS_PIN;
-/** SPI Master Out Slave In pin */
-uint8_t const SPI_MOSI_PIN = SOFT_SPI_MOSI_PIN;
-/** SPI Master In Slave Out pin */
-uint8_t const SPI_MISO_PIN = SOFT_SPI_MISO_PIN;
-/** SPI Clock pin */
-uint8_t const SPI_SCK_PIN = SOFT_SPI_SCK_PIN;
-#endif  // SOFTWARE_SPI
-//------------------------------------------------------------------------------
-/**
- * \class Sd2Card
- * \brief Raw access to SD and SDHC flash memory cards.
- */
-class Sd2Card {
- public:
-  /** Construct an instance of Sd2Card. */
-  Sd2Card() : errorCode_(SD_CARD_ERROR_INIT_NOT_CALLED), type_(0) {}
-  uint32_t cardSize();
-  bool erase(uint32_t firstBlock, uint32_t lastBlock);
-  bool eraseSingleBlockEnable();
-  /**
-   *  Set SD error code.
-   *  \param[in] code value for error code.
-   */
-  void error(uint8_t code) {errorCode_ = code;}
-  /**
-   * \return error code for last error. See Sd2Card.h for a list of error codes.
-   */
-  int errorCode() const {return errorCode_;}
-  /** \return error data for last error. */
-  int errorData() const {return status_;}
-  /**
-   * Initialize an SD flash memory card with default clock rate and chip
-   * select pin.  See sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin).
-   *
-   * \return true for success or false for failure.
-   */
-  bool init(uint8_t sckRateID = SPI_FULL_SPEED,
-    uint8_t chipSelectPin = SD_CHIP_SELECT_PIN);
-  bool readBlock(uint32_t block, uint8_t* dst);
-  /**
-   * Read a card's CID register. The CID contains card identification
-   * information such as Manufacturer ID, Product name, Product serial
-   * number and Manufacturing date. 
-   *
-   * \param[out] cid pointer to area for returned data.
-   *
-   * \return true for success or false for failure.
-   */
-  bool readCID(cid_t* cid) {
-    return readRegister(CMD10, cid);
-  }
-  /**
-   * Read a card's CSD register. The CSD contains Card-Specific Data that
-   * provides information regarding access to the card's contents.
-   *
-   * \param[out] csd pointer to area for returned data.
-   *
-   * \return true for success or false for failure.
-   */
-  bool readCSD(csd_t* csd) {
-    return readRegister(CMD9, csd);
-  }
-  bool readData(uint8_t *dst);
-  bool readStart(uint32_t blockNumber);
-  bool readStop();
-  bool setSckRate(uint8_t sckRateID);
-  /** Return the card type: SD V1, SD V2 or SDHC
-   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC.
-   */
-  int type() const {return type_;}
-  bool writeBlock(uint32_t blockNumber, const uint8_t* src);
-  bool writeData(const uint8_t* src);
-  bool writeStart(uint32_t blockNumber, uint32_t eraseCount);
-  bool writeStop();
- private:
-  //----------------------------------------------------------------------------
-  uint8_t chipSelectPin_;
-  uint8_t errorCode_;
-  uint8_t spiRate_;
-  uint8_t status_;
-  uint8_t type_;
-  // private functions
-  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
-    cardCommand(CMD55, 0);
-    return cardCommand(cmd, arg);
-  }
-  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
-
-  bool readData(uint8_t* dst, uint16_t count);
-  bool readRegister(uint8_t cmd, void* buf);
-  void chipSelectHigh();
-  void chipSelectLow();
-  void type(uint8_t value) {type_ = value;}
-  bool waitNotBusy(uint16_t timeoutMillis);
-  bool writeData(uint8_t token, const uint8_t* src);
-};
-#endif  // Sd2Card_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2PinMap.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2PinMap.h
deleted file mode 100644
index 77e4e5c..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/Sd2PinMap.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2010 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-// Warning this file was generated by a program.
-#ifndef Sd2PinMap_h
-#define Sd2PinMap_h
-#include <avr/io.h>
-//------------------------------------------------------------------------------
-/** struct for mapping digital pins */
-struct pin_map_t {
-  volatile uint8_t* ddr;
-  volatile uint8_t* pin;
-  volatile uint8_t* port;
-  uint8_t bit;
-};
-//------------------------------------------------------------------------------
-#if defined(__AVR_ATmega1280__)\
-|| defined(__AVR_ATmega2560__)
-// Mega
-
-// Two Wire (aka I2C) ports
-uint8_t const SDA_PIN = 20;  // D1
-uint8_t const SCL_PIN = 21;  // D0
-
-#undef MOSI_PIN
-#undef MISO_PIN
-// SPI port
-uint8_t const SS_PIN = 53;    // B0
-uint8_t const MOSI_PIN = 51;  // B2
-uint8_t const MISO_PIN = 50;  // B3
-uint8_t const SCK_PIN = 52;   // B1
-
-static const pin_map_t digitalPinMap[] = {
-  {&DDRE, &PINE, &PORTE, 0},  // E0  0
-  {&DDRE, &PINE, &PORTE, 1},  // E1  1
-  {&DDRE, &PINE, &PORTE, 4},  // E4  2
-  {&DDRE, &PINE, &PORTE, 5},  // E5  3
-  {&DDRG, &PING, &PORTG, 5},  // G5  4
-  {&DDRE, &PINE, &PORTE, 3},  // E3  5
-  {&DDRH, &PINH, &PORTH, 3},  // H3  6
-  {&DDRH, &PINH, &PORTH, 4},  // H4  7
-  {&DDRH, &PINH, &PORTH, 5},  // H5  8
-  {&DDRH, &PINH, &PORTH, 6},  // H6  9
-  {&DDRB, &PINB, &PORTB, 4},  // B4 10
-  {&DDRB, &PINB, &PORTB, 5},  // B5 11
-  {&DDRB, &PINB, &PORTB, 6},  // B6 12
-  {&DDRB, &PINB, &PORTB, 7},  // B7 13
-  {&DDRJ, &PINJ, &PORTJ, 1},  // J1 14
-  {&DDRJ, &PINJ, &PORTJ, 0},  // J0 15
-  {&DDRH, &PINH, &PORTH, 1},  // H1 16
-  {&DDRH, &PINH, &PORTH, 0},  // H0 17
-  {&DDRD, &PIND, &PORTD, 3},  // D3 18
-  {&DDRD, &PIND, &PORTD, 2},  // D2 19
-  {&DDRD, &PIND, &PORTD, 1},  // D1 20
-  {&DDRD, &PIND, &PORTD, 0},  // D0 21
-  {&DDRA, &PINA, &PORTA, 0},  // A0 22
-  {&DDRA, &PINA, &PORTA, 1},  // A1 23
-  {&DDRA, &PINA, &PORTA, 2},  // A2 24
-  {&DDRA, &PINA, &PORTA, 3},  // A3 25
-  {&DDRA, &PINA, &PORTA, 4},  // A4 26
-  {&DDRA, &PINA, &PORTA, 5},  // A5 27
-  {&DDRA, &PINA, &PORTA, 6},  // A6 28
-  {&DDRA, &PINA, &PORTA, 7},  // A7 29
-  {&DDRC, &PINC, &PORTC, 7},  // C7 30
-  {&DDRC, &PINC, &PORTC, 6},  // C6 31
-  {&DDRC, &PINC, &PORTC, 5},  // C5 32
-  {&DDRC, &PINC, &PORTC, 4},  // C4 33
-  {&DDRC, &PINC, &PORTC, 3},  // C3 34
-  {&DDRC, &PINC, &PORTC, 2},  // C2 35
-  {&DDRC, &PINC, &PORTC, 1},  // C1 36
-  {&DDRC, &PINC, &PORTC, 0},  // C0 37
-  {&DDRD, &PIND, &PORTD, 7},  // D7 38
-  {&DDRG, &PING, &PORTG, 2},  // G2 39
-  {&DDRG, &PING, &PORTG, 1},  // G1 40
-  {&DDRG, &PING, &PORTG, 0},  // G0 41
-  {&DDRL, &PINL, &PORTL, 7},  // L7 42
-  {&DDRL, &PINL, &PORTL, 6},  // L6 43
-  {&DDRL, &PINL, &PORTL, 5},  // L5 44
-  {&DDRL, &PINL, &PORTL, 4},  // L4 45
-  {&DDRL, &PINL, &PORTL, 3},  // L3 46
-  {&DDRL, &PINL, &PORTL, 2},  // L2 47
-  {&DDRL, &PINL, &PORTL, 1},  // L1 48
-  {&DDRL, &PINL, &PORTL, 0},  // L0 49
-  {&DDRB, &PINB, &PORTB, 3},  // B3 50
-  {&DDRB, &PINB, &PORTB, 2},  // B2 51
-  {&DDRB, &PINB, &PORTB, 1},  // B1 52
-  {&DDRB, &PINB, &PORTB, 0},  // B0 53
-  {&DDRF, &PINF, &PORTF, 0},  // F0 54
-  {&DDRF, &PINF, &PORTF, 1},  // F1 55
-  {&DDRF, &PINF, &PORTF, 2},  // F2 56
-  {&DDRF, &PINF, &PORTF, 3},  // F3 57
-  {&DDRF, &PINF, &PORTF, 4},  // F4 58
-  {&DDRF, &PINF, &PORTF, 5},  // F5 59
-  {&DDRF, &PINF, &PORTF, 6},  // F6 60
-  {&DDRF, &PINF, &PORTF, 7},  // F7 61
-  {&DDRK, &PINK, &PORTK, 0},  // K0 62
-  {&DDRK, &PINK, &PORTK, 1},  // K1 63
-  {&DDRK, &PINK, &PORTK, 2},  // K2 64
-  {&DDRK, &PINK, &PORTK, 3},  // K3 65
-  {&DDRK, &PINK, &PORTK, 4},  // K4 66
-  {&DDRK, &PINK, &PORTK, 5},  // K5 67
-  {&DDRK, &PINK, &PORTK, 6},  // K6 68
-  {&DDRK, &PINK, &PORTK, 7}   // K7 69
-};
-//------------------------------------------------------------------------------
-#elif defined(__AVR_ATmega644P__)\
-|| defined(__AVR_ATmega644__)\
-|| defined(__AVR_ATmega1284P__)
-// Sanguino
-
-// Two Wire (aka I2C) ports
-uint8_t const SDA_PIN = 17;  // C1
-uint8_t const SCL_PIN = 18;  // C2
-
-// SPI port
-uint8_t const SS_PIN = 4;    // B4
-uint8_t const MOSI_PIN = 5;  // B5
-uint8_t const MISO_PIN = 6;  // B6
-uint8_t const SCK_PIN = 7;   // B7
-
-static const pin_map_t digitalPinMap[] = {
-  {&DDRB, &PINB, &PORTB, 0},  // B0  0
-  {&DDRB, &PINB, &PORTB, 1},  // B1  1
-  {&DDRB, &PINB, &PORTB, 2},  // B2  2
-  {&DDRB, &PINB, &PORTB, 3},  // B3  3
-  {&DDRB, &PINB, &PORTB, 4},  // B4  4
-  {&DDRB, &PINB, &PORTB, 5},  // B5  5
-  {&DDRB, &PINB, &PORTB, 6},  // B6  6
-  {&DDRB, &PINB, &PORTB, 7},  // B7  7
-  {&DDRD, &PIND, &PORTD, 0},  // D0  8
-  {&DDRD, &PIND, &PORTD, 1},  // D1  9
-  {&DDRD, &PIND, &PORTD, 2},  // D2 10
-  {&DDRD, &PIND, &PORTD, 3},  // D3 11
-  {&DDRD, &PIND, &PORTD, 4},  // D4 12
-  {&DDRD, &PIND, &PORTD, 5},  // D5 13
-  {&DDRD, &PIND, &PORTD, 6},  // D6 14
-  {&DDRD, &PIND, &PORTD, 7},  // D7 15
-  {&DDRC, &PINC, &PORTC, 0},  // C0 16
-  {&DDRC, &PINC, &PORTC, 1},  // C1 17
-  {&DDRC, &PINC, &PORTC, 2},  // C2 18
-  {&DDRC, &PINC, &PORTC, 3},  // C3 19
-  {&DDRC, &PINC, &PORTC, 4},  // C4 20
-  {&DDRC, &PINC, &PORTC, 5},  // C5 21
-  {&DDRC, &PINC, &PORTC, 6},  // C6 22
-  {&DDRC, &PINC, &PORTC, 7},  // C7 23
-  {&DDRA, &PINA, &PORTA, 7},  // A7 24
-  {&DDRA, &PINA, &PORTA, 6},  // A6 25
-  {&DDRA, &PINA, &PORTA, 5},  // A5 26
-  {&DDRA, &PINA, &PORTA, 4},  // A4 27
-  {&DDRA, &PINA, &PORTA, 3},  // A3 28
-  {&DDRA, &PINA, &PORTA, 2},  // A2 29
-  {&DDRA, &PINA, &PORTA, 1},  // A1 30
-  {&DDRA, &PINA, &PORTA, 0}   // A0 31
-};
-//------------------------------------------------------------------------------
-#elif defined(__AVR_ATmega32U4__)
-// Teensy 2.0
-
-// Two Wire (aka I2C) ports
-uint8_t const SDA_PIN = 6;  // D1
-uint8_t const SCL_PIN = 5;  // D0
-
-// SPI port
-uint8_t const SS_PIN = 0;    // B0
-uint8_t const MOSI_PIN = 2;  // B2
-uint8_t const MISO_PIN = 3;  // B3
-uint8_t const SCK_PIN = 1;   // B1
-
-static const pin_map_t digitalPinMap[] = {
-  {&DDRB, &PINB, &PORTB, 0},  // B0  0
-  {&DDRB, &PINB, &PORTB, 1},  // B1  1
-  {&DDRB, &PINB, &PORTB, 2},  // B2  2
-  {&DDRB, &PINB, &PORTB, 3},  // B3  3
-  {&DDRB, &PINB, &PORTB, 7},  // B7  4
-  {&DDRD, &PIND, &PORTD, 0},  // D0  5
-  {&DDRD, &PIND, &PORTD, 1},  // D1  6
-  {&DDRD, &PIND, &PORTD, 2},  // D2  7
-  {&DDRD, &PIND, &PORTD, 3},  // D3  8
-  {&DDRC, &PINC, &PORTC, 6},  // C6  9
-  {&DDRC, &PINC, &PORTC, 7},  // C7 10
-  {&DDRD, &PIND, &PORTD, 6},  // D6 11
-  {&DDRD, &PIND, &PORTD, 7},  // D7 12
-  {&DDRB, &PINB, &PORTB, 4},  // B4 13
-  {&DDRB, &PINB, &PORTB, 5},  // B5 14
-  {&DDRB, &PINB, &PORTB, 6},  // B6 15
-  {&DDRF, &PINF, &PORTF, 7},  // F7 16
-  {&DDRF, &PINF, &PORTF, 6},  // F6 17
-  {&DDRF, &PINF, &PORTF, 5},  // F5 18
-  {&DDRF, &PINF, &PORTF, 4},  // F4 19
-  {&DDRF, &PINF, &PORTF, 1},  // F1 20
-  {&DDRF, &PINF, &PORTF, 0},  // F0 21
-  {&DDRD, &PIND, &PORTD, 4},  // D4 22
-  {&DDRD, &PIND, &PORTD, 5},  // D5 23
-  {&DDRE, &PINE, &PORTE, 6}   // E6 24
-};
-//------------------------------------------------------------------------------
-#elif defined(__AVR_AT90USB646__)\
-|| defined(__AVR_AT90USB1286__)
-// Teensy++ 1.0 & 2.0
-
-// Two Wire (aka I2C) ports
-uint8_t const SDA_PIN = 1;  // D1
-uint8_t const SCL_PIN = 0;  // D0
-
-// SPI port
-uint8_t const SS_PIN    = 20;    // B0
-uint8_t const MOSI_PIN  = 22;    // B2
-uint8_t const MISO_PIN  = 23;    // B3
-uint8_t const SCK_PIN   = 21;    // B1
-
-static const pin_map_t digitalPinMap[] = {
-  {&DDRD, &PIND, &PORTD, 0},  // D0  0
-  {&DDRD, &PIND, &PORTD, 1},  // D1  1
-  {&DDRD, &PIND, &PORTD, 2},  // D2  2
-  {&DDRD, &PIND, &PORTD, 3},  // D3  3
-  {&DDRD, &PIND, &PORTD, 4},  // D4  4
-  {&DDRD, &PIND, &PORTD, 5},  // D5  5
-  {&DDRD, &PIND, &PORTD, 6},  // D6  6
-  {&DDRD, &PIND, &PORTD, 7},  // D7  7
-  {&DDRE, &PINE, &PORTE, 0},  // E0  8
-  {&DDRE, &PINE, &PORTE, 1},  // E1  9
-  {&DDRC, &PINC, &PORTC, 0},  // C0 10
-  {&DDRC, &PINC, &PORTC, 1},  // C1 11
-  {&DDRC, &PINC, &PORTC, 2},  // C2 12
-  {&DDRC, &PINC, &PORTC, 3},  // C3 13
-  {&DDRC, &PINC, &PORTC, 4},  // C4 14
-  {&DDRC, &PINC, &PORTC, 5},  // C5 15
-  {&DDRC, &PINC, &PORTC, 6},  // C6 16
-  {&DDRC, &PINC, &PORTC, 7},  // C7 17
-  {&DDRE, &PINE, &PORTE, 6},  // E6 18
-  {&DDRE, &PINE, &PORTE, 7},  // E7 19
-  {&DDRB, &PINB, &PORTB, 0},  // B0 20
-  {&DDRB, &PINB, &PORTB, 1},  // B1 21
-  {&DDRB, &PINB, &PORTB, 2},  // B2 22
-  {&DDRB, &PINB, &PORTB, 3},  // B3 23
-  {&DDRB, &PINB, &PORTB, 4},  // B4 24
-  {&DDRB, &PINB, &PORTB, 5},  // B5 25
-  {&DDRB, &PINB, &PORTB, 6},  // B6 26
-  {&DDRB, &PINB, &PORTB, 7},  // B7 27
-  {&DDRA, &PINA, &PORTA, 0},  // A0 28
-  {&DDRA, &PINA, &PORTA, 1},  // A1 29
-  {&DDRA, &PINA, &PORTA, 2},  // A2 30
-  {&DDRA, &PINA, &PORTA, 3},  // A3 31
-  {&DDRA, &PINA, &PORTA, 4},  // A4 32
-  {&DDRA, &PINA, &PORTA, 5},  // A5 33
-  {&DDRA, &PINA, &PORTA, 6},  // A6 34
-  {&DDRA, &PINA, &PORTA, 7},  // A7 35
-  {&DDRE, &PINE, &PORTE, 4},  // E4 36
-  {&DDRE, &PINE, &PORTE, 5},  // E5 37
-  {&DDRF, &PINF, &PORTF, 0},  // F0 38
-  {&DDRF, &PINF, &PORTF, 1},  // F1 39
-  {&DDRF, &PINF, &PORTF, 2},  // F2 40
-  {&DDRF, &PINF, &PORTF, 3},  // F3 41
-  {&DDRF, &PINF, &PORTF, 4},  // F4 42
-  {&DDRF, &PINF, &PORTF, 5},  // F5 43
-  {&DDRF, &PINF, &PORTF, 6},  // F6 44
-  {&DDRF, &PINF, &PORTF, 7}   // F7 45
-};
-//------------------------------------------------------------------------------
-#elif defined(__AVR_ATmega168__)\
-||defined(__AVR_ATmega168P__)\
-||defined(__AVR_ATmega328P__)
-// 168 and 328 Arduinos
-
-// Two Wire (aka I2C) ports
-uint8_t const SDA_PIN = 18;  // C4
-uint8_t const SCL_PIN = 19;  // C5
-
-// SPI port
-uint8_t const SS_PIN = 10;    // B2
-uint8_t const MOSI_PIN = 11;  // B3
-uint8_t const MISO_PIN = 12;  // B4
-uint8_t const SCK_PIN = 13;   // B5
-
-static const pin_map_t digitalPinMap[] = {
-  {&DDRD, &PIND, &PORTD, 0},  // D0  0
-  {&DDRD, &PIND, &PORTD, 1},  // D1  1
-  {&DDRD, &PIND, &PORTD, 2},  // D2  2
-  {&DDRD, &PIND, &PORTD, 3},  // D3  3
-  {&DDRD, &PIND, &PORTD, 4},  // D4  4
-  {&DDRD, &PIND, &PORTD, 5},  // D5  5
-  {&DDRD, &PIND, &PORTD, 6},  // D6  6
-  {&DDRD, &PIND, &PORTD, 7},  // D7  7
-  {&DDRB, &PINB, &PORTB, 0},  // B0  8
-  {&DDRB, &PINB, &PORTB, 1},  // B1  9
-  {&DDRB, &PINB, &PORTB, 2},  // B2 10
-  {&DDRB, &PINB, &PORTB, 3},  // B3 11
-  {&DDRB, &PINB, &PORTB, 4},  // B4 12
-  {&DDRB, &PINB, &PORTB, 5},  // B5 13
-  {&DDRC, &PINC, &PORTC, 0},  // C0 14
-  {&DDRC, &PINC, &PORTC, 1},  // C1 15
-  {&DDRC, &PINC, &PORTC, 2},  // C2 16
-  {&DDRC, &PINC, &PORTC, 3},  // C3 17
-  {&DDRC, &PINC, &PORTC, 4},  // C4 18
-  {&DDRC, &PINC, &PORTC, 5}   // C5 19
-};
-#else  // defined(__AVR_ATmega1280__)
-#error unknown chip
-#endif  // defined(__AVR_ATmega1280__)
-//------------------------------------------------------------------------------
-static const uint8_t digitalPinCount = sizeof(digitalPinMap)/sizeof(pin_map_t);
-
-uint8_t badPinNumber(void)
-  __attribute__((error("Pin number is too large or not a constant")));
-
-static inline __attribute__((always_inline))
-  bool getPinMode(uint8_t pin) {
-  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
-    return (*digitalPinMap[pin].ddr >> digitalPinMap[pin].bit) & 1;
-  } else {
-    return badPinNumber();
-  }
-}
-static inline __attribute__((always_inline))
-  void setPinMode(uint8_t pin, uint8_t mode) {
-  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
-    if (mode) {
-      *digitalPinMap[pin].ddr |= 1 << digitalPinMap[pin].bit;
-    } else {
-      *digitalPinMap[pin].ddr &= ~(1 << digitalPinMap[pin].bit);
-    }
-  } else {
-    badPinNumber();
-  }
-}
-static inline __attribute__((always_inline))
-  bool fastDigitalRead(uint8_t pin) {
-  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
-    return (*digitalPinMap[pin].pin >> digitalPinMap[pin].bit) & 1;
-  } else {
-    return badPinNumber();
-  }
-}
-static inline __attribute__((always_inline))
-  void fastDigitalWrite(uint8_t pin, uint8_t value) {
-  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
-    if (value) {
-      *digitalPinMap[pin].port |= 1 << digitalPinMap[pin].bit;
-    } else {
-      *digitalPinMap[pin].port &= ~(1 << digitalPinMap[pin].bit);
-    }
-  } else {
-    badPinNumber();
-  }
-}
-#endif  // Sd2PinMap_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.cpp b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.cpp
deleted file mode 100644
index 1a12af5..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.cpp
+++ /dev/null
@@ -1,1828 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#include "SdFat.h"
-#include <Print.h>
-
-#include "SdBaseFile.h"
-//------------------------------------------------------------------------------
-// pointer to cwd directory
-SdBaseFile* SdBaseFile::cwd_ = 0;
-// callback function for date/time
-void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
-//------------------------------------------------------------------------------
-// add a cluster to a file
-bool SdBaseFile::addCluster() {
-  if (!vol_->allocContiguous(1, &curCluster_)) goto fail;
-
-  // if first cluster of file link to directory entry
-  if (firstCluster_ == 0) {
-    firstCluster_ = curCluster_;
-    flags_ |= F_FILE_DIR_DIRTY;
-  }
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// Add a cluster to a directory file and zero the cluster.
-// return with first block of cluster in the cache
-bool SdBaseFile::addDirCluster() {
-  uint32_t block;
-  // max folder size
-  if (fileSize_/sizeof(dir_t) >= 0XFFFF) goto fail;
-
-  if (!addCluster()) goto fail;
-  if (!vol_->cacheFlush()) goto fail;
-
-  block = vol_->clusterStartBlock(curCluster_);
-
-  // set cache to first block of cluster
-  vol_->cacheSetBlockNumber(block, true);
-
-  // zero first block of cluster
-  memset(vol_->cacheBuffer_.data, 0, 512);
-
-  // zero rest of cluster
-  for (uint8_t i = 1; i < vol_->blocksPerCluster_; i++) {
-    if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) goto fail;
-  }
-  // Increase directory file size by cluster size
-  fileSize_ += 512UL << vol_->clusterSizeShift_;
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// cache a file's directory entry
-// return pointer to cached entry or null for failure
-dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
-  if (!vol_->cacheRawBlock(dirBlock_, action)) goto fail;
-  return vol_->cache()->dir + dirIndex_;
-
- fail:
-  return 0;
-}
-//------------------------------------------------------------------------------
-/** Close a file and force cached data and directory information
- *  to be written to the storage device.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include no file is open or an I/O error.
- */
-bool SdBaseFile::close() {
-  bool rtn = sync();
-  type_ = FAT_FILE_TYPE_CLOSED;
-  return rtn;
-}
-//------------------------------------------------------------------------------
-/** Check for contiguous file and return its raw block range.
- *
- * \param[out] bgnBlock the first block address for the file.
- * \param[out] endBlock the last  block address for the file.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include file is not contiguous, file has zero length
- * or an I/O error occurred.
- */
-bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
-  // error if no blocks
-  if (firstCluster_ == 0) goto fail;
-
-  for (uint32_t c = firstCluster_; ; c++) {
-    uint32_t next;
-    if (!vol_->fatGet(c, &next)) goto fail;
-
-    // check for contiguous
-    if (next != (c + 1)) {
-      // error if not end of chain
-      if (!vol_->isEOC(next)) goto fail;
-      *bgnBlock = vol_->clusterStartBlock(firstCluster_);
-      *endBlock = vol_->clusterStartBlock(c)
-                  + vol_->blocksPerCluster_ - 1;
-      return true;
-    }
-  }
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Create and open a new contiguous file of a specified size.
- *
- * \note This function only supports short DOS 8.3 names.
- * See open() for more information.
- *
- * \param[in] dirFile The directory where the file will be created.
- * \param[in] path A path with a valid DOS 8.3 file name.
- * \param[in] size The desired file size.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include \a path contains
- * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
- * a file is already open, the file already exists, the root
- * directory is full or an I/O error.
- *
- */
-bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
-        const char* path, uint32_t size) {
-  uint32_t count;
-  // don't allow zero length file
-  if (size == 0) goto fail;
-  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto fail;
-
-  // calculate number of clusters needed
-  count = ((size - 1) >> (vol_->clusterSizeShift_ + 9)) + 1;
-
-  // allocate clusters
-  if (!vol_->allocContiguous(count, &firstCluster_)) {
-    remove();
-    goto fail;
-  }
-  fileSize_ = size;
-
-  // insure sync() will update dir entry
-  flags_ |= F_FILE_DIR_DIRTY;
-
-  return sync();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Return a file's directory entry.
- *
- * \param[out] dir Location for return of the file's directory entry.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::dirEntry(dir_t* dir) {
-  dir_t* p;
-  // make sure fields on SD are correct
-  if (!sync()) goto fail;
-
-  // read entry
-  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
-  if (!p) goto fail;
-
-  // copy to caller's struct
-  memcpy(dir, p, sizeof(dir_t));
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Format the name field of \a dir into the 13 byte array
- * \a name in standard 8.3 short name format.
- *
- * \param[in] dir The directory structure containing the name.
- * \param[out] name A 13 byte char array for the formatted name.
- */
-void SdBaseFile::dirName(const dir_t& dir, char* name) {
-  uint8_t j = 0;
-  for (uint8_t i = 0; i < 11; i++) {
-    if (dir.name[i] == ' ')continue;
-    if (i == 8) name[j++] = '.';
-    name[j++] = dir.name[i];
-  }
-  name[j] = 0;
-}
-//------------------------------------------------------------------------------
-/** Test for the existence of a file in a directory
- *
- * \param[in] name Name of the file to be tested for.
- *
- * The calling instance must be an open directory file.
- *
- * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
- * dirFile.
- *
- * \return true if the file exists else false.
- */
-bool SdBaseFile::exists(const char* name) {
-  SdBaseFile file;
-  return file.open(this, name, O_READ);
-}
-//------------------------------------------------------------------------------
-/**
- * Get a string from a file.
- *
- * fgets() reads bytes from a file into the array pointed to by \a str, until
- * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,
- * or end-of-file is encountered. The string is then terminated
- * with a null byte.
- *
- * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'
- * terminates the string for Windows text files which use CRLF for newline.
- *
- * \param[out] str Pointer to the array where the string is stored.
- * \param[in] num Maximum number of characters to be read
- * (including the final null byte). Usually the length
- * of the array \a str is used.
- * \param[in] delim Optional set of delimiters. The default is "\n".
- *
- * \return For success fgets() returns the length of the string in \a str.
- * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
- **/
-int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
-  char ch;
-  int16_t n = 0;
-  int16_t r = -1;
-  while ((n + 1) < num && (r = read(&ch, 1)) == 1) {
-    // delete CR
-    if (ch == '\r') continue;
-    str[n++] = ch;
-    if (!delim) {
-      if (ch == '\n') break;
-    } else {
-      if (strchr(delim, ch)) break;
-    }
-  }
-  if (r < 0) {
-    // read error
-    return -1;
-  }
-  str[n] = '\0';
-  return n;
-}
-//------------------------------------------------------------------------------
-/** Get a file's name
- *
- * \param[out] name An array of 13 characters for the file's name.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::getFilename(char* name) {
-  if (!isOpen()) return false;
-
-  if (isRoot()) {
-    name[0] = '/';
-    name[1] = '\0';
-    return true;
-  }
-  // cache entry
-  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
-  if (!p) return false;
-
-  // format name
-  dirName(*p, name);
-  return true;
-}
-//------------------------------------------------------------------------------
-void SdBaseFile::getpos(fpos_t* pos) {
-  pos->position = curPosition_;
-  pos->cluster = curCluster_;
-}
-
-//------------------------------------------------------------------------------
-/** List directory contents.
- *
- * \param[in] pr Print stream for list.
- *
- * \param[in] flags The inclusive OR of
- *
- * LS_DATE - %Print file modification date
- *
- * LS_SIZE - %Print file size.
- *
- * LS_R - Recursive list of subdirectories.
- *
- * \param[in] indent Amount of space before file name. Used for recursive
- * list to indicate subdirectory level.
- */
-void SdBaseFile::ls(Print *p, uint8_t flags, uint8_t indent) {
-  rewind();
-  int8_t status;
-  while ((status = lsPrintNext( p, flags, indent))) {
-    if (status > 1 && (flags & LS_R)) {
-      uint16_t index = curPosition()/32 - 1;
-      SdBaseFile s;
-      if (s.open(this, index, O_READ)) s.ls( p, flags, indent + 2);
-      seekSet(32 * (index + 1));
-    }
-  }
-}
-//------------------------------------------------------------------------------
-// saves 32 bytes on stack for ls recursion
-// return 0 - EOF, 1 - normal file, or 2 - directory
-int8_t SdBaseFile::lsPrintNext( Print *p, uint8_t flags, uint8_t indent) {
-	Print &MYSERIAL = *p;
-  dir_t dir;
-  uint8_t w = 0;
-
-  while (1) {
-    if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;
-    if (dir.name[0] == DIR_NAME_FREE) return 0;
-
-    // skip deleted entry and entries for . and  ..
-    if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'
-      && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
-  }
-  // indent for dir level
-  for (uint8_t i = 0; i < indent; i++) MYSERIAL.write(' ');
-
-  // print name
-  for (uint8_t i = 0; i < 11; i++) {
-    if (dir.name[i] == ' ')continue;
-    if (i == 8) {
-      MYSERIAL.write('.');
-      w++;
-    }
-    MYSERIAL.write(dir.name[i]);
-    w++;
-  }
-  if (DIR_IS_SUBDIR(&dir)) {
-    MYSERIAL.write('/');
-    w++;
-  }
-  if (flags & (LS_DATE | LS_SIZE)) {
-    while (w++ < 14) MYSERIAL.write(' ');
-  }
-  // print modify date/time if requested
-  if (flags & LS_DATE) {
-    MYSERIAL.write(' ');
-    printFatDate( p, dir.lastWriteDate);
-    MYSERIAL.write(' ');
-    printFatTime( p, dir.lastWriteTime);
-  }
-  // print size if requested
-  if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {
-    MYSERIAL.write(' ');
-    MYSERIAL.print(dir.fileSize);
-  }
-  MYSERIAL.println();
-  return DIR_IS_FILE(&dir) ? 1 : 2;
-}
-//------------------------------------------------------------------------------
-// format directory name field from a 8.3 name string
-bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
-  uint8_t c;
-  uint8_t n = 7;  // max index for part before dot
-  uint8_t i = 0;
-  // blank fill name and extension
-  while (i < 11) name[i++] = ' ';
-  i = 0;
-  while (*str != '\0' && *str != '/') {
-    c = *str++;
-    if (c == '.') {
-      if (n == 10) goto fail;  // only one dot allowed
-      n = 10;  // max index for full 8.3 name
-      i = 8;   // place for extension
-    } else {
-      // illegal FAT characters
-      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
-      uint8_t b;
-      while ((b = pgm_read_byte(p++))) if (b == c) goto fail;
-      // check size and only allow ASCII printable characters
-      if (i > n || c < 0X21 || c > 0X7E)goto fail;
-      // only upper case allowed in 8.3 names - convert lower to upper
-      name[i++] = (c < 'a' || c > 'z') ?  (c) : (c + ('A' - 'a'));
-    }
-  }
-  *ptr = str;
-  // must have a file name, extension is optional
-  return name[0] != ' ';
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Make a new directory.
- *
- * \param[in] parent An open SdFat instance for the directory that will contain
- * the new directory.
- *
- * \param[in] path A path with a valid 8.3 DOS name for the new directory.
- *
- * \param[in] pFlag Create missing parent directories if true.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include this file is already open, \a parent is not a
- * directory, \a path is invalid or already exists in \a parent.
- */
-bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
-  uint8_t dname[11];
-  SdBaseFile dir1, dir2;
-  SdBaseFile* sub = &dir1;
-  SdBaseFile* start = parent;
-
-  if (!parent || isOpen()) goto fail;
-
-  if (*path == '/') {
-    while (*path == '/') path++;
-    if (!parent->isRoot()) {
-      if (!dir2.openRoot(parent->vol_)) goto fail;
-      parent = &dir2;
-    }
-  }
-  while (1) {
-    if (!make83Name(path, dname, &path)) goto fail;
-    while (*path == '/') path++;
-    if (!*path) break;
-    if (!sub->open(parent, dname, O_READ)) {
-      if (!pFlag || !sub->mkdir(parent, dname)) {
-        goto fail;
-      }
-    }
-    if (parent != start) parent->close();
-    parent = sub;
-    sub = parent != &dir1 ? &dir1 : &dir2;
-  }
-  return mkdir(parent, dname);
-
-  fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
-  uint32_t block;
-  dir_t d;
-  dir_t* p;
-
-  if (!parent->isDir()) goto fail;
-
-  // create a normal file
-  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto fail;
-
-  // convert file to directory
-  flags_ = O_READ;
-  type_ = FAT_FILE_TYPE_SUBDIR;
-
-  // allocate and zero first cluster
-  if (!addDirCluster())goto fail;
-
-  // force entry to SD
-  if (!sync()) goto fail;
-
-  // cache entry - should already be in cache due to sync() call
-  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!p) goto fail;
-
-  // change directory entry  attribute
-  p->attributes = DIR_ATT_DIRECTORY;
-
-  // make entry for '.'
-  memcpy(&d, p, sizeof(d));
-  d.name[0] = '.';
-  for (uint8_t i = 1; i < 11; i++) d.name[i] = ' ';
-
-  // cache block for '.'  and '..'
-  block = vol_->clusterStartBlock(firstCluster_);
-  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
-
-  // copy '.' to block
-  memcpy(&vol_->cache()->dir[0], &d, sizeof(d));
-
-  // make entry for '..'
-  d.name[1] = '.';
-  if (parent->isRoot()) {
-    d.firstClusterLow = 0;
-    d.firstClusterHigh = 0;
-  } else {
-    d.firstClusterLow = parent->firstCluster_ & 0XFFFF;
-    d.firstClusterHigh = parent->firstCluster_ >> 16;
-  }
-  // copy '..' to block
-  memcpy(&vol_->cache()->dir[1], &d, sizeof(d));
-
-  // write first block
-  return vol_->cacheFlush();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
- /** Open a file in the current working directory.
-  *
-  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
-  *
-  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
-  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
-  *
-  * \return The value one, true, is returned for success and
-  * the value zero, false, is returned for failure.
-  */
-  bool SdBaseFile::open(const char* path, uint8_t oflag) {
-    return open(cwd_, path, oflag);
-  }
-//------------------------------------------------------------------------------
-/** Open a file or directory by name.
- *
- * \param[in] dirFile An open SdFat instance for the directory containing the
- * file to be opened.
- *
- * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
- *
- * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
- * OR of flags from the following list
- *
- * O_READ - Open for reading.
- *
- * O_RDONLY - Same as O_READ.
- *
- * O_WRITE - Open for writing.
- *
- * O_WRONLY - Same as O_WRITE.
- *
- * O_RDWR - Open for reading and writing.
- *
- * O_APPEND - If set, the file offset shall be set to the end of the
- * file prior to each write.
- *
- * O_AT_END - Set the initial position at the end of the file.
- *
- * O_CREAT - If the file exists, this flag has no effect except as noted
- * under O_EXCL below. Otherwise, the file shall be created
- *
- * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
- *
- * O_SYNC - Call sync() after each write.  This flag should not be used with
- * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.
- * These functions do character at a time writes so sync() will be called
- * after each byte.
- *
- * O_TRUNC - If the file exists and is a regular file, and the file is
- * successfully opened and is not read only, its length shall be truncated to 0.
- *
- * WARNING: A given file must not be opened by more than one SdBaseFile object
- * of file corruption may occur.
- *
- * \note Directory files must be opened read only.  Write and truncation is
- * not allowed for directory files.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include this file is already open, \a dirFile is not
- * a directory, \a path is invalid, the file does not exist
- * or can't be opened in the access mode specified by oflag.
- */
-bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
-  uint8_t dname[11];
-  SdBaseFile dir1, dir2;
-  SdBaseFile *parent = dirFile;
-  SdBaseFile *sub = &dir1;
-
-  if (!dirFile) goto fail;
-
-  // error if already open
-  if (isOpen()) goto fail;
-
-  if (*path == '/') {
-    while (*path == '/') path++;
-    if (!dirFile->isRoot()) {
-      if (!dir2.openRoot(dirFile->vol_)) goto fail;
-      parent = &dir2;
-    }
-  }
-  while (1) {
-    if (!make83Name(path, dname, &path)) goto fail;
-    while (*path == '/') path++;
-    if (!*path) break;
-    if (!sub->open(parent, dname, O_READ)) goto fail;
-    if (parent != dirFile) parent->close();
-    parent = sub;
-    sub = parent != &dir1 ? &dir1 : &dir2;
-  }
-  return open(parent, dname, oflag);
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// open with filename in dname
-bool SdBaseFile::open(SdBaseFile* dirFile,
-  const uint8_t dname[11], uint8_t oflag) {
-  bool emptyFound = false;
-  bool fileFound = false;
-  uint8_t index;
-  dir_t* p;
-
-  vol_ = dirFile->vol_;
-
-  dirFile->rewind();
-  // search for file
-
-  while (dirFile->curPosition_ < dirFile->fileSize_) {
-    index = 0XF & (dirFile->curPosition_ >> 5);
-    p = dirFile->readDirCache();
-    if (!p) goto fail;
-
-    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
-      // remember first empty slot
-      if (!emptyFound) {
-        dirBlock_ = dirFile->vol_->cacheBlockNumber();
-        dirIndex_ = index;
-        emptyFound = true;
-      }
-      // done if no entries follow
-      if (p->name[0] == DIR_NAME_FREE) break;
-    } else if (!memcmp(dname, p->name, 11)) {
-      fileFound = true;
-      break;
-    }
-  }
-  if (fileFound) {
-    // don't open existing file if O_EXCL
-    if (oflag & O_EXCL) goto fail;
-  } else {
-    // don't create unless O_CREAT and O_WRITE
-    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto fail;
-    if (emptyFound) {
-      index = dirIndex_;
-      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-      if (!p) goto fail;
-    } else {
-      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) goto fail;
-
-      // add and zero cluster for dirFile - first cluster is in cache for write
-      if (!dirFile->addDirCluster()) goto fail;
-
-      // use first entry in cluster
-      p = dirFile->vol_->cache()->dir;
-      index = 0;
-    }
-    // initialize as empty file
-    memset(p, 0, sizeof(dir_t));
-    memcpy(p->name, dname, 11);
-
-    // set timestamps
-    if (dateTime_) {
-      // call user date/time function
-      dateTime_(&p->creationDate, &p->creationTime);
-    } else {
-      // use default date/time
-      p->creationDate = FAT_DEFAULT_DATE;
-      p->creationTime = FAT_DEFAULT_TIME;
-    }
-    p->lastAccessDate = p->creationDate;
-    p->lastWriteDate = p->creationDate;
-    p->lastWriteTime = p->creationTime;
-
-    // write entry to SD
-    if (!dirFile->vol_->cacheFlush()) goto fail;
-  }
-  // open entry in cache
-  return openCachedEntry(index, oflag);
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Open a file by index.
- *
- * \param[in] dirFile An open SdFat instance for the directory.
- *
- * \param[in] index The \a index of the directory entry for the file to be
- * opened.  The value for \a index is (directory file position)/32.
- *
- * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
- * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
- *
- * See open() by path for definition of flags.
- * \return true for success or false for failure.
- */
-bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
-  dir_t* p;
-
-  vol_ = dirFile->vol_;
-
-  // error if already open
-  if (isOpen() || !dirFile) goto fail;
-
-  // don't open existing file if O_EXCL - user call error
-  if (oflag & O_EXCL) goto fail;
-
-  // seek to location of entry
-  if (!dirFile->seekSet(32 * index)) goto fail;
-
-  // read entry into cache
-  p = dirFile->readDirCache();
-  if (!p) goto fail;
-
-  // error if empty slot or '.' or '..'
-  if (p->name[0] == DIR_NAME_FREE ||
-      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
-    goto fail;
-  }
-  // open cached entry
-  return openCachedEntry(index & 0XF, oflag);
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// open a cached directory entry. Assumes vol_ is initialized
-bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
-  // location of entry in cache
-  dir_t* p = &vol_->cache()->dir[dirIndex];
-
-  // write or truncate is an error for a directory or read-only file
-  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
-    if (oflag & (O_WRITE | O_TRUNC)) goto fail;
-  }
-  // remember location of directory entry on SD
-  dirBlock_ = vol_->cacheBlockNumber();
-  dirIndex_ = dirIndex;
-
-  // copy first cluster number for directory fields
-  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
-  firstCluster_ |= p->firstClusterLow;
-
-  // make sure it is a normal file or subdirectory
-  if (DIR_IS_FILE(p)) {
-    fileSize_ = p->fileSize;
-    type_ = FAT_FILE_TYPE_NORMAL;
-  } else if (DIR_IS_SUBDIR(p)) {
-    if (!vol_->chainSize(firstCluster_, &fileSize_)) goto fail;
-    type_ = FAT_FILE_TYPE_SUBDIR;
-  } else {
-    goto fail;
-  }
-  // save open flags for read/write
-  flags_ = oflag & F_OFLAG;
-
-  // set to start of file
-  curCluster_ = 0;
-  curPosition_ = 0;
-  if ((oflag & O_TRUNC) && !truncate(0)) return false;
-  return oflag & O_AT_END ? seekEnd(0) : true;
-
- fail:
-  type_ = FAT_FILE_TYPE_CLOSED;
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Open the next file or subdirectory in a directory.
- *
- * \param[in] dirFile An open SdFat instance for the directory containing the
- * file to be opened.
- *
- * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
- * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
- *
- * See open() by path for definition of flags.
- * \return true for success or false for failure.
- */
-bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
-  dir_t* p;
-  uint8_t index;
-
-  if (!dirFile) goto fail;
-
-  // error if already open
-  if (isOpen()) goto fail;
-
-  vol_ = dirFile->vol_;
-
-  while (1) {
-    index = 0XF & (dirFile->curPosition_ >> 5);
-
-    // read entry into cache
-    p = dirFile->readDirCache();
-    if (!p) goto fail;
-
-    // done if last entry
-    if (p->name[0] == DIR_NAME_FREE) goto fail;
-
-    // skip empty slot or '.' or '..'
-    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
-      continue;
-    }
-    // must be file or dir
-    if (DIR_IS_FILE_OR_SUBDIR(p)) {
-      return openCachedEntry(index, oflag);
-    }
-  }
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Open a directory's parent directory.
- *
- * \param[in] dir Parent of this directory will be opened.  Must not be root.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::openParent(SdBaseFile* dir) {
-  dir_t entry;
-  dir_t* p;
-  SdBaseFile file;
-  uint32_t c;
-  uint32_t cluster;
-  uint32_t lbn;
-  // error if already open or dir is root or dir is not a directory
-  if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) goto fail;
-  vol_ = dir->vol_;
-  // position to '..'
-  if (!dir->seekSet(32)) goto fail;
-  // read '..' entry
-  if (dir->read(&entry, sizeof(entry)) != 32) goto fail;
-  // verify it is '..'
-  if (entry.name[0] != '.' || entry.name[1] != '.') goto fail;
-  // start cluster for '..'
-  cluster = entry.firstClusterLow;
-  cluster |= (uint32_t)entry.firstClusterHigh << 16;
-  if (cluster == 0) return openRoot(vol_);
-  // start block for '..'
-  lbn = vol_->clusterStartBlock(cluster);
-  // first block of parent dir
-  if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {
-    goto fail;
-  }
-  p = &vol_->cacheBuffer_.dir[1];
-  // verify name for '../..'
-  if (p->name[0] != '.' || p->name[1] != '.') goto fail;
-  // '..' is pointer to first cluster of parent. open '../..' to find parent
-  if (p->firstClusterHigh == 0 && p->firstClusterLow == 0) {
-    if (!file.openRoot(dir->volume())) goto fail;
-  } else {
-    if (!file.openCachedEntry(1, O_READ)) goto fail;
-  }
-  // search for parent in '../..'
-  do {
-    if (file.readDir(&entry, NULL) != 32) goto fail;
-    c = entry.firstClusterLow;
-    c |= (uint32_t)entry.firstClusterHigh << 16;
-  } while (c != cluster);
-  // open parent
-  return open(&file, file.curPosition()/32 - 1, O_READ);
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Open a volume's root directory.
- *
- * \param[in] vol The FAT volume containing the root directory to be opened.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include the file is already open, the FAT volume has
- * not been initialized or it a FAT12 volume.
- */
-bool SdBaseFile::openRoot(SdVolume* vol) {
-  // error if file is already open
-  if (isOpen()) goto fail;
-
-  if (vol->fatType() == 16 || (FAT12_SUPPORT && vol->fatType() == 12)) {
-    type_ = FAT_FILE_TYPE_ROOT_FIXED;
-    firstCluster_ = 0;
-    fileSize_ = 32 * vol->rootDirEntryCount();
-  } else if (vol->fatType() == 32) {
-    type_ = FAT_FILE_TYPE_ROOT32;
-    firstCluster_ = vol->rootDirStart();
-    if (!vol->chainSize(firstCluster_, &fileSize_)) goto fail;
-  } else {
-    // volume is not initialized, invalid, or FAT12 without support
-    return false;
-  }
-  vol_ = vol;
-  // read only
-  flags_ = O_READ;
-
-  // set to start of file
-  curCluster_ = 0;
-  curPosition_ = 0;
-
-  // root has no directory entry
-  dirBlock_ = 0;
-  dirIndex_ = 0;
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Return the next available byte without consuming it.
- *
- * \return The byte if no error and not at eof else -1;
- */
-int SdBaseFile::peek() {
-  fpos_t pos;
-  getpos(&pos);
-  int c = read();
-  if (c >= 0) setpos(&pos);
-  return c;
-}
-
-//------------------------------------------------------------------------------
-/** %Print the name field of a directory entry in 8.3 format.
- * \param[in] pr Print stream for output.
- * \param[in] dir The directory structure containing the name.
- * \param[in] width Blank fill name if length is less than \a width.
- * \param[in] printSlash Print '/' after directory names if true.
- */
-void SdBaseFile::printDirName(Print *p, const dir_t& dir, uint8_t width, bool printSlash) {
-		Print &MYSERIAL = *p;
-  uint8_t w = 0;
-  for (uint8_t i = 0; i < 11; i++) {
-    if (dir.name[i] == ' ')continue;
-    if (i == 8) {
-      MYSERIAL.write('.');
-      w++;
-    }
-    MYSERIAL.write(dir.name[i]);
-    w++;
-  }
-  if (DIR_IS_SUBDIR(&dir) && printSlash) {
-    MYSERIAL.write('/');
-    w++;
-  }
-  while (w < width) {
-    MYSERIAL.write(' ');
-    w++;
-  }
-}
-//------------------------------------------------------------------------------
-// print uint8_t with width 2
-static void print2u( Print *p, uint8_t v) {
-	Print &MYSERIAL = *p;
-  if (v < 10) MYSERIAL.write('0');
-  MYSERIAL.print(v, DEC);
-}
-//------------------------------------------------------------------------------
-/** %Print a directory date field to Serial.
- *
- *  Format is yyyy-mm-dd.
- *
- * \param[in] fatDate The date field from a directory entry.
- */
-
-//------------------------------------------------------------------------------
-/** %Print a directory date field.
- *
- *  Format is yyyy-mm-dd.
- *
- * \param[in] pr Print stream for output.
- * \param[in] fatDate The date field from a directory entry.
- */
-void SdBaseFile::printFatDate(Print *p, uint16_t fatDate) {
-	Print &MYSERIAL = *p;
-
-  MYSERIAL.print(FAT_YEAR(fatDate));
-  MYSERIAL.write('-');
-  print2u( p, FAT_MONTH(fatDate));
-  MYSERIAL.write('-');
-  print2u( p, FAT_DAY(fatDate));
-}
-
-//------------------------------------------------------------------------------
-/** %Print a directory time field.
- *
- * Format is hh:mm:ss.
- *
- * \param[in] pr Print stream for output.
- * \param[in] fatTime The time field from a directory entry.
- */
-void SdBaseFile::printFatTime( Print *p, uint16_t fatTime) {
-	Print &MYSERIAL = *p;
-
-  print2u( p, FAT_HOUR(fatTime));
-  MYSERIAL.write(':');
-  print2u( p, FAT_MINUTE(fatTime));
-  MYSERIAL.write(':');
-  print2u( p, FAT_SECOND(fatTime));
-}
-//------------------------------------------------------------------------------
-/** Print a file's name to Serial
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::printName(Print *p) {
-	Print &MYSERIAL = *p;
-  char name[13];
-  if (!getFilename(name)) return false;
-  MYSERIAL.print(name);
-  return true;
-}
-//------------------------------------------------------------------------------
-/** Read the next byte from a file.
- *
- * \return For success read returns the next byte in the file as an int.
- * If an error occurs or end of file is reached -1 is returned.
- */
-int16_t SdBaseFile::read() {
-  uint8_t b;
-  return read(&b, 1) == 1 ? b : -1;
-}
-//------------------------------------------------------------------------------
-/** Read data from a file starting at the current position.
- *
- * \param[out] buf Pointer to the location that will receive the data.
- *
- * \param[in] nbyte Maximum number of bytes to read.
- *
- * \return For success read() returns the number of bytes read.
- * A value less than \a nbyte, including zero, will be returned
- * if end of file is reached.
- * If an error occurs, read() returns -1.  Possible errors include
- * read() called before a file has been opened, corrupt file system
- * or an I/O error occurred.
- */
-int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
-  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
-  uint16_t offset;
-  uint16_t toRead;
-  uint32_t block;  // raw device block number
-
-  // error if not open or write only
-  if (!isOpen() || !(flags_ & O_READ)) goto fail;
-
-  // max bytes left in file
-  if (nbyte >= (fileSize_ - curPosition_)) {
-    nbyte = fileSize_ - curPosition_;
-  }
-  // amount left to read
-  toRead = nbyte;
-  while (toRead > 0) {
-    offset = curPosition_ & 0X1FF;  // offset in block
-    if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
-      block = vol_->rootDirStart() + (curPosition_ >> 9);
-    } else {
-      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
-      if (offset == 0 && blockOfCluster == 0) {
-        // start of new cluster
-        if (curPosition_ == 0) {
-          // use first cluster in file
-          curCluster_ = firstCluster_;
-        } else {
-          // get next cluster from FAT
-          if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
-        }
-      }
-      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
-    }
-    uint16_t n = toRead;
-
-    // amount to be read from current block
-    if (n > (512 - offset)) n = 512 - offset;
-
-    // no buffering needed if n == 512
-    if (n == 512 && block != vol_->cacheBlockNumber()) {
-      if (!vol_->readBlock(block, dst)) goto fail;
-    } else {
-      // read block to cache and copy data to caller
-      if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
-      uint8_t* src = vol_->cache()->data + offset;
-      memcpy(dst, src, n);
-    }
-    dst += n;
-    curPosition_ += n;
-    toRead -= n;
-  }
-  return nbyte;
-
- fail:
-  return -1;
-}
-//------------------------------------------------------------------------------
-/** Read the next directory entry from a directory file.
- *
- * \param[out] dir The dir_t struct that will receive the data.
- *
- * \return For success readDir() returns the number of bytes read.
- * A value of zero will be returned if end of file is reached.
- * If an error occurs, readDir() returns -1.  Possible errors include
- * readDir() called before a directory has been opened, this is not
- * a directory file or an I/O error occurred.
- */
-int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
-  int16_t n;
-  // if not a directory file or miss-positioned return an error
-  if (!isDir() || (0X1F & curPosition_)) return -1;
-  
-  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.
-  if (longFilename != NULL)
-  {
-  	longFilename[0] = '\0';
-  }
-
-  while (1) {
-    n = read(dir, sizeof(dir_t));
-    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;
-    // last entry if DIR_NAME_FREE
-    if (dir->name[0] == DIR_NAME_FREE) return 0;
-    // skip empty entries and entry for .  and ..
-    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') continue;
-    //Fill the long filename if we have a long filename entry,
-	// long filename entries are stored before the actual filename.
-	if (DIR_IS_LONG_NAME(dir) && longFilename != NULL)
-    {
-    	vfat_t *VFAT = (vfat_t*)dir;
-		//Sanity check the VFAT entry. The first cluster is always set to zero. And th esequence number should be higher then 0
-    	if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES)
-    	{
-			//TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
-    		n = ((VFAT->sequenceNumber & 0x1F) - 1) * 13;
-			longFilename[n+0] = VFAT->name1[0];
-			longFilename[n+1] = VFAT->name1[1];
-			longFilename[n+2] = VFAT->name1[2];
-			longFilename[n+3] = VFAT->name1[3];
-			longFilename[n+4] = VFAT->name1[4];
-			longFilename[n+5] = VFAT->name2[0];
-			longFilename[n+6] = VFAT->name2[1];
-			longFilename[n+7] = VFAT->name2[2];
-			longFilename[n+8] = VFAT->name2[3];
-			longFilename[n+9] = VFAT->name2[4];
-			longFilename[n+10] = VFAT->name2[5];
-			longFilename[n+11] = VFAT->name3[0];
-			longFilename[n+12] = VFAT->name3[1];
-			//If this VFAT entry is the last one, add a NUL terminator at the end of the string
-			if (VFAT->sequenceNumber & 0x40)
-				longFilename[n+13] = '\0';
-		}
-    }
-    // return if normal file or subdirectory
-    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;
-  }
-}
-//------------------------------------------------------------------------------
-// Read next directory entry into the cache
-// Assumes file is correctly positioned
-dir_t* SdBaseFile::readDirCache() {
-  uint8_t i;
-  // error if not directory
-  if (!isDir()) goto fail;
-
-  // index of entry in cache
-  i = (curPosition_ >> 5) & 0XF;
-
-  // use read to locate and cache block
-  if (read() < 0) goto fail;
-
-  // advance to next entry
-  curPosition_ += 31;
-
-  // return pointer to entry
-  return vol_->cache()->dir + i;
-
- fail:
-  return 0;
-}
-//------------------------------------------------------------------------------
-/** Remove a file.
- *
- * The directory entry and all data for the file are deleted.
- *
- * \note This function should not be used to delete the 8.3 version of a
- * file that has a long name. For example if a file has the long name
- * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include the file read-only, is a directory,
- * or an I/O error occurred.
- */
-bool SdBaseFile::remove() {
-  dir_t* d;
-  // free any clusters - will fail if read-only or directory
-  if (!truncate(0)) goto fail;
-
-  // cache directory entry
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-
-  // mark entry deleted
-  d->name[0] = DIR_NAME_DELETED;
-
-  // set this file closed
-  type_ = FAT_FILE_TYPE_CLOSED;
-
-  // write entry to SD
-  return vol_->cacheFlush();
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Remove a file.
- *
- * The directory entry and all data for the file are deleted.
- *
- * \param[in] dirFile The directory that contains the file.
- * \param[in] path Path for the file to be removed.
- *
- * \note This function should not be used to delete the 8.3 version of a
- * file that has a long name. For example if a file has the long name
- * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include the file is a directory, is read only,
- * \a dirFile is not a directory, \a path is not found
- * or an I/O error occurred.
- */
-bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
-  SdBaseFile file;
-  if (!file.open(dirFile, path, O_WRITE)) goto fail;
-  return file.remove();
-
- fail:
-  // can't set iostate - static function
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Rename a file or subdirectory.
- *
- * \param[in] dirFile Directory for the new path.
- * \param[in] newPath New path name for the file/directory.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include \a dirFile is not open or is not a directory
- * file, newPath is invalid or already exists, or an I/O error occurs.
- */
-bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
-  dir_t entry;
-  uint32_t dirCluster = 0;
-  SdBaseFile file;
-  dir_t* d;
-
-  // must be an open file or subdirectory
-  if (!(isFile() || isSubDir())) goto fail;
-
-  // can't move file
-  if (vol_ != dirFile->vol_) goto fail;
-
-  // sync() and cache directory entry
-  sync();
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-
-  // save directory entry
-  memcpy(&entry, d, sizeof(entry));
-
-  // mark entry deleted
-  d->name[0] = DIR_NAME_DELETED;
-
-  // make directory entry for new path
-  if (isFile()) {
-    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {
-      goto restore;
-    }
-  } else {
-    // don't create missing path prefix components
-    if (!file.mkdir(dirFile, newPath, false)) {
-      goto restore;
-    }
-    // save cluster containing new dot dot
-    dirCluster = file.firstCluster_;
-  }
-  // change to new directory entry
-  dirBlock_ = file.dirBlock_;
-  dirIndex_ = file.dirIndex_;
-
-  // mark closed to avoid possible destructor close call
-  file.type_ = FAT_FILE_TYPE_CLOSED;
-
-  // cache new directory entry
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-
-  // copy all but name field to new directory entry
-  memcpy(&d->attributes, &entry.attributes, sizeof(entry) - sizeof(d->name));
-
-  // update dot dot if directory
-  if (dirCluster) {
-    // get new dot dot
-    uint32_t block = vol_->clusterStartBlock(dirCluster);
-    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
-    memcpy(&entry, &vol_->cache()->dir[1], sizeof(entry));
-
-    // free unused cluster
-    if (!vol_->freeChain(dirCluster)) goto fail;
-
-    // store new dot dot
-    block = vol_->clusterStartBlock(firstCluster_);
-    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
-    memcpy(&vol_->cache()->dir[1], &entry, sizeof(entry));
-  }
-  return vol_->cacheFlush();
-
- restore:
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-  // restore entry
-  d->name[0] = entry.name[0];
-  vol_->cacheFlush();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Remove a directory file.
- *
- * The directory file will be removed only if it is empty and is not the
- * root directory.  rmdir() follows DOS and Windows and ignores the
- * read-only attribute for the directory.
- *
- * \note This function should not be used to delete the 8.3 version of a
- * directory that has a long name. For example if a directory has the
- * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include the file is not a directory, is the root
- * directory, is not empty, or an I/O error occurred.
- */
-bool SdBaseFile::rmdir() {
-  // must be open subdirectory
-  if (!isSubDir()) goto fail;
-
-  rewind();
-
-  // make sure directory is empty
-  while (curPosition_ < fileSize_) {
-    dir_t* p = readDirCache();
-    if (!p) goto fail;
-    // done if past last used entry
-    if (p->name[0] == DIR_NAME_FREE) break;
-    // skip empty slot, '.' or '..'
-    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
-    // error not empty
-    if (DIR_IS_FILE_OR_SUBDIR(p)) goto fail;
-  }
-  // convert empty directory to normal file for remove
-  type_ = FAT_FILE_TYPE_NORMAL;
-  flags_ |= O_WRITE;
-  return remove();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Recursively delete a directory and all contained files.
- *
- * This is like the Unix/Linux 'rm -rf *' if called with the root directory
- * hence the name.
- *
- * Warning - This will remove all contents of the directory including
- * subdirectories.  The directory will then be removed if it is not root.
- * The read-only attribute for files will be ignored.
- *
- * \note This function should not be used to delete the 8.3 version of
- * a directory that has a long name.  See remove() and rmdir().
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::rmRfStar() {
-  uint16_t index;
-  SdBaseFile f;
-  rewind();
-  while (curPosition_ < fileSize_) {
-    // remember position
-    index = curPosition_/32;
-
-    dir_t* p = readDirCache();
-    if (!p) goto fail;
-
-    // done if past last entry
-    if (p->name[0] == DIR_NAME_FREE) break;
-
-    // skip empty slot or '.' or '..'
-    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
-
-    // skip if part of long file name or volume label in root
-    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
-
-    if (!f.open(this, index, O_READ)) goto fail;
-    if (f.isSubDir()) {
-      // recursively delete
-      if (!f.rmRfStar()) goto fail;
-    } else {
-      // ignore read-only
-      f.flags_ |= O_WRITE;
-      if (!f.remove()) goto fail;
-    }
-    // position to next entry if required
-    if (curPosition_ != (32*(index + 1))) {
-      if (!seekSet(32*(index + 1))) goto fail;
-    }
-  }
-  // don't try to delete root
-  if (!isRoot()) {
-    if (!rmdir()) goto fail;
-  }
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/**  Create a file object and open it in the current working directory.
- *
- * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
- *
- * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
- * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
- */
-SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
-  type_ = FAT_FILE_TYPE_CLOSED;
-  writeError = false;
-  open(path, oflag);
-}
-//------------------------------------------------------------------------------
-/** Sets a file's position.
- *
- * \param[in] pos The new position in bytes from the beginning of the file.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::seekSet(uint32_t pos) {
-  uint32_t nCur;
-  uint32_t nNew;
-  // error if file not open or seek past end of file
-  if (!isOpen() || pos > fileSize_) goto fail;
-
-  if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
-    curPosition_ = pos;
-    goto done;
-  }
-  if (pos == 0) {
-    // set position to start of file
-    curCluster_ = 0;
-    curPosition_ = 0;
-    goto done;
-  }
-  // calculate cluster index for cur and new position
-  nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
-  nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
-
-  if (nNew < nCur || curPosition_ == 0) {
-    // must follow chain from first cluster
-    curCluster_ = firstCluster_;
-  } else {
-    // advance from curPosition
-    nNew -= nCur;
-  }
-  while (nNew--) {
-    if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
-  }
-  curPosition_ = pos;
-
- done:
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-void SdBaseFile::setpos(fpos_t* pos) {
-  curPosition_ = pos->position;
-  curCluster_ = pos->cluster;
-}
-//------------------------------------------------------------------------------
-/** The sync() call causes all modified data and directory fields
- * to be written to the storage device.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include a call to sync() before a file has been
- * opened or an I/O error.
- */
-bool SdBaseFile::sync() {
-  // only allow open files and directories
-  if (!isOpen()) goto fail;
-
-  if (flags_ & F_FILE_DIR_DIRTY) {
-    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-    // check for deleted by another open file object
-    if (!d || d->name[0] == DIR_NAME_DELETED) goto fail;
-
-    // do not set filesize for dir files
-    if (!isDir()) d->fileSize = fileSize_;
-
-    // update first cluster fields
-    d->firstClusterLow = firstCluster_ & 0XFFFF;
-    d->firstClusterHigh = firstCluster_ >> 16;
-
-    // set modify time if user supplied a callback date/time function
-    if (dateTime_) {
-      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
-      d->lastAccessDate = d->lastWriteDate;
-    }
-    // clear directory dirty
-    flags_ &= ~F_FILE_DIR_DIRTY;
-  }
-  return vol_->cacheFlush();
-
- fail:
-  writeError = true;
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Copy a file's timestamps
- *
- * \param[in] file File to copy timestamps from.
- *
- * \note
- * Modify and access timestamps may be overwritten if a date time callback
- * function has been set by dateTimeCallback().
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::timestamp(SdBaseFile* file) {
-  dir_t* d;
-  dir_t dir;
-
-  // get timestamps
-  if (!file->dirEntry(&dir)) goto fail;
-
-  // update directory fields
-  if (!sync()) goto fail;
-
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-
-  // copy timestamps
-  d->lastAccessDate = dir.lastAccessDate;
-  d->creationDate = dir.creationDate;
-  d->creationTime = dir.creationTime;
-  d->creationTimeTenths = dir.creationTimeTenths;
-  d->lastWriteDate = dir.lastWriteDate;
-  d->lastWriteTime = dir.lastWriteTime;
-
-  // write back entry
-  return vol_->cacheFlush();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Set a file's timestamps in its directory entry.
- *
- * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive
- * OR of flags from the following list
- *
- * T_ACCESS - Set the file's last access date.
- *
- * T_CREATE - Set the file's creation date and time.
- *
- * T_WRITE - Set the file's last write/modification date and time.
- *
- * \param[in] year Valid range 1980 - 2107 inclusive.
- *
- * \param[in] month Valid range 1 - 12 inclusive.
- *
- * \param[in] day Valid range 1 - 31 inclusive.
- *
- * \param[in] hour Valid range 0 - 23 inclusive.
- *
- * \param[in] minute Valid range 0 - 59 inclusive.
- *
- * \param[in] second Valid range 0 - 59 inclusive
- *
- * \note It is possible to set an invalid date since there is no check for
- * the number of days in a month.
- *
- * \note
- * Modify and access timestamps may be overwritten if a date time callback
- * function has been set by dateTimeCallback().
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- */
-bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
-         uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
-  uint16_t dirDate;
-  uint16_t dirTime;
-  dir_t* d;
-
-  if (!isOpen()
-    || year < 1980
-    || year > 2107
-    || month < 1
-    || month > 12
-    || day < 1
-    || day > 31
-    || hour > 23
-    || minute > 59
-    || second > 59) {
-      goto fail;
-  }
-  // update directory entry
-  if (!sync()) goto fail;
-
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto fail;
-
-  dirDate = FAT_DATE(year, month, day);
-  dirTime = FAT_TIME(hour, minute, second);
-  if (flags & T_ACCESS) {
-    d->lastAccessDate = dirDate;
-  }
-  if (flags & T_CREATE) {
-    d->creationDate = dirDate;
-    d->creationTime = dirTime;
-    // seems to be units of 1/100 second not 1/10 as Microsoft states
-    d->creationTimeTenths = second & 1 ? 100 : 0;
-  }
-  if (flags & T_WRITE) {
-    d->lastWriteDate = dirDate;
-    d->lastWriteTime = dirTime;
-  }
-  return vol_->cacheFlush();
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Truncate a file to a specified length.  The current file position
- * will be maintained if it is less than or equal to \a length otherwise
- * it will be set to end of file.
- *
- * \param[in] length The desired length for the file.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
- * Reasons for failure include file is read only, file is a directory,
- * \a length is greater than the current file size or an I/O error occurs.
- */
-bool SdBaseFile::truncate(uint32_t length) {
-  uint32_t newPos;
-  // error if not a normal file or read-only
-  if (!isFile() || !(flags_ & O_WRITE)) goto fail;
-
-  // error if length is greater than current size
-  if (length > fileSize_) goto fail;
-
-  // fileSize and length are zero - nothing to do
-  if (fileSize_ == 0) return true;
-
-  // remember position for seek after truncation
-  newPos = curPosition_ > length ? length : curPosition_;
-
-  // position to last cluster in truncated file
-  if (!seekSet(length)) goto fail;
-
-  if (length == 0) {
-    // free all clusters
-    if (!vol_->freeChain(firstCluster_)) goto fail;
-    firstCluster_ = 0;
-  } else {
-    uint32_t toFree;
-    if (!vol_->fatGet(curCluster_, &toFree)) goto fail;
-
-    if (!vol_->isEOC(toFree)) {
-      // free extra clusters
-      if (!vol_->freeChain(toFree)) goto fail;
-
-      // current cluster is end of chain
-      if (!vol_->fatPutEOC(curCluster_)) goto fail;
-    }
-  }
-  fileSize_ = length;
-
-  // need to update directory entry
-  flags_ |= F_FILE_DIR_DIRTY;
-
-  if (!sync()) goto fail;
-
-  // set file to correct position
-  return seekSet(newPos);
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Write data to an open file.
- *
- * \note Data is moved to the cache but may not be written to the
- * storage device until sync() is called.
- *
- * \param[in] buf Pointer to the location of the data to be written.
- *
- * \param[in] nbyte Number of bytes to write.
- *
- * \return For success write() returns the number of bytes written, always
- * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
- * include write() is called before a file has been opened, write is called
- * for a read-only file, device is full, a corrupt file system or an I/O error.
- *
- */
-int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
-  // convert void* to uint8_t*  -  must be before goto statements
-  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
-
-  // number of bytes left to write  -  must be before goto statements
-  uint16_t nToWrite = nbyte;
-
-  // error if not a normal file or is read-only
-  if (!isFile() || !(flags_ & O_WRITE)) goto fail;
-
-  // seek to end of file if append flag
-  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
-    if (!seekEnd()) goto fail;
-  }
-
-  while (nToWrite > 0) {
-    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
-    uint16_t blockOffset = curPosition_ & 0X1FF;
-    if (blockOfCluster == 0 && blockOffset == 0) {
-      // start of new cluster
-      if (curCluster_ == 0) {
-        if (firstCluster_ == 0) {
-          // allocate first cluster of file
-          if (!addCluster()) goto fail;
-        } else {
-          curCluster_ = firstCluster_;
-        }
-      } else {
-        uint32_t next;
-        if (!vol_->fatGet(curCluster_, &next)) goto fail;
-        if (vol_->isEOC(next)) {
-          // add cluster if at end of chain
-          if (!addCluster()) goto fail;
-        } else {
-          curCluster_ = next;
-        }
-      }
-    }
-    // max space in block
-    uint16_t n = 512 - blockOffset;
-
-    // lesser of space and amount to write
-    if (n > nToWrite) n = nToWrite;
-
-    // block for data write
-    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
-    if (n == 512) {
-      // full block - don't need to use cache
-      if (vol_->cacheBlockNumber() == block) {
-        // invalidate cache if block is in cache
-        vol_->cacheSetBlockNumber(0XFFFFFFFF, false);
-      }
-      if (!vol_->writeBlock(block, src)) goto fail;
-    } else {
-      if (blockOffset == 0 && curPosition_ >= fileSize_) {
-        // start of new block don't need to read into cache
-        if (!vol_->cacheFlush()) goto fail;
-        // set cache dirty and SD address of block
-        vol_->cacheSetBlockNumber(block, true);
-      } else {
-        // rewrite part of block
-        if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
-      }
-      uint8_t* dst = vol_->cache()->data + blockOffset;
-      memcpy(dst, src, n);
-    }
-    curPosition_ += n;
-    src += n;
-    nToWrite -= n;
-  }
-  if (curPosition_ > fileSize_) {
-    // update fileSize and insure sync will update dir entry
-    fileSize_ = curPosition_;
-    flags_ |= F_FILE_DIR_DIRTY;
-  } else if (dateTime_ && nbyte) {
-    // insure sync will update modified date and time
-    flags_ |= F_FILE_DIR_DIRTY;
-  }
-
-  if (flags_ & O_SYNC) {
-    if (!sync()) goto fail;
-  }
-  return nbyte;
-
- fail:
-  // return for write error
-  writeError = true;
-  return -1;
-}
-//------------------------------------------------------------------------------
-// suppress cpplint warnings with NOLINT comment
-#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
-void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT
-#endif  // ALLOW_DEPRECATED_FUNCTIONS
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.h
deleted file mode 100644
index 9df19c4..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdBaseFile.h
+++ /dev/null
@@ -1,480 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#ifndef SdBaseFile_h
-#define SdBaseFile_h
-/**
- * \file
- * \brief SdBaseFile class
- */
-#include "SdFatConfig.h"
-#include "SdVolume.h"
-//------------------------------------------------------------------------------
-/**
- * \struct fpos_t
- * \brief internal type for istream
- * do not use in user apps
- */
-struct fpos_t {
-  /** stream position */
-  uint32_t position;
-  /** cluster for position */
-  uint32_t cluster;
-  fpos_t() : position(0), cluster(0) {}
-};
-
-// use the gnu style oflag in open()
-/** open() oflag for reading */
-uint8_t const O_READ = 0X01;
-/** open() oflag - same as O_IN */
-uint8_t const O_RDONLY = O_READ;
-/** open() oflag for write */
-uint8_t const O_WRITE = 0X02;
-/** open() oflag - same as O_WRITE */
-uint8_t const O_WRONLY = O_WRITE;
-/** open() oflag for reading and writing */
-uint8_t const O_RDWR = (O_READ | O_WRITE);
-/** open() oflag mask for access modes */
-uint8_t const O_ACCMODE = (O_READ | O_WRITE);
-/** The file offset shall be set to the end of the file prior to each write. */
-uint8_t const O_APPEND = 0X04;
-/** synchronous writes - call sync() after each write */
-uint8_t const O_SYNC = 0X08;
-/** truncate the file to zero length */
-uint8_t const O_TRUNC = 0X10;
-/** set the initial position at the end of the file */
-uint8_t const O_AT_END = 0X20;
-/** create the file if nonexistent */
-uint8_t const O_CREAT = 0X40;
-/** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */
-uint8_t const O_EXCL = 0X80;
-
-// SdBaseFile class static and const definitions
-// flags for ls()
-/** ls() flag to print modify date */
-uint8_t const LS_DATE = 1;
-/** ls() flag to print file size */
-uint8_t const LS_SIZE = 2;
-/** ls() flag for recursive list of subdirectories */
-uint8_t const LS_R = 4;
-
-
-// flags for timestamp
-/** set the file's last access date */
-uint8_t const T_ACCESS = 1;
-/** set the file's creation date and time */
-uint8_t const T_CREATE = 2;
-/** Set the file's write date and time */
-uint8_t const T_WRITE = 4;
-// values for type_
-/** This file has not been opened. */
-uint8_t const FAT_FILE_TYPE_CLOSED = 0;
-/** A normal file */
-uint8_t const FAT_FILE_TYPE_NORMAL = 1;
-/** A FAT12 or FAT16 root directory */
-uint8_t const FAT_FILE_TYPE_ROOT_FIXED = 2;
-/** A FAT32 root directory */
-uint8_t const FAT_FILE_TYPE_ROOT32 = 3;
-/** A subdirectory file*/
-uint8_t const FAT_FILE_TYPE_SUBDIR = 4;
-/** Test value for directory type */
-uint8_t const FAT_FILE_TYPE_MIN_DIR = FAT_FILE_TYPE_ROOT_FIXED;
-
-/** date field for FAT directory entry
- * \param[in] year [1980,2107]
- * \param[in] month [1,12]
- * \param[in] day [1,31]
- *
- * \return Packed date for dir_t entry.
- */
-static inline uint16_t FAT_DATE(uint16_t year, uint8_t month, uint8_t day) {
-  return (year - 1980) << 9 | month << 5 | day;
-}
-/** year part of FAT directory date field
- * \param[in] fatDate Date in packed dir format.
- *
- * \return Extracted year [1980,2107]
- */
-static inline uint16_t FAT_YEAR(uint16_t fatDate) {
-  return 1980 + (fatDate >> 9);
-}
-/** month part of FAT directory date field
- * \param[in] fatDate Date in packed dir format.
- *
- * \return Extracted month [1,12]
- */
-static inline uint8_t FAT_MONTH(uint16_t fatDate) {
-  return (fatDate >> 5) & 0XF;
-}
-/** day part of FAT directory date field
- * \param[in] fatDate Date in packed dir format.
- *
- * \return Extracted day [1,31]
- */
-static inline uint8_t FAT_DAY(uint16_t fatDate) {
-  return fatDate & 0X1F;
-}
-/** time field for FAT directory entry
- * \param[in] hour [0,23]
- * \param[in] minute [0,59]
- * \param[in] second [0,59]
- *
- * \return Packed time for dir_t entry.
- */
-static inline uint16_t FAT_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
-  return hour << 11 | minute << 5 | second >> 1;
-}
-/** hour part of FAT directory time field
- * \param[in] fatTime Time in packed dir format.
- *
- * \return Extracted hour [0,23]
- */
-static inline uint8_t FAT_HOUR(uint16_t fatTime) {
-  return fatTime >> 11;
-}
-/** minute part of FAT directory time field
- * \param[in] fatTime Time in packed dir format.
- *
- * \return Extracted minute [0,59]
- */
-static inline uint8_t FAT_MINUTE(uint16_t fatTime) {
-  return(fatTime >> 5) & 0X3F;
-}
-/** second part of FAT directory time field
- * Note second/2 is stored in packed time.
- *
- * \param[in] fatTime Time in packed dir format.
- *
- * \return Extracted second [0,58]
- */
-static inline uint8_t FAT_SECOND(uint16_t fatTime) {
-  return 2*(fatTime & 0X1F);
-}
-/** Default date for file timestamps is 1 Jan 2000 */
-uint16_t const FAT_DEFAULT_DATE = ((2000 - 1980) << 9) | (1 << 5) | 1;
-/** Default time for file timestamp is 1 am */
-uint16_t const FAT_DEFAULT_TIME = (1 << 11);
-
-class Print;
-//------------------------------------------------------------------------------
-/**
- * \class SdBaseFile
- * \brief Base class for SdFile with Print and C++ streams.
- */
-class SdBaseFile {
- public:
-  /** Create an instance. */
-  SdBaseFile() : writeError(false), type_(FAT_FILE_TYPE_CLOSED) {}
-  SdBaseFile(const char* path, uint8_t oflag);
-  ~SdBaseFile() {if(isOpen()) close();}
-  /**
-   * writeError is set to true if an error occurs during a write().
-   * Set writeError to false before calling print() and/or write() and check
-   * for true after calls to print() and/or write().
-   */
-  bool writeError;
-  //----------------------------------------------------------------------------
-  // helpers for stream classes
-  /** get position for streams
-   * \param[out] pos struct to receive position
-   */
-  void getpos(fpos_t* pos);
-  /** set position for streams
-   * \param[out] pos struct with value for new position
-   */
-  void setpos(fpos_t* pos);
-  //----------------------------------------------------------------------------
-  bool close();
-  bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);
-  bool createContiguous(SdBaseFile* dirFile,
-          const char* path, uint32_t size);
-  /** \return The current cluster number for a file or directory. */
-  uint32_t curCluster() const {return curCluster_;}
-  /** \return The current position for a file or directory. */
-  uint32_t curPosition() const {return curPosition_;}
-  /** \return Current working directory */
-  static SdBaseFile* cwd() {return cwd_;}
-  /** Set the date/time callback function
-   *
-   * \param[in] dateTime The user's call back function.  The callback
-   * function is of the form:
-   *
-   * \code
-   * void dateTime(uint16_t* date, uint16_t* time) {
-   *   uint16_t year;
-   *   uint8_t month, day, hour, minute, second;
-   *
-   *   // User gets date and time from GPS or real-time clock here
-   *
-   *   // return date using FAT_DATE macro to format fields
-   *   *date = FAT_DATE(year, month, day);
-   *
-   *   // return time using FAT_TIME macro to format fields
-   *   *time = FAT_TIME(hour, minute, second);
-   * }
-   * \endcode
-   *
-   * Sets the function that is called when a file is created or when
-   * a file's directory entry is modified by sync(). All timestamps,
-   * access, creation, and modify, are set when a file is created.
-   * sync() maintains the last access date and last modify date/time.
-   *
-   * See the timestamp() function.
-   */
-  static void dateTimeCallback(
-    void (*dateTime)(uint16_t* date, uint16_t* time)) {
-    dateTime_ = dateTime;
-  }
-  /**  Cancel the date/time callback function. */
-  static void dateTimeCallbackCancel() {dateTime_ = 0;}
-  bool dirEntry(dir_t* dir);
-  static void dirName(const dir_t& dir, char* name);
-  bool exists(const char* name);
-  int16_t fgets(char* str, int16_t num, char* delim = 0);
-  /** \return The total number of bytes in a file or directory. */
-  uint32_t fileSize() const {return fileSize_;}
-  /** \return The first cluster number for a file or directory. */
-  uint32_t firstCluster() const {return firstCluster_;}
-  bool getFilename(char* name);
-  /** \return True if this is a directory else false. */
-  bool isDir() const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
-  /** \return True if this is a normal file else false. */
-  bool isFile() const {return type_ == FAT_FILE_TYPE_NORMAL;}
-  /** \return True if this is an open file/directory else false. */
-  bool isOpen() const {return type_ != FAT_FILE_TYPE_CLOSED;}
-  /** \return True if this is a subdirectory else false. */
-  bool isSubDir() const {return type_ == FAT_FILE_TYPE_SUBDIR;}
-  /** \return True if this is the root directory. */
-  bool isRoot() const {
-    return type_ == FAT_FILE_TYPE_ROOT_FIXED || type_ == FAT_FILE_TYPE_ROOT32;
-  }
-  void ls( Print *p, uint8_t flags = 0, uint8_t indent = 0);
-  bool mkdir(SdBaseFile* dir, const char* path, bool pFlag = true);
-  // alias for backward compactability
-  bool makeDir(SdBaseFile* dir, const char* path) {
-    return mkdir(dir, path, false);
-  }
-  bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);
-  bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);
-  bool open(const char* path, uint8_t oflag = O_READ);
-  bool openNext(SdBaseFile* dirFile, uint8_t oflag);
-  bool openRoot(SdVolume* vol);
-  int peek();
-  static void printFatDate(Print *p, uint16_t fatDate);
-  static void printFatTime(Print *p, uint16_t fatTime);
-  bool printName(Print *p);
-  int16_t read();
-  int16_t read(void* buf, uint16_t nbyte);
-  int8_t readDir(dir_t* dir, char* longFilename);
-  static bool remove(SdBaseFile* dirFile, const char* path);
-  bool remove();
-  /** Set the file's current position to zero. */
-  void rewind() {seekSet(0);}
-  bool rename(SdBaseFile* dirFile, const char* newPath);
-  bool rmdir();
-  // for backward compatibility
-  bool rmDir() {return rmdir();}
-  bool rmRfStar();
-  /** Set the files position to current position + \a pos. See seekSet().
-   * \param[in] offset The new position in bytes from the current position.
-   * \return true for success or false for failure.
-   */
-  bool seekCur(int32_t offset) {
-    return seekSet(curPosition_ + offset);
-  }
-  /** Set the files position to end-of-file + \a offset. See seekSet().
-   * \param[in] offset The new position in bytes from end-of-file.
-   * \return true for success or false for failure.
-   */
-  bool seekEnd(int32_t offset = 0) {return seekSet(fileSize_ + offset);}
-  bool seekSet(uint32_t pos);
-  bool sync();
-  bool timestamp(SdBaseFile* file);
-  bool timestamp(uint8_t flag, uint16_t year, uint8_t month, uint8_t day,
-          uint8_t hour, uint8_t minute, uint8_t second);
-  /** Type of file.  You should use isFile() or isDir() instead of type()
-   * if possible.
-   *
-   * \return The file or directory type.
-   */
-  uint8_t type() const {return type_;}
-  bool truncate(uint32_t size);
-  /** \return SdVolume that contains this file. */
-  SdVolume* volume() const {return vol_;}
-  int16_t write(const void* buf, uint16_t nbyte);
-//------------------------------------------------------------------------------
- private:
-  // allow SdFat to set cwd_
-  friend class SdFat;
-  // global pointer to cwd dir
-  static SdBaseFile* cwd_;
-  // data time callback function
-  static void (*dateTime_)(uint16_t* date, uint16_t* time);
-  // bits defined in flags_
-  // should be 0X0F
-  static uint8_t const F_OFLAG = (O_ACCMODE | O_APPEND | O_SYNC);
-  // sync of directory entry required
-  static uint8_t const F_FILE_DIR_DIRTY = 0X80;
-
-  // private data
-  uint8_t   flags_;         // See above for definition of flags_ bits
-  uint8_t   fstate_;        // error and eof indicator
-  uint8_t   type_;          // type of file see above for values
-  uint32_t  curCluster_;    // cluster for current file position
-  uint32_t  curPosition_;   // current file position in bytes from beginning
-  uint32_t  dirBlock_;      // block for this files directory entry
-  uint8_t   dirIndex_;      // index of directory entry in dirBlock
-  uint32_t  fileSize_;      // file size in bytes
-  uint32_t  firstCluster_;  // first cluster of file
-  SdVolume* vol_;           // volume where file is located
-
-  /** experimental don't use */
-  bool openParent(SdBaseFile* dir);
-  // private functions
-  bool addCluster();
-  bool addDirCluster();
-  dir_t* cacheDirEntry(uint8_t action);
-  int8_t lsPrintNext( Print *p, uint8_t flags, uint8_t indent);
-  static bool make83Name(const char* str, uint8_t* name, const char** ptr);
-  bool mkdir(SdBaseFile* parent, const uint8_t dname[11]);
-  bool open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag);
-  bool openCachedEntry(uint8_t cacheIndex, uint8_t oflags);
-  dir_t* readDirCache();
-//------------------------------------------------------------------------------
-// to be deleted
-  static void printDirName( Print *p, const dir_t& dir,
-    uint8_t width, bool printSlash);
-//------------------------------------------------------------------------------
-// Deprecated functions  - suppress cpplint warnings with NOLINT comment
-#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
- public:
-  /** \deprecated Use:
-   * bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);
-   * \param[out] bgnBlock the first block address for the file.
-   * \param[out] endBlock the last  block address for the file.
-   * \return true for success or false for failure.
-   */
-  bool contiguousRange(uint32_t& bgnBlock, uint32_t& endBlock) {  // NOLINT
-    return contiguousRange(&bgnBlock, &endBlock);
-  }
- /** \deprecated Use:
-   * bool createContiguous(SdBaseFile* dirFile,
-   *   const char* path, uint32_t size)
-   * \param[in] dirFile The directory where the file will be created.
-   * \param[in] path A path with a valid DOS 8.3 file name.
-   * \param[in] size The desired file size.
-   * \return true for success or false for failure.
-   */
-  bool createContiguous(SdBaseFile& dirFile,  // NOLINT
-    const char* path, uint32_t size) {
-    return createContiguous(&dirFile, path, size);
-  }
-  /** \deprecated Use:
-   * static void dateTimeCallback(
-   *   void (*dateTime)(uint16_t* date, uint16_t* time));
-   * \param[in] dateTime The user's call back function.
-   */
-  static void dateTimeCallback(
-    void (*dateTime)(uint16_t& date, uint16_t& time)) {  // NOLINT
-    oldDateTime_ = dateTime;
-    dateTime_ = dateTime ? oldToNew : 0;
-  }
-  /** \deprecated Use: bool dirEntry(dir_t* dir);
-   * \param[out] dir Location for return of the file's directory entry.
-   * \return true for success or false for failure.
-   */
-  bool dirEntry(dir_t& dir) {return dirEntry(&dir);}  // NOLINT
-  /** \deprecated Use:
-   * bool mkdir(SdBaseFile* dir, const char* path);
-   * \param[in] dir An open SdFat instance for the directory that will contain
-   * the new directory.
-   * \param[in] path A path with a valid 8.3 DOS name for the new directory.
-   * \return true for success or false for failure.
-   */
-  bool mkdir(SdBaseFile& dir, const char* path) {  // NOLINT
-    return mkdir(&dir, path);
-  }
-  /** \deprecated Use:
-   * bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);
-   * \param[in] dirFile An open SdFat instance for the directory containing the
-   * file to be opened.
-   * \param[in] path A path with a valid 8.3 DOS name for the file.
-   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
-   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
-   * \return true for success or false for failure.
-   */
-  bool open(SdBaseFile& dirFile, // NOLINT
-    const char* path, uint8_t oflag) {
-    return open(&dirFile, path, oflag);
-  }
-  /** \deprecated  Do not use in new apps
-   * \param[in] dirFile An open SdFat instance for the directory containing the
-   * file to be opened.
-   * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
-   * \return true for success or false for failure.
-   */
-  bool open(SdBaseFile& dirFile, const char* path) {  // NOLINT
-    return open(dirFile, path, O_RDWR);
-  }
-  /** \deprecated Use:
-   * bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);
-   * \param[in] dirFile An open SdFat instance for the directory.
-   * \param[in] index The \a index of the directory entry for the file to be
-   * opened.  The value for \a index is (directory file position)/32.
-   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
-   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
-   * \return true for success or false for failure.
-   */
-  bool open(SdBaseFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
-    return open(&dirFile, index, oflag);
-  }
-  /** \deprecated Use: bool openRoot(SdVolume* vol);
-   * \param[in] vol The FAT volume containing the root directory to be opened.
-   * \return true for success or false for failure.
-   */
-  bool openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT
-  /** \deprecated Use: int8_t readDir(dir_t* dir);
-   * \param[out] dir The dir_t struct that will receive the data.
-   * \return bytes read for success zero for eof or -1 for failure.
-   */
-  int8_t readDir(dir_t& dir, char* longFilename) {return readDir(&dir, longFilename);}  // NOLINT
-  /** \deprecated Use:
-   * static uint8_t remove(SdBaseFile* dirFile, const char* path);
-   * \param[in] dirFile The directory that contains the file.
-   * \param[in] path The name of the file to be removed.
-   * \return true for success or false for failure.
-   */
-  static bool remove(SdBaseFile& dirFile, const char* path) {  // NOLINT
-    return remove(&dirFile, path);
-  }
-//------------------------------------------------------------------------------
-// rest are private
- private:
-  static void (*oldDateTime_)(uint16_t& date, uint16_t& time);  // NOLINT
-  static void oldToNew(uint16_t* date, uint16_t* time) {
-    uint16_t d;
-    uint16_t t;
-    oldDateTime_(d, t);
-    *date = d;
-    *time = t;
-  }
-#endif  // ALLOW_DEPRECATED_FUNCTIONS
-};
-
-#endif  // SdBaseFile_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFat.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFat.h
deleted file mode 100644
index 77c1d0d..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFat.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef AT90USB
-#define  HardwareSerial_h // trick to disable the standard HWserial
-#endif
-
-#include <Arduino.h>
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatConfig.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatConfig.h
deleted file mode 100644
index 406a5a5..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatConfig.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-/**
- * \file
- * \brief configuration definitions
- */
-#ifndef SdFatConfig_h
-#define SdFatConfig_h
-#include <stdint.h>
-//------------------------------------------------------------------------------
-/**
- * To use multiple SD cards set USE_MULTIPLE_CARDS nonzero.
- *
- * Using multiple cards costs 400 - 500  bytes of flash.
- *
- * Each card requires about 550 bytes of SRAM so use of a Mega is recommended.
- */
-#define USE_MULTIPLE_CARDS 0
-//------------------------------------------------------------------------------
-/**
- * Call flush for endl if ENDL_CALLS_FLUSH is nonzero
- *
- * The standard for iostreams is to call flush.  This is very costly for
- * SdFat.  Each call to flush causes 2048 bytes of I/O to the SD.
- *
- * SdFat has a single 512 byte buffer for SD I/O so it must write the current
- * data block to the SD, read the directory block from the SD, update the
- * directory entry, write the directory block to the SD and read the data
- * block back into the buffer.
- *
- * The SD flash memory controller is not designed for this many rewrites
- * so performance may be reduced by more than a factor of 100.
- *
- * If ENDL_CALLS_FLUSH is zero, you must call flush and/or close to force
- * all data to be written to the SD.
- */
-#define ENDL_CALLS_FLUSH 0
-//------------------------------------------------------------------------------
-/**
- * Allow use of deprecated functions if ALLOW_DEPRECATED_FUNCTIONS is nonzero
- */
-#define ALLOW_DEPRECATED_FUNCTIONS 1
-//------------------------------------------------------------------------------
-/**
- * Allow FAT12 volumes if FAT12_SUPPORT is nonzero.
- * FAT12 has not been well tested.
- */
-#define FAT12_SUPPORT 0
-//------------------------------------------------------------------------------
-/**
- * SPI init rate for SD initialization commands. Must be 5 (F_CPU/64)
- * or 6 (F_CPU/128).
- */
-#define SPI_SD_INIT_RATE 5
-//------------------------------------------------------------------------------
-/**
- * Set the SS pin high for hardware SPI.  If SS is chip select for another SPI
- * device this will disable that device during the SD init phase.
- */
-#define SET_SPI_SS_HIGH 1
-//------------------------------------------------------------------------------
-/**
- * Define MEGA_SOFT_SPI nonzero to use software SPI on Mega Arduinos.
- * Pins used are SS 10, MOSI 11, MISO 12, and SCK 13.
- *
- * MEGA_SOFT_SPI allows an unmodified Adafruit GPS Shield to be used
- * on Mega Arduinos.  Software SPI works well with GPS Shield V1.1
- * but many SD cards will fail with GPS Shield V1.0.
- */
-#define MEGA_SOFT_SPI 0
-//------------------------------------------------------------------------------
-/**
- * Set USE_SOFTWARE_SPI nonzero to always use software SPI.
- */
-#define USE_SOFTWARE_SPI 0
-// define software SPI pins so Mega can use unmodified 168/328 shields
-/** Software SPI chip select pin for the SD */
-uint8_t const SOFT_SPI_CS_PIN = 10;
-/** Software SPI Master Out Slave In pin */
-uint8_t const SOFT_SPI_MOSI_PIN = 11;
-/** Software SPI Master In Slave Out pin */
-uint8_t const SOFT_SPI_MISO_PIN = 12;
-/** Software SPI Clock pin */
-uint8_t const SOFT_SPI_SCK_PIN = 13;
-//------------------------------------------------------------------------------
-/**
- * The __cxa_pure_virtual function is an error handler that is invoked when
- * a pure virtual function is called.
- */
-#define USE_CXA_PURE_VIRTUAL 1
-/**
- * Defines for long (vfat) filenames
- */
-/** Number of VFAT entries used. Every entry has 13 UTF-16 characters */
-#define MAX_VFAT_ENTRIES (2)
-/** Number of UTF-16 characters per entry */
-#define FILENAME_LENGTH 13
-/** Total size of the buffer used to store the long filenames */
-#define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
-#endif  // SdFatConfig_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatStructs.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatStructs.h
deleted file mode 100644
index 8991316..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatStructs.h
+++ /dev/null
@@ -1,640 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#ifndef SdFatStructs_h
-#define SdFatStructs_h
-
-#define PACKED __attribute__((__packed__))
-/**
- * \file
- * \brief FAT file structures
- */
-/*
- * mostly from Microsoft document fatgen103.doc
- * http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
- */
-//------------------------------------------------------------------------------
-/** Value for byte 510 of boot block or MBR */
-uint8_t const BOOTSIG0 = 0X55;
-/** Value for byte 511 of boot block or MBR */
-uint8_t const BOOTSIG1 = 0XAA;
-/** Value for bootSignature field int FAT/FAT32 boot sector */
-uint8_t const EXTENDED_BOOT_SIG = 0X29;
-//------------------------------------------------------------------------------
-/**
- * \struct partitionTable
- * \brief MBR partition table entry
- *
- * A partition table entry for a MBR formatted storage device.
- * The MBR partition table has four entries.
- */
-struct partitionTable {
-          /**
-           * Boot Indicator . Indicates whether the volume is the active
-           * partition.  Legal values include: 0X00. Do not use for booting.
-           * 0X80 Active partition.
-           */
-  uint8_t  boot;
-          /**
-            * Head part of Cylinder-head-sector address of the first block in
-            * the partition. Legal values are 0-255. Only used in old PC BIOS.
-            */
-  uint8_t  beginHead;
-          /**
-           * Sector part of Cylinder-head-sector address of the first block in
-           * the partition. Legal values are 1-63. Only used in old PC BIOS.
-           */
-  unsigned beginSector : 6;
-           /** High bits cylinder for first block in partition. */
-  unsigned beginCylinderHigh : 2;
-          /**
-           * Combine beginCylinderLow with beginCylinderHigh. Legal values
-           * are 0-1023.  Only used in old PC BIOS.
-           */
-  uint8_t  beginCylinderLow;
-          /**
-           * Partition type. See defines that begin with PART_TYPE_ for
-           * some Microsoft partition types.
-           */
-  uint8_t  type;
-          /**
-           * head part of cylinder-head-sector address of the last sector in the
-           * partition.  Legal values are 0-255. Only used in old PC BIOS.
-           */
-  uint8_t  endHead;
-          /**
-           * Sector part of cylinder-head-sector address of the last sector in
-           * the partition.  Legal values are 1-63. Only used in old PC BIOS.
-           */
-  unsigned endSector : 6;
-           /** High bits of end cylinder */
-  unsigned endCylinderHigh : 2;
-          /**
-           * Combine endCylinderLow with endCylinderHigh. Legal values
-           * are 0-1023.  Only used in old PC BIOS.
-           */
-  uint8_t  endCylinderLow;
-           /** Logical block address of the first block in the partition. */
-  uint32_t firstSector;
-           /** Length of the partition, in blocks. */
-  uint32_t totalSectors;
-} PACKED;
-/** Type name for partitionTable */
-typedef struct partitionTable part_t;
-//------------------------------------------------------------------------------
-/**
- * \struct masterBootRecord
- *
- * \brief Master Boot Record
- *
- * The first block of a storage device that is formatted with a MBR.
- */
-struct masterBootRecord {
-           /** Code Area for master boot program. */
-  uint8_t  codeArea[440];
-           /** Optional Windows NT disk signature. May contain boot code. */
-  uint32_t diskSignature;
-           /** Usually zero but may be more boot code. */
-  uint16_t usuallyZero;
-           /** Partition tables. */
-  part_t   part[4];
-           /** First MBR signature byte. Must be 0X55 */
-  uint8_t  mbrSig0;
-           /** Second MBR signature byte. Must be 0XAA */
-  uint8_t  mbrSig1;
-} PACKED;
-/** Type name for masterBootRecord */
-typedef struct masterBootRecord mbr_t;
-//------------------------------------------------------------------------------
-/**
- * \struct fat_boot
- *
- * \brief Boot sector for a FAT12/FAT16 volume.
- *
- */
-struct fat_boot {
-         /**
-          * The first three bytes of the boot sector must be valid,
-          * executable x 86-based CPU instructions. This includes a
-          * jump instruction that skips the next nonexecutable bytes.
-          */
-  uint8_t jump[3];
-         /**
-          * This is typically a string of characters that identifies
-          * the operating system that formatted the volume.
-          */
-  char    oemId[8];
-          /**
-           * The size of a hardware sector. Valid decimal values for this
-           * field are 512, 1024, 2048, and 4096. For most disks used in
-           * the United States, the value of this field is 512.
-           */
-  uint16_t bytesPerSector;
-          /**
-           * Number of sectors per allocation unit. This value must be a
-           * power of 2 that is greater than 0. The legal values are
-           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.
-           */
-  uint8_t  sectorsPerCluster;
-          /**
-           * The number of sectors preceding the start of the first FAT,
-           * including the boot sector. The value of this field is always 1.
-           */
-  uint16_t reservedSectorCount;
-          /**
-           * The number of copies of the FAT on the volume.
-           * The value of this field is always 2.
-           */
-  uint8_t  fatCount;
-          /**
-           * For FAT12 and FAT16 volumes, this field contains the count of
-           * 32-byte directory entries in the root directory. For FAT32 volumes,
-           * this field must be set to 0. For FAT12 and FAT16 volumes, this
-           * value should always specify a count that when multiplied by 32
-           * results in a multiple of bytesPerSector.  FAT16 volumes should
-           * use the value 512.
-           */
-  uint16_t rootDirEntryCount;
-          /**
-           * This field is the old 16-bit total count of sectors on the volume.
-           * This count includes the count of all sectors in all four regions
-           * of the volume. This field can be 0; if it is 0, then totalSectors32
-           * must be nonzero.  For FAT32 volumes, this field must be 0. For
-           * FAT12 and FAT16 volumes, this field contains the sector count, and
-           * totalSectors32 is 0 if the total sector count fits
-           * (is less than 0x10000).
-           */
-  uint16_t totalSectors16;
-          /**
-           * This dates back to the old MS-DOS 1.x media determination and is
-           * no longer usually used for anything.  0xF8 is the standard value
-           * for fixed (nonremovable) media. For removable media, 0xF0 is
-           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.
-           */
-  uint8_t  mediaType;
-          /**
-           * Count of sectors occupied by one FAT on FAT12/FAT16 volumes.
-           * On FAT32 volumes this field must be 0, and sectorsPerFat32
-           * contains the FAT size count.
-           */
-  uint16_t sectorsPerFat16;
-           /** Sectors per track for interrupt 0x13. Not used otherwise. */
-  uint16_t sectorsPerTrack;
-           /** Number of heads for interrupt 0x13.  Not used otherwise. */
-  uint16_t headCount;
-          /**
-           * Count of hidden sectors preceding the partition that contains this
-           * FAT volume. This field is generally only relevant for media
-           * visible on interrupt 0x13.
-           */
-  uint32_t hidddenSectors;
-          /**
-           * This field is the new 32-bit total count of sectors on the volume.
-           * This count includes the count of all sectors in all four regions
-           * of the volume.  This field can be 0; if it is 0, then
-           * totalSectors16 must be nonzero.
-           */
-  uint32_t totalSectors32;
-           /**
-            * Related to the BIOS physical drive number. Floppy drives are
-            * identified as 0x00 and physical hard disks are identified as
-            * 0x80, regardless of the number of physical disk drives.
-            * Typically, this value is set prior to issuing an INT 13h BIOS
-            * call to specify the device to access. The value is only
-            * relevant if the device is a boot device.
-            */
-  uint8_t  driveNumber;
-           /** used by Windows NT - should be zero for FAT */
-  uint8_t  reserved1;
-           /** 0X29 if next three fields are valid */
-  uint8_t  bootSignature;
-           /**
-            * A random serial number created when formatting a disk,
-            * which helps to distinguish between disks.
-            * Usually generated by combining date and time.
-            */
-  uint32_t volumeSerialNumber;
-           /**
-            * A field once used to store the volume label. The volume label
-            * is now stored as a special file in the root directory.
-            */
-  char     volumeLabel[11];
-           /**
-            * A field with a value of either FAT, FAT12 or FAT16,
-            * depending on the disk format.
-            */
-  char     fileSystemType[8];
-           /** X86 boot code */
-  uint8_t  bootCode[448];
-           /** must be 0X55 */
-  uint8_t  bootSectorSig0;
-           /** must be 0XAA */
-  uint8_t  bootSectorSig1;
-} PACKED;
-/** Type name for FAT Boot Sector */
-typedef struct fat_boot fat_boot_t;
-//------------------------------------------------------------------------------
-/**
- * \struct fat32_boot
- *
- * \brief Boot sector for a FAT32 volume.
- *
- */
-struct fat32_boot {
-         /**
-          * The first three bytes of the boot sector must be valid,
-          * executable x 86-based CPU instructions. This includes a
-          * jump instruction that skips the next nonexecutable bytes.
-          */
-  uint8_t jump[3];
-         /**
-          * This is typically a string of characters that identifies
-          * the operating system that formatted the volume.
-          */
-  char    oemId[8];
-          /**
-           * The size of a hardware sector. Valid decimal values for this
-           * field are 512, 1024, 2048, and 4096. For most disks used in
-           * the United States, the value of this field is 512.
-           */
-  uint16_t bytesPerSector;
-          /**
-           * Number of sectors per allocation unit. This value must be a
-           * power of 2 that is greater than 0. The legal values are
-           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.
-           */
-  uint8_t  sectorsPerCluster;
-          /**
-           * The number of sectors preceding the start of the first FAT,
-           * including the boot sector. Must not be zero
-           */
-  uint16_t reservedSectorCount;
-          /**
-           * The number of copies of the FAT on the volume.
-           * The value of this field is always 2.
-           */
-  uint8_t  fatCount;
-          /**
-           * FAT12/FAT16 only. For FAT32 volumes, this field must be set to 0.
-           */
-  uint16_t rootDirEntryCount;
-          /**
-           * For FAT32 volumes, this field must be 0.
-           */
-  uint16_t totalSectors16;
-          /**
-           * This dates back to the old MS-DOS 1.x media determination and is
-           * no longer usually used for anything.  0xF8 is the standard value
-           * for fixed (nonremovable) media. For removable media, 0xF0 is
-           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.
-           */
-  uint8_t  mediaType;
-          /**
-           * On FAT32 volumes this field must be 0, and sectorsPerFat32
-           * contains the FAT size count.
-           */
-  uint16_t sectorsPerFat16;
-           /** Sectors per track for interrupt 0x13. Not used otherwise. */
-  uint16_t sectorsPerTrack;
-           /** Number of heads for interrupt 0x13.  Not used otherwise. */
-  uint16_t headCount;
-          /**
-           * Count of hidden sectors preceding the partition that contains this
-           * FAT volume. This field is generally only relevant for media
-           * visible on interrupt 0x13.
-           */
-  uint32_t hidddenSectors;
-          /**
-           * Contains the total number of sectors in the FAT32 volume.
-           */
-  uint32_t totalSectors32;
-         /**
-           * Count of sectors occupied by one FAT on FAT32 volumes.
-           */
-  uint32_t sectorsPerFat32;
-          /**
-           * This field is only defined for FAT32 media and does not exist on
-           * FAT12 and FAT16 media.
-           * Bits 0-3 -- Zero-based number of active FAT.
-           *             Only valid if mirroring is disabled.
-           * Bits 4-6 -- Reserved.
-           * Bit 7	-- 0 means the FAT is mirrored at runtime into all FATs.
-	         *        -- 1 means only one FAT is active; it is the one referenced
-	         *             in bits 0-3.
-           * Bits 8-15 	-- Reserved.
-           */
-  uint16_t fat32Flags;
-          /**
-           * FAT32 version. High byte is major revision number.
-           * Low byte is minor revision number. Only 0.0 define.
-           */
-  uint16_t fat32Version;
-          /**
-           * Cluster number of the first cluster of the root directory for FAT32.
-           * This usually 2 but not required to be 2.
-           */
-  uint32_t fat32RootCluster;
-          /**
-           * Sector number of FSINFO structure in the reserved area of the
-           * FAT32 volume. Usually 1.
-           */
-  uint16_t fat32FSInfo;
-          /**
-           * If nonzero, indicates the sector number in the reserved area
-           * of the volume of a copy of the boot record. Usually 6.
-           * No value other than 6 is recommended.
-           */
-  uint16_t fat32BackBootBlock;
-          /**
-           * Reserved for future expansion. Code that formats FAT32 volumes
-           * should always set all of the bytes of this field to 0.
-           */
-  uint8_t  fat32Reserved[12];
-           /**
-            * Related to the BIOS physical drive number. Floppy drives are
-            * identified as 0x00 and physical hard disks are identified as
-            * 0x80, regardless of the number of physical disk drives.
-            * Typically, this value is set prior to issuing an INT 13h BIOS
-            * call to specify the device to access. The value is only
-            * relevant if the device is a boot device.
-            */
-  uint8_t  driveNumber;
-           /** used by Windows NT - should be zero for FAT */
-  uint8_t  reserved1;
-           /** 0X29 if next three fields are valid */
-  uint8_t  bootSignature;
-           /**
-            * A random serial number created when formatting a disk,
-            * which helps to distinguish between disks.
-            * Usually generated by combining date and time.
-            */
-  uint32_t volumeSerialNumber;
-           /**
-            * A field once used to store the volume label. The volume label
-            * is now stored as a special file in the root directory.
-            */
-  char     volumeLabel[11];
-           /**
-            * A text field with a value of FAT32.
-            */
-  char     fileSystemType[8];
-           /** X86 boot code */
-  uint8_t  bootCode[420];
-           /** must be 0X55 */
-  uint8_t  bootSectorSig0;
-           /** must be 0XAA */
-  uint8_t  bootSectorSig1;
-} PACKED;
-/** Type name for FAT32 Boot Sector */
-typedef struct fat32_boot fat32_boot_t;
-//------------------------------------------------------------------------------
-/** Lead signature for a FSINFO sector */
-uint32_t const FSINFO_LEAD_SIG = 0x41615252;
-/** Struct signature for a FSINFO sector */
-uint32_t const FSINFO_STRUCT_SIG = 0x61417272;
-/**
- * \struct fat32_fsinfo
- *
- * \brief FSINFO sector for a FAT32 volume.
- *
- */
-struct fat32_fsinfo {
-           /** must be 0X52, 0X52, 0X61, 0X41 */
-  uint32_t  leadSignature;
-           /** must be zero */
-  uint8_t  reserved1[480];
-           /** must be 0X72, 0X72, 0X41, 0X61 */
-  uint32_t  structSignature;
-          /**
-           * Contains the last known free cluster count on the volume.
-           * If the value is 0xFFFFFFFF, then the free count is unknown
-           * and must be computed. Any other value can be used, but is
-           * not necessarily correct. It should be range checked at least
-           * to make sure it is <= volume cluster count.
-           */
-  uint32_t freeCount;
-          /**
-           * This is a hint for the FAT driver. It indicates the cluster
-           * number at which the driver should start looking for free clusters.
-           * If the value is 0xFFFFFFFF, then there is no hint and the driver
-           * should start looking at cluster 2.
-           */
-  uint32_t nextFree;
-           /** must be zero */
-  uint8_t  reserved2[12];
-           /** must be 0X00, 0X00, 0X55, 0XAA */
-  uint8_t  tailSignature[4];
-} PACKED;
-/** Type name for FAT32 FSINFO Sector */
-typedef struct fat32_fsinfo fat32_fsinfo_t;
-//------------------------------------------------------------------------------
-// End Of Chain values for FAT entries
-/** FAT12 end of chain value used by Microsoft. */
-uint16_t const FAT12EOC = 0XFFF;
-/** Minimum value for FAT12 EOC.  Use to test for EOC. */
-uint16_t const FAT12EOC_MIN = 0XFF8;
-/** FAT16 end of chain value used by Microsoft. */
-uint16_t const FAT16EOC = 0XFFFF;
-/** Minimum value for FAT16 EOC.  Use to test for EOC. */
-uint16_t const FAT16EOC_MIN = 0XFFF8;
-/** FAT32 end of chain value used by Microsoft. */
-uint32_t const FAT32EOC = 0X0FFFFFFF;
-/** Minimum value for FAT32 EOC.  Use to test for EOC. */
-uint32_t const FAT32EOC_MIN = 0X0FFFFFF8;
-/** Mask a for FAT32 entry. Entries are 28 bits. */
-uint32_t const FAT32MASK = 0X0FFFFFFF;
-//------------------------------------------------------------------------------
-/**
- * \struct directoryEntry
- * \brief FAT short directory entry
- *
- * Short means short 8.3 name, not the entry size.
- *  
- * Date Format. A FAT directory entry date stamp is a 16-bit field that is 
- * basically a date relative to the MS-DOS epoch of 01/01/1980. Here is the
- * format (bit 0 is the LSB of the 16-bit word, bit 15 is the MSB of the 
- * 16-bit word):
- *   
- * Bits 9-15: Count of years from 1980, valid value range 0-127 
- * inclusive (1980-2107).
- *   
- * Bits 5-8: Month of year, 1 = January, valid value range 1-12 inclusive.
- *
- * Bits 0-4: Day of month, valid value range 1-31 inclusive.
- *
- * Time Format. A FAT directory entry time stamp is a 16-bit field that has
- * a granularity of 2 seconds. Here is the format (bit 0 is the LSB of the 
- * 16-bit word, bit 15 is the MSB of the 16-bit word).
- *   
- * Bits 11-15: Hours, valid value range 0-23 inclusive.
- * 
- * Bits 5-10: Minutes, valid value range 0-59 inclusive.
- *      
- * Bits 0-4: 2-second count, valid value range 0-29 inclusive (0 - 58 seconds).
- *   
- * The valid time range is from Midnight 00:00:00 to 23:59:58.
- */
-struct directoryEntry {
-           /** Short 8.3 name.
-            *
-            * The first eight bytes contain the file name with blank fill.
-            * The last three bytes contain the file extension with blank fill.
-            */
-  uint8_t  name[11];
-          /** Entry attributes.
-           *
-           * The upper two bits of the attribute byte are reserved and should
-           * always be set to 0 when a file is created and never modified or
-           * looked at after that.  See defines that begin with DIR_ATT_.
-           */
-  uint8_t  attributes;
-          /**
-           * Reserved for use by Windows NT. Set value to 0 when a file is
-           * created and never modify or look at it after that.
-           */
-  uint8_t  reservedNT;
-          /**
-           * The granularity of the seconds part of creationTime is 2 seconds
-           * so this field is a count of tenths of a second and its valid
-           * value range is 0-199 inclusive. (WHG note - seems to be hundredths)
-           */
-  uint8_t  creationTimeTenths;
-           /** Time file was created. */
-  uint16_t creationTime;
-           /** Date file was created. */
-  uint16_t creationDate;
-          /**
-           * Last access date. Note that there is no last access time, only
-           * a date.  This is the date of last read or write. In the case of
-           * a write, this should be set to the same date as lastWriteDate.
-           */
-  uint16_t lastAccessDate;
-          /**
-           * High word of this entry's first cluster number (always 0 for a
-           * FAT12 or FAT16 volume).
-           */
-  uint16_t firstClusterHigh;
-           /** Time of last write. File creation is considered a write. */
-  uint16_t lastWriteTime;
-           /** Date of last write. File creation is considered a write. */
-  uint16_t lastWriteDate;
-           /** Low word of this entry's first cluster number. */
-  uint16_t firstClusterLow;
-           /** 32-bit unsigned holding this file's size in bytes. */
-  uint32_t fileSize;
-} PACKED;
-/**
- * \struct directoryVFATEntry
- * \brief VFAT long filename directory entry
- *
- * directoryVFATEntries are found in the same list as normal directoryEntry.
- * But have the attribute field set to DIR_ATT_LONG_NAME.
- * 
- * Long filenames are saved in multiple directoryVFATEntries.
- * Each entry containing 13 UTF-16 characters.
- */
-struct directoryVFATEntry {
-  /**
-   * Sequence number. Consists of 2 parts:
-   *  bit 6:   indicates first long filename block for the next file
-   *  bit 0-4: the position of this long filename block (first block is 1)
-   */
-  uint8_t  sequenceNumber;
-  /** First set of UTF-16 characters */
-  uint16_t name1[5];//UTF-16
-  /** attributes (at the same location as in directoryEntry), always 0x0F */
-  uint8_t  attributes;
-  /** Reserved for use by Windows NT. Always 0. */
-  uint8_t  reservedNT;
-  /** Checksum of the short 8.3 filename, can be used to checked if the file system as modified by a not-long-filename aware implementation. */
-  uint8_t  checksum;
-  /** Second set of UTF-16 characters */
-  uint16_t name2[6];//UTF-16
-  /** firstClusterLow is always zero for longFilenames */
-  uint16_t firstClusterLow;
-  /** Third set of UTF-16 characters */
-  uint16_t name3[2];//UTF-16
-} PACKED;
-//------------------------------------------------------------------------------
-// Definitions for directory entries
-//
-/** Type name for directoryEntry */
-typedef struct directoryEntry dir_t;
-/** Type name for directoryVFATEntry */
-typedef struct directoryVFATEntry vfat_t;
-/** escape for name[0] = 0XE5 */
-uint8_t const DIR_NAME_0XE5 = 0X05;
-/** name[0] value for entry that is free after being "deleted" */
-uint8_t const DIR_NAME_DELETED = 0XE5;
-/** name[0] value for entry that is free and no allocated entries follow */
-uint8_t const DIR_NAME_FREE = 0X00;
-/** file is read-only */
-uint8_t const DIR_ATT_READ_ONLY = 0X01;
-/** File should hidden in directory listings */
-uint8_t const DIR_ATT_HIDDEN = 0X02;
-/** Entry is for a system file */
-uint8_t const DIR_ATT_SYSTEM = 0X04;
-/** Directory entry contains the volume label */
-uint8_t const DIR_ATT_VOLUME_ID = 0X08;
-/** Entry is for a directory */
-uint8_t const DIR_ATT_DIRECTORY = 0X10;
-/** Old DOS archive bit for backup support */
-uint8_t const DIR_ATT_ARCHIVE = 0X20;
-/** Test value for long name entry.  Test is
-  (d->attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME. */
-uint8_t const DIR_ATT_LONG_NAME = 0X0F;
-/** Test mask for long name entry */
-uint8_t const DIR_ATT_LONG_NAME_MASK = 0X3F;
-/** defined attribute bits */
-uint8_t const DIR_ATT_DEFINED_BITS = 0X3F;
-/** Directory entry is part of a long name
- * \param[in] dir Pointer to a directory entry.
- *
- * \return true if the entry is for part of a long name else false.
- */
-static inline uint8_t DIR_IS_LONG_NAME(const dir_t* dir) {
-  return (dir->attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME;
-}
-/** Mask for file/subdirectory tests */
-uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);
-/** Directory entry is for a file
- * \param[in] dir Pointer to a directory entry.
- *
- * \return true if the entry is for a normal file else false.
- */
-static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
-  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
-}
-/** Directory entry is for a subdirectory
- * \param[in] dir Pointer to a directory entry.
- *
- * \return true if the entry is for a subdirectory else false.
- */
-static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
-  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
-}
-/** Directory entry is for a file or subdirectory
- * \param[in] dir Pointer to a directory entry.
- *
- * \return true if the entry is for a normal file or subdirectory else false.
- */
-static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {
-  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
-}
-#endif  // SdFatStructs_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.cpp b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.cpp
deleted file mode 100644
index f6c825a..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2008 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#include "SdFat.h"
-#include <Print.h>
-#include "SdFatUtil.h"
-
-//------------------------------------------------------------------------------
-/** Amount of free RAM
- * \return The number of free bytes.
- */
-#ifdef __arm__
-extern "C" char* sbrk(int incr);
-int SdFatUtil::FreeRam() {
-  char top;
-  return &top - reinterpret_cast<char*>(sbrk(0));
-}
-#else  // __arm__
-extern char *__brkval;
-extern char __bss_end;
-/** Amount of free RAM
- * \return The number of free bytes.
- */
-int SdFatUtil::FreeRam() {
-  char top;
-  return __brkval ? &top - __brkval : &top - &__bss_end;
-}
-#endif  // __arm
-
-//------------------------------------------------------------------------------
-/** %Print a string in flash memory.
- *
- * \param[in] pr Print object for output.
- * \param[in] str Pointer to string stored in flash memory.
- */
-void SdFatUtil::print_P( Print *p, PGM_P str) {
-	Print &MYSERIAL = *p;
-  for (uint8_t c; (c = pgm_read_byte(str)); str++) MYSERIAL.write(c);
-}
-//------------------------------------------------------------------------------
-/** %Print a string in flash memory followed by a CR/LF.
- *
- * \param[in] pr Print object for output.
- * \param[in] str Pointer to string stored in flash memory.
- */
-void SdFatUtil::println_P( Print *p, PGM_P str) {
-	Print &MYSERIAL = *p;
-  print_P( p, str);
-  MYSERIAL.println();
-}
-//------------------------------------------------------------------------------
-/** %Print a string in flash memory to Serial.
- *
- * \param[in] str Pointer to string stored in flash memory.
- */
-void SdFatUtil::SerialPrint_P( Print *p, PGM_P str) {
-  print_P(p, str);
-}
-//------------------------------------------------------------------------------
-/** %Print a string in flash memory to Serial followed by a CR/LF.
- *
- * \param[in] str Pointer to string stored in flash memory.
- */
-void SdFatUtil::SerialPrintln_P(Print *p, PGM_P str) {
-  println_P( p, str);
-}
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.h
deleted file mode 100644
index 4265d8c..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFatUtil.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2008 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#ifndef SdFatUtil_h
-#define SdFatUtil_h
-/**
- * \file
- * \brief Useful utility functions.
- */
-
-namespace SdFatUtil {
-  int FreeRam();
-  void print_P( Print *p, PGM_P str);
-  void println_P( Print *p, PGM_P str);
-  void SerialPrint_P(Print *p, PGM_P str);
-  void SerialPrintln_P(Print *p, PGM_P str);
-}
-using namespace SdFatUtil;  // NOLINT
-#endif  // #define SdFatUtil_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.cpp b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.cpp
deleted file mode 100644
index 09e2fba..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.cpp
+++ /dev/null
@@ -1,89 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#include "SdFile.h"
-/**  Create a file object and open it in the current working directory.
- *
- * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
- *
- * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
- * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
- */
-SdFile::SdFile(const char* path, uint8_t oflag) : SdBaseFile(path, oflag) {
-}
-//------------------------------------------------------------------------------
-/** Write data to an open file.
- *
- * \note Data is moved to the cache but may not be written to the
- * storage device until sync() is called.
- *
- * \param[in] buf Pointer to the location of the data to be written.
- *
- * \param[in] nbyte Number of bytes to write.
- *
- * \return For success write() returns the number of bytes written, always
- * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
- * include write() is called before a file has been opened, write is called
- * for a read-only file, device is full, a corrupt file system or an I/O error.
- *
- */
-int16_t SdFile::write(const void* buf, uint16_t nbyte) {
-  return SdBaseFile::write(buf, nbyte);
-}
-//------------------------------------------------------------------------------
-/** Write a byte to a file. Required by the Arduino Print class.
- * \param[in] b the byte to be written.
- * Use writeError to check for errors.
- */
-#if ARDUINO >= 100
-size_t SdFile::write(uint8_t b)
-{
-    return SdBaseFile::write(&b, 1);
-}
-#else
-void SdFile::write(uint8_t b)
-{
-    SdBaseFile::write(&b, 1);
-}
-#endif
-//------------------------------------------------------------------------------
-/** Write a string to a file. Used by the Arduino Print class.
- * \param[in] str Pointer to the string.
- * Use writeError to check for errors.
- */
-void SdFile::write(const char* str) {
-  SdBaseFile::write(str, strlen(str));
-}
-//------------------------------------------------------------------------------
-/** Write a PROGMEM string to a file.
- * \param[in] str Pointer to the PROGMEM string.
- * Use writeError to check for errors.
- */
-void SdFile::write_P(PGM_P str) {
-  for (uint8_t c; (c = pgm_read_byte(str)); str++) write(c);
-}
-//------------------------------------------------------------------------------
-/** Write a PROGMEM string followed by CR/LF to a file.
- * \param[in] str Pointer to the PROGMEM string.
- * Use writeError to check for errors.
- */
-void SdFile::writeln_P(PGM_P str) {
-  write_P(str);
-  write_P(PSTR("\r\n"));
-}
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.h
deleted file mode 100644
index f0611c4..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdFile.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-/**
- * \file
- * \brief SdFile class
- */
-#include "SdBaseFile.h"
-#include <Print.h>
-#ifndef SdFile_h
-#define SdFile_h
-//------------------------------------------------------------------------------
-/**
- * \class SdFile
- * \brief SdBaseFile with Print.
- */
-class SdFile : public SdBaseFile, public Print {
- public:
-  SdFile() {}
-  SdFile(const char* name, uint8_t oflag);
-  #if ARDUINO >= 100
-      size_t write(uint8_t b);
-  #else
-   void write(uint8_t b);
-  #endif
-  
-  int16_t write(const void* buf, uint16_t nbyte);
-  void write(const char* str);
-  void write_P(PGM_P str);
-  void writeln_P(PGM_P str);
-};
-#endif  // SdFile_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdInfo.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdInfo.h
deleted file mode 100644
index 2a58eb7..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdInfo.h
+++ /dev/null
@@ -1,275 +0,0 @@
-/* Arduino Sd2Card Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino Sd2Card Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino Sd2Card Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#ifndef SdInfo_h
-#define SdInfo_h
-#include <stdint.h>
-// Based on the document:
-//
-// SD Specifications
-// Part 1
-// Physical Layer
-// Simplified Specification
-// Version 3.01
-// May 18, 2010
-//
-// http://www.sdcard.org/developers/tech/sdcard/pls/simplified_specs
-//------------------------------------------------------------------------------
-// SD card commands
-/** GO_IDLE_STATE - init card in spi mode if CS low */
-uint8_t const CMD0 = 0X00;
-/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/
-uint8_t const CMD8 = 0X08;
-/** SEND_CSD - read the Card Specific Data (CSD register) */
-uint8_t const CMD9 = 0X09;
-/** SEND_CID - read the card identification information (CID register) */
-uint8_t const CMD10 = 0X0A;
-/** STOP_TRANSMISSION - end multiple block read sequence */
-uint8_t const CMD12 = 0X0C;
-/** SEND_STATUS - read the card status register */
-uint8_t const CMD13 = 0X0D;
-/** READ_SINGLE_BLOCK - read a single data block from the card */
-uint8_t const CMD17 = 0X11;
-/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */
-uint8_t const CMD18 = 0X12;
-/** WRITE_BLOCK - write a single data block to the card */
-uint8_t const CMD24 = 0X18;
-/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */
-uint8_t const CMD25 = 0X19;
-/** ERASE_WR_BLK_START - sets the address of the first block to be erased */
-uint8_t const CMD32 = 0X20;
-/** ERASE_WR_BLK_END - sets the address of the last block of the continuous
-    range to be erased*/
-uint8_t const CMD33 = 0X21;
-/** ERASE - erase all previously selected blocks */
-uint8_t const CMD38 = 0X26;
-/** APP_CMD - escape for application specific command */
-uint8_t const CMD55 = 0X37;
-/** READ_OCR - read the OCR register of a card */
-uint8_t const CMD58 = 0X3A;
-/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be
-     pre-erased before writing */
-uint8_t const ACMD23 = 0X17;
-/** SD_SEND_OP_COMD - Sends host capacity support information and
-    activates the card's initialization process */
-uint8_t const ACMD41 = 0X29;
-//------------------------------------------------------------------------------
-/** status for card in the ready state */
-uint8_t const R1_READY_STATE = 0X00;
-/** status for card in the idle state */
-uint8_t const R1_IDLE_STATE = 0X01;
-/** status bit for illegal command */
-uint8_t const R1_ILLEGAL_COMMAND = 0X04;
-/** start data token for read or write single block*/
-uint8_t const DATA_START_BLOCK = 0XFE;
-/** stop token for write multiple blocks*/
-uint8_t const STOP_TRAN_TOKEN = 0XFD;
-/** start data token for write multiple blocks*/
-uint8_t const WRITE_MULTIPLE_TOKEN = 0XFC;
-/** mask for data response tokens after a write block operation */
-uint8_t const DATA_RES_MASK = 0X1F;
-/** write data accepted token */
-uint8_t const DATA_RES_ACCEPTED = 0X05;
-//------------------------------------------------------------------------------
-/** Card IDentification (CID) register */
-typedef struct CID {
-  // byte 0
-  /** Manufacturer ID */
-  unsigned char mid;
-  // byte 1-2
-  /** OEM/Application ID */
-  char oid[2];
-  // byte 3-7
-  /** Product name */
-  char pnm[5];
-  // byte 8
-  /** Product revision least significant digit */
-  unsigned char prv_m : 4;
-  /** Product revision most significant digit */
-  unsigned char prv_n : 4;
-  // byte 9-12
-  /** Product serial number */
-  uint32_t psn;
-  // byte 13
-  /** Manufacturing date year low digit */
-  unsigned char mdt_year_high : 4;
-  /** not used */
-  unsigned char reserved : 4;
-  // byte 14
-  /** Manufacturing date month */
-  unsigned char mdt_month : 4;
-  /** Manufacturing date year low digit */
-  unsigned char mdt_year_low :4;
-  // byte 15
-  /** not used always 1 */
-  unsigned char always1 : 1;
-  /** CRC7 checksum */
-  unsigned char crc : 7;
-}cid_t;
-//------------------------------------------------------------------------------
-/** CSD for version 1.00 cards */
-typedef struct CSDV1 {
-  // byte 0
-  unsigned char reserved1 : 6;
-  unsigned char csd_ver : 2;
-  // byte 1
-  unsigned char taac;
-  // byte 2
-  unsigned char nsac;
-  // byte 3
-  unsigned char tran_speed;
-  // byte 4
-  unsigned char ccc_high;
-  // byte 5
-  unsigned char read_bl_len : 4;
-  unsigned char ccc_low : 4;
-  // byte 6
-  unsigned char c_size_high : 2;
-  unsigned char reserved2 : 2;
-  unsigned char dsr_imp : 1;
-  unsigned char read_blk_misalign :1;
-  unsigned char write_blk_misalign : 1;
-  unsigned char read_bl_partial : 1;
-  // byte 7
-  unsigned char c_size_mid;
-  // byte 8
-  unsigned char vdd_r_curr_max : 3;
-  unsigned char vdd_r_curr_min : 3;
-  unsigned char c_size_low :2;
-  // byte 9
-  unsigned char c_size_mult_high : 2;
-  unsigned char vdd_w_cur_max : 3;
-  unsigned char vdd_w_curr_min : 3;
-  // byte 10
-  unsigned char sector_size_high : 6;
-  unsigned char erase_blk_en : 1;
-  unsigned char c_size_mult_low : 1;
-  // byte 11
-  unsigned char wp_grp_size : 7;
-  unsigned char sector_size_low : 1;
-  // byte 12
-  unsigned char write_bl_len_high : 2;
-  unsigned char r2w_factor : 3;
-  unsigned char reserved3 : 2;
-  unsigned char wp_grp_enable : 1;
-  // byte 13
-  unsigned char reserved4 : 5;
-  unsigned char write_partial : 1;
-  unsigned char write_bl_len_low : 2;
-  // byte 14
-  unsigned char reserved5: 2;
-  unsigned char file_format : 2;
-  unsigned char tmp_write_protect : 1;
-  unsigned char perm_write_protect : 1;
-  unsigned char copy : 1;
-  /** Indicates the file format on the card */
-  unsigned char file_format_grp : 1;
-  // byte 15
-  unsigned char always1 : 1;
-  unsigned char crc : 7;
-}csd1_t;
-//------------------------------------------------------------------------------
-/** CSD for version 2.00 cards */
-typedef struct CSDV2 {
-  // byte 0
-  unsigned char reserved1 : 6;
-  unsigned char csd_ver : 2;
-  // byte 1
-  /** fixed to 0X0E */
-  unsigned char taac;
-  // byte 2
-  /** fixed to 0 */
-  unsigned char nsac;
-  // byte 3
-  unsigned char tran_speed;
-  // byte 4
-  unsigned char ccc_high;
-  // byte 5
-  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */
-  unsigned char read_bl_len : 4;
-  unsigned char ccc_low : 4;
-  // byte 6
-  /** not used */
-  unsigned char reserved2 : 4;
-  unsigned char dsr_imp : 1;
-  /** fixed to 0 */
-  unsigned char read_blk_misalign :1;
-  /** fixed to 0 */
-  unsigned char write_blk_misalign : 1;
-  /** fixed to 0 - no partial read */
-  unsigned char read_bl_partial : 1;
-  // byte 7
-  /** not used */
-  unsigned char reserved3 : 2;
-  /** high part of card size */
-  unsigned char c_size_high : 6;
-  // byte 8
-  /** middle part of card size */
-  unsigned char c_size_mid;
-  // byte 9
-  /** low part of card size */
-  unsigned char c_size_low;
-  // byte 10
-  /** sector size is fixed at 64 KB */
-  unsigned char sector_size_high : 6;
-  /** fixed to 1 - erase single is supported */
-  unsigned char erase_blk_en : 1;
-  /** not used */
-  unsigned char reserved4 : 1;
-  // byte 11
-  unsigned char wp_grp_size : 7;
-  /** sector size is fixed at 64 KB */
-  unsigned char sector_size_low : 1;
-  // byte 12
-  /** write_bl_len fixed for 512 byte blocks */
-  unsigned char write_bl_len_high : 2;
-  /** fixed value of 2 */
-  unsigned char r2w_factor : 3;
-  /** not used */
-  unsigned char reserved5 : 2;
-  /** fixed value of 0 - no write protect groups */
-  unsigned char wp_grp_enable : 1;
-  // byte 13
-  unsigned char reserved6 : 5;
-  /** always zero - no partial block read*/
-  unsigned char write_partial : 1;
-  /** write_bl_len fixed for 512 byte blocks */
-  unsigned char write_bl_len_low : 2;
-  // byte 14
-  unsigned char reserved7: 2;
-  /** Do not use always 0 */
-  unsigned char file_format : 2;
-  unsigned char tmp_write_protect : 1;
-  unsigned char perm_write_protect : 1;
-  unsigned char copy : 1;
-  /** Do not use always 0 */
-  unsigned char file_format_grp : 1;
-  // byte 15
-  /** not used always 1 */
-  unsigned char always1 : 1;
-  /** checksum */
-  unsigned char crc : 7;
-}csd2_t;
-//------------------------------------------------------------------------------
-/** union of old and new style CSD register */
-union csd_t {
-  csd1_t v1;
-  csd2_t v2;
-};
-#endif  // SdInfo_h
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.cpp b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.cpp
deleted file mode 100644
index 3c84c18..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.cpp
+++ /dev/null
@@ -1,402 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#include "SdFat.h"
-#include "SdVolume.h"
-//------------------------------------------------------------------------------
-#if !USE_MULTIPLE_CARDS
-// raw block cache
-uint32_t SdVolume::cacheBlockNumber_;  // current block number
-cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card
-Sd2Card* SdVolume::sdCard_;            // pointer to SD card object
-bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
-uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
-#endif  // USE_MULTIPLE_CARDS
-//------------------------------------------------------------------------------
-// find a contiguous group of clusters
-bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
-  // start of group
-  uint32_t bgnCluster;
-  // end of group
-  uint32_t endCluster;
-  // last cluster of FAT
-  uint32_t fatEnd = clusterCount_ + 1;
-
-  // flag to save place to start next search
-  bool setStart;
-
-  // set search start cluster
-  if (*curCluster) {
-    // try to make file contiguous
-    bgnCluster = *curCluster + 1;
-
-    // don't save new start location
-    setStart = false;
-  } else {
-    // start at likely place for free cluster
-    bgnCluster = allocSearchStart_;
-
-    // save next search start if one cluster
-    setStart = count == 1;
-  }
-  // end of group
-  endCluster = bgnCluster;
-
-  // search the FAT for free clusters
-  for (uint32_t n = 0;; n++, endCluster++) {
-    // can't find space checked all clusters
-    if (n >= clusterCount_) goto fail;
-
-    // past end - start from beginning of FAT
-    if (endCluster > fatEnd) {
-      bgnCluster = endCluster = 2;
-    }
-    uint32_t f;
-    if (!fatGet(endCluster, &f)) goto fail;
-
-    if (f != 0) {
-      // cluster in use try next cluster as bgnCluster
-      bgnCluster = endCluster + 1;
-    } else if ((endCluster - bgnCluster + 1) == count) {
-      // done - found space
-      break;
-    }
-  }
-  // mark end of chain
-  if (!fatPutEOC(endCluster)) goto fail;
-
-  // link clusters
-  while (endCluster > bgnCluster) {
-    if (!fatPut(endCluster - 1, endCluster)) goto fail;
-    endCluster--;
-  }
-  if (*curCluster != 0) {
-    // connect chains
-    if (!fatPut(*curCluster, bgnCluster)) goto fail;
-  }
-  // return first cluster number to caller
-  *curCluster = bgnCluster;
-
-  // remember possible next free cluster
-  if (setStart) allocSearchStart_ = bgnCluster + 1;
-
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-bool SdVolume::cacheFlush() {
-  if (cacheDirty_) {
-    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
-      goto fail;
-    }
-    // mirror FAT tables
-    if (cacheMirrorBlock_) {
-      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
-        goto fail;
-      }
-      cacheMirrorBlock_ = 0;
-    }
-    cacheDirty_ = 0;
-  }
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
-  if (cacheBlockNumber_ != blockNumber) {
-    if (!cacheFlush()) goto fail;
-    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) goto fail;
-    cacheBlockNumber_ = blockNumber;
-  }
-  if (dirty) cacheDirty_ = true;
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// return the size in bytes of a cluster chain
-bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
-  uint32_t s = 0;
-  do {
-    if (!fatGet(cluster, &cluster)) goto fail;
-    s += 512UL << clusterSizeShift_;
-  } while (!isEOC(cluster));
-  *size = s;
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// Fetch a FAT entry
-bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
-  uint32_t lba;
-  if (cluster > (clusterCount_ + 1)) goto fail;
-  if (FAT12_SUPPORT && fatType_ == 12) {
-    uint16_t index = cluster;
-    index += index >> 1;
-    lba = fatStartBlock_ + (index >> 9);
-    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
-    index &= 0X1FF;
-    uint16_t tmp = cacheBuffer_.data[index];
-    index++;
-    if (index == 512) {
-      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto fail;
-      index = 0;
-    }
-    tmp |= cacheBuffer_.data[index] << 8;
-    *value = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
-    return true;
-  }
-  if (fatType_ == 16) {
-    lba = fatStartBlock_ + (cluster >> 8);
-  } else if (fatType_ == 32) {
-    lba = fatStartBlock_ + (cluster >> 7);
-  } else {
-    goto fail;
-  }
-  if (lba != cacheBlockNumber_) {
-    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
-  }
-  if (fatType_ == 16) {
-    *value = cacheBuffer_.fat16[cluster & 0XFF];
-  } else {
-    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
-  }
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// Store a FAT entry
-bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
-  uint32_t lba;
-  // error if reserved cluster
-  if (cluster < 2) goto fail;
-
-  // error if not in FAT
-  if (cluster > (clusterCount_ + 1)) goto fail;
-
-  if (FAT12_SUPPORT && fatType_ == 12) {
-    uint16_t index = cluster;
-    index += index >> 1;
-    lba = fatStartBlock_ + (index >> 9);
-    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
-    // mirror second FAT
-    if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
-    index &= 0X1FF;
-    uint8_t tmp = value;
-    if (cluster & 1) {
-      tmp = (cacheBuffer_.data[index] & 0XF) | tmp << 4;
-    }
-    cacheBuffer_.data[index] = tmp;
-    index++;
-    if (index == 512) {
-      lba++;
-      index = 0;
-      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
-      // mirror second FAT
-      if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
-    }
-    tmp = value >> 4;
-    if (!(cluster & 1)) {
-      tmp = ((cacheBuffer_.data[index] & 0XF0)) | tmp >> 4;
-    }
-    cacheBuffer_.data[index] = tmp;
-    return true;
-  }
-  if (fatType_ == 16) {
-    lba = fatStartBlock_ + (cluster >> 8);
-  } else if (fatType_ == 32) {
-    lba = fatStartBlock_ + (cluster >> 7);
-  } else {
-    goto fail;
-  }
-  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
-  // store entry
-  if (fatType_ == 16) {
-    cacheBuffer_.fat16[cluster & 0XFF] = value;
-  } else {
-    cacheBuffer_.fat32[cluster & 0X7F] = value;
-  }
-  // mirror second FAT
-  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-// free a cluster chain
-bool SdVolume::freeChain(uint32_t cluster) {
-  uint32_t next;
-
-  // clear free cluster location
-  allocSearchStart_ = 2;
-
-  do {
-    if (!fatGet(cluster, &next)) goto fail;
-
-    // free cluster
-    if (!fatPut(cluster, 0)) goto fail;
-
-    cluster = next;
-  } while (!isEOC(cluster));
-
-  return true;
-
- fail:
-  return false;
-}
-//------------------------------------------------------------------------------
-/** Volume free space in clusters.
- *
- * \return Count of free clusters for success or -1 if an error occurs.
- */
-int32_t SdVolume::freeClusterCount() {
-  uint32_t free = 0;
-  uint16_t n;
-  uint32_t todo = clusterCount_ + 2;
-
-  if (fatType_ == 16) {
-    n = 256;
-  } else if (fatType_ == 32) {
-    n = 128;
-  } else {
-    // put FAT12 here
-    return -1;
-  }
-
-  for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {
-    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;
-    if (todo < n) n = todo;
-    if (fatType_ == 16) {
-      for (uint16_t i = 0; i < n; i++) {
-        if (cacheBuffer_.fat16[i] == 0) free++;
-      }
-    } else {
-      for (uint16_t i = 0; i < n; i++) {
-        if (cacheBuffer_.fat32[i] == 0) free++;
-      }
-    }
-  }
-  return free;
-}
-//------------------------------------------------------------------------------
-/** Initialize a FAT volume.
- *
- * \param[in] dev The SD card where the volume is located.
- *
- * \param[in] part The partition to be used.  Legal values for \a part are
- * 1-4 to use the corresponding partition on a device formatted with
- * a MBR, Master Boot Record, or zero if the device is formatted as
- * a super floppy with the FAT boot sector in block zero.
- *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.  Reasons for
- * failure include not finding a valid partition, not finding a valid
- * FAT file system in the specified partition or an I/O error.
- */
-bool SdVolume::init(Sd2Card* dev, uint8_t part) {
-  uint32_t totalBlocks;
-  uint32_t volumeStartBlock = 0;
-  fat32_boot_t* fbs;
-
-  sdCard_ = dev;
-  fatType_ = 0;
-  allocSearchStart_ = 2;
-  cacheDirty_ = 0;  // cacheFlush() will write block if true
-  cacheMirrorBlock_ = 0;
-  cacheBlockNumber_ = 0XFFFFFFFF;
-
-  // if part == 0 assume super floppy with FAT boot sector in block zero
-  // if part > 0 assume mbr volume with partition table
-  if (part) {
-    if (part > 4)goto fail;
-    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
-    part_t* p = &cacheBuffer_.mbr.part[part-1];
-    if ((p->boot & 0X7F) !=0  ||
-      p->totalSectors < 100 ||
-      p->firstSector == 0) {
-      // not a valid partition
-      goto fail;
-    }
-    volumeStartBlock = p->firstSector;
-  }
-  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
-  fbs = &cacheBuffer_.fbs32;
-  if (fbs->bytesPerSector != 512 ||
-    fbs->fatCount == 0 ||
-    fbs->reservedSectorCount == 0 ||
-    fbs->sectorsPerCluster == 0) {
-       // not valid FAT volume
-      goto fail;
-  }
-  fatCount_ = fbs->fatCount;
-  blocksPerCluster_ = fbs->sectorsPerCluster;
-  // determine shift that is same as multiply by blocksPerCluster_
-  clusterSizeShift_ = 0;
-  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
-    // error if not power of 2
-    if (clusterSizeShift_++ > 7) goto fail;
-  }
-  blocksPerFat_ = fbs->sectorsPerFat16 ?
-                    fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
-
-  fatStartBlock_ = volumeStartBlock + fbs->reservedSectorCount;
-
-  // count for FAT16 zero for FAT32
-  rootDirEntryCount_ = fbs->rootDirEntryCount;
-
-  // directory start for FAT16 dataStart for FAT32
-  rootDirStart_ = fatStartBlock_ + fbs->fatCount * blocksPerFat_;
-
-  // data start for FAT16 and FAT32
-  dataStartBlock_ = rootDirStart_ + ((32 * fbs->rootDirEntryCount + 511)/512);
-
-  // total blocks for FAT16 or FAT32
-  totalBlocks = fbs->totalSectors16 ?
-                           fbs->totalSectors16 : fbs->totalSectors32;
-  // total data blocks
-  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
-
-  // divide by cluster size to get cluster count
-  clusterCount_ >>= clusterSizeShift_;
-
-  // FAT type is determined by cluster count
-  if (clusterCount_ < 4085) {
-    fatType_ = 12;
-    if (!FAT12_SUPPORT) goto fail;
-  } else if (clusterCount_ < 65525) {
-    fatType_ = 16;
-  } else {
-    rootDirStart_ = fbs->fat32RootCluster;
-    fatType_ = 32;
-  }
-  return true;
-
- fail:
-  return false;
-}
diff --git a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.h b/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.h
deleted file mode 100644
index 0f2e55a..0000000
--- a/ArduinoAddons/Arduino_1.0.x/libraries/SdFat/SdVolume.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/* Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
- *
- * This file is part of the Arduino SdFat Library
- *
- * This Library is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This Library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with the Arduino SdFat Library.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-#ifndef SdVolume_h
-#define SdVolume_h
-/**
- * \file
- * \brief SdVolume class
- */
-#include "SdFatConfig.h"
-#include "Sd2Card.h"
-#include "SdFatStructs.h"
-
-//==============================================================================
-// SdVolume class
-/**
- * \brief Cache for an SD data block
- */
-union cache_t {
-           /** Used to access cached file data blocks. */
-  uint8_t  data[512];
-           /** Used to access cached FAT16 entries. */
-  uint16_t fat16[256];
-           /** Used to access cached FAT32 entries. */
-  uint32_t fat32[128];
-           /** Used to access cached directory entries. */
-  dir_t    dir[16];
-           /** Used to access a cached Master Boot Record. */
-  mbr_t    mbr;
-           /** Used to access to a cached FAT boot sector. */
-  fat_boot_t fbs;
-           /** Used to access to a cached FAT32 boot sector. */
-  fat32_boot_t fbs32;
-           /** Used to access to a cached FAT32 FSINFO sector. */
-  fat32_fsinfo_t fsinfo;
-};
-//------------------------------------------------------------------------------
-/**
- * \class SdVolume
- * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
- */
-class SdVolume {
- public:
-  /** Create an instance of SdVolume */
-  SdVolume() : fatType_(0) {}
-  /** Clear the cache and returns a pointer to the cache.  Used by the WaveRP
-   * recorder to do raw write to the SD card.  Not for normal apps.
-   * \return A pointer to the cache buffer or zero if an error occurs.
-   */
-  cache_t* cacheClear() {
-    if (!cacheFlush()) return 0;
-    cacheBlockNumber_ = 0XFFFFFFFF;
-    return &cacheBuffer_;
-  }
-  /** Initialize a FAT volume.  Try partition one first then try super
-   * floppy format.
-   *
-   * \param[in] dev The Sd2Card where the volume is located.
-   *
-   * \return The value one, true, is returned for success and
-   * the value zero, false, is returned for failure.  Reasons for
-   * failure include not finding a valid partition, not finding a valid
-   * FAT file system or an I/O error.
-   */
-  bool init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
-  bool init(Sd2Card* dev, uint8_t part);
-
-  // inline functions that return volume info
-  /** \return The volume's cluster size in blocks. */
-  uint8_t blocksPerCluster() const {return blocksPerCluster_;}
-  /** \return The number of blocks in one FAT. */
-  uint32_t blocksPerFat()  const {return blocksPerFat_;}
-  /** \return The total number of clusters in the volume. */
-  uint32_t clusterCount() const {return clusterCount_;}
-  /** \return The shift count required to multiply by blocksPerCluster. */
-  uint8_t clusterSizeShift() const {return clusterSizeShift_;}
-  /** \return The logical block number for the start of file data. */
-  uint32_t dataStartBlock() const {return dataStartBlock_;}
-  /** \return The number of FAT structures on the volume. */
-  uint8_t fatCount() const {return fatCount_;}
-  /** \return The logical block number for the start of the first FAT. */
-  uint32_t fatStartBlock() const {return fatStartBlock_;}
-  /** \return The FAT type of the volume. Values are 12, 16 or 32. */
-  uint8_t fatType() const {return fatType_;}
-  int32_t freeClusterCount();
-  /** \return The number of entries in the root directory for FAT16 volumes. */
-  uint32_t rootDirEntryCount() const {return rootDirEntryCount_;}
-  /** \return The logical block number for the start of the root directory
-       on FAT16 volumes or the first cluster number on FAT32 volumes. */
-  uint32_t rootDirStart() const {return rootDirStart_;}
-  /** Sd2Card object for this volume
-   * \return pointer to Sd2Card object.
-   */
-  Sd2Card* sdCard() {return sdCard_;}
-  /** Debug access to FAT table
-   *
-   * \param[in] n cluster number.
-   * \param[out] v value of entry
-   * \return true for success or false for failure
-   */
-  bool dbgFat(uint32_t n, uint32_t* v) {return fatGet(n, v);}
-//------------------------------------------------------------------------------
- private:
-  // Allow SdBaseFile access to SdVolume private data.
-  friend class SdBaseFile;
-
-  // value for dirty argument in cacheRawBlock to indicate read from cache
-  static bool const CACHE_FOR_READ = false;
-  // value for dirty argument in cacheRawBlock to indicate write to cache
-  static bool const CACHE_FOR_WRITE = true;
-
-#if USE_MULTIPLE_CARDS
-  cache_t cacheBuffer_;        // 512 byte cache for device blocks
-  uint32_t cacheBlockNumber_;  // Logical number of block in the cache
-  Sd2Card* sdCard_;            // Sd2Card object for cache
-  bool cacheDirty_;            // cacheFlush() will write block if true
-  uint32_t cacheMirrorBlock_;  // block number for mirror FAT
-#else  // USE_MULTIPLE_CARDS
-  static cache_t cacheBuffer_;        // 512 byte cache for device blocks
-  static uint32_t cacheBlockNumber_;  // Logical number of block in the cache
-  static Sd2Card* sdCard_;            // Sd2Card object for cache
-  static bool cacheDirty_;            // cacheFlush() will write block if true
-  static uint32_t cacheMirrorBlock_;  // block number for mirror FAT
-#endif  // USE_MULTIPLE_CARDS
-  uint32_t allocSearchStart_;   // start cluster for alloc search
-  uint8_t blocksPerCluster_;    // cluster size in blocks
-  uint32_t blocksPerFat_;       // FAT size in blocks
-  uint32_t clusterCount_;       // clusters in one FAT
-  uint8_t clusterSizeShift_;    // shift to convert cluster count to block count
-  uint32_t dataStartBlock_;     // first data block number
-  uint8_t fatCount_;            // number of FATs on volume
-  uint32_t fatStartBlock_;      // start block for first FAT
-  uint8_t fatType_;             // volume type (12, 16, OR 32)
-  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
-  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
-  //----------------------------------------------------------------------------
-  bool allocContiguous(uint32_t count, uint32_t* curCluster);
-  uint8_t blockOfCluster(uint32_t position) const {
-          return (position >> 9) & (blocksPerCluster_ - 1);}
-  uint32_t clusterStartBlock(uint32_t cluster) const {
-           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
-  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
-           return clusterStartBlock(cluster) + blockOfCluster(position);}
-  cache_t *cache() {return &cacheBuffer_;}
-  uint32_t cacheBlockNumber() {return cacheBlockNumber_;}
-#if USE_MULTIPLE_CARDS
-  bool cacheFlush();
-  bool cacheRawBlock(uint32_t blockNumber, bool dirty);
-#else  // USE_MULTIPLE_CARDS
-  static bool cacheFlush();
-  static bool cacheRawBlock(uint32_t blockNumber, bool dirty);
-#endif  // USE_MULTIPLE_CARDS
-  // used by SdBaseFile write to assign cache to SD location
-  void cacheSetBlockNumber(uint32_t blockNumber, bool dirty) {
-    cacheDirty_ = dirty;
-    cacheBlockNumber_  = blockNumber;
-  }
-  void cacheSetDirty() {cacheDirty_ |= CACHE_FOR_WRITE;}
-  bool chainSize(uint32_t beginCluster, uint32_t* size);
-  bool fatGet(uint32_t cluster, uint32_t* value);
-  bool fatPut(uint32_t cluster, uint32_t value);
-  bool fatPutEOC(uint32_t cluster) {
-    return fatPut(cluster, 0x0FFFFFFF);
-  }
-  bool freeChain(uint32_t cluster);
-  bool isEOC(uint32_t cluster) const {
-    if (FAT12_SUPPORT && fatType_ == 12) return  cluster >= FAT12EOC_MIN;
-    if (fatType_ == 16) return cluster >= FAT16EOC_MIN;
-    return  cluster >= FAT32EOC_MIN;
-  }
-  bool readBlock(uint32_t block, uint8_t* dst) {
-    return sdCard_->readBlock(block, dst);}
-  bool writeBlock(uint32_t block, const uint8_t* dst) {
-    return sdCard_->writeBlock(block, dst);
-  }
-//------------------------------------------------------------------------------
-  // Deprecated functions  - suppress cpplint warnings with NOLINT comment
-#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
- public:
-  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev);
-   * \param[in] dev The SD card where the volume is located.
-   * \return true for success or false for failure.
-   */
-  bool init(Sd2Card& dev) {return init(&dev);}  // NOLINT
-  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev, uint8_t vol);
-   * \param[in] dev The SD card where the volume is located.
-   * \param[in] part The partition to be used.
-   * \return true for success or false for failure.
-   */
-  bool init(Sd2Card& dev, uint8_t part) {  // NOLINT
-    return init(&dev, part);
-  }
-#endif  // ALLOW_DEPRECATED_FUNCTIONS
-};
-#endif  // SdVolume
diff --git a/Marlin/Marlin.pde b/Marlin/Marlin.pde
index f65681f..79c934b 100644
--- a/Marlin/Marlin.pde
+++ b/Marlin/Marlin.pde
@@ -54,8 +54,3 @@
 #if defined(DIGIPOT_I2C)
   #include <Wire.h>
 #endif
-
-#if defined(HEATER_0_USES_MAX6675) || defined(SDSUPPORT)
-#include <Sd2Card.h>
-#endif
-
diff --git a/Marlin/Sd2Card.cpp b/Marlin/Sd2Card.cpp
new file mode 100644
index 0000000..69ae777
--- /dev/null
+++ b/Marlin/Sd2Card.cpp
@@ -0,0 +1,723 @@
+/* Arduino Sd2Card Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino Sd2Card Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+
+#ifdef SDSUPPORT
+#include "Sd2Card.h"
+//------------------------------------------------------------------------------
+#ifndef SOFTWARE_SPI
+// functions for hardware SPI
+//------------------------------------------------------------------------------
+// make sure SPCR rate is in expected bits
+#if (SPR0 != 0 || SPR1 != 1)
+#error unexpected SPCR bits
+#endif
+/**
+ * Initialize hardware SPI
+ * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]
+ */
+static void spiInit(uint8_t spiRate) {
+  // See avr processor documentation
+  SPCR = (1 << SPE) | (1 << MSTR) | (spiRate >> 1);
+  SPSR = spiRate & 1 || spiRate == 6 ? 0 : 1 << SPI2X;
+}
+//------------------------------------------------------------------------------
+/** SPI receive a byte */
+static uint8_t spiRec() {
+  SPDR = 0XFF;
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+  return SPDR;
+}
+//------------------------------------------------------------------------------
+/** SPI read data - only one call so force inline */
+static inline __attribute__((always_inline))
+void spiRead(uint8_t* buf, uint16_t nbyte) {
+  if (nbyte-- == 0) return;
+  SPDR = 0XFF;
+  for (uint16_t i = 0; i < nbyte; i++) {
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+    buf[i] = SPDR;
+    SPDR = 0XFF;
+  }
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+  buf[nbyte] = SPDR;
+}
+//------------------------------------------------------------------------------
+/** SPI send a byte */
+static void spiSend(uint8_t b) {
+  SPDR = b;
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+}
+//------------------------------------------------------------------------------
+/** SPI send block - only one call so force inline */
+static inline __attribute__((always_inline))
+  void spiSendBlock(uint8_t token, const uint8_t* buf) {
+  SPDR = token;
+  for (uint16_t i = 0; i < 512; i += 2) {
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+    SPDR = buf[i];
+    while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+    SPDR = buf[i + 1];
+  }
+  while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
+}
+//------------------------------------------------------------------------------
+#else  // SOFTWARE_SPI
+//------------------------------------------------------------------------------
+/** nop to tune soft SPI timing */
+#define nop asm volatile ("nop\n\t")
+//------------------------------------------------------------------------------
+/** Soft SPI receive byte */
+static uint8_t spiRec() {
+  uint8_t data = 0;
+  // no interrupts during byte receive - about 8 us
+  cli();
+  // output pin high - like sending 0XFF
+  fastDigitalWrite(SPI_MOSI_PIN, HIGH);
+
+  for (uint8_t i = 0; i < 8; i++) {
+    fastDigitalWrite(SPI_SCK_PIN, HIGH);
+
+    // adjust so SCK is nice
+    nop;
+    nop;
+
+    data <<= 1;
+
+    if (fastDigitalRead(SPI_MISO_PIN)) data |= 1;
+
+    fastDigitalWrite(SPI_SCK_PIN, LOW);
+  }
+  // enable interrupts
+  sei();
+  return data;
+}
+//------------------------------------------------------------------------------
+/** Soft SPI read data */
+static void spiRead(uint8_t* buf, uint16_t nbyte) {
+  for (uint16_t i = 0; i < nbyte; i++) {
+    buf[i] = spiRec();
+  }
+}
+//------------------------------------------------------------------------------
+/** Soft SPI send byte */
+static void spiSend(uint8_t data) {
+  // no interrupts during byte send - about 8 us
+  cli();
+  for (uint8_t i = 0; i < 8; i++) {
+    fastDigitalWrite(SPI_SCK_PIN, LOW);
+
+    fastDigitalWrite(SPI_MOSI_PIN, data & 0X80);
+
+    data <<= 1;
+
+    fastDigitalWrite(SPI_SCK_PIN, HIGH);
+  }
+  // hold SCK high for a few ns
+  nop;
+  nop;
+  nop;
+  nop;
+
+  fastDigitalWrite(SPI_SCK_PIN, LOW);
+  // enable interrupts
+  sei();
+}
+//------------------------------------------------------------------------------
+/** Soft SPI send block */
+  void spiSendBlock(uint8_t token, const uint8_t* buf) {
+  spiSend(token);
+  for (uint16_t i = 0; i < 512; i++) {
+    spiSend(buf[i]);
+  }
+}
+#endif  // SOFTWARE_SPI
+//------------------------------------------------------------------------------
+// send command and return error code.  Return zero for OK
+uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
+  // select card
+  chipSelectLow();
+
+  // wait up to 300 ms if busy
+  waitNotBusy(300);
+
+  // send command
+  spiSend(cmd | 0x40);
+
+  // send argument
+  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
+
+  // send CRC
+  uint8_t crc = 0XFF;
+  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
+  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
+  spiSend(crc);
+
+  // skip stuff byte for stop read
+  if (cmd == CMD12) spiRec();
+
+  // wait for response
+  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
+  return status_;
+}
+//------------------------------------------------------------------------------
+/**
+ * Determine the size of an SD flash memory card.
+ *
+ * \return The number of 512 byte data blocks in the card
+ *         or zero if an error occurs.
+ */
+uint32_t Sd2Card::cardSize() {
+  csd_t csd;
+  if (!readCSD(&csd)) return 0;
+  if (csd.v1.csd_ver == 0) {
+    uint8_t read_bl_len = csd.v1.read_bl_len;
+    uint16_t c_size = (csd.v1.c_size_high << 10)
+                      | (csd.v1.c_size_mid << 2) | csd.v1.c_size_low;
+    uint8_t c_size_mult = (csd.v1.c_size_mult_high << 1)
+                          | csd.v1.c_size_mult_low;
+    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
+  } else if (csd.v2.csd_ver == 1) {
+    uint32_t c_size = ((uint32_t)csd.v2.c_size_high << 16)
+                      | (csd.v2.c_size_mid << 8) | csd.v2.c_size_low;
+    return (c_size + 1) << 10;
+  } else {
+    error(SD_CARD_ERROR_BAD_CSD);
+    return 0;
+  }
+}
+//------------------------------------------------------------------------------
+void Sd2Card::chipSelectHigh() {
+  digitalWrite(chipSelectPin_, HIGH);
+}
+//------------------------------------------------------------------------------
+void Sd2Card::chipSelectLow() {
+#ifndef SOFTWARE_SPI
+  spiInit(spiRate_);
+#endif  // SOFTWARE_SPI
+  digitalWrite(chipSelectPin_, LOW);
+}
+//------------------------------------------------------------------------------
+/** Erase a range of blocks.
+ *
+ * \param[in] firstBlock The address of the first block in the range.
+ * \param[in] lastBlock The address of the last block in the range.
+ *
+ * \note This function requests the SD card to do a flash erase for a
+ * range of blocks.  The data on the card after an erase operation is
+ * either 0 or 1, depends on the card vendor.  The card must support
+ * single block erase.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
+  csd_t csd;
+  if (!readCSD(&csd)) goto fail;
+  // check for single block erase
+  if (!csd.v1.erase_blk_en) {
+    // erase size mask
+    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
+    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
+      // error card can't erase specified area
+      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
+      goto fail;
+    }
+  }
+  if (type_ != SD_CARD_TYPE_SDHC) {
+    firstBlock <<= 9;
+    lastBlock <<= 9;
+  }
+  if (cardCommand(CMD32, firstBlock)
+    || cardCommand(CMD33, lastBlock)
+    || cardCommand(CMD38, 0)) {
+      error(SD_CARD_ERROR_ERASE);
+      goto fail;
+  }
+  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
+    error(SD_CARD_ERROR_ERASE_TIMEOUT);
+    goto fail;
+  }
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Determine if card supports single block erase.
+ *
+ * \return The value one, true, is returned if single block erase is supported.
+ * The value zero, false, is returned if single block erase is not supported.
+ */
+bool Sd2Card::eraseSingleBlockEnable() {
+  csd_t csd;
+  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Initialize an SD flash memory card.
+ *
+ * \param[in] sckRateID SPI clock rate selector. See setSckRate().
+ * \param[in] chipSelectPin SD chip select pin number.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.  The reason for failure
+ * can be determined by calling errorCode() and errorData().
+ */
+bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
+  errorCode_ = type_ = 0;
+  chipSelectPin_ = chipSelectPin;
+  // 16-bit init start time allows over a minute
+  uint16_t t0 = (uint16_t)millis();
+  uint32_t arg;
+
+  // set pin modes
+  pinMode(chipSelectPin_, OUTPUT);
+  chipSelectHigh();
+  pinMode(SPI_MISO_PIN, INPUT);
+  pinMode(SPI_MOSI_PIN, OUTPUT);
+  pinMode(SPI_SCK_PIN, OUTPUT);
+
+#ifndef SOFTWARE_SPI
+  // SS must be in output mode even it is not chip select
+  pinMode(SS_PIN, OUTPUT);
+  // set SS high - may be chip select for another SPI device
+#if SET_SPI_SS_HIGH
+  digitalWrite(SS_PIN, HIGH);
+#endif  // SET_SPI_SS_HIGH
+  // set SCK rate for initialization commands
+  spiRate_ = SPI_SD_INIT_RATE;
+  spiInit(spiRate_);
+#endif  // SOFTWARE_SPI
+
+  // must supply min of 74 clock cycles with CS high.
+  for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
+
+  // command to go idle in SPI mode
+  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
+    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+      error(SD_CARD_ERROR_CMD0);
+      goto fail;
+    }
+  }
+  // check SD version
+  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
+    type(SD_CARD_TYPE_SD1);
+  } else {
+    // only need last byte of r7 response
+    for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
+    if (status_ != 0XAA) {
+      error(SD_CARD_ERROR_CMD8);
+      goto fail;
+    }
+    type(SD_CARD_TYPE_SD2);
+  }
+  // initialize card and send host supports SDHC if SD2
+  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
+
+  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
+    // check for timeout
+    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+      error(SD_CARD_ERROR_ACMD41);
+      goto fail;
+    }
+  }
+  // if SD2 read OCR register to check for SDHC card
+  if (type() == SD_CARD_TYPE_SD2) {
+    if (cardCommand(CMD58, 0)) {
+      error(SD_CARD_ERROR_CMD58);
+      goto fail;
+    }
+    if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
+    // discard rest of ocr - contains allowed voltage range
+    for (uint8_t i = 0; i < 3; i++) spiRec();
+  }
+  chipSelectHigh();
+
+#ifndef SOFTWARE_SPI
+  return setSckRate(sckRateID);
+#else  // SOFTWARE_SPI
+  return true;
+#endif  // SOFTWARE_SPI
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Read a 512 byte block from an SD card.
+ *
+ * \param[in] blockNumber Logical block to be read.
+ * \param[out] dst Pointer to the location that will receive the data.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
+#ifdef SD_CHECK_AND_RETRY
+  uint8_t retryCnt = 3;
+  // use address if not SDHC card
+  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+ retry2:
+  retryCnt --;
+  if (cardCommand(CMD17, blockNumber)) {
+    error(SD_CARD_ERROR_CMD17);
+    if (retryCnt > 0) goto retry;
+    goto fail;
+  }
+  if (!readData(dst, 512))
+  {
+    if (retryCnt > 0) goto retry;
+    goto fail;
+  }
+  return true;
+ retry:
+   chipSelectHigh();
+   cardCommand(CMD12, 0);//Try sending a stop command, but ignore the result.
+   errorCode_ = 0;
+   goto retry2;
+#else
+  // use address if not SDHC card
+  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD17, blockNumber)) {
+    error(SD_CARD_ERROR_CMD17);
+    goto fail;
+  }
+  return readData(dst, 512);
+#endif
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Read one data block in a multiple block read sequence
+ *
+ * \param[in] dst Pointer to the location for the data to be read.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readData(uint8_t *dst) {
+  chipSelectLow();
+  return readData(dst, 512);
+}
+
+#ifdef SD_CHECK_AND_RETRY
+static const uint16_t crctab[] PROGMEM = {
+  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
+  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
+  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
+  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
+  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
+  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
+  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
+  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
+  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
+  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
+  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
+  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
+  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
+  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
+  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
+  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
+  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
+  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
+  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
+  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
+  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
+  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
+  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
+  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
+  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
+  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
+  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
+  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
+  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
+  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
+  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
+};
+static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+  uint16_t crc = 0;
+  for (size_t i = 0; i < n; i++) {
+    crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0XFF]) ^ (crc << 8);
+  }
+  return crc;
+}
+#endif
+
+//------------------------------------------------------------------------------
+bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
+  // wait for start block token
+  uint16_t t0 = millis();
+  while ((status_ = spiRec()) == 0XFF) {
+    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
+      error(SD_CARD_ERROR_READ_TIMEOUT);
+      goto fail;
+    }
+  }
+  if (status_ != DATA_START_BLOCK) {
+    error(SD_CARD_ERROR_READ);
+    goto fail;
+  }
+  // transfer data
+  spiRead(dst, count);
+
+#ifdef SD_CHECK_AND_RETRY
+  {
+    uint16_t calcCrc = CRC_CCITT(dst, count);
+    uint16_t recvCrc = spiRec() << 8;
+    recvCrc |= spiRec();
+    if (calcCrc != recvCrc)
+    {
+        error(SD_CARD_ERROR_CRC);
+        goto fail;
+    }
+  }
+#else
+  // discard CRC
+  spiRec();
+  spiRec();
+#endif
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** read CID or CSR register */
+bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
+  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  if (cardCommand(cmd, 0)) {
+    error(SD_CARD_ERROR_READ_REG);
+    goto fail;
+  }
+  return readData(dst, 16);
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Start a read multiple blocks sequence.
+ *
+ * \param[in] blockNumber Address of first block in sequence.
+ *
+ * \note This function is used with readData() and readStop() for optimized
+ * multiple block reads.  SPI chipSelect must be low for the entire sequence.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readStart(uint32_t blockNumber) {
+  if (type()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD18, blockNumber)) {
+    error(SD_CARD_ERROR_CMD18);
+    goto fail;
+  }
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** End a read multiple blocks sequence.
+ *
+* \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readStop() {
+  chipSelectLow();
+  if (cardCommand(CMD12, 0)) {
+    error(SD_CARD_ERROR_CMD12);
+    goto fail;
+  }
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Set the SPI clock rate.
+ *
+ * \param[in] sckRateID A value in the range [0, 6].
+ *
+ * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum
+ * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128
+ * for \a scsRateID = 6.
+ *
+ * \return The value one, true, is returned for success and the value zero,
+ * false, is returned for an invalid value of \a sckRateID.
+ */
+bool Sd2Card::setSckRate(uint8_t sckRateID) {
+  if (sckRateID > 6) {
+    error(SD_CARD_ERROR_SCK_RATE);
+    return false;
+  }
+  spiRate_ = sckRateID;
+  return true;
+}
+//------------------------------------------------------------------------------
+// wait for card to go not busy
+bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
+  uint16_t t0 = millis();
+  while (spiRec() != 0XFF) {
+    if (((uint16_t)millis() - t0) >= timeoutMillis) goto fail;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Writes a 512 byte block to an SD card.
+ *
+ * \param[in] blockNumber Logical block to be written.
+ * \param[in] src Pointer to the location of the data to be written.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
+  // use address if not SDHC card
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD24, blockNumber)) {
+    error(SD_CARD_ERROR_CMD24);
+    goto fail;
+  }
+  if (!writeData(DATA_START_BLOCK, src)) goto fail;
+
+  // wait for flash programming to complete
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
+    error(SD_CARD_ERROR_WRITE_TIMEOUT);
+    goto fail;
+  }
+  // response is r2 so get and check two bytes for nonzero
+  if (cardCommand(CMD13, 0) || spiRec()) {
+    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
+    goto fail;
+  }
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Write one data block in a multiple block write sequence
+ * \param[in] src Pointer to the location of the data to be written.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeData(const uint8_t* src) {
+  chipSelectLow();
+  // wait for previous write to finish
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
+  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;
+  chipSelectHigh();
+  return true;
+
+ fail:
+  error(SD_CARD_ERROR_WRITE_MULTIPLE);
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+// send one block of data for write block or write multiple blocks
+bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
+  spiSendBlock(token, src);
+
+  spiSend(0xff);  // dummy crc
+  spiSend(0xff);  // dummy crc
+
+  status_ = spiRec();
+  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
+    error(SD_CARD_ERROR_WRITE);
+    goto fail;
+  }
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Start a write multiple blocks sequence.
+ *
+ * \param[in] blockNumber Address of first block in sequence.
+ * \param[in] eraseCount The number of blocks to be pre-erased.
+ *
+ * \note This function is used with writeData() and writeStop()
+ * for optimized multiple block writes.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
+  // send pre-erase count
+  if (cardAcmd(ACMD23, eraseCount)) {
+    error(SD_CARD_ERROR_ACMD23);
+    goto fail;
+  }
+  // use address if not SDHC card
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD25, blockNumber)) {
+    error(SD_CARD_ERROR_CMD25);
+    goto fail;
+  }
+  chipSelectHigh();
+  return true;
+
+ fail:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** End a write multiple blocks sequence.
+ *
+* \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeStop() {
+  chipSelectLow();
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
+  spiSend(STOP_TRAN_TOKEN);
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
+  chipSelectHigh();
+  return true;
+
+ fail:
+  error(SD_CARD_ERROR_STOP_TRAN);
+  chipSelectHigh();
+  return false;
+}
+
+#endif
diff --git a/Marlin/Sd2Card.h b/Marlin/Sd2Card.h
new file mode 100644
index 0000000..d6b302b
--- /dev/null
+++ b/Marlin/Sd2Card.h
@@ -0,0 +1,243 @@
+/* Arduino Sd2Card Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino Sd2Card Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef Sd2Card_h
+#define Sd2Card_h
+/**
+ * \file
+ * \brief Sd2Card class for V2 SD/SDHC cards
+ */
+#include "SdFatConfig.h"
+#include "Sd2PinMap.h"
+#include "SdInfo.h"
+//------------------------------------------------------------------------------
+// SPI speed is F_CPU/2^(1 + index), 0 <= index <= 6
+/** Set SCK to max rate of F_CPU/2. See Sd2Card::setSckRate(). */
+uint8_t const SPI_FULL_SPEED = 0;
+/** Set SCK rate to F_CPU/4. See Sd2Card::setSckRate(). */
+uint8_t const SPI_HALF_SPEED = 1;
+/** Set SCK rate to F_CPU/8. See Sd2Card::setSckRate(). */
+uint8_t const SPI_QUARTER_SPEED = 2;
+/** Set SCK rate to F_CPU/16. See Sd2Card::setSckRate(). */
+uint8_t const SPI_EIGHTH_SPEED = 3;
+/** Set SCK rate to F_CPU/32. See Sd2Card::setSckRate(). */
+uint8_t const SPI_SIXTEENTH_SPEED = 4;
+//------------------------------------------------------------------------------
+/** init timeout ms */
+uint16_t const SD_INIT_TIMEOUT = 2000;
+/** erase timeout ms */
+uint16_t const SD_ERASE_TIMEOUT = 10000;
+/** read timeout ms */
+uint16_t const SD_READ_TIMEOUT = 300;
+/** write time out ms */
+uint16_t const SD_WRITE_TIMEOUT = 600;
+//------------------------------------------------------------------------------
+// SD card errors
+/** timeout error for command CMD0 (initialize card in SPI mode) */
+uint8_t const SD_CARD_ERROR_CMD0 = 0X1;
+/** CMD8 was not accepted - not a valid SD card*/
+uint8_t const SD_CARD_ERROR_CMD8 = 0X2;
+/** card returned an error response for CMD12 (write stop) */
+uint8_t const SD_CARD_ERROR_CMD12 = 0X3;
+/** card returned an error response for CMD17 (read block) */
+uint8_t const SD_CARD_ERROR_CMD17 = 0X4;
+/** card returned an error response for CMD18 (read multiple block) */
+uint8_t const SD_CARD_ERROR_CMD18 = 0X5;
+/** card returned an error response for CMD24 (write block) */
+uint8_t const SD_CARD_ERROR_CMD24 = 0X6;
+/**  WRITE_MULTIPLE_BLOCKS command failed */
+uint8_t const SD_CARD_ERROR_CMD25 = 0X7;
+/** card returned an error response for CMD58 (read OCR) */
+uint8_t const SD_CARD_ERROR_CMD58 = 0X8;
+/** SET_WR_BLK_ERASE_COUNT failed */
+uint8_t const SD_CARD_ERROR_ACMD23 = 0X9;
+/** ACMD41 initialization process timeout */
+uint8_t const SD_CARD_ERROR_ACMD41 = 0XA;
+/** card returned a bad CSR version field */
+uint8_t const SD_CARD_ERROR_BAD_CSD = 0XB;
+/** erase block group command failed */
+uint8_t const SD_CARD_ERROR_ERASE = 0XC;
+/** card not capable of single block erase */
+uint8_t const SD_CARD_ERROR_ERASE_SINGLE_BLOCK = 0XD;
+/** Erase sequence timed out */
+uint8_t const SD_CARD_ERROR_ERASE_TIMEOUT = 0XE;
+/** card returned an error token instead of read data */
+uint8_t const SD_CARD_ERROR_READ = 0XF;
+/** read CID or CSD failed */
+uint8_t const SD_CARD_ERROR_READ_REG = 0X10;
+/** timeout while waiting for start of read data */
+uint8_t const SD_CARD_ERROR_READ_TIMEOUT = 0X11;
+/** card did not accept STOP_TRAN_TOKEN */
+uint8_t const SD_CARD_ERROR_STOP_TRAN = 0X12;
+/** card returned an error token as a response to a write operation */
+uint8_t const SD_CARD_ERROR_WRITE = 0X13;
+/** attempt to write protected block zero */
+uint8_t const SD_CARD_ERROR_WRITE_BLOCK_ZERO = 0X14;  // REMOVE - not used
+/** card did not go ready for a multiple block write */
+uint8_t const SD_CARD_ERROR_WRITE_MULTIPLE = 0X15;
+/** card returned an error to a CMD13 status check after a write */
+uint8_t const SD_CARD_ERROR_WRITE_PROGRAMMING = 0X16;
+/** timeout occurred during write programming */
+uint8_t const SD_CARD_ERROR_WRITE_TIMEOUT = 0X17;
+/** incorrect rate selected */
+uint8_t const SD_CARD_ERROR_SCK_RATE = 0X18;
+/** init() not called */
+uint8_t const SD_CARD_ERROR_INIT_NOT_CALLED = 0X19;
+/** crc check error */
+uint8_t const SD_CARD_ERROR_CRC = 0X20;
+//------------------------------------------------------------------------------
+// card types
+/** Standard capacity V1 SD card */
+uint8_t const SD_CARD_TYPE_SD1  = 1;
+/** Standard capacity V2 SD card */
+uint8_t const SD_CARD_TYPE_SD2  = 2;
+/** High Capacity SD card */
+uint8_t const SD_CARD_TYPE_SDHC = 3;
+/**
+ * define SOFTWARE_SPI to use bit-bang SPI
+ */
+//------------------------------------------------------------------------------
+#if MEGA_SOFT_SPI && (defined(__AVR_ATmega1280__)||defined(__AVR_ATmega2560__))
+#define SOFTWARE_SPI
+#elif USE_SOFTWARE_SPI
+#define SOFTWARE_SPI
+#endif  // MEGA_SOFT_SPI
+//------------------------------------------------------------------------------
+// SPI pin definitions - do not edit here - change in SdFatConfig.h
+//
+#ifndef SOFTWARE_SPI
+// hardware pin defs
+/** The default chip select pin for the SD card is SS. */
+uint8_t const  SD_CHIP_SELECT_PIN = SS_PIN;
+// The following three pins must not be redefined for hardware SPI.
+/** SPI Master Out Slave In pin */
+uint8_t const  SPI_MOSI_PIN = MOSI_PIN;
+/** SPI Master In Slave Out pin */
+uint8_t const  SPI_MISO_PIN = MISO_PIN;
+/** SPI Clock pin */
+uint8_t const  SPI_SCK_PIN = SCK_PIN;
+
+#else  // SOFTWARE_SPI
+
+/** SPI chip select pin */
+uint8_t const SD_CHIP_SELECT_PIN = SOFT_SPI_CS_PIN;
+/** SPI Master Out Slave In pin */
+uint8_t const SPI_MOSI_PIN = SOFT_SPI_MOSI_PIN;
+/** SPI Master In Slave Out pin */
+uint8_t const SPI_MISO_PIN = SOFT_SPI_MISO_PIN;
+/** SPI Clock pin */
+uint8_t const SPI_SCK_PIN = SOFT_SPI_SCK_PIN;
+#endif  // SOFTWARE_SPI
+//------------------------------------------------------------------------------
+/**
+ * \class Sd2Card
+ * \brief Raw access to SD and SDHC flash memory cards.
+ */
+class Sd2Card {
+ public:
+  /** Construct an instance of Sd2Card. */
+  Sd2Card() : errorCode_(SD_CARD_ERROR_INIT_NOT_CALLED), type_(0) {}
+  uint32_t cardSize();
+  bool erase(uint32_t firstBlock, uint32_t lastBlock);
+  bool eraseSingleBlockEnable();
+  /**
+   *  Set SD error code.
+   *  \param[in] code value for error code.
+   */
+  void error(uint8_t code) {errorCode_ = code;}
+  /**
+   * \return error code for last error. See Sd2Card.h for a list of error codes.
+   */
+  int errorCode() const {return errorCode_;}
+  /** \return error data for last error. */
+  int errorData() const {return status_;}
+  /**
+   * Initialize an SD flash memory card with default clock rate and chip
+   * select pin.  See sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin).
+   *
+   * \return true for success or false for failure.
+   */
+  bool init(uint8_t sckRateID = SPI_FULL_SPEED,
+    uint8_t chipSelectPin = SD_CHIP_SELECT_PIN);
+  bool readBlock(uint32_t block, uint8_t* dst);
+  /**
+   * Read a card's CID register. The CID contains card identification
+   * information such as Manufacturer ID, Product name, Product serial
+   * number and Manufacturing date. 
+   *
+   * \param[out] cid pointer to area for returned data.
+   *
+   * \return true for success or false for failure.
+   */
+  bool readCID(cid_t* cid) {
+    return readRegister(CMD10, cid);
+  }
+  /**
+   * Read a card's CSD register. The CSD contains Card-Specific Data that
+   * provides information regarding access to the card's contents.
+   *
+   * \param[out] csd pointer to area for returned data.
+   *
+   * \return true for success or false for failure.
+   */
+  bool readCSD(csd_t* csd) {
+    return readRegister(CMD9, csd);
+  }
+  bool readData(uint8_t *dst);
+  bool readStart(uint32_t blockNumber);
+  bool readStop();
+  bool setSckRate(uint8_t sckRateID);
+  /** Return the card type: SD V1, SD V2 or SDHC
+   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC.
+   */
+  int type() const {return type_;}
+  bool writeBlock(uint32_t blockNumber, const uint8_t* src);
+  bool writeData(const uint8_t* src);
+  bool writeStart(uint32_t blockNumber, uint32_t eraseCount);
+  bool writeStop();
+ private:
+  //----------------------------------------------------------------------------
+  uint8_t chipSelectPin_;
+  uint8_t errorCode_;
+  uint8_t spiRate_;
+  uint8_t status_;
+  uint8_t type_;
+  // private functions
+  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
+    cardCommand(CMD55, 0);
+    return cardCommand(cmd, arg);
+  }
+  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
+
+  bool readData(uint8_t* dst, uint16_t count);
+  bool readRegister(uint8_t cmd, void* buf);
+  void chipSelectHigh();
+  void chipSelectLow();
+  void type(uint8_t value) {type_ = value;}
+  bool waitNotBusy(uint16_t timeoutMillis);
+  bool writeData(uint8_t token, const uint8_t* src);
+};
+#endif  // Sd2Card_h
+
+
+#endif
\ No newline at end of file
diff --git a/Marlin/Sd2PinMap.h b/Marlin/Sd2PinMap.h
new file mode 100644
index 0000000..93ab943
--- /dev/null
+++ b/Marlin/Sd2PinMap.h
@@ -0,0 +1,368 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2010 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+// Warning this file was generated by a program.
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef Sd2PinMap_h
+#define Sd2PinMap_h
+#include <avr/io.h>
+//------------------------------------------------------------------------------
+/** struct for mapping digital pins */
+struct pin_map_t {
+  volatile uint8_t* ddr;
+  volatile uint8_t* pin;
+  volatile uint8_t* port;
+  uint8_t bit;
+};
+//------------------------------------------------------------------------------
+#if defined(__AVR_ATmega1280__)\
+|| defined(__AVR_ATmega2560__)
+// Mega
+
+// Two Wire (aka I2C) ports
+uint8_t const SDA_PIN = 20;  // D1
+uint8_t const SCL_PIN = 21;  // D0
+
+#undef MOSI_PIN
+#undef MISO_PIN
+// SPI port
+uint8_t const SS_PIN = 53;    // B0
+uint8_t const MOSI_PIN = 51;  // B2
+uint8_t const MISO_PIN = 50;  // B3
+uint8_t const SCK_PIN = 52;   // B1
+
+static const pin_map_t digitalPinMap[] = {
+  {&DDRE, &PINE, &PORTE, 0},  // E0  0
+  {&DDRE, &PINE, &PORTE, 1},  // E1  1
+  {&DDRE, &PINE, &PORTE, 4},  // E4  2
+  {&DDRE, &PINE, &PORTE, 5},  // E5  3
+  {&DDRG, &PING, &PORTG, 5},  // G5  4
+  {&DDRE, &PINE, &PORTE, 3},  // E3  5
+  {&DDRH, &PINH, &PORTH, 3},  // H3  6
+  {&DDRH, &PINH, &PORTH, 4},  // H4  7
+  {&DDRH, &PINH, &PORTH, 5},  // H5  8
+  {&DDRH, &PINH, &PORTH, 6},  // H6  9
+  {&DDRB, &PINB, &PORTB, 4},  // B4 10
+  {&DDRB, &PINB, &PORTB, 5},  // B5 11
+  {&DDRB, &PINB, &PORTB, 6},  // B6 12
+  {&DDRB, &PINB, &PORTB, 7},  // B7 13
+  {&DDRJ, &PINJ, &PORTJ, 1},  // J1 14
+  {&DDRJ, &PINJ, &PORTJ, 0},  // J0 15
+  {&DDRH, &PINH, &PORTH, 1},  // H1 16
+  {&DDRH, &PINH, &PORTH, 0},  // H0 17
+  {&DDRD, &PIND, &PORTD, 3},  // D3 18
+  {&DDRD, &PIND, &PORTD, 2},  // D2 19
+  {&DDRD, &PIND, &PORTD, 1},  // D1 20
+  {&DDRD, &PIND, &PORTD, 0},  // D0 21
+  {&DDRA, &PINA, &PORTA, 0},  // A0 22
+  {&DDRA, &PINA, &PORTA, 1},  // A1 23
+  {&DDRA, &PINA, &PORTA, 2},  // A2 24
+  {&DDRA, &PINA, &PORTA, 3},  // A3 25
+  {&DDRA, &PINA, &PORTA, 4},  // A4 26
+  {&DDRA, &PINA, &PORTA, 5},  // A5 27
+  {&DDRA, &PINA, &PORTA, 6},  // A6 28
+  {&DDRA, &PINA, &PORTA, 7},  // A7 29
+  {&DDRC, &PINC, &PORTC, 7},  // C7 30
+  {&DDRC, &PINC, &PORTC, 6},  // C6 31
+  {&DDRC, &PINC, &PORTC, 5},  // C5 32
+  {&DDRC, &PINC, &PORTC, 4},  // C4 33
+  {&DDRC, &PINC, &PORTC, 3},  // C3 34
+  {&DDRC, &PINC, &PORTC, 2},  // C2 35
+  {&DDRC, &PINC, &PORTC, 1},  // C1 36
+  {&DDRC, &PINC, &PORTC, 0},  // C0 37
+  {&DDRD, &PIND, &PORTD, 7},  // D7 38
+  {&DDRG, &PING, &PORTG, 2},  // G2 39
+  {&DDRG, &PING, &PORTG, 1},  // G1 40
+  {&DDRG, &PING, &PORTG, 0},  // G0 41
+  {&DDRL, &PINL, &PORTL, 7},  // L7 42
+  {&DDRL, &PINL, &PORTL, 6},  // L6 43
+  {&DDRL, &PINL, &PORTL, 5},  // L5 44
+  {&DDRL, &PINL, &PORTL, 4},  // L4 45
+  {&DDRL, &PINL, &PORTL, 3},  // L3 46
+  {&DDRL, &PINL, &PORTL, 2},  // L2 47
+  {&DDRL, &PINL, &PORTL, 1},  // L1 48
+  {&DDRL, &PINL, &PORTL, 0},  // L0 49
+  {&DDRB, &PINB, &PORTB, 3},  // B3 50
+  {&DDRB, &PINB, &PORTB, 2},  // B2 51
+  {&DDRB, &PINB, &PORTB, 1},  // B1 52
+  {&DDRB, &PINB, &PORTB, 0},  // B0 53
+  {&DDRF, &PINF, &PORTF, 0},  // F0 54
+  {&DDRF, &PINF, &PORTF, 1},  // F1 55
+  {&DDRF, &PINF, &PORTF, 2},  // F2 56
+  {&DDRF, &PINF, &PORTF, 3},  // F3 57
+  {&DDRF, &PINF, &PORTF, 4},  // F4 58
+  {&DDRF, &PINF, &PORTF, 5},  // F5 59
+  {&DDRF, &PINF, &PORTF, 6},  // F6 60
+  {&DDRF, &PINF, &PORTF, 7},  // F7 61
+  {&DDRK, &PINK, &PORTK, 0},  // K0 62
+  {&DDRK, &PINK, &PORTK, 1},  // K1 63
+  {&DDRK, &PINK, &PORTK, 2},  // K2 64
+  {&DDRK, &PINK, &PORTK, 3},  // K3 65
+  {&DDRK, &PINK, &PORTK, 4},  // K4 66
+  {&DDRK, &PINK, &PORTK, 5},  // K5 67
+  {&DDRK, &PINK, &PORTK, 6},  // K6 68
+  {&DDRK, &PINK, &PORTK, 7}   // K7 69
+};
+//------------------------------------------------------------------------------
+#elif defined(__AVR_ATmega644P__)\
+|| defined(__AVR_ATmega644__)\
+|| defined(__AVR_ATmega1284P__)
+// Sanguino
+
+// Two Wire (aka I2C) ports
+uint8_t const SDA_PIN = 17;  // C1
+uint8_t const SCL_PIN = 18;  // C2
+
+// SPI port
+uint8_t const SS_PIN = 4;    // B4
+uint8_t const MOSI_PIN = 5;  // B5
+uint8_t const MISO_PIN = 6;  // B6
+uint8_t const SCK_PIN = 7;   // B7
+
+static const pin_map_t digitalPinMap[] = {
+  {&DDRB, &PINB, &PORTB, 0},  // B0  0
+  {&DDRB, &PINB, &PORTB, 1},  // B1  1
+  {&DDRB, &PINB, &PORTB, 2},  // B2  2
+  {&DDRB, &PINB, &PORTB, 3},  // B3  3
+  {&DDRB, &PINB, &PORTB, 4},  // B4  4
+  {&DDRB, &PINB, &PORTB, 5},  // B5  5
+  {&DDRB, &PINB, &PORTB, 6},  // B6  6
+  {&DDRB, &PINB, &PORTB, 7},  // B7  7
+  {&DDRD, &PIND, &PORTD, 0},  // D0  8
+  {&DDRD, &PIND, &PORTD, 1},  // D1  9
+  {&DDRD, &PIND, &PORTD, 2},  // D2 10
+  {&DDRD, &PIND, &PORTD, 3},  // D3 11
+  {&DDRD, &PIND, &PORTD, 4},  // D4 12
+  {&DDRD, &PIND, &PORTD, 5},  // D5 13
+  {&DDRD, &PIND, &PORTD, 6},  // D6 14
+  {&DDRD, &PIND, &PORTD, 7},  // D7 15
+  {&DDRC, &PINC, &PORTC, 0},  // C0 16
+  {&DDRC, &PINC, &PORTC, 1},  // C1 17
+  {&DDRC, &PINC, &PORTC, 2},  // C2 18
+  {&DDRC, &PINC, &PORTC, 3},  // C3 19
+  {&DDRC, &PINC, &PORTC, 4},  // C4 20
+  {&DDRC, &PINC, &PORTC, 5},  // C5 21
+  {&DDRC, &PINC, &PORTC, 6},  // C6 22
+  {&DDRC, &PINC, &PORTC, 7},  // C7 23
+  {&DDRA, &PINA, &PORTA, 7},  // A7 24
+  {&DDRA, &PINA, &PORTA, 6},  // A6 25
+  {&DDRA, &PINA, &PORTA, 5},  // A5 26
+  {&DDRA, &PINA, &PORTA, 4},  // A4 27
+  {&DDRA, &PINA, &PORTA, 3},  // A3 28
+  {&DDRA, &PINA, &PORTA, 2},  // A2 29
+  {&DDRA, &PINA, &PORTA, 1},  // A1 30
+  {&DDRA, &PINA, &PORTA, 0}   // A0 31
+};
+//------------------------------------------------------------------------------
+#elif defined(__AVR_ATmega32U4__)
+// Teensy 2.0
+
+// Two Wire (aka I2C) ports
+uint8_t const SDA_PIN = 6;  // D1
+uint8_t const SCL_PIN = 5;  // D0
+
+// SPI port
+uint8_t const SS_PIN = 0;    // B0
+uint8_t const MOSI_PIN = 2;  // B2
+uint8_t const MISO_PIN = 3;  // B3
+uint8_t const SCK_PIN = 1;   // B1
+
+static const pin_map_t digitalPinMap[] = {
+  {&DDRB, &PINB, &PORTB, 0},  // B0  0
+  {&DDRB, &PINB, &PORTB, 1},  // B1  1
+  {&DDRB, &PINB, &PORTB, 2},  // B2  2
+  {&DDRB, &PINB, &PORTB, 3},  // B3  3
+  {&DDRB, &PINB, &PORTB, 7},  // B7  4
+  {&DDRD, &PIND, &PORTD, 0},  // D0  5
+  {&DDRD, &PIND, &PORTD, 1},  // D1  6
+  {&DDRD, &PIND, &PORTD, 2},  // D2  7
+  {&DDRD, &PIND, &PORTD, 3},  // D3  8
+  {&DDRC, &PINC, &PORTC, 6},  // C6  9
+  {&DDRC, &PINC, &PORTC, 7},  // C7 10
+  {&DDRD, &PIND, &PORTD, 6},  // D6 11
+  {&DDRD, &PIND, &PORTD, 7},  // D7 12
+  {&DDRB, &PINB, &PORTB, 4},  // B4 13
+  {&DDRB, &PINB, &PORTB, 5},  // B5 14
+  {&DDRB, &PINB, &PORTB, 6},  // B6 15
+  {&DDRF, &PINF, &PORTF, 7},  // F7 16
+  {&DDRF, &PINF, &PORTF, 6},  // F6 17
+  {&DDRF, &PINF, &PORTF, 5},  // F5 18
+  {&DDRF, &PINF, &PORTF, 4},  // F4 19
+  {&DDRF, &PINF, &PORTF, 1},  // F1 20
+  {&DDRF, &PINF, &PORTF, 0},  // F0 21
+  {&DDRD, &PIND, &PORTD, 4},  // D4 22
+  {&DDRD, &PIND, &PORTD, 5},  // D5 23
+  {&DDRE, &PINE, &PORTE, 6}   // E6 24
+};
+//------------------------------------------------------------------------------
+#elif defined(__AVR_AT90USB646__)\
+|| defined(__AVR_AT90USB1286__)
+// Teensy++ 1.0 & 2.0
+
+// Two Wire (aka I2C) ports
+uint8_t const SDA_PIN = 1;  // D1
+uint8_t const SCL_PIN = 0;  // D0
+
+// SPI port
+uint8_t const SS_PIN    = 20;    // B0
+uint8_t const MOSI_PIN  = 22;    // B2
+uint8_t const MISO_PIN  = 23;    // B3
+uint8_t const SCK_PIN   = 21;    // B1
+
+static const pin_map_t digitalPinMap[] = {
+  {&DDRD, &PIND, &PORTD, 0},  // D0  0
+  {&DDRD, &PIND, &PORTD, 1},  // D1  1
+  {&DDRD, &PIND, &PORTD, 2},  // D2  2
+  {&DDRD, &PIND, &PORTD, 3},  // D3  3
+  {&DDRD, &PIND, &PORTD, 4},  // D4  4
+  {&DDRD, &PIND, &PORTD, 5},  // D5  5
+  {&DDRD, &PIND, &PORTD, 6},  // D6  6
+  {&DDRD, &PIND, &PORTD, 7},  // D7  7
+  {&DDRE, &PINE, &PORTE, 0},  // E0  8
+  {&DDRE, &PINE, &PORTE, 1},  // E1  9
+  {&DDRC, &PINC, &PORTC, 0},  // C0 10
+  {&DDRC, &PINC, &PORTC, 1},  // C1 11
+  {&DDRC, &PINC, &PORTC, 2},  // C2 12
+  {&DDRC, &PINC, &PORTC, 3},  // C3 13
+  {&DDRC, &PINC, &PORTC, 4},  // C4 14
+  {&DDRC, &PINC, &PORTC, 5},  // C5 15
+  {&DDRC, &PINC, &PORTC, 6},  // C6 16
+  {&DDRC, &PINC, &PORTC, 7},  // C7 17
+  {&DDRE, &PINE, &PORTE, 6},  // E6 18
+  {&DDRE, &PINE, &PORTE, 7},  // E7 19
+  {&DDRB, &PINB, &PORTB, 0},  // B0 20
+  {&DDRB, &PINB, &PORTB, 1},  // B1 21
+  {&DDRB, &PINB, &PORTB, 2},  // B2 22
+  {&DDRB, &PINB, &PORTB, 3},  // B3 23
+  {&DDRB, &PINB, &PORTB, 4},  // B4 24
+  {&DDRB, &PINB, &PORTB, 5},  // B5 25
+  {&DDRB, &PINB, &PORTB, 6},  // B6 26
+  {&DDRB, &PINB, &PORTB, 7},  // B7 27
+  {&DDRA, &PINA, &PORTA, 0},  // A0 28
+  {&DDRA, &PINA, &PORTA, 1},  // A1 29
+  {&DDRA, &PINA, &PORTA, 2},  // A2 30
+  {&DDRA, &PINA, &PORTA, 3},  // A3 31
+  {&DDRA, &PINA, &PORTA, 4},  // A4 32
+  {&DDRA, &PINA, &PORTA, 5},  // A5 33
+  {&DDRA, &PINA, &PORTA, 6},  // A6 34
+  {&DDRA, &PINA, &PORTA, 7},  // A7 35
+  {&DDRE, &PINE, &PORTE, 4},  // E4 36
+  {&DDRE, &PINE, &PORTE, 5},  // E5 37
+  {&DDRF, &PINF, &PORTF, 0},  // F0 38
+  {&DDRF, &PINF, &PORTF, 1},  // F1 39
+  {&DDRF, &PINF, &PORTF, 2},  // F2 40
+  {&DDRF, &PINF, &PORTF, 3},  // F3 41
+  {&DDRF, &PINF, &PORTF, 4},  // F4 42
+  {&DDRF, &PINF, &PORTF, 5},  // F5 43
+  {&DDRF, &PINF, &PORTF, 6},  // F6 44
+  {&DDRF, &PINF, &PORTF, 7}   // F7 45
+};
+//------------------------------------------------------------------------------
+#elif defined(__AVR_ATmega168__)\
+||defined(__AVR_ATmega168P__)\
+||defined(__AVR_ATmega328P__)
+// 168 and 328 Arduinos
+
+// Two Wire (aka I2C) ports
+uint8_t const SDA_PIN = 18;  // C4
+uint8_t const SCL_PIN = 19;  // C5
+
+// SPI port
+uint8_t const SS_PIN = 10;    // B2
+uint8_t const MOSI_PIN = 11;  // B3
+uint8_t const MISO_PIN = 12;  // B4
+uint8_t const SCK_PIN = 13;   // B5
+
+static const pin_map_t digitalPinMap[] = {
+  {&DDRD, &PIND, &PORTD, 0},  // D0  0
+  {&DDRD, &PIND, &PORTD, 1},  // D1  1
+  {&DDRD, &PIND, &PORTD, 2},  // D2  2
+  {&DDRD, &PIND, &PORTD, 3},  // D3  3
+  {&DDRD, &PIND, &PORTD, 4},  // D4  4
+  {&DDRD, &PIND, &PORTD, 5},  // D5  5
+  {&DDRD, &PIND, &PORTD, 6},  // D6  6
+  {&DDRD, &PIND, &PORTD, 7},  // D7  7
+  {&DDRB, &PINB, &PORTB, 0},  // B0  8
+  {&DDRB, &PINB, &PORTB, 1},  // B1  9
+  {&DDRB, &PINB, &PORTB, 2},  // B2 10
+  {&DDRB, &PINB, &PORTB, 3},  // B3 11
+  {&DDRB, &PINB, &PORTB, 4},  // B4 12
+  {&DDRB, &PINB, &PORTB, 5},  // B5 13
+  {&DDRC, &PINC, &PORTC, 0},  // C0 14
+  {&DDRC, &PINC, &PORTC, 1},  // C1 15
+  {&DDRC, &PINC, &PORTC, 2},  // C2 16
+  {&DDRC, &PINC, &PORTC, 3},  // C3 17
+  {&DDRC, &PINC, &PORTC, 4},  // C4 18
+  {&DDRC, &PINC, &PORTC, 5}   // C5 19
+};
+#else  // defined(__AVR_ATmega1280__)
+#error unknown chip
+#endif  // defined(__AVR_ATmega1280__)
+//------------------------------------------------------------------------------
+static const uint8_t digitalPinCount = sizeof(digitalPinMap)/sizeof(pin_map_t);
+
+uint8_t badPinNumber(void)
+  __attribute__((error("Pin number is too large or not a constant")));
+
+static inline __attribute__((always_inline))
+  bool getPinMode(uint8_t pin) {
+  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
+    return (*digitalPinMap[pin].ddr >> digitalPinMap[pin].bit) & 1;
+  } else {
+    return badPinNumber();
+  }
+}
+static inline __attribute__((always_inline))
+  void setPinMode(uint8_t pin, uint8_t mode) {
+  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
+    if (mode) {
+      *digitalPinMap[pin].ddr |= 1 << digitalPinMap[pin].bit;
+    } else {
+      *digitalPinMap[pin].ddr &= ~(1 << digitalPinMap[pin].bit);
+    }
+  } else {
+    badPinNumber();
+  }
+}
+static inline __attribute__((always_inline))
+  bool fastDigitalRead(uint8_t pin) {
+  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
+    return (*digitalPinMap[pin].pin >> digitalPinMap[pin].bit) & 1;
+  } else {
+    return badPinNumber();
+  }
+}
+static inline __attribute__((always_inline))
+  void fastDigitalWrite(uint8_t pin, uint8_t value) {
+  if (__builtin_constant_p(pin) && pin < digitalPinCount) {
+    if (value) {
+      *digitalPinMap[pin].port |= 1 << digitalPinMap[pin].bit;
+    } else {
+      *digitalPinMap[pin].port &= ~(1 << digitalPinMap[pin].bit);
+    }
+  } else {
+    badPinNumber();
+  }
+}
+#endif  // Sd2PinMap_h
+
+
+#endif
\ No newline at end of file
diff --git a/Marlin/SdBaseFile.cpp b/Marlin/SdBaseFile.cpp
new file mode 100644
index 0000000..dbcf77f
--- /dev/null
+++ b/Marlin/SdBaseFile.cpp
@@ -0,0 +1,1825 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#include "SdBaseFile.h"
+//------------------------------------------------------------------------------
+// pointer to cwd directory
+SdBaseFile* SdBaseFile::cwd_ = 0;
+// callback function for date/time
+void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
+//------------------------------------------------------------------------------
+// add a cluster to a file
+bool SdBaseFile::addCluster() {
+  if (!vol_->allocContiguous(1, &curCluster_)) goto fail;
+
+  // if first cluster of file link to directory entry
+  if (firstCluster_ == 0) {
+    firstCluster_ = curCluster_;
+    flags_ |= F_FILE_DIR_DIRTY;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Add a cluster to a directory file and zero the cluster.
+// return with first block of cluster in the cache
+bool SdBaseFile::addDirCluster() {
+  uint32_t block;
+  // max folder size
+  if (fileSize_/sizeof(dir_t) >= 0XFFFF) goto fail;
+
+  if (!addCluster()) goto fail;
+  if (!vol_->cacheFlush()) goto fail;
+
+  block = vol_->clusterStartBlock(curCluster_);
+
+  // set cache to first block of cluster
+  vol_->cacheSetBlockNumber(block, true);
+
+  // zero first block of cluster
+  memset(vol_->cacheBuffer_.data, 0, 512);
+
+  // zero rest of cluster
+  for (uint8_t i = 1; i < vol_->blocksPerCluster_; i++) {
+    if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) goto fail;
+  }
+  // Increase directory file size by cluster size
+  fileSize_ += 512UL << vol_->clusterSizeShift_;
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// cache a file's directory entry
+// return pointer to cached entry or null for failure
+dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
+  if (!vol_->cacheRawBlock(dirBlock_, action)) goto fail;
+  return vol_->cache()->dir + dirIndex_;
+
+ fail:
+  return 0;
+}
+//------------------------------------------------------------------------------
+/** Close a file and force cached data and directory information
+ *  to be written to the storage device.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include no file is open or an I/O error.
+ */
+bool SdBaseFile::close() {
+  bool rtn = sync();
+  type_ = FAT_FILE_TYPE_CLOSED;
+  return rtn;
+}
+//------------------------------------------------------------------------------
+/** Check for contiguous file and return its raw block range.
+ *
+ * \param[out] bgnBlock the first block address for the file.
+ * \param[out] endBlock the last  block address for the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include file is not contiguous, file has zero length
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
+  // error if no blocks
+  if (firstCluster_ == 0) goto fail;
+
+  for (uint32_t c = firstCluster_; ; c++) {
+    uint32_t next;
+    if (!vol_->fatGet(c, &next)) goto fail;
+
+    // check for contiguous
+    if (next != (c + 1)) {
+      // error if not end of chain
+      if (!vol_->isEOC(next)) goto fail;
+      *bgnBlock = vol_->clusterStartBlock(firstCluster_);
+      *endBlock = vol_->clusterStartBlock(c)
+                  + vol_->blocksPerCluster_ - 1;
+      return true;
+    }
+  }
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Create and open a new contiguous file of a specified size.
+ *
+ * \note This function only supports short DOS 8.3 names.
+ * See open() for more information.
+ *
+ * \param[in] dirFile The directory where the file will be created.
+ * \param[in] path A path with a valid DOS 8.3 file name.
+ * \param[in] size The desired file size.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include \a path contains
+ * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
+ * a file is already open, the file already exists, the root
+ * directory is full or an I/O error.
+ *
+ */
+bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
+        const char* path, uint32_t size) {
+  uint32_t count;
+  // don't allow zero length file
+  if (size == 0) goto fail;
+  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto fail;
+
+  // calculate number of clusters needed
+  count = ((size - 1) >> (vol_->clusterSizeShift_ + 9)) + 1;
+
+  // allocate clusters
+  if (!vol_->allocContiguous(count, &firstCluster_)) {
+    remove();
+    goto fail;
+  }
+  fileSize_ = size;
+
+  // insure sync() will update dir entry
+  flags_ |= F_FILE_DIR_DIRTY;
+
+  return sync();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Return a file's directory entry.
+ *
+ * \param[out] dir Location for return of the file's directory entry.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::dirEntry(dir_t* dir) {
+  dir_t* p;
+  // make sure fields on SD are correct
+  if (!sync()) goto fail;
+
+  // read entry
+  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  if (!p) goto fail;
+
+  // copy to caller's struct
+  memcpy(dir, p, sizeof(dir_t));
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Format the name field of \a dir into the 13 byte array
+ * \a name in standard 8.3 short name format.
+ *
+ * \param[in] dir The directory structure containing the name.
+ * \param[out] name A 13 byte char array for the formatted name.
+ */
+void SdBaseFile::dirName(const dir_t& dir, char* name) {
+  uint8_t j = 0;
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) name[j++] = '.';
+    name[j++] = dir.name[i];
+  }
+  name[j] = 0;
+}
+//------------------------------------------------------------------------------
+/** Test for the existence of a file in a directory
+ *
+ * \param[in] name Name of the file to be tested for.
+ *
+ * The calling instance must be an open directory file.
+ *
+ * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
+ * dirFile.
+ *
+ * \return true if the file exists else false.
+ */
+bool SdBaseFile::exists(const char* name) {
+  SdBaseFile file;
+  return file.open(this, name, O_READ);
+}
+//------------------------------------------------------------------------------
+/**
+ * Get a string from a file.
+ *
+ * fgets() reads bytes from a file into the array pointed to by \a str, until
+ * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,
+ * or end-of-file is encountered. The string is then terminated
+ * with a null byte.
+ *
+ * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'
+ * terminates the string for Windows text files which use CRLF for newline.
+ *
+ * \param[out] str Pointer to the array where the string is stored.
+ * \param[in] num Maximum number of characters to be read
+ * (including the final null byte). Usually the length
+ * of the array \a str is used.
+ * \param[in] delim Optional set of delimiters. The default is "\n".
+ *
+ * \return For success fgets() returns the length of the string in \a str.
+ * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
+ **/
+int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
+  char ch;
+  int16_t n = 0;
+  int16_t r = -1;
+  while ((n + 1) < num && (r = read(&ch, 1)) == 1) {
+    // delete CR
+    if (ch == '\r') continue;
+    str[n++] = ch;
+    if (!delim) {
+      if (ch == '\n') break;
+    } else {
+      if (strchr(delim, ch)) break;
+    }
+  }
+  if (r < 0) {
+    // read error
+    return -1;
+  }
+  str[n] = '\0';
+  return n;
+}
+//------------------------------------------------------------------------------
+/** Get a file's name
+ *
+ * \param[out] name An array of 13 characters for the file's name.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::getFilename(char* name) {
+  if (!isOpen()) return false;
+
+  if (isRoot()) {
+    name[0] = '/';
+    name[1] = '\0';
+    return true;
+  }
+  // cache entry
+  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  if (!p) return false;
+
+  // format name
+  dirName(*p, name);
+  return true;
+}
+//------------------------------------------------------------------------------
+void SdBaseFile::getpos(fpos_t* pos) {
+  pos->position = curPosition_;
+  pos->cluster = curCluster_;
+}
+
+//------------------------------------------------------------------------------
+/** List directory contents.
+ *
+ * \param[in] pr Print stream for list.
+ *
+ * \param[in] flags The inclusive OR of
+ *
+ * LS_DATE - %Print file modification date
+ *
+ * LS_SIZE - %Print file size.
+ *
+ * LS_R - Recursive list of subdirectories.
+ *
+ * \param[in] indent Amount of space before file name. Used for recursive
+ * list to indicate subdirectory level.
+ */
+void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
+  rewind();
+  int8_t status;
+  while ((status = lsPrintNext( flags, indent))) {
+    if (status > 1 && (flags & LS_R)) {
+      uint16_t index = curPosition()/32 - 1;
+      SdBaseFile s;
+      if (s.open(this, index, O_READ)) s.ls( flags, indent + 2);
+      seekSet(32 * (index + 1));
+    }
+  }
+}
+//------------------------------------------------------------------------------
+// saves 32 bytes on stack for ls recursion
+// return 0 - EOF, 1 - normal file, or 2 - directory
+int8_t SdBaseFile::lsPrintNext( uint8_t flags, uint8_t indent) {
+  dir_t dir;
+  uint8_t w = 0;
+
+  while (1) {
+    if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;
+    if (dir.name[0] == DIR_NAME_FREE) return 0;
+
+    // skip deleted entry and entries for . and  ..
+    if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'
+      && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
+  }
+  // indent for dir level
+  for (uint8_t i = 0; i < indent; i++) MYSERIAL.write(' ');
+
+  // print name
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) {
+      MYSERIAL.write('.');
+      w++;
+    }
+    MYSERIAL.write(dir.name[i]);
+    w++;
+  }
+  if (DIR_IS_SUBDIR(&dir)) {
+    MYSERIAL.write('/');
+    w++;
+  }
+  if (flags & (LS_DATE | LS_SIZE)) {
+    while (w++ < 14) MYSERIAL.write(' ');
+  }
+  // print modify date/time if requested
+  if (flags & LS_DATE) {
+    MYSERIAL.write(' ');
+    printFatDate( dir.lastWriteDate);
+    MYSERIAL.write(' ');
+    printFatTime( dir.lastWriteTime);
+  }
+  // print size if requested
+  if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {
+    MYSERIAL.write(' ');
+    MYSERIAL.print(dir.fileSize);
+  }
+  MYSERIAL.println();
+  return DIR_IS_FILE(&dir) ? 1 : 2;
+}
+//------------------------------------------------------------------------------
+// format directory name field from a 8.3 name string
+bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
+  uint8_t c;
+  uint8_t n = 7;  // max index for part before dot
+  uint8_t i = 0;
+  // blank fill name and extension
+  while (i < 11) name[i++] = ' ';
+  i = 0;
+  while (*str != '\0' && *str != '/') {
+    c = *str++;
+    if (c == '.') {
+      if (n == 10) goto fail;  // only one dot allowed
+      n = 10;  // max index for full 8.3 name
+      i = 8;   // place for extension
+    } else {
+      // illegal FAT characters
+      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
+      uint8_t b;
+      while ((b = pgm_read_byte(p++))) if (b == c) goto fail;
+      // check size and only allow ASCII printable characters
+      if (i > n || c < 0X21 || c > 0X7E)goto fail;
+      // only upper case allowed in 8.3 names - convert lower to upper
+      name[i++] = (c < 'a' || c > 'z') ?  (c) : (c + ('A' - 'a'));
+    }
+  }
+  *ptr = str;
+  // must have a file name, extension is optional
+  return name[0] != ' ';
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Make a new directory.
+ *
+ * \param[in] parent An open SdFat instance for the directory that will contain
+ * the new directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for the new directory.
+ *
+ * \param[in] pFlag Create missing parent directories if true.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include this file is already open, \a parent is not a
+ * directory, \a path is invalid or already exists in \a parent.
+ */
+bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
+  uint8_t dname[11];
+  SdBaseFile dir1, dir2;
+  SdBaseFile* sub = &dir1;
+  SdBaseFile* start = parent;
+
+  if (!parent || isOpen()) goto fail;
+
+  if (*path == '/') {
+    while (*path == '/') path++;
+    if (!parent->isRoot()) {
+      if (!dir2.openRoot(parent->vol_)) goto fail;
+      parent = &dir2;
+    }
+  }
+  while (1) {
+    if (!make83Name(path, dname, &path)) goto fail;
+    while (*path == '/') path++;
+    if (!*path) break;
+    if (!sub->open(parent, dname, O_READ)) {
+      if (!pFlag || !sub->mkdir(parent, dname)) {
+        goto fail;
+      }
+    }
+    if (parent != start) parent->close();
+    parent = sub;
+    sub = parent != &dir1 ? &dir1 : &dir2;
+  }
+  return mkdir(parent, dname);
+
+  fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
+  uint32_t block;
+  dir_t d;
+  dir_t* p;
+
+  if (!parent->isDir()) goto fail;
+
+  // create a normal file
+  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto fail;
+
+  // convert file to directory
+  flags_ = O_READ;
+  type_ = FAT_FILE_TYPE_SUBDIR;
+
+  // allocate and zero first cluster
+  if (!addDirCluster())goto fail;
+
+  // force entry to SD
+  if (!sync()) goto fail;
+
+  // cache entry - should already be in cache due to sync() call
+  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!p) goto fail;
+
+  // change directory entry  attribute
+  p->attributes = DIR_ATT_DIRECTORY;
+
+  // make entry for '.'
+  memcpy(&d, p, sizeof(d));
+  d.name[0] = '.';
+  for (uint8_t i = 1; i < 11; i++) d.name[i] = ' ';
+
+  // cache block for '.'  and '..'
+  block = vol_->clusterStartBlock(firstCluster_);
+  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
+
+  // copy '.' to block
+  memcpy(&vol_->cache()->dir[0], &d, sizeof(d));
+
+  // make entry for '..'
+  d.name[1] = '.';
+  if (parent->isRoot()) {
+    d.firstClusterLow = 0;
+    d.firstClusterHigh = 0;
+  } else {
+    d.firstClusterLow = parent->firstCluster_ & 0XFFFF;
+    d.firstClusterHigh = parent->firstCluster_ >> 16;
+  }
+  // copy '..' to block
+  memcpy(&vol_->cache()->dir[1], &d, sizeof(d));
+
+  // write first block
+  return vol_->cacheFlush();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+ /** Open a file in the current working directory.
+  *
+  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+  *
+  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
+  *
+  * \return The value one, true, is returned for success and
+  * the value zero, false, is returned for failure.
+  */
+  bool SdBaseFile::open(const char* path, uint8_t oflag) {
+    return open(cwd_, path, oflag);
+  }
+//------------------------------------------------------------------------------
+/** Open a file or directory by name.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory containing the
+ * file to be opened.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags from the following list
+ *
+ * O_READ - Open for reading.
+ *
+ * O_RDONLY - Same as O_READ.
+ *
+ * O_WRITE - Open for writing.
+ *
+ * O_WRONLY - Same as O_WRITE.
+ *
+ * O_RDWR - Open for reading and writing.
+ *
+ * O_APPEND - If set, the file offset shall be set to the end of the
+ * file prior to each write.
+ *
+ * O_AT_END - Set the initial position at the end of the file.
+ *
+ * O_CREAT - If the file exists, this flag has no effect except as noted
+ * under O_EXCL below. Otherwise, the file shall be created
+ *
+ * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
+ *
+ * O_SYNC - Call sync() after each write.  This flag should not be used with
+ * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.
+ * These functions do character at a time writes so sync() will be called
+ * after each byte.
+ *
+ * O_TRUNC - If the file exists and is a regular file, and the file is
+ * successfully opened and is not read only, its length shall be truncated to 0.
+ *
+ * WARNING: A given file must not be opened by more than one SdBaseFile object
+ * of file corruption may occur.
+ *
+ * \note Directory files must be opened read only.  Write and truncation is
+ * not allowed for directory files.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include this file is already open, \a dirFile is not
+ * a directory, \a path is invalid, the file does not exist
+ * or can't be opened in the access mode specified by oflag.
+ */
+bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
+  uint8_t dname[11];
+  SdBaseFile dir1, dir2;
+  SdBaseFile *parent = dirFile;
+  SdBaseFile *sub = &dir1;
+
+  if (!dirFile) goto fail;
+
+  // error if already open
+  if (isOpen()) goto fail;
+
+  if (*path == '/') {
+    while (*path == '/') path++;
+    if (!dirFile->isRoot()) {
+      if (!dir2.openRoot(dirFile->vol_)) goto fail;
+      parent = &dir2;
+    }
+  }
+  while (1) {
+    if (!make83Name(path, dname, &path)) goto fail;
+    while (*path == '/') path++;
+    if (!*path) break;
+    if (!sub->open(parent, dname, O_READ)) goto fail;
+    if (parent != dirFile) parent->close();
+    parent = sub;
+    sub = parent != &dir1 ? &dir1 : &dir2;
+  }
+  return open(parent, dname, oflag);
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// open with filename in dname
+bool SdBaseFile::open(SdBaseFile* dirFile,
+  const uint8_t dname[11], uint8_t oflag) {
+  bool emptyFound = false;
+  bool fileFound = false;
+  uint8_t index;
+  dir_t* p;
+
+  vol_ = dirFile->vol_;
+
+  dirFile->rewind();
+  // search for file
+
+  while (dirFile->curPosition_ < dirFile->fileSize_) {
+    index = 0XF & (dirFile->curPosition_ >> 5);
+    p = dirFile->readDirCache();
+    if (!p) goto fail;
+
+    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
+      // remember first empty slot
+      if (!emptyFound) {
+        dirBlock_ = dirFile->vol_->cacheBlockNumber();
+        dirIndex_ = index;
+        emptyFound = true;
+      }
+      // done if no entries follow
+      if (p->name[0] == DIR_NAME_FREE) break;
+    } else if (!memcmp(dname, p->name, 11)) {
+      fileFound = true;
+      break;
+    }
+  }
+  if (fileFound) {
+    // don't open existing file if O_EXCL
+    if (oflag & O_EXCL) goto fail;
+  } else {
+    // don't create unless O_CREAT and O_WRITE
+    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto fail;
+    if (emptyFound) {
+      index = dirIndex_;
+      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+      if (!p) goto fail;
+    } else {
+      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) goto fail;
+
+      // add and zero cluster for dirFile - first cluster is in cache for write
+      if (!dirFile->addDirCluster()) goto fail;
+
+      // use first entry in cluster
+      p = dirFile->vol_->cache()->dir;
+      index = 0;
+    }
+    // initialize as empty file
+    memset(p, 0, sizeof(dir_t));
+    memcpy(p->name, dname, 11);
+
+    // set timestamps
+    if (dateTime_) {
+      // call user date/time function
+      dateTime_(&p->creationDate, &p->creationTime);
+    } else {
+      // use default date/time
+      p->creationDate = FAT_DEFAULT_DATE;
+      p->creationTime = FAT_DEFAULT_TIME;
+    }
+    p->lastAccessDate = p->creationDate;
+    p->lastWriteDate = p->creationDate;
+    p->lastWriteTime = p->creationTime;
+
+    // write entry to SD
+    if (!dirFile->vol_->cacheFlush()) goto fail;
+  }
+  // open entry in cache
+  return openCachedEntry(index, oflag);
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a file by index.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory.
+ *
+ * \param[in] index The \a index of the directory entry for the file to be
+ * opened.  The value for \a index is (directory file position)/32.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+ *
+ * See open() by path for definition of flags.
+ * \return true for success or false for failure.
+ */
+bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
+  dir_t* p;
+
+  vol_ = dirFile->vol_;
+
+  // error if already open
+  if (isOpen() || !dirFile) goto fail;
+
+  // don't open existing file if O_EXCL - user call error
+  if (oflag & O_EXCL) goto fail;
+
+  // seek to location of entry
+  if (!dirFile->seekSet(32 * index)) goto fail;
+
+  // read entry into cache
+  p = dirFile->readDirCache();
+  if (!p) goto fail;
+
+  // error if empty slot or '.' or '..'
+  if (p->name[0] == DIR_NAME_FREE ||
+      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
+    goto fail;
+  }
+  // open cached entry
+  return openCachedEntry(index & 0XF, oflag);
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// open a cached directory entry. Assumes vol_ is initialized
+bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
+  // location of entry in cache
+  dir_t* p = &vol_->cache()->dir[dirIndex];
+
+  // write or truncate is an error for a directory or read-only file
+  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
+    if (oflag & (O_WRITE | O_TRUNC)) goto fail;
+  }
+  // remember location of directory entry on SD
+  dirBlock_ = vol_->cacheBlockNumber();
+  dirIndex_ = dirIndex;
+
+  // copy first cluster number for directory fields
+  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
+  firstCluster_ |= p->firstClusterLow;
+
+  // make sure it is a normal file or subdirectory
+  if (DIR_IS_FILE(p)) {
+    fileSize_ = p->fileSize;
+    type_ = FAT_FILE_TYPE_NORMAL;
+  } else if (DIR_IS_SUBDIR(p)) {
+    if (!vol_->chainSize(firstCluster_, &fileSize_)) goto fail;
+    type_ = FAT_FILE_TYPE_SUBDIR;
+  } else {
+    goto fail;
+  }
+  // save open flags for read/write
+  flags_ = oflag & F_OFLAG;
+
+  // set to start of file
+  curCluster_ = 0;
+  curPosition_ = 0;
+  if ((oflag & O_TRUNC) && !truncate(0)) return false;
+  return oflag & O_AT_END ? seekEnd(0) : true;
+
+ fail:
+  type_ = FAT_FILE_TYPE_CLOSED;
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open the next file or subdirectory in a directory.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory containing the
+ * file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+ *
+ * See open() by path for definition of flags.
+ * \return true for success or false for failure.
+ */
+bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
+  dir_t* p;
+  uint8_t index;
+
+  if (!dirFile) goto fail;
+
+  // error if already open
+  if (isOpen()) goto fail;
+
+  vol_ = dirFile->vol_;
+
+  while (1) {
+    index = 0XF & (dirFile->curPosition_ >> 5);
+
+    // read entry into cache
+    p = dirFile->readDirCache();
+    if (!p) goto fail;
+
+    // done if last entry
+    if (p->name[0] == DIR_NAME_FREE) goto fail;
+
+    // skip empty slot or '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
+      continue;
+    }
+    // must be file or dir
+    if (DIR_IS_FILE_OR_SUBDIR(p)) {
+      return openCachedEntry(index, oflag);
+    }
+  }
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a directory's parent directory.
+ *
+ * \param[in] dir Parent of this directory will be opened.  Must not be root.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::openParent(SdBaseFile* dir) {
+  dir_t entry;
+  dir_t* p;
+  SdBaseFile file;
+  uint32_t c;
+  uint32_t cluster;
+  uint32_t lbn;
+  // error if already open or dir is root or dir is not a directory
+  if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) goto fail;
+  vol_ = dir->vol_;
+  // position to '..'
+  if (!dir->seekSet(32)) goto fail;
+  // read '..' entry
+  if (dir->read(&entry, sizeof(entry)) != 32) goto fail;
+  // verify it is '..'
+  if (entry.name[0] != '.' || entry.name[1] != '.') goto fail;
+  // start cluster for '..'
+  cluster = entry.firstClusterLow;
+  cluster |= (uint32_t)entry.firstClusterHigh << 16;
+  if (cluster == 0) return openRoot(vol_);
+  // start block for '..'
+  lbn = vol_->clusterStartBlock(cluster);
+  // first block of parent dir
+  if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {
+    goto fail;
+  }
+  p = &vol_->cacheBuffer_.dir[1];
+  // verify name for '../..'
+  if (p->name[0] != '.' || p->name[1] != '.') goto fail;
+  // '..' is pointer to first cluster of parent. open '../..' to find parent
+  if (p->firstClusterHigh == 0 && p->firstClusterLow == 0) {
+    if (!file.openRoot(dir->volume())) goto fail;
+  } else {
+    if (!file.openCachedEntry(1, O_READ)) goto fail;
+  }
+  // search for parent in '../..'
+  do {
+    if (file.readDir(&entry, NULL) != 32) goto fail;
+    c = entry.firstClusterLow;
+    c |= (uint32_t)entry.firstClusterHigh << 16;
+  } while (c != cluster);
+  // open parent
+  return open(&file, file.curPosition()/32 - 1, O_READ);
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a volume's root directory.
+ *
+ * \param[in] vol The FAT volume containing the root directory to be opened.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is already open, the FAT volume has
+ * not been initialized or it a FAT12 volume.
+ */
+bool SdBaseFile::openRoot(SdVolume* vol) {
+  // error if file is already open
+  if (isOpen()) goto fail;
+
+  if (vol->fatType() == 16 || (FAT12_SUPPORT && vol->fatType() == 12)) {
+    type_ = FAT_FILE_TYPE_ROOT_FIXED;
+    firstCluster_ = 0;
+    fileSize_ = 32 * vol->rootDirEntryCount();
+  } else if (vol->fatType() == 32) {
+    type_ = FAT_FILE_TYPE_ROOT32;
+    firstCluster_ = vol->rootDirStart();
+    if (!vol->chainSize(firstCluster_, &fileSize_)) goto fail;
+  } else {
+    // volume is not initialized, invalid, or FAT12 without support
+    return false;
+  }
+  vol_ = vol;
+  // read only
+  flags_ = O_READ;
+
+  // set to start of file
+  curCluster_ = 0;
+  curPosition_ = 0;
+
+  // root has no directory entry
+  dirBlock_ = 0;
+  dirIndex_ = 0;
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Return the next available byte without consuming it.
+ *
+ * \return The byte if no error and not at eof else -1;
+ */
+int SdBaseFile::peek() {
+  fpos_t pos;
+  getpos(&pos);
+  int c = read();
+  if (c >= 0) setpos(&pos);
+  return c;
+}
+
+//------------------------------------------------------------------------------
+/** %Print the name field of a directory entry in 8.3 format.
+ * \param[in] pr Print stream for output.
+ * \param[in] dir The directory structure containing the name.
+ * \param[in] width Blank fill name if length is less than \a width.
+ * \param[in] printSlash Print '/' after directory names if true.
+ */
+void SdBaseFile::printDirName(const dir_t& dir,
+  uint8_t width, bool printSlash) {
+  uint8_t w = 0;
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) {
+      MYSERIAL.write('.');
+      w++;
+    }
+    MYSERIAL.write(dir.name[i]);
+    w++;
+  }
+  if (DIR_IS_SUBDIR(&dir) && printSlash) {
+    MYSERIAL.write('/');
+    w++;
+  }
+  while (w < width) {
+    MYSERIAL.write(' ');
+    w++;
+  }
+}
+//------------------------------------------------------------------------------
+// print uint8_t with width 2
+static void print2u( uint8_t v) {
+  if (v < 10) MYSERIAL.write('0');
+  MYSERIAL.print(v, DEC);
+}
+//------------------------------------------------------------------------------
+/** %Print a directory date field to Serial.
+ *
+ *  Format is yyyy-mm-dd.
+ *
+ * \param[in] fatDate The date field from a directory entry.
+ */
+
+//------------------------------------------------------------------------------
+/** %Print a directory date field.
+ *
+ *  Format is yyyy-mm-dd.
+ *
+ * \param[in] pr Print stream for output.
+ * \param[in] fatDate The date field from a directory entry.
+ */
+void SdBaseFile::printFatDate(uint16_t fatDate) {
+  MYSERIAL.print(FAT_YEAR(fatDate));
+  MYSERIAL.write('-');
+  print2u( FAT_MONTH(fatDate));
+  MYSERIAL.write('-');
+  print2u( FAT_DAY(fatDate));
+}
+
+//------------------------------------------------------------------------------
+/** %Print a directory time field.
+ *
+ * Format is hh:mm:ss.
+ *
+ * \param[in] pr Print stream for output.
+ * \param[in] fatTime The time field from a directory entry.
+ */
+void SdBaseFile::printFatTime( uint16_t fatTime) {
+  print2u( FAT_HOUR(fatTime));
+  MYSERIAL.write(':');
+  print2u( FAT_MINUTE(fatTime));
+  MYSERIAL.write(':');
+  print2u( FAT_SECOND(fatTime));
+}
+//------------------------------------------------------------------------------
+/** Print a file's name to Serial
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::printName() {
+  char name[13];
+  if (!getFilename(name)) return false;
+  MYSERIAL.print(name);
+  return true;
+}
+//------------------------------------------------------------------------------
+/** Read the next byte from a file.
+ *
+ * \return For success read returns the next byte in the file as an int.
+ * If an error occurs or end of file is reached -1 is returned.
+ */
+int16_t SdBaseFile::read() {
+  uint8_t b;
+  return read(&b, 1) == 1 ? b : -1;
+}
+//------------------------------------------------------------------------------
+/** Read data from a file starting at the current position.
+ *
+ * \param[out] buf Pointer to the location that will receive the data.
+ *
+ * \param[in] nbyte Maximum number of bytes to read.
+ *
+ * \return For success read() returns the number of bytes read.
+ * A value less than \a nbyte, including zero, will be returned
+ * if end of file is reached.
+ * If an error occurs, read() returns -1.  Possible errors include
+ * read() called before a file has been opened, corrupt file system
+ * or an I/O error occurred.
+ */
+int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
+  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  uint16_t offset;
+  uint16_t toRead;
+  uint32_t block;  // raw device block number
+
+  // error if not open or write only
+  if (!isOpen() || !(flags_ & O_READ)) goto fail;
+
+  // max bytes left in file
+  if (nbyte >= (fileSize_ - curPosition_)) {
+    nbyte = fileSize_ - curPosition_;
+  }
+  // amount left to read
+  toRead = nbyte;
+  while (toRead > 0) {
+    offset = curPosition_ & 0X1FF;  // offset in block
+    if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
+      block = vol_->rootDirStart() + (curPosition_ >> 9);
+    } else {
+      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
+      if (offset == 0 && blockOfCluster == 0) {
+        // start of new cluster
+        if (curPosition_ == 0) {
+          // use first cluster in file
+          curCluster_ = firstCluster_;
+        } else {
+          // get next cluster from FAT
+          if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
+        }
+      }
+      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
+    }
+    uint16_t n = toRead;
+
+    // amount to be read from current block
+    if (n > (512 - offset)) n = 512 - offset;
+
+    // no buffering needed if n == 512
+    if (n == 512 && block != vol_->cacheBlockNumber()) {
+      if (!vol_->readBlock(block, dst)) goto fail;
+    } else {
+      // read block to cache and copy data to caller
+      if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
+      uint8_t* src = vol_->cache()->data + offset;
+      memcpy(dst, src, n);
+    }
+    dst += n;
+    curPosition_ += n;
+    toRead -= n;
+  }
+  return nbyte;
+
+ fail:
+  return -1;
+}
+//------------------------------------------------------------------------------
+/** Read the next directory entry from a directory file.
+ *
+ * \param[out] dir The dir_t struct that will receive the data.
+ *
+ * \return For success readDir() returns the number of bytes read.
+ * A value of zero will be returned if end of file is reached.
+ * If an error occurs, readDir() returns -1.  Possible errors include
+ * readDir() called before a directory has been opened, this is not
+ * a directory file or an I/O error occurred.
+ */
+int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
+  int16_t n;
+  // if not a directory file or miss-positioned return an error
+  if (!isDir() || (0X1F & curPosition_)) return -1;
+  
+  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.
+  if (longFilename != NULL)
+  {
+  	longFilename[0] = '\0';
+  }
+
+  while (1) {
+    n = read(dir, sizeof(dir_t));
+    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;
+    // last entry if DIR_NAME_FREE
+    if (dir->name[0] == DIR_NAME_FREE) return 0;
+    // skip empty entries and entry for .  and ..
+    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') continue;
+    //Fill the long filename if we have a long filename entry,
+	// long filename entries are stored before the actual filename.
+	if (DIR_IS_LONG_NAME(dir) && longFilename != NULL)
+    {
+    	vfat_t *VFAT = (vfat_t*)dir;
+		//Sanity check the VFAT entry. The first cluster is always set to zero. And th esequence number should be higher then 0
+    	if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES)
+    	{
+			//TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
+    		n = ((VFAT->sequenceNumber & 0x1F) - 1) * 13;
+			longFilename[n+0] = VFAT->name1[0];
+			longFilename[n+1] = VFAT->name1[1];
+			longFilename[n+2] = VFAT->name1[2];
+			longFilename[n+3] = VFAT->name1[3];
+			longFilename[n+4] = VFAT->name1[4];
+			longFilename[n+5] = VFAT->name2[0];
+			longFilename[n+6] = VFAT->name2[1];
+			longFilename[n+7] = VFAT->name2[2];
+			longFilename[n+8] = VFAT->name2[3];
+			longFilename[n+9] = VFAT->name2[4];
+			longFilename[n+10] = VFAT->name2[5];
+			longFilename[n+11] = VFAT->name3[0];
+			longFilename[n+12] = VFAT->name3[1];
+			//If this VFAT entry is the last one, add a NUL terminator at the end of the string
+			if (VFAT->sequenceNumber & 0x40)
+				longFilename[n+13] = '\0';
+		}
+    }
+    // return if normal file or subdirectory
+    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;
+  }
+}
+//------------------------------------------------------------------------------
+// Read next directory entry into the cache
+// Assumes file is correctly positioned
+dir_t* SdBaseFile::readDirCache() {
+  uint8_t i;
+  // error if not directory
+  if (!isDir()) goto fail;
+
+  // index of entry in cache
+  i = (curPosition_ >> 5) & 0XF;
+
+  // use read to locate and cache block
+  if (read() < 0) goto fail;
+
+  // advance to next entry
+  curPosition_ += 31;
+
+  // return pointer to entry
+  return vol_->cache()->dir + i;
+
+ fail:
+  return 0;
+}
+//------------------------------------------------------------------------------
+/** Remove a file.
+ *
+ * The directory entry and all data for the file are deleted.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * file that has a long name. For example if a file has the long name
+ * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file read-only, is a directory,
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::remove() {
+  dir_t* d;
+  // free any clusters - will fail if read-only or directory
+  if (!truncate(0)) goto fail;
+
+  // cache directory entry
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+
+  // mark entry deleted
+  d->name[0] = DIR_NAME_DELETED;
+
+  // set this file closed
+  type_ = FAT_FILE_TYPE_CLOSED;
+
+  // write entry to SD
+  return vol_->cacheFlush();
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Remove a file.
+ *
+ * The directory entry and all data for the file are deleted.
+ *
+ * \param[in] dirFile The directory that contains the file.
+ * \param[in] path Path for the file to be removed.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * file that has a long name. For example if a file has the long name
+ * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is a directory, is read only,
+ * \a dirFile is not a directory, \a path is not found
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
+  SdBaseFile file;
+  if (!file.open(dirFile, path, O_WRITE)) goto fail;
+  return file.remove();
+
+ fail:
+  // can't set iostate - static function
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Rename a file or subdirectory.
+ *
+ * \param[in] dirFile Directory for the new path.
+ * \param[in] newPath New path name for the file/directory.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include \a dirFile is not open or is not a directory
+ * file, newPath is invalid or already exists, or an I/O error occurs.
+ */
+bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
+  dir_t entry;
+  uint32_t dirCluster = 0;
+  SdBaseFile file;
+  dir_t* d;
+
+  // must be an open file or subdirectory
+  if (!(isFile() || isSubDir())) goto fail;
+
+  // can't move file
+  if (vol_ != dirFile->vol_) goto fail;
+
+  // sync() and cache directory entry
+  sync();
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+
+  // save directory entry
+  memcpy(&entry, d, sizeof(entry));
+
+  // mark entry deleted
+  d->name[0] = DIR_NAME_DELETED;
+
+  // make directory entry for new path
+  if (isFile()) {
+    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {
+      goto restore;
+    }
+  } else {
+    // don't create missing path prefix components
+    if (!file.mkdir(dirFile, newPath, false)) {
+      goto restore;
+    }
+    // save cluster containing new dot dot
+    dirCluster = file.firstCluster_;
+  }
+  // change to new directory entry
+  dirBlock_ = file.dirBlock_;
+  dirIndex_ = file.dirIndex_;
+
+  // mark closed to avoid possible destructor close call
+  file.type_ = FAT_FILE_TYPE_CLOSED;
+
+  // cache new directory entry
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+
+  // copy all but name field to new directory entry
+  memcpy(&d->attributes, &entry.attributes, sizeof(entry) - sizeof(d->name));
+
+  // update dot dot if directory
+  if (dirCluster) {
+    // get new dot dot
+    uint32_t block = vol_->clusterStartBlock(dirCluster);
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;
+    memcpy(&entry, &vol_->cache()->dir[1], sizeof(entry));
+
+    // free unused cluster
+    if (!vol_->freeChain(dirCluster)) goto fail;
+
+    // store new dot dot
+    block = vol_->clusterStartBlock(firstCluster_);
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
+    memcpy(&vol_->cache()->dir[1], &entry, sizeof(entry));
+  }
+  return vol_->cacheFlush();
+
+ restore:
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+  // restore entry
+  d->name[0] = entry.name[0];
+  vol_->cacheFlush();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Remove a directory file.
+ *
+ * The directory file will be removed only if it is empty and is not the
+ * root directory.  rmdir() follows DOS and Windows and ignores the
+ * read-only attribute for the directory.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * directory that has a long name. For example if a directory has the
+ * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is not a directory, is the root
+ * directory, is not empty, or an I/O error occurred.
+ */
+bool SdBaseFile::rmdir() {
+  // must be open subdirectory
+  if (!isSubDir()) goto fail;
+
+  rewind();
+
+  // make sure directory is empty
+  while (curPosition_ < fileSize_) {
+    dir_t* p = readDirCache();
+    if (!p) goto fail;
+    // done if past last used entry
+    if (p->name[0] == DIR_NAME_FREE) break;
+    // skip empty slot, '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
+    // error not empty
+    if (DIR_IS_FILE_OR_SUBDIR(p)) goto fail;
+  }
+  // convert empty directory to normal file for remove
+  type_ = FAT_FILE_TYPE_NORMAL;
+  flags_ |= O_WRITE;
+  return remove();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Recursively delete a directory and all contained files.
+ *
+ * This is like the Unix/Linux 'rm -rf *' if called with the root directory
+ * hence the name.
+ *
+ * Warning - This will remove all contents of the directory including
+ * subdirectories.  The directory will then be removed if it is not root.
+ * The read-only attribute for files will be ignored.
+ *
+ * \note This function should not be used to delete the 8.3 version of
+ * a directory that has a long name.  See remove() and rmdir().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::rmRfStar() {
+  uint16_t index;
+  SdBaseFile f;
+  rewind();
+  while (curPosition_ < fileSize_) {
+    // remember position
+    index = curPosition_/32;
+
+    dir_t* p = readDirCache();
+    if (!p) goto fail;
+
+    // done if past last entry
+    if (p->name[0] == DIR_NAME_FREE) break;
+
+    // skip empty slot or '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
+
+    // skip if part of long file name or volume label in root
+    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
+
+    if (!f.open(this, index, O_READ)) goto fail;
+    if (f.isSubDir()) {
+      // recursively delete
+      if (!f.rmRfStar()) goto fail;
+    } else {
+      // ignore read-only
+      f.flags_ |= O_WRITE;
+      if (!f.remove()) goto fail;
+    }
+    // position to next entry if required
+    if (curPosition_ != (32*(index + 1))) {
+      if (!seekSet(32*(index + 1))) goto fail;
+    }
+  }
+  // don't try to delete root
+  if (!isRoot()) {
+    if (!rmdir()) goto fail;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/**  Create a file object and open it in the current working directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
+ */
+SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
+  type_ = FAT_FILE_TYPE_CLOSED;
+  writeError = false;
+  open(path, oflag);
+}
+//------------------------------------------------------------------------------
+/** Sets a file's position.
+ *
+ * \param[in] pos The new position in bytes from the beginning of the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::seekSet(uint32_t pos) {
+  uint32_t nCur;
+  uint32_t nNew;
+  // error if file not open or seek past end of file
+  if (!isOpen() || pos > fileSize_) goto fail;
+
+  if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
+    curPosition_ = pos;
+    goto done;
+  }
+  if (pos == 0) {
+    // set position to start of file
+    curCluster_ = 0;
+    curPosition_ = 0;
+    goto done;
+  }
+  // calculate cluster index for cur and new position
+  nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
+  nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
+
+  if (nNew < nCur || curPosition_ == 0) {
+    // must follow chain from first cluster
+    curCluster_ = firstCluster_;
+  } else {
+    // advance from curPosition
+    nNew -= nCur;
+  }
+  while (nNew--) {
+    if (!vol_->fatGet(curCluster_, &curCluster_)) goto fail;
+  }
+  curPosition_ = pos;
+
+ done:
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+void SdBaseFile::setpos(fpos_t* pos) {
+  curPosition_ = pos->position;
+  curCluster_ = pos->cluster;
+}
+//------------------------------------------------------------------------------
+/** The sync() call causes all modified data and directory fields
+ * to be written to the storage device.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include a call to sync() before a file has been
+ * opened or an I/O error.
+ */
+bool SdBaseFile::sync() {
+  // only allow open files and directories
+  if (!isOpen()) goto fail;
+
+  if (flags_ & F_FILE_DIR_DIRTY) {
+    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+    // check for deleted by another open file object
+    if (!d || d->name[0] == DIR_NAME_DELETED) goto fail;
+
+    // do not set filesize for dir files
+    if (!isDir()) d->fileSize = fileSize_;
+
+    // update first cluster fields
+    d->firstClusterLow = firstCluster_ & 0XFFFF;
+    d->firstClusterHigh = firstCluster_ >> 16;
+
+    // set modify time if user supplied a callback date/time function
+    if (dateTime_) {
+      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
+      d->lastAccessDate = d->lastWriteDate;
+    }
+    // clear directory dirty
+    flags_ &= ~F_FILE_DIR_DIRTY;
+  }
+  return vol_->cacheFlush();
+
+ fail:
+  writeError = true;
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Copy a file's timestamps
+ *
+ * \param[in] file File to copy timestamps from.
+ *
+ * \note
+ * Modify and access timestamps may be overwritten if a date time callback
+ * function has been set by dateTimeCallback().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::timestamp(SdBaseFile* file) {
+  dir_t* d;
+  dir_t dir;
+
+  // get timestamps
+  if (!file->dirEntry(&dir)) goto fail;
+
+  // update directory fields
+  if (!sync()) goto fail;
+
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+
+  // copy timestamps
+  d->lastAccessDate = dir.lastAccessDate;
+  d->creationDate = dir.creationDate;
+  d->creationTime = dir.creationTime;
+  d->creationTimeTenths = dir.creationTimeTenths;
+  d->lastWriteDate = dir.lastWriteDate;
+  d->lastWriteTime = dir.lastWriteTime;
+
+  // write back entry
+  return vol_->cacheFlush();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Set a file's timestamps in its directory entry.
+ *
+ * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive
+ * OR of flags from the following list
+ *
+ * T_ACCESS - Set the file's last access date.
+ *
+ * T_CREATE - Set the file's creation date and time.
+ *
+ * T_WRITE - Set the file's last write/modification date and time.
+ *
+ * \param[in] year Valid range 1980 - 2107 inclusive.
+ *
+ * \param[in] month Valid range 1 - 12 inclusive.
+ *
+ * \param[in] day Valid range 1 - 31 inclusive.
+ *
+ * \param[in] hour Valid range 0 - 23 inclusive.
+ *
+ * \param[in] minute Valid range 0 - 59 inclusive.
+ *
+ * \param[in] second Valid range 0 - 59 inclusive
+ *
+ * \note It is possible to set an invalid date since there is no check for
+ * the number of days in a month.
+ *
+ * \note
+ * Modify and access timestamps may be overwritten if a date time callback
+ * function has been set by dateTimeCallback().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
+         uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
+  uint16_t dirDate;
+  uint16_t dirTime;
+  dir_t* d;
+
+  if (!isOpen()
+    || year < 1980
+    || year > 2107
+    || month < 1
+    || month > 12
+    || day < 1
+    || day > 31
+    || hour > 23
+    || minute > 59
+    || second > 59) {
+      goto fail;
+  }
+  // update directory entry
+  if (!sync()) goto fail;
+
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto fail;
+
+  dirDate = FAT_DATE(year, month, day);
+  dirTime = FAT_TIME(hour, minute, second);
+  if (flags & T_ACCESS) {
+    d->lastAccessDate = dirDate;
+  }
+  if (flags & T_CREATE) {
+    d->creationDate = dirDate;
+    d->creationTime = dirTime;
+    // seems to be units of 1/100 second not 1/10 as Microsoft states
+    d->creationTimeTenths = second & 1 ? 100 : 0;
+  }
+  if (flags & T_WRITE) {
+    d->lastWriteDate = dirDate;
+    d->lastWriteTime = dirTime;
+  }
+  return vol_->cacheFlush();
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Truncate a file to a specified length.  The current file position
+ * will be maintained if it is less than or equal to \a length otherwise
+ * it will be set to end of file.
+ *
+ * \param[in] length The desired length for the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include file is read only, file is a directory,
+ * \a length is greater than the current file size or an I/O error occurs.
+ */
+bool SdBaseFile::truncate(uint32_t length) {
+  uint32_t newPos;
+  // error if not a normal file or read-only
+  if (!isFile() || !(flags_ & O_WRITE)) goto fail;
+
+  // error if length is greater than current size
+  if (length > fileSize_) goto fail;
+
+  // fileSize and length are zero - nothing to do
+  if (fileSize_ == 0) return true;
+
+  // remember position for seek after truncation
+  newPos = curPosition_ > length ? length : curPosition_;
+
+  // position to last cluster in truncated file
+  if (!seekSet(length)) goto fail;
+
+  if (length == 0) {
+    // free all clusters
+    if (!vol_->freeChain(firstCluster_)) goto fail;
+    firstCluster_ = 0;
+  } else {
+    uint32_t toFree;
+    if (!vol_->fatGet(curCluster_, &toFree)) goto fail;
+
+    if (!vol_->isEOC(toFree)) {
+      // free extra clusters
+      if (!vol_->freeChain(toFree)) goto fail;
+
+      // current cluster is end of chain
+      if (!vol_->fatPutEOC(curCluster_)) goto fail;
+    }
+  }
+  fileSize_ = length;
+
+  // need to update directory entry
+  flags_ |= F_FILE_DIR_DIRTY;
+
+  if (!sync()) goto fail;
+
+  // set file to correct position
+  return seekSet(newPos);
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Write data to an open file.
+ *
+ * \note Data is moved to the cache but may not be written to the
+ * storage device until sync() is called.
+ *
+ * \param[in] buf Pointer to the location of the data to be written.
+ *
+ * \param[in] nbyte Number of bytes to write.
+ *
+ * \return For success write() returns the number of bytes written, always
+ * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
+ * include write() is called before a file has been opened, write is called
+ * for a read-only file, device is full, a corrupt file system or an I/O error.
+ *
+ */
+int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
+  // convert void* to uint8_t*  -  must be before goto statements
+  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
+
+  // number of bytes left to write  -  must be before goto statements
+  uint16_t nToWrite = nbyte;
+
+  // error if not a normal file or is read-only
+  if (!isFile() || !(flags_ & O_WRITE)) goto fail;
+
+  // seek to end of file if append flag
+  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
+    if (!seekEnd()) goto fail;
+  }
+
+  while (nToWrite > 0) {
+    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
+    uint16_t blockOffset = curPosition_ & 0X1FF;
+    if (blockOfCluster == 0 && blockOffset == 0) {
+      // start of new cluster
+      if (curCluster_ == 0) {
+        if (firstCluster_ == 0) {
+          // allocate first cluster of file
+          if (!addCluster()) goto fail;
+        } else {
+          curCluster_ = firstCluster_;
+        }
+      } else {
+        uint32_t next;
+        if (!vol_->fatGet(curCluster_, &next)) goto fail;
+        if (vol_->isEOC(next)) {
+          // add cluster if at end of chain
+          if (!addCluster()) goto fail;
+        } else {
+          curCluster_ = next;
+        }
+      }
+    }
+    // max space in block
+    uint16_t n = 512 - blockOffset;
+
+    // lesser of space and amount to write
+    if (n > nToWrite) n = nToWrite;
+
+    // block for data write
+    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
+    if (n == 512) {
+      // full block - don't need to use cache
+      if (vol_->cacheBlockNumber() == block) {
+        // invalidate cache if block is in cache
+        vol_->cacheSetBlockNumber(0XFFFFFFFF, false);
+      }
+      if (!vol_->writeBlock(block, src)) goto fail;
+    } else {
+      if (blockOffset == 0 && curPosition_ >= fileSize_) {
+        // start of new block don't need to read into cache
+        if (!vol_->cacheFlush()) goto fail;
+        // set cache dirty and SD address of block
+        vol_->cacheSetBlockNumber(block, true);
+      } else {
+        // rewrite part of block
+        if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;
+      }
+      uint8_t* dst = vol_->cache()->data + blockOffset;
+      memcpy(dst, src, n);
+    }
+    curPosition_ += n;
+    src += n;
+    nToWrite -= n;
+  }
+  if (curPosition_ > fileSize_) {
+    // update fileSize and insure sync will update dir entry
+    fileSize_ = curPosition_;
+    flags_ |= F_FILE_DIR_DIRTY;
+  } else if (dateTime_ && nbyte) {
+    // insure sync will update modified date and time
+    flags_ |= F_FILE_DIR_DIRTY;
+  }
+
+  if (flags_ & O_SYNC) {
+    if (!sync()) goto fail;
+  }
+  return nbyte;
+
+ fail:
+  // return for write error
+  writeError = true;
+  return -1;
+}
+//------------------------------------------------------------------------------
+// suppress cpplint warnings with NOLINT comment
+#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
+void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT
+#endif  // ALLOW_DEPRECATED_FUNCTIONS
+
+
+#endif
diff --git a/Marlin/SdBaseFile.h b/Marlin/SdBaseFile.h
new file mode 100644
index 0000000..dea299a
--- /dev/null
+++ b/Marlin/SdBaseFile.h
@@ -0,0 +1,483 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef SdBaseFile_h
+#define SdBaseFile_h
+/**
+ * \file
+ * \brief SdBaseFile class
+ */
+#include "Marlin.h"
+#include "SdFatConfig.h"
+#include "SdVolume.h"
+//------------------------------------------------------------------------------
+/**
+ * \struct fpos_t
+ * \brief internal type for istream
+ * do not use in user apps
+ */
+struct fpos_t {
+  /** stream position */
+  uint32_t position;
+  /** cluster for position */
+  uint32_t cluster;
+  fpos_t() : position(0), cluster(0) {}
+};
+
+// use the gnu style oflag in open()
+/** open() oflag for reading */
+uint8_t const O_READ = 0X01;
+/** open() oflag - same as O_IN */
+uint8_t const O_RDONLY = O_READ;
+/** open() oflag for write */
+uint8_t const O_WRITE = 0X02;
+/** open() oflag - same as O_WRITE */
+uint8_t const O_WRONLY = O_WRITE;
+/** open() oflag for reading and writing */
+uint8_t const O_RDWR = (O_READ | O_WRITE);
+/** open() oflag mask for access modes */
+uint8_t const O_ACCMODE = (O_READ | O_WRITE);
+/** The file offset shall be set to the end of the file prior to each write. */
+uint8_t const O_APPEND = 0X04;
+/** synchronous writes - call sync() after each write */
+uint8_t const O_SYNC = 0X08;
+/** truncate the file to zero length */
+uint8_t const O_TRUNC = 0X10;
+/** set the initial position at the end of the file */
+uint8_t const O_AT_END = 0X20;
+/** create the file if nonexistent */
+uint8_t const O_CREAT = 0X40;
+/** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */
+uint8_t const O_EXCL = 0X80;
+
+// SdBaseFile class static and const definitions
+// flags for ls()
+/** ls() flag to print modify date */
+uint8_t const LS_DATE = 1;
+/** ls() flag to print file size */
+uint8_t const LS_SIZE = 2;
+/** ls() flag for recursive list of subdirectories */
+uint8_t const LS_R = 4;
+
+
+// flags for timestamp
+/** set the file's last access date */
+uint8_t const T_ACCESS = 1;
+/** set the file's creation date and time */
+uint8_t const T_CREATE = 2;
+/** Set the file's write date and time */
+uint8_t const T_WRITE = 4;
+// values for type_
+/** This file has not been opened. */
+uint8_t const FAT_FILE_TYPE_CLOSED = 0;
+/** A normal file */
+uint8_t const FAT_FILE_TYPE_NORMAL = 1;
+/** A FAT12 or FAT16 root directory */
+uint8_t const FAT_FILE_TYPE_ROOT_FIXED = 2;
+/** A FAT32 root directory */
+uint8_t const FAT_FILE_TYPE_ROOT32 = 3;
+/** A subdirectory file*/
+uint8_t const FAT_FILE_TYPE_SUBDIR = 4;
+/** Test value for directory type */
+uint8_t const FAT_FILE_TYPE_MIN_DIR = FAT_FILE_TYPE_ROOT_FIXED;
+
+/** date field for FAT directory entry
+ * \param[in] year [1980,2107]
+ * \param[in] month [1,12]
+ * \param[in] day [1,31]
+ *
+ * \return Packed date for dir_t entry.
+ */
+static inline uint16_t FAT_DATE(uint16_t year, uint8_t month, uint8_t day) {
+  return (year - 1980) << 9 | month << 5 | day;
+}
+/** year part of FAT directory date field
+ * \param[in] fatDate Date in packed dir format.
+ *
+ * \return Extracted year [1980,2107]
+ */
+static inline uint16_t FAT_YEAR(uint16_t fatDate) {
+  return 1980 + (fatDate >> 9);
+}
+/** month part of FAT directory date field
+ * \param[in] fatDate Date in packed dir format.
+ *
+ * \return Extracted month [1,12]
+ */
+static inline uint8_t FAT_MONTH(uint16_t fatDate) {
+  return (fatDate >> 5) & 0XF;
+}
+/** day part of FAT directory date field
+ * \param[in] fatDate Date in packed dir format.
+ *
+ * \return Extracted day [1,31]
+ */
+static inline uint8_t FAT_DAY(uint16_t fatDate) {
+  return fatDate & 0X1F;
+}
+/** time field for FAT directory entry
+ * \param[in] hour [0,23]
+ * \param[in] minute [0,59]
+ * \param[in] second [0,59]
+ *
+ * \return Packed time for dir_t entry.
+ */
+static inline uint16_t FAT_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
+  return hour << 11 | minute << 5 | second >> 1;
+}
+/** hour part of FAT directory time field
+ * \param[in] fatTime Time in packed dir format.
+ *
+ * \return Extracted hour [0,23]
+ */
+static inline uint8_t FAT_HOUR(uint16_t fatTime) {
+  return fatTime >> 11;
+}
+/** minute part of FAT directory time field
+ * \param[in] fatTime Time in packed dir format.
+ *
+ * \return Extracted minute [0,59]
+ */
+static inline uint8_t FAT_MINUTE(uint16_t fatTime) {
+  return(fatTime >> 5) & 0X3F;
+}
+/** second part of FAT directory time field
+ * Note second/2 is stored in packed time.
+ *
+ * \param[in] fatTime Time in packed dir format.
+ *
+ * \return Extracted second [0,58]
+ */
+static inline uint8_t FAT_SECOND(uint16_t fatTime) {
+  return 2*(fatTime & 0X1F);
+}
+/** Default date for file timestamps is 1 Jan 2000 */
+uint16_t const FAT_DEFAULT_DATE = ((2000 - 1980) << 9) | (1 << 5) | 1;
+/** Default time for file timestamp is 1 am */
+uint16_t const FAT_DEFAULT_TIME = (1 << 11);
+//------------------------------------------------------------------------------
+/**
+ * \class SdBaseFile
+ * \brief Base class for SdFile with Print and C++ streams.
+ */
+class SdBaseFile {
+ public:
+  /** Create an instance. */
+  SdBaseFile() : writeError(false), type_(FAT_FILE_TYPE_CLOSED) {}
+  SdBaseFile(const char* path, uint8_t oflag);
+  ~SdBaseFile() {if(isOpen()) close();}
+  /**
+   * writeError is set to true if an error occurs during a write().
+   * Set writeError to false before calling print() and/or write() and check
+   * for true after calls to print() and/or write().
+   */
+  bool writeError;
+  //----------------------------------------------------------------------------
+  // helpers for stream classes
+  /** get position for streams
+   * \param[out] pos struct to receive position
+   */
+  void getpos(fpos_t* pos);
+  /** set position for streams
+   * \param[out] pos struct with value for new position
+   */
+  void setpos(fpos_t* pos);
+  //----------------------------------------------------------------------------
+  bool close();
+  bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);
+  bool createContiguous(SdBaseFile* dirFile,
+          const char* path, uint32_t size);
+  /** \return The current cluster number for a file or directory. */
+  uint32_t curCluster() const {return curCluster_;}
+  /** \return The current position for a file or directory. */
+  uint32_t curPosition() const {return curPosition_;}
+  /** \return Current working directory */
+  static SdBaseFile* cwd() {return cwd_;}
+  /** Set the date/time callback function
+   *
+   * \param[in] dateTime The user's call back function.  The callback
+   * function is of the form:
+   *
+   * \code
+   * void dateTime(uint16_t* date, uint16_t* time) {
+   *   uint16_t year;
+   *   uint8_t month, day, hour, minute, second;
+   *
+   *   // User gets date and time from GPS or real-time clock here
+   *
+   *   // return date using FAT_DATE macro to format fields
+   *   *date = FAT_DATE(year, month, day);
+   *
+   *   // return time using FAT_TIME macro to format fields
+   *   *time = FAT_TIME(hour, minute, second);
+   * }
+   * \endcode
+   *
+   * Sets the function that is called when a file is created or when
+   * a file's directory entry is modified by sync(). All timestamps,
+   * access, creation, and modify, are set when a file is created.
+   * sync() maintains the last access date and last modify date/time.
+   *
+   * See the timestamp() function.
+   */
+  static void dateTimeCallback(
+    void (*dateTime)(uint16_t* date, uint16_t* time)) {
+    dateTime_ = dateTime;
+  }
+  /**  Cancel the date/time callback function. */
+  static void dateTimeCallbackCancel() {dateTime_ = 0;}
+  bool dirEntry(dir_t* dir);
+  static void dirName(const dir_t& dir, char* name);
+  bool exists(const char* name);
+  int16_t fgets(char* str, int16_t num, char* delim = 0);
+  /** \return The total number of bytes in a file or directory. */
+  uint32_t fileSize() const {return fileSize_;}
+  /** \return The first cluster number for a file or directory. */
+  uint32_t firstCluster() const {return firstCluster_;}
+  bool getFilename(char* name);
+  /** \return True if this is a directory else false. */
+  bool isDir() const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
+  /** \return True if this is a normal file else false. */
+  bool isFile() const {return type_ == FAT_FILE_TYPE_NORMAL;}
+  /** \return True if this is an open file/directory else false. */
+  bool isOpen() const {return type_ != FAT_FILE_TYPE_CLOSED;}
+  /** \return True if this is a subdirectory else false. */
+  bool isSubDir() const {return type_ == FAT_FILE_TYPE_SUBDIR;}
+  /** \return True if this is the root directory. */
+  bool isRoot() const {
+    return type_ == FAT_FILE_TYPE_ROOT_FIXED || type_ == FAT_FILE_TYPE_ROOT32;
+  }
+  void ls( uint8_t flags = 0, uint8_t indent = 0);
+  bool mkdir(SdBaseFile* dir, const char* path, bool pFlag = true);
+  // alias for backward compactability
+  bool makeDir(SdBaseFile* dir, const char* path) {
+    return mkdir(dir, path, false);
+  }
+  bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);
+  bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);
+  bool open(const char* path, uint8_t oflag = O_READ);
+  bool openNext(SdBaseFile* dirFile, uint8_t oflag);
+  bool openRoot(SdVolume* vol);
+  int peek();
+  static void printFatDate(uint16_t fatDate);
+  static void printFatTime( uint16_t fatTime);
+  bool printName();
+  int16_t read();
+  int16_t read(void* buf, uint16_t nbyte);
+  int8_t readDir(dir_t* dir, char* longFilename);
+  static bool remove(SdBaseFile* dirFile, const char* path);
+  bool remove();
+  /** Set the file's current position to zero. */
+  void rewind() {seekSet(0);}
+  bool rename(SdBaseFile* dirFile, const char* newPath);
+  bool rmdir();
+  // for backward compatibility
+  bool rmDir() {return rmdir();}
+  bool rmRfStar();
+  /** Set the files position to current position + \a pos. See seekSet().
+   * \param[in] offset The new position in bytes from the current position.
+   * \return true for success or false for failure.
+   */
+  bool seekCur(int32_t offset) {
+    return seekSet(curPosition_ + offset);
+  }
+  /** Set the files position to end-of-file + \a offset. See seekSet().
+   * \param[in] offset The new position in bytes from end-of-file.
+   * \return true for success or false for failure.
+   */
+  bool seekEnd(int32_t offset = 0) {return seekSet(fileSize_ + offset);}
+  bool seekSet(uint32_t pos);
+  bool sync();
+  bool timestamp(SdBaseFile* file);
+  bool timestamp(uint8_t flag, uint16_t year, uint8_t month, uint8_t day,
+          uint8_t hour, uint8_t minute, uint8_t second);
+  /** Type of file.  You should use isFile() or isDir() instead of type()
+   * if possible.
+   *
+   * \return The file or directory type.
+   */
+  uint8_t type() const {return type_;}
+  bool truncate(uint32_t size);
+  /** \return SdVolume that contains this file. */
+  SdVolume* volume() const {return vol_;}
+  int16_t write(const void* buf, uint16_t nbyte);
+//------------------------------------------------------------------------------
+ private:
+  // allow SdFat to set cwd_
+  friend class SdFat;
+  // global pointer to cwd dir
+  static SdBaseFile* cwd_;
+  // data time callback function
+  static void (*dateTime_)(uint16_t* date, uint16_t* time);
+  // bits defined in flags_
+  // should be 0X0F
+  static uint8_t const F_OFLAG = (O_ACCMODE | O_APPEND | O_SYNC);
+  // sync of directory entry required
+  static uint8_t const F_FILE_DIR_DIRTY = 0X80;
+
+  // private data
+  uint8_t   flags_;         // See above for definition of flags_ bits
+  uint8_t   fstate_;        // error and eof indicator
+  uint8_t   type_;          // type of file see above for values
+  uint32_t  curCluster_;    // cluster for current file position
+  uint32_t  curPosition_;   // current file position in bytes from beginning
+  uint32_t  dirBlock_;      // block for this files directory entry
+  uint8_t   dirIndex_;      // index of directory entry in dirBlock
+  uint32_t  fileSize_;      // file size in bytes
+  uint32_t  firstCluster_;  // first cluster of file
+  SdVolume* vol_;           // volume where file is located
+
+  /** experimental don't use */
+  bool openParent(SdBaseFile* dir);
+  // private functions
+  bool addCluster();
+  bool addDirCluster();
+  dir_t* cacheDirEntry(uint8_t action);
+  int8_t lsPrintNext( uint8_t flags, uint8_t indent);
+  static bool make83Name(const char* str, uint8_t* name, const char** ptr);
+  bool mkdir(SdBaseFile* parent, const uint8_t dname[11]);
+  bool open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag);
+  bool openCachedEntry(uint8_t cacheIndex, uint8_t oflags);
+  dir_t* readDirCache();
+//------------------------------------------------------------------------------
+// to be deleted
+  static void printDirName( const dir_t& dir,
+    uint8_t width, bool printSlash);
+//------------------------------------------------------------------------------
+// Deprecated functions  - suppress cpplint warnings with NOLINT comment
+#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
+ public:
+  /** \deprecated Use:
+   * bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);
+   * \param[out] bgnBlock the first block address for the file.
+   * \param[out] endBlock the last  block address for the file.
+   * \return true for success or false for failure.
+   */
+  bool contiguousRange(uint32_t& bgnBlock, uint32_t& endBlock) {  // NOLINT
+    return contiguousRange(&bgnBlock, &endBlock);
+  }
+ /** \deprecated Use:
+   * bool createContiguous(SdBaseFile* dirFile,
+   *   const char* path, uint32_t size)
+   * \param[in] dirFile The directory where the file will be created.
+   * \param[in] path A path with a valid DOS 8.3 file name.
+   * \param[in] size The desired file size.
+   * \return true for success or false for failure.
+   */
+  bool createContiguous(SdBaseFile& dirFile,  // NOLINT
+    const char* path, uint32_t size) {
+    return createContiguous(&dirFile, path, size);
+  }
+  /** \deprecated Use:
+   * static void dateTimeCallback(
+   *   void (*dateTime)(uint16_t* date, uint16_t* time));
+   * \param[in] dateTime The user's call back function.
+   */
+  static void dateTimeCallback(
+    void (*dateTime)(uint16_t& date, uint16_t& time)) {  // NOLINT
+    oldDateTime_ = dateTime;
+    dateTime_ = dateTime ? oldToNew : 0;
+  }
+  /** \deprecated Use: bool dirEntry(dir_t* dir);
+   * \param[out] dir Location for return of the file's directory entry.
+   * \return true for success or false for failure.
+   */
+  bool dirEntry(dir_t& dir) {return dirEntry(&dir);}  // NOLINT
+  /** \deprecated Use:
+   * bool mkdir(SdBaseFile* dir, const char* path);
+   * \param[in] dir An open SdFat instance for the directory that will contain
+   * the new directory.
+   * \param[in] path A path with a valid 8.3 DOS name for the new directory.
+   * \return true for success or false for failure.
+   */
+  bool mkdir(SdBaseFile& dir, const char* path) {  // NOLINT
+    return mkdir(&dir, path);
+  }
+  /** \deprecated Use:
+   * bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);
+   * \param[in] dirFile An open SdFat instance for the directory containing the
+   * file to be opened.
+   * \param[in] path A path with a valid 8.3 DOS name for the file.
+   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+   * \return true for success or false for failure.
+   */
+  bool open(SdBaseFile& dirFile, // NOLINT
+    const char* path, uint8_t oflag) {
+    return open(&dirFile, path, oflag);
+  }
+  /** \deprecated  Do not use in new apps
+   * \param[in] dirFile An open SdFat instance for the directory containing the
+   * file to be opened.
+   * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+   * \return true for success or false for failure.
+   */
+  bool open(SdBaseFile& dirFile, const char* path) {  // NOLINT
+    return open(dirFile, path, O_RDWR);
+  }
+  /** \deprecated Use:
+   * bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);
+   * \param[in] dirFile An open SdFat instance for the directory.
+   * \param[in] index The \a index of the directory entry for the file to be
+   * opened.  The value for \a index is (directory file position)/32.
+   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+   * \return true for success or false for failure.
+   */
+  bool open(SdBaseFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
+    return open(&dirFile, index, oflag);
+  }
+  /** \deprecated Use: bool openRoot(SdVolume* vol);
+   * \param[in] vol The FAT volume containing the root directory to be opened.
+   * \return true for success or false for failure.
+   */
+  bool openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT
+  /** \deprecated Use: int8_t readDir(dir_t* dir);
+   * \param[out] dir The dir_t struct that will receive the data.
+   * \return bytes read for success zero for eof or -1 for failure.
+   */
+  int8_t readDir(dir_t& dir, char* longFilename) {return readDir(&dir, longFilename);}  // NOLINT
+  /** \deprecated Use:
+   * static uint8_t remove(SdBaseFile* dirFile, const char* path);
+   * \param[in] dirFile The directory that contains the file.
+   * \param[in] path The name of the file to be removed.
+   * \return true for success or false for failure.
+   */
+  static bool remove(SdBaseFile& dirFile, const char* path) {  // NOLINT
+    return remove(&dirFile, path);
+  }
+//------------------------------------------------------------------------------
+// rest are private
+ private:
+  static void (*oldDateTime_)(uint16_t& date, uint16_t& time);  // NOLINT
+  static void oldToNew(uint16_t* date, uint16_t* time) {
+    uint16_t d;
+    uint16_t t;
+    oldDateTime_(d, t);
+    *date = d;
+    *time = t;
+  }
+#endif  // ALLOW_DEPRECATED_FUNCTIONS
+};
+
+#endif  // SdBaseFile_h
+#endif
diff --git a/Marlin/SdFatConfig.h b/Marlin/SdFatConfig.h
new file mode 100644
index 0000000..24caf6f
--- /dev/null
+++ b/Marlin/SdFatConfig.h
@@ -0,0 +1,123 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+/**
+ * \file
+ * \brief configuration definitions
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef SdFatConfig_h
+#define SdFatConfig_h
+#include <stdint.h>
+//------------------------------------------------------------------------------
+/**
+ * To use multiple SD cards set USE_MULTIPLE_CARDS nonzero.
+ *
+ * Using multiple cards costs 400 - 500  bytes of flash.
+ *
+ * Each card requires about 550 bytes of SRAM so use of a Mega is recommended.
+ */
+#define USE_MULTIPLE_CARDS 0
+//------------------------------------------------------------------------------
+/**
+ * Call flush for endl if ENDL_CALLS_FLUSH is nonzero
+ *
+ * The standard for iostreams is to call flush.  This is very costly for
+ * SdFat.  Each call to flush causes 2048 bytes of I/O to the SD.
+ *
+ * SdFat has a single 512 byte buffer for SD I/O so it must write the current
+ * data block to the SD, read the directory block from the SD, update the
+ * directory entry, write the directory block to the SD and read the data
+ * block back into the buffer.
+ *
+ * The SD flash memory controller is not designed for this many rewrites
+ * so performance may be reduced by more than a factor of 100.
+ *
+ * If ENDL_CALLS_FLUSH is zero, you must call flush and/or close to force
+ * all data to be written to the SD.
+ */
+#define ENDL_CALLS_FLUSH 0
+//------------------------------------------------------------------------------
+/**
+ * Allow use of deprecated functions if ALLOW_DEPRECATED_FUNCTIONS is nonzero
+ */
+#define ALLOW_DEPRECATED_FUNCTIONS 1
+//------------------------------------------------------------------------------
+/**
+ * Allow FAT12 volumes if FAT12_SUPPORT is nonzero.
+ * FAT12 has not been well tested.
+ */
+#define FAT12_SUPPORT 0
+//------------------------------------------------------------------------------
+/**
+ * SPI init rate for SD initialization commands. Must be 5 (F_CPU/64)
+ * or 6 (F_CPU/128).
+ */
+#define SPI_SD_INIT_RATE 5
+//------------------------------------------------------------------------------
+/**
+ * Set the SS pin high for hardware SPI.  If SS is chip select for another SPI
+ * device this will disable that device during the SD init phase.
+ */
+#define SET_SPI_SS_HIGH 1
+//------------------------------------------------------------------------------
+/**
+ * Define MEGA_SOFT_SPI nonzero to use software SPI on Mega Arduinos.
+ * Pins used are SS 10, MOSI 11, MISO 12, and SCK 13.
+ *
+ * MEGA_SOFT_SPI allows an unmodified Adafruit GPS Shield to be used
+ * on Mega Arduinos.  Software SPI works well with GPS Shield V1.1
+ * but many SD cards will fail with GPS Shield V1.0.
+ */
+#define MEGA_SOFT_SPI 0
+//------------------------------------------------------------------------------
+/**
+ * Set USE_SOFTWARE_SPI nonzero to always use software SPI.
+ */
+#define USE_SOFTWARE_SPI 0
+// define software SPI pins so Mega can use unmodified 168/328 shields
+/** Software SPI chip select pin for the SD */
+uint8_t const SOFT_SPI_CS_PIN = 10;
+/** Software SPI Master Out Slave In pin */
+uint8_t const SOFT_SPI_MOSI_PIN = 11;
+/** Software SPI Master In Slave Out pin */
+uint8_t const SOFT_SPI_MISO_PIN = 12;
+/** Software SPI Clock pin */
+uint8_t const SOFT_SPI_SCK_PIN = 13;
+//------------------------------------------------------------------------------
+/**
+ * The __cxa_pure_virtual function is an error handler that is invoked when
+ * a pure virtual function is called.
+ */
+#define USE_CXA_PURE_VIRTUAL 1
+/**
+ * Defines for long (vfat) filenames
+ */
+/** Number of VFAT entries used. Every entry has 13 UTF-16 characters */
+#define MAX_VFAT_ENTRIES (2)
+/** Number of UTF-16 characters per entry */
+#define FILENAME_LENGTH 13
+/** Total size of the buffer used to store the long filenames */
+#define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
+#endif  // SdFatConfig_h
+
+
+#endif
diff --git a/Marlin/SdFatStructs.h b/Marlin/SdFatStructs.h
new file mode 100644
index 0000000..3867216
--- /dev/null
+++ b/Marlin/SdFatStructs.h
@@ -0,0 +1,646 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef SdFatStructs_h
+#define SdFatStructs_h
+
+#define PACKED __attribute__((__packed__))
+/**
+ * \file
+ * \brief FAT file structures
+ */
+/*
+ * mostly from Microsoft document fatgen103.doc
+ * http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx
+ */
+//------------------------------------------------------------------------------
+/** Value for byte 510 of boot block or MBR */
+uint8_t const BOOTSIG0 = 0X55;
+/** Value for byte 511 of boot block or MBR */
+uint8_t const BOOTSIG1 = 0XAA;
+/** Value for bootSignature field int FAT/FAT32 boot sector */
+uint8_t const EXTENDED_BOOT_SIG = 0X29;
+//------------------------------------------------------------------------------
+/**
+ * \struct partitionTable
+ * \brief MBR partition table entry
+ *
+ * A partition table entry for a MBR formatted storage device.
+ * The MBR partition table has four entries.
+ */
+struct partitionTable {
+          /**
+           * Boot Indicator . Indicates whether the volume is the active
+           * partition.  Legal values include: 0X00. Do not use for booting.
+           * 0X80 Active partition.
+           */
+  uint8_t  boot;
+          /**
+            * Head part of Cylinder-head-sector address of the first block in
+            * the partition. Legal values are 0-255. Only used in old PC BIOS.
+            */
+  uint8_t  beginHead;
+          /**
+           * Sector part of Cylinder-head-sector address of the first block in
+           * the partition. Legal values are 1-63. Only used in old PC BIOS.
+           */
+  unsigned beginSector : 6;
+           /** High bits cylinder for first block in partition. */
+  unsigned beginCylinderHigh : 2;
+          /**
+           * Combine beginCylinderLow with beginCylinderHigh. Legal values
+           * are 0-1023.  Only used in old PC BIOS.
+           */
+  uint8_t  beginCylinderLow;
+          /**
+           * Partition type. See defines that begin with PART_TYPE_ for
+           * some Microsoft partition types.
+           */
+  uint8_t  type;
+          /**
+           * head part of cylinder-head-sector address of the last sector in the
+           * partition.  Legal values are 0-255. Only used in old PC BIOS.
+           */
+  uint8_t  endHead;
+          /**
+           * Sector part of cylinder-head-sector address of the last sector in
+           * the partition.  Legal values are 1-63. Only used in old PC BIOS.
+           */
+  unsigned endSector : 6;
+           /** High bits of end cylinder */
+  unsigned endCylinderHigh : 2;
+          /**
+           * Combine endCylinderLow with endCylinderHigh. Legal values
+           * are 0-1023.  Only used in old PC BIOS.
+           */
+  uint8_t  endCylinderLow;
+           /** Logical block address of the first block in the partition. */
+  uint32_t firstSector;
+           /** Length of the partition, in blocks. */
+  uint32_t totalSectors;
+} PACKED;
+/** Type name for partitionTable */
+typedef struct partitionTable part_t;
+//------------------------------------------------------------------------------
+/**
+ * \struct masterBootRecord
+ *
+ * \brief Master Boot Record
+ *
+ * The first block of a storage device that is formatted with a MBR.
+ */
+struct masterBootRecord {
+           /** Code Area for master boot program. */
+  uint8_t  codeArea[440];
+           /** Optional Windows NT disk signature. May contain boot code. */
+  uint32_t diskSignature;
+           /** Usually zero but may be more boot code. */
+  uint16_t usuallyZero;
+           /** Partition tables. */
+  part_t   part[4];
+           /** First MBR signature byte. Must be 0X55 */
+  uint8_t  mbrSig0;
+           /** Second MBR signature byte. Must be 0XAA */
+  uint8_t  mbrSig1;
+} PACKED;
+/** Type name for masterBootRecord */
+typedef struct masterBootRecord mbr_t;
+//------------------------------------------------------------------------------
+/**
+ * \struct fat_boot
+ *
+ * \brief Boot sector for a FAT12/FAT16 volume.
+ *
+ */
+struct fat_boot {
+         /**
+          * The first three bytes of the boot sector must be valid,
+          * executable x 86-based CPU instructions. This includes a
+          * jump instruction that skips the next nonexecutable bytes.
+          */
+  uint8_t jump[3];
+         /**
+          * This is typically a string of characters that identifies
+          * the operating system that formatted the volume.
+          */
+  char    oemId[8];
+          /**
+           * The size of a hardware sector. Valid decimal values for this
+           * field are 512, 1024, 2048, and 4096. For most disks used in
+           * the United States, the value of this field is 512.
+           */
+  uint16_t bytesPerSector;
+          /**
+           * Number of sectors per allocation unit. This value must be a
+           * power of 2 that is greater than 0. The legal values are
+           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.
+           */
+  uint8_t  sectorsPerCluster;
+          /**
+           * The number of sectors preceding the start of the first FAT,
+           * including the boot sector. The value of this field is always 1.
+           */
+  uint16_t reservedSectorCount;
+          /**
+           * The number of copies of the FAT on the volume.
+           * The value of this field is always 2.
+           */
+  uint8_t  fatCount;
+          /**
+           * For FAT12 and FAT16 volumes, this field contains the count of
+           * 32-byte directory entries in the root directory. For FAT32 volumes,
+           * this field must be set to 0. For FAT12 and FAT16 volumes, this
+           * value should always specify a count that when multiplied by 32
+           * results in a multiple of bytesPerSector.  FAT16 volumes should
+           * use the value 512.
+           */
+  uint16_t rootDirEntryCount;
+          /**
+           * This field is the old 16-bit total count of sectors on the volume.
+           * This count includes the count of all sectors in all four regions
+           * of the volume. This field can be 0; if it is 0, then totalSectors32
+           * must be nonzero.  For FAT32 volumes, this field must be 0. For
+           * FAT12 and FAT16 volumes, this field contains the sector count, and
+           * totalSectors32 is 0 if the total sector count fits
+           * (is less than 0x10000).
+           */
+  uint16_t totalSectors16;
+          /**
+           * This dates back to the old MS-DOS 1.x media determination and is
+           * no longer usually used for anything.  0xF8 is the standard value
+           * for fixed (nonremovable) media. For removable media, 0xF0 is
+           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.
+           */
+  uint8_t  mediaType;
+          /**
+           * Count of sectors occupied by one FAT on FAT12/FAT16 volumes.
+           * On FAT32 volumes this field must be 0, and sectorsPerFat32
+           * contains the FAT size count.
+           */
+  uint16_t sectorsPerFat16;
+           /** Sectors per track for interrupt 0x13. Not used otherwise. */
+  uint16_t sectorsPerTrack;
+           /** Number of heads for interrupt 0x13.  Not used otherwise. */
+  uint16_t headCount;
+          /**
+           * Count of hidden sectors preceding the partition that contains this
+           * FAT volume. This field is generally only relevant for media
+           * visible on interrupt 0x13.
+           */
+  uint32_t hidddenSectors;
+          /**
+           * This field is the new 32-bit total count of sectors on the volume.
+           * This count includes the count of all sectors in all four regions
+           * of the volume.  This field can be 0; if it is 0, then
+           * totalSectors16 must be nonzero.
+           */
+  uint32_t totalSectors32;
+           /**
+            * Related to the BIOS physical drive number. Floppy drives are
+            * identified as 0x00 and physical hard disks are identified as
+            * 0x80, regardless of the number of physical disk drives.
+            * Typically, this value is set prior to issuing an INT 13h BIOS
+            * call to specify the device to access. The value is only
+            * relevant if the device is a boot device.
+            */
+  uint8_t  driveNumber;
+           /** used by Windows NT - should be zero for FAT */
+  uint8_t  reserved1;
+           /** 0X29 if next three fields are valid */
+  uint8_t  bootSignature;
+           /**
+            * A random serial number created when formatting a disk,
+            * which helps to distinguish between disks.
+            * Usually generated by combining date and time.
+            */
+  uint32_t volumeSerialNumber;
+           /**
+            * A field once used to store the volume label. The volume label
+            * is now stored as a special file in the root directory.
+            */
+  char     volumeLabel[11];
+           /**
+            * A field with a value of either FAT, FAT12 or FAT16,
+            * depending on the disk format.
+            */
+  char     fileSystemType[8];
+           /** X86 boot code */
+  uint8_t  bootCode[448];
+           /** must be 0X55 */
+  uint8_t  bootSectorSig0;
+           /** must be 0XAA */
+  uint8_t  bootSectorSig1;
+} PACKED;
+/** Type name for FAT Boot Sector */
+typedef struct fat_boot fat_boot_t;
+//------------------------------------------------------------------------------
+/**
+ * \struct fat32_boot
+ *
+ * \brief Boot sector for a FAT32 volume.
+ *
+ */
+struct fat32_boot {
+         /**
+          * The first three bytes of the boot sector must be valid,
+          * executable x 86-based CPU instructions. This includes a
+          * jump instruction that skips the next nonexecutable bytes.
+          */
+  uint8_t jump[3];
+         /**
+          * This is typically a string of characters that identifies
+          * the operating system that formatted the volume.
+          */
+  char    oemId[8];
+          /**
+           * The size of a hardware sector. Valid decimal values for this
+           * field are 512, 1024, 2048, and 4096. For most disks used in
+           * the United States, the value of this field is 512.
+           */
+  uint16_t bytesPerSector;
+          /**
+           * Number of sectors per allocation unit. This value must be a
+           * power of 2 that is greater than 0. The legal values are
+           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.
+           */
+  uint8_t  sectorsPerCluster;
+          /**
+           * The number of sectors preceding the start of the first FAT,
+           * including the boot sector. Must not be zero
+           */
+  uint16_t reservedSectorCount;
+          /**
+           * The number of copies of the FAT on the volume.
+           * The value of this field is always 2.
+           */
+  uint8_t  fatCount;
+          /**
+           * FAT12/FAT16 only. For FAT32 volumes, this field must be set to 0.
+           */
+  uint16_t rootDirEntryCount;
+          /**
+           * For FAT32 volumes, this field must be 0.
+           */
+  uint16_t totalSectors16;
+          /**
+           * This dates back to the old MS-DOS 1.x media determination and is
+           * no longer usually used for anything.  0xF8 is the standard value
+           * for fixed (nonremovable) media. For removable media, 0xF0 is
+           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.
+           */
+  uint8_t  mediaType;
+          /**
+           * On FAT32 volumes this field must be 0, and sectorsPerFat32
+           * contains the FAT size count.
+           */
+  uint16_t sectorsPerFat16;
+           /** Sectors per track for interrupt 0x13. Not used otherwise. */
+  uint16_t sectorsPerTrack;
+           /** Number of heads for interrupt 0x13.  Not used otherwise. */
+  uint16_t headCount;
+          /**
+           * Count of hidden sectors preceding the partition that contains this
+           * FAT volume. This field is generally only relevant for media
+           * visible on interrupt 0x13.
+           */
+  uint32_t hidddenSectors;
+          /**
+           * Contains the total number of sectors in the FAT32 volume.
+           */
+  uint32_t totalSectors32;
+         /**
+           * Count of sectors occupied by one FAT on FAT32 volumes.
+           */
+  uint32_t sectorsPerFat32;
+          /**
+           * This field is only defined for FAT32 media and does not exist on
+           * FAT12 and FAT16 media.
+           * Bits 0-3 -- Zero-based number of active FAT.
+           *             Only valid if mirroring is disabled.
+           * Bits 4-6 -- Reserved.
+           * Bit 7	-- 0 means the FAT is mirrored at runtime into all FATs.
+	         *        -- 1 means only one FAT is active; it is the one referenced
+	         *             in bits 0-3.
+           * Bits 8-15 	-- Reserved.
+           */
+  uint16_t fat32Flags;
+          /**
+           * FAT32 version. High byte is major revision number.
+           * Low byte is minor revision number. Only 0.0 define.
+           */
+  uint16_t fat32Version;
+          /**
+           * Cluster number of the first cluster of the root directory for FAT32.
+           * This usually 2 but not required to be 2.
+           */
+  uint32_t fat32RootCluster;
+          /**
+           * Sector number of FSINFO structure in the reserved area of the
+           * FAT32 volume. Usually 1.
+           */
+  uint16_t fat32FSInfo;
+          /**
+           * If nonzero, indicates the sector number in the reserved area
+           * of the volume of a copy of the boot record. Usually 6.
+           * No value other than 6 is recommended.
+           */
+  uint16_t fat32BackBootBlock;
+          /**
+           * Reserved for future expansion. Code that formats FAT32 volumes
+           * should always set all of the bytes of this field to 0.
+           */
+  uint8_t  fat32Reserved[12];
+           /**
+            * Related to the BIOS physical drive number. Floppy drives are
+            * identified as 0x00 and physical hard disks are identified as
+            * 0x80, regardless of the number of physical disk drives.
+            * Typically, this value is set prior to issuing an INT 13h BIOS
+            * call to specify the device to access. The value is only
+            * relevant if the device is a boot device.
+            */
+  uint8_t  driveNumber;
+           /** used by Windows NT - should be zero for FAT */
+  uint8_t  reserved1;
+           /** 0X29 if next three fields are valid */
+  uint8_t  bootSignature;
+           /**
+            * A random serial number created when formatting a disk,
+            * which helps to distinguish between disks.
+            * Usually generated by combining date and time.
+            */
+  uint32_t volumeSerialNumber;
+           /**
+            * A field once used to store the volume label. The volume label
+            * is now stored as a special file in the root directory.
+            */
+  char     volumeLabel[11];
+           /**
+            * A text field with a value of FAT32.
+            */
+  char     fileSystemType[8];
+           /** X86 boot code */
+  uint8_t  bootCode[420];
+           /** must be 0X55 */
+  uint8_t  bootSectorSig0;
+           /** must be 0XAA */
+  uint8_t  bootSectorSig1;
+} PACKED;
+/** Type name for FAT32 Boot Sector */
+typedef struct fat32_boot fat32_boot_t;
+//------------------------------------------------------------------------------
+/** Lead signature for a FSINFO sector */
+uint32_t const FSINFO_LEAD_SIG = 0x41615252;
+/** Struct signature for a FSINFO sector */
+uint32_t const FSINFO_STRUCT_SIG = 0x61417272;
+/**
+ * \struct fat32_fsinfo
+ *
+ * \brief FSINFO sector for a FAT32 volume.
+ *
+ */
+struct fat32_fsinfo {
+           /** must be 0X52, 0X52, 0X61, 0X41 */
+  uint32_t  leadSignature;
+           /** must be zero */
+  uint8_t  reserved1[480];
+           /** must be 0X72, 0X72, 0X41, 0X61 */
+  uint32_t  structSignature;
+          /**
+           * Contains the last known free cluster count on the volume.
+           * If the value is 0xFFFFFFFF, then the free count is unknown
+           * and must be computed. Any other value can be used, but is
+           * not necessarily correct. It should be range checked at least
+           * to make sure it is <= volume cluster count.
+           */
+  uint32_t freeCount;
+          /**
+           * This is a hint for the FAT driver. It indicates the cluster
+           * number at which the driver should start looking for free clusters.
+           * If the value is 0xFFFFFFFF, then there is no hint and the driver
+           * should start looking at cluster 2.
+           */
+  uint32_t nextFree;
+           /** must be zero */
+  uint8_t  reserved2[12];
+           /** must be 0X00, 0X00, 0X55, 0XAA */
+  uint8_t  tailSignature[4];
+} PACKED;
+/** Type name for FAT32 FSINFO Sector */
+typedef struct fat32_fsinfo fat32_fsinfo_t;
+//------------------------------------------------------------------------------
+// End Of Chain values for FAT entries
+/** FAT12 end of chain value used by Microsoft. */
+uint16_t const FAT12EOC = 0XFFF;
+/** Minimum value for FAT12 EOC.  Use to test for EOC. */
+uint16_t const FAT12EOC_MIN = 0XFF8;
+/** FAT16 end of chain value used by Microsoft. */
+uint16_t const FAT16EOC = 0XFFFF;
+/** Minimum value for FAT16 EOC.  Use to test for EOC. */
+uint16_t const FAT16EOC_MIN = 0XFFF8;
+/** FAT32 end of chain value used by Microsoft. */
+uint32_t const FAT32EOC = 0X0FFFFFFF;
+/** Minimum value for FAT32 EOC.  Use to test for EOC. */
+uint32_t const FAT32EOC_MIN = 0X0FFFFFF8;
+/** Mask a for FAT32 entry. Entries are 28 bits. */
+uint32_t const FAT32MASK = 0X0FFFFFFF;
+//------------------------------------------------------------------------------
+/**
+ * \struct directoryEntry
+ * \brief FAT short directory entry
+ *
+ * Short means short 8.3 name, not the entry size.
+ *  
+ * Date Format. A FAT directory entry date stamp is a 16-bit field that is 
+ * basically a date relative to the MS-DOS epoch of 01/01/1980. Here is the
+ * format (bit 0 is the LSB of the 16-bit word, bit 15 is the MSB of the 
+ * 16-bit word):
+ *   
+ * Bits 9-15: Count of years from 1980, valid value range 0-127 
+ * inclusive (1980-2107).
+ *   
+ * Bits 5-8: Month of year, 1 = January, valid value range 1-12 inclusive.
+ *
+ * Bits 0-4: Day of month, valid value range 1-31 inclusive.
+ *
+ * Time Format. A FAT directory entry time stamp is a 16-bit field that has
+ * a granularity of 2 seconds. Here is the format (bit 0 is the LSB of the 
+ * 16-bit word, bit 15 is the MSB of the 16-bit word).
+ *   
+ * Bits 11-15: Hours, valid value range 0-23 inclusive.
+ * 
+ * Bits 5-10: Minutes, valid value range 0-59 inclusive.
+ *      
+ * Bits 0-4: 2-second count, valid value range 0-29 inclusive (0 - 58 seconds).
+ *   
+ * The valid time range is from Midnight 00:00:00 to 23:59:58.
+ */
+struct directoryEntry {
+           /** Short 8.3 name.
+            *
+            * The first eight bytes contain the file name with blank fill.
+            * The last three bytes contain the file extension with blank fill.
+            */
+  uint8_t  name[11];
+          /** Entry attributes.
+           *
+           * The upper two bits of the attribute byte are reserved and should
+           * always be set to 0 when a file is created and never modified or
+           * looked at after that.  See defines that begin with DIR_ATT_.
+           */
+  uint8_t  attributes;
+          /**
+           * Reserved for use by Windows NT. Set value to 0 when a file is
+           * created and never modify or look at it after that.
+           */
+  uint8_t  reservedNT;
+          /**
+           * The granularity of the seconds part of creationTime is 2 seconds
+           * so this field is a count of tenths of a second and its valid
+           * value range is 0-199 inclusive. (WHG note - seems to be hundredths)
+           */
+  uint8_t  creationTimeTenths;
+           /** Time file was created. */
+  uint16_t creationTime;
+           /** Date file was created. */
+  uint16_t creationDate;
+          /**
+           * Last access date. Note that there is no last access time, only
+           * a date.  This is the date of last read or write. In the case of
+           * a write, this should be set to the same date as lastWriteDate.
+           */
+  uint16_t lastAccessDate;
+          /**
+           * High word of this entry's first cluster number (always 0 for a
+           * FAT12 or FAT16 volume).
+           */
+  uint16_t firstClusterHigh;
+           /** Time of last write. File creation is considered a write. */
+  uint16_t lastWriteTime;
+           /** Date of last write. File creation is considered a write. */
+  uint16_t lastWriteDate;
+           /** Low word of this entry's first cluster number. */
+  uint16_t firstClusterLow;
+           /** 32-bit unsigned holding this file's size in bytes. */
+  uint32_t fileSize;
+} PACKED;
+/**
+ * \struct directoryVFATEntry
+ * \brief VFAT long filename directory entry
+ *
+ * directoryVFATEntries are found in the same list as normal directoryEntry.
+ * But have the attribute field set to DIR_ATT_LONG_NAME.
+ * 
+ * Long filenames are saved in multiple directoryVFATEntries.
+ * Each entry containing 13 UTF-16 characters.
+ */
+struct directoryVFATEntry {
+  /**
+   * Sequence number. Consists of 2 parts:
+   *  bit 6:   indicates first long filename block for the next file
+   *  bit 0-4: the position of this long filename block (first block is 1)
+   */
+  uint8_t  sequenceNumber;
+  /** First set of UTF-16 characters */
+  uint16_t name1[5];//UTF-16
+  /** attributes (at the same location as in directoryEntry), always 0x0F */
+  uint8_t  attributes;
+  /** Reserved for use by Windows NT. Always 0. */
+  uint8_t  reservedNT;
+  /** Checksum of the short 8.3 filename, can be used to checked if the file system as modified by a not-long-filename aware implementation. */
+  uint8_t  checksum;
+  /** Second set of UTF-16 characters */
+  uint16_t name2[6];//UTF-16
+  /** firstClusterLow is always zero for longFilenames */
+  uint16_t firstClusterLow;
+  /** Third set of UTF-16 characters */
+  uint16_t name3[2];//UTF-16
+} PACKED;
+//------------------------------------------------------------------------------
+// Definitions for directory entries
+//
+/** Type name for directoryEntry */
+typedef struct directoryEntry dir_t;
+/** Type name for directoryVFATEntry */
+typedef struct directoryVFATEntry vfat_t;
+/** escape for name[0] = 0XE5 */
+uint8_t const DIR_NAME_0XE5 = 0X05;
+/** name[0] value for entry that is free after being "deleted" */
+uint8_t const DIR_NAME_DELETED = 0XE5;
+/** name[0] value for entry that is free and no allocated entries follow */
+uint8_t const DIR_NAME_FREE = 0X00;
+/** file is read-only */
+uint8_t const DIR_ATT_READ_ONLY = 0X01;
+/** File should hidden in directory listings */
+uint8_t const DIR_ATT_HIDDEN = 0X02;
+/** Entry is for a system file */
+uint8_t const DIR_ATT_SYSTEM = 0X04;
+/** Directory entry contains the volume label */
+uint8_t const DIR_ATT_VOLUME_ID = 0X08;
+/** Entry is for a directory */
+uint8_t const DIR_ATT_DIRECTORY = 0X10;
+/** Old DOS archive bit for backup support */
+uint8_t const DIR_ATT_ARCHIVE = 0X20;
+/** Test value for long name entry.  Test is
+  (d->attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME. */
+uint8_t const DIR_ATT_LONG_NAME = 0X0F;
+/** Test mask for long name entry */
+uint8_t const DIR_ATT_LONG_NAME_MASK = 0X3F;
+/** defined attribute bits */
+uint8_t const DIR_ATT_DEFINED_BITS = 0X3F;
+/** Directory entry is part of a long name
+ * \param[in] dir Pointer to a directory entry.
+ *
+ * \return true if the entry is for part of a long name else false.
+ */
+static inline uint8_t DIR_IS_LONG_NAME(const dir_t* dir) {
+  return (dir->attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME;
+}
+/** Mask for file/subdirectory tests */
+uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);
+/** Directory entry is for a file
+ * \param[in] dir Pointer to a directory entry.
+ *
+ * \return true if the entry is for a normal file else false.
+ */
+static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
+  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
+}
+/** Directory entry is for a subdirectory
+ * \param[in] dir Pointer to a directory entry.
+ *
+ * \return true if the entry is for a subdirectory else false.
+ */
+static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
+  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
+}
+/** Directory entry is for a file or subdirectory
+ * \param[in] dir Pointer to a directory entry.
+ *
+ * \return true if the entry is for a normal file or subdirectory else false.
+ */
+static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {
+  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
+}
+#endif  // SdFatStructs_h
+
+
+#endif
diff --git a/Marlin/SdFatUtil.cpp b/Marlin/SdFatUtil.cpp
new file mode 100644
index 0000000..32cd198
--- /dev/null
+++ b/Marlin/SdFatUtil.cpp
@@ -0,0 +1,82 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2008 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+
+#ifdef SDSUPPORT
+#include "SdFatUtil.h"
+
+//------------------------------------------------------------------------------
+/** Amount of free RAM
+ * \return The number of free bytes.
+ */
+#ifdef __arm__
+extern "C" char* sbrk(int incr);
+int SdFatUtil::FreeRam() {
+  char top;
+  return &top - reinterpret_cast<char*>(sbrk(0));
+}
+#else  // __arm__
+extern char *__brkval;
+extern char __bss_end;
+/** Amount of free RAM
+ * \return The number of free bytes.
+ */
+int SdFatUtil::FreeRam() {
+  char top;
+  return __brkval ? &top - __brkval : &top - &__bss_end;
+}
+#endif  // __arm
+
+//------------------------------------------------------------------------------
+/** %Print a string in flash memory.
+ *
+ * \param[in] pr Print object for output.
+ * \param[in] str Pointer to string stored in flash memory.
+ */
+void SdFatUtil::print_P( PGM_P str) {
+  for (uint8_t c; (c = pgm_read_byte(str)); str++) MYSERIAL.write(c);
+}
+//------------------------------------------------------------------------------
+/** %Print a string in flash memory followed by a CR/LF.
+ *
+ * \param[in] pr Print object for output.
+ * \param[in] str Pointer to string stored in flash memory.
+ */
+void SdFatUtil::println_P( PGM_P str) {
+  print_P( str);
+  MYSERIAL.println();
+}
+//------------------------------------------------------------------------------
+/** %Print a string in flash memory to Serial.
+ *
+ * \param[in] str Pointer to string stored in flash memory.
+ */
+void SdFatUtil::SerialPrint_P(PGM_P str) {
+  print_P(str);
+}
+//------------------------------------------------------------------------------
+/** %Print a string in flash memory to Serial followed by a CR/LF.
+ *
+ * \param[in] str Pointer to string stored in flash memory.
+ */
+void SdFatUtil::SerialPrintln_P(PGM_P str) {
+  println_P( str);
+}
+#endif
diff --git a/Marlin/SdFatUtil.h b/Marlin/SdFatUtil.h
new file mode 100644
index 0000000..7f18094
--- /dev/null
+++ b/Marlin/SdFatUtil.h
@@ -0,0 +1,48 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2008 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef SdFatUtil_h
+#define SdFatUtil_h
+/**
+ * \file
+ * \brief Useful utility functions.
+ */
+#include "Marlin.h"
+#include "MarlinSerial.h"
+/** Store and print a string in flash memory.*/
+#define PgmPrint(x) SerialPrint_P(PSTR(x))
+/** Store and print a string in flash memory followed by a CR/LF.*/
+#define PgmPrintln(x) SerialPrintln_P(PSTR(x))
+
+namespace SdFatUtil {
+  int FreeRam();
+  void print_P( PGM_P str);
+  void println_P( PGM_P str);
+  void SerialPrint_P(PGM_P str);
+  void SerialPrintln_P(PGM_P str);
+}
+
+using namespace SdFatUtil;  // NOLINT
+#endif  // #define SdFatUtil_h
+
+
+#endif
\ No newline at end of file
diff --git a/Marlin/SdFile.cpp b/Marlin/SdFile.cpp
new file mode 100644
index 0000000..29f5efa
--- /dev/null
+++ b/Marlin/SdFile.cpp
@@ -0,0 +1,95 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+
+#ifdef SDSUPPORT
+#include "SdFile.h"
+/**  Create a file object and open it in the current working directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
+ */
+SdFile::SdFile(const char* path, uint8_t oflag) : SdBaseFile(path, oflag) {
+}
+//------------------------------------------------------------------------------
+/** Write data to an open file.
+ *
+ * \note Data is moved to the cache but may not be written to the
+ * storage device until sync() is called.
+ *
+ * \param[in] buf Pointer to the location of the data to be written.
+ *
+ * \param[in] nbyte Number of bytes to write.
+ *
+ * \return For success write() returns the number of bytes written, always
+ * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
+ * include write() is called before a file has been opened, write is called
+ * for a read-only file, device is full, a corrupt file system or an I/O error.
+ *
+ */
+int16_t SdFile::write(const void* buf, uint16_t nbyte) {
+  return SdBaseFile::write(buf, nbyte);
+}
+//------------------------------------------------------------------------------
+/** Write a byte to a file. Required by the Arduino Print class.
+ * \param[in] b the byte to be written.
+ * Use writeError to check for errors.
+ */
+#if ARDUINO >= 100
+size_t SdFile::write(uint8_t b)
+{
+    return SdBaseFile::write(&b, 1);
+}
+#else
+void SdFile::write(uint8_t b)
+{
+    SdBaseFile::write(&b, 1);
+}
+#endif
+//------------------------------------------------------------------------------
+/** Write a string to a file. Used by the Arduino Print class.
+ * \param[in] str Pointer to the string.
+ * Use writeError to check for errors.
+ */
+void SdFile::write(const char* str) {
+  SdBaseFile::write(str, strlen(str));
+}
+//------------------------------------------------------------------------------
+/** Write a PROGMEM string to a file.
+ * \param[in] str Pointer to the PROGMEM string.
+ * Use writeError to check for errors.
+ */
+void SdFile::write_P(PGM_P str) {
+  for (uint8_t c; (c = pgm_read_byte(str)); str++) write(c);
+}
+//------------------------------------------------------------------------------
+/** Write a PROGMEM string followed by CR/LF to a file.
+ * \param[in] str Pointer to the PROGMEM string.
+ * Use writeError to check for errors.
+ */
+void SdFile::writeln_P(PGM_P str) {
+  write_P(str);
+  write_P(PSTR("\r\n"));
+}
+
+
+#endif
diff --git a/Marlin/SdFile.h b/Marlin/SdFile.h
new file mode 100644
index 0000000..cbf1bbd
--- /dev/null
+++ b/Marlin/SdFile.h
@@ -0,0 +1,54 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+/**
+ * \file
+ * \brief SdFile class
+ */
+#include "Marlin.h"
+
+#ifdef SDSUPPORT
+#include "SdBaseFile.h"
+#include <Print.h>
+#ifndef SdFile_h
+#define SdFile_h
+//------------------------------------------------------------------------------
+/**
+ * \class SdFile
+ * \brief SdBaseFile with Print.
+ */
+class SdFile : public SdBaseFile, public Print {
+ public:
+  SdFile() {}
+  SdFile(const char* name, uint8_t oflag);
+  #if ARDUINO >= 100
+      size_t write(uint8_t b);
+  #else
+   void write(uint8_t b);
+  #endif
+  
+  int16_t write(const void* buf, uint16_t nbyte);
+  void write(const char* str);
+  void write_P(PGM_P str);
+  void writeln_P(PGM_P str);
+};
+#endif  // SdFile_h
+
+
+#endif
\ No newline at end of file
diff --git a/Marlin/SdInfo.h b/Marlin/SdInfo.h
new file mode 100644
index 0000000..03ece10
--- /dev/null
+++ b/Marlin/SdInfo.h
@@ -0,0 +1,280 @@
+/* Arduino Sd2Card Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino Sd2Card Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#ifndef SdInfo_h
+#define SdInfo_h
+#include <stdint.h>
+// Based on the document:
+//
+// SD Specifications
+// Part 1
+// Physical Layer
+// Simplified Specification
+// Version 3.01
+// May 18, 2010
+//
+// http://www.sdcard.org/developers/tech/sdcard/pls/simplified_specs
+//------------------------------------------------------------------------------
+// SD card commands
+/** GO_IDLE_STATE - init card in spi mode if CS low */
+uint8_t const CMD0 = 0X00;
+/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/
+uint8_t const CMD8 = 0X08;
+/** SEND_CSD - read the Card Specific Data (CSD register) */
+uint8_t const CMD9 = 0X09;
+/** SEND_CID - read the card identification information (CID register) */
+uint8_t const CMD10 = 0X0A;
+/** STOP_TRANSMISSION - end multiple block read sequence */
+uint8_t const CMD12 = 0X0C;
+/** SEND_STATUS - read the card status register */
+uint8_t const CMD13 = 0X0D;
+/** READ_SINGLE_BLOCK - read a single data block from the card */
+uint8_t const CMD17 = 0X11;
+/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */
+uint8_t const CMD18 = 0X12;
+/** WRITE_BLOCK - write a single data block to the card */
+uint8_t const CMD24 = 0X18;
+/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */
+uint8_t const CMD25 = 0X19;
+/** ERASE_WR_BLK_START - sets the address of the first block to be erased */
+uint8_t const CMD32 = 0X20;
+/** ERASE_WR_BLK_END - sets the address of the last block of the continuous
+    range to be erased*/
+uint8_t const CMD33 = 0X21;
+/** ERASE - erase all previously selected blocks */
+uint8_t const CMD38 = 0X26;
+/** APP_CMD - escape for application specific command */
+uint8_t const CMD55 = 0X37;
+/** READ_OCR - read the OCR register of a card */
+uint8_t const CMD58 = 0X3A;
+/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be
+     pre-erased before writing */
+uint8_t const ACMD23 = 0X17;
+/** SD_SEND_OP_COMD - Sends host capacity support information and
+    activates the card's initialization process */
+uint8_t const ACMD41 = 0X29;
+//------------------------------------------------------------------------------
+/** status for card in the ready state */
+uint8_t const R1_READY_STATE = 0X00;
+/** status for card in the idle state */
+uint8_t const R1_IDLE_STATE = 0X01;
+/** status bit for illegal command */
+uint8_t const R1_ILLEGAL_COMMAND = 0X04;
+/** start data token for read or write single block*/
+uint8_t const DATA_START_BLOCK = 0XFE;
+/** stop token for write multiple blocks*/
+uint8_t const STOP_TRAN_TOKEN = 0XFD;
+/** start data token for write multiple blocks*/
+uint8_t const WRITE_MULTIPLE_TOKEN = 0XFC;
+/** mask for data response tokens after a write block operation */
+uint8_t const DATA_RES_MASK = 0X1F;
+/** write data accepted token */
+uint8_t const DATA_RES_ACCEPTED = 0X05;
+//------------------------------------------------------------------------------
+/** Card IDentification (CID) register */
+typedef struct CID {
+  // byte 0
+  /** Manufacturer ID */
+  unsigned char mid;
+  // byte 1-2
+  /** OEM/Application ID */
+  char oid[2];
+  // byte 3-7
+  /** Product name */
+  char pnm[5];
+  // byte 8
+  /** Product revision least significant digit */
+  unsigned char prv_m : 4;
+  /** Product revision most significant digit */
+  unsigned char prv_n : 4;
+  // byte 9-12
+  /** Product serial number */
+  uint32_t psn;
+  // byte 13
+  /** Manufacturing date year low digit */
+  unsigned char mdt_year_high : 4;
+  /** not used */
+  unsigned char reserved : 4;
+  // byte 14
+  /** Manufacturing date month */
+  unsigned char mdt_month : 4;
+  /** Manufacturing date year low digit */
+  unsigned char mdt_year_low :4;
+  // byte 15
+  /** not used always 1 */
+  unsigned char always1 : 1;
+  /** CRC7 checksum */
+  unsigned char crc : 7;
+}cid_t;
+//------------------------------------------------------------------------------
+/** CSD for version 1.00 cards */
+typedef struct CSDV1 {
+  // byte 0
+  unsigned char reserved1 : 6;
+  unsigned char csd_ver : 2;
+  // byte 1
+  unsigned char taac;
+  // byte 2
+  unsigned char nsac;
+  // byte 3
+  unsigned char tran_speed;
+  // byte 4
+  unsigned char ccc_high;
+  // byte 5
+  unsigned char read_bl_len : 4;
+  unsigned char ccc_low : 4;
+  // byte 6
+  unsigned char c_size_high : 2;
+  unsigned char reserved2 : 2;
+  unsigned char dsr_imp : 1;
+  unsigned char read_blk_misalign :1;
+  unsigned char write_blk_misalign : 1;
+  unsigned char read_bl_partial : 1;
+  // byte 7
+  unsigned char c_size_mid;
+  // byte 8
+  unsigned char vdd_r_curr_max : 3;
+  unsigned char vdd_r_curr_min : 3;
+  unsigned char c_size_low :2;
+  // byte 9
+  unsigned char c_size_mult_high : 2;
+  unsigned char vdd_w_cur_max : 3;
+  unsigned char vdd_w_curr_min : 3;
+  // byte 10
+  unsigned char sector_size_high : 6;
+  unsigned char erase_blk_en : 1;
+  unsigned char c_size_mult_low : 1;
+  // byte 11
+  unsigned char wp_grp_size : 7;
+  unsigned char sector_size_low : 1;
+  // byte 12
+  unsigned char write_bl_len_high : 2;
+  unsigned char r2w_factor : 3;
+  unsigned char reserved3 : 2;
+  unsigned char wp_grp_enable : 1;
+  // byte 13
+  unsigned char reserved4 : 5;
+  unsigned char write_partial : 1;
+  unsigned char write_bl_len_low : 2;
+  // byte 14
+  unsigned char reserved5: 2;
+  unsigned char file_format : 2;
+  unsigned char tmp_write_protect : 1;
+  unsigned char perm_write_protect : 1;
+  unsigned char copy : 1;
+  /** Indicates the file format on the card */
+  unsigned char file_format_grp : 1;
+  // byte 15
+  unsigned char always1 : 1;
+  unsigned char crc : 7;
+}csd1_t;
+//------------------------------------------------------------------------------
+/** CSD for version 2.00 cards */
+typedef struct CSDV2 {
+  // byte 0
+  unsigned char reserved1 : 6;
+  unsigned char csd_ver : 2;
+  // byte 1
+  /** fixed to 0X0E */
+  unsigned char taac;
+  // byte 2
+  /** fixed to 0 */
+  unsigned char nsac;
+  // byte 3
+  unsigned char tran_speed;
+  // byte 4
+  unsigned char ccc_high;
+  // byte 5
+  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */
+  unsigned char read_bl_len : 4;
+  unsigned char ccc_low : 4;
+  // byte 6
+  /** not used */
+  unsigned char reserved2 : 4;
+  unsigned char dsr_imp : 1;
+  /** fixed to 0 */
+  unsigned char read_blk_misalign :1;
+  /** fixed to 0 */
+  unsigned char write_blk_misalign : 1;
+  /** fixed to 0 - no partial read */
+  unsigned char read_bl_partial : 1;
+  // byte 7
+  /** not used */
+  unsigned char reserved3 : 2;
+  /** high part of card size */
+  unsigned char c_size_high : 6;
+  // byte 8
+  /** middle part of card size */
+  unsigned char c_size_mid;
+  // byte 9
+  /** low part of card size */
+  unsigned char c_size_low;
+  // byte 10
+  /** sector size is fixed at 64 KB */
+  unsigned char sector_size_high : 6;
+  /** fixed to 1 - erase single is supported */
+  unsigned char erase_blk_en : 1;
+  /** not used */
+  unsigned char reserved4 : 1;
+  // byte 11
+  unsigned char wp_grp_size : 7;
+  /** sector size is fixed at 64 KB */
+  unsigned char sector_size_low : 1;
+  // byte 12
+  /** write_bl_len fixed for 512 byte blocks */
+  unsigned char write_bl_len_high : 2;
+  /** fixed value of 2 */
+  unsigned char r2w_factor : 3;
+  /** not used */
+  unsigned char reserved5 : 2;
+  /** fixed value of 0 - no write protect groups */
+  unsigned char wp_grp_enable : 1;
+  // byte 13
+  unsigned char reserved6 : 5;
+  /** always zero - no partial block read*/
+  unsigned char write_partial : 1;
+  /** write_bl_len fixed for 512 byte blocks */
+  unsigned char write_bl_len_low : 2;
+  // byte 14
+  unsigned char reserved7: 2;
+  /** Do not use always 0 */
+  unsigned char file_format : 2;
+  unsigned char tmp_write_protect : 1;
+  unsigned char perm_write_protect : 1;
+  unsigned char copy : 1;
+  /** Do not use always 0 */
+  unsigned char file_format_grp : 1;
+  // byte 15
+  /** not used always 1 */
+  unsigned char always1 : 1;
+  /** checksum */
+  unsigned char crc : 7;
+}csd2_t;
+//------------------------------------------------------------------------------
+/** union of old and new style CSD register */
+union csd_t {
+  csd1_t v1;
+  csd2_t v2;
+};
+#endif  // SdInfo_h
+
+#endif
\ No newline at end of file
diff --git a/Marlin/SdVolume.cpp b/Marlin/SdVolume.cpp
new file mode 100644
index 0000000..f14d7bc
--- /dev/null
+++ b/Marlin/SdVolume.cpp
@@ -0,0 +1,405 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+
+#include "SdVolume.h"
+//------------------------------------------------------------------------------
+#if !USE_MULTIPLE_CARDS
+// raw block cache
+uint32_t SdVolume::cacheBlockNumber_;  // current block number
+cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card
+Sd2Card* SdVolume::sdCard_;            // pointer to SD card object
+bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
+uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
+#endif  // USE_MULTIPLE_CARDS
+//------------------------------------------------------------------------------
+// find a contiguous group of clusters
+bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
+  // start of group
+  uint32_t bgnCluster;
+  // end of group
+  uint32_t endCluster;
+  // last cluster of FAT
+  uint32_t fatEnd = clusterCount_ + 1;
+
+  // flag to save place to start next search
+  bool setStart;
+
+  // set search start cluster
+  if (*curCluster) {
+    // try to make file contiguous
+    bgnCluster = *curCluster + 1;
+
+    // don't save new start location
+    setStart = false;
+  } else {
+    // start at likely place for free cluster
+    bgnCluster = allocSearchStart_;
+
+    // save next search start if one cluster
+    setStart = count == 1;
+  }
+  // end of group
+  endCluster = bgnCluster;
+
+  // search the FAT for free clusters
+  for (uint32_t n = 0;; n++, endCluster++) {
+    // can't find space checked all clusters
+    if (n >= clusterCount_) goto fail;
+
+    // past end - start from beginning of FAT
+    if (endCluster > fatEnd) {
+      bgnCluster = endCluster = 2;
+    }
+    uint32_t f;
+    if (!fatGet(endCluster, &f)) goto fail;
+
+    if (f != 0) {
+      // cluster in use try next cluster as bgnCluster
+      bgnCluster = endCluster + 1;
+    } else if ((endCluster - bgnCluster + 1) == count) {
+      // done - found space
+      break;
+    }
+  }
+  // mark end of chain
+  if (!fatPutEOC(endCluster)) goto fail;
+
+  // link clusters
+  while (endCluster > bgnCluster) {
+    if (!fatPut(endCluster - 1, endCluster)) goto fail;
+    endCluster--;
+  }
+  if (*curCluster != 0) {
+    // connect chains
+    if (!fatPut(*curCluster, bgnCluster)) goto fail;
+  }
+  // return first cluster number to caller
+  *curCluster = bgnCluster;
+
+  // remember possible next free cluster
+  if (setStart) allocSearchStart_ = bgnCluster + 1;
+
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdVolume::cacheFlush() {
+  if (cacheDirty_) {
+    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
+      goto fail;
+    }
+    // mirror FAT tables
+    if (cacheMirrorBlock_) {
+      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
+        goto fail;
+      }
+      cacheMirrorBlock_ = 0;
+    }
+    cacheDirty_ = 0;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
+  if (cacheBlockNumber_ != blockNumber) {
+    if (!cacheFlush()) goto fail;
+    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) goto fail;
+    cacheBlockNumber_ = blockNumber;
+  }
+  if (dirty) cacheDirty_ = true;
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// return the size in bytes of a cluster chain
+bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
+  uint32_t s = 0;
+  do {
+    if (!fatGet(cluster, &cluster)) goto fail;
+    s += 512UL << clusterSizeShift_;
+  } while (!isEOC(cluster));
+  *size = s;
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Fetch a FAT entry
+bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
+  uint32_t lba;
+  if (cluster > (clusterCount_ + 1)) goto fail;
+  if (FAT12_SUPPORT && fatType_ == 12) {
+    uint16_t index = cluster;
+    index += index >> 1;
+    lba = fatStartBlock_ + (index >> 9);
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
+    index &= 0X1FF;
+    uint16_t tmp = cacheBuffer_.data[index];
+    index++;
+    if (index == 512) {
+      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto fail;
+      index = 0;
+    }
+    tmp |= cacheBuffer_.data[index] << 8;
+    *value = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
+    return true;
+  }
+  if (fatType_ == 16) {
+    lba = fatStartBlock_ + (cluster >> 8);
+  } else if (fatType_ == 32) {
+    lba = fatStartBlock_ + (cluster >> 7);
+  } else {
+    goto fail;
+  }
+  if (lba != cacheBlockNumber_) {
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;
+  }
+  if (fatType_ == 16) {
+    *value = cacheBuffer_.fat16[cluster & 0XFF];
+  } else {
+    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Store a FAT entry
+bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
+  uint32_t lba;
+  // error if reserved cluster
+  if (cluster < 2) goto fail;
+
+  // error if not in FAT
+  if (cluster > (clusterCount_ + 1)) goto fail;
+
+  if (FAT12_SUPPORT && fatType_ == 12) {
+    uint16_t index = cluster;
+    index += index >> 1;
+    lba = fatStartBlock_ + (index >> 9);
+    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
+    // mirror second FAT
+    if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+    index &= 0X1FF;
+    uint8_t tmp = value;
+    if (cluster & 1) {
+      tmp = (cacheBuffer_.data[index] & 0XF) | tmp << 4;
+    }
+    cacheBuffer_.data[index] = tmp;
+    index++;
+    if (index == 512) {
+      lba++;
+      index = 0;
+      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
+      // mirror second FAT
+      if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+    }
+    tmp = value >> 4;
+    if (!(cluster & 1)) {
+      tmp = ((cacheBuffer_.data[index] & 0XF0)) | tmp >> 4;
+    }
+    cacheBuffer_.data[index] = tmp;
+    return true;
+  }
+  if (fatType_ == 16) {
+    lba = fatStartBlock_ + (cluster >> 8);
+  } else if (fatType_ == 32) {
+    lba = fatStartBlock_ + (cluster >> 7);
+  } else {
+    goto fail;
+  }
+  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;
+  // store entry
+  if (fatType_ == 16) {
+    cacheBuffer_.fat16[cluster & 0XFF] = value;
+  } else {
+    cacheBuffer_.fat32[cluster & 0X7F] = value;
+  }
+  // mirror second FAT
+  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+// free a cluster chain
+bool SdVolume::freeChain(uint32_t cluster) {
+  uint32_t next;
+
+  // clear free cluster location
+  allocSearchStart_ = 2;
+
+  do {
+    if (!fatGet(cluster, &next)) goto fail;
+
+    // free cluster
+    if (!fatPut(cluster, 0)) goto fail;
+
+    cluster = next;
+  } while (!isEOC(cluster));
+
+  return true;
+
+ fail:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Volume free space in clusters.
+ *
+ * \return Count of free clusters for success or -1 if an error occurs.
+ */
+int32_t SdVolume::freeClusterCount() {
+  uint32_t free = 0;
+  uint16_t n;
+  uint32_t todo = clusterCount_ + 2;
+
+  if (fatType_ == 16) {
+    n = 256;
+  } else if (fatType_ == 32) {
+    n = 128;
+  } else {
+    // put FAT12 here
+    return -1;
+  }
+
+  for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;
+    if (todo < n) n = todo;
+    if (fatType_ == 16) {
+      for (uint16_t i = 0; i < n; i++) {
+        if (cacheBuffer_.fat16[i] == 0) free++;
+      }
+    } else {
+      for (uint16_t i = 0; i < n; i++) {
+        if (cacheBuffer_.fat32[i] == 0) free++;
+      }
+    }
+  }
+  return free;
+}
+//------------------------------------------------------------------------------
+/** Initialize a FAT volume.
+ *
+ * \param[in] dev The SD card where the volume is located.
+ *
+ * \param[in] part The partition to be used.  Legal values for \a part are
+ * 1-4 to use the corresponding partition on a device formatted with
+ * a MBR, Master Boot Record, or zero if the device is formatted as
+ * a super floppy with the FAT boot sector in block zero.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.  Reasons for
+ * failure include not finding a valid partition, not finding a valid
+ * FAT file system in the specified partition or an I/O error.
+ */
+bool SdVolume::init(Sd2Card* dev, uint8_t part) {
+  uint32_t totalBlocks;
+  uint32_t volumeStartBlock = 0;
+  fat32_boot_t* fbs;
+
+  sdCard_ = dev;
+  fatType_ = 0;
+  allocSearchStart_ = 2;
+  cacheDirty_ = 0;  // cacheFlush() will write block if true
+  cacheMirrorBlock_ = 0;
+  cacheBlockNumber_ = 0XFFFFFFFF;
+
+  // if part == 0 assume super floppy with FAT boot sector in block zero
+  // if part > 0 assume mbr volume with partition table
+  if (part) {
+    if (part > 4)goto fail;
+    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
+    part_t* p = &cacheBuffer_.mbr.part[part-1];
+    if ((p->boot & 0X7F) !=0  ||
+      p->totalSectors < 100 ||
+      p->firstSector == 0) {
+      // not a valid partition
+      goto fail;
+    }
+    volumeStartBlock = p->firstSector;
+  }
+  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;
+  fbs = &cacheBuffer_.fbs32;
+  if (fbs->bytesPerSector != 512 ||
+    fbs->fatCount == 0 ||
+    fbs->reservedSectorCount == 0 ||
+    fbs->sectorsPerCluster == 0) {
+       // not valid FAT volume
+      goto fail;
+  }
+  fatCount_ = fbs->fatCount;
+  blocksPerCluster_ = fbs->sectorsPerCluster;
+  // determine shift that is same as multiply by blocksPerCluster_
+  clusterSizeShift_ = 0;
+  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
+    // error if not power of 2
+    if (clusterSizeShift_++ > 7) goto fail;
+  }
+  blocksPerFat_ = fbs->sectorsPerFat16 ?
+                    fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
+
+  fatStartBlock_ = volumeStartBlock + fbs->reservedSectorCount;
+
+  // count for FAT16 zero for FAT32
+  rootDirEntryCount_ = fbs->rootDirEntryCount;
+
+  // directory start for FAT16 dataStart for FAT32
+  rootDirStart_ = fatStartBlock_ + fbs->fatCount * blocksPerFat_;
+
+  // data start for FAT16 and FAT32
+  dataStartBlock_ = rootDirStart_ + ((32 * fbs->rootDirEntryCount + 511)/512);
+
+  // total blocks for FAT16 or FAT32
+  totalBlocks = fbs->totalSectors16 ?
+                           fbs->totalSectors16 : fbs->totalSectors32;
+  // total data blocks
+  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
+
+  // divide by cluster size to get cluster count
+  clusterCount_ >>= clusterSizeShift_;
+
+  // FAT type is determined by cluster count
+  if (clusterCount_ < 4085) {
+    fatType_ = 12;
+    if (!FAT12_SUPPORT) goto fail;
+  } else if (clusterCount_ < 65525) {
+    fatType_ = 16;
+  } else {
+    rootDirStart_ = fbs->fat32RootCluster;
+    fatType_ = 32;
+  }
+  return true;
+
+ fail:
+  return false;
+}
+#endif
\ No newline at end of file
diff --git a/Marlin/SdVolume.h b/Marlin/SdVolume.h
new file mode 100644
index 0000000..2ff2b6e
--- /dev/null
+++ b/Marlin/SdVolume.h
@@ -0,0 +1,214 @@
+/* Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino SdFat Library
+ *
+ * This Library is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with the Arduino SdFat Library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+#include "Marlin.h"
+#ifdef SDSUPPORT
+#ifndef SdVolume_h
+#define SdVolume_h
+/**
+ * \file
+ * \brief SdVolume class
+ */
+#include "SdFatConfig.h"
+#include "Sd2Card.h"
+#include "SdFatStructs.h"
+
+//==============================================================================
+// SdVolume class
+/**
+ * \brief Cache for an SD data block
+ */
+union cache_t {
+           /** Used to access cached file data blocks. */
+  uint8_t  data[512];
+           /** Used to access cached FAT16 entries. */
+  uint16_t fat16[256];
+           /** Used to access cached FAT32 entries. */
+  uint32_t fat32[128];
+           /** Used to access cached directory entries. */
+  dir_t    dir[16];
+           /** Used to access a cached Master Boot Record. */
+  mbr_t    mbr;
+           /** Used to access to a cached FAT boot sector. */
+  fat_boot_t fbs;
+           /** Used to access to a cached FAT32 boot sector. */
+  fat32_boot_t fbs32;
+           /** Used to access to a cached FAT32 FSINFO sector. */
+  fat32_fsinfo_t fsinfo;
+};
+//------------------------------------------------------------------------------
+/**
+ * \class SdVolume
+ * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
+ */
+class SdVolume {
+ public:
+  /** Create an instance of SdVolume */
+  SdVolume() : fatType_(0) {}
+  /** Clear the cache and returns a pointer to the cache.  Used by the WaveRP
+   * recorder to do raw write to the SD card.  Not for normal apps.
+   * \return A pointer to the cache buffer or zero if an error occurs.
+   */
+  cache_t* cacheClear() {
+    if (!cacheFlush()) return 0;
+    cacheBlockNumber_ = 0XFFFFFFFF;
+    return &cacheBuffer_;
+  }
+  /** Initialize a FAT volume.  Try partition one first then try super
+   * floppy format.
+   *
+   * \param[in] dev The Sd2Card where the volume is located.
+   *
+   * \return The value one, true, is returned for success and
+   * the value zero, false, is returned for failure.  Reasons for
+   * failure include not finding a valid partition, not finding a valid
+   * FAT file system or an I/O error.
+   */
+  bool init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
+  bool init(Sd2Card* dev, uint8_t part);
+
+  // inline functions that return volume info
+  /** \return The volume's cluster size in blocks. */
+  uint8_t blocksPerCluster() const {return blocksPerCluster_;}
+  /** \return The number of blocks in one FAT. */
+  uint32_t blocksPerFat()  const {return blocksPerFat_;}
+  /** \return The total number of clusters in the volume. */
+  uint32_t clusterCount() const {return clusterCount_;}
+  /** \return The shift count required to multiply by blocksPerCluster. */
+  uint8_t clusterSizeShift() const {return clusterSizeShift_;}
+  /** \return The logical block number for the start of file data. */
+  uint32_t dataStartBlock() const {return dataStartBlock_;}
+  /** \return The number of FAT structures on the volume. */
+  uint8_t fatCount() const {return fatCount_;}
+  /** \return The logical block number for the start of the first FAT. */
+  uint32_t fatStartBlock() const {return fatStartBlock_;}
+  /** \return The FAT type of the volume. Values are 12, 16 or 32. */
+  uint8_t fatType() const {return fatType_;}
+  int32_t freeClusterCount();
+  /** \return The number of entries in the root directory for FAT16 volumes. */
+  uint32_t rootDirEntryCount() const {return rootDirEntryCount_;}
+  /** \return The logical block number for the start of the root directory
+       on FAT16 volumes or the first cluster number on FAT32 volumes. */
+  uint32_t rootDirStart() const {return rootDirStart_;}
+  /** Sd2Card object for this volume
+   * \return pointer to Sd2Card object.
+   */
+  Sd2Card* sdCard() {return sdCard_;}
+  /** Debug access to FAT table
+   *
+   * \param[in] n cluster number.
+   * \param[out] v value of entry
+   * \return true for success or false for failure
+   */
+  bool dbgFat(uint32_t n, uint32_t* v) {return fatGet(n, v);}
+//------------------------------------------------------------------------------
+ private:
+  // Allow SdBaseFile access to SdVolume private data.
+  friend class SdBaseFile;
+
+  // value for dirty argument in cacheRawBlock to indicate read from cache
+  static bool const CACHE_FOR_READ = false;
+  // value for dirty argument in cacheRawBlock to indicate write to cache
+  static bool const CACHE_FOR_WRITE = true;
+
+#if USE_MULTIPLE_CARDS
+  cache_t cacheBuffer_;        // 512 byte cache for device blocks
+  uint32_t cacheBlockNumber_;  // Logical number of block in the cache
+  Sd2Card* sdCard_;            // Sd2Card object for cache
+  bool cacheDirty_;            // cacheFlush() will write block if true
+  uint32_t cacheMirrorBlock_;  // block number for mirror FAT
+#else  // USE_MULTIPLE_CARDS
+  static cache_t cacheBuffer_;        // 512 byte cache for device blocks
+  static uint32_t cacheBlockNumber_;  // Logical number of block in the cache
+  static Sd2Card* sdCard_;            // Sd2Card object for cache
+  static bool cacheDirty_;            // cacheFlush() will write block if true
+  static uint32_t cacheMirrorBlock_;  // block number for mirror FAT
+#endif  // USE_MULTIPLE_CARDS
+  uint32_t allocSearchStart_;   // start cluster for alloc search
+  uint8_t blocksPerCluster_;    // cluster size in blocks
+  uint32_t blocksPerFat_;       // FAT size in blocks
+  uint32_t clusterCount_;       // clusters in one FAT
+  uint8_t clusterSizeShift_;    // shift to convert cluster count to block count
+  uint32_t dataStartBlock_;     // first data block number
+  uint8_t fatCount_;            // number of FATs on volume
+  uint32_t fatStartBlock_;      // start block for first FAT
+  uint8_t fatType_;             // volume type (12, 16, OR 32)
+  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
+  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
+  //----------------------------------------------------------------------------
+  bool allocContiguous(uint32_t count, uint32_t* curCluster);
+  uint8_t blockOfCluster(uint32_t position) const {
+          return (position >> 9) & (blocksPerCluster_ - 1);}
+  uint32_t clusterStartBlock(uint32_t cluster) const {
+           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
+  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
+           return clusterStartBlock(cluster) + blockOfCluster(position);}
+  cache_t *cache() {return &cacheBuffer_;}
+  uint32_t cacheBlockNumber() {return cacheBlockNumber_;}
+#if USE_MULTIPLE_CARDS
+  bool cacheFlush();
+  bool cacheRawBlock(uint32_t blockNumber, bool dirty);
+#else  // USE_MULTIPLE_CARDS
+  static bool cacheFlush();
+  static bool cacheRawBlock(uint32_t blockNumber, bool dirty);
+#endif  // USE_MULTIPLE_CARDS
+  // used by SdBaseFile write to assign cache to SD location
+  void cacheSetBlockNumber(uint32_t blockNumber, bool dirty) {
+    cacheDirty_ = dirty;
+    cacheBlockNumber_  = blockNumber;
+  }
+  void cacheSetDirty() {cacheDirty_ |= CACHE_FOR_WRITE;}
+  bool chainSize(uint32_t beginCluster, uint32_t* size);
+  bool fatGet(uint32_t cluster, uint32_t* value);
+  bool fatPut(uint32_t cluster, uint32_t value);
+  bool fatPutEOC(uint32_t cluster) {
+    return fatPut(cluster, 0x0FFFFFFF);
+  }
+  bool freeChain(uint32_t cluster);
+  bool isEOC(uint32_t cluster) const {
+    if (FAT12_SUPPORT && fatType_ == 12) return  cluster >= FAT12EOC_MIN;
+    if (fatType_ == 16) return cluster >= FAT16EOC_MIN;
+    return  cluster >= FAT32EOC_MIN;
+  }
+  bool readBlock(uint32_t block, uint8_t* dst) {
+    return sdCard_->readBlock(block, dst);}
+  bool writeBlock(uint32_t block, const uint8_t* dst) {
+    return sdCard_->writeBlock(block, dst);
+  }
+//------------------------------------------------------------------------------
+  // Deprecated functions  - suppress cpplint warnings with NOLINT comment
+#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
+ public:
+  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev);
+   * \param[in] dev The SD card where the volume is located.
+   * \return true for success or false for failure.
+   */
+  bool init(Sd2Card& dev) {return init(&dev);}  // NOLINT
+  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev, uint8_t vol);
+   * \param[in] dev The SD card where the volume is located.
+   * \param[in] part The partition to be used.
+   * \return true for success or false for failure.
+   */
+  bool init(Sd2Card& dev, uint8_t part) {  // NOLINT
+    return init(&dev, part);
+  }
+#endif  // ALLOW_DEPRECATED_FUNCTIONS
+};
+#endif  // SdVolume
+#endif
\ No newline at end of file
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index d902d45..d04f1fe 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -35,9 +35,8 @@
 #include "watchdog.h"
 #include "thermistortables.h"
 
-#ifdef HEATER_0_USES_MAX6675
-//#include <Sd2PinMap.h>
-#endif
+#include "Sd2PinMap.h"
+
 
 //===========================================================================
 //=============================public variables============================

