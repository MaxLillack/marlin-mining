commit 7c81398f952dd4708e7d1df9dadef582da2bded8 (from 0554b65d22a1556ca426f651b0ae960c125f9463)
Merge: 0554b65 9b5cbf2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 12 16:39:37 2016 -0700

    Merge pull request #4279 from esenapaj/Follow-up-the-PR-#4271
    
    Follow-up the PR #4271 (X_DUAL_STEPPER_DRIVERS)

diff --git a/Marlin/example_configurations/K8400/Configuration_adv.h b/Marlin/example_configurations/K8400/Configuration_adv.h
index 12a924d..ba78a15 100644
--- a/Marlin/example_configurations/K8400/Configuration_adv.h
+++ b/Marlin/example_configurations/K8400/Configuration_adv.h
@@ -229,11 +229,28 @@
 
 //#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.
 
+// Dual X Steppers
+// Uncomment this option to drive two X axis motors.
+// The next unused E driver will be assigned to the second X stepper.
+//#define X_DUAL_STEPPER_DRIVERS
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  // Set true if the two X motors need to rotate in opposite directions
+  #define INVERT_X2_VS_X_DIR true
+#endif
+
+
+// Dual Y Steppers
+// Uncomment this option to drive two Y axis motors.
+// The next unused E driver will be assigned to the second Y stepper.
+//#define Y_DUAL_STEPPER_DRIVERS
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  // Set true if the two Y motors need to rotate in opposite directions
+  #define INVERT_Y2_VS_Y_DIR true
+#endif
+
 // A single Z stepper driver is usually used to drive 2 stepper motors.
-// Uncomment this define to utilize a separate stepper driver for each Z axis motor.
-// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used
-// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.
-// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.
+// Uncomment this option to use a separate stepper driver for each Z axis motor.
+// The next unused E driver will be assigned to the second Z stepper.
 //#define Z_DUAL_STEPPER_DRIVERS
 
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
@@ -255,14 +272,6 @@
 
 #endif // Z_DUAL_STEPPER_DRIVERS
 
-// Same again but for Y Axis.
-//#define Y_DUAL_STEPPER_DRIVERS
-
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  // Define if the two Y drives need to rotate in opposite directions
-  #define INVERT_Y2_VS_Y_DIR true
-#endif
-
 // Enable this for dual x-carriage printers.
 // A dual x-carriage design has the advantage that the inactive extruder can be parked which
 // prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage

commit 7c81398f952dd4708e7d1df9dadef582da2bded8 (from 9b5cbf242399bbf3b4f319a71ccf6cbaeea81b78)
Merge: 0554b65 9b5cbf2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 12 16:39:37 2016 -0700

    Merge pull request #4279 from esenapaj/Follow-up-the-PR-#4271
    
    Follow-up the PR #4271 (X_DUAL_STEPPER_DRIVERS)

diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index ea73077..1d0e025 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -813,6 +813,16 @@
     #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_3
       #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
     #endif
+    #if ENABLED(AUTO_BED_LEVELING_GRID)
+      #define DELTA_BED_LEVELING_GRID
+    #endif
+  #endif
+
+  /**
+   * When not using other bed leveling...
+   */
+  #if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(AUTO_BED_LEVELING_GRID) && DISABLED(DELTA_BED_LEVELING_GRID)
+    #define AUTO_BED_LEVELING_3POINT
   #endif
 
   /**
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 9c48e9e..9c25150 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -200,11 +200,9 @@
 #if ENABLED(MESH_BED_LEVELING)
   #if ENABLED(DELTA)
     #error "MESH_BED_LEVELING does not yet support DELTA printers."
-  #endif
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
     #error "Select AUTO_BED_LEVELING_FEATURE or MESH_BED_LEVELING, not both."
-  #endif
-  #if MESH_NUM_X_POINTS > 7 || MESH_NUM_Y_POINTS > 7
+  #elif MESH_NUM_X_POINTS > 7 || MESH_NUM_Y_POINTS > 7
     #error "MESH_NUM_X_POINTS and MESH_NUM_Y_POINTS need to be less than 8."
   #endif
 #elif ENABLED(MANUAL_BED_LEVELING)
@@ -217,6 +215,10 @@
 
 #if PROBE_SELECTED
 
+  #if ENABLED(Z_PROBE_SLED) && ENABLED(DELTA)
+    #error "You cannot use Z_PROBE_SLED with DELTA."
+  #endif
+
   /**
    * NUM_SERVOS is required for a Z servo probe
    */
@@ -325,6 +327,13 @@
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
 
   /**
+   * Delta has limited bed leveling options
+   */
+  #if ENABLED(DELTA) && DISABLED(AUTO_BED_LEVELING_GRID)
+    #error "You must use AUTO_BED_LEVELING_GRID for DELTA bed leveling."
+  #endif
+
+  /**
    * Require a Z min pin
    */
   #if !PIN_EXISTS(Z_MIN)
@@ -409,25 +418,6 @@
 #endif
 
 /**
- * Delta has limited bed leveling options
- */
-#if ENABLED(DELTA)
-
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-    #if DISABLED(AUTO_BED_LEVELING_GRID)
-      #error "Only AUTO_BED_LEVELING_GRID is supported with DELTA."
-    #endif
-
-    #if ENABLED(Z_PROBE_SLED)
-      #error "You cannot use Z_PROBE_SLED with DELTA."
-    #endif
-
-  #endif
-
-#endif
-
-/**
  * Don't set more than one kinematic type
  */
 #if (ENABLED(DELTA) && (ENABLED(SCARA) || ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ))) \
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 4b7aaf6..c7e1604 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -416,6 +416,7 @@ void CardReader::openFile(char* name, bool read, bool push_current/*=false*/) {
     else {
       saving = true;
       SERIAL_PROTOCOLPAIR(MSG_SD_WRITE_TO_FILE, name);
+      SERIAL_EOL;
       lcd_setstatus(fname);
     }
   }
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 00ea854..aacc041 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -129,18 +129,16 @@ float Planner::previous_nominal_speed;
  * Class and Instance Methods
  */
 
-Planner::Planner() {
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    bed_level_matrix.set_to_identity();
-  #endif
-  init();
-}
+Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   memset(position, 0, sizeof(position)); // clear position
   for (int i = 0; i < NUM_AXIS; i++) previous_speed[i] = 0.0;
   previous_nominal_speed = 0.0;
+  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    bed_level_matrix.set_to_identity();
+  #endif
 }
 
 /**
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 1aff9b3..aa0ff79 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -128,7 +128,7 @@ volatile bool Temperature::temp_meas_ready = false;
 
   #if ENABLED(PID_ADD_EXTRUSION_RATE)
     float Temperature::cTerm[HOTENDS];
-    long Temperature::last_position[HOTENDS];
+    long Temperature::last_e_position;
     long Temperature::lpq[LPQ_MAX_LEN];
     int Temperature::lpq_ptr = 0;
   #endif
@@ -444,11 +444,11 @@ Temperature::Temperature() { }
 
 void Temperature::updatePID() {
   #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_ADD_EXTRUSION_RATE)
+      last_e_position = 0;
+    #endif
     HOTEND_LOOP() {
       temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
-      #if ENABLED(PID_ADD_EXTRUSION_RATE)
-        last_position[e] = 0;
-      #endif
     }
   #endif
   #if ENABLED(PIDTEMPBED)
@@ -531,10 +531,8 @@ float Temperature::get_pid_output(int e) {
   #if HOTENDS == 1
     UNUSED(e);
     #define _HOTEND_TEST     true
-    #define _HOTEND_EXTRUDER active_extruder
   #else
     #define _HOTEND_TEST     e == active_extruder
-    #define _HOTEND_EXTRUDER e
   #endif
   float pid_output;
   #if ENABLED(PIDTEMP)
@@ -566,14 +564,14 @@ float Temperature::get_pid_output(int e) {
           cTerm[HOTEND_INDEX] = 0;
           if (_HOTEND_TEST) {
             long e_position = stepper.position(E_AXIS);
-            if (e_position > last_position[_HOTEND_EXTRUDER]) {
-              lpq[lpq_ptr++] = e_position - last_position[_HOTEND_EXTRUDER];
-              last_position[_HOTEND_EXTRUDER] = e_position;
+            if (e_position > last_e_position) {
+              lpq[lpq_ptr] = e_position - last_e_position;
+              last_e_position = e_position;
             }
             else {
-              lpq[lpq_ptr++] = 0;
+              lpq[lpq_ptr] = 0;
             }
-            if (lpq_ptr >= lpq_len) lpq_ptr = 0;
+            if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
             cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] / planner.axis_steps_per_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
             pid_output += cTerm[HOTEND_INDEX];
           }
@@ -952,7 +950,7 @@ void Temperature::init() {
       temp_iState_min[e] = 0.0;
       temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
       #if ENABLED(PID_ADD_EXTRUSION_RATE)
-        last_position[e] = 0;
+        last_e_position = 0;
       #endif
     #endif //PIDTEMP
     #if ENABLED(PIDTEMPBED)
@@ -961,6 +959,10 @@ void Temperature::init() {
     #endif //PIDTEMPBED
   }
 
+  #if ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE)
+    last_e_position = 0;
+  #endif
+
   #if HAS_HEATER_0
     SET_OUTPUT(HEATER_0_PIN);
   #endif
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index dbb4343..fd737bc 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -76,13 +76,13 @@ class Temperature {
 
     #if ENABLED(PIDTEMP)
 
-      #if ENABLED(PID_PARAMS_PER_HOTEND)
+      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
 
         static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
           static float Kc[HOTENDS];
         #endif
-        #define PID_PARAM(param, e) Temperature::param[e]
+        #define PID_PARAM(param, h) Temperature::param[h]
 
       #else
 
@@ -90,7 +90,7 @@ class Temperature {
         #if ENABLED(PID_ADD_EXTRUSION_RATE)
           static float Kc;
         #endif
-        #define PID_PARAM(param, e) Temperature::param
+        #define PID_PARAM(param, h) Temperature::param
 
       #endif // PID_PARAMS_PER_HOTEND
 
@@ -150,7 +150,7 @@ class Temperature {
 
       #if ENABLED(PID_ADD_EXTRUSION_RATE)
         static float cTerm[HOTENDS];
-        static long last_position[HOTENDS];
+        static long last_e_position;
         static long lpq[LPQ_MAX_LEN];
         static int lpq_ptr;
       #endif
@@ -247,11 +247,24 @@ class Temperature {
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
-      static bool is_preheating(uint8_t hotend) {
-        return preheat_end_time[hotend] && PENDING(millis(), preheat_end_time[hotend]);
+      static bool is_preheating(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
+      }
+      static void start_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
+      }
+      static void reset_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = 0;
       }
-      static void start_preheat_time(uint8_t hotend) { preheat_end_time[hotend] = millis() + MILLISECONDS_PREHEAT_TIME; }
-      static void reset_preheat_time(uint8_t hotend) { preheat_end_time[hotend] = 0; }
     #else
       #define is_preheating(n) (false)
     #endif
@@ -306,9 +319,9 @@ class Temperature {
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0.0f)
-          reset_preheat_time(hotend);
-        else if (target_temperature[hotend] == 0.0f)
-          start_preheat_time(hotend);
+          reset_preheat_time(HOTEND_INDEX);
+        else if (target_temperature[HOTEND_INDEX] == 0.0f)
+          start_preheat_time(HOTEND_INDEX);
       #endif
       target_temperature[HOTEND_INDEX] = celsius;
       #if ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0

