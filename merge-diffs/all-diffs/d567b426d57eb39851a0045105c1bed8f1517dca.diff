commit d567b426d57eb39851a0045105c1bed8f1517dca (from 43df9ace4ee08ee6834d026ee73b1c3c128cc70b)
Merge: 43df9ac ab84ed2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 31 08:01:41 2016 -0500

    Merge pull request #4894 from thinkyhead/rc_mightyboard_rev_e
    
    Mightyboard Revision E preliminary support

diff --git a/Marlin/boards.h b/Marlin/boards.h
index bf7be0e..285bfb7 100644
--- a/Marlin/boards.h
+++ b/Marlin/boards.h
@@ -33,6 +33,7 @@
 #define BOARD_CNCONTROLS_12     112  // Cartesio CN Controls V12
 #define BOARD_CHEAPTRONIC       2    // Cheaptronic v1.0
 #define BOARD_SETHI             20   // Sethi 3D_1
+#define BOARD_MIGHTYBOARD_REVE  200  // Makerbot Mightyboard Revision E
 #define BOARD_RAMPS_OLD         3    // MEGA/RAMPS up to 1.2
 #define BOARD_RAMPS_13_EFB      33   // RAMPS 1.3 (Power outputs: Hotend, Fan, Bed)
 #define BOARD_RAMPS_13_EEB      34   // RAMPS 1.3 (Power outputs: Hotend0, Hotend1, Bed)
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index 9872423..fff057a 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -1835,18 +1835,6 @@
   #define PG5_WPORT   PORTG
   #define PG5_DDR     DDRG
   #define PG5_PWM     &OCR0B
-  #undef PG6
-  #define PG6_PIN     PING6
-  #define PG6_RPORT   PING
-  #define PG6_WPORT   PORTG
-  #define PG6_DDR     DDRG
-  #define PG6_PWM     NULL
-  #undef PG7
-  #define PG7_PIN     PING7
-  #define PG7_RPORT   PING
-  #define PG7_WPORT   PORTG
-  #define PG7_DDR     DDRG
-  #define PG7_PWM     NULL
 
   #undef PH0
   #define PH0_PIN     PINH0
diff --git a/Marlin/pins.h b/Marlin/pins.h
index b2701ae..472133c 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -39,6 +39,8 @@
   #include "pins_CHEAPTRONIC.h"
 #elif MB(SETHI)
   #include "pins_SETHI.h"
+#elif MB(MIGHTYBOARD_REVE)
+  #include "pins_MIGHTYBOARD_REVE.h"
 #elif MB(RAMPS_OLD)
   #include "pins_RAMPS_OLD.h"
 #elif MB(RAMPS_13_EFB)
diff --git a/Marlin/pins_MIGHTYBOARD_REVE.h b/Marlin/pins_MIGHTYBOARD_REVE.h
new file mode 100644
index 0000000..fc4d02e
--- /dev/null
+++ b/Marlin/pins_MIGHTYBOARD_REVE.h
@@ -0,0 +1,205 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Mightyboard Rev.E pin assignments
+ */
+
+#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)
+  #error "Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -> Boards' menu."
+#endif
+
+#define DEFAULT_MACHINE_NAME    "MB Replicator"
+#define BOARD_NAME              "Mightyboard"
+
+#define LARGE_FLASH true
+
+//
+// Servos
+//
+#define SERVO0_PIN         36 // C1 (1280-EX1)
+#define SERVO1_PIN         37 // C0 (1280-EX2)
+#define SERVO2_PIN         40 // G1 (1280-EX3)
+#define SERVO3_PIN         41 // G0 (1280-EX4)
+
+//
+// Limit Switches
+//
+#define X_MIN_PIN          49 // L0
+#define X_MAX_PIN          48 // L1
+#define Y_MIN_PIN          47 // L2
+#define Y_MAX_PIN          46 // L3
+#define Z_MIN_PIN          43 // L6
+#define Z_MAX_PIN          42 // L7
+
+//
+// Z Probe (when not Z_MIN_PIN)
+//
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN  42
+#endif
+
+//
+// Steppers
+//
+#define X_STEP_PIN         55 // F1
+#define X_DIR_PIN          54 // F0
+#define X_ENABLE_PIN       56 // F2
+
+#define Y_STEP_PIN         59 // F5
+#define Y_DIR_PIN          58 // F4
+#define Y_ENABLE_PIN       60 // F6
+
+#define Z_STEP_PIN         63 // K1
+#define Z_DIR_PIN          62 // K0
+#define Z_ENABLE_PIN       64 // K2
+
+#define E0_STEP_PIN        25 // A3
+#define E0_DIR_PIN         24 // A2
+#define E0_ENABLE_PIN      26 // A4
+
+#define E1_STEP_PIN        29 // A7
+#define E1_DIR_PIN         28 // A6
+#define E1_ENABLE_PIN      39 // G2
+
+//
+// I2C Digipots - MCP4018
+// Address 5E (2F << 1)
+// Set from 0 - 127 with stop bit.
+// (Ex. 3F << 1 | 1)
+//
+#define DIGIPOTS_I2C_SCL    76 // J5
+#define DIGIPOTS_I2C_SDA_X  57 // F3
+#define DIGIPOTS_I2C_SDA_Y  61 // F7
+#define DIGIPOTS_I2C_SDA_Z  65 // K3
+#define DIGIPOTS_I2C_SDA_E0 27 // A5
+#define DIGIPOTS_I2C_SDA_E1 77 // J6
+
+//
+// Temperature Sensors
+//
+#define TEMP_BED_PIN       69 // K7
+
+// SPI for Max6675 or Max31855 Thermocouple
+// Uses a separate SPI bus
+//
+//  3 E5 DO (SO)
+//  5 E3 CS1
+//  2 E4 CS2
+// 78 E2 SCK
+//
+#define THERMO_SCK_PIN     78 // E2
+#define THERMO_DO_PIN       3 // E5
+#define THERMO_CS1          5 // E3
+#define THERMO_CS2          2 // E4
+
+//
+// Augmentation for auto-assigning plugs
+//
+// Two thermocouple connectors allows for either
+// 2 extruders or 1 extruder and a heated bed.
+// With no heated bed, an additional 24V fan is possible.
+//
+#define MOSFET_A_PIN     6 // H3
+#define MOSFET_B_PIN     9 // B5
+#define MOSFET_C_PIN    45 // L4
+#define MOSFET_D_PIN    44 // L5
+
+#if HOTENDS > 1
+  #if TEMP_SENSOR_BED
+    #define IS_EEB
+  #else
+    #define IS_EEF
+  #endif
+#elif TEMP_SENSOR_BED
+  #define IS_EFB
+#else
+  #define IS_EFF
+#endif
+
+//
+// Heaters / Fans (24V)
+//
+#define HEATER_0_PIN     MOSFET_A_PIN
+
+#if ENABLED(IS_EFB)                            // Hotend, Fan, Bed
+  #define FAN_PIN        MOSFET_B_PIN
+  #define HEATER_BED_PIN MOSFET_C_PIN
+#elif ENABLED(IS_EEF)                          // Hotend, Hotend, Fan
+  #define HEATER_1_PIN   MOSFET_B_PIN
+  #define FAN_PIN        MOSFET_C_PIN
+#elif ENABLED(IS_EEB)                          // Hotend, Hotend, Bed
+  #define HEATER_1_PIN   MOSFET_B_PIN
+  #define HEATER_BED_PIN MOSFET_C_PIN
+#elif ENABLED(IS_EFF)                          // Hotend, Fan, Fan
+  #define FAN_PIN        MOSFET_B_PIN
+  #define FAN1_PIN       MOSFET_C_PIN
+#elif ENABLED(IS_SF)                           // Spindle, Fan
+  #define FAN_PIN        MOSFET_C_PIN
+#endif
+
+#ifndef FAN_PIN
+  #define FAN_PIN MOSFET_D_PIN
+#endif
+
+//
+// Extruder Auto Fan Pins
+//
+#define EXTRUDER_0_AUTO_FAN  7 // H4
+#define EXTRUDER_1_AUTO_FAN 12 // B6
+
+//
+// Misc. Functions
+//
+#define LED_PIN             13 // B7
+#define CUTOFF_RESET_PIN    16 // H1
+#define CUTOFF_TEST_PIN     17 // H0
+
+//
+// LCD / Controller
+//
+// Replicator uses a 3-wire SR controller with HD44780
+// For now, pretend it's the SAV
+//
+#define SAV_3DLCD
+#define SR_DATA_PIN         34 // C3
+#define SR_CLK_PIN          35 // C2
+#define SR_STROBE_PIN       33 // C4
+
+#define BTN_UP              75 // J4
+#define BTN_DOWN            73 // J3
+#define BTN_LEFT            72 // J2
+#define BTN_RIGHT           14 // J1
+#define BTN_CENTER          15 // J0
+#define BTN_ENC             BTN_CENTER
+
+#define BEEPER_PIN           4 // G5
+
+#define STAT_LED_RED        32 // C5
+#define STAT_LED_BLUE       31 // C6 (Actually green)
+
+//
+// SD Card
+//
+#define SDSS                53 // B0
+#define SD_DETECT_PIN       30 // C7
+
diff --git a/Marlin/ultralcd_impl_HD44780.h b/Marlin/ultralcd_impl_HD44780.h
index d43f88e..b60deec 100644
--- a/Marlin/ultralcd_impl_HD44780.h
+++ b/Marlin/ultralcd_impl_HD44780.h
@@ -161,7 +161,11 @@ extern volatile uint8_t buttons;  //an extended version of the last checked butt
   #include <LCD.h>
   #include <LiquidCrystal_SR.h>
   #define LCD_CLASS LiquidCrystal_SR
-  LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN);
+  #if defined(SR_STROBE_PIN)
+    LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN, SR_STROBE_PIN);
+  #else
+    LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN);
+  #endif
 #elif ENABLED(LCM1602)
   #include <Wire.h>
   #include <LCD.h>

commit d567b426d57eb39851a0045105c1bed8f1517dca (from ab84ed22cac2ad82d027a06f4a8fcf9d5c70ff8d)
Merge: 43df9ac ab84ed2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 31 08:01:41 2016 -0500

    Merge pull request #4894 from thinkyhead/rc_mightyboard_rev_e
    
    Mightyboard Revision E preliminary support

diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
index 1e87012..cfbb873
--- a/.gitignore
+++ b/.gitignore
@@ -114,3 +114,7 @@ applet/
 # Debug files
 *.dSYM/
 *.su
+
+#PlatformIO files/dirs
+.pioenvs
+.piolib
diff --git a/.travis.yml b/.travis.yml
index fe43525..5638542 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -106,9 +106,9 @@ script:
   - opt_enable FIX_MOUNTED_PROBE Z_SAFE_HOMING
   - build_marlin
   #
-  # ...with AUTO_BED_LEVELING_FEATURE, Z_MIN_PROBE_REPEATABILITY_TEST, & DEBUG_LEVELING_FEATURE
+  # ...with AUTO_BED_LEVELING_LINEAR, Z_MIN_PROBE_REPEATABILITY_TEST, & DEBUG_LEVELING_FEATURE
   #
-  - opt_enable AUTO_BED_LEVELING_FEATURE Z_MIN_PROBE_REPEATABILITY_TEST DEBUG_LEVELING_FEATURE
+  - opt_enable AUTO_BED_LEVELING_LINEAR Z_MIN_PROBE_REPEATABILITY_TEST DEBUG_LEVELING_FEATURE
   - opt_set ABL_GRID_POINTS_X 16
   - opt_set ABL_GRID_POINTS_Y 16
   - build_marlin
@@ -119,9 +119,9 @@ script:
   - opt_enable Z_PROBE_SLED
   - build_marlin
   #
-  # ...with AUTO_BED_LEVELING_FEATURE & DEBUG_LEVELING_FEATURE
+  # ...with AUTO_BED_LEVELING_LINEAR & DEBUG_LEVELING_FEATURE
   #
-  - opt_enable AUTO_BED_LEVELING_FEATURE DEBUG_LEVELING_FEATURE
+  - opt_enable AUTO_BED_LEVELING_LINEAR DEBUG_LEVELING_FEATURE
   - build_marlin
   #
   # Test a Servo Probe
@@ -130,9 +130,9 @@ script:
   - opt_enable NUM_SERVOS Z_ENDSTOP_SERVO_NR Z_SERVO_ANGLES DEACTIVATE_SERVOS_AFTER_MOVE
   - build_marlin
   #
-  # ...with AUTO_BED_LEVELING_FEATURE & DEBUG_LEVELING_FEATURE
+  # ...with AUTO_BED_LEVELING_3POINT & DEBUG_LEVELING_FEATURE
   #
-  - opt_enable AUTO_BED_LEVELING_FEATURE DEBUG_LEVELING_FEATURE
+  - opt_enable AUTO_BED_LEVELING_3POINT DEBUG_LEVELING_FEATURE
   - build_marlin
   #
   # Test MESH_BED_LEVELING feature, with LCD
@@ -360,7 +360,7 @@ script:
   #
   - use_example_configs delta/generic
   - opt_disable DISABLE_MIN_ENDSTOPS
-  - opt_enable AUTO_BED_LEVELING_FEATURE Z_PROBE_ALLEN_KEY
+  - opt_enable AUTO_BED_LEVELING_BILINEAR Z_PROBE_ALLEN_KEY
   - build_marlin
   #
   # Delta Config (Mini Kossel)
@@ -376,7 +376,7 @@ script:
   # SCARA Config
   #
   - use_example_configs SCARA
-  - opt_enable AUTO_BED_LEVELING_FEATURE FIX_MOUNTED_PROBE USE_ZMIN_PLUG EEPROM_SETTINGS EEPROM_CHITCHAT ULTIMAKERCONTROLLER
+  - opt_enable AUTO_BED_LEVELING_BILINEAR FIX_MOUNTED_PROBE USE_ZMIN_PLUG EEPROM_SETTINGS EEPROM_CHITCHAT ULTIMAKERCONTROLLER
   - build_marlin
   #
   # tvrrug Config need to check board type for sanguino atmega644p
diff --git a/Marlin/Conditionals_post.h b/Marlin/Conditionals_post.h
index 1b5e418..95054af 100644
--- a/Marlin/Conditionals_post.h
+++ b/Marlin/Conditionals_post.h
@@ -117,8 +117,6 @@
   /**
    * Auto Bed Leveling and Z Probe Repeatability Test
    */
-  #define HAS_PROBING_PROCEDURE (ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST))
-
   #define HOMING_Z_WITH_PROBE (HAS_BED_PROBE && Z_HOME_DIR < 0 && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))
 
   /**
@@ -224,8 +222,12 @@
   #if TEMP_SENSOR_0 == -3
     #define HEATER_0_USES_MAX6675
     #define MAX6675_IS_MAX31855
+    #define MAX6675_TMIN -270
+    #define MAX6675_TMAX 1800
   #elif TEMP_SENSOR_0 == -2
     #define HEATER_0_USES_MAX6675
+    #define MAX6675_TMIN 0
+    #define MAX6675_TMAX 1024
   #elif TEMP_SENSOR_0 == -1
     #define HEATER_0_USES_AD595
   #elif TEMP_SENSOR_0 == 0
@@ -308,13 +310,13 @@
   /**
    * ARRAY_BY_EXTRUDERS based on EXTRUDERS
    */
-  #define ARRAY_BY_EXTRUDERS(args...) ARRAY_N(EXTRUDERS, args)
+  #define ARRAY_BY_EXTRUDERS(...) ARRAY_N(EXTRUDERS, __VA_ARGS__)
   #define ARRAY_BY_EXTRUDERS1(v1) ARRAY_BY_EXTRUDERS(v1, v1, v1, v1, v1, v1)
 
   /**
    * ARRAY_BY_HOTENDS based on HOTENDS
    */
-  #define ARRAY_BY_HOTENDS(args...) ARRAY_N(HOTENDS, args)
+  #define ARRAY_BY_HOTENDS(...) ARRAY_N(HOTENDS, __VA_ARGS__)
   #define ARRAY_BY_HOTENDS1(v1) ARRAY_BY_HOTENDS(v1, v1, v1, v1, v1, v1)
 
   /**
@@ -327,66 +329,68 @@
     #define _XMAX_ 101
     #define _YMAX_ 201
     #define _ZMAX_ 301
-    #if Z2_USE_ENDSTOP == _XMAX_
-      #define USE_XMAX_PLUG
-    #elif Z2_USE_ENDSTOP == _YMAX_
-      #define USE_YMAX_PLUG
-    #elif Z2_USE_ENDSTOP == _ZMAX_
-      #define USE_ZMAX_PLUG
-    #elif Z2_USE_ENDSTOP == _XMIN_
+    #if Z2_USE_ENDSTOP == _XMIN_
       #define USE_XMIN_PLUG
+    #elif Z2_USE_ENDSTOP == _XMAX_
+      #define USE_XMAX_PLUG
     #elif Z2_USE_ENDSTOP == _YMIN_
       #define USE_YMIN_PLUG
+    #elif Z2_USE_ENDSTOP == _YMAX_
+      #define USE_YMAX_PLUG
     #elif Z2_USE_ENDSTOP == _ZMIN_
       #define USE_ZMIN_PLUG
+    #elif Z2_USE_ENDSTOP == _ZMAX_
+      #define USE_ZMAX_PLUG
     #endif
     #if Z_HOME_DIR > 0
-      #if Z2_USE_ENDSTOP == _XMAX_
-        #define Z2_MAX_ENDSTOP_INVERTING X_MAX_ENDSTOP_INVERTING
-        #define Z2_MAX_PIN X_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _YMAX_
-        #define Z2_MAX_ENDSTOP_INVERTING Y_MAX_ENDSTOP_INVERTING
-        #define Z2_MAX_PIN Y_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _ZMAX_
-        #define Z2_MAX_ENDSTOP_INVERTING Z_MAX_ENDSTOP_INVERTING
-        #define Z2_MAX_PIN Z_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _XMIN_
+      #if Z2_USE_ENDSTOP == _XMIN_
         #define Z2_MAX_ENDSTOP_INVERTING X_MIN_ENDSTOP_INVERTING
         #define Z2_MAX_PIN X_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _XMAX_
+        #define Z2_MAX_ENDSTOP_INVERTING X_MAX_ENDSTOP_INVERTING
+        #define Z2_MAX_PIN X_MAX_PIN
       #elif Z2_USE_ENDSTOP == _YMIN_
         #define Z2_MAX_ENDSTOP_INVERTING Y_MIN_ENDSTOP_INVERTING
         #define Z2_MAX_PIN Y_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _YMAX_
+        #define Z2_MAX_ENDSTOP_INVERTING Y_MAX_ENDSTOP_INVERTING
+        #define Z2_MAX_PIN Y_MAX_PIN
       #elif Z2_USE_ENDSTOP == _ZMIN_
         #define Z2_MAX_ENDSTOP_INVERTING Z_MIN_ENDSTOP_INVERTING
         #define Z2_MAX_PIN Z_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _ZMAX_
+        #define Z2_MAX_ENDSTOP_INVERTING Z_MAX_ENDSTOP_INVERTING
+        #define Z2_MAX_PIN Z_MAX_PIN
       #else
         #define Z2_MAX_ENDSTOP_INVERTING false
       #endif
     #else
-      #if Z2_USE_ENDSTOP == _XMAX_
-        #define Z2_MIN_ENDSTOP_INVERTING X_MAX_ENDSTOP_INVERTING
-        #define Z2_MIN_PIN X_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _YMAX_
-        #define Z2_MIN_ENDSTOP_INVERTING Y_MAX_ENDSTOP_INVERTING
-        #define Z2_MIN_PIN Y_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _ZMAX_
-        #define Z2_MIN_ENDSTOP_INVERTING Z_MAX_ENDSTOP_INVERTING
-        #define Z2_MIN_PIN Z_MAX_PIN
-      #elif Z2_USE_ENDSTOP == _XMIN_
+      #if Z2_USE_ENDSTOP == _XMIN_
         #define Z2_MIN_ENDSTOP_INVERTING X_MIN_ENDSTOP_INVERTING
         #define Z2_MIN_PIN X_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _XMAX_
+        #define Z2_MIN_ENDSTOP_INVERTING X_MAX_ENDSTOP_INVERTING
+        #define Z2_MIN_PIN X_MAX_PIN
       #elif Z2_USE_ENDSTOP == _YMIN_
         #define Z2_MIN_ENDSTOP_INVERTING Y_MIN_ENDSTOP_INVERTING
         #define Z2_MIN_PIN Y_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _YMAX_
+        #define Z2_MIN_ENDSTOP_INVERTING Y_MAX_ENDSTOP_INVERTING
+        #define Z2_MIN_PIN Y_MAX_PIN
       #elif Z2_USE_ENDSTOP == _ZMIN_
         #define Z2_MIN_ENDSTOP_INVERTING Z_MIN_ENDSTOP_INVERTING
         #define Z2_MIN_PIN Z_MIN_PIN
+      #elif Z2_USE_ENDSTOP == _ZMAX_
+        #define Z2_MIN_ENDSTOP_INVERTING Z_MAX_ENDSTOP_INVERTING
+        #define Z2_MIN_PIN Z_MAX_PIN
       #else
         #define Z2_MIN_ENDSTOP_INVERTING false
       #endif
     #endif
   #endif
 
+  #define IS_Z2_OR_PROBE(P) (P == Z2_MIN_PIN || P == Z2_MAX_PIN || P == Z_MIN_PROBE_PIN)
+
   /**
    * Set ENDSTOPPULLUPS for active endstop switches
    */
@@ -424,20 +428,20 @@
   #define HAS_HEATER_2 (PIN_EXISTS(HEATER_2))
   #define HAS_HEATER_3 (PIN_EXISTS(HEATER_3))
   #define HAS_HEATER_BED (PIN_EXISTS(HEATER_BED))
-  #define HAS_AUTO_FAN_0 (PIN_EXISTS(EXTRUDER_0_AUTO_FAN))
-  #define HAS_AUTO_FAN_1 (PIN_EXISTS(EXTRUDER_1_AUTO_FAN))
-  #define HAS_AUTO_FAN_2 (PIN_EXISTS(EXTRUDER_2_AUTO_FAN))
-  #define HAS_AUTO_FAN_3 (PIN_EXISTS(EXTRUDER_3_AUTO_FAN))
-  #define AUTO_1_IS_0 (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN)
-  #define AUTO_2_IS_0 (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN)
-  #define AUTO_2_IS_1 (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN)
-  #define AUTO_3_IS_0 (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN)
-  #define AUTO_3_IS_1 (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN)
-  #define AUTO_3_IS_2 (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_2_AUTO_FAN_PIN)
+  #define HAS_AUTO_FAN_0 (PIN_EXISTS(E0_AUTO_FAN))
+  #define HAS_AUTO_FAN_1 (HOTENDS > 1 && PIN_EXISTS(E1_AUTO_FAN))
+  #define HAS_AUTO_FAN_2 (HOTENDS > 2 && PIN_EXISTS(E2_AUTO_FAN))
+  #define HAS_AUTO_FAN_3 (HOTENDS > 3 && PIN_EXISTS(E3_AUTO_FAN))
   #define HAS_AUTO_FAN (HAS_AUTO_FAN_0 || HAS_AUTO_FAN_1 || HAS_AUTO_FAN_2 || HAS_AUTO_FAN_3)
+  #define AUTO_1_IS_0 (E1_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_2_IS_0 (E2_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_2_IS_1 (E2_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_3_IS_0 (E3_AUTO_FAN_PIN == E0_AUTO_FAN_PIN)
+  #define AUTO_3_IS_1 (E3_AUTO_FAN_PIN == E1_AUTO_FAN_PIN)
+  #define AUTO_3_IS_2 (E3_AUTO_FAN_PIN == E2_AUTO_FAN_PIN)
   #define HAS_FAN0 (PIN_EXISTS(FAN))
-  #define HAS_FAN1 (PIN_EXISTS(FAN1) && CONTROLLERFAN_PIN != FAN1_PIN && EXTRUDER_0_AUTO_FAN_PIN != FAN1_PIN && EXTRUDER_1_AUTO_FAN_PIN != FAN1_PIN && EXTRUDER_2_AUTO_FAN_PIN != FAN1_PIN && EXTRUDER_3_AUTO_FAN_PIN != FAN1_PIN)
-  #define HAS_FAN2 (PIN_EXISTS(FAN2) && CONTROLLERFAN_PIN != FAN2_PIN && EXTRUDER_0_AUTO_FAN_PIN != FAN2_PIN && EXTRUDER_1_AUTO_FAN_PIN != FAN2_PIN && EXTRUDER_2_AUTO_FAN_PIN != FAN2_PIN && EXTRUDER_3_AUTO_FAN_PIN != FAN2_PIN)
+  #define HAS_FAN1 (PIN_EXISTS(FAN1) && CONTROLLERFAN_PIN != FAN1_PIN && E0_AUTO_FAN_PIN != FAN1_PIN && E1_AUTO_FAN_PIN != FAN1_PIN && E2_AUTO_FAN_PIN != FAN1_PIN && E3_AUTO_FAN_PIN != FAN1_PIN)
+  #define HAS_FAN2 (PIN_EXISTS(FAN2) && CONTROLLERFAN_PIN != FAN2_PIN && E0_AUTO_FAN_PIN != FAN2_PIN && E1_AUTO_FAN_PIN != FAN2_PIN && E2_AUTO_FAN_PIN != FAN2_PIN && E3_AUTO_FAN_PIN != FAN2_PIN)
   #define HAS_CONTROLLERFAN (PIN_EXISTS(CONTROLLERFAN))
   #define HAS_SERVOS (defined(NUM_SERVOS) && NUM_SERVOS > 0)
   #define HAS_SERVO_0 (PIN_EXISTS(SERVO0))
@@ -450,22 +454,25 @@
   #define HAS_KILL (PIN_EXISTS(KILL))
   #define HAS_SUICIDE (PIN_EXISTS(SUICIDE))
   #define HAS_PHOTOGRAPH (PIN_EXISTS(PHOTOGRAPH))
-  #define HAS_X_MIN (PIN_EXISTS(X_MIN))
-  #define HAS_X_MAX (PIN_EXISTS(X_MAX))
-  #define HAS_Y_MIN (PIN_EXISTS(Y_MIN))
-  #define HAS_Y_MAX (PIN_EXISTS(Y_MAX))
-  #define HAS_Z_MIN (PIN_EXISTS(Z_MIN))
-  #define HAS_Z_MAX (PIN_EXISTS(Z_MAX))
+  #define HAS_X_MIN (PIN_EXISTS(X_MIN) && !IS_Z2_OR_PROBE(X_MIN_PIN))
+  #define HAS_X_MAX (PIN_EXISTS(X_MAX) && !IS_Z2_OR_PROBE(X_MAX_PIN))
+  #define HAS_Y_MIN (PIN_EXISTS(Y_MIN) && !IS_Z2_OR_PROBE(Y_MIN_PIN))
+  #define HAS_Y_MAX (PIN_EXISTS(Y_MAX) && !IS_Z2_OR_PROBE(Y_MAX_PIN))
+  #define HAS_Z_MIN (PIN_EXISTS(Z_MIN) && !IS_Z2_OR_PROBE(Z_MIN_PIN))
+  #define HAS_Z_MAX (PIN_EXISTS(Z_MAX) && !IS_Z2_OR_PROBE(Z_MAX_PIN))
   #define HAS_Z2_MIN (PIN_EXISTS(Z2_MIN))
   #define HAS_Z2_MAX (PIN_EXISTS(Z2_MAX))
   #define HAS_Z_MIN_PROBE_PIN (PIN_EXISTS(Z_MIN_PROBE))
   #define HAS_SOLENOID_1 (PIN_EXISTS(SOL1))
   #define HAS_SOLENOID_2 (PIN_EXISTS(SOL2))
   #define HAS_SOLENOID_3 (PIN_EXISTS(SOL3))
-  #define HAS_MICROSTEPS (PIN_EXISTS(X_MS1))
+  #define HAS_MICROSTEPS_X (PIN_EXISTS(X_MS1))
+  #define HAS_MICROSTEPS_Y (PIN_EXISTS(Y_MS1))
+  #define HAS_MICROSTEPS_Z (PIN_EXISTS(Z_MS1))
   #define HAS_MICROSTEPS_E0 (PIN_EXISTS(E0_MS1))
   #define HAS_MICROSTEPS_E1 (PIN_EXISTS(E1_MS1))
   #define HAS_MICROSTEPS_E2 (PIN_EXISTS(E2_MS1))
+  #define HAS_MICROSTEPS (HAS_MICROSTEPS_X || HAS_MICROSTEPS_Y || HAS_MICROSTEPS_Z || HAS_MICROSTEPS_E0 || HAS_MICROSTEPS_E1 || HAS_MICROSTEPS_E2)
   #define HAS_STEPPER_RESET (PIN_EXISTS(STEPPER_RESET))
   #define HAS_X_ENABLE (PIN_EXISTS(X_ENABLE))
   #define HAS_X2_ENABLE (PIN_EXISTS(X2_ENABLE))
@@ -641,25 +648,19 @@
   #endif
 
   /**
-   * Specify the exact style of auto bed leveling
-   *
-   *  3POINT    - 3 Point Probing with the least-squares solution.
-   *  LINEAR    - Grid Probing with the least-squares solution.
-   *  NONLINEAR - Grid Probing with a mesh solution. Best for large beds.
+   * Set ABL options based on the specific type of leveling
    */
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    #if DISABLED(AUTO_BED_LEVELING_GRID)
-      #define AUTO_BED_LEVELING_LINEAR
-      #define AUTO_BED_LEVELING_3POINT
-    #elif IS_KINEMATIC
-      #define AUTO_BED_LEVELING_NONLINEAR
-    #else
-      #define AUTO_BED_LEVELING_LINEAR
-      #define AUTO_BED_LEVELING_LINEAR_GRID
-    #endif
-  #endif
+  #define ABL_PLANAR (ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT))
+  #define ABL_GRID   (ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR))
+  #define HAS_ABL    (ABL_PLANAR || ABL_GRID)
+
+  #define PLANNER_LEVELING      (HAS_ABL || ENABLED(MESH_BED_LEVELING))
+  #define HAS_PROBING_PROCEDURE (HAS_ABL || ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST))
 
-  #define PLANNER_LEVELING (ENABLED(MESH_BED_LEVELING) || ENABLED(AUTO_BED_LEVELING_FEATURE))
+  #if HAS_PROBING_PROCEDURE
+    #define PROBE_BED_WIDTH abs(RIGHT_PROBE_BED_POSITION - (LEFT_PROBE_BED_POSITION))
+    #define PROBE_BED_HEIGHT abs(BACK_PROBE_BED_POSITION - (FRONT_PROBE_BED_POSITION))
+  #endif
 
   /**
    * Buzzer/Speaker
@@ -711,4 +712,8 @@
   // Stepper pulse duration, in cycles
   #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)
 
+  #ifndef DELTA_ENDSTOP_ADJ
+    #define DELTA_ENDSTOP_ADJ { 0 }
+  #endif
+
 #endif // CONDITIONALS_POST_H
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 08b6b75..6b63fc3 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -114,7 +114,6 @@
  */
 #define SERIAL_PORT 0
 
-#define BAUDRATE 250000
 /**
  * This setting determines the communication speed of the printer.
  *
@@ -123,6 +122,7 @@
  *
  * :[2400,9600,19200,38400,57600,115200,250000]
  */
+#define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
 //#define BLUETOOTH
@@ -298,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -345,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -495,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -516,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -738,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
-
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
-
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #endif // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index cdf223d..067d86c 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index f62dfef..58d56cd 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -209,6 +209,11 @@ void manage_inactivity(bool ignore_stepper_queue = false);
 
 #endif // !MIXING_EXTRUDER
 
+#if ENABLED(G38_PROBE_TARGET)
+  extern bool G38_move,        // flag to tell the interrupt handler that a G38 command is being run
+              G38_endstop_hit; // flag from the interrupt handler to indicate if the endstop went active
+#endif
+
 /**
  * The axis order in all axis related arrays is X, Y, Z, E
  */
@@ -265,7 +270,7 @@ extern bool axis_known_position[XYZ]; // axis[n].is_known
 extern bool axis_homed[XYZ]; // axis[n].is_homed
 extern volatile bool wait_for_heatup;
 
-#if ENABLED(EMERGENCY_PARSER) && DISABLED(ULTIPANEL)
+#if ENABLED(EMERGENCY_PARSER) || ENABLED(ULTIPANEL)
   extern volatile bool wait_for_user;
 #endif
 
@@ -273,6 +278,10 @@ extern float current_position[NUM_AXIS];
 extern float position_shift[XYZ];
 extern float home_offset[XYZ];
 
+#if HOTENDS > 1
+  extern float hotend_offset[XYZ][HOTENDS];
+#endif
+
 // Software Endstops
 void update_software_endstops(AxisEnum axis);
 #if ENABLED(min_software_endstops) || ENABLED(max_software_endstops)
@@ -319,9 +328,9 @@ float code_value_temp_diff();
   void forward_kinematics_SCARA(const float &a, const float &b);
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
-  extern int nonlinear_grid_spacing[2];
-  float nonlinear_z_offset(float logical[XYZ]);
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  extern int bilinear_grid_spacing[2];
+  float bilinear_z_offset(float logical[XYZ]);
 #endif
 
 #if ENABLED(Z_DUAL_ENDSTOPS)
@@ -389,11 +398,6 @@ extern uint8_t active_extruder;
 
 void calculate_volumetric_multipliers();
 
-// Buzzer
-#if HAS_BUZZER && PIN_EXISTS(BEEPER)
-  #include "buzzer.h"
-#endif
-
 /**
  * Blocking movement and shorthand functions
  */
diff --git a/Marlin/MarlinSerial.cpp b/Marlin/MarlinSerial.cpp
index 3bb2a82..682c730 100644
--- a/Marlin/MarlinSerial.cpp
+++ b/Marlin/MarlinSerial.cpp
@@ -508,10 +508,7 @@ MarlinSerial customizedSerial;
         if (c == '\n') {
           switch (state) {
             case state_M108:
-              wait_for_heatup = false;
-              #if DISABLED(ULTIPANEL)
-                wait_for_user = false;
-              #endif
+              wait_for_user = wait_for_heatup = false;
               break;
             case state_M112:
               kill(PSTR(MSG_KILLED));
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
old mode 100644
new mode 100755
index 15149f2..f3588fd
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -21,7 +21,6 @@
  */
 
 /**
- *
  * About Marlin
  *
  * This firmware is a mashup between Sprinter and grbl.
@@ -34,20 +33,6 @@
 
 #include "Marlin.h"
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-  #include "vector_3.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
-  #include "qr_solve.h"
-#elif ENABLED(MESH_BED_LEVELING)
-  #include "mesh_bed_leveling.h"
-#endif
-
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-  #include "planner_bezier.h"
-#endif
-
 #include "ultralcd.h"
 #include "planner.h"
 #include "stepper.h"
@@ -62,6 +47,23 @@
 #include "duration_t.h"
 #include "types.h"
 
+#if HAS_ABL
+  #include "vector_3.h"
+  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #include "qr_solve.h"
+  #endif
+#elif ENABLED(MESH_BED_LEVELING)
+  #include "mesh_bed_leveling.h"
+#endif
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+  #include "planner_bezier.h"
+#endif
+
+#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #include "buzzer.h"
+#endif
+
 #if ENABLED(USE_WATCHDOG)
   #include "watchdog.h"
 #endif
@@ -118,6 +120,7 @@
  * G30 - Single Z probe, probes bed at current XY location.
  * G31 - Dock sled (Z_PROBE_SLED only)
  * G32 - Undock sled (Z_PROBE_SLED only)
+ * G38 - Probe target - similar to G28 except it uses the Z_MIN endstop for all three axes
  * G90 - Use Absolute Coordinates
  * G91 - Use Relative Coordinates
  * G92 - Set current position to coordinates given
@@ -128,124 +131,123 @@
  * M1   - Same as M0
  * M17  - Enable/Power all stepper motors
  * M18  - Disable all stepper motors; same as M84
- * M20  - List SD card
- * M21  - Init SD card
- * M22  - Release SD card
- * M23  - Select SD file (M23 filename.g)
- * M24  - Start/resume SD print
- * M25  - Pause SD print
- * M26  - Set SD position in bytes (M26 S12345)
- * M27  - Report SD print status
- * M28  - Start SD write (M28 filename.g)
- * M29  - Stop SD write
- * M30  - Delete file from SD (M30 filename.g)
- * M31  - Output time since last M109 or SD card start to serial
- * M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
- *        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
- *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
+ * M20  - List SD card. (Requires SDSUPPORT)
+ * M21  - Init SD card. (Requires SDSUPPORT)
+ * M22  - Release SD card. (Requires SDSUPPORT)
+ * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
+ * M24  - Start/resume SD print. (Requires SDSUPPORT)
+ * M25  - Pause SD print. (Requires SDSUPPORT)
+ * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
+ * M27  - Report SD print status. (Requires SDSUPPORT)
+ * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
+ * M29  - Stop SD write. (Requires SDSUPPORT)
+ * M30  - Delete file from SD: "M30 /path/file.gco"
+ * M31  - Report time since last M109 or SD card start to serial.
+ * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
+ *        Use P to run other files as sub-programs: "M32 P !filename#"
  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
- * M33  - Get the longname version of a path
- * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
- * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]
- * M75  - Start the print job timer
- * M76  - Pause the print job timer
- * M77  - Stop the print job timer
- * M78  - Show statistical information about the print jobs
- * M80  - Turn on Power Supply
- * M81  - Turn off Power Supply
- * M82  - Set E codes absolute (default)
- * M83  - Set E codes relative while in Absolute Coordinates (G90) mode
- * M84  - Disable steppers until next move,
- *        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
+ * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
+ * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
+ * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
+ * M75  - Start the print job timer.
+ * M76  - Pause the print job timer.
+ * M77  - Stop the print job timer.
+ * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
+ * M80  - Turn on Power Supply. (Requires POWER_SUPPLY)
+ * M81  - Turn off Power Supply. (Requires POWER_SUPPLY)
+ * M82  - Set E codes absolute (default).
+ * M83  - Set E codes relative while in Absolute (G90) mode.
+ * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
+ *        duration after which steppers should turn off. S0 disables the timeout.
  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
- * M92  - Set planner.axis_steps_per_mm - same syntax as G92
- * M104 - Set extruder target temp
- * M105 - Read current temp
- * M106 - Fan on
- * M107 - Fan off
- * M108 - Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
+ * M92  - Set planner.axis_steps_per_mm for one or more axes.
+ * M104 - Set extruder target temp.
+ * M105 - Report current temperatures.
+ * M106 - Fan on.
+ * M107 - Fan off.
+ * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
  *        IF AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
- * M110 - Set the current line number
- * M111 - Set debug flags with S<mask>. See flag bits defined in enum.h.
- * M112 - Emergency stop
- * M113 - Get or set the timeout interval for Host Keepalive "busy" messages
- * M114 - Output current position to serial port
- * M115 - Capabilities string
- * M117 - Display a message on the controller screen
- * M119 - Output Endstop status to serial port
- * M120 - Enable endstop detection
- * M121 - Disable endstop detection
- * M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
- * M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
- * M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
- * M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
- * M140 - Set bed target temp
- * M145 - Set the heatup state H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
- * M149 - Set temperature units
- * M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
- * M163 - Set a single proportion for a mixing extruder. Requires MIXING_EXTRUDER.
- * M164 - Save the mix as a virtual extruder. Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS.
- * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. Requires MIXING_EXTRUDER.
- * M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
- *        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
+ * M110 - Set the current line number. (Used by host printing)
+ * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
+ * M112 - Emergency stop.
+ * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
+ * M114 - Report current position.
+ * M115 - Report capabilities.
+ * M117 - Display a message on the controller screen. (Requires an LCD)
+ * M119 - Report endstops status.
+ * M120 - Enable endstops detection.
+ * M121 - Disable endstops detection.
+ * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
+ * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
+ * M128 - EtoP Open. (Requires BARICUDA)
+ * M129 - EtoP Closed. (Requires BARICUDA)
+ * M140 - Set bed target temp. S<temp>
+ * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
+ * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
+ * M150 - Set BlinkM Color R<red> U<green> B<blue>. Values 0-255. (Requires BLINKM)
+ * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
+ * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
+ * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
+ * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
+ *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
- * M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
- * M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
- * M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
- * M204 - Set default acceleration: P for Printing moves, R for Retract only (no X, Y, Z) moves and T for Travel (non printing) moves (ex. M204 P800 T3000 R9000) in units/sec^2
+ * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
+ * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
+ * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
+ * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
  * M205 - Set advanced settings. Current units apply:
             S<print> T<travel> minimum speeds
             B<minimum segment time>
-            X<max xy jerk>, Z<max Z jerk>, E<max E jerk>
- * M206 - Set additional homing offset
- * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>
- * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>
- * M209 - Turn Automatic Retract Detection on/off: S<bool> (For slicers that don't support G10/11).
+            X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
+ * M206 - Set additional homing offset.
+ * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
+ * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
+ * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
           Every normal extrude-only move will be classified as retract depending on the direction.
- * M211 - Enable, Disable, and/or Report software endstops: [S<bool>]
- * M218 - Set a tool offset: T<index> X<offset> Y<offset>
- * M220 - Set Feedrate Percentage: S<percent> ("FR" on your LCD)
- * M221 - Set Flow Percentage: S<percent>
- * M226 - Wait until the specified pin reaches the state required: P<pin number> S<pin state>
- * M240 - Trigger a camera to take a photograph
- * M250 - Set LCD contrast C<contrast value> (value 0..63)
- * M280 - Set servo position absolute. P: servo index, S: angle or microseconds
+ * M211 - Enable, Disable, and/or Report software endstops: S<0|1>
+ * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
+ * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
+ * M221 - Set Flow Percentage: "M221 S<percent>"
+ * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
+ * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
+ * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
+ * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
  * M300 - Play beep sound S<frequency Hz> P<duration ms>
- * M301 - Set PID parameters P I and D
- * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
- * M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
- * M304 - Set bed PID parameters P I and D
- * M380 - Activate solenoid on active extruder
- * M381 - Disable all solenoids
- * M400 - Finish all moves
- * M401 - Lower Z probe if present
- * M402 - Raise Z probe if present
- * M404 - Display or set the Nominal Filament Width: [ N<diameter> ]
- * M405 - Enable Filament Sensor extrusion control. Optional delay between sensor and extruder: D<cm>
- * M406 - Disable Filament Sensor extrusion control
- * M407 - Display measured filament diameter in millimeters
- * M410 - Quickstop. Abort all the planned moves
- * M420 - Enable/Disable Mesh Leveling (with current values) S1=enable S0=disable
- * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units>
- * M428 - Set the home_offset logically based on the current_position
- * M500 - Store parameters in EEPROM
- * M501 - Read parameters from EEPROM (if you need reset them after you changed them temporarily).
- * M502 - Revert to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.
- * M503 - Print the current settings (from memory not from EEPROM). Use S0 to leave off headings.
- * M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
- * M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
- * M665 - Set delta configurations: L<diagonal rod> R<delta radius> S<segments/s>
- * M666 - Set delta endstop adjustment
- * M605 - Set dual x-carriage movement mode: S<mode> [ X<duplication x-offset> R<duplication temp offset> ]
- * M851 - Set Z probe's Z offset in current units. (Negative values apply to probes that extend below the nozzle.)
- * M907 - Set digital trimpot motor current using axis codes.
- * M908 - Control digital trimpot directly.
- * M909 - DAC_STEPPER_CURRENT: Print digipot/DAC current value
- * M910 - DAC_STEPPER_CURRENT: Commit digipot/DAC value to external EEPROM via I2C
- * M350 - Set microstepping mode.
- * M351 - Toggle MS1 MS2 pins directly.
+ * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
+ * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
+ * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
+ * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
+ * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
+ * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
+ * M400 - Finish all moves.
+ * M401 - Lower Z probe. (Requires a probe)
+ * M402 - Raise Z probe. (Requires a probe)
+ * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
+ * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
+ * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
+ * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
+ * M410 - Quickstop. Abort all planned moves.
+ * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
+ * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING)
+ * M428 - Set the home_offset based on the current_position. Nearest edge applies.
+ * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
+ * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
+ * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
+ * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
+ * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+ * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires FILAMENT_CHANGE_FEATURE)
+ * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s>" (Requires DELTA)
+ * M666 - Set delta endstop adjustment. (Requires DELTA)
+ * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
+ * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
+ * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
+ * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
+ * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
+ * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
+ * M350 - Set microstepping mode. (Requires digital microstepping pins.)
+ * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
  *
  * ************ SCARA Specific - This can change to suit future G-code regulations
  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
@@ -256,13 +258,13 @@
  * ************* SCARA End ***************
  *
  * ************ Custom codes - This can change to suit future G-code regulations
- * M100 - Watch Free Memory (For Debugging Only)
- * M928 - Start SD logging (M928 filename.g) - ended by M29
+ * M100 - Watch Free Memory (For Debugging). (Requires M100_FREE_MEMORY_WATCHER)
+ * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
  * M999 - Restart after being stopped by error
  *
  * "T" Codes
  *
- * T0-T3 - Select a tool by index (usually an extruder) [ F<units/min> ]
+ * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
  *
  */
 
@@ -278,27 +280,82 @@
   TWIBus i2c;
 #endif
 
+#if ENABLED(G38_PROBE_TARGET)
+  bool G38_move = false,
+       G38_endstop_hit = false;
+#endif
+
 bool Running = true;
 
 uint8_t marlin_debug_flags = DEBUG_NONE;
 
-float current_position[NUM_AXIS] = { 0.0 };
-static float destination[NUM_AXIS] = { 0.0 };
-bool axis_known_position[XYZ] = { false };
-bool axis_homed[XYZ] = { false };
+/**
+ * Cartesian Current Position
+ *   Used to track the logical position as moves are queued.
+ *   Used by 'line_to_current_position' to do a move after changing it.
+ *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
+ */
+float current_position[XYZE] = { 0.0 };
+
+/**
+ * Cartesian Destination
+ *   A temporary position, usually applied to 'current_position'.
+ *   Set with 'gcode_get_destination' or 'set_destination_to_current'.
+ *   'line_to_destination' sets 'current_position' to 'destination'.
+ */
+static float destination[XYZE] = { 0.0 };
 
+/**
+ * axis_homed
+ *   Flags that each linear axis was homed.
+ *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
+ *
+ * axis_known_position
+ *   Flags that the position is known in each linear axis. Set when homed.
+ *   Cleared whenever a stepper powers off, potentially losing its position.
+ */
+bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
+
+/**
+ * GCode line number handling. Hosts may opt to include line numbers when
+ * sending commands to Marlin, and lines will be checked for sequentiality.
+ * M110 S<int> sets the current line number.
+ */
 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
 
+/**
+ * GCode Command Queue
+ * A simple ring buffer of BUFSIZE command strings.
+ *
+ * Commands are copied into this buffer by the command injectors
+ * (immediate, serial, sd card) and they are processed sequentially by
+ * the main loop. The process_next_command function parses the next
+ * command and hands off execution to individual handler functions.
+ */
 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
-static char* current_command, *current_command_args;
-static uint8_t cmd_queue_index_r = 0,
-               cmd_queue_index_w = 0,
-               commands_in_queue = 0;
+static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
+               cmd_queue_index_w = 0, // Ring buffer write position
+               commands_in_queue = 0; // Count of commands in the queue
+
+/**
+ * Current GCode Command
+ * When a GCode handler is running, these will be set
+ */
+static char *current_command,      // The command currently being executed
+            *current_command_args, // The address where arguments begin
+            *seen_pointer;         // Set by code_seen(), used by the code_value functions
+
+/**
+ * Next Injected Command pointer. NULL if no commands are being injected.
+ * Used by Marlin internally to ensure that commands initiated from within
+ * are enqueued ahead of any pending serial or sd card commands.
+ */
+static const char *injected_commands_P = NULL;
 
 #if ENABLED(INCH_MODE_SUPPORT)
-  float linear_unit_factor = 1.0;
-  float volumetric_unit_factor = 1.0;
+  float linear_unit_factor = 1.0, volumetric_unit_factor = 1.0;
 #endif
+
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
@@ -316,13 +373,13 @@ float constexpr homing_feedrate_mm_s[] = {
   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
 };
 static float feedrate_mm_s = MMM_TO_MMS(1500.0), saved_feedrate_mm_s;
-int feedrate_percentage = 100, saved_feedrate_percentage;
+int feedrate_percentage = 100, saved_feedrate_percentage,
+    flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
 
-bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
-int flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
-bool volumetric_enabled = false;
-float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA);
-float volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
+bool axis_relative_modes[] = AXIS_RELATIVE_MODES,
+     volumetric_enabled = false;
+float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA),
+      volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
 
 // The distance that XYZ has been offset by G92. Reset by G28.
 float position_shift[XYZ] = { 0 };
@@ -348,9 +405,11 @@ uint8_t active_extruder = 0;
 // Relative Mode. Enable with G91, disable with G90.
 static bool relative_mode = false;
 
+// For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
-#if ENABLED(EMERGENCY_PARSER) && DISABLED(ULTIPANEL)
+// For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
+#if ENABLED(EMERGENCY_PARSER) || ENABLED(ULTIPANEL)
   volatile bool wait_for_user = false;
 #endif
 
@@ -358,16 +417,9 @@ const char errormagic[] PROGMEM = "Error:";
 const char echomagic[] PROGMEM = "echo:";
 const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
 
+// Number of characters read in the current line of serial input
 static int serial_count = 0;
 
-// GCode parameter pointer used by code_seen(), code_value_float(), etc.
-static char* seen_pointer;
-
-// Next Immediate GCode Command pointer. NULL if none.
-const char* queued_commands_P = NULL;
-
-const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
-
 // Inactivity shutdown
 millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
@@ -383,7 +435,7 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
 // Buzzer - I2C on the LCD or a BEEPER_PIN
 #if ENABLED(LCD_USE_I2C_BUZZER)
   #define BUZZ(d,f) lcd_buzz(d, f)
-#elif HAS_BUZZER
+#elif PIN_EXISTS(BEEPER)
   Buzzer buzzer;
   #define BUZZ(d,f) buzzer.tone(d, f)
 #else
@@ -398,7 +450,7 @@ static uint8_t target_extruder;
 
 #define PLANNER_XY_FEEDRATE() (min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
@@ -407,19 +459,29 @@ static uint8_t target_extruder;
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  #if ENABLED(DELTA)
+    #define ADJUST_DELTA(V) \
+      if (planner.abl_enabled) { \
+        const float zadj = bilinear_z_offset(V); \
+        delta[A_AXIS] += zadj; \
+        delta[B_AXIS] += zadj; \
+        delta[C_AXIS] += zadj; \
+      }
+  #else
+    #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
+  #endif
+#elif IS_KINEMATIC
+  #define ADJUST_DELTA(V) NOOP
+#endif
+
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj = 0;
 #endif
 
 // Extruder offsets
 #if HOTENDS > 1
-  float hotend_offset[][HOTENDS] = {
-    HOTEND_OFFSET_X,
-    HOTEND_OFFSET_Y
-    #ifdef HOTEND_OFFSET_Z
-      , HOTEND_OFFSET_Z
-    #endif
-  };
+  float hotend_offset[XYZ][HOTENDS];
 #endif
 
 #if HAS_Z_SERVO_ENDSTOP
@@ -491,8 +553,8 @@ static uint8_t target_extruder;
 
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
-  int nonlinear_grid_spacing[2] = { 0 };
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  int bilinear_grid_spacing[2] = { 0 }, bilinear_start[2] = { 0 };
   float bed_level_grid[ABL_GRID_POINTS_X][ABL_GRID_POINTS_Y];
 #endif
 
@@ -566,8 +628,8 @@ static bool send_ok[BUFSIZE];
   static inline type pgm_read_any(const type *p)  \
   { return pgm_read_##reader##_near(p); }
 
-DEFINE_PGM_READ_ANY(float,       float);
-DEFINE_PGM_READ_ANY(signed char, byte);
+DEFINE_PGM_READ_ANY(float,       float)
+DEFINE_PGM_READ_ANY(signed char, byte)
 
 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
   static const PROGMEM type array##_P[XYZ] =        \
@@ -575,12 +637,12 @@ DEFINE_PGM_READ_ANY(signed char, byte);
   static inline type array(int axis)          \
   { return pgm_read_any(&array##_P[axis]); }
 
-XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
-XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
-XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
-XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS)
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS)
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS)
+XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH)
+XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM)
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR)
 
 /**
  * ***************************************************************************
@@ -632,14 +694,14 @@ static void report_current_position();
     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
   }
 
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  #if HAS_ABL
     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
     }
   #endif
 
   #define DEBUG_POS(SUFFIX,VAR) do { \
-    print_xyz(PSTR(STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
+    print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
 #endif
 
 /**
@@ -662,8 +724,7 @@ inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
     #endif
-    inverse_kinematics(current_position);
-    planner.set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS]);
+    planner.set_position_mm_kinematic(current_position);
   }
   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
 
@@ -702,32 +763,32 @@ extern "C" {
  * Inject the next "immediate" command, when possible.
  * Return true if any immediate commands remain to inject.
  */
-static bool drain_queued_commands_P() {
-  if (queued_commands_P != NULL) {
+static bool drain_injected_commands_P() {
+  if (injected_commands_P != NULL) {
     size_t i = 0;
     char c, cmd[30];
-    strncpy_P(cmd, queued_commands_P, sizeof(cmd) - 1);
+    strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
     cmd[sizeof(cmd) - 1] = '\0';
     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
     cmd[i] = '\0';
     if (enqueue_and_echo_command(cmd)) {   // success?
       if (c)                               // newline char?
-        queued_commands_P += i + 1;        // advance to the next command
+        injected_commands_P += i + 1;        // advance to the next command
       else
-        queued_commands_P = NULL;          // nul char? no more commands
+        injected_commands_P = NULL;          // nul char? no more commands
     }
   }
-  return (queued_commands_P != NULL);      // return whether any more remain
+  return (injected_commands_P != NULL);      // return whether any more remain
 }
 
 /**
  * Record one or many commands to run from program memory.
  * Aborts the current queue, if any.
- * Note: drain_queued_commands_P() must be called repeatedly to drain the commands afterwards
+ * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
  */
 void enqueue_and_echo_commands_P(const char* pgcode) {
-  queued_commands_P = pgcode;
-  drain_queued_commands_P(); // first command executed asap (when possible)
+  injected_commands_P = pgcode;
+  drain_injected_commands_P(); // first command executed asap (when possible)
 }
 
 void clear_command_queue() {
@@ -766,7 +827,8 @@ bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   if (_enqueuecommand(cmd, say_ok)) {
     SERIAL_ECHO_START;
     SERIAL_ECHOPAIR(MSG_Enqueueing, cmd);
-    SERIAL_ECHOLNPGM("\"");
+    SERIAL_CHAR('"');
+    SERIAL_EOL;
     return true;
   }
   return false;
@@ -782,7 +844,7 @@ void setup_killpin() {
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void setup_filrunoutpin() {
-    pinMode(FIL_RUNOUT_PIN, INPUT);
+    SET_INPUT(FIL_RUNOUT_PIN);
     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
       WRITE(FIL_RUNOUT_PIN, HIGH);
     #endif
@@ -860,10 +922,9 @@ void servo_init() {
  */
 #if HAS_STEPPER_RESET
   void disableStepperDrivers() {
-    pinMode(STEPPER_RESET_PIN, OUTPUT);
-    digitalWrite(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
+    OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   }
-  void enableStepperDrivers() { pinMode(STEPPER_RESET_PIN, INPUT); }  // set to input, which allows it to be pulled high by pullups
+  void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
@@ -985,7 +1046,12 @@ inline void get_serial_commands() {
 
       #if DISABLED(EMERGENCY_PARSER)
         // If command was e-stop process now
-        if (strcmp(command, "M108") == 0) wait_for_heatup = false;
+        if (strcmp(command, "M108") == 0) {
+          wait_for_heatup = false;
+          #if ENABLED(ULTIPANEL)
+            wait_for_user = false;
+          #endif
+        }
         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
       #endif
@@ -1081,14 +1147,14 @@ inline void get_serial_commands() {
 
 /**
  * Add to the circular command queue the next command from:
- *  - The command-injection queue (queued_commands_P)
+ *  - The command-injection queue (injected_commands_P)
  *  - The active serial input (usually USB)
  *  - The SD card file being actively printed
  */
 void get_available_commands() {
 
   // if any immediate commands remain, don't get other commands yet
-  if (drain_queued_commands_P()) return;
+  if (drain_injected_commands_P()) return;
 
   get_serial_commands();
 
@@ -1259,7 +1325,7 @@ bool get_target_extruder_from_command(int code) {
   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   static float duplicate_extruder_temp_offset = 0;   // used in mode 2
 
-#endif //DUAL_X_CARRIAGE
+#endif // DUAL_X_CARRIAGE
 
 /**
  * Software endstops can be used to monitor the open end of
@@ -1340,13 +1406,14 @@ static void set_home_offset(AxisEnum axis, float v) {
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
- * 
+ *
  */
 static void set_axis_is_at_home(AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
     }
   #endif
 
@@ -1434,7 +1501,8 @@ static void set_axis_is_at_home(AxisEnum axis) {
       SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
       DEBUG_POS("", current_position);
       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
     }
   #endif
 }
@@ -1490,8 +1558,7 @@ inline void set_destination_to_current() { memcpy(destination, current_position,
     ) return;
 
     refresh_cmd_timeout();
-    inverse_kinematics(destination);
-    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], destination[E_AXIS], MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
+    planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     set_current_to_destination();
   }
 #endif // IS_KINEMATIC
@@ -1658,7 +1725,8 @@ static void clean_up_after_endstop_or_probe_move() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
-        SERIAL_ECHOLNPGM(")");
+        SERIAL_CHAR(')');
+        SERIAL_EOL;
       }
     #endif
 
@@ -1715,7 +1783,8 @@ static void clean_up_after_endstop_or_probe_move() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("dock_sled(", stow);
-        SERIAL_ECHOLNPGM(")");
+        SERIAL_CHAR(')');
+        SERIAL_EOL;
       }
     #endif
 
@@ -1727,8 +1796,8 @@ static void clean_up_after_endstop_or_probe_move() {
     #endif
   }
 
-#endif // Z_PROBE_SLED
-#if ENABLED(Z_PROBE_ALLEN_KEY)
+#elif ENABLED(Z_PROBE_ALLEN_KEY)
+
   void run_deploy_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
@@ -1806,6 +1875,7 @@ static void clean_up_after_endstop_or_probe_move() {
       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
+
   void run_stow_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
@@ -1883,6 +1953,7 @@ static void clean_up_after_endstop_or_probe_move() {
       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
+
 #endif
 
 #if HAS_BED_PROBE
@@ -1902,6 +1973,13 @@ static void clean_up_after_endstop_or_probe_move() {
   #if ENABLED(BLTOUCH)
     FORCE_INLINE void set_bltouch_deployed(const bool &deploy) {
       servo[Z_ENDSTOP_SERVO_NR].move(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
+          SERIAL_CHAR(')');
+          SERIAL_EOL;
+        }
+      #endif
     }
   #endif
 
@@ -2003,12 +2081,13 @@ static void clean_up_after_endstop_or_probe_move() {
     // Clear endstop flags
     endstops.hit_on_purpose();
 
-    // Tell the planner where we actually are
-    planner.sync_from_steppers();
-
     // Get Z where the steppers were interrupted
     set_current_from_steppers_for_axis(Z_AXIS);
 
+    // Tell the planner where we actually are
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
     #endif
@@ -2030,6 +2109,11 @@ static void clean_up_after_endstop_or_probe_move() {
       // Do a first probe at the fast speed
       do_probe_move(-(Z_MAX_LENGTH) - 10, Z_PROBE_SPEED_FAST);
 
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        float first_probe_z = current_position[Z_AXIS];
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
+      #endif
+
       // move up by the bump distance
       do_blocking_move_to_z(current_position[Z_AXIS] + home_bump_mm(Z_AXIS), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
@@ -2038,6 +2122,7 @@ static void clean_up_after_endstop_or_probe_move() {
       // If the nozzle is above the travel height then
       // move down quickly before doing the slow probe
       float z = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
+      if (zprobe_zoffset < 0) z -= zprobe_zoffset;
       if (z < current_position[Z_AXIS])
         do_blocking_move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
@@ -2050,6 +2135,13 @@ static void clean_up_after_endstop_or_probe_move() {
       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
     #endif
 
+    // Debug: compare probe heights
+    #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
+        SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
+      }
+    #endif
     return current_position[Z_AXIS];
   }
 
@@ -2067,8 +2159,8 @@ static void clean_up_after_endstop_or_probe_move() {
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR(">>> probe_pt(", x);
         SERIAL_ECHOPAIR(", ", y);
-        SERIAL_ECHOPAIR(", ", stow ? "stow" : "no stow");
-        SERIAL_ECHOLNPGM(")");
+        SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
+        SERIAL_ECHOLNPGM("stow)");
         DEBUG_POS("", current_position);
       }
     #endif
@@ -2078,15 +2170,6 @@ static void clean_up_after_endstop_or_probe_move() {
     // Ensure a minimum height before moving the probe
     do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
 
-    // Move to the XY where we shall probe
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("> do_blocking_move_to_xy(", x - (X_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_ECHOPAIR(", ", y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_ECHOLNPGM(")");
-      }
-    #endif
-
     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
     // Move the probe to the given XY
@@ -2122,82 +2205,217 @@ static void clean_up_after_endstop_or_probe_move() {
 
 #endif // HAS_BED_PROBE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if PLANNER_LEVELING
+  /**
+   * Turn bed leveling on or off, fixing the current
+   * position as-needed.
+   *
+   * Disable: Current position = physical position
+   *  Enable: Current position = "unleveled" physical position
+   */
+  void set_bed_leveling_enabled(bool enable=true) {
+    #if ENABLED(MESH_BED_LEVELING)
+
+      if (!enable && mbl.active())
+        current_position[Z_AXIS] +=
+          mbl.get_z(RAW_CURRENT_POSITION(X_AXIS), RAW_CURRENT_POSITION(Y_AXIS)) - (MESH_HOME_SEARCH_Z);
+
+      mbl.set_active(enable && mbl.has_mesh()); // was set_has_mesh(). Is this not correct?
+
+    #elif HAS_ABL
+
+      if (enable != planner.abl_enabled) {
+        planner.abl_enabled = enable;
+        if (!enable)
+          set_current_from_steppers_for_axis(
+            #if ABL_PLANAR
+              ALL_AXES
+            #else
+              Z_AXIS
+            #endif
+          );
+        else
+          planner.unapply_leveling(current_position);
+      }
+
+    #endif
+  }
+
 
   /**
    * Reset calibration results to zero.
-   *
-   * TODO: Proper functions to disable / enable
-   *       bed leveling via a flag, correcting the
-   *       current position in each case.
    */
   void reset_bed_level() {
-    planner.abl_enabled = false;
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
-    #endif
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      planner.bed_level_matrix.set_to_identity();
-    #elif ENABLED(AUTO_BED_LEVELING_NONLINEAR)
-      memset(bed_level_grid, 0, sizeof(bed_level_grid));
+    #if ENABLED(MESH_BED_LEVELING)
+      if (mbl.has_mesh()) {
+        set_bed_leveling_enabled(false);
+        mbl.reset();
+        mbl.set_has_mesh(false);
+      }
+    #else
+      planner.abl_enabled = false;
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
+      #endif
+      #if ABL_PLANAR
+        planner.bed_level_matrix.set_to_identity();
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        for (uint8_t x = 0; x < ABL_GRID_POINTS_X; x++)
+          for (uint8_t y = 0; y < ABL_GRID_POINTS_Y; y++)
+            bed_level_grid[x][y] = 1000.0;
+      #endif
     #endif
   }
 
-#endif // AUTO_BED_LEVELING_FEATURE
+#endif // PLANNER_LEVELING
 
-#if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
   /**
    * Extrapolate a single point from its neighbors
    */
   static void extrapolate_one_point(uint8_t x, uint8_t y, int8_t xdir, int8_t ydir) {
-    if (bed_level_grid[x][y]) return;  // Don't overwrite good values.
-    float a = 2 * bed_level_grid[x + xdir][y] - bed_level_grid[x + xdir * 2][y], // Left to right.
-          b = 2 * bed_level_grid[x][y + ydir] - bed_level_grid[x][y + ydir * 2], // Front to back.
-          c = 2 * bed_level_grid[x + xdir][y + ydir] - bed_level_grid[x + xdir * 2][y + ydir * 2]; // Diagonal.
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPGM("Extrapolate [");
+        if (x < 10) SERIAL_CHAR(' ');
+        SERIAL_ECHO((int)x);
+        SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
+        SERIAL_CHAR(' ');
+        if (y < 10) SERIAL_CHAR(' ');
+        SERIAL_ECHO((int)y);
+        SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
+        SERIAL_CHAR(']');
+      }
+    #endif
+    if (bed_level_grid[x][y] < 999.0) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
+      #endif
+      return;  // Don't overwrite good values.
+    }
+    SERIAL_EOL;
+
+    // Get X neighbors, Y neighbors, and XY neighbors
+    float a1 = bed_level_grid[x + xdir][y], a2 = bed_level_grid[x + xdir * 2][y],
+          b1 = bed_level_grid[x][y + ydir], b2 = bed_level_grid[x][y + ydir * 2],
+          c1 = bed_level_grid[x + xdir][y + ydir], c2 = bed_level_grid[x + xdir * 2][y + ydir * 2];
+
+    // Treat far unprobed points as zero, near as equal to far
+    if (a2 > 999.0) a2 = 0.0; if (a1 > 999.0) a1 = a2;
+    if (b2 > 999.0) b2 = 0.0; if (b1 > 999.0) b1 = b2;
+    if (c2 > 999.0) c2 = 0.0; if (c1 > 999.0) c1 = c2;
+
+    float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
+
+    // Take the average intstead of the median
+    bed_level_grid[x][y] = (a + b + c) / 3.0;
+
     // Median is robust (ignores outliers).
-    bed_level_grid[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
-                                   : ((c < b) ? b : (a < c) ? a : c);
+    // bed_level_grid[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
+    //                                : ((c < b) ? b : (a < c) ? a : c);
   }
 
+  //Enable this if your SCARA uses 180° of total area
+  //#define EXTRAPOLATE_FROM_EDGE
+
+  #if ENABLED(EXTRAPOLATE_FROM_EDGE)
+    #if ABL_GRID_POINTS_X < ABL_GRID_POINTS_Y
+      #define HALF_IN_X
+    #elif ABL_GRID_POINTS_Y < ABL_GRID_POINTS_X
+      #define HALF_IN_Y
+    #endif
+  #endif
+
   /**
    * Fill in the unprobed points (corners of circular print surface)
    * using linear extrapolation, away from the center.
    */
   static void extrapolate_unprobed_bed_level() {
-    int half_x = (ABL_GRID_POINTS_X - 1) / 2,
-        half_y = (ABL_GRID_POINTS_Y - 1) / 2;
-    for (uint8_t y = 0; y <= half_y; y++) {
-      for (uint8_t x = 0; x <= half_x; x++) {
-        if (x + y < 3) continue;
-        extrapolate_one_point(half_x - x, half_y - y, x > 1 ? +1 : 0, y > 1 ? +1 : 0);
-        extrapolate_one_point(half_x + x, half_y - y, x > 1 ? -1 : 0, y > 1 ? +1 : 0);
-        extrapolate_one_point(half_x - x, half_y + y, x > 1 ? +1 : 0, y > 1 ? -1 : 0);
-        extrapolate_one_point(half_x + x, half_y + y, x > 1 ? -1 : 0, y > 1 ? -1 : 0);
+    #ifdef HALF_IN_X
+      const uint8_t ctrx2 = 0, xlen = ABL_GRID_POINTS_X - 1;
+    #else
+      const uint8_t ctrx1 = (ABL_GRID_POINTS_X - 1) / 2, // left-of-center
+                    ctrx2 = ABL_GRID_POINTS_X / 2,       // right-of-center
+                    xlen = ctrx1;
+    #endif
+
+    #ifdef HALF_IN_Y
+      const uint8_t ctry2 = 0, ylen = ABL_GRID_POINTS_Y - 1;
+    #else
+      const uint8_t ctry1 = (ABL_GRID_POINTS_Y - 1) / 2, // top-of-center
+                    ctry2 = ABL_GRID_POINTS_Y / 2,       // bottom-of-center
+                    ylen = ctry1;
+    #endif
+
+    for (uint8_t xo = 0; xo <= xlen; xo++)
+      for (uint8_t yo = 0; yo <= ylen; yo++) {
+        uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
+        #ifndef HALF_IN_X
+          uint8_t x1 = ctrx1 - xo;
+        #endif
+        #ifndef HALF_IN_Y
+          uint8_t y1 = ctry1 - yo;
+          #ifndef HALF_IN_X
+            extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
+          #endif
+          extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
+        #endif
+        #ifndef HALF_IN_X
+          extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
+        #endif
+        extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
       }
-    }
+
   }
 
   /**
    * Print calibration results for plotting or manual frame adjustment.
    */
   static void print_bed_level() {
+    SERIAL_ECHOPGM("Bilinear Leveling Grid:\n ");
+    for (uint8_t x = 0; x < ABL_GRID_POINTS_X; x++) {
+      SERIAL_PROTOCOLPGM("    ");
+      if (x < 10) SERIAL_PROTOCOLCHAR(' ');
+      SERIAL_PROTOCOL((int)x);
+    }
+    SERIAL_EOL;
     for (uint8_t y = 0; y < ABL_GRID_POINTS_Y; y++) {
+      if (y < 9) SERIAL_PROTOCOLCHAR(' ');
+      SERIAL_PROTOCOL((int)y);
       for (uint8_t x = 0; x < ABL_GRID_POINTS_X; x++) {
-        SERIAL_PROTOCOL_F(bed_level_grid[x][y], 2);
         SERIAL_PROTOCOLCHAR(' ');
+        float offset = bed_level_grid[x][y];
+        if (offset < 999.0) {
+          if (offset > 0) SERIAL_CHAR('+');
+          SERIAL_PROTOCOL_F(offset, 2);
+        }
+        else
+          SERIAL_PROTOCOLPGM(" ====");
       }
       SERIAL_EOL;
     }
+    SERIAL_EOL;
   }
 
-#endif // AUTO_BED_LEVELING_NONLINEAR
+#endif // AUTO_BED_LEVELING_BILINEAR
+
 
 /**
  * Home an individual linear axis
  */
 static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.0) {
 
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
+      SERIAL_ECHOPAIR(", ", distance);
+      SERIAL_ECHOPAIR(", ", fr_mm_s);
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
+    }
+  #endif
+
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
     if (deploy_bltouch) set_bltouch_deployed(true);
@@ -2224,6 +2442,14 @@ static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.
   #endif
 
   endstops.hit_on_purpose();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
+    }
+  #endif
 }
 
 /**
@@ -2253,7 +2479,8 @@ static void homeaxis(AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
     }
   #endif
 
@@ -2274,6 +2501,9 @@ static void homeaxis(AxisEnum axis) {
   #endif
 
   // Fast move towards endstop until triggered
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
+  #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
@@ -2287,8 +2517,15 @@ static void homeaxis(AxisEnum axis) {
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
+    #endif
     do_homing_move(axis, -bump);
+
     // Slow move towards endstop until triggered
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
+    #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
@@ -2327,10 +2564,7 @@ static void homeaxis(AxisEnum axis) {
     // retrace by the amount specified in endstop_adj
     if (endstop_adj[axis] * Z_HOME_DIR < 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOPAIR("> endstop_adj = ", endstop_adj[axis] * Z_HOME_DIR);
-          DEBUG_POS("", current_position);
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("endstop_adj:");
       #endif
       do_homing_move(axis, endstop_adj[axis]);
     }
@@ -2358,7 +2592,8 @@ static void homeaxis(AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
     }
   #endif
 } // homeaxis()
@@ -2478,7 +2713,8 @@ void gcode_get_destination() {
 void unknown_command_error() {
   SERIAL_ECHO_START;
   SERIAL_ECHOPAIR(MSG_UNKNOWN_COMMAND, current_command);
-  SERIAL_ECHOLNPGM("\"");
+  SERIAL_CHAR('"');
+  SERIAL_EOL;
 }
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
@@ -2628,7 +2864,7 @@ inline void gcode_G0_G1(
                     x1 = current_position[X_AXIS], y1 = current_position[Y_AXIS],
                     x2 = destination[X_AXIS], y2 = destination[Y_AXIS];
         if (r && (x2 != x1 || y2 != y1)) {
-          const float e = clockwise ? -1 : 1,                     // clockwise -1, counterclockwise 1
+          const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
                       dx = x2 - x1, dy = y2 - y1,                 // X and Y differences
                       d = HYPOT(dx, dy),                          // Linear distance between the points
                       h = sqrt(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
@@ -2813,10 +3049,10 @@ inline void gcode_G4() {
     SERIAL_ECHOPGM("Probe: ");
     #if ENABLED(FIX_MOUNTED_PROBE)
       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
-    #elif HAS_Z_SERVO_ENDSTOP
-      SERIAL_ECHOLNPGM("SERVO PROBE");
     #elif ENABLED(BLTOUCH)
       SERIAL_ECHOLNPGM("BLTOUCH");
+    #elif HAS_Z_SERVO_ENDSTOP
+      SERIAL_ECHOLNPGM("SERVO PROBE");
     #elif ENABLED(Z_PROBE_SLED)
       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
     #elif ENABLED(Z_PROBE_ALLEN_KEY)
@@ -2853,6 +3089,47 @@ inline void gcode_G4() {
         SERIAL_ECHOPGM(" & Same Z as");
       SERIAL_ECHOLNPGM(" Nozzle)");
     #endif
+
+    #if HAS_ABL
+      SERIAL_ECHOPGM("Auto Bed Leveling: ");
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+        SERIAL_ECHOPGM("LINEAR");
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        SERIAL_ECHOPGM("BILINEAR");
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+        SERIAL_ECHOPGM("3POINT");
+      #endif
+      if (planner.abl_enabled) {
+        SERIAL_ECHOLNPGM(" (enabled)");
+        #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_3POINT)
+          float diff[XYZ] = {
+            stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
+            stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
+            stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
+          };
+          SERIAL_ECHOPGM("ABL Adjustment X");
+          if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[X_AXIS]);
+          SERIAL_ECHOPGM(" Y");
+          if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[Y_AXIS]);
+          SERIAL_ECHOPGM(" Z");
+          if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[Z_AXIS]);
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
+        #endif
+      }
+      SERIAL_EOL;
+    #elif ENABLED(MESH_BED_LEVELING)
+      SERIAL_ECHOPGM("Mesh Bed Leveling");
+      if (mbl.active()) {
+        SERIAL_ECHOLNPGM(" (enabled)");
+        SERIAL_ECHOPAIR("MBL Adjustment Z", mbl.get_z(RAW_CURRENT_POSITION(X_AXIS), RAW_CURRENT_POSITION(Y_AXIS)));
+      }
+      SERIAL_EOL;
+    #endif
+
   }
 
 #endif // DEBUG_LEVELING_FEATURE
@@ -2864,8 +3141,11 @@ inline void gcode_G4() {
    * This is like quick_home_xy() but for 3 towers.
    */
   inline void home_delta() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
+    #endif
     // Init the current position of all carriages to 0,0,0
-    memset(current_position, 0, sizeof(current_position));
+    ZERO(current_position);
     sync_plan_position();
 
     // Move all carriages together linearly until an endstop is hit.
@@ -2875,11 +3155,8 @@ inline void gcode_G4() {
     stepper.synchronize();
     endstops.hit_on_purpose(); // clear endstop hit flags
 
-    // Probably not needed. Double-check this line:
-    memset(current_position, 0, sizeof(current_position));
-
     // At least one carriage has reached the top.
-    // Now back off and re-home each carriage separately.
+    // Now re-home each carriage separately.
     HOMEAXIS(A);
     HOMEAXIS(B);
     HOMEAXIS(C);
@@ -2893,7 +3170,7 @@ inline void gcode_G4() {
     SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(DELTA)", current_position);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
     #endif
   }
 
@@ -2982,7 +3259,7 @@ inline void gcode_G28() {
   stepper.synchronize();
 
   // For auto bed leveling, clear the level matrix
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  #if HAS_ABL
     reset_bed_level();
   #endif
 
@@ -3133,6 +3410,11 @@ inline void gcode_G28() {
 
   endstops.not_homing();
 
+  #if ENABLED(DELTA)
+    // move to a height where we can use the full xy-area
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+
   // Enable mesh leveling again
   #if ENABLED(MESH_BED_LEVELING)
     if (mbl.has_mesh()) {
@@ -3177,11 +3459,6 @@ inline void gcode_G28() {
     }
   #endif
 
-  #if ENABLED(DELTA)
-    // move to a height where we can use the full xy-area
-    do_blocking_move_to_z(delta_clip_start_height);
-  #endif
-
   clean_up_after_endstop_or_probe_move();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3346,9 +3623,10 @@ inline void gcode_G28() {
           }
         }
         else {
-          SERIAL_PROTOCOLLNPGM("X not entered.");
+          SERIAL_CHAR('X'); SERIAL_PROTOCOLLNPGM(" not entered.");
           return;
         }
+
         if (code_seen('Y')) {
           py = code_value_int() - 1;
           if (py < 0 || py >= MESH_NUM_Y_POINTS) {
@@ -3357,14 +3635,15 @@ inline void gcode_G28() {
           }
         }
         else {
-          SERIAL_PROTOCOLLNPGM("Y not entered.");
+          SERIAL_CHAR('Y'); SERIAL_PROTOCOLLNPGM(" not entered.");
           return;
         }
+
         if (code_seen('Z')) {
           mbl.z_values[py][px] = code_value_axis_units(Z_AXIS);
         }
         else {
-          SERIAL_PROTOCOLLNPGM("Z not entered.");
+          SERIAL_CHAR('Z'); SERIAL_PROTOCOLLNPGM(" not entered.");
           return;
         }
         break;
@@ -3374,7 +3653,7 @@ inline void gcode_G28() {
           mbl.z_offset = code_value_axis_units(Z_AXIS);
         }
         else {
-          SERIAL_PROTOCOLLNPGM("Z not entered.");
+          SERIAL_CHAR('Z'); SERIAL_PROTOCOLLNPGM(" not entered.");
           return;
         }
         break;
@@ -3394,7 +3673,7 @@ inline void gcode_G28() {
     report_current_position();
   }
 
-#elif ENABLED(AUTO_BED_LEVELING_FEATURE)
+#elif HAS_ABL
 
   /**
    * G29: Detailed Z probe, probes the bed at 3 or more points.
@@ -3402,7 +3681,7 @@ inline void gcode_G28() {
    *
    * Enhanced G29 Auto Bed Leveling Probe Routine
    *
-   * Parameters With AUTO_BED_LEVELING_GRID:
+   * Parameters With ABL_GRID:
    *
    *  P  Set the size of the grid that will be probed (P x P points).
    *     Not supported by non-linear delta printer bed leveling.
@@ -3437,11 +3716,15 @@ inline void gcode_G28() {
   inline void gcode_G29() {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
+      bool query = code_seen('Q');
+      uint8_t old_debug_flags = marlin_debug_flags;
+      if (query) marlin_debug_flags |= DEBUG_LEVELING;
       if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM(">>> gcode_G29");
-        DEBUG_POS("", current_position);
+        DEBUG_POS(">>> gcode_G29", current_position);
         log_machine_info();
       }
+      marlin_debug_flags = old_debug_flags;
+      if (query) return;
     #endif
 
     // Don't allow auto-leveling without homing first
@@ -3456,26 +3739,33 @@ inline void gcode_G28() {
     bool dryrun = code_seen('D'),
          stow_probe_after_each = code_seen('E');
 
-    #if ENABLED(AUTO_BED_LEVELING_GRID)
-
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-        bool do_topography_map = verbose_level > 2 || code_seen('T');
-      #endif
+    #if ABL_GRID
 
       if (verbose_level > 0) {
         SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
         if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
       }
 
-      int abl_grid_points_x = ABL_GRID_POINTS_X,
-          abl_grid_points_y = ABL_GRID_POINTS_Y;
+      #if ABL_PLANAR
+
+        bool do_topography_map = verbose_level > 2 || code_seen('T');
+
+        // X and Y specify points in each direction, overriding the default
+        // These values may be saved with the completed mesh
+        int abl_grid_points_x = code_seen('X') ? code_value_int() : ABL_GRID_POINTS_X,
+            abl_grid_points_y = code_seen('Y') ? code_value_int() : ABL_GRID_POINTS_Y;
 
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
         if (code_seen('P')) abl_grid_points_x = abl_grid_points_y = code_value_int();
-        if (abl_grid_points_x < 2) {
-          SERIAL_PROTOCOLLNPGM("?Number of probed (P)oints is implausible (2 minimum).");
+
+        if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
+          SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
           return;
         }
+
+      #else
+
+         const int abl_grid_points_x = ABL_GRID_POINTS_X, abl_grid_points_y = ABL_GRID_POINTS_Y;
+
       #endif
 
       xy_probe_feedrate_mm_s = MMM_TO_MMS(code_seen('S') ? code_value_linear_units() : XY_PROBE_SPEED);
@@ -3514,22 +3804,21 @@ inline void gcode_G28() {
         return;
       }
 
-    #endif // AUTO_BED_LEVELING_GRID
+    #endif // ABL_GRID
 
     stepper.synchronize();
 
     // Disable auto bed leveling during G29
-    bool abl_should_reenable = planner.abl_enabled;
+    bool abl_should_enable = planner.abl_enabled;
 
     planner.abl_enabled = false;
 
     if (!dryrun) {
       // Re-orient the current position without leveling
       // based on where the steppers are positioned.
-      get_cartesian_from_steppers();
-      memcpy(current_position, cartes, sizeof(cartes));
+      set_current_from_steppers_for_axis(ALL_AXES);
 
-      // Inform the planner about the new coordinates
+      // Sync the planner to where the steppers stopped
       SYNC_PLAN_POSITION_KINEMATIC();
     }
 
@@ -3537,31 +3826,38 @@ inline void gcode_G28() {
 
     // Deploy the probe. Probe will raise if needed.
     if (DEPLOY_PROBE()) {
-      planner.abl_enabled = abl_should_reenable;
+      planner.abl_enabled = abl_should_enable;
       return;
     }
 
     float xProbe = 0, yProbe = 0, measured_z = 0;
 
-    #if ENABLED(AUTO_BED_LEVELING_GRID)
+    #if ABL_GRID
 
       // probe at the points of a lattice grid
       const float xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1),
                   yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
 
-      #if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         float zoffset = zprobe_zoffset;
         if (code_seen('Z')) zoffset += code_value_axis_units(Z_AXIS);
 
-        if (xGridSpacing != nonlinear_grid_spacing[X_AXIS] || yGridSpacing != nonlinear_grid_spacing[Y_AXIS]) {
-          nonlinear_grid_spacing[X_AXIS] = xGridSpacing;
-          nonlinear_grid_spacing[Y_AXIS] = yGridSpacing;
+        if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
+          || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
+          || left_probe_bed_position != bilinear_start[X_AXIS]
+          || front_probe_bed_position != bilinear_start[Y_AXIS]
+        ) {
+          reset_bed_level();
+          bilinear_grid_spacing[X_AXIS] = xGridSpacing;
+          bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
+          bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
+          bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
           // Can't re-enable (on error) until the new grid is written
-          abl_should_reenable = false;
+          abl_should_enable = false;
         }
 
-      #elif ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
+      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
         /**
          * solve the plane equation ax + by + d = z
@@ -3580,34 +3876,50 @@ inline void gcode_G28() {
               eqnBVector[abl2],     // "B" vector of Z points
               mean = 0.0;
 
-      #endif // AUTO_BED_LEVELING_LINEAR_GRID
+      #endif // AUTO_BED_LEVELING_LINEAR
+
+      #if ENABLED(PROBE_Y_FIRST)
+        #define PR_OUTER_VAR xCount
+        #define PR_OUTER_END abl_grid_points_x
+        #define PR_INNER_VAR yCount
+        #define PR_INNER_END abl_grid_points_y
+      #else
+        #define PR_OUTER_VAR yCount
+        #define PR_OUTER_END abl_grid_points_y
+        #define PR_INNER_VAR xCount
+        #define PR_INNER_END abl_grid_points_x
+      #endif
 
-      bool zig = abl_grid_points_y & 1; //always end at [RIGHT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION]
+      bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
-      for (uint8_t yCount = 0; yCount < abl_grid_points_y; yCount++) {
-        float yBase = front_probe_bed_position + yGridSpacing * yCount;
-        yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
+      // Outer loop is Y with PROBE_Y_FIRST disabled
+      for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END; PR_OUTER_VAR++) {
 
-        int8_t xStart, xStop, xInc;
+        int8_t inStart, inStop, inInc;
 
-        if (zig) {
-          xStart = 0;
-          xStop = abl_grid_points_x;
-          xInc = 1;
+        if (zig) { // away from origin
+          inStart = 0;
+          inStop = PR_INNER_END;
+          inInc = 1;
         }
-        else {
-          xStart = abl_grid_points_x - 1;
-          xStop = -1;
-          xInc = -1;
+        else {     // towards origin
+          inStart = PR_INNER_END - 1;
+          inStop = -1;
+          inInc = -1;
         }
 
-        zig = !zig;
+        zig = !zig; // zag
+
+        // Inner loop is Y with PROBE_Y_FIRST enabled
+        for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
+
+          float xBase = left_probe_bed_position + xGridSpacing * xCount,
+                yBase = front_probe_bed_position + yGridSpacing * yCount;
 
-        for (int8_t xCount = xStart; xCount != xStop; xCount += xInc) {
-          float xBase = left_probe_bed_position + xGridSpacing * xCount;
           xProbe = floor(xBase + (xBase < 0 ? 0 : 0.5));
+          yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
 
-          #if ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
+          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
             indexIntoAB[xCount][yCount] = ++probePointCounter;
           #endif
 
@@ -3620,11 +3932,11 @@ inline void gcode_G28() {
           measured_z = probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
 
           if (measured_z == NAN) {
-            planner.abl_enabled = abl_should_reenable;
+            planner.abl_enabled = abl_should_enable;
             return;
           }
 
-          #if ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
+          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
             eqnBVector[probePointCounter] = measured_z;
@@ -3632,7 +3944,7 @@ inline void gcode_G28() {
             eqnAMatrix[probePointCounter + 1 * abl2] = yProbe;
             eqnAMatrix[probePointCounter + 2 * abl2] = 1;
 
-          #elif ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
             bed_level_grid[xCount][yCount] = measured_z + zoffset;
 
@@ -3664,7 +3976,7 @@ inline void gcode_G28() {
       }
 
       if (measured_z == NAN) {
-        planner.abl_enabled = abl_should_reenable;
+        planner.abl_enabled = abl_should_enable;
         return;
       }
 
@@ -3678,14 +3990,14 @@ inline void gcode_G28() {
         planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
 
         // Can't re-enable (on error) until the new grid is written
-        abl_should_reenable = false;
+        abl_should_enable = false;
       }
 
     #endif // AUTO_BED_LEVELING_3POINT
 
     // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
     if (STOW_PROBE()) {
-      planner.abl_enabled = abl_should_reenable;
+      planner.abl_enabled = abl_should_enable;
       return;
     }
 
@@ -3702,12 +4014,12 @@ inline void gcode_G28() {
     #endif
 
     // Calculate leveling, print reports, correct the position
-    #if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       if (!dryrun) extrapolate_unprobed_bed_level();
       print_bed_level();
 
-    #elif ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
+    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
 
       // For LINEAR leveling calculate matrix, print reports, correct the position
 
@@ -3804,9 +4116,9 @@ inline void gcode_G28() {
         }
       } //do_topography_map
 
-    #endif // AUTO_BED_LEVELING_LINEAR_GRID
+    #endif // AUTO_BED_LEVELING_LINEAR
 
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #if ABL_PLANAR
 
       // For LINEAR and 3POINT leveling correct the current position
 
@@ -3821,7 +4133,7 @@ inline void gcode_G28() {
         // 1. Get the distance from the current position to the reference point.
         float x_dist = RAW_CURRENT_POSITION(X_AXIS) - X_TILT_FULCRUM,
               y_dist = RAW_CURRENT_POSITION(Y_AXIS) - Y_TILT_FULCRUM,
-              z_real = RAW_CURRENT_POSITION(Z_AXIS),
+              z_real = current_position[Z_AXIS],
               z_zero = 0;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3856,16 +4168,30 @@ inline void gcode_G28() {
         // 5. The rotated XY and corrected Z are now current_position
         current_position[X_AXIS] = LOGICAL_X_POSITION(x_dist) + X_TILT_FULCRUM;
         current_position[Y_AXIS] = LOGICAL_Y_POSITION(y_dist) + Y_TILT_FULCRUM;
-        current_position[Z_AXIS] = LOGICAL_Z_POSITION(new_z);
-
-        SYNC_PLAN_POSITION_KINEMATIC();
+        current_position[Z_AXIS] = new_z;
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
         #endif
       }
 
-    #endif // AUTO_BED_LEVELING_LINEAR
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      if (!dryrun) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
+        #endif
+
+        // Unapply the offset because it is going to be immediately applied
+        // and cause compensation movement in Z
+        current_position[Z_AXIS] -= bilinear_z_offset(current_position);
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
+        #endif
+      }
+
+    #endif // ABL_PLANAR
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3884,10 +4210,13 @@ inline void gcode_G28() {
     KEEPALIVE_STATE(IN_HANDLER);
 
     // Auto Bed Leveling is complete! Enable if possible.
-    planner.abl_enabled = dryrun ? abl_should_reenable : true;
+    planner.abl_enabled = dryrun ? abl_should_enable : true;
+
+    if (planner.abl_enabled)
+      SYNC_PLAN_POSITION_KINEMATIC();
   }
 
-#endif // AUTO_BED_LEVELING_FEATURE
+#endif // HAS_ABL
 
 #if HAS_BED_PROBE
 
@@ -3896,13 +4225,13 @@ inline void gcode_G28() {
    */
   inline void gcode_G30() {
 
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-      reset_bed_level();
+    // Disable leveling so the planner won't mess with us
+    #if PLANNER_LEVELING
+      set_bed_leveling_enabled(false);
     #endif
 
     setup_for_endstop_or_probe_move();
 
-    // TODO: clear the leveling matrix or the planner will be set incorrectly
     float measured_z = probe_pt(current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,
                                 current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,
                                 true, 1);
@@ -3936,6 +4265,94 @@ inline void gcode_G28() {
 
 #endif // HAS_BED_PROBE
 
+#if ENABLED(G38_PROBE_TARGET)
+
+  static bool G38_run_probe() {
+
+    bool G38_pass_fail = false;
+
+    // Get direction of move and retract
+    float retract_mm[XYZ];
+    LOOP_XYZ(i) {
+      float dist = destination[i] - current_position[i];
+      retract_mm[i] = fabs(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm(i) * (dist > 0 ? -1 : 1);
+    }
+
+    stepper.synchronize();  // wait until the machine is idle
+
+    // Move until destination reached or target hit
+    endstops.enable(true);
+    G38_move = true;
+    G38_endstop_hit = false;
+    prepare_move_to_destination();
+    stepper.synchronize();
+    G38_move = false;
+
+    endstops.hit_on_purpose();
+    set_current_from_steppers_for_axis(ALL_AXES);
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    // Only do remaining moves if target was hit
+    if (G38_endstop_hit) {
+
+      G38_pass_fail = true;
+
+      // Move away by the retract distance
+      set_destination_to_current();
+      LOOP_XYZ(i) destination[i] += retract_mm[i];
+      endstops.enable(false);
+      prepare_move_to_destination();
+      stepper.synchronize();
+
+      feedrate_mm_s /= 4;
+
+      // Bump the target more slowly
+      LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
+
+      endstops.enable(true);
+      G38_move = true;
+      prepare_move_to_destination();
+      stepper.synchronize();
+      G38_move = false;
+
+      set_current_from_steppers_for_axis(ALL_AXES);
+      SYNC_PLAN_POSITION_KINEMATIC();
+    }
+
+    endstops.hit_on_purpose();
+    endstops.not_homing();
+    return G38_pass_fail;
+  }
+
+  /**
+   * G38.2 - probe toward workpiece, stop on contact, signal error if failure
+   * G38.3 - probe toward workpiece, stop on contact
+   *
+   * Like G28 except uses Z min endstop for all axes
+   */
+  inline void gcode_G38(bool is_38_2) {
+    // Get X Y Z E F
+    gcode_get_destination();
+
+    setup_for_endstop_or_probe_move();
+
+    // If any axis has enough movement, do the move
+    LOOP_XYZ(i)
+      if (fabs(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
+        if (!code_seen('F')) feedrate_mm_s = homing_feedrate_mm_s[i];
+        // If G38.2 fails throw an error
+        if (!G38_run_probe() && is_38_2) {
+          SERIAL_ERROR_START;
+          SERIAL_ERRORLNPGM("Failed to reach target");
+        }
+        break;
+      }
+
+    clean_up_after_endstop_or_probe_move();
+  }
+
+#endif // G38_PROBE_TARGET
+
 /**
  * G92: Set current position to given X Y Z E
  */
@@ -3972,7 +4389,7 @@ inline void gcode_G92() {
   report_current_position();
 }
 
-#if ENABLED(ULTIPANEL) || ENABLED(EMERGENCY_PARSER)
+#if ENABLED(EMERGENCY_PARSER) || ENABLED(ULTIPANEL)
 
   /**
    * M0: Unconditional stop - Wait for user button press on LCD
@@ -4002,7 +4419,6 @@ inline void gcode_G92() {
           dontExpireStatus();
         #endif
       }
-      lcd_ignore_click();
 
     #else
 
@@ -4013,47 +4429,32 @@ inline void gcode_G92() {
 
     #endif
 
+    wait_for_user = true;
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+
     stepper.synchronize();
     refresh_cmd_timeout();
 
-    #if ENABLED(ULTIPANEL)
-
-      if (codenum > 0) {
-        codenum += previous_cmd_ms;  // wait until this time for a click
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        while (PENDING(millis(), codenum) && !lcd_clicked()) idle();
-        lcd_ignore_click(false);
-      }
-      else if (lcd_detected()) {
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        while (!lcd_clicked()) idle();
-      }
-      else return;
-
-      if (IS_SD_PRINTING)
-        LCD_MESSAGEPGM(MSG_RESUMING);
-      else
-        LCD_MESSAGEPGM(WELCOME_MSG);
-
-    #else
-
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      wait_for_user = true;
-
-      if (codenum > 0) {
-        codenum += previous_cmd_ms;  // wait until this time for an M108
-        while (PENDING(millis(), codenum) && wait_for_user) idle();
-      }
-      else while (wait_for_user) idle();
-
-      wait_for_user = false;
-
-    #endif
+    if (codenum > 0) {
+      codenum += previous_cmd_ms;  // wait until this time for a click
+      while (PENDING(millis(), codenum) && wait_for_user) idle();
+    }
+    else {
+      #if ENABLED(ULTIPANEL)
+        if (lcd_detected()) {
+          while (wait_for_user) idle();
+          IS_SD_PRINTING ? LCD_MESSAGEPGM(MSG_RESUMING) : LCD_MESSAGEPGM(WELCOME_MSG);
+        }
+      #else
+        while (wait_for_user) idle();
+      #endif
+    }
 
+    wait_for_user = false;
     KEEPALIVE_STATE(IN_HANDLER);
   }
 
-#endif // ULTIPANEL || EMERGENCY_PARSER
+#endif // EMERGENCY_PARSER || ULTIPANEL
 
 /**
  * M17: Enable power on all stepper motors
@@ -4153,7 +4554,9 @@ inline void gcode_M31() {
   SERIAL_ECHO_START;
   SERIAL_ECHOLNPAIR("Print time: ", buffer);
 
-  thermalManager.autotempShutdown();
+  #if ENABLED(AUTOTEMP)
+    thermalManager.autotempShutdown();
+  #endif
 }
 
 #if ENABLED(SDSUPPORT)
@@ -4216,6 +4619,16 @@ inline void gcode_M31() {
 #endif // SDSUPPORT
 
 /**
+ * Sensitive pin test for M42, M226
+ */
+static bool pin_is_protected(uint8_t pin) {
+  static const int sensitive_pins[] = SENSITIVE_PINS;
+  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
+    if (sensitive_pins[i] == pin) return true;
+  return false;
+}
+
+/**
  * M42: Change pin status via GCode
  *
  *  P<pin>  Pin number (LED if omitted)
@@ -4230,12 +4643,11 @@ inline void gcode_M42() {
   int pin_number = code_seen('P') ? code_value_int() : LED_PIN;
   if (pin_number < 0) return;
 
-  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
-    if (pin_number == sensitive_pins[i]) {
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
-      return;
-    }
+  if (pin_is_protected(pin_number)) {
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
+    return;
+  }
 
   pinMode(pin_number, OUTPUT);
   digitalWrite(pin_number, pin_status);
@@ -4256,6 +4668,66 @@ inline void gcode_M42() {
   #endif
 }
 
+#if ENABLED(PINS_DEBUGGING)
+
+  #include "pinsDebug.h"
+
+  /**
+   * M43: Pin report and debug
+   *
+   *      P<pin> Will read/watch a single pin
+   *      W      Watch pins for changes until reboot
+   */
+  inline void gcode_M43() {
+    int first_pin = 0, last_pin = DIO_COUNT - 1;
+    if (code_seen('P')) {
+      first_pin = last_pin = code_value_byte();
+      if (first_pin > DIO_COUNT - 1) return;
+    }
+
+    if (code_seen('W') && code_value_bool()) { // watch digital pins
+      byte pin_state[last_pin - first_pin + 1];
+      for (int8_t pin = first_pin; pin <= last_pin; pin++) {
+        if (pin_is_protected(pin)) continue;
+        pinMode(pin, INPUT_PULLUP);
+        // if (IS_ANALOG(pin))
+        //   pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
+        // else
+          pin_state[pin - first_pin] = digitalRead(pin);
+      }
+
+      #if ENABLED(EMERGENCY_PARSER) || ENABLED(ULTIPANEL)
+        wait_for_user = true;
+      #endif
+
+      for(;;) {
+        for (int8_t pin = first_pin; pin <= last_pin; pin++) {
+          if (pin_is_protected(pin)) continue;
+          byte val;
+          // if (IS_ANALOG(pin))
+          //   val = analogRead(pin - analogInputToDigitalPin(0)); // int16_t val
+          // else
+            val = digitalRead(pin);
+          if (val != pin_state[pin - first_pin]) {
+            report_pin_state(pin);
+            pin_state[pin - first_pin] = val;
+          }
+        }
+
+        #if ENABLED(EMERGENCY_PARSER) || ENABLED(ULTIPANEL)
+          if (!wait_for_user) break;
+        #endif
+
+        safe_delay(500);
+      }
+    }
+    else // single pins report
+      for (int8_t pin = first_pin; pin <= last_pin; pin++)
+        report_pin_state(pin);
+  }
+
+#endif // PINS_DEBUGGING
+
 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
 
   /**
@@ -4287,7 +4759,7 @@ inline void gcode_M42() {
     }
 
     if (verbose_level > 0)
-      SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability test");
+      SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
 
     int8_t n_samples = code_seen('P') ? code_value_byte() : 10;
     if (n_samples < 4 || n_samples > 50) {
@@ -4342,7 +4814,7 @@ inline void gcode_M42() {
       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
 
     // Disable bed level correction in M48 because we want the raw data when we probe
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    #if HAS_ABL
       reset_bed_level();
     #endif
 
@@ -4353,7 +4825,8 @@ inline void gcode_M42() {
 
     randomSeed(millis());
 
-    double mean = 0, sigma = 0, sample_set[n_samples];
+    double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
+
     for (uint8_t n = 0; n < n_samples; n++) {
       if (n_legs) {
         int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
@@ -4423,7 +4896,7 @@ inline void gcode_M42() {
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
+      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
 
       /**
        * Get the current mean for the data points we have so far
@@ -4432,6 +4905,9 @@ inline void gcode_M42() {
       for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
       mean = sum / (n + 1);
 
+      NOMORE(min, sample_set[n]);
+      NOLESS(max, sample_set[n]);
+
       /**
        * Now, use that mean to calculate the standard deviation for the
        * data points we have so far
@@ -4446,13 +4922,19 @@ inline void gcode_M42() {
           SERIAL_PROTOCOL(n + 1);
           SERIAL_PROTOCOLPGM(" of ");
           SERIAL_PROTOCOL((int)n_samples);
-          SERIAL_PROTOCOLPGM("   z: ");
-          SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
+          SERIAL_PROTOCOLPGM(": z: ");
+          SERIAL_PROTOCOL_F(sample_set[n], 3);
           if (verbose_level > 2) {
             SERIAL_PROTOCOLPGM(" mean: ");
-            SERIAL_PROTOCOL_F(mean, 6);
-            SERIAL_PROTOCOLPGM("   sigma: ");
+            SERIAL_PROTOCOL_F(mean, 4);
+            SERIAL_PROTOCOLPGM(" sigma: ");
             SERIAL_PROTOCOL_F(sigma, 6);
+            SERIAL_PROTOCOLPGM(" min: ");
+            SERIAL_PROTOCOL_F(min, 3);
+            SERIAL_PROTOCOLPGM(" max: ");
+            SERIAL_PROTOCOL_F(max, 3);
+            SERIAL_PROTOCOLPGM(" range: ");
+            SERIAL_PROTOCOL_F(max-min, 3);
           }
         }
         SERIAL_EOL;
@@ -4462,15 +4944,25 @@ inline void gcode_M42() {
 
     if (STOW_PROBE()) return;
 
+    SERIAL_PROTOCOLPGM("Finished!");
+    SERIAL_EOL;
+
     if (verbose_level > 0) {
       SERIAL_PROTOCOLPGM("Mean: ");
       SERIAL_PROTOCOL_F(mean, 6);
+      SERIAL_PROTOCOLPGM(" Min: ");
+      SERIAL_PROTOCOL_F(min, 3);
+      SERIAL_PROTOCOLPGM(" Max: ");
+      SERIAL_PROTOCOL_F(max, 3);
+      SERIAL_PROTOCOLPGM(" Range: ");
+      SERIAL_PROTOCOL_F(max-min, 3);
       SERIAL_EOL;
     }
 
     SERIAL_PROTOCOLPGM("Standard Deviation: ");
     SERIAL_PROTOCOL_F(sigma, 6);
-    SERIAL_EOL; SERIAL_EOL;
+    SERIAL_EOL;
+    SERIAL_EOL;
 
     clean_up_after_endstop_or_probe_move();
 
@@ -5026,47 +5518,27 @@ inline void gcode_M140() {
    *   F<fan speed>
    */
   inline void gcode_M145() {
-    int8_t material = code_seen('S') ? (int8_t)code_value_int() : 0;
-    if (material < 0 || material > 1) {
+    uint8_t material = code_seen('S') ? (uint8_t)code_value_int() : 0;
+    if (material >= COUNT(lcd_preheat_hotend_temp)) {
       SERIAL_ERROR_START;
       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
     }
     else {
       int v;
-      switch (material) {
-        case 0:
-          if (code_seen('H')) {
-            v = code_value_int();
-            preheatHotendTemp1 = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
-          }
-          if (code_seen('F')) {
-            v = code_value_int();
-            preheatFanSpeed1 = constrain(v, 0, 255);
-          }
-          #if TEMP_SENSOR_BED != 0
-            if (code_seen('B')) {
-              v = code_value_int();
-              preheatBedTemp1 = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
-            }
-          #endif
-          break;
-        case 1:
-          if (code_seen('H')) {
-            v = code_value_int();
-            preheatHotendTemp2 = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
-          }
-          if (code_seen('F')) {
-            v = code_value_int();
-            preheatFanSpeed2 = constrain(v, 0, 255);
-          }
-          #if TEMP_SENSOR_BED != 0
-            if (code_seen('B')) {
-              v = code_value_int();
-              preheatBedTemp2 = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
-            }
-          #endif
-          break;
+      if (code_seen('H')) {
+        v = code_value_int();
+        lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
+      }
+      if (code_seen('F')) {
+        v = code_value_int();
+        lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
       }
+      #if TEMP_SENSOR_BED != 0
+        if (code_seen('B')) {
+          v = code_value_int();
+          lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
+        }
+      #endif
     }
   }
 
@@ -5077,13 +5549,9 @@ inline void gcode_M140() {
    * M149: Set temperature units
    */
   inline void gcode_M149() {
-    if (code_seen('C')) {
-      set_input_temp_units(TEMPUNIT_C);
-    } else if (code_seen('K')) {
-      set_input_temp_units(TEMPUNIT_K);
-    } else if (code_seen('F')) {
-      set_input_temp_units(TEMPUNIT_F);
-    }
+         if (code_seen('C')) set_input_temp_units(TEMPUNIT_C);
+    else if (code_seen('K')) set_input_temp_units(TEMPUNIT_K);
+    else if (code_seen('F')) set_input_temp_units(TEMPUNIT_F);
   }
 #endif
 
@@ -5201,11 +5669,11 @@ inline void gcode_M92() {
         float value = code_value_per_axis_unit(i);
         if (value < 20.0) {
           float factor = planner.axis_steps_per_mm[i] / value; // increase e constants if M92 E14 is given for netfab.
-          planner.max_e_jerk *= factor;
-          planner.max_feedrate_mm_s[i] *= factor;
-          planner.max_acceleration_steps_per_s2[i] *= factor;
+          planner.max_jerk[E_AXIS] *= factor;
+          planner.max_feedrate_mm_s[E_AXIS] *= factor;
+          planner.max_acceleration_steps_per_s2[E_AXIS] *= factor;
         }
-        planner.axis_steps_per_mm[i] = value;
+        planner.axis_steps_per_mm[E_AXIS] = value;
       }
       else {
         planner.axis_steps_per_mm[i] = code_value_per_axis_unit(i);
@@ -5231,8 +5699,8 @@ static void report_current_position() {
   stepper.report_positions();
 
   #if IS_SCARA
-    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_mm(A_AXIS));
-    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_mm(B_AXIS));
+    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
+    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
     SERIAL_EOL;
   #endif
 }
@@ -5433,7 +5901,8 @@ inline void gcode_M204() {
  *    S = Min Feed Rate (units/s)
  *    T = Min Travel Feed Rate (units/s)
  *    B = Min Segment Time (µs)
- *    X = Max XY Jerk (units/sec^2)
+ *    X = Max X Jerk (units/sec^2)
+ *    Y = Max Y Jerk (units/sec^2)
  *    Z = Max Z Jerk (units/sec^2)
  *    E = Max E Jerk (units/sec^2)
  */
@@ -5441,9 +5910,10 @@ inline void gcode_M205() {
   if (code_seen('S')) planner.min_feedrate_mm_s = code_value_linear_units();
   if (code_seen('T')) planner.min_travel_feedrate_mm_s = code_value_linear_units();
   if (code_seen('B')) planner.min_segment_time = code_value_millis();
-  if (code_seen('X')) planner.max_xy_jerk = code_value_linear_units();
-  if (code_seen('Z')) planner.max_z_jerk = code_value_axis_units(Z_AXIS);
-  if (code_seen('E')) planner.max_e_jerk = code_value_axis_units(E_AXIS);
+  if (code_seen('X')) planner.max_jerk[X_AXIS] = code_value_axis_units(X_AXIS);
+  if (code_seen('Y')) planner.max_jerk[Y_AXIS] = code_value_axis_units(Y_AXIS);
+  if (code_seen('Z')) planner.max_jerk[Z_AXIS] = code_value_axis_units(Z_AXIS);
+  if (code_seen('E')) planner.max_jerk[E_AXIS] = code_value_axis_units(E_AXIS);
 }
 
 /**
@@ -5558,7 +6028,8 @@ inline void gcode_M206() {
 
   /**
    * M209: Enable automatic retract (M209 S1)
-   *       detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
+   *   For slicers that don't support G10/11, reversed extrude-only
+   *   moves will be classified as retraction.
    */
   inline void gcode_M209() {
     if (code_seen('S')) {
@@ -5607,7 +6078,7 @@ inline void gcode_M211() {
    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_EXTRUDER
    */
   inline void gcode_M218() {
-    if (get_target_extruder_from_command(218)) return;
+    if (get_target_extruder_from_command(218) || target_extruder == 0) return;
 
     if (code_seen('X')) hotend_offset[X_AXIS][target_extruder] = code_value_axis_units(X_AXIS);
     if (code_seen('Y')) hotend_offset[Y_AXIS][target_extruder] = code_value_axis_units(Y_AXIS);
@@ -5654,43 +6125,31 @@ inline void gcode_M221() {
  */
 inline void gcode_M226() {
   if (code_seen('P')) {
-    int pin_number = code_value_int();
-    int pin_state = code_seen('S') ? code_value_int() : -1; // required pin state - default is inverted
-
-    if (pin_state >= -1 && pin_state <= 1) {
-
-      for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
-        if (sensitive_pins[i] == pin_number) {
-          pin_number = -1;
-          break;
-        }
-      }
+    int pin_number = code_value_int(),
+        pin_state = code_seen('S') ? code_value_int() : -1; // required pin state - default is inverted
 
-      if (pin_number > -1) {
-        int target = LOW;
+    if (pin_state >= -1 && pin_state <= 1 && pin_number > -1 && !pin_is_protected(pin_number)) {
 
-        stepper.synchronize();
+      int target = LOW;
 
-        pinMode(pin_number, INPUT);
-
-        switch (pin_state) {
-          case 1:
-            target = HIGH;
-            break;
-
-          case 0:
-            target = LOW;
-            break;
+      stepper.synchronize();
 
-          case -1:
-            target = !digitalRead(pin_number);
-            break;
-        }
+      pinMode(pin_number, INPUT);
+      switch (pin_state) {
+        case 1:
+          target = HIGH;
+          break;
+        case 0:
+          target = LOW;
+          break;
+        case -1:
+          target = !digitalRead(pin_number);
+          break;
+      }
 
-        while (digitalRead(pin_number) != target) idle();
+      while (digitalRead(pin_number) != target) idle();
 
-      } // pin_number > -1
-    } // pin_state -1 0 1
+    } // pin_state -1 0 1 && pin_number > -1
   } // code_seen('P')
 }
 
@@ -6111,12 +6570,14 @@ void quickstop_stepper() {
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(MESH_BED_LEVELING)
-
+#if PLANNER_LEVELING
   /**
-   * M420: Enable/Disable Mesh Bed Leveling
+   * M420: Enable/Disable Bed Leveling
    */
-  inline void gcode_M420() { if (code_seen('S')) mbl.set_has_mesh(code_value_bool()); }
+  inline void gcode_M420() { if (code_seen('S')) set_bed_leveling_enabled(code_value_bool()); }
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
 
   /**
    * M421: Set a single Mesh Bed Leveling Z coordinate
@@ -6299,8 +6760,7 @@ inline void gcode_M503() {
 
     // Define runplan for move axes
     #if IS_KINEMATIC
-      #define RUNPLAN(RATE_MM_S) inverse_kinematics(destination); \
-                                 planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], destination[E_AXIS], RATE_MM_S, active_extruder);
+      #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder);
     #else
       #define RUNPLAN(RATE_MM_S) line_to_destination(RATE_MM_S);
     #endif
@@ -6363,25 +6823,25 @@ inline void gcode_M503() {
     delay(100);
 
     #if HAS_BUZZER
-      millis_t next_tick = 0;
+      millis_t next_buzz = 0;
     #endif
 
     // Wait for filament insert by user and press button
     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
 
-    while (!lcd_clicked()) {
+    // LCD click or M108 will clear this
+    wait_for_user = true;
+
+    while (wait_for_user) {
       #if HAS_BUZZER
         millis_t ms = millis();
-        if (ms >= next_tick) {
+        if (ms >= next_buzz) {
           BUZZ(300, 2000);
-          next_tick = ms + 2500; // Beep every 2.5s while waiting
+          next_buzz = ms + 2500; // Beep every 2.5s while waiting
         }
       #endif
       idle(true);
     }
-    delay(100);
-    while (lcd_clicked()) idle(true);
-    delay(100);
 
     // Show load message
     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_LOAD);
@@ -6415,17 +6875,14 @@ inline void gcode_M503() {
     KEEPALIVE_STATE(IN_HANDLER);
 
     // Set extruder to saved position
-    current_position[E_AXIS] = lastpos[E_AXIS];
-    destination[E_AXIS] = lastpos[E_AXIS];
+    destination[E_AXIS] = current_position[E_AXIS] = lastpos[E_AXIS];
     planner.set_e_position_mm(current_position[E_AXIS]);
 
     #if IS_KINEMATIC
-      // Move XYZ to starting position, then E
-      inverse_kinematics(lastpos);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], destination[E_AXIS], FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], lastpos[E_AXIS], FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
+      // Move XYZ to starting position
+      planner.buffer_line_kinematic(lastpos, FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
     #else
-      // Move XY to starting position, then Z, then E
+      // Move XY to starting position, then Z
       destination[X_AXIS] = lastpos[X_AXIS];
       destination[Y_AXIS] = lastpos[Y_AXIS];
       RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
@@ -6515,18 +6972,19 @@ inline void gcode_M503() {
 inline void gcode_M907() {
   #if HAS_DIGIPOTSS
     LOOP_XYZE(i)
-      if (code_seen(axis_codes[i])) stepper.digipot_current(i, code_value_int());
+    if (code_seen(axis_codes[i])) stepper.digipot_current(i, code_value_int());
     if (code_seen('B')) stepper.digipot_current(4, code_value_int());
     if (code_seen('S')) for (int i = 0; i <= 4; i++) stepper.digipot_current(i, code_value_int());
-  #endif
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-    if (code_seen('X')) stepper.digipot_current(0, code_value_int());
-  #endif
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-    if (code_seen('Z')) stepper.digipot_current(1, code_value_int());
-  #endif
-  #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-    if (code_seen('E')) stepper.digipot_current(2, code_value_int());
+  #elif HAS_MOTOR_CURRENT_PWM
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+      if (code_seen('X')) stepper.digipot_current(0, code_value_int());
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+      if (code_seen('Z')) stepper.digipot_current(1, code_value_int());
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+      if (code_seen('E')) stepper.digipot_current(2, code_value_int());
+    #endif
   #endif
   #if ENABLED(DIGIPOT_I2C)
     // this one uses actual amps in floating point
@@ -6807,7 +7265,7 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             }
           #endif
 
-          // No extra case for AUTO_BED_LEVELING_FEATURE in DUAL_X_CARRIAGE. Does that mean they don't work together?
+          // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
         #else // !DUAL_X_CARRIAGE
 
           #if ENABLED(SWITCHING_EXTRUDER)
@@ -6815,15 +7273,11 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
                   z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
 
+            set_destination_to_current();
+
             // Always raise by some amount
-            planner.buffer_line(
-              current_position[X_AXIS],
-              current_position[Y_AXIS],
-              current_position[Z_AXIS] + z_raise,
-              current_position[E_AXIS],
-              planner.max_feedrate_mm_s[Z_AXIS],
-              active_extruder
-            );
+            destination[Z_AXIS] += z_raise;
+            planner.buffer_line_kinematic(destination, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             stepper.synchronize();
 
             move_extruder_servo(active_extruder);
@@ -6831,14 +7285,8 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
             // Move back down, if needed
             if (z_raise != z_diff) {
-              planner.buffer_line(
-                current_position[X_AXIS],
-                current_position[Y_AXIS],
-                current_position[Z_AXIS] + z_diff,
-                current_position[E_AXIS],
-                planner.max_feedrate_mm_s[Z_AXIS],
-                active_extruder
-              );
+              destination[Z_AXIS] = current_position[Z_AXIS] + z_diff;
+              planner.buffer_line_kinematic(destination, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
               stepper.synchronize();
             }
           #endif
@@ -6866,7 +7314,7 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
            * Z software endstop. But this is technically correct (and
            * there is no viable alternative).
            */
-          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+          #if ABL_PLANAR
             // Offset extruder, make sure to apply the bed level rotation matrix
             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
                                                hotend_offset[Y_AXIS][tmp_extruder],
@@ -6894,7 +7342,7 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             float xydiff[2] = { offset_vec.x, offset_vec.y };
             current_position[Z_AXIS] += offset_vec.z;
 
-          #else // !AUTO_BED_LEVELING_LINEAR
+          #else // !ABL_PLANAR
 
             float xydiff[2] = {
               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
@@ -6918,7 +7366,7 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
             #endif // MESH_BED_LEVELING
 
-          #endif // !AUTO_BED_LEVELING_FEATURE
+          #endif // !HAS_ABL
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
@@ -6994,7 +7442,8 @@ inline void gcode_T(uint8_t tmp_extruder) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
       DEBUG_POS("BEFORE", current_position);
     }
   #endif
@@ -7054,6 +7503,11 @@ void process_next_command() {
   // Skip spaces to get the numeric part
   while (*cmd_ptr == ' ') cmd_ptr++;
 
+  // Allow for decimal point in command
+  #if ENABLED(G38_PROBE_TARGET)
+    uint8_t subcode = 0;
+  #endif
+
   uint16_t codenum = 0; // define ahead of goto
 
   // Bail early if there's no code
@@ -7066,6 +7520,15 @@ void process_next_command() {
     cmd_ptr++;
   } while (NUMERIC(*cmd_ptr));
 
+  // Allow for decimal point in command
+  #if ENABLED(G38_PROBE_TARGET)
+    if (*cmd_ptr == '.') {
+      cmd_ptr++;
+      while (NUMERIC(*cmd_ptr))
+        subcode = (subcode * 10) + (*cmd_ptr++ - '0');
+    }
+  #endif
+
   // Skip all spaces to get to the first argument, or nul
   while (*cmd_ptr == ' ') cmd_ptr++;
 
@@ -7141,11 +7604,11 @@ void process_next_command() {
         gcode_G28();
         break;
 
-      #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
+      #if PLANNER_LEVELING
         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points.
           gcode_G29();
           break;
-      #endif // AUTO_BED_LEVELING_FEATURE
+      #endif // PLANNER_LEVELING
 
       #if HAS_BED_PROBE
 
@@ -7166,6 +7629,13 @@ void process_next_command() {
         #endif // Z_PROBE_SLED
       #endif // HAS_BED_PROBE
 
+      #if ENABLED(G38_PROBE_TARGET)
+        case 38: // G38.2 & G38.3
+          if (subcode == 2 || subcode == 3)
+            gcode_G38(subcode == 2);
+          break;
+      #endif
+
       case 90: // G90
         relative_mode = false;
         break;
@@ -7181,90 +7651,87 @@ void process_next_command() {
 
     case 'M': switch (codenum) {
       #if ENABLED(ULTIPANEL) || ENABLED(EMERGENCY_PARSER)
-        case 0: // M0 - Unconditional stop - Wait for user button press on LCD
-        case 1: // M1 - Conditional stop - Wait for user button press on LCD
+        case 0: // M0: Unconditional stop - Wait for user button press on LCD
+        case 1: // M1: Conditional stop - Wait for user button press on LCD
           gcode_M0_M1();
           break;
       #endif // ULTIPANEL
 
-      case 17:
+      case 17: // M17: Enable all stepper motors
         gcode_M17();
         break;
 
       #if ENABLED(SDSUPPORT)
-        case 20: // M20 - list SD card
+        case 20: // M20: list SD card
           gcode_M20(); break;
-        case 21: // M21 - init SD card
+        case 21: // M21: init SD card
           gcode_M21(); break;
-        case 22: //M22 - release SD card
+        case 22: // M22: release SD card
           gcode_M22(); break;
-        case 23: //M23 - Select file
+        case 23: // M23: Select file
           gcode_M23(); break;
-        case 24: //M24 - Start SD print
+        case 24: // M24: Start SD print
           gcode_M24(); break;
-        case 25: //M25 - Pause SD print
+        case 25: // M25: Pause SD print
           gcode_M25(); break;
-        case 26: //M26 - Set SD index
+        case 26: // M26: Set SD index
           gcode_M26(); break;
-        case 27: //M27 - Get SD status
+        case 27: // M27: Get SD status
           gcode_M27(); break;
-        case 28: //M28 - Start SD write
+        case 28: // M28: Start SD write
           gcode_M28(); break;
-        case 29: //M29 - Stop SD write
+        case 29: // M29: Stop SD write
           gcode_M29(); break;
-        case 30: //M30 <filename> Delete File
+        case 30: // M30 <filename> Delete File
           gcode_M30(); break;
-        case 32: //M32 - Select file and start SD print
+        case 32: // M32: Select file and start SD print
           gcode_M32(); break;
 
         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
-          case 33: //M33 - Get the long full path to a file or folder
+          case 33: // M33: Get the long full path to a file or folder
             gcode_M33(); break;
-        #endif // LONG_FILENAME_HOST_SUPPORT
+        #endif
 
-        case 928: //M928 - Start SD write
+        case 928: // M928: Start SD write
           gcode_M928(); break;
       #endif //SDSUPPORT
 
-      case 31: //M31 take time since the start of the SD print or an M109 command
-        gcode_M31();
-        break;
+      case 31: // M31: Report time since the start of SD print or last M109
+        gcode_M31(); break;
 
-      case 42: //M42 -Change pin status via gcode
-        gcode_M42();
-        break;
+      case 42: // M42: Change pin state
+        gcode_M42(); break;
+
+      #if ENABLED(PINS_DEBUGGING)
+        case 43: // M43: Read pin state
+          gcode_M43(); break;
+      #endif
 
       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
-        case 48: // M48 Z probe repeatability
+        case 48: // M48: Z probe repeatability test
           gcode_M48();
           break;
       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
 
-      case 75: // Start print timer
-        gcode_M75();
-        break;
-
-      case 76: // Pause print timer
-        gcode_M76();
-        break;
-
-      case 77: // Stop print timer
-        gcode_M77();
-        break;
+      case 75: // M75: Start print timer
+        gcode_M75(); break;
+      case 76: // M76: Pause print timer
+        gcode_M76(); break;
+      case 77: // M77: Stop print timer
+        gcode_M77(); break;
 
       #if ENABLED(PRINTCOUNTER)
-        case 78: // Show print statistics
-          gcode_M78();
-          break;
+        case 78: // M78: Show print statistics
+          gcode_M78(); break;
       #endif
 
       #if ENABLED(M100_FREE_MEMORY_WATCHER)
-        case 100:
+        case 100: // M100: Free Memory Report
           gcode_M100();
           break;
       #endif
 
-      case 104: // M104
+      case 104: // M104: Set hot end temperature
         gcode_M104();
         break;
 
@@ -7298,21 +7765,21 @@ void process_next_command() {
           break;
       #endif
 
-      case 140: // M140: Set bed temp
+      case 140: // M140: Set bed temperature
         gcode_M140();
         break;
 
-      case 105: // M105: Read current temperature
+      case 105: // M105: Report current temperature
         gcode_M105();
         KEEPALIVE_STATE(NOT_BUSY);
         return; // "ok" already printed
 
-      case 109: // M109: Wait for temperature
+      case 109: // M109: Wait for hotend temperature to reach target
         gcode_M109();
         break;
 
       #if HAS_TEMP_BED
-        case 190: // M190: Wait for bed heater to reach target
+        case 190: // M190: Wait for bed temperature to reach target
           gcode_M190();
           break;
       #endif // HAS_TEMP_BED
@@ -7360,17 +7827,17 @@ void process_next_command() {
         gcode_M81();
         break;
 
-      case 82:
+      case 82: // M83: Set E axis normal mode (same as other axes)
         gcode_M82();
         break;
-      case 83:
+      case 83: // M83: Set E axis relative mode
         gcode_M83();
         break;
-      case 18: // (for compatibility)
-      case 84: // M84
+      case 18: // M18 => M84
+      case 84: // M84: Disable all steppers or set timeout
         gcode_M18_M84();
         break;
-      case 85: // M85
+      case 85: // M85: Set inactivity stepper shutdown timeout
         gcode_M85();
         break;
       case 92: // M92: Set the steps-per-unit for one or more axes
@@ -7404,51 +7871,51 @@ void process_next_command() {
       #endif
 
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        case 149:
+        case 149: // M149: Set temperature units
           gcode_M149();
           break;
       #endif
 
       #if ENABLED(BLINKM)
 
-        case 150: // M150
+        case 150: // M150: Set the BlinkM LCD color
           gcode_M150();
           break;
 
-      #endif //BLINKM
+      #endif // BLINKM
 
       #if ENABLED(EXPERIMENTAL_I2CBUS)
 
-        case 155:
+        case 155: // M155: Send data to an i2c slave
           gcode_M155();
           break;
 
-        case 156:
+        case 156: // M156: Request data from an i2c slave
           gcode_M156();
           break;
 
       #endif //EXPERIMENTAL_I2CBUS
 
       #if ENABLED(MIXING_EXTRUDER)
-        case 163: // M163 S<int> P<float> set weight for a mixing extruder
+        case 163: // M163: Set a component weight for mixing extruder
           gcode_M163();
           break;
         #if MIXING_VIRTUAL_TOOLS > 1
-          case 164: // M164 S<int> save current mix as a virtual extruder
+          case 164: // M164: Save current mix as a virtual extruder
             gcode_M164();
             break;
         #endif
         #if ENABLED(DIRECT_MIXING_IN_G1)
-          case 165: // M165 [ABCDHI]<float> set multiple mix weights
+          case 165: // M165: Set multiple mix weights
             gcode_M165();
             break;
         #endif
       #endif
 
-      case 200: // M200 D<diameter> Set filament diameter and set E axis units to cubic. (Use S0 to revert to linear units.)
+      case 200: // M200: Set filament diameter, E to cubic units
         gcode_M200();
         break;
-      case 201: // M201
+      case 201: // M201: Set max acceleration for print moves (units/s^2)
         gcode_M201();
         break;
       #if 0 // Not used for Sprinter/grbl gen6
@@ -7456,180 +7923,183 @@ void process_next_command() {
           gcode_M202();
           break;
       #endif
-      case 203: // M203 max feedrate units/sec
+      case 203: // M203: Set max feedrate (units/sec)
         gcode_M203();
         break;
-      case 204: // M204 acclereration S normal moves T filmanent only moves
+      case 204: // M204: Set acceleration
         gcode_M204();
         break;
-      case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
+      case 205: //M205: Set advanced settings
         gcode_M205();
         break;
-      case 206: // M206 additional homing offset
+      case 206: // M206: Set home offsets
         gcode_M206();
         break;
 
       #if ENABLED(DELTA)
-        case 665: // M665 set delta configurations L<diagonal_rod> R<delta_radius> S<segments_per_sec>
+        case 665: // M665: Set delta configurations
           gcode_M665();
           break;
       #endif
 
       #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
-        case 666: // M666 set delta / dual endstop adjustment
+        case 666: // M666: Set delta or dual endstop adjustment
           gcode_M666();
           break;
       #endif
 
       #if ENABLED(FWRETRACT)
-        case 207: // M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>
+        case 207: // M207: Set Retract Length, Feedrate, and Z lift
           gcode_M207();
           break;
-        case 208: // M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>
+        case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
           gcode_M208();
           break;
-        case 209: // M209 - Turn Automatic Retract Detection on/off: S<bool> (For slicers that don't support G10/11). Every normal extrude-only move will be classified as retract depending on the direction.
+        case 209: // M209: Turn Automatic Retract Detection on/off
           gcode_M209();
           break;
       #endif // FWRETRACT
 
-      case 211: // M211 - Enable, Disable, and/or Report software endstops
+      case 211: // M211: Enable, Disable, and/or Report software endstops
         gcode_M211();
         break;
 
       #if HOTENDS > 1
-        case 218: // M218 - Set a tool offset: T<index> X<offset> Y<offset>
+        case 218: // M218: Set a tool offset
           gcode_M218();
           break;
       #endif
 
-      case 220: // M220 - Set Feedrate Percentage: S<percent> ("FR" on your LCD)
+      case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
         gcode_M220();
         break;
 
-      case 221: // M221 - Set Flow Percentage: S<percent>
+      case 221: // M221: Set Flow Percentage
         gcode_M221();
         break;
 
-      case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
+      case 226: // M226: Wait until a pin reaches a state
         gcode_M226();
         break;
 
       #if HAS_SERVOS
-        case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
+        case 280: // M280: Set servo position absolute
           gcode_M280();
           break;
       #endif // HAS_SERVOS
 
       #if HAS_BUZZER
-        case 300: // M300 - Play beep tone
+        case 300: // M300: Play beep tone
           gcode_M300();
           break;
       #endif // HAS_BUZZER
 
       #if ENABLED(PIDTEMP)
-        case 301: // M301
+        case 301: // M301: Set hotend PID parameters
           gcode_M301();
           break;
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
-        case 304: // M304
+        case 304: // M304: Set bed PID parameters
           gcode_M304();
           break;
       #endif // PIDTEMPBED
 
       #if defined(CHDK) || HAS_PHOTOGRAPH
-        case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
+        case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
           gcode_M240();
           break;
       #endif // CHDK || PHOTOGRAPH_PIN
 
       #if HAS_LCD_CONTRAST
-        case 250: // M250  Set LCD contrast value: C<value> (value 0..63)
+        case 250: // M250: Set LCD contrast
           gcode_M250();
           break;
       #endif // HAS_LCD_CONTRAST
 
       #if ENABLED(PREVENT_COLD_EXTRUSION)
-        case 302: // allow cold extrudes, or set the minimum extrude temperature
+        case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
           gcode_M302();
           break;
       #endif // PREVENT_COLD_EXTRUSION
 
-      case 303: // M303 PID autotune
+      case 303: // M303: PID autotune
         gcode_M303();
         break;
 
       #if ENABLED(MORGAN_SCARA)
-        case 360:  // M360 SCARA Theta pos1
+        case 360:  // M360: SCARA Theta pos1
           if (gcode_M360()) return;
           break;
-        case 361:  // M361 SCARA Theta pos2
+        case 361:  // M361: SCARA Theta pos2
           if (gcode_M361()) return;
           break;
-        case 362:  // M362 SCARA Psi pos1
+        case 362:  // M362: SCARA Psi pos1
           if (gcode_M362()) return;
           break;
-        case 363:  // M363 SCARA Psi pos2
+        case 363:  // M363: SCARA Psi pos2
           if (gcode_M363()) return;
           break;
-        case 364:  // M364 SCARA Psi pos3 (90 deg to Theta)
+        case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
           if (gcode_M364()) return;
           break;
       #endif // SCARA
 
-      case 400: // M400 finish all moves
+      case 400: // M400: Finish all moves
         gcode_M400();
         break;
 
       #if HAS_BED_PROBE
-        case 401:
+        case 401: // M401: Deploy probe
           gcode_M401();
           break;
-        case 402:
+        case 402: // M402: Stow probe
           gcode_M402();
           break;
       #endif // HAS_BED_PROBE
 
       #if ENABLED(FILAMENT_WIDTH_SENSOR)
-        case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
+        case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
           gcode_M404();
           break;
-        case 405:  //M405 Turn on filament sensor for control
+        case 405:  // M405: Turn on filament sensor for control
           gcode_M405();
           break;
-        case 406:  //M406 Turn off filament sensor for control
+        case 406:  // M406: Turn off filament sensor for control
           gcode_M406();
           break;
-        case 407:   //M407 Display measured filament diameter
+        case 407:   // M407: Display measured filament diameter
           gcode_M407();
           break;
       #endif // ENABLED(FILAMENT_WIDTH_SENSOR)
 
-      #if ENABLED(MESH_BED_LEVELING)
-        case 420: // M420 Enable/Disable Mesh Bed Leveling
+      #if PLANNER_LEVELING
+        case 420: // M420: Enable/Disable Bed Leveling
           gcode_M420();
           break;
-        case 421: // M421 Set a Mesh Bed Leveling Z coordinate
+      #endif
+
+      #if ENABLED(MESH_BED_LEVELING)
+        case 421: // M421: Set a Mesh Bed Leveling Z coordinate
           gcode_M421();
           break;
       #endif
 
-      case 428: // M428 Apply current_position to home_offset
+      case 428: // M428: Apply current_position to home_offset
         gcode_M428();
         break;
 
-      case 500: // M500 Store settings in EEPROM
+      case 500: // M500: Store settings in EEPROM
         gcode_M500();
         break;
-      case 501: // M501 Read settings from EEPROM
+      case 501: // M501: Read settings from EEPROM
         gcode_M501();
         break;
-      case 502: // M502 Revert to default settings
+      case 502: // M502: Revert to default settings
         gcode_M502();
         break;
-      case 503: // M503 print settings currently in memory
+      case 503: // M503: print settings currently in memory
         gcode_M503();
         break;
 
@@ -7640,46 +8110,46 @@ void process_next_command() {
       #endif
 
       #if HAS_BED_PROBE
-        case 851: // Set Z Probe Z Offset
+        case 851: // M851: Set Z Probe Z Offset
           gcode_M851();
           break;
       #endif // HAS_BED_PROBE
 
       #if ENABLED(FILAMENT_CHANGE_FEATURE)
-        case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
+        case 600: // M600: Pause for filament change
           gcode_M600();
           break;
       #endif // FILAMENT_CHANGE_FEATURE
 
       #if ENABLED(DUAL_X_CARRIAGE)
-        case 605:
+        case 605: // M605: Set Dual X Carriage movement mode
           gcode_M605();
           break;
       #endif // DUAL_X_CARRIAGE
 
       #if ENABLED(LIN_ADVANCE)
-        case 905: // M905 Set advance factor.
+        case 905: // M905: Set advance K factor.
           gcode_M905();
           break;
       #endif
 
-      case 907: // M907 Set digital trimpot motor current using axis codes.
+      case 907: // M907: Set digital trimpot motor current using axis codes.
         gcode_M907();
         break;
 
       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
 
-        case 908: // M908 Control digital trimpot directly.
+        case 908: // M908: Control digital trimpot directly.
           gcode_M908();
           break;
 
         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
 
-          case 909: // M909 Print digipot/DAC current value
+          case 909: // M909: Print digipot/DAC current value
             gcode_M909();
             break;
 
-          case 910: // M910 Commit digipot/DAC value to external EEPROM
+          case 910: // M910: Commit digipot/DAC value to external EEPROM
             gcode_M910();
             break;
 
@@ -7689,11 +8159,11 @@ void process_next_command() {
 
       #if HAS_MICROSTEPS
 
-        case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+        case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
           gcode_M350();
           break;
 
-        case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
+        case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
           gcode_M351();
           break;
 
@@ -7781,46 +8251,69 @@ void ok_to_send() {
 
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
   // Get the Z adjustment for non-linear bed leveling
-  float nonlinear_z_offset(float cartesian[XYZ]) {
-
-    int half_x = (ABL_GRID_POINTS_X - 1) / 2,
-        half_y = (ABL_GRID_POINTS_Y - 1) / 2;
-    float hx2 = half_x - 0.001, hx1 = -hx2,
-          hy2 = half_y - 0.001, hy1 = -hy2,
-          grid_x = max(hx1, min(hx2, RAW_X_POSITION(cartesian[X_AXIS]) / nonlinear_grid_spacing[X_AXIS])),
-          grid_y = max(hy1, min(hy2, RAW_Y_POSITION(cartesian[Y_AXIS]) / nonlinear_grid_spacing[Y_AXIS]));
-    int   floor_x = floor(grid_x), floor_y = floor(grid_y);
-    float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
-          z1 = bed_level_grid[floor_x + half_x][floor_y + half_y],
-          z2 = bed_level_grid[floor_x + half_x][floor_y + half_y + 1],
-          z3 = bed_level_grid[floor_x + half_x + 1][floor_y + half_y],
-          z4 = bed_level_grid[floor_x + half_x + 1][floor_y + half_y + 1],
-          left = (1 - ratio_y) * z1 + ratio_y * z2,
-          right = (1 - ratio_y) * z3 + ratio_y * z4;
+  float bilinear_z_offset(float cartesian[XYZ]) {
+
+    // XY relative to the probed area
+    const float x = RAW_X_POSITION(cartesian[X_AXIS]) - bilinear_start[X_AXIS],
+                y = RAW_Y_POSITION(cartesian[Y_AXIS]) - bilinear_start[Y_AXIS];
+
+    // Convert to grid box units
+    float ratio_x = x / bilinear_grid_spacing[X_AXIS],
+          ratio_y = y / bilinear_grid_spacing[Y_AXIS];
+
+    // Whole units for the grid line indices. Constrained within bounds.
+    const int gridx = constrain(floor(ratio_x), 0, ABL_GRID_POINTS_X - 1),
+              gridy = constrain(floor(ratio_y), 0, ABL_GRID_POINTS_Y - 1),
+              nextx = min(gridx + 1, ABL_GRID_POINTS_X - 1),
+              nexty = min(gridy + 1, ABL_GRID_POINTS_Y - 1);
+
+    // Subtract whole to get the ratio within the grid box
+    ratio_x -= gridx; ratio_y -= gridy;
+
+    // Never less than 0.0. (Over 1.0 is fine due to previous contraints.)
+    NOLESS(ratio_x, 0); NOLESS(ratio_y, 0);
+
+    // Z at the box corners
+    const float z1 = bed_level_grid[gridx][gridy],  // left-front
+                z2 = bed_level_grid[gridx][nexty],  // left-back
+                z3 = bed_level_grid[nextx][gridy],  // right-front
+                z4 = bed_level_grid[nextx][nexty],  // right-back
+
+                // Bilinear interpolate
+                L = z1 + (z2 - z1) * ratio_y,   // Linear interp. LF -> LB
+                R = z3 + (z4 - z3) * ratio_y,   // Linear interp. RF -> RB
+                offset = L + ratio_x * (R - L);
 
     /*
-      SERIAL_ECHOPAIR("grid_x=", grid_x);
-      SERIAL_ECHOPAIR(" grid_y=", grid_y);
-      SERIAL_ECHOPAIR(" floor_x=", floor_x);
-      SERIAL_ECHOPAIR(" floor_y=", floor_y);
+    static float last_offset = 0;
+    if (fabs(last_offset - offset) > 0.2) {
+      SERIAL_ECHOPGM("Sudden Shift at ");
+      SERIAL_ECHOPAIR("x=", x);
+      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
+      SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
+      SERIAL_ECHOPAIR(" y=", y);
+      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
+      SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
-      SERIAL_ECHOPAIR(" ratio_y=", ratio_y);
+      SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
       SERIAL_ECHOPAIR(" z1=", z1);
       SERIAL_ECHOPAIR(" z2=", z2);
       SERIAL_ECHOPAIR(" z3=", z3);
-      SERIAL_ECHOPAIR(" z4=", z4);
-      SERIAL_ECHOPAIR(" left=", left);
-      SERIAL_ECHOPAIR(" right=", right);
-      SERIAL_ECHOPAIR(" offset=", (1 - ratio_x) * left + ratio_x * right);
+      SERIAL_ECHOLNPAIR(" z4=", z4);
+      SERIAL_ECHOPAIR(" L=", L);
+      SERIAL_ECHOPAIR(" R=", R);
+      SERIAL_ECHOLNPAIR(" offset=", offset);
+    }
+    last_offset = offset;
     //*/
 
-    return (1 - ratio_x) * left + ratio_x * right;
+    return offset;
   }
 
-#endif // AUTO_BED_LEVELING_NONLINEAR
+#endif // AUTO_BED_LEVELING_BILINEAR
 
 #if ENABLED(DELTA)
 
@@ -8014,7 +8507,7 @@ void ok_to_send() {
     cartes[X_AXIS] = delta_tower1_x + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
     cartes[Y_AXIS] = delta_tower1_y + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
-  };
+  }
 
   void forward_kinematics_DELTA(float point[ABC]) {
     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
@@ -8150,8 +8643,7 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 
     // If the move is only in Z/E don't split up the move
     if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
-      inverse_kinematics(ltarget);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], ltarget[E_AXIS], _feedrate_mm_s, active_extruder);
+      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
       return true;
     }
 
@@ -8244,7 +8736,10 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
       #define DELTA_NEXT(ADDEND) LOOP_XYZ(i) DELTA_VAR[i] += ADDEND;
 
       // Get the starting delta if interpolation is possible
-      if (segments >= 2) DELTA_IK();
+      if (segments >= 2) {
+        DELTA_IK();
+        ADJUST_DELTA(DELTA_VAR); // Adjust Z if bed leveling is enabled
+      }
 
       // Loop using decrement
       for (uint16_t s = segments + 1; --s;) {
@@ -8261,6 +8756,7 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 
           // Get the exact delta for the move after this
           DELTA_IK();
+          ADJUST_DELTA(DELTA_VAR); // Adjust Z if bed leveling is enabled
 
           // Move to the interpolated delta position first
           planner.buffer_line(
@@ -8281,6 +8777,7 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
           DELTA_NEXT(segment_distance[i]);
           DELTA_VAR[E_AXIS] += segment_distance[E_AXIS];
           DELTA_IK();
+          ADJUST_DELTA(DELTA_VAR); // Adjust Z if bed leveling is enabled
         }
 
         // Move to the non-interpolated position
@@ -8294,16 +8791,14 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
       // For non-interpolated delta calculate every segment
       for (uint16_t s = segments + 1; --s;) {
         DELTA_NEXT(segment_distance[i]);
-        DELTA_IK();
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], DELTA_VAR[E_AXIS], _feedrate_mm_s, active_extruder);
+        planner.buffer_line_kinematic(DELTA_VAR, _feedrate_mm_s, active_extruder);
       }
 
     #endif
 
     // Since segment_distance is only approximate,
     // the final move must be to the exact destination.
-    inverse_kinematics(ltarget);
-    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], ltarget[E_AXIS], _feedrate_mm_s, active_extruder);
+    planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
     return true;
   }
 
@@ -8460,18 +8955,15 @@ void prepare_move_to_destination() {
 
     float mm_of_travel = HYPOT(angular_travel * radius, fabs(linear_travel));
     if (mm_of_travel < 0.001) return;
+
     uint16_t segments = floor(mm_of_travel / (MM_PER_ARC_SEGMENT));
     if (segments == 0) segments = 1;
 
-    float theta_per_segment = angular_travel / segments;
-    float linear_per_segment = linear_travel / segments;
-    float extruder_per_segment = extruder_travel / segments;
-
     /**
      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
      *     r_T = [cos(phi) -sin(phi);
-     *            sin(phi)  cos(phi] * r ;
+     *            sin(phi)  cos(phi)] * r ;
      *
      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
      * defined from the circle center to the initial position. Each line segment is formed by successive
@@ -8494,13 +8986,12 @@ void prepare_move_to_destination() {
      * This is important when there are successive arc motions.
      */
     // Vector rotation matrix values
-    float cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
-    float sin_T = theta_per_segment;
-
-    float arc_target[NUM_AXIS];
-    float sin_Ti, cos_Ti, r_new_Y;
-    uint16_t i;
-    int8_t count = 0;
+    float arc_target[XYZE],
+          theta_per_segment = angular_travel / segments,
+          linear_per_segment = linear_travel / segments,
+          extruder_per_segment = extruder_travel / segments,
+          sin_T = theta_per_segment,
+          cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
 
     // Initialize the linear axis
     arc_target[Z_AXIS] = current_position[Z_AXIS];
@@ -8512,18 +9003,18 @@ void prepare_move_to_destination() {
 
     millis_t next_idle_ms = millis() + 200UL;
 
-    for (i = 1; i < segments; i++) { // Iterate (segments-1) times
+    int8_t count = 0;
+    for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
       thermalManager.manage_heater();
-      millis_t now = millis();
-      if (ELAPSED(now, next_idle_ms)) {
-        next_idle_ms = now + 200UL;
+      if (ELAPSED(millis(), next_idle_ms)) {
+        next_idle_ms = millis() + 200UL;
         idle();
       }
 
       if (++count < N_ARC_CORRECTION) {
         // Apply vector rotation matrix to previous r_X / 1
-        r_new_Y = r_X * sin_T + r_Y * cos_T;
+        float r_new_Y = r_X * sin_T + r_Y * cos_T;
         r_X = r_X * cos_T - r_Y * sin_T;
         r_Y = r_new_Y;
       }
@@ -8532,8 +9023,8 @@ void prepare_move_to_destination() {
         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
         // To reduce stuttering, the sin and cos could be computed at different times.
         // For now, compute both at the same time.
-        cos_Ti = cos(i * theta_per_segment);
-        sin_Ti = sin(i * theta_per_segment);
+        float cos_Ti = cos(i * theta_per_segment),
+              sin_Ti = sin(i * theta_per_segment);
         r_X = -offset[X_AXIS] * cos_Ti + offset[Y_AXIS] * sin_Ti;
         r_Y = -offset[X_AXIS] * sin_Ti - offset[Y_AXIS] * cos_Ti;
         count = 0;
@@ -8547,21 +9038,11 @@ void prepare_move_to_destination() {
 
       clamp_to_software_endstops(arc_target);
 
-      #if IS_KINEMATIC
-        inverse_kinematics(arc_target);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], arc_target[E_AXIS], fr_mm_s, active_extruder);
-      #else
-        planner.buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], fr_mm_s, active_extruder);
-      #endif
+      planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
     }
 
     // Ensure last segment arrives at target location.
-    #if IS_KINEMATIC
-      inverse_kinematics(logical);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], fr_mm_s, active_extruder);
-    #else
-      planner.buffer_line(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS], logical[E_AXIS], fr_mm_s, active_extruder);
-    #endif
+    planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
 
     // As far as the parser is concerned, the position is now == target. In reality the
     // motion control system might still be processing the action and the real tool position
@@ -8653,7 +9134,7 @@ void prepare_move_to_destination() {
    * Morgan SCARA Inverse Kinematics. Results in delta[].
    *
    * See http://forums.reprap.org/read.php?185,283327
-   * 
+   *
    * Maths and first version by QHARLEY.
    * Integrated into Marlin and slightly restructured by Joachim Cerny.
    */
@@ -8719,8 +9200,14 @@ void prepare_move_to_destination() {
       bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
       if (new_led != red_led) {
         red_led = new_led;
-        digitalWrite(STAT_LED_RED, new_led ? HIGH : LOW);
-        digitalWrite(STAT_LED_BLUE, new_led ? LOW : HIGH);
+        #if PIN_EXISTS(STAT_LED_RED)
+          WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
+          #if PIN_EXISTS(STAT_LED_BLUE)
+            WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
+          #endif
+        #else
+          WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
+        #endif
       }
     }
   }
@@ -8803,8 +9290,7 @@ void prepare_move_to_destination() {
 
 float calculate_volumetric_multiplier(float diameter) {
   if (!volumetric_enabled || diameter == 0) return 1.0;
-  float d2 = diameter * 0.5;
-  return 1.0 / (M_PI * d2 * d2);
+  return 1.0 / (M_PI * diameter * 0.5 * diameter * 0.5);
 }
 
 void calculate_volumetric_multipliers() {
@@ -8957,11 +9443,22 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       #endif // !SWITCHING_EXTRUDER
 
       previous_cmd_ms = ms; // refresh_cmd_timeout()
-      planner.buffer_line(
-        current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
-        current_position[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE,
-        MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder
-      );
+
+      #if IS_KINEMATIC
+        inverse_kinematics(current_position);
+        ADJUST_DELTA(current_position);
+        planner.buffer_line(
+          delta[A_AXIS], delta[B_AXIS], delta[C_AXIS],
+          current_position[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE,
+          MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder
+        );
+      #else
+        planner.buffer_line(
+          current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
+          current_position[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE,
+          MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder
+        );
+      #endif
       stepper.synchronize();
       planner.set_e_position_mm(current_position[E_AXIS]);
       #if ENABLED(SWITCHING_EXTRUDER)
@@ -9030,7 +9527,7 @@ void idle(
     print_job_timer.tick();
   #endif
 
-  #if HAS_BUZZER && PIN_EXISTS(BEEPER)
+  #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
     buzzer.tick();
   #endif
 }
@@ -9194,20 +9691,17 @@ void setup() {
   #endif
 
   #if ENABLED(Z_PROBE_SLED) && PIN_EXISTS(SLED)
-    pinMode(SLED_PIN, OUTPUT);
-    digitalWrite(SLED_PIN, LOW); // turn it off
+    OUT_WRITE(SLED_PIN, LOW); // turn it off
   #endif // Z_PROBE_SLED
 
   setup_homepin();
 
-  #ifdef STAT_LED_RED
-    pinMode(STAT_LED_RED, OUTPUT);
-    digitalWrite(STAT_LED_RED, LOW); // turn it off
+  #if PIN_EXISTS(STAT_LED_RED)
+    OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
   #endif
 
-  #ifdef STAT_LED_BLUE
-    pinMode(STAT_LED_BLUE, OUTPUT);
-    digitalWrite(STAT_LED_BLUE, LOW); // turn it off
+  #if PIN_EXISTS(STAT_LED_BLUE)
+    OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
   #endif
 
   lcd_init();
@@ -9216,7 +9710,9 @@ void setup() {
       safe_delay(BOOTSCREEN_TIMEOUT);
     #elif ENABLED(ULTRA_LCD)
       bootscreen();
-      lcd_init();
+      #if DISABLED(SDSUPPORT)
+        lcd_init();
+      #endif
     #endif
   #endif
 
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 7c2526b..3cd9ade 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -30,8 +30,8 @@
  * Due to the high number of issues related with old versions of Arduino IDE
  * we now prevent Marlin from compiling with older toolkits.
  */
-#if !defined(ARDUINO) || ARDUINO < 10600
-  #error "Versions of Arduino IDE prior to 1.6.0 are no longer supported, please update your toolkit."
+#if !defined(ARDUINO) || ARDUINO < 10608
+  #error "Versions of Arduino IDE prior to 1.6.8 are no longer supported, please update your toolkit."
 #endif
 
 /**
@@ -61,10 +61,6 @@
   #error "Z_LATE_ENABLE can't be used with COREXZ."
 #elif defined(X_HOME_RETRACT_MM)
   #error "[XYZ]_HOME_RETRACT_MM settings have been renamed [XYZ]_HOME_BUMP_MM."
-#elif defined(BEEPER)
-  #error "BEEPER is now BEEPER_PIN. Please update your pins definitions."
-#elif defined(SDCARDDETECT)
-  #error "SDCARDDETECT is now SD_DETECT_PIN. Please update your pins definitions."
 #elif defined(SDCARDDETECTINVERTED)
   #error "SDCARDDETECTINVERTED is now SD_DETECT_INVERTED. Please update your configuration."
 #elif defined(BTENABLED)
@@ -73,8 +69,6 @@
   #error "CUSTOM_MENDEL_NAME is now CUSTOM_MACHINE_NAME. Please update your configuration."
 #elif defined(HAS_AUTOMATIC_VERSIONING)
   #error "HAS_AUTOMATIC_VERSIONING is now USE_AUTOMATIC_VERSIONING. Please update your configuration."
-#elif defined(ENABLE_AUTO_BED_LEVELING)
-  #error "ENABLE_AUTO_BED_LEVELING is now AUTO_BED_LEVELING_FEATURE. Please update your configuration."
 #elif defined(SDSLOW)
   #error "SDSLOW deprecated. Set SPI_SPEED to SPI_HALF_SPEED instead."
 #elif defined(SDEXTRASLOW)
@@ -97,6 +91,8 @@
   #error "SERVO_ENDSTOP_ANGLES is deprecated. Use Z_SERVO_ANGLES instead."
 #elif defined(X_ENDSTOP_SERVO_NR) || defined(Y_ENDSTOP_SERVO_NR)
   #error "X_ENDSTOP_SERVO_NR and Y_ENDSTOP_SERVO_NR are deprecated and should be removed."
+#elif defined(DEFAULT_XYJERK)
+  #error "DEFAULT_XYJERK is deprecated. Use DEFAULT_XJERK and DEFAULT_YJERK instead."
 #elif defined(XY_TRAVEL_SPEED)
   #error "XY_TRAVEL_SPEED is deprecated. Use XY_PROBE_SPEED instead."
 #elif defined(PROBE_SERVO_DEACTIVATION_DELAY)
@@ -141,8 +137,24 @@
   #error "PREVENT_DANGEROUS_EXTRUDE is now PREVENT_COLD_EXTRUSION. Please update your configuration."
 #elif defined(SCARA)
   #error "SCARA is now MORGAN_SCARA. Please update your configuration."
-#elif defined(AUTO_BED_LEVELING_GRID_POINTS)
-  #error "AUTO_BED_LEVELING_GRID_POINTS is now ABL_GRID_POINTS_X and ABL_GRID_POINTS_Y. Please update your configuration."
+#elif defined(ENABLE_AUTO_BED_LEVELING)
+  #error "ENABLE_AUTO_BED_LEVELING is deprecated. Specify AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_BILINEAR, or AUTO_BED_LEVELING_3POINT."
+#elif defined(AUTO_BED_LEVELING_FEATURE)
+  #error "AUTO_BED_LEVELING_FEATURE is deprecated. Specify AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_BILINEAR, or AUTO_BED_LEVELING_3POINT."
+#elif defined(ABL_GRID_POINTS)
+  #error "ABL_GRID_POINTS is now ABL_GRID_POINTS_X and ABL_GRID_POINTS_Y. Please update your configuration."
+#elif defined(BEEPER)
+  #error "BEEPER is now BEEPER_PIN. Please update your pins definitions."
+#elif defined(SDCARDDETECT)
+  #error "SDCARDDETECT is now SD_DETECT_PIN. Please update your pins definitions."
+#elif defined(STAT_LED_RED) || defined(STAT_LED_BLUE)
+  #error "STAT_LED_RED/STAT_LED_BLUE are now STAT_LED_RED_PIN/STAT_LED_BLUE_PIN. Please update your pins definitions."
+#elif defined(LCD_PIN_BL)
+  #error "LCD_PIN_BL is now LCD_BACKLIGHT_PIN. Please update your pins definitions."
+#elif defined(LCD_PIN_RESET)
+  #error "LCD_PIN_RESET is now LCD_RESET_PIN. Please update your pins definitions."
+#elif defined(EXTRUDER_0_AUTO_FAN_PIN) || defined(EXTRUDER_1_AUTO_FAN_PIN) || defined(EXTRUDER_2_AUTO_FAN_PIN) || defined(EXTRUDER_3_AUTO_FAN_PIN)
+  #error "EXTRUDER_[0123]_AUTO_FAN_PIN is now E[0123]_AUTO_FAN_PIN. Please update your Configuration_adv.h."
 #endif
 
 /**
@@ -199,7 +211,7 @@
   #if DISABLED(USE_XMAX_PLUG) && DISABLED(USE_YMAX_PLUG) && DISABLED(USE_ZMAX_PLUG)
     #error "You probably want to use Max Endstops for DELTA!"
   #endif
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  #if ABL_GRID
     #if (ABL_GRID_POINTS_X & 1) == 0 || (ABL_GRID_POINTS_Y & 1) == 0
       #error "DELTA requires ABL_GRID_POINTS_X and ABL_GRID_POINTS_Y to be odd numbers."
     #elif ABL_GRID_POINTS_X < 3
@@ -334,28 +346,55 @@
 #endif
 
 /**
+ * Allow only one bed leveling option to be defined
+ */
+#if HAS_ABL
+  #define COUNT_LEV_1 0
+  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #define COUNT_LEV_2 INCREMENT(COUNT_LEV_1)
+  #else
+    #define COUNT_LEV_2 COUNT_LEV_1
+  #endif
+  #if ENABLED(AUTO_BED_LEVELING_3POINT)
+    #define COUNT_LEV_3 INCREMENT(COUNT_LEV_2)
+  #else
+    #define COUNT_LEV_3 COUNT_LEV_2
+  #endif
+  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    #define COUNT_LEV_4 INCREMENT(COUNT_LEV_3)
+  #else
+    #define COUNT_LEV_4 COUNT_LEV_3
+  #endif
+  #if ENABLED(MESH_BED_LEVELING)
+    #define COUNT_LEV_5 INCREMENT(COUNT_LEV_4)
+  #else
+    #define COUNT_LEV_5 COUNT_LEV_4
+  #endif
+  #if COUNT_LEV_5 > 1
+    #error "Select only one of: MESH_BED_LEVELING, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT, or AUTO_BED_LEVELING_BILINEAR."
+  #endif
+#endif
+
+/**
  * Mesh Bed Leveling
  */
 #if ENABLED(MESH_BED_LEVELING)
   #if ENABLED(DELTA)
     #error "MESH_BED_LEVELING does not yet support DELTA printers."
-  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
-    #error "Select AUTO_BED_LEVELING_FEATURE or MESH_BED_LEVELING, not both."
   #elif MESH_NUM_X_POINTS > 9 || MESH_NUM_Y_POINTS > 9
     #error "MESH_NUM_X_POINTS and MESH_NUM_Y_POINTS must be less than 10."
   #endif
 #elif ENABLED(MANUAL_BED_LEVELING)
-  #error "MESH_BED_LEVELING is required for MANUAL_BED_LEVELING."
+  #error "MANUAL_BED_LEVELING only applies to MESH_BED_LEVELING."
 #endif
 
 /**
  * Probes
  */
-
 #if PROBE_SELECTED
 
   /**
-   * Only allow one probe option to be defined
+   * Allow only one probe option to be defined
    */
   #define COUNT_PROBE_1 0
   #if ENABLED(FIX_MOUNTED_PROBE)
@@ -442,8 +481,8 @@
   /**
    * Require some kind of probe for bed leveling and probe testing
    */
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    #error "AUTO_BED_LEVELING_FEATURE requires a probe! Define a Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
+  #if HAS_ABL
+    #error "Auto Bed Leveling requires a probe! Define a Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
   #elif ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
     #error "Z_MIN_PROBE_REPEATABILITY_TEST requires a probe! Define a Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
   #endif
@@ -479,19 +518,27 @@
 /**
  * Auto Bed Leveling
  */
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
+
+  #if ENABLED(USE_RAW_KINEMATICS)
+    #error "USE_RAW_KINEMATICS is not compatible with AUTO_BED_LEVELING"
+  #endif
 
   /**
-   * Delta has limited bed leveling options
+   * Delta and SCARA have limited bed leveling options
    */
-  #if ENABLED(DELTA) && DISABLED(AUTO_BED_LEVELING_GRID)
-    #error "You must use AUTO_BED_LEVELING_GRID for DELTA bed leveling."
+  #if DISABLED(AUTO_BED_LEVELING_BILINEAR)
+    #if ENABLED(DELTA)
+      #error "Only AUTO_BED_LEVELING_BILINEAR is supported for DELTA bed leveling."
+    #elif ENABLED(SCARA)
+      #error "Only AUTO_BED_LEVELING_BILINEAR is supported for SCARA bed leveling."
+    #endif
   #endif
 
   /**
    * Check if Probe_Offset * Grid Points is greater than Probing Range
    */
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  #if ABL_GRID
     #ifndef DELTA_PROBEABLE_RADIUS
       // Be sure points are in the right order
       #if LEFT_PROBE_BED_POSITION > RIGHT_PROBE_BED_POSITION
@@ -510,7 +557,7 @@
         #error "The given BACK_PROBE_BED_POSITION can't be reached by the Z probe."
       #endif
     #endif
-  #else // !AUTO_BED_LEVELING_GRID
+  #else // !ABL_GRID
 
     // Check the triangulation points
     #if ABL_PROBE_PT_1_X < MIN_PROBE_X || ABL_PROBE_PT_1_X > MAX_PROBE_X
@@ -527,9 +574,9 @@
       #error "The given ABL_PROBE_PT_3_Y can't be reached by the Z probe."
     #endif
 
-  #endif // !AUTO_BED_LEVELING_GRID
+  #endif // !ABL_GRID
 
-#endif // AUTO_BED_LEVELING_FEATURE
+#endif // HAS_ABL
 
 /**
  * Advance Extrusion
@@ -633,14 +680,14 @@
  */
 #if HAS_AUTO_FAN
   #if HAS_FAN0
-    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN
-      #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN."
-    #elif EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN
-      #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN."
-    #elif EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN
-      #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN."
-    #elif EXTRUDER_3_AUTO_FAN_PIN == FAN_PIN
-      #error "You cannot set EXTRUDER_3_AUTO_FAN_PIN equal to FAN_PIN."
+    #if E0_AUTO_FAN_PIN == FAN_PIN
+      #error "You cannot set E0_AUTO_FAN_PIN equal to FAN_PIN."
+    #elif E1_AUTO_FAN_PIN == FAN_PIN
+      #error "You cannot set E1_AUTO_FAN_PIN equal to FAN_PIN."
+    #elif E2_AUTO_FAN_PIN == FAN_PIN
+      #error "You cannot set E2_AUTO_FAN_PIN equal to FAN_PIN."
+    #elif E3_AUTO_FAN_PIN == FAN_PIN
+      #error "You cannot set E3_AUTO_FAN_PIN equal to FAN_PIN."
     #endif
   #endif
 #endif
@@ -650,14 +697,14 @@
 #endif
 
 #if HAS_CONTROLLERFAN
-  #if EXTRUDER_0_AUTO_FAN_PIN == CONTROLLERFAN_PIN
-    #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
-  #elif EXTRUDER_1_AUTO_FAN_PIN == CONTROLLERFAN_PIN
-    #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
-  #elif EXTRUDER_2_AUTO_FAN_PIN == CONTROLLERFAN_PIN
-    #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
-  #elif EXTRUDER_3_AUTO_FAN_PIN == CONTROLLERFAN_PIN
-    #error "You cannot set EXTRUDER_3_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
+  #if E0_AUTO_FAN_PIN == CONTROLLERFAN_PIN
+    #error "You cannot set E0_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
+  #elif E1_AUTO_FAN_PIN == CONTROLLERFAN_PIN
+    #error "You cannot set E1_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
+  #elif E2_AUTO_FAN_PIN == CONTROLLERFAN_PIN
+    #error "You cannot set E2_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
+  #elif E3_AUTO_FAN_PIN == CONTROLLERFAN_PIN
+    #error "You cannot set E3_AUTO_FAN_PIN equal to CONTROLLERFAN_PIN."
   #endif
 #endif
 
@@ -723,6 +770,13 @@
 #endif
 
 /**
+ * Temperature status LEDs
+ */
+#if ENABLED(TEMP_STAT_LEDS) && !PIN_EXISTS(STAT_LED_RED) && !PIN_EXISTS(STAT_LED_BLUE)
+  #error "TEMP_STAT_LEDS requires STAT_LED_RED_PIN or STAT_LED_BLUE_PIN, preferably both."
+#endif
+
+/**
  * Basic 2-nozzle duplication mode
  */
 #if ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
@@ -806,6 +860,34 @@
 #endif
 
 /**
+ * G38 Probe Target
+ */
+#if ENABLED(G38_PROBE_TARGET)
+  #if !HAS_BED_PROBE
+    #error "G38_PROBE_TARGET requires a bed probe."
+  #elif !IS_CARTESIAN
+    #error "G38_PROBE_TARGET requires a Cartesian machine."
+  #endif
+#endif
+
+/**
+ * Auto Fan check for PWM pins
+ */
+#if HAS_AUTO_FAN && EXTRUDER_AUTO_FAN_SPEED != 255
+  #define AF_ERR_SUFF "_AUTO_FAN_PIN is not a PWM pin. Set EXTRUDER_AUTO_FAN_SPEED to 255."
+  #if HAS_AUTO_FAN_0
+    static_assert(GET_TIMER(E0_AUTO_FAN_PIN), "E0" AF_ERR_SUFF);
+  #elif HAS_AUTO_FAN_1
+    static_assert(GET_TIMER(E1_AUTO_FAN_PIN), "E1" AF_ERR_SUFF);
+  #elif HAS_AUTO_FAN_2
+    static_assert(GET_TIMER(E2_AUTO_FAN_PIN), "E2" AF_ERR_SUFF);
+  #elif HAS_AUTO_FAN_3
+    static_assert(GET_TIMER(E3_AUTO_FAN_PIN), "E3" AF_ERR_SUFF);
+  #endif
+#endif
+
+
+/**
  * Make sure only one display is enabled
  *
  * Note: BQ_LCD_SMART_CONTROLLER => REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
@@ -879,7 +961,7 @@
 #else
   #define COUNT_LCD_13 COUNT_LCD_12
 #endif
-#if ENABLED(REPRAPWORLD_KEYPAD)
+#if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(CARTESIO_UI)
   #define COUNT_LCD_14 INCREMENT(COUNT_LCD_13)
 #else
   #define COUNT_LCD_14 COUNT_LCD_13
diff --git a/Marlin/Sd2Card.cpp b/Marlin/Sd2Card.cpp
index 190e4ad..900c73b 100644
--- a/Marlin/Sd2Card.cpp
+++ b/Marlin/Sd2Card.cpp
@@ -302,16 +302,16 @@ bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
   // set pin modes
   pinMode(chipSelectPin_, OUTPUT);
   chipSelectHigh();
-  pinMode(SPI_MISO_PIN, INPUT);
-  pinMode(SPI_MOSI_PIN, OUTPUT);
-  pinMode(SPI_SCK_PIN, OUTPUT);
+  SET_INPUT(SPI_MISO_PIN);
+  SET_OUTPUT(SPI_MOSI_PIN);
+  SET_OUTPUT(SPI_SCK_PIN);
 
   #if DISABLED(SOFTWARE_SPI)
     // SS must be in output mode even it is not chip select
-    pinMode(SS_PIN, OUTPUT);
+    SET_OUTPUT(SS_PIN);
     // set SS high - may be chip select for another SPI device
     #if SET_SPI_SS_HIGH
-      digitalWrite(SS_PIN, HIGH);
+      WRITE(SS_PIN, HIGH);
     #endif  // SET_SPI_SS_HIGH
     // set SCK rate for initialization commands
     spiRate_ = SPI_SD_INIT_RATE;
diff --git a/Marlin/SdBaseFile.cpp b/Marlin/SdBaseFile.cpp
index 95765f9..298cdd1 100644
--- a/Marlin/SdBaseFile.cpp
+++ b/Marlin/SdBaseFile.cpp
@@ -674,7 +674,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile,
       index = 0;
     }
     // initialize as empty file
-    memset(p, 0, sizeof(dir_t));
+    memset(p, 0, sizeof(*p));
     memcpy(p->name, dname, 11);
 
     // set timestamps
diff --git a/Marlin/buzzer.h b/Marlin/buzzer.h
index 199d64e..9441875 100644
--- a/Marlin/buzzer.h
+++ b/Marlin/buzzer.h
@@ -109,7 +109,8 @@ class Buzzer {
         this->tick();
         thermalManager.manage_heater();
       }
-      this->buffer.enqueue((tone_t) { duration, frequency });
+      tone_t tone = { duration, frequency };
+      this->buffer.enqueue(tone);
     }
 
     /**
diff --git a/Marlin/cardreader.cpp b/Marlin/cardreader.cpp
index 319665a..5f004d2 100644
--- a/Marlin/cardreader.cpp
+++ b/Marlin/cardreader.cpp
@@ -24,7 +24,6 @@
 
 #include "ultralcd.h"
 #include "stepper.h"
-#include "temperature.h"
 #include "language.h"
 
 #include "Marlin.h"
@@ -37,7 +36,7 @@ CardReader::CardReader() {
   sdpos = 0;
   workDirDepth = 0;
   file_subcall_ctr = 0;
-  memset(workDirParents, 0, sizeof(workDirParents));
+  ZERO(workDirParents);
 
   autostart_stilltocheck = true; //the SD start is delayed, because otherwise the serial cannot answer fast enough to make contact with the host software.
   autostart_index = 0;
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index f6d061d..d6bc2be 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -36,14 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V25"
+#define EEPROM_VERSION "V27"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
-#define MAX_EXTRUDERS 4
 
 /**
- * V24 EEPROM Layout:
+ * V27 EEPROM Layout:
  *
  *  100  Version (char x4)
  *  104  EEPROM Checksum (uint16_t)
@@ -57,69 +56,68 @@
  *  166  M205 S    planner.min_feedrate_mm_s (float)
  *  170  M205 T    planner.min_travel_feedrate_mm_s (float)
  *  174  M205 B    planner.min_segment_time (ulong)
- *  178  M205 X    planner.max_xy_jerk (float)
- *  182  M205 Z    planner.max_z_jerk (float)
- *  186  M205 E    planner.max_e_jerk (float)
- *  190  M206 XYZ  home_offset (float x3)
+ *  178  M205 X    planner.max_jerk[X_AXIS] (float)
+ *  182  M205 Y    planner.max_jerk[Y_AXIS] (float)
+ *  186  M205 Z    planner.max_jerk[Z_AXIS] (float)
+ *  190  M205 E    planner.max_jerk[E_AXIS] (float)
+ *  194  M206 XYZ  home_offset (float x3)
+ *  206  M218 XYZ  hotend_offset (float x3 per additional hotend)
  *
  * Mesh bed leveling:
- *  202  M420 S    status (uint8)
- *  203            z_offset (float)
- *  207            mesh_num_x (uint8 as set in firmware)
- *  208            mesh_num_y (uint8 as set in firmware)
- *  209 G29 S3 XYZ z_values[][] (float x9, by default, up to float x 81)
+ *  218  M420 S    status (uint8)
+ *  219            z_offset (float)
+ *  223            mesh_num_x (uint8 as set in firmware)
+ *  224            mesh_num_y (uint8 as set in firmware)
+ *  225 G29 S3 XYZ z_values[][] (float x9, by default, up to float x 81)
  *
  * AUTO BED LEVELING
- *  245  M851      zprobe_zoffset (float)
+ *  261  M851      zprobe_zoffset (float)
  *
  * DELTA:
- *  249  M666 XYZ  endstop_adj (float x3)
- *  261  M665 R    delta_radius (float)
- *  265  M665 L    delta_diagonal_rod (float)
- *  269  M665 S    delta_segments_per_second (float)
- *  273  M665 A    delta_diagonal_rod_trim_tower_1 (float)
- *  277  M665 B    delta_diagonal_rod_trim_tower_2 (float)
- *  281  M665 C    delta_diagonal_rod_trim_tower_3 (float)
+ *  265  M666 XYZ  endstop_adj (float x3)
+ *  277  M665 R    delta_radius (float)
+ *  281  M665 L    delta_diagonal_rod (float)
+ *  285  M665 S    delta_segments_per_second (float)
+ *  289  M665 A    delta_diagonal_rod_trim_tower_1 (float)
+ *  293  M665 B    delta_diagonal_rod_trim_tower_2 (float)
+ *  297  M665 C    delta_diagonal_rod_trim_tower_3 (float)
  *
  * Z_DUAL_ENDSTOPS:
- *  285  M666 Z    z_endstop_adj (float)
+ *  301  M666 Z    z_endstop_adj (float)
  *
  * ULTIPANEL:
- *  289  M145 S0 H preheatHotendTemp1 (int)
- *  291  M145 S0 B preheatBedTemp1 (int)
- *  293  M145 S0 F preheatFanSpeed1 (int)
- *  295  M145 S1 H preheatHotendTemp2 (int)
- *  297  M145 S1 B preheatBedTemp2 (int)
- *  299  M145 S1 F preheatFanSpeed2 (int)
+ *  305  M145 S0 H lcd_preheat_hotend_temp (int x2)
+ *  309  M145 S0 B lcd_preheat_bed_temp (int x2)
+ *  313  M145 S0 F lcd_preheat_fan_speed (int x2)
  *
  * PIDTEMP:
- *  301  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0] (float x4)
- *  317  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1] (float x4)
- *  333  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2] (float x4)
- *  349  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3] (float x4)
- *  365  M301 L        lpq_len (int)
+ *  317  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0] (float x4)
+ *  333  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1] (float x4)
+ *  349  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2] (float x4)
+ *  365  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3] (float x4)
+ *  381  M301 L        lpq_len (int)
  *
  * PIDTEMPBED:
- *  367  M304 PID  thermalManager.bedKp, thermalManager.bedKi, thermalManager.bedKd (float x3)
+ *  383  M304 PID  thermalManager.bedKp, thermalManager.bedKi, thermalManager.bedKd (float x3)
  *
  * DOGLCD:
- *  379  M250 C    lcd_contrast (int)
+ *  395  M250 C    lcd_contrast (int)
  *
  * FWRETRACT:
- *  381  M209 S    autoretract_enabled (bool)
- *  382  M207 S    retract_length (float)
- *  386  M207 W    retract_length_swap (float)
- *  390  M207 F    retract_feedrate_mm_s (float)
- *  394  M207 Z    retract_zlift (float)
- *  398  M208 S    retract_recover_length (float)
- *  402  M208 W    retract_recover_length_swap (float)
- *  406  M208 F    retract_recover_feedrate_mm_s (float)
+ *  397  M209 S    autoretract_enabled (bool)
+ *  398  M207 S    retract_length (float)
+ *  402  M207 W    retract_length_swap (float)
+ *  406  M207 F    retract_feedrate_mm_s (float)
+ *  410  M207 Z    retract_zlift (float)
+ *  414  M208 S    retract_recover_length (float)
+ *  418  M208 W    retract_recover_length_swap (float)
+ *  422  M208 F    retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:
- *  410  M200 D    volumetric_enabled (bool)
- *  411  M200 T D  filament_size (float x4) (T0..3)
+ *  426  M200 D    volumetric_enabled (bool)
+ *  427  M200 T D  filament_size (float x4) (T0..3)
  *
- *  427  This Slot is Available!
+ *  443  This Slot is Available!
  *
  */
 #include "Marlin.h"
@@ -196,374 +194,383 @@ void Config_Postprocess() {
   #define EEPROM_WRITE(VAR) _EEPROM_writeData(eeprom_index, (uint8_t*)&VAR, sizeof(VAR))
   #define EEPROM_READ(VAR) _EEPROM_readData(eeprom_index, (uint8_t*)&VAR, sizeof(VAR))
 
-/**
- * M500 - Store Configuration
- */
-void Config_StoreSettings()  {
-  float dummy = 0.0f;
-  char ver[4] = "000";
-
-  EEPROM_START();
-
-  EEPROM_WRITE(ver);     // invalidate data first
-  EEPROM_SKIP(eeprom_checksum); // Skip the checksum slot
-
-  eeprom_checksum = 0; // clear before first "real data"
-
-  EEPROM_WRITE(planner.axis_steps_per_mm);
-  EEPROM_WRITE(planner.max_feedrate_mm_s);
-  EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
-  EEPROM_WRITE(planner.acceleration);
-  EEPROM_WRITE(planner.retract_acceleration);
-  EEPROM_WRITE(planner.travel_acceleration);
-  EEPROM_WRITE(planner.min_feedrate_mm_s);
-  EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
-  EEPROM_WRITE(planner.min_segment_time);
-  EEPROM_WRITE(planner.max_xy_jerk);
-  EEPROM_WRITE(planner.max_z_jerk);
-  EEPROM_WRITE(planner.max_e_jerk);
-  EEPROM_WRITE(home_offset);
-
-  #if ENABLED(MESH_BED_LEVELING)
-    // Compile time test that sizeof(mbl.z_values) is as expected
-    typedef char c_assert[(sizeof(mbl.z_values) == (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS) * sizeof(dummy)) ? 1 : -1];
-    uint8_t mesh_num_x = MESH_NUM_X_POINTS,
-            mesh_num_y = MESH_NUM_Y_POINTS,
-            dummy_uint8 = mbl.status & _BV(MBL_STATUS_HAS_MESH_BIT);
-    EEPROM_WRITE(dummy_uint8);
-    EEPROM_WRITE(mbl.z_offset);
-    EEPROM_WRITE(mesh_num_x);
-    EEPROM_WRITE(mesh_num_y);
-    EEPROM_WRITE(mbl.z_values);
-  #else
-    // For disabled MBL write a default mesh
-    uint8_t mesh_num_x = 3,
-            mesh_num_y = 3,
-            dummy_uint8 = 0;
-    dummy = 0.0f;
-    EEPROM_WRITE(dummy_uint8);
-    EEPROM_WRITE(dummy);
-    EEPROM_WRITE(mesh_num_x);
-    EEPROM_WRITE(mesh_num_y);
-    for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_WRITE(dummy);
-  #endif // MESH_BED_LEVELING
-
-  #if !HAS_BED_PROBE
-    float zprobe_zoffset = 0;
-  #endif
-  EEPROM_WRITE(zprobe_zoffset);
-
-  // 9 floats for DELTA / Z_DUAL_ENDSTOPS
-  #if ENABLED(DELTA)
-    EEPROM_WRITE(endstop_adj);               // 3 floats
-    EEPROM_WRITE(delta_radius);              // 1 float
-    EEPROM_WRITE(delta_diagonal_rod);        // 1 float
-    EEPROM_WRITE(delta_segments_per_second); // 1 float
-    EEPROM_WRITE(delta_diagonal_rod_trim_tower_1);  // 1 float
-    EEPROM_WRITE(delta_diagonal_rod_trim_tower_2);  // 1 float
-    EEPROM_WRITE(delta_diagonal_rod_trim_tower_3);  // 1 float
-  #elif ENABLED(Z_DUAL_ENDSTOPS)
-    EEPROM_WRITE(z_endstop_adj);            // 1 float
-    dummy = 0.0f;
-    for (uint8_t q = 8; q--;) EEPROM_WRITE(dummy);
-  #else
-    dummy = 0.0f;
-    for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
-  #endif
-
-  #if DISABLED(ULTIPANEL)
-    int preheatHotendTemp1 = PREHEAT_1_TEMP_HOTEND, preheatBedTemp1 = PREHEAT_1_TEMP_BED, preheatFanSpeed1 = PREHEAT_1_FAN_SPEED,
-        preheatHotendTemp2 = PREHEAT_2_TEMP_HOTEND, preheatBedTemp2 = PREHEAT_2_TEMP_BED, preheatFanSpeed2 = PREHEAT_2_FAN_SPEED;
-  #endif // !ULTIPANEL
-
-  EEPROM_WRITE(preheatHotendTemp1);
-  EEPROM_WRITE(preheatBedTemp1);
-  EEPROM_WRITE(preheatFanSpeed1);
-  EEPROM_WRITE(preheatHotendTemp2);
-  EEPROM_WRITE(preheatBedTemp2);
-  EEPROM_WRITE(preheatFanSpeed2);
-
-  for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
-
-    #if ENABLED(PIDTEMP)
-      if (e < HOTENDS) {
-        EEPROM_WRITE(PID_PARAM(Kp, e));
-        EEPROM_WRITE(PID_PARAM(Ki, e));
-        EEPROM_WRITE(PID_PARAM(Kd, e));
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          EEPROM_WRITE(PID_PARAM(Kc, e));
-        #else
-          dummy = 1.0f; // 1.0 = default kc
-          EEPROM_WRITE(dummy);
-        #endif
-      }
-      else
-    #endif // !PIDTEMP
-      {
-        dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
-        EEPROM_WRITE(dummy); // Kp
-        dummy = 0.0f;
-        for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
-      }
-
-  } // Hotends Loop
-
-  #if DISABLED(PID_EXTRUSION_SCALING)
-    int lpq_len = 20;
-  #endif
-  EEPROM_WRITE(lpq_len);
-
-  #if DISABLED(PIDTEMPBED)
-    dummy = DUMMY_PID_VALUE;
-    for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
-  #else
-    EEPROM_WRITE(thermalManager.bedKp);
-    EEPROM_WRITE(thermalManager.bedKi);
-    EEPROM_WRITE(thermalManager.bedKd);
-  #endif
-
-  #if !HAS_LCD_CONTRAST
-    const int lcd_contrast = 32;
-  #endif
-  EEPROM_WRITE(lcd_contrast);
-
-  #if ENABLED(FWRETRACT)
-    EEPROM_WRITE(autoretract_enabled);
-    EEPROM_WRITE(retract_length);
-    #if EXTRUDERS > 1
-      EEPROM_WRITE(retract_length_swap);
-    #else
-      dummy = 0.0f;
-      EEPROM_WRITE(dummy);
-    #endif
-    EEPROM_WRITE(retract_feedrate_mm_s);
-    EEPROM_WRITE(retract_zlift);
-    EEPROM_WRITE(retract_recover_length);
-    #if EXTRUDERS > 1
-      EEPROM_WRITE(retract_recover_length_swap);
-    #else
-      dummy = 0.0f;
-      EEPROM_WRITE(dummy);
+  /**
+   * M500 - Store Configuration
+   */
+  void Config_StoreSettings()  {
+    float dummy = 0.0f;
+    char ver[4] = "000";
+
+    EEPROM_START();
+
+    EEPROM_WRITE(ver);     // invalidate data first
+    EEPROM_SKIP(eeprom_checksum); // Skip the checksum slot
+
+    eeprom_checksum = 0; // clear before first "real data"
+
+    EEPROM_WRITE(planner.axis_steps_per_mm);
+    EEPROM_WRITE(planner.max_feedrate_mm_s);
+    EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
+    EEPROM_WRITE(planner.acceleration);
+    EEPROM_WRITE(planner.retract_acceleration);
+    EEPROM_WRITE(planner.travel_acceleration);
+    EEPROM_WRITE(planner.min_feedrate_mm_s);
+    EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
+    EEPROM_WRITE(planner.min_segment_time);
+    EEPROM_WRITE(planner.max_jerk);
+    EEPROM_WRITE(home_offset);
+
+    #if HOTENDS > 1
+      // Skip hotend 0 which must be 0
+      for (uint8_t e = 1; e < HOTENDS; e++)
+        LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
     #endif
-    EEPROM_WRITE(retract_recover_feedrate_mm_s);
-  #endif // FWRETRACT
-
-  EEPROM_WRITE(volumetric_enabled);
-
-  // Save filament sizes
-  for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-    if (q < COUNT(filament_size)) dummy = filament_size[q];
-    EEPROM_WRITE(dummy);
-  }
 
-  uint16_t final_checksum = eeprom_checksum,
-           eeprom_size = eeprom_index;
-
-  eeprom_index = EEPROM_OFFSET;
-  EEPROM_WRITE(version);
-  EEPROM_WRITE(final_checksum);
-
-  // Report storage size
-  SERIAL_ECHO_START;
-  SERIAL_ECHOPAIR("Settings Stored (", eeprom_size);
-  SERIAL_ECHOLNPGM(" bytes)");
-}
-
-/**
- * M501 - Retrieve Configuration
- */
-void Config_RetrieveSettings() {
-
-  EEPROM_START();
-
-  char stored_ver[4];
-  EEPROM_READ(stored_ver);
-
-  uint16_t stored_checksum;
-  EEPROM_READ(stored_checksum);
-
-  //  SERIAL_ECHOPAIR("Version: [", ver);
-  //  SERIAL_ECHOPAIR("] Stored version: [", stored_ver);
-  //  SERIAL_ECHOLNPGM("]");
-
-  if (strncmp(version, stored_ver, 3) != 0) {
-    Config_ResetDefault();
-  }
-  else {
-    float dummy = 0;
-
-    eeprom_checksum = 0; // clear before reading first "real data"
-
-    // version number match
-    EEPROM_READ(planner.axis_steps_per_mm);
-    EEPROM_READ(planner.max_feedrate_mm_s);
-    EEPROM_READ(planner.max_acceleration_mm_per_s2);
-
-    EEPROM_READ(planner.acceleration);
-    EEPROM_READ(planner.retract_acceleration);
-    EEPROM_READ(planner.travel_acceleration);
-    EEPROM_READ(planner.min_feedrate_mm_s);
-    EEPROM_READ(planner.min_travel_feedrate_mm_s);
-    EEPROM_READ(planner.min_segment_time);
-    EEPROM_READ(planner.max_xy_jerk);
-    EEPROM_READ(planner.max_z_jerk);
-    EEPROM_READ(planner.max_e_jerk);
-    EEPROM_READ(home_offset);
-
-    uint8_t dummy_uint8 = 0, mesh_num_x = 0, mesh_num_y = 0;
-    EEPROM_READ(dummy_uint8);
-    EEPROM_READ(dummy);
-    EEPROM_READ(mesh_num_x);
-    EEPROM_READ(mesh_num_y);
     #if ENABLED(MESH_BED_LEVELING)
-      mbl.status = dummy_uint8;
-      mbl.z_offset = dummy;
-      if (mesh_num_x == MESH_NUM_X_POINTS && mesh_num_y == MESH_NUM_Y_POINTS) {
-        // EEPROM data fits the current mesh
-        EEPROM_READ(mbl.z_values);
-      }
-      else {
-        // EEPROM data is stale
-        mbl.reset();
-        for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
-      }
+      // Compile time test that sizeof(mbl.z_values) is as expected
+      typedef char c_assert[(sizeof(mbl.z_values) == (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS) * sizeof(dummy)) ? 1 : -1];
+      uint8_t mesh_num_x = MESH_NUM_X_POINTS,
+              mesh_num_y = MESH_NUM_Y_POINTS,
+              dummy_uint8 = mbl.status & _BV(MBL_STATUS_HAS_MESH_BIT);
+      EEPROM_WRITE(dummy_uint8);
+      EEPROM_WRITE(mbl.z_offset);
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+      EEPROM_WRITE(mbl.z_values);
     #else
-      // MBL is disabled - skip the stored data
-      for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
+      // For disabled MBL write a default mesh
+      uint8_t mesh_num_x = 3,
+              mesh_num_y = 3,
+              dummy_uint8 = 0;
+      dummy = 0.0f;
+      EEPROM_WRITE(dummy_uint8);
+      EEPROM_WRITE(dummy);
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+      for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_WRITE(dummy);
     #endif // MESH_BED_LEVELING
 
     #if !HAS_BED_PROBE
       float zprobe_zoffset = 0;
     #endif
-    EEPROM_READ(zprobe_zoffset);
+    EEPROM_WRITE(zprobe_zoffset);
 
+    // 9 floats for DELTA / Z_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
-      EEPROM_READ(endstop_adj);                // 3 floats
-      EEPROM_READ(delta_radius);               // 1 float
-      EEPROM_READ(delta_diagonal_rod);         // 1 float
-      EEPROM_READ(delta_segments_per_second);  // 1 float
-      EEPROM_READ(delta_diagonal_rod_trim_tower_1);  // 1 float
-      EEPROM_READ(delta_diagonal_rod_trim_tower_2);  // 1 float
-      EEPROM_READ(delta_diagonal_rod_trim_tower_3);  // 1 float
+      EEPROM_WRITE(endstop_adj);               // 3 floats
+      EEPROM_WRITE(delta_radius);              // 1 float
+      EEPROM_WRITE(delta_diagonal_rod);        // 1 float
+      EEPROM_WRITE(delta_segments_per_second); // 1 float
+      EEPROM_WRITE(delta_diagonal_rod_trim_tower_1);  // 1 float
+      EEPROM_WRITE(delta_diagonal_rod_trim_tower_2);  // 1 float
+      EEPROM_WRITE(delta_diagonal_rod_trim_tower_3);  // 1 float
     #elif ENABLED(Z_DUAL_ENDSTOPS)
-      EEPROM_READ(z_endstop_adj);
+      EEPROM_WRITE(z_endstop_adj);            // 1 float
       dummy = 0.0f;
-      for (uint8_t q=8; q--;) EEPROM_READ(dummy);
+      for (uint8_t q = 8; q--;) EEPROM_WRITE(dummy);
     #else
       dummy = 0.0f;
-      for (uint8_t q=9; q--;) EEPROM_READ(dummy);
+      for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
     #endif
 
     #if DISABLED(ULTIPANEL)
-      int preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1,
-          preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2;
-    #endif
-
-    EEPROM_READ(preheatHotendTemp1);
-    EEPROM_READ(preheatBedTemp1);
-    EEPROM_READ(preheatFanSpeed1);
-    EEPROM_READ(preheatHotendTemp2);
-    EEPROM_READ(preheatBedTemp2);
-    EEPROM_READ(preheatFanSpeed2);
-
-    #if ENABLED(PIDTEMP)
-      for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
-        EEPROM_READ(dummy); // Kp
-        if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
-          // do not need to scale PID values as the values in EEPROM are already scaled
-          PID_PARAM(Kp, e) = dummy;
-          EEPROM_READ(PID_PARAM(Ki, e));
-          EEPROM_READ(PID_PARAM(Kd, e));
+      const int lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
+                lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
+                lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+    #endif // !ULTIPANEL
+
+    EEPROM_WRITE(lcd_preheat_hotend_temp);
+    EEPROM_WRITE(lcd_preheat_bed_temp);
+    EEPROM_WRITE(lcd_preheat_fan_speed);
+
+    for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
+
+      #if ENABLED(PIDTEMP)
+        if (e < HOTENDS) {
+          EEPROM_WRITE(PID_PARAM(Kp, e));
+          EEPROM_WRITE(PID_PARAM(Ki, e));
+          EEPROM_WRITE(PID_PARAM(Kd, e));
           #if ENABLED(PID_EXTRUSION_SCALING)
-            EEPROM_READ(PID_PARAM(Kc, e));
+            EEPROM_WRITE(PID_PARAM(Kc, e));
           #else
-            EEPROM_READ(dummy);
+            dummy = 1.0f; // 1.0 = default kc
+            EEPROM_WRITE(dummy);
           #endif
         }
-        else {
-          for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
+        else
+      #endif // !PIDTEMP
+        {
+          dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
+          EEPROM_WRITE(dummy); // Kp
+          dummy = 0.0f;
+          for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
         }
-      }
-    #else // !PIDTEMP
-      // 4 x 4 = 16 slots for PID parameters
-      for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
-    #endif // !PIDTEMP
+
+    } // Hotends Loop
 
     #if DISABLED(PID_EXTRUSION_SCALING)
-      int lpq_len;
+      int lpq_len = 20;
     #endif
-    EEPROM_READ(lpq_len);
-
-    #if ENABLED(PIDTEMPBED)
-      EEPROM_READ(dummy); // bedKp
-      if (dummy != DUMMY_PID_VALUE) {
-        thermalManager.bedKp = dummy;
-        EEPROM_READ(thermalManager.bedKi);
-        EEPROM_READ(thermalManager.bedKd);
-      }
+    EEPROM_WRITE(lpq_len);
+
+    #if DISABLED(PIDTEMPBED)
+      dummy = DUMMY_PID_VALUE;
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
     #else
-      for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
+      EEPROM_WRITE(thermalManager.bedKp);
+      EEPROM_WRITE(thermalManager.bedKi);
+      EEPROM_WRITE(thermalManager.bedKd);
     #endif
 
     #if !HAS_LCD_CONTRAST
-      int lcd_contrast;
+      const int lcd_contrast = 32;
     #endif
-    EEPROM_READ(lcd_contrast);
+    EEPROM_WRITE(lcd_contrast);
 
     #if ENABLED(FWRETRACT)
-      EEPROM_READ(autoretract_enabled);
-      EEPROM_READ(retract_length);
+      EEPROM_WRITE(autoretract_enabled);
+      EEPROM_WRITE(retract_length);
       #if EXTRUDERS > 1
-        EEPROM_READ(retract_length_swap);
+        EEPROM_WRITE(retract_length_swap);
       #else
-        EEPROM_READ(dummy);
+        dummy = 0.0f;
+        EEPROM_WRITE(dummy);
       #endif
-      EEPROM_READ(retract_feedrate_mm_s);
-      EEPROM_READ(retract_zlift);
-      EEPROM_READ(retract_recover_length);
+      EEPROM_WRITE(retract_feedrate_mm_s);
+      EEPROM_WRITE(retract_zlift);
+      EEPROM_WRITE(retract_recover_length);
       #if EXTRUDERS > 1
-        EEPROM_READ(retract_recover_length_swap);
+        EEPROM_WRITE(retract_recover_length_swap);
       #else
-        EEPROM_READ(dummy);
+        dummy = 0.0f;
+        EEPROM_WRITE(dummy);
       #endif
-      EEPROM_READ(retract_recover_feedrate_mm_s);
+      EEPROM_WRITE(retract_recover_feedrate_mm_s);
     #endif // FWRETRACT
 
-    EEPROM_READ(volumetric_enabled);
+    EEPROM_WRITE(volumetric_enabled);
 
+    // Save filament sizes
     for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-      EEPROM_READ(dummy);
-      if (q < COUNT(filament_size)) filament_size[q] = dummy;
+      if (q < COUNT(filament_size)) dummy = filament_size[q];
+      EEPROM_WRITE(dummy);
     }
 
-    if (eeprom_checksum == stored_checksum) {
-      Config_Postprocess();
-      SERIAL_ECHO_START;
-      SERIAL_ECHO(version);
-      SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index);
-      SERIAL_ECHOLNPGM(" bytes)");
-    }
-    else {
-      SERIAL_ERROR_START;
-      SERIAL_ERRORLNPGM("EEPROM checksum mismatch");
+    uint16_t final_checksum = eeprom_checksum,
+             eeprom_size = eeprom_index;
+
+    eeprom_index = EEPROM_OFFSET;
+    EEPROM_WRITE(version);
+    EEPROM_WRITE(final_checksum);
+
+    // Report storage size
+    SERIAL_ECHO_START;
+    SERIAL_ECHOPAIR("Settings Stored (", eeprom_size);
+    SERIAL_ECHOLNPGM(" bytes)");
+  }
+
+  /**
+   * M501 - Retrieve Configuration
+   */
+  void Config_RetrieveSettings() {
+
+    EEPROM_START();
+
+    char stored_ver[4];
+    EEPROM_READ(stored_ver);
+
+    uint16_t stored_checksum;
+    EEPROM_READ(stored_checksum);
+
+    //  SERIAL_ECHOPAIR("Version: [", ver);
+    //  SERIAL_ECHOPAIR("] Stored version: [", stored_ver);
+    //  SERIAL_CHAR(']');
+    //  SERIAL_EOL;
+
+    if (strncmp(version, stored_ver, 3) != 0) {
       Config_ResetDefault();
     }
- }
+    else {
+      float dummy = 0;
 
-  #if ENABLED(EEPROM_CHITCHAT)
-    Config_PrintSettings();
-  #endif
-}
+      eeprom_checksum = 0; // clear before reading first "real data"
+
+      // version number match
+      EEPROM_READ(planner.axis_steps_per_mm);
+      EEPROM_READ(planner.max_feedrate_mm_s);
+      EEPROM_READ(planner.max_acceleration_mm_per_s2);
+
+      EEPROM_READ(planner.acceleration);
+      EEPROM_READ(planner.retract_acceleration);
+      EEPROM_READ(planner.travel_acceleration);
+      EEPROM_READ(planner.min_feedrate_mm_s);
+      EEPROM_READ(planner.min_travel_feedrate_mm_s);
+      EEPROM_READ(planner.min_segment_time);
+      EEPROM_READ(planner.max_jerk);
+      EEPROM_READ(home_offset);
+
+      #if HOTENDS > 1
+        // Skip hotend 0 which must be 0
+        for (uint8_t e = 1; e < HOTENDS; e++)
+          LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
+      #endif
+
+      uint8_t dummy_uint8 = 0, mesh_num_x = 0, mesh_num_y = 0;
+      EEPROM_READ(dummy_uint8);
+      EEPROM_READ(dummy);
+      EEPROM_READ(mesh_num_x);
+      EEPROM_READ(mesh_num_y);
+      #if ENABLED(MESH_BED_LEVELING)
+        mbl.status = dummy_uint8;
+        mbl.z_offset = dummy;
+        if (mesh_num_x == MESH_NUM_X_POINTS && mesh_num_y == MESH_NUM_Y_POINTS) {
+          // EEPROM data fits the current mesh
+          EEPROM_READ(mbl.z_values);
+        }
+        else {
+          // EEPROM data is stale
+          mbl.reset();
+          for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
+        }
+      #else
+        // MBL is disabled - skip the stored data
+        for (uint8_t q = 0; q < mesh_num_x * mesh_num_y; q++) EEPROM_READ(dummy);
+      #endif // MESH_BED_LEVELING
+
+      #if !HAS_BED_PROBE
+        float zprobe_zoffset = 0;
+      #endif
+      EEPROM_READ(zprobe_zoffset);
+
+      #if ENABLED(DELTA)
+        EEPROM_READ(endstop_adj);                // 3 floats
+        EEPROM_READ(delta_radius);               // 1 float
+        EEPROM_READ(delta_diagonal_rod);         // 1 float
+        EEPROM_READ(delta_segments_per_second);  // 1 float
+        EEPROM_READ(delta_diagonal_rod_trim_tower_1);  // 1 float
+        EEPROM_READ(delta_diagonal_rod_trim_tower_2);  // 1 float
+        EEPROM_READ(delta_diagonal_rod_trim_tower_3);  // 1 float
+      #elif ENABLED(Z_DUAL_ENDSTOPS)
+        EEPROM_READ(z_endstop_adj);
+        dummy = 0.0f;
+        for (uint8_t q=8; q--;) EEPROM_READ(dummy);
+      #else
+        dummy = 0.0f;
+        for (uint8_t q=9; q--;) EEPROM_READ(dummy);
+      #endif
+
+      #if DISABLED(ULTIPANEL)
+        int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+      #endif
+
+      EEPROM_READ(lcd_preheat_hotend_temp);
+      EEPROM_READ(lcd_preheat_bed_temp);
+      EEPROM_READ(lcd_preheat_fan_speed);
+
+      #if ENABLED(PIDTEMP)
+        for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
+          EEPROM_READ(dummy); // Kp
+          if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
+            // do not need to scale PID values as the values in EEPROM are already scaled
+            PID_PARAM(Kp, e) = dummy;
+            EEPROM_READ(PID_PARAM(Ki, e));
+            EEPROM_READ(PID_PARAM(Kd, e));
+            #if ENABLED(PID_EXTRUSION_SCALING)
+              EEPROM_READ(PID_PARAM(Kc, e));
+            #else
+              EEPROM_READ(dummy);
+            #endif
+          }
+          else {
+            for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
+          }
+        }
+      #else // !PIDTEMP
+        // 4 x 4 = 16 slots for PID parameters
+        for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
+      #endif // !PIDTEMP
+
+      #if DISABLED(PID_EXTRUSION_SCALING)
+        int lpq_len;
+      #endif
+      EEPROM_READ(lpq_len);
+
+      #if ENABLED(PIDTEMPBED)
+        EEPROM_READ(dummy); // bedKp
+        if (dummy != DUMMY_PID_VALUE) {
+          thermalManager.bedKp = dummy;
+          EEPROM_READ(thermalManager.bedKi);
+          EEPROM_READ(thermalManager.bedKd);
+        }
+      #else
+        for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
+      #endif
 
-#endif // EEPROM_SETTINGS
+      #if !HAS_LCD_CONTRAST
+        int lcd_contrast;
+      #endif
+      EEPROM_READ(lcd_contrast);
+
+      #if ENABLED(FWRETRACT)
+        EEPROM_READ(autoretract_enabled);
+        EEPROM_READ(retract_length);
+        #if EXTRUDERS > 1
+          EEPROM_READ(retract_length_swap);
+        #else
+          EEPROM_READ(dummy);
+        #endif
+        EEPROM_READ(retract_feedrate_mm_s);
+        EEPROM_READ(retract_zlift);
+        EEPROM_READ(retract_recover_length);
+        #if EXTRUDERS > 1
+          EEPROM_READ(retract_recover_length_swap);
+        #else
+          EEPROM_READ(dummy);
+        #endif
+        EEPROM_READ(retract_recover_feedrate_mm_s);
+      #endif // FWRETRACT
+
+      EEPROM_READ(volumetric_enabled);
+
+      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        EEPROM_READ(dummy);
+        if (q < COUNT(filament_size)) filament_size[q] = dummy;
+      }
+
+      if (eeprom_checksum == stored_checksum) {
+        Config_Postprocess();
+        SERIAL_ECHO_START;
+        SERIAL_ECHO(version);
+        SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index);
+        SERIAL_ECHOLNPGM(" bytes)");
+      }
+      else {
+        SERIAL_ERROR_START;
+        SERIAL_ERRORLNPGM("EEPROM checksum mismatch");
+        Config_ResetDefault();
+      }
+   }
+
+    #if ENABLED(EEPROM_CHITCHAT)
+      Config_PrintSettings();
+    #endif
+  }
+
+#else // !EEPROM_SETTINGS
+
+  void Config_StoreSettings() {
+    SERIAL_ERROR_START;
+    SERIAL_ERRORLNPGM("EEPROM disabled");
+  }
+
+#endif // !EEPROM_SETTINGS
 
 /**
  * M502 - Reset Configuration
  */
 void Config_ResetDefault() {
-  float tmp1[] = DEFAULT_AXIS_STEPS_PER_UNIT;
-  float tmp2[] = DEFAULT_MAX_FEEDRATE;
-  long tmp3[] = DEFAULT_MAX_ACCELERATION;
+  const float tmp1[] = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] = DEFAULT_MAX_FEEDRATE;
+  const long tmp3[] = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE(i) {
     planner.axis_steps_per_mm[i] = tmp1[i];
     planner.max_feedrate_mm_s[i] = tmp2[i];
@@ -576,11 +583,29 @@ void Config_ResetDefault() {
   planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
   planner.min_segment_time = DEFAULT_MINSEGMENTTIME;
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
-  planner.max_xy_jerk = DEFAULT_XYJERK;
-  planner.max_z_jerk = DEFAULT_ZJERK;
-  planner.max_e_jerk = DEFAULT_EJERK;
+  planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
+  planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
+  planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
+  planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
   home_offset[X_AXIS] = home_offset[Y_AXIS] = home_offset[Z_AXIS] = 0;
 
+  #if HOTENDS > 1
+    constexpr float tmp4[XYZ][HOTENDS] = {
+      HOTEND_OFFSET_X,
+      HOTEND_OFFSET_Y
+      #ifdef HOTEND_OFFSET_Z
+        , HOTEND_OFFSET_Z
+      #else
+        , { 0 }
+      #endif
+    };
+    static_assert(
+      tmp4[X_AXIS][0] == 0 && tmp4[Y_AXIS][0] == 0 && tmp4[Z_AXIS][0] == 0,
+      "Offsets for the first hotend must be 0.0."
+    );
+    LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp4[i][e];
+  #endif
+
   #if ENABLED(MESH_BED_LEVELING)
     mbl.reset();
   #endif
@@ -590,7 +615,10 @@ void Config_ResetDefault() {
   #endif
 
   #if ENABLED(DELTA)
-    endstop_adj[X_AXIS] = endstop_adj[Y_AXIS] = endstop_adj[Z_AXIS] = 0;
+    const float adj[ABC] = DELTA_ENDSTOP_ADJ;
+    endstop_adj[A_AXIS] = adj[A_AXIS];
+    endstop_adj[B_AXIS] = adj[B_AXIS];
+    endstop_adj[C_AXIS] = adj[C_AXIS];
     delta_radius =  DELTA_RADIUS;
     delta_diagonal_rod =  DELTA_DIAGONAL_ROD;
     delta_segments_per_second =  DELTA_SEGMENTS_PER_SECOND;
@@ -602,12 +630,12 @@ void Config_ResetDefault() {
   #endif
 
   #if ENABLED(ULTIPANEL)
-    preheatHotendTemp1 = PREHEAT_1_TEMP_HOTEND;
-    preheatBedTemp1 = PREHEAT_1_TEMP_BED;
-    preheatFanSpeed1 = PREHEAT_1_FAN_SPEED;
-    preheatHotendTemp2 = PREHEAT_2_TEMP_HOTEND;
-    preheatBedTemp2 = PREHEAT_2_TEMP_BED;
-    preheatFanSpeed2 = PREHEAT_2_FAN_SPEED;
+    lcd_preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
+    lcd_preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
+    lcd_preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
+    lcd_preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
+    lcd_preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
+    lcd_preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
   #endif
 
   #if HAS_LCD_CONTRAST
@@ -674,292 +702,308 @@ void Config_ResetDefault() {
 
 #if DISABLED(DISABLE_M503)
 
-#define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START; }while(0)
-
-/**
- * M503 - Print Configuration
- */
-void Config_PrintSettings(bool forReplay) {
-  // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown
-
-  CONFIG_ECHO_START;
-
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Steps per unit:");
-    CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M92 X", planner.axis_steps_per_mm[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", planner.axis_steps_per_mm[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", planner.axis_steps_per_mm[Z_AXIS]);
-  SERIAL_ECHOPAIR(" E", planner.axis_steps_per_mm[E_AXIS]);
-  SERIAL_EOL;
+  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START; }while(0)
 
-  CONFIG_ECHO_START;
+  /**
+   * M503 - Print Configuration
+   */
+  void Config_PrintSettings(bool forReplay) {
+    // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown
 
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
-    CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M203 X", planner.max_feedrate_mm_s[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", planner.max_feedrate_mm_s[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", planner.max_feedrate_mm_s[Z_AXIS]);
-  SERIAL_ECHOPAIR(" E", planner.max_feedrate_mm_s[E_AXIS]);
-  SERIAL_EOL;
-
-  CONFIG_ECHO_START;
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
-    CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M201 X", planner.max_acceleration_mm_per_s2[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", planner.max_acceleration_mm_per_s2[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", planner.max_acceleration_mm_per_s2[Z_AXIS]);
-  SERIAL_ECHOPAIR(" E", planner.max_acceleration_mm_per_s2[E_AXIS]);
-  SERIAL_EOL;
-  CONFIG_ECHO_START;
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Accelerations: P=printing, R=retract and T=travel");
-    CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M204 P", planner.acceleration);
-  SERIAL_ECHOPAIR(" R", planner.retract_acceleration);
-  SERIAL_ECHOPAIR(" T", planner.travel_acceleration);
-  SERIAL_EOL;
-
-  CONFIG_ECHO_START;
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum XY jerk (mm/s),  Z=maximum Z jerk (mm/s),  E=maximum E jerk (mm/s)");
     CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M205 S", planner.min_feedrate_mm_s);
-  SERIAL_ECHOPAIR(" T", planner.min_travel_feedrate_mm_s);
-  SERIAL_ECHOPAIR(" B", planner.min_segment_time);
-  SERIAL_ECHOPAIR(" X", planner.max_xy_jerk);
-  SERIAL_ECHOPAIR(" Z", planner.max_z_jerk);
-  SERIAL_ECHOPAIR(" E", planner.max_e_jerk);
-  SERIAL_EOL;
-
-  CONFIG_ECHO_START;
-  if (!forReplay) {
-    SERIAL_ECHOLNPGM("Home offset (mm)");
-    CONFIG_ECHO_START;
-  }
-  SERIAL_ECHOPAIR("  M206 X", home_offset[X_AXIS]);
-  SERIAL_ECHOPAIR(" Y", home_offset[Y_AXIS]);
-  SERIAL_ECHOPAIR(" Z", home_offset[Z_AXIS]);
-  SERIAL_EOL;
 
-  #if ENABLED(MESH_BED_LEVELING)
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("Mesh bed leveling:");
+      SERIAL_ECHOLNPGM("Steps per unit:");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M420 S", mbl.has_mesh() ? 1 : 0);
-    SERIAL_ECHOPAIR(" X", MESH_NUM_X_POINTS);
-    SERIAL_ECHOPAIR(" Y", MESH_NUM_Y_POINTS);
+    SERIAL_ECHOPAIR("  M92 X", planner.axis_steps_per_mm[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", planner.axis_steps_per_mm[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z", planner.axis_steps_per_mm[Z_AXIS]);
+    SERIAL_ECHOPAIR(" E", planner.axis_steps_per_mm[E_AXIS]);
     SERIAL_EOL;
-    for (uint8_t py = 1; py <= MESH_NUM_Y_POINTS; py++) {
-      for (uint8_t px = 1; px <= MESH_NUM_X_POINTS; px++) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  G29 S3 X", px);
-        SERIAL_ECHOPAIR(" Y", py);
-        SERIAL_ECHOPGM(" Z");
-        SERIAL_PROTOCOL_F(mbl.z_values[py-1][px-1], 5);
-        SERIAL_EOL;
-      }
-    }
-  #endif
 
-  #if ENABLED(DELTA)
     CONFIG_ECHO_START;
+
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("Endstop adjustment (mm):");
+      SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M666 X", endstop_adj[X_AXIS]);
-    SERIAL_ECHOPAIR(" Y", endstop_adj[Y_AXIS]);
-    SERIAL_ECHOPAIR(" Z", endstop_adj[Z_AXIS]);
+    SERIAL_ECHOPAIR("  M203 X", planner.max_feedrate_mm_s[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", planner.max_feedrate_mm_s[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z", planner.max_feedrate_mm_s[Z_AXIS]);
+    SERIAL_ECHOPAIR(" E", planner.max_feedrate_mm_s[E_AXIS]);
     SERIAL_EOL;
+
     CONFIG_ECHO_START;
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("Delta settings: L=diagonal_rod, R=radius, S=segments_per_second, ABC=diagonal_rod_trim_tower_[123]");
+      SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M665 L", delta_diagonal_rod);
-    SERIAL_ECHOPAIR(" R", delta_radius);
-    SERIAL_ECHOPAIR(" S", delta_segments_per_second);
-    SERIAL_ECHOPAIR(" A", delta_diagonal_rod_trim_tower_1);
-    SERIAL_ECHOPAIR(" B", delta_diagonal_rod_trim_tower_2);
-    SERIAL_ECHOPAIR(" C", delta_diagonal_rod_trim_tower_3);
+    SERIAL_ECHOPAIR("  M201 X", planner.max_acceleration_mm_per_s2[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", planner.max_acceleration_mm_per_s2[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z", planner.max_acceleration_mm_per_s2[Z_AXIS]);
+    SERIAL_ECHOPAIR(" E", planner.max_acceleration_mm_per_s2[E_AXIS]);
     SERIAL_EOL;
-  #elif ENABLED(Z_DUAL_ENDSTOPS)
     CONFIG_ECHO_START;
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("Z2 Endstop adjustment (mm):");
+      SERIAL_ECHOLNPGM("Accelerations: P=printing, R=retract and T=travel");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M666 Z", z_endstop_adj);
+    SERIAL_ECHOPAIR("  M204 P", planner.acceleration);
+    SERIAL_ECHOPAIR(" R", planner.retract_acceleration);
+    SERIAL_ECHOPAIR(" T", planner.travel_acceleration);
     SERIAL_EOL;
-  #endif // DELTA
 
-  #if ENABLED(ULTIPANEL)
     CONFIG_ECHO_START;
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("Material heatup parameters:");
+      SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum XY jerk (mm/s),  Z=maximum Z jerk (mm/s),  E=maximum E jerk (mm/s)");
       CONFIG_ECHO_START;
     }
-    SERIAL_ECHOPAIR("  M145 S0 H", preheatHotendTemp1);
-    SERIAL_ECHOPAIR(" B", preheatBedTemp1);
-    SERIAL_ECHOPAIR(" F", preheatFanSpeed1);
+    SERIAL_ECHOPAIR("  M205 S", planner.min_feedrate_mm_s);
+    SERIAL_ECHOPAIR(" T", planner.min_travel_feedrate_mm_s);
+    SERIAL_ECHOPAIR(" B", planner.min_segment_time);
+    SERIAL_ECHOPAIR(" X", planner.max_jerk[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", planner.max_jerk[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z", planner.max_jerk[Z_AXIS]);
+    SERIAL_ECHOPAIR(" E", planner.max_jerk[E_AXIS]);
     SERIAL_EOL;
-    CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M145 S1 H", preheatHotendTemp2);
-    SERIAL_ECHOPAIR(" B", preheatBedTemp2);
-    SERIAL_ECHOPAIR(" F", preheatFanSpeed2);
-    SERIAL_EOL;
-  #endif // ULTIPANEL
-
-  #if HAS_PID_HEATING
 
     CONFIG_ECHO_START;
     if (!forReplay) {
-      SERIAL_ECHOLNPGM("PID settings:");
+      SERIAL_ECHOLNPGM("Home offset (mm)");
+      CONFIG_ECHO_START;
     }
-    #if ENABLED(PIDTEMP)
-      #if HOTENDS > 1
-        if (forReplay) {
-          HOTEND_LOOP() {
-            CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M301 E", e);
-            SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
-            SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
-            SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
-            #if ENABLED(PID_EXTRUSION_SCALING)
-              SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
-              if (e == 0) SERIAL_ECHOPAIR(" L", lpq_len);
-            #endif
-            SERIAL_EOL;
-          }
-        }
-        else
-      #endif // HOTENDS > 1
-      // !forReplay || HOTENDS == 1
-      {
+    SERIAL_ECHOPAIR("  M206 X", home_offset[X_AXIS]);
+    SERIAL_ECHOPAIR(" Y", home_offset[Y_AXIS]);
+    SERIAL_ECHOPAIR(" Z", home_offset[Z_AXIS]);
+    SERIAL_EOL;
+
+    #if HOTENDS > 1
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Hotend offsets (mm)");
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
-        SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
-        SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
-          SERIAL_ECHOPAIR(" L", lpq_len);
+      }
+      for (uint8_t e = 1; e < HOTENDS; e++) {
+        SERIAL_ECHOPAIR("  M218 T", (int)e);
+        SERIAL_ECHOPAIR(" X", hotend_offset[X_AXIS]);
+        SERIAL_ECHOPAIR(" Y", hotend_offset[Y_AXIS]);
+        #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_EXTRUDER)
+          SERIAL_ECHOPAIR(" Z", hotend_offset[Z_AXIS]);
         #endif
         SERIAL_EOL;
       }
-    #endif // PIDTEMP
+    #endif
 
-    #if ENABLED(PIDTEMPBED)
-      CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M304 P", thermalManager.bedKp);
-      SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bedKi));
-      SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bedKd));
+    #if ENABLED(MESH_BED_LEVELING)
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Mesh bed leveling:");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M420 S", mbl.has_mesh() ? 1 : 0);
+      SERIAL_ECHOPAIR(" X", MESH_NUM_X_POINTS);
+      SERIAL_ECHOPAIR(" Y", MESH_NUM_Y_POINTS);
       SERIAL_EOL;
+      for (uint8_t py = 1; py <= MESH_NUM_Y_POINTS; py++) {
+        for (uint8_t px = 1; px <= MESH_NUM_X_POINTS; px++) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  G29 S3 X", (int)px);
+          SERIAL_ECHOPAIR(" Y", (int)py);
+          SERIAL_ECHOPGM(" Z");
+          SERIAL_PROTOCOL_F(mbl.z_values[py-1][px-1], 5);
+          SERIAL_EOL;
+        }
+      }
     #endif
 
-  #endif // PIDTEMP || PIDTEMPBED
+    #if ENABLED(DELTA)
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Endstop adjustment (mm):");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M666 X", endstop_adj[X_AXIS]);
+      SERIAL_ECHOPAIR(" Y", endstop_adj[Y_AXIS]);
+      SERIAL_ECHOPAIR(" Z", endstop_adj[Z_AXIS]);
+      SERIAL_EOL;
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Delta settings: L=diagonal_rod, R=radius, S=segments_per_second, ABC=diagonal_rod_trim_tower_[123]");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M665 L", delta_diagonal_rod);
+      SERIAL_ECHOPAIR(" R", delta_radius);
+      SERIAL_ECHOPAIR(" S", delta_segments_per_second);
+      SERIAL_ECHOPAIR(" A", delta_diagonal_rod_trim_tower_1);
+      SERIAL_ECHOPAIR(" B", delta_diagonal_rod_trim_tower_2);
+      SERIAL_ECHOPAIR(" C", delta_diagonal_rod_trim_tower_3);
+      SERIAL_EOL;
+    #elif ENABLED(Z_DUAL_ENDSTOPS)
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Z2 Endstop adjustment (mm):");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M666 Z", z_endstop_adj);
+      SERIAL_EOL;
+    #endif // DELTA
 
-  #if HAS_LCD_CONTRAST
-    CONFIG_ECHO_START;
-    if (!forReplay) {
-      SERIAL_ECHOLNPGM("LCD Contrast:");
+    #if ENABLED(ULTIPANEL)
       CONFIG_ECHO_START;
-    }
-    SERIAL_ECHOPAIR("  M250 C", lcd_contrast);
-    SERIAL_EOL;
-  #endif
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Material heatup parameters:");
+        CONFIG_ECHO_START;
+      }
+      for (uint8_t i = 0; i < COUNT(lcd_preheat_hotend_temp); i++) {
+        SERIAL_ECHOPAIR("  M145 S", (int)i);
+        SERIAL_ECHOPAIR(" H", lcd_preheat_hotend_temp[i]);
+        SERIAL_ECHOPAIR(" B", lcd_preheat_bed_temp[i]);
+        SERIAL_ECHOPAIR(" F", lcd_preheat_fan_speed[i]);
+        SERIAL_EOL;
+      }
+    #endif // ULTIPANEL
 
-  #if ENABLED(FWRETRACT)
+    #if HAS_PID_HEATING
 
-    CONFIG_ECHO_START;
-    if (!forReplay) {
-      SERIAL_ECHOLNPGM("Retract: S=Length (mm) F:Speed (mm/m) Z: ZLift (mm)");
       CONFIG_ECHO_START;
-    }
-    SERIAL_ECHOPAIR("  M207 S", retract_length);
-    #if EXTRUDERS > 1
-      SERIAL_ECHOPAIR(" W", retract_length_swap);
-    #endif
-    SERIAL_ECHOPAIR(" F", MMS_TO_MMM(retract_feedrate_mm_s));
-    SERIAL_ECHOPAIR(" Z", retract_zlift);
-    SERIAL_EOL;
-    CONFIG_ECHO_START;
-    if (!forReplay) {
-      SERIAL_ECHOLNPGM("Recover: S=Extra length (mm) F:Speed (mm/m)");
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("PID settings:");
+      }
+      #if ENABLED(PIDTEMP)
+        #if HOTENDS > 1
+          if (forReplay) {
+            HOTEND_LOOP() {
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR("  M301 E", e);
+              SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
+              SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
+              SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
+              #if ENABLED(PID_EXTRUSION_SCALING)
+                SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
+                if (e == 0) SERIAL_ECHOPAIR(" L", lpq_len);
+              #endif
+              SERIAL_EOL;
+            }
+          }
+          else
+        #endif // HOTENDS > 1
+        // !forReplay || HOTENDS == 1
+        {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
+          SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
+          SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
+            SERIAL_ECHOPAIR(" L", lpq_len);
+          #endif
+          SERIAL_EOL;
+        }
+      #endif // PIDTEMP
+
+      #if ENABLED(PIDTEMPBED)
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR("  M304 P", thermalManager.bedKp);
+        SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bedKi));
+        SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bedKd));
+        SERIAL_EOL;
+      #endif
+
+    #endif // PIDTEMP || PIDTEMPBED
+
+    #if HAS_LCD_CONTRAST
       CONFIG_ECHO_START;
-    }
-    SERIAL_ECHOPAIR("  M208 S", retract_recover_length);
-    #if EXTRUDERS > 1
-      SERIAL_ECHOPAIR(" W", retract_recover_length_swap);
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("LCD Contrast:");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M250 C", lcd_contrast);
+      SERIAL_EOL;
     #endif
-    SERIAL_ECHOPAIR(" F", MMS_TO_MMM(retract_recover_feedrate_mm_s));
-    SERIAL_EOL;
-    CONFIG_ECHO_START;
-    if (!forReplay) {
-      SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret extrude-only moves as retracts or recoveries");
-      CONFIG_ECHO_START;
-    }
-    SERIAL_ECHOPAIR("  M209 S", autoretract_enabled ? 1 : 0);
-    SERIAL_EOL;
 
-  #endif // FWRETRACT
+    #if ENABLED(FWRETRACT)
 
-  /**
-   * Volumetric extrusion M200
-   */
-  if (!forReplay) {
-    CONFIG_ECHO_START;
-    SERIAL_ECHOPGM("Filament settings:");
-    if (volumetric_enabled)
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Retract: S=Length (mm) F:Speed (mm/m) Z: ZLift (mm)");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M207 S", retract_length);
+      #if EXTRUDERS > 1
+        SERIAL_ECHOPAIR(" W", retract_length_swap);
+      #endif
+      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(retract_feedrate_mm_s));
+      SERIAL_ECHOPAIR(" Z", retract_zlift);
       SERIAL_EOL;
-    else
-      SERIAL_ECHOLNPGM(" Disabled");
-  }
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Recover: S=Extra length (mm) F:Speed (mm/m)");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M208 S", retract_recover_length);
+      #if EXTRUDERS > 1
+        SERIAL_ECHOPAIR(" W", retract_recover_length_swap);
+      #endif
+      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(retract_recover_feedrate_mm_s));
+      SERIAL_EOL;
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret extrude-only moves as retracts or recoveries");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M209 S", autoretract_enabled ? 1 : 0);
+      SERIAL_EOL;
+
+    #endif // FWRETRACT
+
+    /**
+     * Volumetric extrusion M200
+     */
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPGM("Filament settings:");
+      if (volumetric_enabled)
+        SERIAL_EOL;
+      else
+        SERIAL_ECHOLNPGM(" Disabled");
+    }
 
-  CONFIG_ECHO_START;
-  SERIAL_ECHOPAIR("  M200 D", filament_size[0]);
-  SERIAL_EOL;
-  #if EXTRUDERS > 1
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M200 T1 D", filament_size[1]);
+    SERIAL_ECHOPAIR("  M200 D", filament_size[0]);
     SERIAL_EOL;
-    #if EXTRUDERS > 2
+    #if EXTRUDERS > 1
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M200 T2 D", filament_size[2]);
+      SERIAL_ECHOPAIR("  M200 T1 D", filament_size[1]);
       SERIAL_EOL;
-      #if EXTRUDERS > 3
+      #if EXTRUDERS > 2
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M200 T3 D", filament_size[3]);
+        SERIAL_ECHOPAIR("  M200 T2 D", filament_size[2]);
         SERIAL_EOL;
+        #if EXTRUDERS > 3
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  M200 T3 D", filament_size[3]);
+          SERIAL_EOL;
+        #endif
       #endif
     #endif
-  #endif
 
-  if (!volumetric_enabled) {
-    CONFIG_ECHO_START;
-    SERIAL_ECHOLNPGM("  M200 D0");
-  }
-
-  /**
-   * Auto Bed Leveling
-   */
-  #if HAS_BED_PROBE
-    if (!forReplay) {
+    if (!volumetric_enabled) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Z-Probe Offset (mm):");
+      SERIAL_ECHOLNPGM("  M200 D0");
     }
-    CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M851 Z", zprobe_zoffset);
-    SERIAL_EOL;
-  #endif
-}
+
+    /**
+     * Auto Bed Leveling
+     */
+    #if HAS_BED_PROBE
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Z-Probe Offset (mm):");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M851 Z", zprobe_zoffset);
+      SERIAL_EOL;
+    #endif
+  }
 
 #endif // !DISABLE_M503
diff --git a/Marlin/configuration_store.h b/Marlin/configuration_store.h
index 891f19f..7279dc4 100644
--- a/Marlin/configuration_store.h
+++ b/Marlin/configuration_store.h
@@ -26,6 +26,7 @@
 #include "MarlinConfig.h"
 
 void Config_ResetDefault();
+void Config_StoreSettings();
 
 #if DISABLED(DISABLE_M503)
   void Config_PrintSettings(bool forReplay=false);
@@ -34,10 +35,8 @@ void Config_ResetDefault();
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
-  void Config_StoreSettings();
   void Config_RetrieveSettings();
 #else
-  FORCE_INLINE void Config_StoreSettings() {}
   FORCE_INLINE void Config_RetrieveSettings() { Config_ResetDefault(); Config_PrintSettings(); }
 #endif
 
diff --git a/Marlin/dac_mcp4728.cpp b/Marlin/dac_mcp4728.cpp
index 01e38ed..2124a80 100644
--- a/Marlin/dac_mcp4728.cpp
+++ b/Marlin/dac_mcp4728.cpp
@@ -31,10 +31,11 @@
  */
 
 #include "dac_mcp4728.h"
+#include "enum.h"
 
 #if ENABLED(DAC_STEPPER_CURRENT)
 
-uint16_t     mcp4728_values[4];
+uint16_t mcp4728_values[XYZE];
 
 /**
  * Begin I2C, get current values (input register and eeprom) of mcp4728
@@ -42,16 +43,13 @@ uint16_t     mcp4728_values[4];
 void mcp4728_init() {
   Wire.begin();
   Wire.requestFrom(int(DAC_DEV_ADDRESS), 24);
-  while(Wire.available()) {
-    int deviceID = Wire.read();
-    int hiByte = Wire.read();
-    int loByte = Wire.read();
-
-    int isEEPROM = (deviceID & 0B00001000) >> 3;
-    int channel = (deviceID & 0B00110000) >> 4;
-    if (isEEPROM != 1) {
-      mcp4728_values[channel] = word((hiByte & 0B00001111), loByte);
-    }
+  while (Wire.available()) {
+    char deviceID = Wire.read(),
+         hiByte = Wire.read(),
+         loByte = Wire.read();
+
+    if (!(deviceID & 0x08))
+      mcp4728_values[(deviceID & 0x30) >> 4] = word((hiByte & 0x0F), loByte);
   }
 }
 
@@ -63,6 +61,7 @@ uint8_t mcp4728_analogWrite(uint8_t channel, uint16_t value) {
   mcp4728_values[channel] = value;
   return mcp4728_fastWrite();
 }
+
 /**
  * Write all input resistor values to EEPROM using SequencialWrite method.
  * This will update both input register and EEPROM value
@@ -71,9 +70,9 @@ uint8_t mcp4728_analogWrite(uint8_t channel, uint16_t value) {
 uint8_t mcp4728_eepromWrite() {
   Wire.beginTransmission(DAC_DEV_ADDRESS);
   Wire.write(SEQWRITE);
-  for (uint8_t channel=0; channel <= 3; channel++) {
-    Wire.write(DAC_STEPPER_VREF << 7 | 0 << 5 | DAC_STEPPER_GAIN << 4 | highByte(mcp4728_values[channel]));
-    Wire.write(lowByte(mcp4728_values[channel]));
+  LOOP_XYZE(i) {
+    Wire.write(DAC_STEPPER_VREF << 7 | DAC_STEPPER_GAIN << 4 | highByte(mcp4728_values[i]));
+    Wire.write(lowByte(mcp4728_values[i]));
   }
   return Wire.endTransmission();
 }
@@ -83,7 +82,7 @@ uint8_t mcp4728_eepromWrite() {
  */
 uint8_t mcp4728_setVref_all(uint8_t value) {
   Wire.beginTransmission(DAC_DEV_ADDRESS);
-  Wire.write(VREFWRITE | value << 3 | value << 2 | value << 1 | value);
+  Wire.write(VREFWRITE | (value ? 0x0F : 0x00));
   return Wire.endTransmission();
 }
 /**
@@ -91,12 +90,12 @@ uint8_t mcp4728_setVref_all(uint8_t value) {
  */
 uint8_t mcp4728_setGain_all(uint8_t value) {
   Wire.beginTransmission(DAC_DEV_ADDRESS);
-  Wire.write(GAINWRITE | value << 3 | value << 2 | value << 1 | value);
+  Wire.write(GAINWRITE | (value ? 0x0F : 0x00));
   return Wire.endTransmission();
 }
 
 /**
- * Return Input Regiter value
+ * Return Input Register value
  */
 uint16_t mcp4728_getValue(uint8_t channel) { return mcp4728_values[channel]; }
 
@@ -105,23 +104,37 @@ uint16_t mcp4728_getValue(uint8_t channel) { return mcp4728_values[channel]; }
  * Return Vout
  *
 uint16_t mcp4728_getVout(uint8_t channel) {
-  uint32_t vref = 2048;
-  uint32_t vOut = (vref * mcp4728_values[channel] * (_DAC_STEPPER_GAIN + 1)) / 4096;
+  uint32_t vref = 2048,
+           vOut = (vref * mcp4728_values[channel] * (_DAC_STEPPER_GAIN + 1)) / 4096;
   if (vOut > defaultVDD) vOut = defaultVDD;
   return vOut;
 }
 */
 
 /**
+ * Returns DAC values as a 0-100 percentage of drive strength
+ */
+uint16_t mcp4728_getDrvPct(uint8_t channel) { return uint16_t(100.0 * mcp4728_values[channel] / (DAC_STEPPER_MAX) + 0.5); }
+
+/**
+ * Receives all Drive strengths as 0-100 percent values, updates
+ * DAC Values array and calls fastwrite to update the DAC.
+ */
+void mcp4728_setDrvPct(uint16_t pct[XYZE]) {
+  LOOP_XYZE(i) mcp4728_values[i] = 0.01 * pct[i] * (DAC_STEPPER_MAX);
+  mcp4728_fastWrite();
+}
+
+/**
  * FastWrite input register values - All DAC ouput update. refer to DATASHEET 5.6.1
  * DAC Input and PowerDown bits update.
  * No EEPROM update
  */
 uint8_t mcp4728_fastWrite() {
   Wire.beginTransmission(DAC_DEV_ADDRESS);
-  for (uint8_t channel=0; channel <= 3; channel++) {
-    Wire.write(highByte(mcp4728_values[channel]));
-    Wire.write(lowByte(mcp4728_values[channel]));
+  LOOP_XYZE(i) {
+    Wire.write(highByte(mcp4728_values[i]));
+    Wire.write(lowByte(mcp4728_values[i]));
   }
   return Wire.endTransmission();
 }
diff --git a/Marlin/dac_mcp4728.h b/Marlin/dac_mcp4728.h
index c096c85..a1e3e35 100644
--- a/Marlin/dac_mcp4728.h
+++ b/Marlin/dac_mcp4728.h
@@ -24,15 +24,15 @@
  * Arduino library for MicroChip MCP4728 I2C D/A converter.
  */
 
-#ifndef mcp4728_h
-#define mcp4728_h
+#ifndef DAC_MCP4728_H
+#define DAC_MCP4728_H
 
 #include "MarlinConfig.h"
 
 #if ENABLED(DAC_STEPPER_CURRENT)
 #include "Wire.h"
 
-#define defaultVDD     5000
+#define defaultVDD     DAC_STEPPER_MAX //was 5000 but differs with internal Vref
 #define BASE_ADDR      0x60
 #define RESET          0B00000110
 #define WAKE           0B00001001
@@ -59,7 +59,8 @@ uint8_t mcp4728_setGain_all(uint8_t value);
 uint16_t mcp4728_getValue(uint8_t channel);
 uint8_t mcp4728_fastWrite();
 uint8_t mcp4728_simpleCommand(byte simpleCommand);
+uint16_t mcp4728_getDrvPct(uint8_t channel);
+void mcp4728_setDrvPct(uint16_t pct[XYZE]);
 
 #endif
-#endif
-
+#endif // DAC_MCP4728_H
diff --git a/Marlin/endstops.cpp b/Marlin/endstops.cpp
index 5cbc382..53e8b20 100644
--- a/Marlin/endstops.cpp
+++ b/Marlin/endstops.cpp
@@ -201,6 +201,10 @@ void Endstops::M119() {
     SERIAL_PROTOCOLPGM(MSG_Z_MIN);
     SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
+  #if HAS_Z2_MIN
+    SERIAL_PROTOCOLPGM(MSG_Z2_MIN);
+    SERIAL_PROTOCOLLN(((READ(Z2_MIN_PIN)^Z2_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
   #if HAS_Z_MAX
     SERIAL_PROTOCOLPGM(MSG_Z_MAX);
     SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
@@ -218,10 +222,9 @@ void Endstops::M119() {
 #if ENABLED(Z_DUAL_ENDSTOPS)
 
   // Pass the result of the endstop test
-  void Endstops::test_dual_z_endstops(EndstopEnum es1, EndstopEnum es2) {
+  void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
-    if (stepper.current_block->steps[Z_AXIS] > 0) {
-      stepper.endstop_triggered(Z_AXIS);
+    if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
       SBI(endstop_hit_bits, Z_MIN);
       if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
         stepper.kill_current_block();
@@ -233,24 +236,38 @@ void Endstops::M119() {
 // Check endstops - Called from ISR!
 void Endstops::update() {
 
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
   #define _ENDSTOP_HIT(AXIS) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MIN))
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
-  // COPY_BIT: copy the value of COPY_BIT to BIT in bits
-  #define COPY_BIT(bits, COPY_BIT, BIT) SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
+  // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
+  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
-  #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
+  #define _UPDATE_ENDSTOP(AXIS,MINMAX,CODE) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
       if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
         _ENDSTOP_HIT(AXIS); \
         stepper.endstop_triggered(_AXIS(AXIS)); \
+        CODE; \
       } \
     } while(0)
 
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN)  // If G38 command then check Z_MIN for every axis and every direction  
+
+    #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
+        _UPDATE_ENDSTOP(AXIS,MINMAX,NOOP); \
+        if (G38_move) _UPDATE_ENDSTOP(Z, MIN, G38_endstop_hit = true); \
+      } while(0)
+
+  #else	
+
+    #define UPDATE_ENDSTOP(AXIS,MINMAX) _UPDATE_ENDSTOP(AXIS,MINMAX,NOOP)
+
+  #endif
+
   #if ENABLED(COREXY) || ENABLED(COREXZ)
     // Head direction in -X axis for CoreXY and CoreXZ bots.
     // If DeltaA == -DeltaB, the movement is only in Y or Z axis
@@ -315,7 +332,7 @@ void Endstops::update() {
   #else
       if (stepper.motor_direction(Z_AXIS))
   #endif
-      { // z -direction
+      { // Z -direction. Gantry down, bed up.
         #if HAS_Z_MIN
 
           #if ENABLED(Z_DUAL_ENDSTOPS)
@@ -341,6 +358,7 @@ void Endstops::update() {
 
         #endif // HAS_Z_MIN
 
+        // When closing the gap check the enabled probe
         #if ENABLED(Z_MIN_PROBE_ENDSTOP)
           if (z_probe_enabled) {
             UPDATE_ENDSTOP(Z, MIN_PROBE);
@@ -348,9 +366,10 @@ void Endstops::update() {
           }
         #endif
       }
-      else { // z +direction
+      else { // Z +direction. Gantry up, bed down.
         #if HAS_Z_MAX
 
+          // Check both Z dual endstops
           #if ENABLED(Z_DUAL_ENDSTOPS)
 
             UPDATE_ENDSTOP_BIT(Z, MAX);
@@ -362,11 +381,13 @@ void Endstops::update() {
 
             test_dual_z_endstops(Z_MAX, Z2_MAX);
 
-          #else // !Z_DUAL_ENDSTOPS
+          // If this pin is not hijacked for the bed probe
+          // then it belongs to the Z endstop
+          #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
 
             UPDATE_ENDSTOP(Z, MAX);
 
-          #endif // !Z_DUAL_ENDSTOPS
+          #endif // !Z_MIN_PROBE_PIN...
         #endif // Z_MAX_PIN
       }
   #if ENABLED(COREXZ)
diff --git a/Marlin/endstops.h b/Marlin/endstops.h
index 22c2468..4f2ce9e 100644
--- a/Marlin/endstops.h
+++ b/Marlin/endstops.h
@@ -86,7 +86,7 @@ class Endstops {
   private:
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      static void test_dual_z_endstops(EndstopEnum es1, EndstopEnum es2);
+      static void test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2);
     #endif
 };
 
diff --git a/Marlin/enum.h b/Marlin/enum.h
index 18db5a6..713f3b6 100644
--- a/Marlin/enum.h
+++ b/Marlin/enum.h
@@ -23,6 +23,8 @@
 #ifndef __ENUM_H__
 #define __ENUM_H__
 
+#include "MarlinConfig.h"
+
 /**
  * Axis indices as enumerated constants
  *
diff --git a/Marlin/example_configurations/Cartesio/Configuration.h b/Marlin/example_configurations/Cartesio/Configuration.h
index 434b6a1..fcb7ee6 100644
--- a/Marlin/example_configurations/Cartesio/Configuration.h
+++ b/Marlin/example_configurations/Cartesio/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(MaukCC, CartesioE)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 #define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 115200
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -170,14 +179,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -282,7 +299,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -330,8 +346,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
     //24V 500W silicone heater on to 4mm glass CartesioW
     #define  DEFAULT_bedKp 390
     #define  DEFAULT_bedKi 70
@@ -478,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   1000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -499,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -721,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -816,7 +840,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (10*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
diff --git a/Marlin/example_configurations/Cartesio/Configuration_adv.h b/Marlin/example_configurations/Cartesio/Configuration_adv.h
index fb5a2eb..0cef74a 100644
--- a/Marlin/example_configurations/Cartesio/Configuration_adv.h
+++ b/Marlin/example_configurations/Cartesio/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN 7
-#define EXTRUDER_1_AUTO_FAN_PIN 7
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+//#define E0_AUTO_FAN_PIN -1
+//#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 35
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/Felix/Configuration.h b/Marlin/example_configurations/Felix/Configuration.h
index 88e11f0..3683a40 100644
--- a/Marlin/example_configurations/Felix/Configuration.h
+++ b/Marlin/example_configurations/Felix/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  #define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Felix 2.0+ electronics with v4 Hotend
@@ -317,8 +333,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   // Felix Foil Heater
   #define DEFAULT_bedKp 103.37
   #define DEFAULT_bedKi 2.79
@@ -461,13 +475,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.3
 #define DEFAULT_EJERK                  5.0
 
@@ -482,7 +497,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -704,69 +719,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 180
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 180
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -799,7 +823,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -827,8 +850,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index 6ebe50e..7139ac1 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/Felix/DUAL/Configuration.h b/Marlin/example_configurations/Felix/DUAL/Configuration.h
index 36bcb64..cf5585a 100644
--- a/Marlin/example_configurations/Felix/DUAL/Configuration.h
+++ b/Marlin/example_configurations/Felix/DUAL/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  #define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Felix 2.0+ electronics with v4 Hotend
@@ -459,13 +475,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.3
 #define DEFAULT_EJERK                  5.0
 
@@ -480,7 +497,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -702,69 +719,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 180
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 180
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -797,7 +823,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
diff --git a/Marlin/example_configurations/Hephestos/Configuration.h b/Marlin/example_configurations/Hephestos/Configuration.h
index dadaa2e..d5ebeff 100644
--- a/Marlin/example_configurations/Hephestos/Configuration.h
+++ b/Marlin/example_configurations/Hephestos/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 115200
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -172,14 +181,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -284,7 +301,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Hephestos i3
@@ -320,8 +336,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -470,13 +484,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   1000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -491,7 +506,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -713,69 +728,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -808,7 +832,6 @@
 #define HOMING_FEEDRATE_XY 2000
 #define HOMING_FEEDRATE_Z  150
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -836,8 +859,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 7113989..8f04e5e 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 1.75
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration.h b/Marlin/example_configurations/Hephestos_2/Configuration.h
index 03f3d6e..d8835d0 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "@jbrazio" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 #define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 250  // If the temperature difference between the target temperature and the actual temperature
                                     // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Tuned PID values using M303
@@ -322,8 +338,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -472,13 +486,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   1000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  2.0
 
@@ -493,7 +508,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -715,69 +730,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION  X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER
+  #define RIGHT_PROBE_BED_POSITION X_MAX_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
+  #define FRONT_PROBE_BED_POSITION Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
+  #define BACK_PROBE_BED_POSITION  Y_MAX_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
 
-    #define LEFT_PROBE_BED_POSITION  X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER
-    #define RIGHT_PROBE_BED_POSITION X_MAX_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
-    #define FRONT_PROBE_BED_POSITION Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
-    #define BACK_PROBE_BED_POSITION  Y_MAX_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER
+  #define ABL_PROBE_PT_1_Y Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
+  #define ABL_PROBE_PT_2_X X_MAX_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
+  #define ABL_PROBE_PT_2_Y Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
+  #define ABL_PROBE_PT_3_X ((X_MIN_POS + X_MAX_POS) / 2)
+  #define ABL_PROBE_PT_3_Y Y_MAX_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER
-    #define ABL_PROBE_PT_1_Y Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
-    #define ABL_PROBE_PT_2_X X_MAX_POS - (X_PROBE_OFFSET_FROM_EXTRUDER)
-    #define ABL_PROBE_PT_2_Y Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER
-    #define ABL_PROBE_PT_3_X ((X_MIN_POS + X_MAX_POS) / 2)
-    #define ABL_PROBE_PT_3_Y Y_MAX_POS - (Y_PROBE_OFFSET_FROM_EXTRUDER)
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -810,7 +834,6 @@
 #define HOMING_FEEDRATE_XY (150*60)
 #define HOMING_FEEDRATE_Z  200
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -838,8 +861,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
index 4a426c6..b221ab7 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN 11
-#define EXTRUDER_1_AUTO_FAN_PIN  6
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+//#define E0_AUTO_FAN_PIN -1
+//#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/K8200/Configuration.h b/Marlin/example_configurations/K8200/Configuration.h
index 08ee867..0c9aab1 100644
--- a/Marlin/example_configurations/K8200/Configuration.h
+++ b/Marlin/example_configurations/K8200/Configuration.h
@@ -95,8 +95,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(K8200, @CONSULitAS)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -112,14 +112,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -176,14 +185,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -288,7 +305,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -339,8 +355,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   //#define  DEFAULT_bedKp 10.00
@@ -495,13 +509,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   1000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -516,7 +531,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -738,69 +753,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -833,7 +857,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -861,8 +884,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index 34d12ec..8ea34fc 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -211,15 +211,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -507,9 +514,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -538,6 +556,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 3
 
@@ -559,7 +583,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 32 // maximize block buffer
 #endif
@@ -810,4 +834,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/K8400/Configuration.h b/Marlin/example_configurations/K8400/Configuration.h
index 31bef4e..5851622 100644
--- a/Marlin/example_configurations/K8400/Configuration.h
+++ b/Marlin/example_configurations/K8400/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(Anthony Birkett, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -478,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.5
 #define DEFAULT_EJERK                 20.0
 
@@ -499,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -721,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -816,7 +840,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (8*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
diff --git a/Marlin/example_configurations/K8400/Configuration_adv.h b/Marlin/example_configurations/K8400/Configuration_adv.h
index 463f173..3cc822c 100644
--- a/Marlin/example_configurations/K8400/Configuration_adv.h
+++ b/Marlin/example_configurations/K8400/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/K8400/Dual-head/Configuration.h b/Marlin/example_configurations/K8400/Dual-head/Configuration.h
index ac8e2c2..4fd1a9f 100644
--- a/Marlin/example_configurations/K8400/Dual-head/Configuration.h
+++ b/Marlin/example_configurations/K8400/Dual-head/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(Anthony Birkett, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -478,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.5
 #define DEFAULT_EJERK                 20.0
 
@@ -499,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -721,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -816,7 +840,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (8*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
diff --git a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
index 928051c..16517f8 100644
--- a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
+++ b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "RepRapWorld.com" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -478,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -499,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -721,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -816,7 +840,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -844,8 +867,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/RigidBot/Configuration.h b/Marlin/example_configurations/RigidBot/Configuration.h
index 435e018..7310bf6 100644
--- a/Marlin/example_configurations/RigidBot/Configuration.h
+++ b/Marlin/example_configurations/RigidBot/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 115200
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -172,14 +181,22 @@
 #define HOTEND_OFFSET_X {0.0, 36.00} // (in mm) for each extruder, offset of the hotend on the X axis
 #define HOTEND_OFFSET_Y {0.0, 0.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -284,7 +301,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -332,8 +348,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //RigidBot, from pid autotune
   #define  DEFAULT_bedKp 355
   #define  DEFAULT_bedKi 66.5
@@ -476,13 +490,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                8.0
+#define DEFAULT_XJERK                 8.0
+#define DEFAULT_YJERK                 8.0
 #define DEFAULT_ZJERK                 0.4
 #define DEFAULT_EJERK                 5.0
 
@@ -497,7 +512,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -719,69 +734,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -814,7 +838,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (15*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -842,8 +865,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/RigidBot/Configuration_adv.h b/Marlin/example_configurations/RigidBot/Configuration_adv.h
index 191f1b8..71166d4 100644
--- a/Marlin/example_configurations/RigidBot/Configuration_adv.h
+++ b/Marlin/example_configurations/RigidBot/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 1.75
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/SCARA/Configuration.h b/Marlin/example_configurations/SCARA/Configuration.h
index 99ceb67..38686f7 100644
--- a/Marlin/example_configurations/SCARA/Configuration.h
+++ b/Marlin/example_configurations/SCARA/Configuration.h
@@ -120,8 +120,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -137,14 +137,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -201,14 +210,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -313,7 +330,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 20 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Merlin Hotend: From Autotune
@@ -349,8 +365,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //12v Heatbed Mk3 12V in parallel
   //from pidautotune
   #define  DEFAULT_bedKp 630.14
@@ -493,13 +507,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   400    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                5.0
+#define DEFAULT_XJERK                 5.0
+#define DEFAULT_YJERK                 5.0
 #define DEFAULT_ZJERK                 0.4
 #define DEFAULT_EJERK                 3.0
 
@@ -514,7 +529,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -736,69 +751,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -831,7 +855,6 @@
 #define HOMING_FEEDRATE_XY (40*60)
 #define HOMING_FEEDRATE_Z  (10*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -859,8 +882,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index 7bc8880..706f412 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 1.75
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/TAZ4/Configuration.h b/Marlin/example_configurations/TAZ4/Configuration.h
index 3f62c57..11cccd8 100644
--- a/Marlin/example_configurations/TAZ4/Configuration.h
+++ b/Marlin/example_configurations/TAZ4/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(Aleph Objects, Inc, TAZ  config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 16 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -338,8 +354,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //24V 360W silicone heater from NPH on 3mm borosilicate (TAZ 2.2+)
   #define  DEFAULT_bedKp 20
   #define  DEFAULT_bedKi 5
@@ -499,13 +513,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                 8.0
+#define DEFAULT_XJERK                  8.0
+#define DEFAULT_YJERK                  8.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                 10.0
 
@@ -520,7 +535,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -742,69 +757,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -837,7 +861,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (8*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -865,8 +888,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/TAZ4/Configuration_adv.h b/Marlin/example_configurations/TAZ4/Configuration_adv.h
index 7d42064..2a39074 100644
--- a/Marlin/example_configurations/TAZ4/Configuration_adv.h
+++ b/Marlin/example_configurations/TAZ4/Configuration_adv.h
@@ -213,15 +213,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -509,9 +516,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -540,6 +558,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -561,7 +585,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -812,4 +836,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/WITBOX/Configuration.h b/Marlin/example_configurations/WITBOX/Configuration.h
index 672b88f..6010d6d 100644
--- a/Marlin/example_configurations/WITBOX/Configuration.h
+++ b/Marlin/example_configurations/WITBOX/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(bq Witbox)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 115200
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -172,14 +181,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -284,7 +301,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Witbox
@@ -320,8 +336,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -470,13 +484,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                10.0
+#define DEFAULT_XJERK                 10.0
+#define DEFAULT_YJERK                 10.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -491,7 +506,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -713,69 +728,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -808,7 +832,6 @@
 #define HOMING_FEEDRATE_XY (120*60)
 #define HOMING_FEEDRATE_Z  432
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -836,8 +859,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 7113989..8f04e5e 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 1.75
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/adafruit/ST7565/Configuration.h b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
index 2186bd7..aa764bb 100644
--- a/Marlin/example_configurations/adafruit/ST7565/Configuration.h
+++ b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -478,13 +492,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -499,7 +514,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -721,69 +736,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -816,7 +840,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -844,8 +867,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration.h b/Marlin/example_configurations/delta/biv2.5/Configuration.h
index 1795c41..934ac34 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -429,6 +443,8 @@
   // in ultralcd.cpp@lcd_delta_calibrate_menu()
   //#define DELTA_CALIBRATION_MENU
 
+  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+
 #endif
 
 // Enable this option for Toshiba steppers
@@ -521,13 +537,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                15.0
+#define DEFAULT_XJERK                 15.0
+#define DEFAULT_YJERK                 15.0
 #define DEFAULT_ZJERK                 15.0 // Must be same as XY for delta
 #define DEFAULT_EJERK                  5.0
 
@@ -542,7 +559,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -614,16 +631,16 @@
   #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z 100.0
   #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE XY_PROBE_SPEED
 
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X Z_PROBE_ALLEN_KEY_DEPLOY_2_X * 0.75
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y Z_PROBE_ALLEN_KEY_DEPLOY_2_Y * 0.75
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE XY_PROBE_SPEED
-
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X 45.00 // Move right to trigger deploy pin
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y -125.00
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z 100.0
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE (XY_PROBE_SPEED)/2
 
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X Z_PROBE_ALLEN_KEY_DEPLOY_3_X * 0.75
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y Z_PROBE_ALLEN_KEY_DEPLOY_3_Y * 0.75
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE XY_PROBE_SPEED
+
   #define Z_PROBE_ALLEN_KEY_STOW_1_X 36.00 // Line up with bed retaining clip
   #define Z_PROBE_ALLEN_KEY_STOW_1_Y -122.00
   #define Z_PROBE_ALLEN_KEY_STOW_1_Z 75.0
@@ -811,73 +828,80 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode.
+  // Set the number of grid points per dimension.
+  // Works best with 5 or more points in each dimension.
+  #define ABL_GRID_POINTS_X 9
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
+  #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
 
-    // Set the rectangle in which to probe.
-    #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
-    #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
-    #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Non-linear bed leveling will be used.
-    // Compensate by interpolating between the nearest four Z probe values for each point.
-    // Useful for deltas where the print surface may appear like a bowl or dome shape.
-    // Works best with 5 or more points in each dimension.
-    #define ABL_GRID_POINTS_X 9
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -906,11 +930,9 @@
   #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
 #endif
 
-
 // Delta only homes to Z
 #define HOMING_FEEDRATE_Z  (200*30)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -938,8 +960,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
index b4efc00..0a00369 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins.
+ * Override those here. Set to -1 to disable unused fans.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -503,9 +510,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -534,6 +552,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -555,7 +579,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -806,4 +830,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index 57d30de..5a647e6 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -429,6 +443,8 @@
   // in ultralcd.cpp@lcd_delta_calibrate_menu()
   //#define DELTA_CALIBRATION_MENU
 
+  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+
 #endif
 
 // Enable this option for Toshiba steppers
@@ -521,13 +537,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                 20.0 // Must be same as XY for delta
 #define DEFAULT_EJERK                  5.0
 
@@ -542,7 +559,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -805,73 +822,80 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode.
+  // Set the number of grid points per dimension.
+  // Works best with 5 or more points in each dimension.
+  #define ABL_GRID_POINTS_X 9
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
+  #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
 
-    // Set the rectangle in which to probe
-    #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
-    #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
-    #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Non-linear bed leveling will be used.
-    // Compensate by interpolating between the nearest four Z probe values for each point.
-    // Useful for deltas where the print surface may appear like a bowl or dome shape.
-    // Works best with 5 or more points in each dimension.
-    #define ABL_GRID_POINTS_X 9
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -900,11 +924,9 @@
   #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
 #endif
 
-
 // Delta only homes to Z
 #define HOMING_FEEDRATE_Z  (200*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -932,8 +954,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index 2960f84..009fad3 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -503,9 +510,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -534,6 +552,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -555,7 +579,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -806,4 +830,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
index 56a206a..2b0a385 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -328,8 +344,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -429,6 +443,8 @@
   // in ultralcd.cpp@lcd_delta_calibrate_menu()
   //#define DELTA_CALIBRATION_MENU
 
+  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+
 #endif
 
 // Enable this option for Toshiba steppers
@@ -521,13 +537,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                 20.0 // Must be same as XY for delta
 #define DEFAULT_EJERK                  5.0
 
@@ -542,7 +559,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -808,73 +825,80 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode.
+  // Set the number of grid points per dimension.
+  // Works best with 5 or more points in each dimension.
+  #define ABL_GRID_POINTS_X 9
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
+  #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
 
-    // Set the rectangle in which to probe
-    #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
-    #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
-    #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Non-linear bed leveling will be used.
-    // Compensate by interpolating between the nearest four Z probe values for each point.
-    // Useful for deltas where the print surface may appear like a bowl or dome shape.
-    // Works best with 5 or more points in each dimension.
-    #define ABL_GRID_POINTS_X 9
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -903,11 +927,9 @@
   #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
 #endif
 
-
 // Delta only homes to Z
 #define HOMING_FEEDRATE_Z  (200*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -935,8 +957,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index 9936c54..009fad3 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -364,6 +371,7 @@
 #define DEFAULT_MINSEGMENTTIME        20000
 
 // If defined the movements slow down when the look ahead buffer is only half full
+// (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
 //#define SLOWDOWN
 
 // Frequency limit
@@ -502,9 +510,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -533,6 +552,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -554,7 +579,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -805,4 +830,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
index 06b2766..c5df135 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -94,8 +94,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -111,14 +111,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 115200
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -175,14 +184,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -287,7 +304,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 50 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // Kossel Pro
@@ -323,8 +339,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //Kossel Pro heated bed plate with borosilicate glass
   //from pidautotune (M303 E-1 S60 C8)
   #define  DEFAULT_bedKp 370.25
@@ -418,6 +432,8 @@
   // in ultralcd.cpp@lcd_delta_calibrate_menu()
   //#define DELTA_CALIBRATION_MENU
 
+  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+
 #endif
 
 // Enable this option for Toshiba steppers
@@ -517,13 +533,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                 20.0 // Must be same as XY for delta
 #define DEFAULT_EJERK                  5.0
 
@@ -538,7 +555,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -617,10 +634,10 @@
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE XY_PROBE_SPEED
 
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X 45.00 // Move right to trigger deploy pin
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y -125.00
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE (XY_PROBE_SPEED)/2
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X 45.00 // Move right to trigger deploy pin
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y -125.00
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE (XY_PROBE_SPEED)/2
 
   #define Z_PROBE_ALLEN_KEY_STOW_1_X 36.00 // Line up with bed retaining clip
   #define Z_PROBE_ALLEN_KEY_STOW_1_Y -125.00
@@ -809,73 +826,80 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+  // Set the number of grid points per dimension.
+  // Works best with 5 or more points in each dimension.
+  #define ABL_GRID_POINTS_X 7
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode.
+  // Set the boundaries for probing (where the probe can reach).
+  #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS-25)
+  #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    // Set the rectangle in which to probe
-    #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS-25)
-    #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
-    #define FRONT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-    // Non-linear bed leveling will be used.
-    // Compensate by interpolating between the nearest four Z probe values for each point.
-    // Useful for deltas where the print surface may appear like a bowl or dome shape.
-    // Works best with 5 or more points in each dimension.
-    #define ABL_GRID_POINTS_X 7
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-  #else  // !AUTO_BED_LEVELING_GRID
-
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -904,7 +928,6 @@
   #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).
 #endif
 
-
 // Delta only homes to Z
 #define HOMING_FEEDRATE_Z  (200*60)
 
@@ -935,8 +958,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index 9c82b1f..33aed46 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -210,15 +210,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -369,6 +376,7 @@
 #define DEFAULT_MINSEGMENTTIME        20000
 
 // If defined the movements slow down when the look ahead buffer is only half full
+// (don't use SLOWDOWN with DELTA because DELTA generates hundreds of segments per second)
 //#define SLOWDOWN
 
 // Frequency limit
@@ -507,9 +515,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -538,6 +557,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -559,7 +584,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -810,4 +835,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration.h b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
index f2992d1..81f6aa8 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
@@ -81,8 +81,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(oxivanisher)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -98,14 +98,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -162,14 +171,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 2
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  #define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -274,7 +291,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -326,8 +342,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 15.00
@@ -427,6 +441,8 @@
   // in ultralcd.cpp@lcd_delta_calibrate_menu()
   //#define DELTA_CALIBRATION_MENU
 
+  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+
 #endif
 
 // Enable this option for Toshiba steppers
@@ -527,13 +543,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                 20.0
 #define DEFAULT_EJERK                 20.0
 
@@ -548,7 +565,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -811,73 +828,80 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID  // Deltas only support grid mode.
+  // Set the number of grid points per dimension.
+  // Works best with 5 or more points in each dimension.
+  #define ABL_GRID_POINTS_X 5
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
+  #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
+  #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
+  #define FRONT_PROBE_BED_POSITION - (DELTA_PROBEABLE_RADIUS - 20)
+  #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS - 40
 
-    // Set the rectangle in which to probe
-    #define DELTA_PROBEABLE_RADIUS (DELTA_PRINTABLE_RADIUS - 10)
-    #define LEFT_PROBE_BED_POSITION -(DELTA_PROBEABLE_RADIUS)
-    #define RIGHT_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
-    #define FRONT_PROBE_BED_POSITION - (DELTA_PROBEABLE_RADIUS - 20)
-    #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS - 40
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Non-linear bed leveling will be used.
-    // Compensate by interpolating between the nearest four Z probe values for each point.
-    // Useful for deltas where the print surface may appear like a bowl or dome shape.
-    // Works best with 5 or more points in each dimension.
-    #define ABL_GRID_POINTS_X 5
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -909,7 +933,6 @@
 // Delta only homes to Z
 #define HOMING_FEEDRATE_Z  (60*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -937,8 +960,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index fc68cbc..70f035f 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -503,9 +510,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -534,6 +552,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -555,7 +579,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -806,4 +830,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/makibox/Configuration.h b/Marlin/example_configurations/makibox/Configuration.h
index c80bace..891ac9c 100644
--- a/Marlin/example_configurations/makibox/Configuration.h
+++ b/Marlin/example_configurations/makibox/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -331,8 +347,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -481,13 +495,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -502,7 +517,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -724,69 +739,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -819,7 +843,6 @@
 #define HOMING_FEEDRATE_XY 1500
 #define HOMING_FEEDRATE_Z  (2*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -847,8 +870,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index fc40866..279fa7e 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration.h b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
index 98b74a6..883f7df 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
@@ -88,8 +88,8 @@
 // build by the user have been successfully uploaded into firmware.
 #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
 #define SHOW_BOOTSCREEN
-#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during boot in line 1
-#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during boot in line 2
+#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1
+#define STRING_SPLASH_LINE2 WEBSITE_URL         // will be shown during bootup in line 2
 
 //
 // *** VENDORS PLEASE READ *****************************************************
@@ -105,14 +105,23 @@
 //#define SHOW_CUSTOM_BOOTSCREEN
 // @section machine
 
-// SERIAL_PORT selects which serial port should be used for communication with the host.
-// This allows the connection of wireless adapters (for instance) to non-default port pins.
-// Serial port 0 is still used by the Arduino bootloader regardless of this setting.
-// :[0,1,2,3,4,5,6,7]
+/**
+ * Select which serial port on the board will be used for communication with the host.
+ * This allows the connection of wireless adapters (for instance) to non-default port pins.
+ * Serial port 0 is always used by the Arduino bootloader regardless of this setting.
+ *
+ * :[0,1,2,3,4,5,6,7]
+ */
 #define SERIAL_PORT 0
 
-// This determines the communication speed of the printer
-// :[2400,9600,19200,38400,57600,115200,250000]
+/**
+ * This setting determines the communication speed of the printer.
+ *
+ * 250000 works in most cases, but you might try a lower speed if
+ * you commonly experience drop-outs during host printing.
+ *
+ * :[2400,9600,19200,38400,57600,115200,250000]
+ */
 #define BAUDRATE 250000
 
 // Enable the Bluetooth serial interface on AT90USB devices
@@ -169,14 +178,22 @@
 //#define HOTEND_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis
 //#define HOTEND_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis
 
-//// The following define selects which power supply you have. Please choose the one that matches your setup
-// 1 = ATX
-// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
-// :{1:'ATX',2:'X-Box 360'}
+/**
+ * Select your power supply here. Use 0 if you haven't connected the PS_ON_PIN
+ *
+ * 0 = No Power Switch
+ * 1 = ATX
+ * 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)
+ *
+ * :{0:'No power switch',1:'ATX',2:'X-Box 360'}
+ */
 #define POWER_SUPPLY 1
 
-// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.
-//#define PS_DEFAULT_OFF
+#if POWER_SUPPLY > 0
+  // Enable this option to leave the PSU off at startup.
+  // Power to steppers and heaters will need to be turned on with M80.
+  //#define PS_DEFAULT_OFF
+#endif
 
 // @section temperature
 
@@ -281,7 +298,6 @@
                                   // Set/get with gcode: M301 E[extruder number, 0-2]
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
                                   // is more than PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.
-  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term
   #define K1 0.95 //smoothing factor within the PID
 
   // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it
@@ -318,8 +334,6 @@
 
   //#define PID_BED_DEBUG // Sends debug data to the serial port.
 
-  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term
-
   //120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
   //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
   #define  DEFAULT_bedKp 10.00
@@ -474,13 +488,14 @@
 #define DEFAULT_TRAVEL_ACCELERATION   500    // X, Y, Z acceleration for travel (non printing) moves
 
 /**
- * Defult Jerk (mm/s)
+ * Default Jerk (mm/s)
  *
  * "Jerk" specifies the minimum speed change that requires acceleration.
  * When changing speed and direction, if the difference is less than the
  * value set here, it may happen instantaneously.
  */
-#define DEFAULT_XYJERK                20.0
+#define DEFAULT_XJERK                 20.0
+#define DEFAULT_YJERK                 20.0
 #define DEFAULT_ZJERK                  0.4
 #define DEFAULT_EJERK                  5.0
 
@@ -495,7 +510,7 @@
 // Probes are sensors/switches that are activated / deactivated before/after use.
 //
 // Allen Key Probes, Servo Probes, Z-Sled Probes, FIX_MOUNTED_PROBE, etc.
-// You must activate one of these to use AUTO_BED_LEVELING_FEATURE below.
+// You must activate one of these to use Auto Bed Leveling below.
 //
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
@@ -717,69 +732,78 @@
 #endif  // MESH_BED_LEVELING
 
 //===========================================================================
-//============================ Bed Auto Leveling ============================
+//============================ Auto Bed Leveling ============================
 //===========================================================================
-
 // @section bedlevel
 
-//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
+/**
+ * Select one form of Auto Bed Leveling below.
+ *
+ *  If you're also using the Probe for Z Homing, it's
+ *  highly recommended to enable Z_SAFE_HOMING also!
+ *
+ * - 3POINT
+ *   Probe 3 arbitrary points on the bed (that aren't collinear)
+ *   You specify the XY coordinates of all 3 points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - LINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a single tilted plane. Best for a flat bed.
+ *
+ * - BILINEAR
+ *   Probe several points in a grid.
+ *   You specify the rectangle and the density of sample points.
+ *   The result is a mesh, best for large or uneven beds.
+ */
+//#define AUTO_BED_LEVELING_3POINT
+//#define AUTO_BED_LEVELING_LINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 
-// Enable this feature to get detailed logging of G28, G29, M48, etc.
-// Logging is off by default. Enable this logging feature with 'M111 S32'.
-// NOTE: Requires a huge amount of PROGMEM.
+/**
+ * Enable detailed logging of G28, G29, M48, etc.
+ * Turn on with the command 'M111 S32'.
+ * NOTE: Requires a lot of PROGMEM!
+ */
 //#define DEBUG_LEVELING_FEATURE
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
-
-  // There are 2 different ways to specify probing locations:
-  //
-  // - "grid" mode
-  //   Probe several points in a rectangular grid.
-  //   You specify the rectangle and the density of sample points.
-  //   This mode is preferred because there are more measurements.
-  //
-  // - "3-point" mode
-  //   Probe 3 arbitrary points on the bed (that aren't collinear)
-  //   You specify the XY coordinates of all 3 points.
+#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-  // Enable this to sample the bed in a grid (least squares solution).
-  // Note: this feature generates 10KB extra code size.
-  #define AUTO_BED_LEVELING_GRID
+  // Set the number of grid points per dimension.
+  #define ABL_GRID_POINTS_X 3
+  #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
 
-  #if ENABLED(AUTO_BED_LEVELING_GRID)
+  // Set the boundaries for probing (where the probe can reach).
+  #define LEFT_PROBE_BED_POSITION 15
+  #define RIGHT_PROBE_BED_POSITION 170
+  #define FRONT_PROBE_BED_POSITION 20
+  #define BACK_PROBE_BED_POSITION 170
 
-    #define LEFT_PROBE_BED_POSITION 15
-    #define RIGHT_PROBE_BED_POSITION 170
-    #define FRONT_PROBE_BED_POSITION 20
-    #define BACK_PROBE_BED_POSITION 170
+  // The Z probe minimum outer margin (to validate G29 parameters).
+  #define MIN_PROBE_EDGE 10
 
-    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.
+  // Probe along the Y axis, advancing X after each column
+  //#define PROBE_Y_FIRST
 
-    // Set the number of grid points per dimension.
-    // You probably don't need more than 3 (squared=9).
-    #define ABL_GRID_POINTS_X 3
-    #define ABL_GRID_POINTS_Y ABL_GRID_POINTS_X
+#elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
-  #else  // !AUTO_BED_LEVELING_GRID
+  // 3 arbitrary points to probe.
+  // A simple cross-product is used to estimate the plane of the bed.
+  #define ABL_PROBE_PT_1_X 15
+  #define ABL_PROBE_PT_1_Y 180
+  #define ABL_PROBE_PT_2_X 15
+  #define ABL_PROBE_PT_2_Y 20
+  #define ABL_PROBE_PT_3_X 170
+  #define ABL_PROBE_PT_3_Y 20
 
-    // Arbitrary points to probe.
-    // A simple cross-product is used to estimate the plane of the bed.
-    #define ABL_PROBE_PT_1_X 15
-    #define ABL_PROBE_PT_1_Y 180
-    #define ABL_PROBE_PT_2_X 15
-    #define ABL_PROBE_PT_2_Y 20
-    #define ABL_PROBE_PT_3_X 170
-    #define ABL_PROBE_PT_3_Y 20
-
-  #endif // !AUTO_BED_LEVELING_GRID
-
-  //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
-                                                                             // Useful to retract a deployable Z probe.
-
-  // If you've enabled AUTO_BED_LEVELING_FEATURE and are using the Z Probe for Z Homing,
-  // it is highly recommended you also enable Z_SAFE_HOMING below!
+#endif
 
-#endif // AUTO_BED_LEVELING_FEATURE
+/**
+ * Commands to execute at the end of G29 probing.
+ * Useful to retract or move the Z probe out of the way.
+ */
+//#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10"
 
 
 // @section homing
@@ -812,7 +836,6 @@
 #define HOMING_FEEDRATE_XY (50*60)
 #define HOMING_FEEDRATE_Z  (4*60)
 
-
 //=============================================================================
 //============================= Additional Features ===========================
 //=============================================================================
@@ -840,8 +863,8 @@
 // When enabled Marlin will send a busy status message to the host
 // every couple of seconds when it can't accept commands.
 //
-#define HOST_KEEPALIVE_FEATURE       // Disable this if your host doesn't like keepalive messages
-#define DEFAULT_KEEPALIVE_INTERVAL 2 // Number of seconds between "busy" messages. Set with M113.
+#define HOST_KEEPALIVE_FEATURE        // Disable this if your host doesn't like keepalive messages
+#define DEFAULT_KEEPALIVE_INTERVAL 2  // Number of seconds between "busy" messages. Set with M113.
 
 //
 // M100 Free Memory Watcher
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index e6f1a7f..bea6cd5 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -205,15 +205,22 @@
 
 // @section extruder
 
-// Extruder cooling fans
-// Configure fan pin outputs to automatically turn on/off when the associated
-// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.
-// Multiple extruders can be assigned to the same pin in which case
-// the fan will turn on when any selected extruder is above the threshold.
-#define EXTRUDER_0_AUTO_FAN_PIN -1
-#define EXTRUDER_1_AUTO_FAN_PIN -1
-#define EXTRUDER_2_AUTO_FAN_PIN -1
-#define EXTRUDER_3_AUTO_FAN_PIN -1
+/**
+ * Extruder cooling fans
+ *
+ * Extruder auto fans automatically turn on when their extruders'
+ * temperatures go above EXTRUDER_AUTO_FAN_TEMPERATURE.
+ *
+ * Your board's pins file specifies the recommended pins. Override those here
+ * or set to -1 to disable completely.
+ *
+ * Multiple extruders can be assigned to the same pin in which case
+ * the fan will turn on when any selected extruder is above the threshold.
+ */
+#define E0_AUTO_FAN_PIN -1
+#define E1_AUTO_FAN_PIN -1
+#define E2_AUTO_FAN_PIN -1
+#define E3_AUTO_FAN_PIN -1
 #define EXTRUDER_AUTO_FAN_TEMPERATURE 50
 #define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed
 
@@ -501,9 +508,20 @@
   #define D_FILAMENT 2.85
 #endif
 
-// Implementation of a linear pressure control
-// Assumption: advance = k * (delta velocity)
-// K=0 means advance disabled. A good value for a gregs wade extruder will be around K=75
+/**
+ * Implementation of linear pressure control
+ *
+ * Assumption: advance = k * (delta velocity)
+ * K=0 means advance disabled.
+ * To get a rough start value for calibration, measure your "free filament length"
+ * between the hobbed bolt and the nozzle (in cm). Use the formula below that fits
+ * your setup, where L is the "free filament length":
+ *
+ * Filament diameter           |   1.75mm  |    3.0mm   |
+ * ----------------------------|-----------|------------|
+ * Stiff filament (PLA)        | K=47*L/10 | K=139*L/10 |
+ * Softer filament (ABS, nGen) | K=88*L/10 | K=260*L/10 |
+ */
 //#define LIN_ADVANCE
 
 #if ENABLED(LIN_ADVANCE)
@@ -532,6 +550,12 @@
 // Support for G5 with XYZE destination and IJPQ offsets. Requires ~2666 bytes.
 //#define BEZIER_CURVE_SUPPORT
 
+// G38.2 and G38.3 Probe Target
+//#define G38_PROBE_TARGET
+#if ENABLED(G38_PROBE_TARGET)
+  #define G38_MINIMUM_MOVE 0.0275 // minimum distance in mm that will produce a move (determined using the print statement in check_move)
+#endif
+
 // Moves (or segments) with fewer steps than this will be joined with the next move
 #define MIN_STEPS_PER_SEGMENT 6
 
@@ -553,7 +577,7 @@
 // The number of linear motions that can be in the plan at any give time.
 // THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.
 #if ENABLED(SDSUPPORT)
-  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller
+  #define BLOCK_BUFFER_SIZE 16 // SD,LCD,Buttons take more memory, block buffer needs to be smaller
 #else
   #define BLOCK_BUFFER_SIZE 16 // maximize block buffer
 #endif
@@ -804,4 +828,9 @@
 //#define EXPERIMENTAL_I2CBUS
 #define I2C_SLAVE_ADDRESS  0 // Set a value from 8 to 127 to act as a slave
 
+/**
+ * Add M43 command for pins info and testing
+ */
+//#define PINS_DEBUGGING
+
 #endif // CONFIGURATION_ADV_H
diff --git a/Marlin/fastio.h b/Marlin/fastio.h
index 1c21672..fff057a 100644
--- a/Marlin/fastio.h
+++ b/Marlin/fastio.h
@@ -79,7 +79,7 @@
 #define _GET_OUTPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) != 0)
 
 /// check if pin is an timer
-#define _GET_TIMER(IO)  ((DIO ## IO ## _PWM)
+#define _GET_TIMER(IO)  (DIO ## IO ## _PWM)
 
 //  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html
 
@@ -93,6 +93,8 @@
 
 /// set pin as input wrapper
 #define SET_INPUT(IO)  _SET_INPUT(IO)
+/// set pin as input with pullup wrapper
+#define SET_INPUT_PULLUP(IO) do{ _SET_INPUT(IO); _WRITE(IO, HIGH); }while(0)
 /// set pin as output wrapper
 #define SET_OUTPUT(IO)  _SET_OUTPUT(IO)
 
@@ -275,8 +277,6 @@
   #define DIO21_DDR   DDRC
   #define DIO21_PWM   NULL
 
-
-
   #undef PB0
   #define PB0_PIN     PINB0
   #define PB0_RPORT   PINB
@@ -2052,343 +2052,342 @@
     #define MOSI        DIO10  // 22
     #define SS          DIO8   // 20
 
-    #define DIO0_PIN        PINA0
-    #define DIO0_RPORT      PINA
-    #define DIO0_WPORT      PORTA
-    #define DIO0_PWM      NULL
-    #define DIO0_DDR        DDRA
-
-    #define DIO1_PIN        PINA1
-    #define DIO1_RPORT      PINA
-    #define DIO1_WPORT      PORTA
-    #define DIO1_PWM      NULL
-    #define DIO1_DDR        DDRA
-
-    #define DIO2_PIN        PINA2
-    #define DIO2_RPORT      PINA
-    #define DIO2_WPORT      PORTA
-    #define DIO2_PWM      NULL
-    #define DIO2_DDR        DDRA
-
-    #define DIO3_PIN        PINA3
-    #define DIO3_RPORT      PINA
-    #define DIO3_WPORT      PORTA
-    #define DIO3_PWM      NULL
-    #define DIO3_DDR        DDRA
-
-    #define DIO4_PIN        PINA4
-    #define DIO4_RPORT      PINA
-    #define DIO4_WPORT      PORTA
-    #define DIO4_PWM      NULL
-    #define DIO4_DDR        DDRA
-
-    #define DIO5_PIN        PINA5
-    #define DIO5_RPORT      PINA
-    #define DIO5_WPORT      PORTA
-    #define DIO5_PWM      NULL
-    #define DIO5_DDR        DDRA
-
-    #define DIO6_PIN        PINA6
-    #define DIO6_RPORT      PINA
-    #define DIO6_WPORT      PORTA
-    #define DIO6_PWM      NULL
-    #define DIO6_DDR        DDRA
-
-    #define DIO7_PIN        PINA7
-    #define DIO7_RPORT      PINA
-    #define DIO7_WPORT      PORTA
-    #define DIO7_PWM      NULL
-    #define DIO7_DDR        DDRA
-
-    #define DIO8_PIN        PINB0
-    #define DIO8_RPORT      PINB
-    #define DIO8_WPORT      PORTB
-    #define DIO8_PWM      NULL
-    #define DIO8_DDR        DDRB
-
-    #define DIO9_PIN        PINB1
-    #define DIO9_RPORT      PINB
-    #define DIO9_WPORT      PORTB
-    #define DIO9_PWM      NULL
-    #define DIO9_DDR        DDRB
-
-    #define DIO10_PIN       PINB2
-    #define DIO10_RPORT     PINB
-    #define DIO10_WPORT     PORTB
-    #define DIO10_PWM     NULL
-    #define DIO10_DDR       DDRB
-
-    #define DIO11_PIN       PINB3
-    #define DIO11_RPORT     PINB
-    #define DIO11_WPORT     PORTB
-    #define DIO11_PWM     NULL
-    #define DIO11_DDR       DDRB
-
-    #define DIO12_PIN       PINB4
-    #define DIO12_RPORT     PINB
-    #define DIO12_WPORT     PORTB
-    #define DIO12_PWM     NULL
-    #define DIO12_DDR       DDRB
-
-    #define DIO13_PIN       PINB5
-    #define DIO13_RPORT     PINB
-    #define DIO13_WPORT     PORTB
-    #define DIO13_PWM     NULL
-    #define DIO13_DDR       DDRB
-
-    #define DIO14_PIN       PINB6
-    #define DIO14_RPORT     PINB
-    #define DIO14_WPORT     PORTB
-    #define DIO14_PWM     NULL
-    #define DIO14_DDR       DDRB
-
-    #define DIO15_PIN       PINB7
-    #define DIO15_RPORT     PINB
-    #define DIO15_WPORT     PORTB
-    #define DIO15_PWM     NULL
-    #define DIO15_DDR       DDRB
-
-    #define DIO16_PIN       PINC0
-    #define DIO16_RPORT     PINC
-    #define DIO16_WPORT     PORTC
-    #define DIO16_PWM     NULL
-    #define DIO16_DDR       DDRC
-
-    #define DIO17_PIN       PINC1
-    #define DIO17_RPORT     PINC
-    #define DIO17_WPORT     PORTC
-    #define DIO17_PWM     NULL
-    #define DIO17_DDR       DDRC
-
-    #define DIO18_PIN       PINC2
-    #define DIO18_RPORT     PINC
-    #define DIO18_WPORT     PORTC
-    #define DIO18_PWM     NULL
-    #define DIO18_DDR       DDRC
-
-    #define DIO19_PIN       PINC3
-    #define DIO19_RPORT     PINC
-    #define DIO19_WPORT     PORTC
-    #define DIO19_PWM     NULL
-    #define DIO19_DDR       DDRC
-
-    #define DIO20_PIN       PINC4
-    #define DIO20_RPORT     PINC
-    #define DIO20_WPORT     PORTC
-    #define DIO20_PWM     NULL
-    #define DIO20_DDR       DDRC
-
-    #define DIO21_PIN       PINC5
-    #define DIO21_RPORT     PINC
-    #define DIO21_WPORT     PORTC
-    #define DIO21_PWM     NULL
-    #define DIO21_DDR       DDRC
-
-    #define DIO22_PIN       PINC6
-    #define DIO22_RPORT     PINC
-    #define DIO22_WPORT     PORTC
-    #define DIO22_PWM     NULL
-    #define DIO22_DDR       DDRC
-
-    #define DIO23_PIN       PINC7
-    #define DIO23_RPORT     PINC
-    #define DIO23_WPORT     PORTC
-    #define DIO23_PWM     NULL
-    #define DIO23_DDR       DDRC
-
-    #define DIO24_PIN       PIND0
-    #define DIO24_RPORT     PIND
-    #define DIO24_WPORT     PORTD
-    #define DIO24_PWM     NULL
-    #define DIO24_DDR       DDRD
-
-    #define DIO25_PIN       PIND1
-    #define DIO25_RPORT     PIND
-    #define DIO25_WPORT     PORTD
-    #define DIO25_PWM     NULL
-    #define DIO25_DDR       DDRD
-
-    #define DIO26_PIN       PIND2
-    #define DIO26_RPORT     PIND
-    #define DIO26_WPORT     PORTD
-    #define DIO26_PWM     NULL
-    #define DIO26_DDR       DDRD
-
-    #define DIO27_PIN       PIND3
-    #define DIO27_RPORT     PIND
-    #define DIO27_WPORT     PORTD
-    #define DIO27_PWM     NULL
-    #define DIO27_DDR       DDRD
-
-    #define DIO28_PIN       PIND4
-    #define DIO28_RPORT     PIND
-    #define DIO28_WPORT     PORTD
-    #define DIO28_PWM     NULL
-    #define DIO28_DDR       DDRD
-
-    #define DIO29_PIN       PIND5
-    #define DIO29_RPORT     PIND
-    #define DIO29_WPORT     PORTD
-    #define DIO29_PWM     NULL
-    #define DIO29_DDR       DDRD
-
-    #define DIO30_PIN       PIND6
-    #define DIO30_RPORT     PIND
-    #define DIO30_WPORT     PORTD
-    #define DIO30_PWM     NULL
-    #define DIO30_DDR       DDRD
-
-    #define DIO31_PIN       PIND7
-    #define DIO31_RPORT     PIND
-    #define DIO31_WPORT     PORTD
-    #define DIO31_PWM     NULL
-    #define DIO31_DDR       DDRD
-
-
-    #define DIO32_PIN       PINE0
-    #define DIO32_RPORT     PINE
-    #define DIO32_WPORT     PORTE
-    #define DIO32_PWM     NULL
-    #define DIO32_DDR       DDRE
-
-    #define DIO33_PIN       PINE1
-    #define DIO33_RPORT     PINE
-    #define DIO33_WPORT     PORTE
-    #define DIO33_PWM     NULL
-    #define DIO33_DDR       DDRE
-
-    #define DIO34_PIN       PINE2
-    #define DIO34_RPORT     PINE
-    #define DIO34_WPORT     PORTE
-    #define DIO34_PWM     NULL
-    #define DIO34_DDR       DDRE
-
-    #define DIO35_PIN       PINE3
-    #define DIO35_RPORT     PINE
-    #define DIO35_WPORT     PORTE
-    #define DIO35_PWM     NULL
-    #define DIO35_DDR       DDRE
-
-    #define DIO36_PIN       PINE4
-    #define DIO36_RPORT     PINE
-    #define DIO36_WPORT     PORTE
-    #define DIO36_PWM     NULL
-    #define DIO36_DDR       DDRE
-
-    #define DIO37_PIN       PINE5
-    #define DIO37_RPORT     PINE
-    #define DIO37_WPORT     PORTE
-    #define DIO37_PWM     NULL
-    #define DIO37_DDR       DDRE
-
-    #define DIO38_PIN       PINE6
-    #define DIO38_RPORT     PINE
-    #define DIO38_WPORT     PORTE
-    #define DIO38_PWM     NULL
-    #define DIO38_DDR       DDRE
-
-    #define DIO39_PIN       PINE7
-    #define DIO39_RPORT     PINE
-    #define DIO39_WPORT     PORTE
-    #define DIO39_PWM     NULL
-    #define DIO39_DDR       DDRE
-
-    #define AIO0_PIN PINF0
-    #define AIO0_RPORT PINF
-    #define AIO0_WPORT PORTF
-    #define AIO0_PWM      NULL
-    #define AIO0_DDR DDRF
-
-    #define AIO1_PIN PINF1
-    #define AIO1_RPORT PINF
-    #define AIO1_WPORT PORTF
-    #define AIO1_PWM      NULL
-    #define AIO1_DDR DDRF
-
-    #define AIO2_PIN PINF2
-    #define AIO2_RPORT PINF
-    #define AIO2_WPORT PORTF
-    #define AIO2_PWM      NULL
-    #define AIO2_DDR DDRF
-
-    #define AIO3_PIN PINF3
-    #define AIO3_RPORT PINF
-    #define AIO3_WPORT PORTF
-    #define AIO3_PWM      NULL
-    #define AIO3_DDR DDRF
-
-    #define AIO4_PIN PINF4
-    #define AIO4_RPORT PINF
-    #define AIO4_WPORT PORTF
-    #define AIO4_PWM      NULL
-    #define AIO4_DDR DDRF
-
-    #define AIO5_PIN PINF5
-    #define AIO5_RPORT PINF
-    #define AIO5_WPORT PORTF
-    #define AIO5_PWM      NULL
-    #define AIO5_DDR DDRF
-
-    #define AIO6_PIN PINF6
-    #define AIO6_RPORT PINF
-    #define AIO6_WPORT PORTF
-    #define AIO6_PWM      NULL
-    #define AIO6_DDR DDRF
-
-    #define AIO7_PIN PINF7
-    #define AIO7_RPORT PINF
-    #define AIO7_WPORT PORTF
-    #define AIO7_PWM      NULL
-    #define AIO7_DDR DDRF
-
-    #define DIO40_PIN       PINF0
-    #define DIO40_RPORT     PINF
-    #define DIO40_WPORT     PORTF
-    #define DIO40_PWM     NULL
-    #define DIO40_DDR       DDRF
-
-    #define DIO41_PIN       PINF1
-    #define DIO41_RPORT     PINF
-    #define DIO41_WPORT     PORTF
-    #define DIO41_PWM     NULL
-    #define DIO41_DDR       DDRF
-
-    #define DIO42_PIN       PINF2
-    #define DIO42_RPORT     PINF
-    #define DIO42_WPORT     PORTF
-    #define DIO42_PWM     NULL
-    #define DIO42_DDR       DDRF
-
-    #define DIO43_PIN       PINF3
-    #define DIO43_RPORT     PINF
-    #define DIO43_WPORT     PORTF
-    #define DIO43_PWM     NULL
-    #define DIO43_DDR       DDRF
-
-    #define DIO44_PIN       PINF4
-    #define DIO44_RPORT     PINF
-    #define DIO44_WPORT     PORTF
-    #define DIO44_PWM     NULL
-    #define DIO44_DDR       DDRF
-
-    #define DIO45_PIN       PINF5
-    #define DIO45_RPORT     PINF
-    #define DIO45_WPORT     PORTF
-    #define DIO45_PWM     NULL
-    #define DIO45_DDR       DDRF
-
-    #define DIO46_PIN       PINF6
-    #define DIO46_RPORT     PINF
-    #define DIO46_WPORT     PORTF
-    #define DIO46_PWM     NULL
-    #define DIO46_DDR       DDRF
-
-    #define DIO47_PIN       PINF7
-    #define DIO47_RPORT     PINF
-    #define DIO47_WPORT     PORTF
-    #define DIO47_PWM     NULL
-    #define DIO47_DDR       DDRF
+    #define DIO0_PIN    PINA0
+    #define DIO0_RPORT  PINA
+    #define DIO0_WPORT  PORTA
+    #define DIO0_PWM    NULL
+    #define DIO0_DDR    DDRA
+
+    #define DIO1_PIN    PINA1
+    #define DIO1_RPORT  PINA
+    #define DIO1_WPORT  PORTA
+    #define DIO1_PWM    NULL
+    #define DIO1_DDR    DDRA
+
+    #define DIO2_PIN    PINA2
+    #define DIO2_RPORT  PINA
+    #define DIO2_WPORT  PORTA
+    #define DIO2_PWM    NULL
+    #define DIO2_DDR    DDRA
+
+    #define DIO3_PIN    PINA3
+    #define DIO3_RPORT  PINA
+    #define DIO3_WPORT  PORTA
+    #define DIO3_PWM    NULL
+    #define DIO3_DDR    DDRA
+
+    #define DIO4_PIN    PINA4
+    #define DIO4_RPORT  PINA
+    #define DIO4_WPORT  PORTA
+    #define DIO4_PWM    NULL
+    #define DIO4_DDR    DDRA
+
+    #define DIO5_PIN    PINA5
+    #define DIO5_RPORT  PINA
+    #define DIO5_WPORT  PORTA
+    #define DIO5_PWM    NULL
+    #define DIO5_DDR    DDRA
+
+    #define DIO6_PIN    PINA6
+    #define DIO6_RPORT  PINA
+    #define DIO6_WPORT  PORTA
+    #define DIO6_PWM    NULL
+    #define DIO6_DDR    DDRA
+
+    #define DIO7_PIN    PINA7
+    #define DIO7_RPORT  PINA
+    #define DIO7_WPORT  PORTA
+    #define DIO7_PWM    NULL
+    #define DIO7_DDR    DDRA
+
+    #define DIO8_PIN    PINB0
+    #define DIO8_RPORT  PINB
+    #define DIO8_WPORT  PORTB
+    #define DIO8_PWM    NULL
+    #define DIO8_DDR    DDRB
+
+    #define DIO9_PIN    PINB1
+    #define DIO9_RPORT  PINB
+    #define DIO9_WPORT  PORTB
+    #define DIO9_PWM    NULL
+    #define DIO9_DDR    DDRB
+
+    #define DIO10_PIN   PINB2
+    #define DIO10_RPORT PINB
+    #define DIO10_WPORT PORTB
+    #define DIO10_PWM   NULL
+    #define DIO10_DDR   DDRB
+
+    #define DIO11_PIN   PINB3
+    #define DIO11_RPORT PINB
+    #define DIO11_WPORT PORTB
+    #define DIO11_PWM   NULL
+    #define DIO11_DDR   DDRB
+
+    #define DIO12_PIN   PINB4
+    #define DIO12_RPORT PINB
+    #define DIO12_WPORT PORTB
+    #define DIO12_PWM   NULL
+    #define DIO12_DDR   DDRB
+
+    #define DIO13_PIN   PINB5
+    #define DIO13_RPORT PINB
+    #define DIO13_WPORT PORTB
+    #define DIO13_PWM   NULL
+    #define DIO13_DDR   DDRB
+
+    #define DIO14_PIN   PINB6
+    #define DIO14_RPORT PINB
+    #define DIO14_WPORT PORTB
+    #define DIO14_PWM   NULL
+    #define DIO14_DDR   DDRB
+
+    #define DIO15_PIN   PINB7
+    #define DIO15_RPORT PINB
+    #define DIO15_WPORT PORTB
+    #define DIO15_PWM   NULL
+    #define DIO15_DDR   DDRB
+
+    #define DIO16_PIN   PINC0
+    #define DIO16_RPORT PINC
+    #define DIO16_WPORT PORTC
+    #define DIO16_PWM   NULL
+    #define DIO16_DDR   DDRC
+
+    #define DIO17_PIN   PINC1
+    #define DIO17_RPORT PINC
+    #define DIO17_WPORT PORTC
+    #define DIO17_PWM   NULL
+    #define DIO17_DDR   DDRC
+
+    #define DIO18_PIN   PINC2
+    #define DIO18_RPORT PINC
+    #define DIO18_WPORT PORTC
+    #define DIO18_PWM   NULL
+    #define DIO18_DDR   DDRC
+
+    #define DIO19_PIN   PINC3
+    #define DIO19_RPORT PINC
+    #define DIO19_WPORT PORTC
+    #define DIO19_PWM   NULL
+    #define DIO19_DDR   DDRC
+
+    #define DIO20_PIN   PINC4
+    #define DIO20_RPORT PINC
+    #define DIO20_WPORT PORTC
+    #define DIO20_PWM   NULL
+    #define DIO20_DDR   DDRC
+
+    #define DIO21_PIN   PINC5
+    #define DIO21_RPORT PINC
+    #define DIO21_WPORT PORTC
+    #define DIO21_PWM   NULL
+    #define DIO21_DDR   DDRC
+
+    #define DIO22_PIN   PINC6
+    #define DIO22_RPORT PINC
+    #define DIO22_WPORT PORTC
+    #define DIO22_PWM   NULL
+    #define DIO22_DDR   DDRC
+
+    #define DIO23_PIN   PINC7
+    #define DIO23_RPORT PINC
+    #define DIO23_WPORT PORTC
+    #define DIO23_PWM   NULL
+    #define DIO23_DDR   DDRC
+
+    #define DIO24_PIN   PIND0
+    #define DIO24_RPORT PIND
+    #define DIO24_WPORT PORTD
+    #define DIO24_PWM   NULL
+    #define DIO24_DDR   DDRD
+
+    #define DIO25_PIN   PIND1
+    #define DIO25_RPORT PIND
+    #define DIO25_WPORT PORTD
+    #define DIO25_PWM   NULL
+    #define DIO25_DDR   DDRD
+
+    #define DIO26_PIN   PIND2
+    #define DIO26_RPORT PIND
+    #define DIO26_WPORT PORTD
+    #define DIO26_PWM   NULL
+    #define DIO26_DDR   DDRD
+
+    #define DIO27_PIN   PIND3
+    #define DIO27_RPORT PIND
+    #define DIO27_WPORT PORTD
+    #define DIO27_PWM   NULL
+    #define DIO27_DDR   DDRD
+
+    #define DIO28_PIN   PIND4
+    #define DIO28_RPORT PIND
+    #define DIO28_WPORT PORTD
+    #define DIO28_PWM   NULL
+    #define DIO28_DDR   DDRD
+
+    #define DIO29_PIN   PIND5
+    #define DIO29_RPORT PIND
+    #define DIO29_WPORT PORTD
+    #define DIO29_PWM   NULL
+    #define DIO29_DDR   DDRD
+
+    #define DIO30_PIN   PIND6
+    #define DIO30_RPORT PIND
+    #define DIO30_WPORT PORTD
+    #define DIO30_PWM   NULL
+    #define DIO30_DDR   DDRD
+
+    #define DIO31_PIN   PIND7
+    #define DIO31_RPORT PIND
+    #define DIO31_WPORT PORTD
+    #define DIO31_PWM   NULL
+    #define DIO31_DDR   DDRD
+
+
+    #define DIO32_PIN   PINE0
+    #define DIO32_RPORT PINE
+    #define DIO32_WPORT PORTE
+    #define DIO32_PWM   NULL
+    #define DIO32_DDR   DDRE
+
+    #define DIO33_PIN   PINE1
+    #define DIO33_RPORT PINE
+    #define DIO33_WPORT PORTE
+    #define DIO33_PWM   NULL
+    #define DIO33_DDR   DDRE
+
+    #define DIO34_PIN   PINE2
+    #define DIO34_RPORT PINE
+    #define DIO34_WPORT PORTE
+    #define DIO34_PWM   NULL
+    #define DIO34_DDR   DDRE
+
+    #define DIO35_PIN   PINE3
+    #define DIO35_RPORT PINE
+    #define DIO35_WPORT PORTE
+    #define DIO35_PWM   NULL
+    #define DIO35_DDR   DDRE
+
+    #define DIO36_PIN   PINE4
+    #define DIO36_RPORT PINE
+    #define DIO36_WPORT PORTE
+    #define DIO36_PWM   NULL
+    #define DIO36_DDR   DDRE
+
+    #define DIO37_PIN   PINE5
+    #define DIO37_RPORT PINE
+    #define DIO37_WPORT PORTE
+    #define DIO37_PWM   NULL
+    #define DIO37_DDR   DDRE
+
+    #define DIO38_PIN   PINE6
+    #define DIO38_RPORT PINE
+    #define DIO38_WPORT PORTE
+    #define DIO38_PWM   NULL
+    #define DIO38_DDR   DDRE
+
+    #define DIO39_PIN   PINE7
+    #define DIO39_RPORT PINE
+    #define DIO39_WPORT PORTE
+    #define DIO39_PWM   NULL
+    #define DIO39_DDR   DDRE
+
+    #define AIO0_PIN    PINF0
+    #define AIO0_RPORT  PINF
+    #define AIO0_WPORT  PORTF
+    #define AIO0_PWM    NULL
+    #define AIO0_DDR    DDRF
+
+    #define AIO1_PIN    PINF1
+    #define AIO1_RPORT  PINF
+    #define AIO1_WPORT  PORTF
+    #define AIO1_PWM    NULL
+    #define AIO1_DDR    DDRF
+
+    #define AIO2_PIN    PINF2
+    #define AIO2_RPORT  PINF
+    #define AIO2_WPORT  PORTF
+    #define AIO2_PWM    NULL
+    #define AIO2_DDR    DDRF
+
+    #define AIO3_PIN    PINF3
+    #define AIO3_RPORT  PINF
+    #define AIO3_WPORT  PORTF
+    #define AIO3_PWM    NULL
+    #define AIO3_DDR    DDRF
+
+    #define AIO4_PIN    PINF4
+    #define AIO4_RPORT  PINF
+    #define AIO4_WPORT  PORTF
+    #define AIO4_PWM    NULL
+    #define AIO4_DDR    DDRF
+
+    #define AIO5_PIN    PINF5
+    #define AIO5_RPORT  PINF
+    #define AIO5_WPORT  PORTF
+    #define AIO5_PWM    NULL
+    #define AIO5_DDR    DDRF
+
+    #define AIO6_PIN    PINF6
+    #define AIO6_RPORT  PINF
+    #define AIO6_WPORT  PORTF
+    #define AIO6_PWM    NULL
+    #define AIO6_DDR    DDRF
+
+    #define AIO7_PIN    PINF7
+    #define AIO7_RPORT  PINF
+    #define AIO7_WPORT  PORTF
+    #define AIO7_PWM    NULL
+    #define AIO7_DDR    DDRF
+
+    #define DIO40_PIN   PINF0
+    #define DIO40_RPORT PINF
+    #define DIO40_WPORT PORTF
+    #define DIO40_PWM   NULL
+    #define DIO40_DDR   DDRF
+
+    #define DIO41_PIN   PINF1
+    #define DIO41_RPORT PINF
+    #define DIO41_WPORT PORTF
+    #define DIO41_PWM   NULL
+    #define DIO41_DDR   DDRF
+
+    #define DIO42_PIN   PINF2
+    #define DIO42_RPORT PINF
+    #define DIO42_WPORT PORTF
+    #define DIO42_PWM   NULL
+    #define DIO42_DDR   DDRF
 
+    #define DIO43_PIN   PINF3
+    #define DIO43_RPORT PINF
+    #define DIO43_WPORT PORTF
+    #define DIO43_PWM   NULL
+    #define DIO43_DDR   DDRF
+
+    #define DIO44_PIN   PINF4
+    #define DIO44_RPORT PINF
+    #define DIO44_WPORT PORTF
+    #define DIO44_PWM   NULL
+    #define DIO44_DDR   DDRF
+
+    #define DIO45_PIN   PINF5
+    #define DIO45_RPORT PINF
+    #define DIO45_WPORT PORTF
+    #define DIO45_PWM   NULL
+    #define DIO45_DDR   DDRF
+
+    #define DIO46_PIN   PINF6
+    #define DIO46_RPORT PINF
+    #define DIO46_WPORT PORTF
+    #define DIO46_PWM   NULL
+    #define DIO46_DDR   DDRF
+
+    #define DIO47_PIN   PINF7
+    #define DIO47_RPORT PINF
+    #define DIO47_WPORT PORTF
+    #define DIO47_PWM   NULL
+    #define DIO47_DDR   DDRF
 
 
     #undef PA0
@@ -2697,643 +2696,643 @@
     */
 
     // SPI
-    #define SCK             DIO21 // 9
-    #define MISO            DIO23 // 11
-    #define MOSI            DIO22 // 10
-    #define SS              DIO20 // 8
-
-    #define DIO0_PIN PIND0
-    #define DIO0_RPORT PIND
-    #define DIO0_WPORT PORTD
-    #define DIO0_PWM NULL
-    #define DIO0_DDR DDRD
-
-    #define DIO1_PIN PIND1
-    #define DIO1_RPORT PIND
-    #define DIO1_WPORT PORTD
-    #define DIO1_PWM NULL
-    #define DIO1_DDR DDRD
-
-    #define DIO2_PIN PIND2
-    #define DIO2_RPORT PIND
-    #define DIO2_WPORT PORTD
-    #define DIO2_PWM NULL
-    #define DIO2_DDR DDRD
-
-    #define DIO3_PIN PIND3
-    #define DIO3_RPORT PIND
-    #define DIO3_WPORT PORTD
-    #define DIO3_PWM NULL
-    #define DIO3_DDR DDRD
-
-    #define DIO4_PIN PIND4
-    #define DIO4_RPORT PIND
-    #define DIO4_WPORT PORTD
-    #define DIO4_PWM NULL
-    #define DIO4_DDR DDRD
-
-    #define DIO5_PIN PIND5
-    #define DIO5_RPORT PIND
-    #define DIO5_WPORT PORTD
-    #define DIO5_PWM NULL
-    #define DIO5_DDR DDRD
-
-    #define DIO6_PIN PIND6
-    #define DIO6_RPORT PIND
-    #define DIO6_WPORT PORTD
-    #define DIO6_PWM NULL
-    #define DIO6_DDR DDRD
-
-    #define DIO7_PIN PIND7
-    #define DIO7_RPORT PIND
-    #define DIO7_WPORT PORTD
-    #define DIO7_PWM NULL
-    #define DIO7_DDR DDRD
-
-    #define DIO8_PIN PINE0
-    #define DIO8_RPORT PINE
-    #define DIO8_WPORT PORTE
-    #define DIO8_PWM NULL
-    #define DIO8_DDR DDRE
-
-    #define DIO9_PIN PINE1
-    #define DIO9_RPORT PINE
-    #define DIO9_WPORT PORTE
-    #define DIO9_PWM NULL
-    #define DIO9_DDR DDRE
-
-    #define DIO10_PIN PINC0
+    #define SCK         DIO21 //  9
+    #define MISO        DIO23 // 11
+    #define MOSI        DIO22 // 10
+    #define SS          DIO20 //  8
+
+    #define DIO0_PIN    PIND0
+    #define DIO0_RPORT  PIND
+    #define DIO0_WPORT  PORTD
+    #define DIO0_PWM    NULL
+    #define DIO0_DDR    DDRD
+
+    #define DIO1_PIN    PIND1
+    #define DIO1_RPORT  PIND
+    #define DIO1_WPORT  PORTD
+    #define DIO1_PWM    NULL
+    #define DIO1_DDR    DDRD
+
+    #define DIO2_PIN    PIND2
+    #define DIO2_RPORT  PIND
+    #define DIO2_WPORT  PORTD
+    #define DIO2_PWM    NULL
+    #define DIO2_DDR    DDRD
+
+    #define DIO3_PIN    PIND3
+    #define DIO3_RPORT  PIND
+    #define DIO3_WPORT  PORTD
+    #define DIO3_PWM    NULL
+    #define DIO3_DDR    DDRD
+
+    #define DIO4_PIN    PIND4
+    #define DIO4_RPORT  PIND
+    #define DIO4_WPORT  PORTD
+    #define DIO4_PWM    NULL
+    #define DIO4_DDR    DDRD
+
+    #define DIO5_PIN    PIND5
+    #define DIO5_RPORT  PIND
+    #define DIO5_WPORT  PORTD
+    #define DIO5_PWM    NULL
+    #define DIO5_DDR    DDRD
+
+    #define DIO6_PIN    PIND6
+    #define DIO6_RPORT  PIND
+    #define DIO6_WPORT  PORTD
+    #define DIO6_PWM    NULL
+    #define DIO6_DDR    DDRD
+
+    #define DIO7_PIN    PIND7
+    #define DIO7_RPORT  PIND
+    #define DIO7_WPORT  PORTD
+    #define DIO7_PWM    NULL
+    #define DIO7_DDR    DDRD
+
+    #define DIO8_PIN    PINE0
+    #define DIO8_RPORT  PINE
+    #define DIO8_WPORT  PORTE
+    #define DIO8_PWM    NULL
+    #define DIO8_DDR    DDRE
+
+    #define DIO9_PIN    PINE1
+    #define DIO9_RPORT  PINE
+    #define DIO9_WPORT  PORTE
+    #define DIO9_PWM    NULL
+    #define DIO9_DDR    DDRE
+
+    #define DIO10_PIN   PINC0
     #define DIO10_RPORT PINC
     #define DIO10_WPORT PORTC
-    #define DIO10_PWM NULL
-    #define DIO10_DDR DDRC
+    #define DIO10_PWM   NULL
+    #define DIO10_DDR   DDRC
 
-    #define DIO11_PIN PINC1
+    #define DIO11_PIN   PINC1
     #define DIO11_RPORT PINC
     #define DIO11_WPORT PORTC
-    #define DIO11_PWM NULL
-    #define DIO11_DDR DDRC
+    #define DIO11_PWM   NULL
+    #define DIO11_DDR   DDRC
 
-    #define DIO12_PIN PINC2
+    #define DIO12_PIN   PINC2
     #define DIO12_RPORT PINC
     #define DIO12_WPORT PORTC
-    #define DIO12_PWM NULL
-    #define DIO12_DDR DDRC
+    #define DIO12_PWM   NULL
+    #define DIO12_DDR   DDRC
 
-    #define DIO13_PIN PINC3
+    #define DIO13_PIN   PINC3
     #define DIO13_RPORT PINC
     #define DIO13_WPORT PORTC
-    #define DIO13_PWM NULL
-    #define DIO13_DDR DDRC
+    #define DIO13_PWM   NULL
+    #define DIO13_DDR   DDRC
 
-    #define DIO14_PIN PINC4
+    #define DIO14_PIN   PINC4
     #define DIO14_RPORT PINC
     #define DIO14_WPORT PORTC
-    #define DIO14_PWM NULL
-    #define DIO14_DDR DDRC
+    #define DIO14_PWM   NULL
+    #define DIO14_DDR   DDRC
 
-    #define DIO15_PIN PINC5
+    #define DIO15_PIN   PINC5
     #define DIO15_RPORT PINC
     #define DIO15_WPORT PORTC
-    #define DIO15_PWM NULL
-    #define DIO15_DDR DDRC
+    #define DIO15_PWM   NULL
+    #define DIO15_DDR   DDRC
 
-    #define DIO16_PIN PINC6
+    #define DIO16_PIN   PINC6
     #define DIO16_RPORT PINC
     #define DIO16_WPORT PORTC
-    #define DIO16_PWM NULL
-    #define DIO16_DDR DDRC
+    #define DIO16_PWM   NULL
+    #define DIO16_DDR   DDRC
 
-    #define DIO17_PIN PINC7
+    #define DIO17_PIN   PINC7
     #define DIO17_RPORT PINC
     #define DIO17_WPORT PORTC
-    #define DIO17_PWM NULL
-    #define DIO17_DDR DDRC
+    #define DIO17_PWM   NULL
+    #define DIO17_DDR   DDRC
 
-    #define DIO18_PIN PINE6
+    #define DIO18_PIN   PINE6
     #define DIO18_RPORT PINE
     #define DIO18_WPORT PORTE
-    #define DIO18_PWM NULL
-    #define DIO18_DDR DDRE
+    #define DIO18_PWM   NULL
+    #define DIO18_DDR   DDRE
 
-    #define DIO19_PIN PINE7
+    #define DIO19_PIN   PINE7
     #define DIO19_RPORT PINE
     #define DIO19_WPORT PORTE
-    #define DIO19_PWM NULL
-    #define DIO19_DDR DDRE
+    #define DIO19_PWM   NULL
+    #define DIO19_DDR   DDRE
 
-    #define DIO20_PIN PINB0
+    #define DIO20_PIN   PINB0
     #define DIO20_RPORT PINB
     #define DIO20_WPORT PORTB
-    #define DIO20_PWM NULL
-    #define DIO20_DDR DDRB
+    #define DIO20_PWM   NULL
+    #define DIO20_DDR   DDRB
 
-    #define DIO21_PIN PINB1
+    #define DIO21_PIN   PINB1
     #define DIO21_RPORT PINB
     #define DIO21_WPORT PORTB
-    #define DIO21_PWM NULL
-    #define DIO21_DDR DDRB
+    #define DIO21_PWM   NULL
+    #define DIO21_DDR   DDRB
 
-    #define DIO22_PIN PINB2
+    #define DIO22_PIN   PINB2
     #define DIO22_RPORT PINB
     #define DIO22_WPORT PORTB
-    #define DIO22_PWM NULL
-    #define DIO22_DDR DDRB
+    #define DIO22_PWM   NULL
+    #define DIO22_DDR   DDRB
 
-    #define DIO23_PIN PINB3
+    #define DIO23_PIN   PINB3
     #define DIO23_RPORT PINB
     #define DIO23_WPORT PORTB
-    #define DIO23_PWM NULL
-    #define DIO23_DDR DDRB
+    #define DIO23_PWM   NULL
+    #define DIO23_DDR   DDRB
 
-    #define DIO24_PIN PINB4
+    #define DIO24_PIN   PINB4
     #define DIO24_RPORT PINB
     #define DIO24_WPORT PORTB
-    #define DIO24_PWM NULL
-    #define DIO24_DDR DDRB
+    #define DIO24_PWM   NULL
+    #define DIO24_DDR   DDRB
 
-    #define DIO25_PIN PINB5
+    #define DIO25_PIN   PINB5
     #define DIO25_RPORT PINB
     #define DIO25_WPORT PORTB
-    #define DIO25_PWM NULL
-    #define DIO25_DDR DDRB
+    #define DIO25_PWM   NULL
+    #define DIO25_DDR   DDRB
 
-    #define DIO26_PIN PINB6
+    #define DIO26_PIN   PINB6
     #define DIO26_RPORT PINB
     #define DIO26_WPORT PORTB
-    #define DIO26_PWM NULL
-    #define DIO26_DDR DDRB
+    #define DIO26_PWM   NULL
+    #define DIO26_DDR   DDRB
 
-    #define DIO27_PIN PINB7
+    #define DIO27_PIN   PINB7
     #define DIO27_RPORT PINB
     #define DIO27_WPORT PORTB
-    #define DIO27_PWM NULL
-    #define DIO27_DDR DDRB
+    #define DIO27_PWM   NULL
+    #define DIO27_DDR   DDRB
 
-    #define DIO28_PIN PINA0
+    #define DIO28_PIN   PINA0
     #define DIO28_RPORT PINA
     #define DIO28_WPORT PORTA
-    #define DIO28_PWM NULL
-    #define DIO28_DDR DDRA
+    #define DIO28_PWM   NULL
+    #define DIO28_DDR   DDRA
 
-    #define DIO29_PIN PINA1
+    #define DIO29_PIN   PINA1
     #define DIO29_RPORT PINA
     #define DIO29_WPORT PORTA
-    #define DIO29_PWM NULL
-    #define DIO29_DDR DDRA
+    #define DIO29_PWM   NULL
+    #define DIO29_DDR   DDRA
 
-    #define DIO30_PIN PINA2
+    #define DIO30_PIN   PINA2
     #define DIO30_RPORT PINA
     #define DIO30_WPORT PORTA
-    #define DIO30_PWM NULL
-    #define DIO30_DDR DDRA
+    #define DIO30_PWM   NULL
+    #define DIO30_DDR   DDRA
 
-    #define DIO31_PIN PINA3
+    #define DIO31_PIN   PINA3
     #define DIO31_RPORT PINA
     #define DIO31_WPORT PORTA
-    #define DIO31_PWM NULL
-    #define DIO31_DDR DDRA
+    #define DIO31_PWM   NULL
+    #define DIO31_DDR   DDRA
 
-    #define DIO32_PIN PINA4
+    #define DIO32_PIN   PINA4
     #define DIO32_RPORT PINA
     #define DIO32_WPORT PORTA
-    #define DIO32_PWM NULL
-    #define DIO32_DDR DDRA
+    #define DIO32_PWM   NULL
+    #define DIO32_DDR   DDRA
 
-    #define DIO33_PIN PINA5
+    #define DIO33_PIN   PINA5
     #define DIO33_RPORT PINA
     #define DIO33_WPORT PORTA
-    #define DIO33_PWM NULL
-    #define DIO33_DDR DDRA
+    #define DIO33_PWM   NULL
+    #define DIO33_DDR   DDRA
 
-    #define DIO34_PIN PINA6
+    #define DIO34_PIN   PINA6
     #define DIO34_RPORT PINA
     #define DIO34_WPORT PORTA
-    #define DIO34_PWM NULL
-    #define DIO34_DDR DDRA
+    #define DIO34_PWM   NULL
+    #define DIO34_DDR   DDRA
 
-    #define DIO35_PIN PINA7
+    #define DIO35_PIN   PINA7
     #define DIO35_RPORT PINA
     #define DIO35_WPORT PORTA
-    #define DIO35_PWM NULL
-    #define DIO35_DDR DDRA
+    #define DIO35_PWM   NULL
+    #define DIO35_DDR   DDRA
 
-    #define DIO36_PIN PINE4
+    #define DIO36_PIN   PINE4
     #define DIO36_RPORT PINE
     #define DIO36_WPORT PORTE
-    #define DIO36_PWM NULL
-    #define DIO36_DDR DDRE
+    #define DIO36_PWM   NULL
+    #define DIO36_DDR   DDRE
 
-    #define DIO37_PIN PINE5
+    #define DIO37_PIN   PINE5
     #define DIO37_RPORT PINE
     #define DIO37_WPORT PORTE
-    #define DIO37_PWM NULL
-    #define DIO37_DDR DDRE
+    #define DIO37_PWM   NULL
+    #define DIO37_DDR   DDRE
 
-    #define DIO38_PIN PINF0
+    #define DIO38_PIN   PINF0
     #define DIO38_RPORT PINF
     #define DIO38_WPORT PORTF
-    #define DIO38_PWM NULL
-    #define DIO38_DDR DDRF
+    #define DIO38_PWM   NULL
+    #define DIO38_DDR   DDRF
 
-    #define DIO39_PIN PINF1
+    #define DIO39_PIN   PINF1
     #define DIO39_RPORT PINF
     #define DIO39_WPORT PORTF
-    #define DIO39_PWM NULL
-    #define DIO39_DDR DDRF
+    #define DIO39_PWM   NULL
+    #define DIO39_DDR   DDRF
 
-    #define DIO40_PIN PINF2
+    #define DIO40_PIN   PINF2
     #define DIO40_RPORT PINF
     #define DIO40_WPORT PORTF
-    #define DIO40_PWM NULL
-    #define DIO40_DDR DDRF
+    #define DIO40_PWM   NULL
+    #define DIO40_DDR   DDRF
 
-    #define DIO41_PIN PINF3
+    #define DIO41_PIN   PINF3
     #define DIO41_RPORT PINF
     #define DIO41_WPORT PORTF
-    #define DIO41_PWM NULL
-    #define DIO41_DDR DDRF
+    #define DIO41_PWM   NULL
+    #define DIO41_DDR   DDRF
 
-    #define DIO42_PIN PINF4
+    #define DIO42_PIN   PINF4
     #define DIO42_RPORT PINF
     #define DIO42_WPORT PORTF
-    #define DIO42_PWM NULL
-    #define DIO42_DDR DDRF
+    #define DIO42_PWM   NULL
+    #define DIO42_DDR   DDRF
 
-    #define DIO43_PIN PINF5
+    #define DIO43_PIN   PINF5
     #define DIO43_RPORT PINF
     #define DIO43_WPORT PORTF
-    #define DIO43_PWM NULL
-    #define DIO43_DDR DDRF
+    #define DIO43_PWM   NULL
+    #define DIO43_DDR   DDRF
 
-    #define DIO44_PIN PINF6
+    #define DIO44_PIN   PINF6
     #define DIO44_RPORT PINF
     #define DIO44_WPORT PORTF
-    #define DIO44_PWM NULL
-    #define DIO44_DDR DDRF
+    #define DIO44_PWM   NULL
+    #define DIO44_DDR   DDRF
 
-    #define DIO45_PIN PINF7
+    #define DIO45_PIN   PINF7
     #define DIO45_RPORT PINF
     #define DIO45_WPORT PORTF
-    #define DIO45_PWM NULL
-    #define DIO45_DDR DDRF
-
-    #define AIO0_PIN PINF0
-    #define AIO0_RPORT PINF
-    #define AIO0_WPORT PORTF
-    #define AIO0_PWM NULL
-    #define AIO0_DDR DDRF
-
-    #define AIO1_PIN PINF1
-    #define AIO1_RPORT PINF
-    #define AIO1_WPORT PORTF
-    #define AIO1_PWM NULL
-    #define AIO1_DDR DDRF
-
-    #define AIO2_PIN PINF2
-    #define AIO2_RPORT PINF
-    #define AIO2_WPORT PORTF
-    #define AIO2_PWM NULL
-    #define AIO2_DDR DDRF
-
-    #define AIO3_PIN PINF3
-    #define AIO3_RPORT PINF
-    #define AIO3_WPORT PORTF
-    #define AIO3_PWM NULL
-    #define AIO3_DDR DDRF
-
-    #define AIO4_PIN PINF4
-    #define AIO4_RPORT PINF
-    #define AIO4_WPORT PORTF
-    #define AIO4_PWM NULL
-    #define AIO4_DDR DDRF
-
-    #define AIO5_PIN PINF5
-    #define AIO5_RPORT PINF
-    #define AIO5_WPORT PORTF
-    #define AIO5_PWM NULL
-    #define AIO5_DDR DDRF
-
-    #define AIO6_PIN PINF6
-    #define AIO6_RPORT PINF
-    #define AIO6_WPORT PORTF
-    #define AIO6_PWM NULL
-    #define AIO6_DDR DDRF
-
-    #define AIO7_PIN PINF7
-    #define AIO7_RPORT PINF
-    #define AIO7_WPORT PORTF
-    #define AIO7_PWM NULL
-    #define AIO7_DDR DDRF
+    #define DIO45_PWM   NULL
+    #define DIO45_DDR   DDRF
+
+    #define AIO0_PIN    PINF0
+    #define AIO0_RPORT  PINF
+    #define AIO0_WPORT  PORTF
+    #define AIO0_PWM    NULL
+    #define AIO0_DDR    DDRF
+
+    #define AIO1_PIN    PINF1
+    #define AIO1_RPORT  PINF
+    #define AIO1_WPORT  PORTF
+    #define AIO1_PWM    NULL
+    #define AIO1_DDR    DDRF
+
+    #define AIO2_PIN    PINF2
+    #define AIO2_RPORT  PINF
+    #define AIO2_WPORT  PORTF
+    #define AIO2_PWM    NULL
+    #define AIO2_DDR    DDRF
+
+    #define AIO3_PIN    PINF3
+    #define AIO3_RPORT  PINF
+    #define AIO3_WPORT  PORTF
+    #define AIO3_PWM    NULL
+    #define AIO3_DDR    DDRF
+
+    #define AIO4_PIN    PINF4
+    #define AIO4_RPORT  PINF
+    #define AIO4_WPORT  PORTF
+    #define AIO4_PWM    NULL
+    #define AIO4_DDR    DDRF
+
+    #define AIO5_PIN    PINF5
+    #define AIO5_RPORT  PINF
+    #define AIO5_WPORT  PORTF
+    #define AIO5_PWM    NULL
+    #define AIO5_DDR    DDRF
+
+    #define AIO6_PIN    PINF6
+    #define AIO6_RPORT  PINF
+    #define AIO6_WPORT  PORTF
+    #define AIO6_PWM    NULL
+    #define AIO6_DDR    DDRF
+
+    #define AIO7_PIN    PINF7
+    #define AIO7_RPORT  PINF
+    #define AIO7_WPORT  PORTF
+    #define AIO7_PWM    NULL
+    #define AIO7_DDR    DDRF
 
     //-- Begin not supported by Teensyduino
     //-- don't use Arduino functions on these pins pinMode/digitalWrite/etc
-    #define DIO46_PIN PINE2
+    #define DIO46_PIN   PINE2
     #define DIO46_RPORT PINE
     #define DIO46_WPORT PORTE
-    #define DIO46_PWM NULL
-    #define DIO46_DDR DDRE
+    #define DIO46_PWM   NULL
+    #define DIO46_DDR   DDRE
 
-    #define DIO47_PIN PINE3
+    #define DIO47_PIN   PINE3
     #define DIO47_RPORT PINE
     #define DIO47_WPORT PORTE
-    #define DIO47_PWM NULL
-    #define DIO47_DDR DDRE
+    #define DIO47_PWM   NULL
+    #define DIO47_DDR   DDRE
     //-- end not supported by Teensyduino
 
     #undef PA0
-    #define PA0_PIN PINA0
-    #define PA0_RPORT PINA
-    #define PA0_WPORT PORTA
-    #define PA0_PWM NULL
-    #define PA0_DDR DDRA
+    #define PA0_PIN     PINA0
+    #define PA0_RPORT   PINA
+    #define PA0_WPORT   PORTA
+    #define PA0_PWM     NULL
+    #define PA0_DDR     DDRA
     #undef PA1
-    #define PA1_PIN PINA1
-    #define PA1_RPORT PINA
-    #define PA1_WPORT PORTA
-    #define PA1_PWM NULL
-    #define PA1_DDR DDRA
+    #define PA1_PIN     PINA1
+    #define PA1_RPORT   PINA
+    #define PA1_WPORT   PORTA
+    #define PA1_PWM     NULL
+    #define PA1_DDR     DDRA
     #undef PA2
-    #define PA2_PIN PINA2
-    #define PA2_RPORT PINA
-    #define PA2_WPORT PORTA
-    #define PA2_PWM NULL
-    #define PA2_DDR DDRA
+    #define PA2_PIN     PINA2
+    #define PA2_RPORT   PINA
+    #define PA2_WPORT   PORTA
+    #define PA2_PWM     NULL
+    #define PA2_DDR     DDRA
     #undef PA3
-    #define PA3_PIN PINA3
-    #define PA3_RPORT PINA
-    #define PA3_WPORT PORTA
-    #define PA3_PWM NULL
-    #define PA3_DDR DDRA
+    #define PA3_PIN     PINA3
+    #define PA3_RPORT   PINA
+    #define PA3_WPORT   PORTA
+    #define PA3_PWM     NULL
+    #define PA3_DDR     DDRA
     #undef PA4
-    #define PA4_PIN PINA4
-    #define PA4_RPORT PINA
-    #define PA4_WPORT PORTA
-    #define PA4_PWM NULL
-    #define PA4_DDR DDRA
+    #define PA4_PIN     PINA4
+    #define PA4_RPORT   PINA
+    #define PA4_WPORT   PORTA
+    #define PA4_PWM     NULL
+    #define PA4_DDR     DDRA
     #undef PA5
-    #define PA5_PIN PINA5
-    #define PA5_RPORT PINA
-    #define PA5_WPORT PORTA
-    #define PA5_PWM NULL
-    #define PA5_DDR DDRA
+    #define PA5_PIN     PINA5
+    #define PA5_RPORT   PINA
+    #define PA5_WPORT   PORTA
+    #define PA5_PWM     NULL
+    #define PA5_DDR     DDRA
     #undef PA6
-    #define PA6_PIN PINA6
-    #define PA6_RPORT PINA
-    #define PA6_WPORT PORTA
-    #define PA6_PWM NULL
-    #define PA6_DDR DDRA
+    #define PA6_PIN     PINA6
+    #define PA6_RPORT   PINA
+    #define PA6_WPORT   PORTA
+    #define PA6_PWM     NULL
+    #define PA6_DDR     DDRA
     #undef PA7
-    #define PA7_PIN PINA7
-    #define PA7_RPORT PINA
-    #define PA7_WPORT PORTA
-    #define PA7_PWM NULL
-    #define PA7_DDR DDRA
+    #define PA7_PIN     PINA7
+    #define PA7_RPORT   PINA
+    #define PA7_WPORT   PORTA
+    #define PA7_PWM     NULL
+    #define PA7_DDR     DDRA
 
     #undef PB0
-    #define PB0_PIN PINB0
-    #define PB0_RPORT PINB
-    #define PB0_WPORT PORTB
-    #define PB0_PWM NULL
-    #define PB0_DDR DDRB
+    #define PB0_PIN     PINB0
+    #define PB0_RPORT   PINB
+    #define PB0_WPORT   PORTB
+    #define PB0_PWM     NULL
+    #define PB0_DDR     DDRB
     #undef PB1
-    #define PB1_PIN PINB1
-    #define PB1_RPORT PINB
-    #define PB1_WPORT PORTB
-    #define PB1_PWM NULL
-    #define PB1_DDR DDRB
+    #define PB1_PIN     PINB1
+    #define PB1_RPORT   PINB
+    #define PB1_WPORT   PORTB
+    #define PB1_PWM     NULL
+    #define PB1_DDR     DDRB
     #undef PB2
-    #define PB2_PIN PINB2
-    #define PB2_RPORT PINB
-    #define PB2_WPORT PORTB
-    #define PB2_PWM NULL
-    #define PB2_DDR DDRB
+    #define PB2_PIN     PINB2
+    #define PB2_RPORT   PINB
+    #define PB2_WPORT   PORTB
+    #define PB2_PWM     NULL
+    #define PB2_DDR     DDRB
     #undef PB3
-    #define PB3_PIN PINB3
-    #define PB3_RPORT PINB
-    #define PB3_WPORT PORTB
-    #define PB3_PWM NULL
-    #define PB3_DDR DDRB
+    #define PB3_PIN     PINB3
+    #define PB3_RPORT   PINB
+    #define PB3_WPORT   PORTB
+    #define PB3_PWM     NULL
+    #define PB3_DDR     DDRB
     #undef PB4
-    #define PB4_PIN PINB4
-    #define PB4_RPORT PINB
-    #define PB4_WPORT PORTB
-    #define PB4_PWM NULL
-    #define PB4_DDR DDRB
+    #define PB4_PIN     PINB4
+    #define PB4_RPORT   PINB
+    #define PB4_WPORT   PORTB
+    #define PB4_PWM     NULL
+    #define PB4_DDR     DDRB
     #undef PB5
-    #define PB5_PIN PINB5
-    #define PB5_RPORT PINB
-    #define PB5_WPORT PORTB
-    #define PB5_PWM NULL
-    #define PB5_DDR DDRB
+    #define PB5_PIN     PINB5
+    #define PB5_RPORT   PINB
+    #define PB5_WPORT   PORTB
+    #define PB5_PWM     NULL
+    #define PB5_DDR     DDRB
     #undef PB6
-    #define PB6_PIN PINB6
-    #define PB6_RPORT PINB
-    #define PB6_WPORT PORTB
-    #define PB6_PWM NULL
-    #define PB6_DDR DDRB
+    #define PB6_PIN     PINB6
+    #define PB6_RPORT   PINB
+    #define PB6_WPORT   PORTB
+    #define PB6_PWM     NULL
+    #define PB6_DDR     DDRB
     #undef PB7
-    #define PB7_PIN PINB7
-    #define PB7_RPORT PINB
-    #define PB7_WPORT PORTB
-    #define PB7_PWM NULL
-    #define PB7_DDR DDRB
+    #define PB7_PIN     PINB7
+    #define PB7_RPORT   PINB
+    #define PB7_WPORT   PORTB
+    #define PB7_PWM     NULL
+    #define PB7_DDR     DDRB
 
     #undef PC0
-    #define PC0_PIN PINC0
-    #define PC0_RPORT PINC
-    #define PC0_WPORT PORTC
-    #define PC0_PWM NULL
-    #define PC0_DDR DDRC
+    #define PC0_PIN     PINC0
+    #define PC0_RPORT   PINC
+    #define PC0_WPORT   PORTC
+    #define PC0_PWM     NULL
+    #define PC0_DDR     DDRC
     #undef PC1
-    #define PC1_PIN PINC1
-    #define PC1_RPORT PINC
-    #define PC1_WPORT PORTC
-    #define PC1_PWM NULL
-    #define PC1_DDR DDRC
+    #define PC1_PIN     PINC1
+    #define PC1_RPORT   PINC
+    #define PC1_WPORT   PORTC
+    #define PC1_PWM     NULL
+    #define PC1_DDR     DDRC
     #undef PC2
-    #define PC2_PIN PINC2
-    #define PC2_RPORT PINC
-    #define PC2_WPORT PORTC
-    #define PC2_PWM NULL
-    #define PC2_DDR DDRC
+    #define PC2_PIN     PINC2
+    #define PC2_RPORT   PINC
+    #define PC2_WPORT   PORTC
+    #define PC2_PWM     NULL
+    #define PC2_DDR     DDRC
     #undef PC3
-    #define PC3_PIN PINC3
-    #define PC3_RPORT PINC
-    #define PC3_WPORT PORTC
-    #define PC3_PWM NULL
-    #define PC3_DDR DDRC
+    #define PC3_PIN     PINC3
+    #define PC3_RPORT   PINC
+    #define PC3_WPORT   PORTC
+    #define PC3_PWM     NULL
+    #define PC3_DDR     DDRC
     #undef PC4
-    #define PC4_PIN PINC4
-    #define PC4_RPORT PINC
-    #define PC4_WPORT PORTC
-    #define PC4_PWM NULL
-    #define PC4_DDR DDRC
+    #define PC4_PIN     PINC4
+    #define PC4_RPORT   PINC
+    #define PC4_WPORT   PORTC
+    #define PC4_PWM     NULL
+    #define PC4_DDR     DDRC
     #undef PC5
-    #define PC5_PIN PINC5
-    #define PC5_RPORT PINC
-    #define PC5_WPORT PORTC
-    #define PC5_PWM NULL
-    #define PC5_DDR DDRC
+    #define PC5_PIN     PINC5
+    #define PC5_RPORT   PINC
+    #define PC5_WPORT   PORTC
+    #define PC5_PWM     NULL
+    #define PC5_DDR     DDRC
     #undef PC6
-    #define PC6_PIN PINC6
-    #define PC6_RPORT PINC
-    #define PC6_WPORT PORTC
-    #define PC6_PWM NULL
-    #define PC6_DDR DDRC
+    #define PC6_PIN     PINC6
+    #define PC6_RPORT   PINC
+    #define PC6_WPORT   PORTC
+    #define PC6_PWM     NULL
+    #define PC6_DDR     DDRC
     #undef PC7
-    #define PC7_PIN PINC7
-    #define PC7_RPORT PINC
-    #define PC7_WPORT PORTC
-    #define PC7_PWM NULL
-    #define PC7_DDR DDRC
+    #define PC7_PIN     PINC7
+    #define PC7_RPORT   PINC
+    #define PC7_WPORT   PORTC
+    #define PC7_PWM     NULL
+    #define PC7_DDR     DDRC
 
     #undef PD0
-    #define PD0_PIN PIND0
-    #define PD0_RPORT PIND
-    #define PD0_WPORT PORTD
-    #define PD0_PWM NULL
-    #define PD0_DDR DDRD
+    #define PD0_PIN     PIND0
+    #define PD0_RPORT   PIND
+    #define PD0_WPORT   PORTD
+    #define PD0_PWM     NULL
+    #define PD0_DDR     DDRD
     #undef PD1
-    #define PD1_PIN PIND1
-    #define PD1_RPORT PIND
-    #define PD1_WPORT PORTD
-    #define PD1_PWM NULL
-    #define PD1_DDR DDRD
+    #define PD1_PIN     PIND1
+    #define PD1_RPORT   PIND
+    #define PD1_WPORT   PORTD
+    #define PD1_PWM     NULL
+    #define PD1_DDR     DDRD
     #undef PD2
-    #define PD2_PIN PIND2
-    #define PD2_RPORT PIND
-    #define PD2_WPORT PORTD
-    #define PD2_PWM NULL
-    #define PD2_DDR DDRD
+    #define PD2_PIN     PIND2
+    #define PD2_RPORT   PIND
+    #define PD2_WPORT   PORTD
+    #define PD2_PWM     NULL
+    #define PD2_DDR     DDRD
     #undef PD3
-    #define PD3_PIN PIND3
-    #define PD3_RPORT PIND
-    #define PD3_WPORT PORTD
-    #define PD3_PWM NULL
-    #define PD3_DDR DDRD
+    #define PD3_PIN     PIND3
+    #define PD3_RPORT   PIND
+    #define PD3_WPORT   PORTD
+    #define PD3_PWM     NULL
+    #define PD3_DDR     DDRD
     #undef PD4
-    #define PD4_PIN PIND4
-    #define PD4_RPORT PIND
-    #define PD4_WPORT PORTD
-    #define PD4_PWM NULL
-    #define PD4_DDR DDRD
+    #define PD4_PIN     PIND4
+    #define PD4_RPORT   PIND
+    #define PD4_WPORT   PORTD
+    #define PD4_PWM     NULL
+    #define PD4_DDR     DDRD
     #undef PD5
-    #define PD5_PIN PIND5
-    #define PD5_RPORT PIND
-    #define PD5_WPORT PORTD
-    #define PD5_PWM NULL
-    #define PD5_DDR DDRD
+    #define PD5_PIN     PIND5
+    #define PD5_RPORT   PIND
+    #define PD5_WPORT   PORTD
+    #define PD5_PWM     NULL
+    #define PD5_DDR     DDRD
     #undef PD6
-    #define PD6_PIN PIND6
-    #define PD6_RPORT PIND
-    #define PD6_WPORT PORTD
-    #define PD6_PWM NULL
-    #define PD6_DDR DDRD
+    #define PD6_PIN     PIND6
+    #define PD6_RPORT   PIND
+    #define PD6_WPORT   PORTD
+    #define PD6_PWM     NULL
+    #define PD6_DDR     DDRD
     #undef PD7
-    #define PD7_PIN PIND7
-    #define PD7_RPORT PIND
-    #define PD7_WPORT PORTD
-    #define PD7_PWM NULL
-    #define PD7_DDR DDRD
+    #define PD7_PIN     PIND7
+    #define PD7_RPORT   PIND
+    #define PD7_WPORT   PORTD
+    #define PD7_PWM     NULL
+    #define PD7_DDR     DDRD
 
     #undef PE0
-    #define PE0_PIN PINE0
-    #define PE0_RPORT PINE
-    #define PE0_WPORT PORTE
-    #define PE0_PWM NULL
-    #define PE0_DDR DDRE
+    #define PE0_PIN     PINE0
+    #define PE0_RPORT   PINE
+    #define PE0_WPORT   PORTE
+    #define PE0_PWM     NULL
+    #define PE0_DDR     DDRE
     #undef PE1
-    #define PE1_PIN PINE1
-    #define PE1_RPORT PINE
-    #define PE1_WPORT PORTE
-    #define PE1_PWM NULL
-    #define PE1_DDR DDRE
+    #define PE1_PIN     PINE1
+    #define PE1_RPORT   PINE
+    #define PE1_WPORT   PORTE
+    #define PE1_PWM     NULL
+    #define PE1_DDR     DDRE
     #undef PE2
-    #define PE2_PIN PINE2
-    #define PE2_RPORT PINE
-    #define PE2_WPORT PORTE
-    #define PE2_PWM NULL
-    #define PE2_DDR DDRE
+    #define PE2_PIN     PINE2
+    #define PE2_RPORT   PINE
+    #define PE2_WPORT   PORTE
+    #define PE2_PWM     NULL
+    #define PE2_DDR     DDRE
     #undef PE3
-    #define PE3_PIN PINE3
-    #define PE3_RPORT PINE
-    #define PE3_WPORT PORTE
-    #define PE3_PWM NULL
-    #define PE3_DDR DDRE
+    #define PE3_PIN     PINE3
+    #define PE3_RPORT   PINE
+    #define PE3_WPORT   PORTE
+    #define PE3_PWM     NULL
+    #define PE3_DDR     DDRE
     #undef PE4
-    #define PE4_PIN PINE4
-    #define PE4_RPORT PINE
-    #define PE4_WPORT PORTE
-    #define PE4_PWM NULL
-    #define PE4_DDR DDRE
+    #define PE4_PIN     PINE4
+    #define PE4_RPORT   PINE
+    #define PE4_WPORT   PORTE
+    #define PE4_PWM     NULL
+    #define PE4_DDR     DDRE
     #undef PE5
-    #define PE5_PIN PINE5
-    #define PE5_RPORT PINE
-    #define PE5_WPORT PORTE
-    #define PE5_PWM NULL
-    #define PE5_DDR DDRE
+    #define PE5_PIN     PINE5
+    #define PE5_RPORT   PINE
+    #define PE5_WPORT   PORTE
+    #define PE5_PWM     NULL
+    #define PE5_DDR     DDRE
     #undef PE6
-    #define PE6_PIN PINE6
-    #define PE6_RPORT PINE
-    #define PE6_WPORT PORTE
-    #define PE6_PWM NULL
-    #define PE6_DDR DDRE
+    #define PE6_PIN     PINE6
+    #define PE6_RPORT   PINE
+    #define PE6_WPORT   PORTE
+    #define PE6_PWM     NULL
+    #define PE6_DDR     DDRE
     #undef PE7
-    #define PE7_PIN PINE7
-    #define PE7_RPORT PINE
-    #define PE7_WPORT PORTE
-    #define PE7_PWM NULL
-    #define PE7_DDR DDRE
+    #define PE7_PIN     PINE7
+    #define PE7_RPORT   PINE
+    #define PE7_WPORT   PORTE
+    #define PE7_PWM     NULL
+    #define PE7_DDR     DDRE
 
     #undef PF0
-    #define PF0_PIN PINF0
-    #define PF0_RPORT PINF
-    #define PF0_WPORT PORTF
-    #define PF0_PWM NULL
-    #define PF0_DDR DDRF
+    #define PF0_PIN     PINF0
+    #define PF0_RPORT   PINF
+    #define PF0_WPORT   PORTF
+    #define PF0_PWM     NULL
+    #define PF0_DDR     DDRF
     #undef PF1
-    #define PF1_PIN PINF1
-    #define PF1_RPORT PINF
-    #define PF1_WPORT PORTF
-    #define PF1_PWM NULL
-    #define PF1_DDR DDRF
+    #define PF1_PIN     PINF1
+    #define PF1_RPORT   PINF
+    #define PF1_WPORT   PORTF
+    #define PF1_PWM     NULL
+    #define PF1_DDR     DDRF
     #undef PF2
-    #define PF2_PIN PINF2
-    #define PF2_RPORT PINF
-    #define PF2_WPORT PORTF
-    #define PF2_PWM NULL
-    #define PF2_DDR DDRF
+    #define PF2_PIN     PINF2
+    #define PF2_RPORT   PINF
+    #define PF2_WPORT   PORTF
+    #define PF2_PWM     NULL
+    #define PF2_DDR     DDRF
     #undef PF3
-    #define PF3_PIN PINF3
-    #define PF3_RPORT PINF
-    #define PF3_WPORT PORTF
-    #define PF3_PWM NULL
-    #define PF3_DDR DDRF
+    #define PF3_PIN     PINF3
+    #define PF3_RPORT   PINF
+    #define PF3_WPORT   PORTF
+    #define PF3_PWM     NULL
+    #define PF3_DDR     DDRF
     #undef PF4
-    #define PF4_PIN PINF4
-    #define PF4_RPORT PINF
-    #define PF4_WPORT PORTF
-    #define PF4_PWM NULL
-    #define PF4_DDR DDRF
+    #define PF4_PIN     PINF4
+    #define PF4_RPORT   PINF
+    #define PF4_WPORT   PORTF
+    #define PF4_PWM     NULL
+    #define PF4_DDR     DDRF
     #undef PF5
-    #define PF5_PIN PINF5
-    #define PF5_RPORT PINF
-    #define PF5_WPORT PORTF
-    #define PF5_PWM NULL
-    #define PF5_DDR DDRF
+    #define PF5_PIN     PINF5
+    #define PF5_RPORT   PINF
+    #define PF5_WPORT   PORTF
+    #define PF5_PWM     NULL
+    #define PF5_DDR     DDRF
     #undef PF6
-    #define PF6_PIN PINF6
-    #define PF6_RPORT PINF
-    #define PF6_WPORT PORTF
-    #define PF6_PWM NULL
-    #define PF6_DDR DDRF
+    #define PF6_PIN     PINF6
+    #define PF6_RPORT   PINF
+    #define PF6_WPORT   PORTF
+    #define PF6_PWM     NULL
+    #define PF6_DDR     DDRF
     #undef PF7
-    #define PF7_PIN PINF7
-    #define PF7_RPORT PINF
-    #define PF7_WPORT PORTF
-    #define PF7_PWM NULL
-    #define PF7_DDR DDRF
+    #define PF7_PIN     PINF7
+    #define PF7_RPORT   PINF
+    #define PF7_WPORT   PORTF
+    #define PF7_PWM     NULL
+    #define PF7_DDR     DDRF
 
   #endif // AT90USBxx_TEENSYPP_ASSIGNMENTS Teensyduino assignments
 #endif // __AVR_AT90usbxxx__
diff --git a/Marlin/language.h b/Marlin/language.h
index 0a97764..96de163 100644
--- a/Marlin/language.h
+++ b/Marlin/language.h
@@ -145,6 +145,7 @@
 #define MSG_Y_MAX                           "y_max: "
 #define MSG_Z_MIN                           "z_min: "
 #define MSG_Z_MAX                           "z_max: "
+#define MSG_Z2_MIN                          "z2_min: "
 #define MSG_Z2_MAX                          "z2_max: "
 #define MSG_Z_PROBE                         "z_probe: "
 #define MSG_ERR_MATERIAL_INDEX              "M145 S<index> out of range (0-1)"
diff --git a/Marlin/language_an.h b/Marlin/language_an.h
index 9184d33..8d6ccd9 100644
--- a/Marlin/language_an.h
+++ b/Marlin/language_an.h
@@ -86,7 +86,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ves-jerk"
 #define MSG_VMAX                            "Vmax"
diff --git a/Marlin/language_bg.h b/Marlin/language_bg.h
index 5d5d322..094aed0 100644
--- a/Marlin/language_bg.h
+++ b/Marlin/language_bg.h
@@ -88,7 +88,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_ca.h b/Marlin/language_ca.h
index efa296f..8bb9706 100644
--- a/Marlin/language_ca.h
+++ b/Marlin/language_ca.h
@@ -87,7 +87,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Accel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_cn.h b/Marlin/language_cn.h
index 9afc052..1a1f813 100644
--- a/Marlin/language_cn.h
+++ b/Marlin/language_cn.h
@@ -86,7 +86,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Accel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_cz.h b/Marlin/language_cz.h
index 89158e7..401f11b 100644
--- a/Marlin/language_cz.h
+++ b/Marlin/language_cz.h
@@ -98,7 +98,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "Vybrat"
 #define MSG_ACC                             "Zrychl"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
@@ -148,6 +149,8 @@
 #define MSG_INIT_SDCARD                     "Nacist SD kartu"
 #define MSG_CNG_SDCARD                      "Vymenit SD kartu"
 #define MSG_ZPROBE_OUT                      "Sonda Z mimo podl"
+#define MSG_BLTOUCH_SELFTEST                "BLTouch Self-Test"
+#define MSG_BLTOUCH_RESET                   "BLTouch Reset"
 #define MSG_HOME                            "Domu"  // Used as MSG_HOME " " MSG_X MSG_Y MSG_Z " " MSG_FIRST
 #define MSG_FIRST                           "prvni"
 #define MSG_ZPROBE_ZOFFSET                  "Z ofset"
@@ -162,6 +165,7 @@
 #define MSG_ERR_MINTEMP                     "NIZKA TEPLOTA"
 #define MSG_ERR_MAXTEMP_BED                 "VYS. TEPL. PODL."
 #define MSG_ERR_MINTEMP_BED                 "NIZ. TEPL. PODL."
+#define MSG_ERR_Z_HOMING                    "G28 Z ZAKAZANO"
 #define MSG_HALTED                          "TISK. ZASTAVENA"
 #define MSG_PLEASE_RESET                    "Provedte reset"
 #define MSG_SHORT_DAY                       "d"
@@ -200,6 +204,9 @@
 #define MSG_INFO_MIN_TEMP                   "Teplota min"
 #define MSG_INFO_MAX_TEMP                   "Teplota max"
 #define MSG_INFO_PSU                        "Nap. zdroj"
+#define MSG_DRIVE_STRENGTH                  "Buzeni motoru"
+#define MSG_DAC_PERCENT                     "Motor %"
+#define MSG_DAC_EEPROM_WRITE                "Ulozit do EEPROM"
 
 #define MSG_FILAMENT_CHANGE_HEADER          "VYMENA FILAMENTU"
 #define MSG_FILAMENT_CHANGE_OPTION_HEADER   "CO DAL?"
diff --git a/Marlin/language_da.h b/Marlin/language_da.h
index 2cf28de..8c77092 100644
--- a/Marlin/language_da.h
+++ b/Marlin/language_da.h
@@ -96,7 +96,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "Vælg"
 #define MSG_ACC                             "Accel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_de.h b/Marlin/language_de.h
index f291a5d..0b64e67 100644
--- a/Marlin/language_de.h
+++ b/Marlin/language_de.h
@@ -95,9 +95,10 @@
 #define MSG_PID_C                           "PID C"
 #define MSG_SELECT                          "Auswählen"
 #define MSG_ACC                             "A"
-#define MSG_VXY_JERK                        "V XY Jerk"
-#define MSG_VZ_JERK                         "V Z  Jerk"
-#define MSG_VE_JERK                         "V E  Jerk"
+#define MSG_VX_JERK                         "V X Jerk"
+#define MSG_VY_JERK                         "V Y Jerk"
+#define MSG_VZ_JERK                         "V Z Jerk"
+#define MSG_VE_JERK                         "V E Jerk"
 #define MSG_VMAX                            "V max " // space by purpose
 #define MSG_VMIN                            "V min"
 #define MSG_VTRAV_MIN                       "V min Leerfahrt"
@@ -159,7 +160,7 @@
 #define MSG_ERR_MINTEMP                     LCD_STR_THERMOMETER " UNTERSCHRITTEN"
 #define MSG_ERR_MAXTEMP_BED                 "BETT " LCD_STR_THERMOMETER " ÜBERSCHRITTEN"
 #define MSG_ERR_MINTEMP_BED                 "BETT " LCD_STR_THERMOMETER " UNTERSCHRITTEN"
-#define MSG_ERR_Z_HOMING                    "G28 Z Forbidden"
+#define MSG_ERR_Z_HOMING                    "G28 Z verboten"
 #define MSG_HALTED                          "DRUCKER STOPP"
 #define MSG_PLEASE_RESET                    "Bitte Resetten"
 #define MSG_SHORT_DAY                       "t" // One character only
@@ -208,22 +209,22 @@
 
 #if LCD_HEIGHT >= 4
   #define MSG_FILAMENT_CHANGE_INIT_1          "Warte auf den"
-  #define MSG_FILAMENT_CHANGE_INIT_2          "Start zum "
-  #define MSG_FILAMENT_CHANGE_INIT_3          "Filament wechsel"
+  #define MSG_FILAMENT_CHANGE_INIT_2          "Start des "
+  #define MSG_FILAMENT_CHANGE_INIT_3          "Filamentwechsels"
   #define MSG_FILAMENT_CHANGE_UNLOAD_1        "Warte auf das"
-  #define MSG_FILAMENT_CHANGE_UNLOAD_2        "herrausnehmen"
+  #define MSG_FILAMENT_CHANGE_UNLOAD_2        "Herausnehmen"
   #define MSG_FILAMENT_CHANGE_UNLOAD_3        "des Filaments"
-  #define MSG_FILAMENT_CHANGE_INSERT_1        "Fädel Filament"
+  #define MSG_FILAMENT_CHANGE_INSERT_1        "Fädle Filament"
   #define MSG_FILAMENT_CHANGE_INSERT_2        "ein und drücke"
   #define MSG_FILAMENT_CHANGE_INSERT_3        "den Knopf..."
   #define MSG_FILAMENT_CHANGE_LOAD_1          "Warte auf das"
-  #define MSG_FILAMENT_CHANGE_LOAD_2          "laden des"
+  #define MSG_FILAMENT_CHANGE_LOAD_2          "Laden des"
   #define MSG_FILAMENT_CHANGE_LOAD_3          "Filaments"
   #define MSG_FILAMENT_CHANGE_EXTRUDE_1       "Warte auf das"
-  #define MSG_FILAMENT_CHANGE_EXTRUDE_2       "Extruden des"
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_2       "Extrudieren des"
   #define MSG_FILAMENT_CHANGE_EXTRUDE_3       "Filaments"
   #define MSG_FILAMENT_CHANGE_RESUME_1        "Warte auf das"
-  #define MSG_FILAMENT_CHANGE_RESUME_2        "fortfahren des"
+  #define MSG_FILAMENT_CHANGE_RESUME_2        "Fortsetzen des"
   #define MSG_FILAMENT_CHANGE_RESUME_3        "Druckes"
 #else // LCD_HEIGHT < 4
   #define MSG_FILAMENT_CHANGE_INIT_1          "Bitte warten..."
diff --git a/Marlin/language_el-gr.h b/Marlin/language_el-gr.h
index 1c18496..0ac443f 100644
--- a/Marlin/language_el-gr.h
+++ b/Marlin/language_el-gr.h
@@ -94,7 +94,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Επιτάχυνση"
-#define MSG_VXY_JERK                        "Vαντίδραση xy"
+#define MSG_VX_JERK                         "Vαντίδραση x"
+#define MSG_VY_JERK                         "Vαντίδραση y"
 #define MSG_VZ_JERK                         "Vαντίδραση z"
 #define MSG_VE_JERK                         "Vαντίδραση e"
 #define MSG_VMAX                            "Vμεγ "
diff --git a/Marlin/language_el.h b/Marlin/language_el.h
index 4242969..03b45c3 100644
--- a/Marlin/language_el.h
+++ b/Marlin/language_el.h
@@ -94,7 +94,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Επιτάχυνση"
-#define MSG_VXY_JERK                        "Vαντίδραση xy"
+#define MSG_VX_JERK                         "Vαντίδραση x"
+#define MSG_VY_JERK                         "Vαντίδραση y"
 #define MSG_VZ_JERK                         "Vαντίδραση z"
 #define MSG_VE_JERK                         "Vαντίδραση e"
 #define MSG_VMAX                            "V Μέγιστο"
diff --git a/Marlin/language_en.h b/Marlin/language_en.h
index ca2fd61..648cee6 100644
--- a/Marlin/language_en.h
+++ b/Marlin/language_en.h
@@ -216,8 +216,11 @@
 #ifndef MSG_ACC
   #define MSG_ACC                             "Accel"
 #endif
-#ifndef MSG_VXY_JERK
-  #define MSG_VXY_JERK                        "Vxy-jerk"
+#ifndef MSG_VX_JERK
+  #define MSG_VX_JERK                         "Vx-jerk"
+#endif
+#ifndef MSG_VY_JERK
+  #define MSG_VY_JERK                         "Vy-jerk"
 #endif
 #ifndef MSG_VZ_JERK
   #define MSG_VZ_JERK                         "Vz-jerk"
@@ -529,6 +532,15 @@
   #define MSG_INFO_PSU                        "Power Supply"
 #endif
 
+#ifndef MSG_DRIVE_STRENGTH
+  #define MSG_DRIVE_STRENGTH                  "Drive Strength"
+#endif
+#ifndef MSG_DAC_PERCENT
+  #define MSG_DAC_PERCENT                     "Driver %"
+#endif
+#ifndef MSG_DAC_EEPROM_WRITE
+  #define MSG_DAC_EEPROM_WRITE                "DAC EEPROM Write"
+#endif
 #ifndef MSG_FILAMENT_CHANGE_HEADER
   #define MSG_FILAMENT_CHANGE_HEADER          "CHANGE FILAMENT"
 #endif
diff --git a/Marlin/language_es.h b/Marlin/language_es.h
index 06d79f7..236842d 100644
--- a/Marlin/language_es.h
+++ b/Marlin/language_es.h
@@ -92,7 +92,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Aceleracion"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax"
diff --git a/Marlin/language_eu.h b/Marlin/language_eu.h
index 64c3fb3..0d66359 100644
--- a/Marlin/language_eu.h
+++ b/Marlin/language_eu.h
@@ -86,7 +86,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Azelerazioa"
-#define MSG_VXY_JERK                        "Vxy-astindua"
+#define MSG_VX_JERK                         "Vx-astindua"
+#define MSG_VY_JERK                         "Vy-astindua"
 #define MSG_VZ_JERK                         "Vz-astindua"
 #define MSG_VE_JERK                         "Ve-astindua"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_fi.h b/Marlin/language_fi.h
index 461bb41..e7db9a2 100644
--- a/Marlin/language_fi.h
+++ b/Marlin/language_fi.h
@@ -87,7 +87,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Kiihtyv"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_fr.h b/Marlin/language_fr.h
index 34bd383..b680f8f 100644
--- a/Marlin/language_fr.h
+++ b/Marlin/language_fr.h
@@ -94,7 +94,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "Selectionner"
 #define MSG_ACC                             "Acceleration"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax"
@@ -129,7 +130,7 @@
 #define MSG_USERWAIT                        "Atten. de l'util."
 #define MSG_RESUMING                        "Repri. de l'impr."
 #define MSG_PRINT_ABORTED                   "Impr. Annulee"
-#define MSG_NO_MOVE                         "Aucun mouvement."
+#define MSG_NO_MOVE                         "Moteurs bloques."
 #define MSG_KILLED                          "MORT."
 #define MSG_STOPPED                         "STOPPE."
 #define MSG_CONTROL_RETRACT                 "Retraction mm"
@@ -144,6 +145,8 @@
 #define MSG_INIT_SDCARD                     "Init. la carte SD"
 #define MSG_CNG_SDCARD                      "Changer de carte"
 #define MSG_ZPROBE_OUT                      "Z sonde exte. lit"
+#define MSG_BLTOUCH_SELFTEST                "Autotest BLTouch"
+#define MSG_BLTOUCH_RESET                   "RaZ BLTouch"
 #define MSG_HOME                            "Origine"  // Used as MSG_HOME " " MSG_X MSG_Y MSG_Z " " MSG_FIRST
 #define MSG_FIRST                           "Premier"
 #define MSG_ZPROBE_ZOFFSET                  "Decalage Z"
@@ -158,6 +161,7 @@
 #define MSG_ERR_MINTEMP                     "Err: TEMP. MIN"
 #define MSG_ERR_MAXTEMP_BED                 "Err: TEMP. MAX LIT"
 #define MSG_ERR_MINTEMP_BED                 "Err: TEMP. MIN LIT"
+#define MSG_ERR_Z_HOMING                    "G28 Z interdit"
 
 #define MSG_HALTED                          "IMPR. STOPPEE"
 #define MSG_PLEASE_RESET                    "RaZ. SVP"
@@ -192,17 +196,19 @@
   #define MSG_INFO_PRINT_LONGEST            "Impr. la + longue"
   #define MSG_INFO_PRINT_FILAMENT           "Total filament"
 #else
-    #define MSG_INFO_PRINT_COUNT              "Impressions"
-    #define MSG_INFO_COMPLETED_PRINTS         "Terminees"
-    #define MSG_INFO_PRINT_TIME               "Total"
-    #define MSG_INFO_PRINT_LONGEST            "+ long"
-    #define MSG_INFO_PRINT_FILAMENT           "Filament"
+  #define MSG_INFO_PRINT_COUNT              "Impressions"
+  #define MSG_INFO_COMPLETED_PRINTS         "Terminees"
+  #define MSG_INFO_PRINT_TIME               "Total"
+  #define MSG_INFO_PRINT_LONGEST            "+ long"
+  #define MSG_INFO_PRINT_FILAMENT           "Filament"
 #endif
 
 #define MSG_INFO_MIN_TEMP                   "Temp Min"
 #define MSG_INFO_MAX_TEMP                   "Temp Max"
 #define MSG_INFO_PSU                        "Alimentation"
-
+#define MSG_DRIVE_STRENGTH                  "Puiss. moteur "
+#define MSG_DAC_PERCENT                     "Driver %"
+#define MSG_DAC_EEPROM_WRITE                "DAC EEPROM sauv."
 #define MSG_FILAMENT_CHANGE_HEADER          "CHANGER FILAMENT"
 #define MSG_FILAMENT_CHANGE_OPTION_HEADER   "CHANGER OPTIONS:"
 #define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "+ extrusion"
diff --git a/Marlin/language_gl.h b/Marlin/language_gl.h
index 5f1b591..19b028b 100644
--- a/Marlin/language_gl.h
+++ b/Marlin/language_gl.h
@@ -95,7 +95,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "Escolla"
 #define MSG_ACC                             "Acel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_hr.h b/Marlin/language_hr.h
index ebfaeb2..d23e18e 100644
--- a/Marlin/language_hr.h
+++ b/Marlin/language_hr.h
@@ -93,7 +93,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Accel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_it.h b/Marlin/language_it.h
index e3a253c..75df0ef 100644
--- a/Marlin/language_it.h
+++ b/Marlin/language_it.h
@@ -102,7 +102,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "Seleziona"
 #define MSG_ACC                             "Accel"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_kana.h b/Marlin/language_kana.h
index f4e1458..03c7331 100644
--- a/Marlin/language_kana.h
+++ b/Marlin/language_kana.h
@@ -103,7 +103,8 @@
 #define MSG_SELECT                          "\xbe\xdd\xc0\xb8"                                                 // "ｾﾝﾀｸ" ("Select")
 #if LCD_WIDTH > 19
   #define MSG_ACC                           "\xb6\xbf\xb8\xc4\xde mm/s2"                                       // "ｶｿｸﾄﾞ mm/s2" ("Accel")
-  #define MSG_VXY_JERK                      "XY\xbc\xde\xb8\x20\xd4\xb8\xc4\xde mm/s"                          // "XYｼﾞｸ ﾔｸﾄﾞ mm/s" ("Vxy-jerk")
+  #define MSG_VX_JERK                       "X\xbc\xde\xb8\x20\xd4\xb8\xc4\xde mm/s"                           // "Xｼﾞｸ ﾔｸﾄﾞ mm/s" ("Vx-jerk")
+  #define MSG_VY_JERK                       "Y\xbc\xde\xb8\x20\xd4\xb8\xc4\xde mm/s"                           // "Yｼﾞｸ ﾔｸﾄﾞ mm/s" ("Vy-jerk")
   #define MSG_VZ_JERK                       "Z\xbc\xde\xb8\x20\xd4\xb8\xc4\xde mm/s"                           // "Zｼﾞｸ ﾔｸﾄﾞ mm/s" ("Vz-jerk")
   #define MSG_VE_JERK                       "\xb4\xb8\xbd\xc4\xd9\xb0\xc0\xde\xb0\x20\xd4\xb8\xc4\xde"         // "ｴｸｽﾄﾙｰﾀﾞｰ ﾔｸﾄﾞ" ("Ve-jerk")
   #define MSG_VMAX                          "\xbb\xb2\xc0\xde\xb2\xb5\xb8\xd8\xbf\xb8\xc4\xde "                // "ｻｲﾀﾞｲｵｸﾘｿｸﾄﾞ " ("Vmax ")
@@ -112,7 +113,8 @@
   #define MSG_AMAX                          "\xbb\xb2\xc0\xde\xb2\xb6\xbf\xb8\xc4\xde "                        // "ｻｲﾀﾞｲｶｿｸﾄﾞ " ("Amax ")
 #else
   #define MSG_ACC                           "\xb6\xbf\xb8\xc4\xde"                                             // "ｶｿｸﾄﾞ" ("Accel")
-  #define MSG_VXY_JERK                      "XY\xbc\xde\xb8\x20\xd4\xb8\xc4\xde"                               // "XYｼﾞｸ ﾔｸﾄﾞ" ("Vxy-jerk")
+  #define MSG_VX_JERK                       "X\xbc\xde\xb8\x20\xd4\xb8\xc4\xde"                                // "XYｼﾞｸ ﾔｸﾄﾞ" ("Vx-jerk")
+  #define MSG_VY_JERK                       "Y\xbc\xde\xb8\x20\xd4\xb8\xc4\xde"                                // "XYｼﾞｸ ﾔｸﾄﾞ" ("Vy-jerk")
   #define MSG_VZ_JERK                       "Z\xbc\xde\xb8\x20\xd4\xb8\xc4\xde"                                // "Zｼﾞｸ ﾔｸﾄﾞ" ("Vz-jerk")
   #define MSG_VE_JERK                       "E\x20\xd4\xb8\xc4\xde"                                            // "E ﾔｸﾄﾞ" ("Ve-jerk")
   #define MSG_VMAX                          "max\xb5\xb8\xd8\xbf\xb8\xc4\xde "                                 // "maxｵｸﾘｿｸﾄﾞ" ("Vmax ")
@@ -253,6 +255,13 @@
 #else
   #define MSG_INFO_PSU                      "\xc3\xde\xdd\xb9\xde\xdd"                                         // "ﾃﾞﾝｹﾞﾝ" ("Power Supply")
 #endif
+#define MSG_DRIVE_STRENGTH                  "\xd3\xb0\xc0\xb0\xb8\xc4\xde\xb3\xd8\xae\xb8"                     // "ﾓｰﾀｰｸﾄﾞｳﾘｮｸ" ("Drive Strength")
+#if LCD_WIDTH > 19
+  #define MSG_DAC_PERCENT                   "DAC\xbc\xad\xc2\xd8\xae\xb8 %"                                    // "DACｼｭﾂﾘｮｸ %" ("Driver %")
+#else
+  #define MSG_DAC_PERCENT                   "DAC\xbc\xad\xc2\xd8\xae\xb8"                                      // "DACｼｭﾂﾘｮｸ" ("Driver %")
+#endif
+#define MSG_DAC_EEPROM_WRITE                MSG_STORE_EPROM                                                    // "ﾒﾓﾘﾍｶｸﾉｳ" ("DAC EEPROM Write")
 #define MSG_FILAMENT_CHANGE_HEADER          "\xcc\xa8\xd7\xd2\xdd\xc4\xba\xb3\xb6\xdd"                         // "ﾌｨﾗﾒﾝﾄｺｳｶﾝ" ("CHANGE FILAMENT")
 #define MSG_FILAMENT_CHANGE_OPTION_HEADER   "\xc4\xde\xb3\xbb\xa6\xbe\xdd\xc0\xb8\xbc\xc3\xb8\xc0\xde\xbb\xb2" // "ﾄﾞｳｻｦｾﾝﾀｸｼﾃｸﾀﾞｻｲ" ("CHANGE OPTIONS:")
 #define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "\xbb\xd7\xc6\xb5\xbc\xc0\xde\xbd"                                 // "ｻﾗﾆｵｼﾀﾞｽ" ("Extrude more")
diff --git a/Marlin/language_kana_utf8.h b/Marlin/language_kana_utf8.h
index 905df71..2d64059 100644
--- a/Marlin/language_kana_utf8.h
+++ b/Marlin/language_kana_utf8.h
@@ -100,7 +100,8 @@
 #define MSG_PID_C                           "PID-C"
 #define MSG_SELECT                          "センタク"                     // "Select"
 #define MSG_ACC                             "カソクド mm/s2"               // "Accel"
-#define MSG_VXY_JERK                        "XYジク ヤクド mm/s"            // "Vxy-jerk"
+#define MSG_VX_JERK                         "Xジク ヤクド mm/s"             // "Vx-jerk"
+#define MSG_VY_JERK                         "Yジク ヤクド mm/s"             // "Vy-jerk"
 #define MSG_VZ_JERK                         "Zジク ヤクド mm/s"             // "Vz-jerk"
 #define MSG_VE_JERK                         "エクストルーダー ヤクド"          // "Ve-jerk"
 #define MSG_VMAX                            "サイダイオクリソクド "            // "Vmax "
@@ -197,6 +198,9 @@
 #define MSG_INFO_MIN_TEMP                   "セッテイサイテイオン"              // "Min Temp"
 #define MSG_INFO_MAX_TEMP                   "セッテイサイコウオン"              // "Max Temp"
 #define MSG_INFO_PSU                        "デンゲンシュベツ"                // "Power Supply"
+#define MSG_DRIVE_STRENGTH                  "モータークドウリョク"              // "Drive Strength"
+#define MSG_DAC_PERCENT                     "DACシュツリョク %"               // "Driver %"
+#define MSG_DAC_EEPROM_WRITE                MSG_STORE_EPROM              // "DAC EEPROM Write"
 #define MSG_FILAMENT_CHANGE_HEADER          "フィラメントコウカン"              // "CHANGE FILAMENT"
 #define MSG_FILAMENT_CHANGE_OPTION_HEADER   "ドウサヲセンタクシテクダサイ"        // "CHANGE OPTIONS:"
 #define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  "サラニオシダス"                 // "Extrude more"
diff --git a/Marlin/language_nl.h b/Marlin/language_nl.h
index 82f0a69..f21ece8 100644
--- a/Marlin/language_nl.h
+++ b/Marlin/language_nl.h
@@ -87,7 +87,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Versn"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_pl.h b/Marlin/language_pl.h
index efde140..61129ae 100644
--- a/Marlin/language_pl.h
+++ b/Marlin/language_pl.h
@@ -90,7 +90,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Przyspieszenie"
-#define MSG_VXY_JERK                        "Zryw Vxy"
+#define MSG_VX_JERK                         "Zryw Vx"
+#define MSG_VY_JERK                         "Zryw Vy"
 #define MSG_VZ_JERK                         "Zryw Vz"
 #define MSG_VE_JERK                         "Zryw Ve"
 #define MSG_VMAX                            "Vmax "
diff --git a/Marlin/language_pt-br.h b/Marlin/language_pt-br.h
index 1db6ae6..fe5b834 100644
--- a/Marlin/language_pt-br.h
+++ b/Marlin/language_pt-br.h
@@ -87,7 +87,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "jogo VXY"
+#define MSG_VX_JERK                         "jogo VX"
+#define MSG_VY_JERK                         "jogo VY"
 #define MSG_VZ_JERK                         "jogo VZ"
 #define MSG_VE_JERK                         "jogo VE"
 #define MSG_VMAX                            " Vmax "
diff --git a/Marlin/language_pt-br_utf8.h b/Marlin/language_pt-br_utf8.h
index 43e5d54..7fb4117 100644
--- a/Marlin/language_pt-br_utf8.h
+++ b/Marlin/language_pt-br_utf8.h
@@ -87,7 +87,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "jogo VXY"
+#define MSG_VX_JERK                         "jogo VX"
+#define MSG_VY_JERK                         "jogo VY"
 #define MSG_VZ_JERK                         "jogo VZ"
 #define MSG_VE_JERK                         "jogo VE"
 #define MSG_VMAX                            " Vmax "
diff --git a/Marlin/language_pt.h b/Marlin/language_pt.h
index 5996dd1..d73af9e 100644
--- a/Marlin/language_pt.h
+++ b/Marlin/language_pt.h
@@ -91,7 +91,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            " Vmax "
diff --git a/Marlin/language_pt_utf8.h b/Marlin/language_pt_utf8.h
index ec56a86..536896b 100644
--- a/Marlin/language_pt_utf8.h
+++ b/Marlin/language_pt_utf8.h
@@ -91,7 +91,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "Vxy-jerk"
+#define MSG_VX_JERK                         "Vx-jerk"
+#define MSG_VY_JERK                         "Vy-jerk"
 #define MSG_VZ_JERK                         "Vz-jerk"
 #define MSG_VE_JERK                         "Ve-jerk"
 #define MSG_VMAX                            " Vmax "
diff --git a/Marlin/language_ru.h b/Marlin/language_ru.h
index 7fb0e10..7441f34 100644
--- a/Marlin/language_ru.h
+++ b/Marlin/language_ru.h
@@ -91,7 +91,8 @@
 #define MSG_PID_D                           "PID-D"
 #define MSG_PID_C                           "PID-C"
 #define MSG_ACC                             "Acc"
-#define MSG_VXY_JERK                        "Vxy-рывок"
+#define MSG_VX_JERK                         "Vx-рывок"
+#define MSG_VY_JERK                         "Vy-рывок"
 #define MSG_VZ_JERK                         "Vz-рывок"
 #define MSG_VE_JERK                         "Ve-рывок"
 #define MSG_VMAX                            "Vмакс "
diff --git a/Marlin/macros.h b/Marlin/macros.h
index 56b5c8b..042f951 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -78,17 +78,18 @@
 #define NUMERIC(a) ((a) >= '0' && '9' >= (a))
 #define NUMERIC_SIGNED(a) (NUMERIC(a) || (a) == '-')
 #define COUNT(a) (sizeof(a)/sizeof(*a))
+#define ZERO(a) memset(a,0,sizeof(a))
 
 // Macros for initializing arrays
-#define ARRAY_6(v1, v2, v3, v4, v5, v6, args...) { v1, v2, v3, v4, v5, v6 }
-#define ARRAY_5(v1, v2, v3, v4, v5, args...)     { v1, v2, v3, v4, v5 }
-#define ARRAY_4(v1, v2, v3, v4, args...)         { v1, v2, v3, v4 }
-#define ARRAY_3(v1, v2, v3, args...)             { v1, v2, v3 }
-#define ARRAY_2(v1, v2, args...)                 { v1, v2 }
-#define ARRAY_1(v1, args...)                     { v1 }
-
-#define _ARRAY_N(N, args...) ARRAY_ ##N(args)
-#define ARRAY_N(N, args...) _ARRAY_N(N, args)
+#define ARRAY_6(v1, v2, v3, v4, v5, v6, ...) { v1, v2, v3, v4, v5, v6 }
+#define ARRAY_5(v1, v2, v3, v4, v5, ...)     { v1, v2, v3, v4, v5 }
+#define ARRAY_4(v1, v2, v3, v4, ...)         { v1, v2, v3, v4 }
+#define ARRAY_3(v1, v2, v3, ...)             { v1, v2, v3 }
+#define ARRAY_2(v1, v2, ...)                 { v1, v2 }
+#define ARRAY_1(v1, ...)                     { v1 }
+
+#define _ARRAY_N(N, ...) ARRAY_ ##N(__VA_ARGS__)
+#define ARRAY_N(N, ...) _ARRAY_N(N, __VA_ARGS__)
 
 // Macros for adding
 #define INC_0 1
diff --git a/Marlin/mesh_bed_leveling.cpp b/Marlin/mesh_bed_leveling.cpp
index babad8a..fa45198 100644
--- a/Marlin/mesh_bed_leveling.cpp
+++ b/Marlin/mesh_bed_leveling.cpp
@@ -31,7 +31,7 @@
   void mesh_bed_leveling::reset() {
     status = MBL_STATUS_NONE;
     z_offset = 0;
-    memset(z_values, 0, sizeof(z_values));
+    ZERO(z_values);
   }
 
 #endif  // MESH_BED_LEVELING
diff --git a/Marlin/pins.h b/Marlin/pins.h
index 8fc194f..472133c 100644
--- a/Marlin/pins.h
+++ b/Marlin/pins.h
@@ -232,6 +232,9 @@
 #ifndef HEATER_3_PIN
   #define HEATER_3_PIN -1
 #endif
+#ifndef HEATER_4_PIN
+  #define HEATER_4_PIN -1
+#endif
 #ifndef HEATER_BED_PIN
   #define HEATER_BED_PIN -1
 #endif
@@ -274,14 +277,35 @@
   #define SUICIDE_PIN -1
 #endif
 
+#ifndef MAX_EXTRUDERS
+  #define MAX_EXTRUDERS 4
+#endif
+
 // Marlin needs to account for pins that equal -1
-#define marlinAnalogInputToDigitalPin(p) ((p) == -1 ? -1 : (p) + 0xA0)
+#define marlinAnalogInputToDigitalPin(p) ((p) == -1 ? -1 : analogInputToDigitalPin(p))
+
+//
+// Assign auto fan pins if needed
+//
+#if !defined(E0_AUTO_FAN_PIN) && defined(ORIG_E0_AUTO_FAN_PIN)
+  #define E0_AUTO_FAN_PIN ORIG_E0_AUTO_FAN_PIN
+#endif
+#if !defined(E1_AUTO_FAN_PIN) && defined(ORIG_E1_AUTO_FAN_PIN)
+  #define E1_AUTO_FAN_PIN ORIG_E1_AUTO_FAN_PIN
+#endif
+#if !defined(E2_AUTO_FAN_PIN) && defined(ORIG_E2_AUTO_FAN_PIN)
+  #define E2_AUTO_FAN_PIN ORIG_E2_AUTO_FAN_PIN
+#endif
+#if !defined(E3_AUTO_FAN_PIN) && defined(ORIG_E3_AUTO_FAN_PIN)
+  #define E3_AUTO_FAN_PIN ORIG_E3_AUTO_FAN_PIN
+#endif
 
 // List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!
 #define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, E0_MS1_PIN, E0_MS2_PIN,
 #define _E1_PINS
 #define _E2_PINS
 #define _E3_PINS
+#define _E4_PINS
 
 #if EXTRUDERS > 1
   #undef _E1_PINS
@@ -292,24 +316,33 @@
     #if EXTRUDERS > 3
       #undef _E3_PINS
       #define _E3_PINS E3_STEP_PIN, E3_DIR_PIN, E3_ENABLE_PIN,
+      #if EXTRUDERS > 4
+        #undef _E4_PINS
+        #define _E4_PINS E4_STEP_PIN, E4_DIR_PIN, E4_ENABLE_PIN,
+      #endif
     #endif
   #endif
 #endif
 
-#define _H0_PINS HEATER_0_PIN, EXTRUDER_0_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_0_PIN),
+#define _H0_PINS HEATER_0_PIN, E0_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_0_PIN),
 #define _H1_PINS
 #define _H2_PINS
 #define _H3_PINS
+#define _H4_PINS
 
 #if HOTENDS > 1
   #undef _H1_PINS
-  #define _H1_PINS HEATER_1_PIN, EXTRUDER_1_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_1_PIN),
+  #define _H1_PINS HEATER_1_PIN, E1_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_1_PIN),
   #if HOTENDS > 2
     #undef _H2_PINS
-    #define _H2_PINS HEATER_2_PIN, EXTRUDER_2_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_2_PIN),
+    #define _H2_PINS HEATER_2_PIN, E2_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_2_PIN),
     #if HOTENDS > 3
       #undef _H3_PINS
-      #define _H3_PINS HEATER_3_PIN, EXTRUDER_3_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_3_PIN),
+      #define _H3_PINS HEATER_3_PIN, E3_AUTO_FAN_PIN, marlinAnalogInputToDigitalPin(TEMP_3_PIN),
+      #if HOTENDS > 4
+        #undef _H4_PINS
+        #define _H4_PINS HEATER_4_PIN, marlinAnalogInputToDigitalPin(TEMP_4_PIN),
+      #endif
     #endif
   #endif
 #elif ENABLED(MIXING_EXTRUDER)
@@ -321,6 +354,10 @@
     #if MIXING_STEPPERS > 3
       #undef _E3_PINS
       #define _E3_PINS E3_STEP_PIN, E3_DIR_PIN, E3_ENABLE_PIN,
+      #if MIXING_STEPPERS > 4
+        #undef _E4_PINS
+        #define _E4_PINS E4_STEP_PIN, E4_DIR_PIN, E4_ENABLE_PIN,
+      #endif
     #endif
   #endif
 #endif
@@ -453,8 +490,8 @@
     Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, \
     Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, Z_MIN_PROBE_PIN, \
     PS_ON_PIN, HEATER_BED_PIN, FAN_PIN, FAN1_PIN, FAN2_PIN, CONTROLLERFAN_PIN, \
-    _E0_PINS _E1_PINS _E2_PINS _E3_PINS BED_PINS \
-    _H0_PINS _H1_PINS _H2_PINS _H3_PINS \
+    _E0_PINS _E1_PINS _E2_PINS _E3_PINS _E4_PINS BED_PINS \
+    _H0_PINS _H1_PINS _H2_PINS _H3_PINS _H4_PINS \
     _X2_PINS _Y2_PINS _Z2_PINS \
     X_MS1_PIN, X_MS2_PIN, Y_MS1_PIN, Y_MS2_PIN, Z_MS1_PIN, Z_MS2_PIN \
   }
diff --git a/Marlin/pinsDebug.h b/Marlin/pinsDebug.h
new file mode 100644
index 0000000..c06eabb
--- /dev/null
+++ b/Marlin/pinsDebug.h
@@ -0,0 +1,447 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// How many DIO pins are defined?
+#if defined(DIO85_PIN)
+  #define DIO_COUNT 86
+#elif defined(DIO53_PIN)
+  #define DIO_COUNT 54
+#elif defined(DIO47_PIN)
+  #define DIO_COUNT 48
+#elif defined(DIO31_PIN)
+  #define DIO_COUNT 32
+#elif defined(DIO21_PIN)
+  #define DIO_COUNT 22
+#endif
+
+#define _PIN_SAY(NAME) { SERIAL_ECHOPGM(STRINGIFY(NAME)); return true; }
+#define PIN_SAY(NAME) if (pin == NAME) _PIN_SAY(_##NAME##_);
+#define ANALOG_PIN_SAY(NAME) if (pin == analogInputToDigitalPin(NAME)) _PIN_SAY(_##NAME##_);
+#define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && ((P) <= analogInputToDigitalPin(15) || (P) <= analogInputToDigitalPin(5)))
+
+// Report pin name for a given fastio digital pin index
+static bool report_pin_name(int8_t pin) {
+
+  SERIAL_ECHO((int)pin);
+  SERIAL_CHAR(' ');
+
+  if (IS_ANALOG(pin)) {
+    SERIAL_CHAR('('); SERIAL_CHAR('A');
+    SERIAL_ECHO(int(pin - analogInputToDigitalPin(0)));
+    SERIAL_CHAR(')'); SERIAL_CHAR(' ');
+  }
+
+  #if defined(RXD) && RXD > -1
+    if (pin == 0) { SERIAL_ECHOPGM("RXD"); return true; }
+  #endif
+  #if defined(TXD) && TXD > -1
+    if (pin == 1) { SERIAL_ECHOPGM("TXD"); return true; }
+  #endif
+
+  #if PIN_EXISTS(SERVO0)
+    PIN_SAY(SERVO0_PIN);
+  #endif
+  #if PIN_EXISTS(SERVO1)
+    PIN_SAY(SERVO1_PIN);
+  #endif
+  #if PIN_EXISTS(SERVO2)
+    PIN_SAY(SERVO2_PIN);
+  #endif
+  #if PIN_EXISTS(SERVO3)
+    PIN_SAY(SERVO3_PIN);
+  #endif
+
+  #if PIN_EXISTS(X_MIN)
+    PIN_SAY(X_MIN_PIN);
+  #endif
+  #if PIN_EXISTS(X_MAX)
+    PIN_SAY(X_MAX_PIN);
+  #endif
+  #if PIN_EXISTS(Y_MIN)
+    PIN_SAY(Y_MIN_PIN);
+  #endif
+  #if PIN_EXISTS(Y_MAX)
+    PIN_SAY(Y_MAX_PIN);
+  #endif
+  #if PIN_EXISTS(Z_MIN)
+    PIN_SAY(Z_MIN_PIN);
+  #endif
+  #if PIN_EXISTS(Z_MAX)
+    PIN_SAY(Z_MAX_PIN);
+  #endif
+  #if PIN_EXISTS(Z_MIN_PROBE)
+    PIN_SAY(Z_MIN_PROBE_PIN);
+  #endif
+  #if PIN_EXISTS(X_STEP)
+    PIN_SAY(X_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(X_DIR)
+    PIN_SAY(X_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(X_ENABLE)
+    PIN_SAY(X_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(X_MS1)
+    PIN_SAY(X_MS1_PIN);
+  #endif
+  #if PIN_EXISTS(X_MS2)
+    PIN_SAY(X_MS2_PIN);
+  #endif
+  #if PIN_EXISTS(X2_STEP)
+    PIN_SAY(X2_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(X2_DIR)
+    PIN_SAY(X2_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(X2_ENABLE)
+    PIN_SAY(X2_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(Y_STEP)
+    PIN_SAY(Y_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(Y_DIR)
+    PIN_SAY(Y_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(Y_ENABLE)
+    PIN_SAY(Y_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(Y_MS1)
+    PIN_SAY(Y_MS1_PIN);
+  #endif
+  #if PIN_EXISTS(Y_MS2)
+    PIN_SAY(Y_MS2_PIN);
+  #endif
+  #if PIN_EXISTS(Y2_STEP)
+    PIN_SAY(Y2_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(Y2_DIR)
+    PIN_SAY(Y2_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(Y2_ENABLE)
+    PIN_SAY(Y2_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(Z_STEP)
+    PIN_SAY(Z_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(Z_DIR)
+    PIN_SAY(Z_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(Z_ENABLE)
+    PIN_SAY(Z_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(Z_MS1)
+    PIN_SAY(Z_MS1_PIN);
+  #endif
+  #if PIN_EXISTS(Z_MS2)
+    PIN_SAY(Z_MS2_PIN);
+  #endif
+  #if PIN_EXISTS(Z2_STEP)
+    PIN_SAY(Z2_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(Z2_DIR)
+    PIN_SAY(Z2_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(Z2_ENABLE)
+    PIN_SAY(Z2_ENABLE_PIN);
+  #endif
+
+  #if PIN_EXISTS(E0_STEP)
+    PIN_SAY(E0_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(E0_DIR)
+    PIN_SAY(E0_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(E0_ENABLE)
+    PIN_SAY(E0_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(E0_MS1)
+    PIN_SAY(E0_MS1_PIN);
+  #endif
+  #if PIN_EXISTS(E0_MS2)
+    PIN_SAY(E0_MS2_PIN);
+  #endif
+  #if PIN_EXISTS(E1_STEP)
+    PIN_SAY(E1_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(E1_DIR)
+    PIN_SAY(E1_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(E1_ENABLE)
+    PIN_SAY(E1_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(E1_MS1)
+    PIN_SAY(E1_MS1_PIN);
+  #endif
+  #if PIN_EXISTS(E1_MS2)
+    PIN_SAY(E1_MS2_PIN);
+  #endif
+  #if PIN_EXISTS(E2_STEP)
+    PIN_SAY(E2_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(E2_DIR)
+    PIN_SAY(E2_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(E2_ENABLE)
+    PIN_SAY(E2_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(E3_STEP)
+    PIN_SAY(E3_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(E3_DIR)
+    PIN_SAY(E3_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(E3_ENABLE)
+    PIN_SAY(E3_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(E4_STEP)
+    PIN_SAY(E4_STEP_PIN);
+  #endif
+  #if PIN_EXISTS(E4_DIR)
+    PIN_SAY(E4_DIR_PIN);
+  #endif
+  #if PIN_EXISTS(E4_ENABLE)
+    PIN_SAY(E4_ENABLE_PIN);
+  #endif
+
+  #if PIN_EXISTS(FAN)
+    PIN_SAY(FAN_PIN);
+  #endif
+  #if PIN_EXISTS(FAN1)
+    PIN_SAY(FAN1_PIN);
+  #endif
+  #if PIN_EXISTS(FAN2)
+    PIN_SAY(FAN2_PIN);
+  #endif
+  #if PIN_EXISTS(CONTROLLERFAN)
+    PIN_SAY(CONTROLLERFAN_PIN);
+  #endif
+  #if PIN_EXISTS(E0_AUTO_FAN)
+    PIN_SAY(E0_AUTO_FAN_PIN);
+  #endif
+  #if PIN_EXISTS(E1_AUTO_FAN)
+    PIN_SAY(E1_AUTO_FAN_PIN);
+  #endif
+  #if PIN_EXISTS(E2_AUTO_FAN)
+    PIN_SAY(E2_AUTO_FAN_PIN);
+  #endif
+  #if PIN_EXISTS(E3_AUTO_FAN)
+    PIN_SAY(E3_AUTO_FAN_PIN);
+  #endif
+  #if PIN_EXISTS(HEATER_0)
+    PIN_SAY(HEATER_0_PIN);
+  #endif
+  #if PIN_EXISTS(HEATER_1)
+    PIN_SAY(HEATER_1_PIN);
+  #endif
+  #if PIN_EXISTS(HEATER_2)
+    PIN_SAY(HEATER_2_PIN);
+  #endif
+  #if PIN_EXISTS(HEATER_3)
+    PIN_SAY(HEATER_3_PIN);
+  #endif
+  #if PIN_EXISTS(HEATER_BED)
+    PIN_SAY(HEATER_BED_PIN);
+  #endif
+
+  #if PIN_EXISTS(X_ATT)
+    PIN_SAY(X_ATT_PIN);
+  #endif
+  #if PIN_EXISTS(Y_ATT)
+    PIN_SAY(Y_ATT_PIN);
+  #endif
+  #if PIN_EXISTS(Z_ATT)
+    PIN_SAY(Z_ATT_PIN);
+  #endif
+  #if PIN_EXISTS(E0_ATT)
+    PIN_SAY(E0_ATT_PIN);
+  #endif
+
+  #if PIN_EXISTS(TEMP_0)
+    ANALOG_PIN_SAY(TEMP_0_PIN);
+  #endif
+  #if PIN_EXISTS(TEMP_1)
+    ANALOG_PIN_SAY(TEMP_1_PIN);
+  #endif
+  #if PIN_EXISTS(TEMP_2)
+    ANALOG_PIN_SAY(TEMP_2_PIN);
+  #endif
+  #if PIN_EXISTS(TEMP_3)
+    ANALOG_PIN_SAY(TEMP_3_PIN);
+  #endif
+  #if PIN_EXISTS(TEMP_BED)
+    ANALOG_PIN_SAY(TEMP_BED_PIN);
+  #endif
+  #if PIN_EXISTS(FILWIDTH)
+    ANALOG_PIN_SAY(FILWIDTH_PIN);
+  #endif
+
+  #if PIN_EXISTS(BEEPER)
+    PIN_SAY(BEEPER_PIN);
+  #endif
+  #if PIN_EXISTS(SLED)
+    PIN_SAY(SLED_PIN);
+  #endif
+  #if PIN_EXISTS(FIL_RUNOUT)
+    PIN_SAY(FIL_RUNOUT_PIN);
+  #endif
+
+  #if PIN_EXISTS(LED)
+    PIN_SAY(LED_PIN);
+  #endif
+  // #if defined(DEBUG_LED) && DEBUG_LED > -1
+  //   PIN_SAY(DEBUG_LED);
+  // #endif
+  #if PIN_EXISTS(STAT_LED_RED)
+    PIN_SAY(STAT_LED_RED_PIN);
+  #endif
+  #if PIN_EXISTS(STAT_LED_BLUE)
+    PIN_SAY(STAT_LED_BLUE_PIN);
+  #endif
+
+  #if PIN_EXISTS(DIGIPOTSS)
+    PIN_SAY(DIGIPOTSS_PIN);
+  #endif
+
+  #if PIN_EXISTS(SCK)
+    PIN_SAY(SCK_PIN);
+  #endif
+  #if PIN_EXISTS(MISO)
+    PIN_SAY(MISO_PIN);
+  #endif
+  #if PIN_EXISTS(MOSI)
+    PIN_SAY(MOSI_PIN);
+  #endif
+  #if PIN_EXISTS(SS)
+    PIN_SAY(SS_PIN);
+  #endif
+
+  #if PIN_EXISTS(SD_DETECT)
+    PIN_SAY(SD_DETECT_PIN);
+  #endif
+
+  #if defined(SDPOWER) && SDPOWER > -1
+    PIN_SAY(SDPOWER);
+  #endif
+  #if defined(SDSS) && SDSS > -1
+    PIN_SAY(SDSS);
+  #endif
+  #if defined(I2C_SCL) && I2C_SCL > -1
+    PIN_SAY(I2C_SCL);
+  #endif
+  #if defined(I2C_SDA) && I2C_SDA > -1
+    PIN_SAY(I2C_SDA);
+  #endif
+  #if defined(SCL) && SCL > -1
+    PIN_SAY(SCL);
+  #endif
+  #if defined(SDA) && SDA > -1
+    PIN_SAY(SDA);
+  #endif
+
+  #if PIN_EXISTS(PS_ON)
+    PIN_SAY(PS_ON_PIN);
+  #endif
+  #if PIN_EXISTS(KILL)
+    PIN_SAY(KILL_PIN);
+  #endif
+  #if PIN_EXISTS(SUICIDE)
+    PIN_SAY(SUICIDE_PIN);
+  #endif
+  #if PIN_EXISTS(DEBUG)
+    PIN_SAY(DEBUG_PIN);
+  #endif
+  #if PIN_EXISTS(PHOTOGRAPH)
+    PIN_SAY(PHOTOGRAPH_PIN);
+  #endif
+
+  #if PIN_EXISTS(BEEPER)
+    PIN_SAY(BEEPER_PIN);
+  #endif
+  #if defined(BTN_EN1) && BTN_EN1 > -1
+    PIN_SAY(BTN_EN1);
+  #endif
+  #if defined(BTN_EN2) && BTN_EN2 > -1
+    PIN_SAY(BTN_EN2);
+  #endif
+  #if defined(BTN_ENC) && BTN_ENC > -1
+    PIN_SAY(BTN_ENC);
+  #endif
+  #if defined(LCD_PINS_RS) && LCD_PINS_RS > -1
+    PIN_SAY(LCD_PINS_RS);
+  #endif
+  #if defined(LCD_PINS_ENABLE) && LCD_PINS_ENABLE > -1
+    PIN_SAY(LCD_PINS_ENABLE);
+  #endif
+  #if defined(LCD_PINS_D4) && LCD_PINS_D4 > -1
+    PIN_SAY(LCD_PINS_D4);
+  #endif
+  #if defined(LCD_PINS_D5) && LCD_PINS_D5 > -1
+    PIN_SAY(LCD_PINS_D5);
+  #endif
+  #if defined(LCD_PINS_D6) && LCD_PINS_D6 > -1
+    PIN_SAY(LCD_PINS_D6);
+  #endif
+  #if defined(LCD_PINS_D7) && LCD_PINS_D7 > -1
+    PIN_SAY(LCD_PINS_D7);
+  #endif
+
+  #if PIN_EXISTS(RAMPS_D8)
+    PIN_SAY(RAMPS_D8_PIN);
+  #endif
+  #if PIN_EXISTS(RAMPS_D9)
+    PIN_SAY(RAMPS_D9_PIN);
+  #endif
+  #if PIN_EXISTS(RAMPS_D10)
+    PIN_SAY(RAMPS_D10_PIN);
+  #endif
+  #if PIN_EXISTS(MOSFET_D)
+    PIN_SAY(MOSFET_D_PIN);
+  #endif
+
+  #if PIN_EXISTS(TX_ENABLE)
+    PIN_SAY(TX_ENABLE_PIN);
+  #endif
+  #if PIN_EXISTS(RX_ENABLE)
+    PIN_SAY(RX_ENABLE_PIN);
+  #endif
+
+  SERIAL_ECHOPGM("<unused>");
+  return false;
+}
+
+inline void report_pin_state(int8_t pin) {
+  if (report_pin_name(pin)) {
+    if (pin_is_protected(pin))
+      SERIAL_ECHOPGM(" (protected)");
+    else {
+      SERIAL_ECHOPGM(" = ");
+      pinMode(pin, INPUT_PULLUP);
+      SERIAL_ECHO(digitalRead(pin));
+      if (IS_ANALOG(pin)) {
+        SERIAL_CHAR(' '); SERIAL_CHAR('(');
+        SERIAL_ECHO(analogRead(pin - analogInputToDigitalPin(0)));
+        SERIAL_CHAR(')');
+      }
+    }
+  }
+  SERIAL_EOL;
+}
diff --git a/Marlin/pins_3DRAG.h b/Marlin/pins_3DRAG.h
index bd0cec2..9eaf2c9 100644
--- a/Marlin/pins_3DRAG.h
+++ b/Marlin/pins_3DRAG.h
@@ -36,6 +36,9 @@
   #define DEFAULT_SOURCE_CODE_URL "http://3dprint.elettronicain.it/"
 #endif
 
+//
+// Heaters / Fans
+//
 #define RAMPS_D8_PIN 9
 #define RAMPS_D9_PIN 8
 #define MOSFET_D_PIN 12
@@ -55,7 +58,12 @@
 #define Z_ENABLE_PIN       63
 
 //
-// SD Card
+// Heaters / Fans
+//
+#define HEATER_2_PIN        6
+
+//
+// Misc. Functions
 //
 #undef SDSS
 #define SDSS               25
@@ -64,11 +72,6 @@
 #define SD_DETECT_PIN      53
 
 //
-// Heaters / Fans
-//
-#define HEATER_2_PIN        6
-
-//
 // LCD / Controller
 //
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
diff --git a/Marlin/pins_5DPRINT.h b/Marlin/pins_5DPRINT.h
index 21769a5..f44a568 100644
--- a/Marlin/pins_5DPRINT.h
+++ b/Marlin/pins_5DPRINT.h
@@ -75,8 +75,8 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          1  // Analog
-#define TEMP_BED_PIN        0  // Analog
+#define TEMP_0_PIN          1   // Analog Input
+#define TEMP_BED_PIN        0   // Analog Input
 
 //
 // Heaters / Fans
@@ -89,6 +89,6 @@
 #define FAN_PIN            16
 
 //
-// SD Card
+// Misc. Functions
 //
 #define SDSS               20
diff --git a/Marlin/pins_99.h b/Marlin/pins_99.h
index f5d7ec3..ba86bf5 100644
--- a/Marlin/pins_99.h
+++ b/Marlin/pins_99.h
@@ -55,8 +55,8 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          6   // ANALOG INPUT - NOT DIGITAL OUTPUT
-#define TEMP_BED_PIN       10
+#define TEMP_0_PIN          6   // Analog Input
+#define TEMP_BED_PIN       10   // Analog Input
 
 //
 // Heaters / Fans
@@ -64,5 +64,8 @@
 #define HEATER_0_PIN       13
 #define HEATER_BED_PIN      4
 
+//
+// Misc. Functions
+//
 #define SDSS               53
 #define PS_ON_PIN           9
diff --git a/Marlin/pins_A4JP.h b/Marlin/pins_A4JP.h
index 28db6c8..7e9acd4 100644
--- a/Marlin/pins_A4JP.h
+++ b/Marlin/pins_A4JP.h
@@ -30,6 +30,12 @@
 
 #define BOARD_NAME "AJ4P"
 
+#define LARGE_FLASH true
+
+/************************************************
+ * Rambo pin assignments old
+ ************************************************/
+
 //
 // Servos
 //
@@ -38,16 +44,6 @@
 #define SERVO2_PIN 24 // Motor header MX3
 #define SERVO3_PIN  5 // PWM header pin 5
 
-#define SLED_PIN -1
-
-#define FILWIDTH_PIN        3  // ANALOG NUMBERING
-
-/************************************************
- * Rambo pin assignments old
- ************************************************/
-
-#define LARGE_FLASH true
-
 //
 // Limit Switches
 //
@@ -65,36 +61,40 @@
   #define Z_MIN_PROBE_PIN   30
 #endif
 
+#define SLED_PIN -1
+
 //
 // Steppers
 //
 #define X_STEP_PIN          37
 #define X_DIR_PIN           48
 #define X_ENABLE_PIN        29
-#define X_MS1_PIN           40
-#define X_MS2_PIN           41
 
 #define Y_STEP_PIN          36
 #define Y_DIR_PIN           49
 #define Y_ENABLE_PIN        28
-#define Y_MS1_PIN           69
-#define Y_MS2_PIN           39
 
 #define Z_STEP_PIN          35
 #define Z_DIR_PIN           47
 #define Z_ENABLE_PIN        27
-#define Z_MS1_PIN           68
-#define Z_MS2_PIN           67
 
 #define E0_STEP_PIN         34
 #define E0_DIR_PIN          43
 #define E0_ENABLE_PIN       26
-#define E0_MS1_PIN          65
-#define E0_MS2_PIN          66
 
 #define E1_STEP_PIN         33
 #define E1_DIR_PIN          42
 #define E1_ENABLE_PIN       25
+
+// Microstepping pins - Mapping not from fastio.h (?)
+#define X_MS1_PIN           40
+#define X_MS2_PIN           41
+#define Y_MS1_PIN           69
+#define Y_MS2_PIN           39
+#define Z_MS1_PIN           68
+#define Z_MS2_PIN           67
+#define E0_MS1_PIN          65
+#define E0_MS2_PIN          66
 #define E1_MS1_PIN          63
 #define E1_MS2_PIN          64
 
@@ -102,55 +102,60 @@
 #define DIGIPOT_CHANNELS {4,5,3,0,1} // X Y Z E0 E1 digipot channels to stepper driver mapping
 
 //
-// Heaters / Fans
+// Temperature Sensors
 //
-#define HEATER_0_PIN   9
-#define HEATER_1_PIN   7
-#define HEATER_BED_PIN 3
+#define TEMP_0_PIN           0   // Analog Input
+#define TEMP_BED_PIN         7   // Analog Input
 
-#define FAN_PIN        8
-#define FAN0_PIN       6
-#define FAN1_PIN       2
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN         9
+#define HEATER_1_PIN         7
+#define HEATER_BED_PIN       3
 
-#define TEMP_0_PIN     0
-#define TEMP_BED_PIN   7
+#define FAN_PIN              8
+#define FAN0_PIN             6
+#define FAN1_PIN             2
 
-#define SDSS          53
-#define LED_PIN       13
-#define PS_ON_PIN      4
+//
+// Misc. Functions
+//
+#define SDSS                53
+#define LED_PIN             13
+#define PS_ON_PIN            4
+#define FILWIDTH_PIN         3   // Analog Input
 
 //
 // LCD / Controller
 //
-#define LCD_PINS_RS     70 //ext2_5
-#define LCD_PINS_ENABLE 71 //ext2_7
-#define LCD_PINS_D4     72 ///////Ext2 9 ?
-#define LCD_PINS_D5     73 ///////Ext2 11 ?
-#define LCD_PINS_D6     74 //ext2_13
-#define LCD_PINS_D7     75 ///////Ext2 15 ?
-#define BEEPER_PIN      -1
-
-#define BTN_HOME        80 //ext_16
-#define BTN_CENTER      81 //ext_14
-#define BTN_ENC         BTN_CENTER
-#define BTN_RIGHT       82 //ext_12
-#define BTN_LEFT        83 //ext_10
-#define BTN_UP          84 //ext2_8
-#define BTN_DOWN        85 //ext2_6
-
-#define HOME_PIN        BTN_HOME
+#define LCD_PINS_RS         70 // Ext2_5
+#define LCD_PINS_ENABLE     71 // Ext2_7
+#define LCD_PINS_D4         72 // Ext2_9 ?
+#define LCD_PINS_D5         73 // Ext2_11 ?
+#define LCD_PINS_D6         74 // Ext2_13
+#define LCD_PINS_D7         75 // Ext2_15 ?
+#define BEEPER_PIN          -1
+
+#define BTN_HOME            80 // Ext_16
+#define BTN_CENTER          81 // Ext_14
+#define BTN_ENC             BTN_CENTER
+#define BTN_RIGHT           82 // Ext_12
+#define BTN_LEFT            83 // Ext_10
+#define BTN_UP              84 // Ext2_8
+#define BTN_DOWN            85 // Ext2_6
+
+#define HOME_PIN            BTN_HOME
 
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
-  #define BEEPER_PIN 44
+  #define BEEPER_PIN        44
   // Pins for DOGM SPI LCD Support
-  #define DOGLCD_A0  70
-  #define DOGLCD_CS  71
+  #define DOGLCD_A0         70
+  #define DOGLCD_CS         71
   #define LCD_SCREEN_ROT_180
 
-  #define SD_DETECT_PIN -1 // Pin 72 if using easy adapter board
+  #define SD_DETECT_PIN     -1 // Pin 72 if using easy adapter board
 
-  #if ENABLED(TEMP_STAT_LEDS)
-    #define STAT_LED_RED      22
-    #define STAT_LED_BLUE     32
-  #endif
+  #define STAT_LED_RED_PIN  22
+  #define STAT_LED_BLUE_PIN 32
 #endif // VIKI2/miniVIKI
diff --git a/Marlin/pins_AZTEEG_X3.h b/Marlin/pins_AZTEEG_X3.h
index b33818e..26f274e 100644
--- a/Marlin/pins_AZTEEG_X3.h
+++ b/Marlin/pins_AZTEEG_X3.h
@@ -32,6 +32,17 @@
 
 #include "pins_RAMPS_13.h"
 
+//
+// Servos
+//
+#undef SERVO0_PIN
+#undef SERVO1_PIN
+#define SERVO0_PIN  44  // SERVO1 port
+#define SERVO1_PIN  55  // SERVO2 port
+
+//
+// LCD / Controller
+//
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
 
   #undef DOGLCD_A0
@@ -41,16 +52,14 @@
   #define DOGLCD_CS         32
   #define BTN_ENC           12
 
-  #if ENABLED(TEMP_STAT_LEDS)
-    #undef STAT_LED_RED
-    #undef STAT_LED_BLUE
-    #define STAT_LED_RED    64
-    #define STAT_LED_BLUE   63
-  #endif
+  #undef STAT_LED_RED_PIN
+  #undef STAT_LED_BLUE_PIN
+  #define STAT_LED_RED_PIN  64
+  #define STAT_LED_BLUE_PIN 63
 
-#elif ENABLED(TEMP_STAT_LEDS)
+#else
 
-  #define STAT_LED_RED       6
-  #define STAT_LED_BLUE     11
+  #define STAT_LED_RED_PIN   6
+  #define STAT_LED_BLUE_PIN 11
 
 #endif
diff --git a/Marlin/pins_AZTEEG_X3_PRO.h b/Marlin/pins_AZTEEG_X3_PRO.h
index 4bc575a..06c2934 100644
--- a/Marlin/pins_AZTEEG_X3_PRO.h
+++ b/Marlin/pins_AZTEEG_X3_PRO.h
@@ -29,6 +29,8 @@
 #include "pins_RAMPS.h"
 
 //
+// Servos
+//
 // Tested this pin with bed leveling on a Delta with 1 servo.
 // Physical wire attachment on EXT1: GND, 5V, D47.
 //
@@ -36,6 +38,8 @@
 #define SERVO0_PIN         47
 
 //
+// Limit Switches
+//
 // Swap the MIN and MAX endstop pins because the X3 Pro comes with only
 // MIN endstop pin headers soldered onto the board.
 //
@@ -80,11 +84,11 @@
 //
 // Temperature Sensors
 //
-#define TEMP_2_PIN         12   // ANALOG NUMBERING
-#define TEMP_3_PIN         11   // ANALOG NUMBERING
-#define TEMP_4_PIN         10   // ANALOG NUMBERING
-#define TC1                 4   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
-#define TC2                 5   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro
+#define TEMP_2_PIN         12   // Analog Input
+#define TEMP_3_PIN         11   // Analog Input
+#define TEMP_4_PIN         10   // Analog Input
+#define TC1                 4   // Analog Input (Thermo couple on Azteeg X3Pro)
+#define TC2                 5   // Analog Input (Thermo couple on Azteeg X3Pro)
 
 //
 // Heaters / Fans
@@ -97,15 +101,15 @@
 #define HEATER_7_PIN       11
 
 #undef FAN_PIN
-#define FAN_PIN             6 //Part Cooling System
+#define FAN_PIN             6 // Part Cooling System
 
-#define CONTROLLERFAN_PIN   4 //Pin used for the fan to cool motherboard (-1 to disable)
+#define CONTROLLERFAN_PIN   4 // Pin used for the fan to cool motherboard (-1 to disable)
 
 // Fans/Water Pump to cool the hotend cool side.
-#define EXTRUDER_0_AUTO_FAN_PIN   5
-#define EXTRUDER_1_AUTO_FAN_PIN   5
-#define EXTRUDER_2_AUTO_FAN_PIN   5
-#define EXTRUDER_3_AUTO_FAN_PIN   5
+#define ORIG_E0_AUTO_FAN_PIN 5
+#define ORIG_E1_AUTO_FAN_PIN 5
+#define ORIG_E2_AUTO_FAN_PIN 5
+#define ORIG_E3_AUTO_FAN_PIN 5
 
 //
 // LCD / Controller
@@ -117,6 +121,6 @@
   #undef SD_DETECT_PIN
   #define SD_DETECT_PIN    49 // For easy adapter board
 #else
-  #define STAT_LED_RED     32
-  #define STAT_LED_BLUE    35
+  #define STAT_LED_RED_PIN 32
+  #define STAT_LED_BLUE_PIN 35
 #endif
diff --git a/Marlin/pins_BAM_DICE_DUE.h b/Marlin/pins_BAM_DICE_DUE.h
index 0c5914f..488861d 100644
--- a/Marlin/pins_BAM_DICE_DUE.h
+++ b/Marlin/pins_BAM_DICE_DUE.h
@@ -32,7 +32,10 @@
 
 #include "pins_RAMPS.h"
 
+//
+// Temperature Sensors
+//
 #undef TEMP_0_PIN
 #undef TEMP_1_PIN
-#define TEMP_0_PIN          9 // ANALOG NUMBERING
-#define TEMP_1_PIN         11 // ANALOG NUMBERING
+#define TEMP_0_PIN          9   // Analog Input
+#define TEMP_1_PIN         11   // Analog Input
diff --git a/Marlin/pins_BQ_ZUM_MEGA_3D.h b/Marlin/pins_BQ_ZUM_MEGA_3D.h
index c05674f..dff48a4 100644
--- a/Marlin/pins_BQ_ZUM_MEGA_3D.h
+++ b/Marlin/pins_BQ_ZUM_MEGA_3D.h
@@ -30,30 +30,56 @@
 
 #define BOARD_NAME "ZUM Mega 3D"
 
+//
+// Heaters / Fans
+//
 #define RAMPS_D8_PIN  10
 #define RAMPS_D9_PIN  12
 #define RAMPS_D10_PIN  9
 #define MOSFET_D_PIN   7
 
+//
+// Auto fans
+//
+#define ORIG_E0_AUTO_FAN_PIN 11
+#define ORIG_E1_AUTO_FAN_PIN  6
+#define ORIG_E2_AUTO_FAN_PIN  6 
+#define ORIG_E3_AUTO_FAN_PIN  6
+
 #include "pins_RAMPS_13.h"
 
+//
+// Limit Switches
+//
 #undef X_MAX_PIN
-#define X_MAX_PIN         79 //  2
+#define X_MAX_PIN         79 // 2
 
+//
+// Z Probe (when not Z_MIN_PIN)
+//
 #undef Z_MIN_PROBE_PIN
 #define Z_MIN_PROBE_PIN   19 // IND_S_5V
 
 #undef Z_ENABLE_PIN
 #define Z_ENABLE_PIN      77 // 62
 
+//
+// Steppers
+//
+#define DIGIPOTSS_PIN     22
+#define DIGIPOT_CHANNELS  { 4, 5, 3, 0, 1 }
+
+//
+// Temperature Sensors
+//
 #undef TEMP_1_PIN
-#define TEMP_1_PIN        14 // 15
+#define TEMP_1_PIN        14   // Analog Input (15)
 
 #undef TEMP_BED_PIN
-#define TEMP_BED_PIN      15 // 14
-
-#define DIGIPOTSS_PIN     22
-#define DIGIPOT_CHANNELS  { 4, 5, 3, 0, 1 }
+#define TEMP_BED_PIN      15   // Analog Input (14)
 
+//
+// Misc. Functions
+//
 #undef PS_ON_PIN             // 12
 #define PS_ON_PIN         81 // External Power Supply
diff --git a/Marlin/pins_BRAINWAVE.h b/Marlin/pins_BRAINWAVE.h
index 6254713..ba9d040 100644
--- a/Marlin/pins_BRAINWAVE.h
+++ b/Marlin/pins_BRAINWAVE.h
@@ -68,14 +68,18 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          7  // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        6  // Bed / Analog pin numbering
+#define TEMP_0_PIN          7   // Analog Input
+#define TEMP_BED_PIN        6   // Analog Input
 
 //
 // Heaters / Fans
 //
 #define HEATER_0_PIN        4  // Extruder
 #define HEATER_BED_PIN     38  // Bed
+
 #define FAN_PIN             3  // Fan
 
+//
+// Misc. Functions
+//
 #define LED_PIN            39
diff --git a/Marlin/pins_BRAINWAVE_PRO.h b/Marlin/pins_BRAINWAVE_PRO.h
index 40f589b..b353581 100644
--- a/Marlin/pins_BRAINWAVE_PRO.h
+++ b/Marlin/pins_BRAINWAVE_PRO.h
@@ -78,9 +78,9 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          2  // Extruder / Analog pin numbering
-#define TEMP_1_PIN          1  // Spare / Analog pin numbering
-#define TEMP_BED_PIN        0  // Bed / Analog pin numbering
+#define TEMP_0_PIN          2   // Analog Input
+#define TEMP_1_PIN          1   // Analog Input
+#define TEMP_BED_PIN        0   // Analog Input
 
 //
 // Heaters / Fans
@@ -90,9 +90,8 @@
 #define FAN_PIN            16  // Fan, PWM
 
 //
-// LCD / Controller
+// Misc. Functions
 //
 #define SDSS               20
 #define SD_DETECT_PIN      12
-
 #define LED_PIN            19
diff --git a/Marlin/pins_CHEAPTRONIC.h b/Marlin/pins_CHEAPTRONIC.h
index a330e37..d1da32c 100644
--- a/Marlin/pins_CHEAPTRONIC.h
+++ b/Marlin/pins_CHEAPTRONIC.h
@@ -64,9 +64,9 @@
 //
 // Temperature sensors
 //
-#define TEMP_0_PIN         15
-#define TEMP_1_PIN         14
-#define TEMP_BED_PIN       13
+#define TEMP_0_PIN         15   // Analog Input
+#define TEMP_1_PIN         14   // Analog Input
+#define TEMP_BED_PIN       13   // Analog Input
 
 //
 // Heaters / Fans
@@ -75,6 +75,9 @@
 #define HEATER_1_PIN       23 // EXTRUDER 2
 #define HEATER_BED_PIN     22
 
+//
+// LCD / Controller
+//
 // Cheaptronic v1.0 doesn't support LCD
 #define LCD_PINS_RS        -1
 #define LCD_PINS_ENABLE    -1
diff --git a/Marlin/pins_CNCONTROLS_11.h b/Marlin/pins_CNCONTROLS_11.h
index 174fb16..fdf6c31 100644
--- a/Marlin/pins_CNCONTROLS_11.h
+++ b/Marlin/pins_CNCONTROLS_11.h
@@ -51,11 +51,12 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0  // ANALOG INPUT !!
-#define TEMP_1_PIN          3  // 3 for tool2 -> 2 for chambertemp
-#define TEMP_2_PIN          2  // 9 for tool3 -> 2 for chambertemp
-#define TEMP_3_PIN         11  // 11 for tool4 -> 2 for chambertemp
-#define TEMP_BED_PIN        1  // ANALOG INPUT !!
+#define TEMP_0_PIN          0   // Analog Input
+#define TEMP_1_PIN          3   // Analog Input.  3 for tool2 -> 2 for chambertemp
+#define TEMP_2_PIN          2   // Analog Input.  9 for tool3 -> 2 for chambertemp
+#define TEMP_3_PIN         11   // Analog Input. 11 for tool4 -> 2 for chambertemp
+#define TEMP_BED_PIN        1   // Analog Input
+//#define TEMP_CHAMBER_PIN    2   // Analog Input
 
 //
 // Heaters / Fans
@@ -66,6 +67,19 @@
 #define HEATER_3_PIN       46
 #define HEATER_BED_PIN      2
 
+//#define FAN_PIN           7  // common PWM pin for all tools
+
+#define ORIG_E0_AUTO_FAN_PIN 7
+#define ORIG_E1_AUTO_FAN_PIN 7
+#define ORIG_E2_AUTO_FAN_PIN 7
+#define ORIG_E3_AUTO_FAN_PIN 7
+
+//
+// Misc. Functions
+//
+#define SDSS               53
+#define SD_DETECT_PIN      13
+
 // Tools
 
 //#define TOOL_0_PIN           4
@@ -76,18 +90,10 @@
 
 // Common I/O
 
-//#define TEMP_CHAMBER_PIN     2  // ANALOG INPUT !!
 //#define FIL_RUNOUT_PIN      -1
 //#define PWM_1_PIN           11
 //#define PWM_2_PIN           10
 //#define SPARE_IO            12
-//#define FAN_PIN              7  // common PWM pin for all tools
-
-//
-// SD Card
-//
-#define SDSS               53
-#define SD_DETECT_PIN      13
 
 //
 // LCD / Controller
@@ -112,8 +118,5 @@
 //#define UI1                31
 //#define UI2                22
 
-//
-// Misc. Functions
-//
-#define STAT_LED_BLUE      -1
-#define STAT_LED_RED       31
+#define STAT_LED_BLUE_PIN  -1
+#define STAT_LED_RED_PIN   31
diff --git a/Marlin/pins_CNCONTROLS_12.h b/Marlin/pins_CNCONTROLS_12.h
index c3d6945..809d1a6 100644
--- a/Marlin/pins_CNCONTROLS_12.h
+++ b/Marlin/pins_CNCONTROLS_12.h
@@ -51,12 +51,12 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0  // ANALOG INPUT !!
-#define TEMP_1_PIN          9  // 9 for tool2 -> 13 for chambertemp
-#define TEMP_2_PIN         13  // 10 for tool3 -> 13 for chambertemp
-#define TEMP_3_PIN         11  // 11 for tool4 -> 13 for chambertemp
-#define TEMP_BED_PIN       14  // ANALOG INPUT !!
-//#define TEMP_CHAMBER_PIN   13  // ANALOG INPUT !!
+#define TEMP_0_PIN          0   // Analog Input
+#define TEMP_1_PIN          9   // Analog Input.  9 for tool2 -> 13 for chambertemp
+#define TEMP_2_PIN         13   // Analog Input. 10 for tool3 -> 13 for chambertemp
+#define TEMP_3_PIN         11   // Analog Input. 11 for tool4 -> 13 for chambertemp
+#define TEMP_BED_PIN       14   // Analog Input
+//#define TEMP_CHAMBER_PIN   13   // Analog Input
 
 //
 // Heaters / Fans
@@ -69,9 +69,16 @@
 
 #define FAN_PIN             5  // 5 is PWMtool3 -> 7 is common PWM pin for all tools
 
-//#define PWM_1_PIN          12
-//#define PWM_2_PIN          13
-//#define SPARE_IO           17
+#define ORIG_E0_AUTO_FAN_PIN 7
+#define ORIG_E1_AUTO_FAN_PIN 7
+#define ORIG_E2_AUTO_FAN_PIN 7
+#define ORIG_E3_AUTO_FAN_PIN 7
+
+//
+// Misc. Functions
+//
+#define SDSS               53
+#define SD_DETECT_PIN      15
 
 // Tools
 
@@ -86,6 +93,11 @@
 
 // Common I/O
 
+#define FIL_RUNOUT_PIN     18
+//#define PWM_1_PIN          12
+//#define PWM_2_PIN          13
+//#define SPARE_IO           17
+
 //
 // LCD / Controller
 //
@@ -111,14 +123,5 @@
 //#define UI1              43
 //#define UI2              37
 
-#define STAT_LED_BLUE      -1
-#define STAT_LED_RED       10 // TOOL_0_PWM_PIN
-
-//
-// SD Card
-//
-#define SDSS               53
-#define SD_DETECT_PIN      15
-
-// Other
-#define FIL_RUNOUT_PIN     18
+#define STAT_LED_BLUE_PIN  -1
+#define STAT_LED_RED_PIN   10 // TOOL_0_PWM_PIN
diff --git a/Marlin/pins_ELEFU_3.h b/Marlin/pins_ELEFU_3.h
index 5526307..51bd078 100644
--- a/Marlin/pins_ELEFU_3.h
+++ b/Marlin/pins_ELEFU_3.h
@@ -77,10 +77,10 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          3 // ANALOG NUMBERING
-#define TEMP_1_PIN          2 // ANALOG NUMBERING
-#define TEMP_2_PIN          1 // ANALOG NUMBERING
-#define TEMP_BED_PIN        0 // ANALOG NUMBERING
+#define TEMP_0_PIN          3   // Analog Input
+#define TEMP_1_PIN          2   // Analog Input
+#define TEMP_2_PIN          1   // Analog Input
+#define TEMP_BED_PIN        0   // Analog Input
 
 //
 // Heaters / Fans
@@ -116,34 +116,34 @@
 #endif // RA_CONTROL_PANEL
 
 #if ENABLED(RA_DISCO)
-  //variables for which pins the TLC5947 is using
+  // variables for which pins the TLC5947 is using
   #define TLC_CLOCK_PIN    25
   #define TLC_BLANK_PIN    23
   #define TLC_XLAT_PIN     22
   #define TLC_DATA_PIN     24
 
-  //We also need to define pin to port number mapping for the 2560 to match the pins listed above. If you change the TLC pins, update this as well per the 2560 datasheet!
-  //This currently only works with the RA Board.
-  #define TLC_CLOCK_BIT 3 //bit 3 on port A
-  #define TLC_CLOCK_PORT &PORTA //bit 3 on port A
+  // We also need to define pin to port number mapping for the 2560 to match the pins listed above. If you change the TLC pins, update this as well per the 2560 datasheet!
+  // This currently only works with the RA Board.
+  #define TLC_CLOCK_BIT 3 // bit 3 on port A
+  #define TLC_CLOCK_PORT &PORTA // bit 3 on port A
 
-  #define TLC_BLANK_BIT 1 //bit 1 on port A
-  #define TLC_BLANK_PORT &PORTA //bit 1 on port A
+  #define TLC_BLANK_BIT 1 // bit 1 on port A
+  #define TLC_BLANK_PORT &PORTA // bit 1 on port A
 
-  #define TLC_DATA_BIT 2 //bit 2 on port A
-  #define TLC_DATA_PORT &PORTA //bit 2 on port A
+  #define TLC_DATA_BIT 2 // bit 2 on port A
+  #define TLC_DATA_PORT &PORTA // bit 2 on port A
 
-  #define TLC_XLAT_BIT 0 //bit 0 on port A
-  #define TLC_XLAT_PORT &PORTA //bit 0 on port A
+  #define TLC_XLAT_BIT 0 // bit 0 on port A
+  #define TLC_XLAT_PORT &PORTA // bit 0 on port A
 
-  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful
-  //Leave it at at least 1 if you have enabled RA_LIGHTING
-  //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.
+  // change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful
+  // Leave it at at least 1 if you have enabled RA_LIGHTING
+  // The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.
   #define NUM_TLCS 2
 
-  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions.
-  //Modify them according to your specific situation.
-  //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.
+  // These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions.
+  // Modify them according to your specific situation.
+  // NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.
   #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards
   //#define TRANS_ARRAY {7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 11, 12, 13, 14, 15} //backwards
 #endif // RA_DISCO
diff --git a/Marlin/pins_FELIX2.h b/Marlin/pins_FELIX2.h
index 31906b5..45bf257 100644
--- a/Marlin/pins_FELIX2.h
+++ b/Marlin/pins_FELIX2.h
@@ -30,16 +30,25 @@
 
 #define BOARD_NAME "Felix 2.0+"
 
+//
+// Heaters / Fans
+//
 // Power outputs EFBF or EFBE
 #define MOSFET_D_PIN 7
 
 #include "pins_RAMPS.h"
 
+//
+// Misc. Functions
+//
 #undef SDPOWER
 #define SDPOWER             1
 
 #define PS_ON_PIN          12
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
 
   #define SD_DETECT_PIN 6
diff --git a/Marlin/pins_GEN3_MONOLITHIC.h b/Marlin/pins_GEN3_MONOLITHIC.h
index aa907be..e7a5dfb 100644
--- a/Marlin/pins_GEN3_MONOLITHIC.h
+++ b/Marlin/pins_GEN3_MONOLITHIC.h
@@ -60,7 +60,7 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0
+#define TEMP_0_PIN          0   // Analog Input
 
 //
 // Heaters
@@ -68,7 +68,7 @@
 #define HEATER_0_PIN       16
 
 //
-// Etc.
+// Misc. Functions
 //
 #define PS_ON_PIN          14 // Alex, does this work on the card?
 
diff --git a/Marlin/pins_GEN3_PLUS.h b/Marlin/pins_GEN3_PLUS.h
index 3f6c9bf..b5236d8 100644
--- a/Marlin/pins_GEN3_PLUS.h
+++ b/Marlin/pins_GEN3_PLUS.h
@@ -56,13 +56,11 @@
 #define E0_DIR_PIN         21
 #define E0_ENABLE_PIN      13
 
-#define PS_ON_PIN          14
-
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0   // ANALOG INPUT (pin 33 extruder)
-#define TEMP_BED_PIN        5   // ANALOG INPUT (pin 34 bed)
+#define TEMP_0_PIN          0   // Analog Input (pin 33 extruder)
+#define TEMP_BED_PIN        5   // Analog Input (pin 34 bed)
 
 //
 // Heaters
@@ -71,6 +69,8 @@
 #define HEATER_BED_PIN     16
 
 //
-// SD Card
+// Misc. Functions
 //
 #define SDSS                4
+#define PS_ON_PIN          14
+
diff --git a/Marlin/pins_GEN6.h b/Marlin/pins_GEN6.h
index 530967e..9d1e1bc 100644
--- a/Marlin/pins_GEN6.h
+++ b/Marlin/pins_GEN6.h
@@ -56,33 +56,29 @@
 #define Z_DIR_PIN          28
 #define Z_ENABLE_PIN       29
 
-#define E0_STEP_PIN         4    //Edited @ EJE Electronics 20100715
-#define E0_DIR_PIN          2    //Edited @ EJE Electronics 20100715
-#define E0_ENABLE_PIN       3    //Added @ EJE Electronics 20100715
+#define E0_STEP_PIN         4   // Edited @ EJE Electronics 20100715
+#define E0_DIR_PIN          2   // Edited @ EJE Electronics 20100715
+#define E0_ENABLE_PIN       3   // Added @ EJE Electronics 20100715
 
 //
 // Temperature Sensor
 //
-#define TEMP_0_PIN          5    //changed @ rkoeppl 20110410
+#define TEMP_0_PIN          5   // Analog Input
 
 //
 // Heaters
 //
-#define HEATER_0_PIN       14    //changed @ rkoeppl 20110410
+#define HEATER_0_PIN       14   // changed @ rkoeppl 20110410
 
 #if !MB(GEN6)
-  #define HEATER_BED_PIN    1    //changed @ rkoeppl 20110410
-  #define TEMP_BED_PIN      0    //changed @ rkoeppl 20110410
+  #define HEATER_BED_PIN    1   // changed @ rkoeppl 20110410
+  #define TEMP_BED_PIN      0   // Analog Input
 #endif
 
 //
-// SD Card
-//
-#define SDSS               17
-
-//
 // Misc. Functions
 //
+#define SDSS               17
 #define DEBUG_PIN           0
 
 // RS485 pins
diff --git a/Marlin/pins_GEN7_12.h b/Marlin/pins_GEN7_12.h
index 951641f..53edb32 100644
--- a/Marlin/pins_GEN7_12.h
+++ b/Marlin/pins_GEN7_12.h
@@ -73,8 +73,8 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          1
-#define TEMP_BED_PIN        2
+#define TEMP_0_PIN          1   // Analog Input
+#define TEMP_BED_PIN        2   // Analog Input
 
 //
 // Heaters / Fans
diff --git a/Marlin/pins_GEN7_14.h b/Marlin/pins_GEN7_14.h
index 87ccb60..d200137 100644
--- a/Marlin/pins_GEN7_14.h
+++ b/Marlin/pins_GEN7_14.h
@@ -32,40 +32,52 @@
 
 #define GEN7_VERSION 14 // v1.4
 
-//x axis pins
-#define X_STEP_PIN 29
-#define X_DIR_PIN 28
-#define X_ENABLE_PIN 25
-#define X_STOP_PIN 0
+//
+// Limit switches
+//
+#define X_STOP_PIN          0
+#define Y_STOP_PIN          1
+#define Z_STOP_PIN          2
 
-//y axis pins
-#define Y_STEP_PIN 27
-#define Y_DIR_PIN 26
-#define Y_ENABLE_PIN 25
-#define Y_STOP_PIN 1
+//
+// Steppers
+//
+#define X_STEP_PIN         29
+#define X_DIR_PIN          28
+#define X_ENABLE_PIN       25
 
-//z axis pins
-#define Z_STEP_PIN 23
-#define Z_DIR_PIN 22
-#define Z_ENABLE_PIN 25
-#define Z_STOP_PIN 2
+#define Y_STEP_PIN         27
+#define Y_DIR_PIN          26
+#define Y_ENABLE_PIN       25
 
-//extruder pins
-#define E0_STEP_PIN 19
-#define E0_DIR_PIN 18
-#define E0_ENABLE_PIN 25
+#define Z_STEP_PIN         23
+#define Z_DIR_PIN          22
+#define Z_ENABLE_PIN       25
 
-#define TEMP_0_PIN 1
-#define TEMP_BED_PIN 0
+#define E0_STEP_PIN        19
+#define E0_DIR_PIN         18
+#define E0_ENABLE_PIN      25
 
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          1   // Analog Input
+#define TEMP_BED_PIN        0   // Analog Input
+
+//
+// Heaters
+//
 #define HEATER_0_PIN 4
 #define HEATER_BED_PIN 3
 
+//
+// Misc. Functions
+//
 #define PS_ON_PIN 15
 
-//our pin for debugging.
+// A pin for debugging
 #define DEBUG_PIN 0
 
-//our RS485 pins
+// RS485 pins
 #define TX_ENABLE_PIN 12
 #define RX_ENABLE_PIN 13
diff --git a/Marlin/pins_GEN7_CUSTOM.h b/Marlin/pins_GEN7_CUSTOM.h
index 06aaebd..81809d6 100644
--- a/Marlin/pins_GEN7_CUSTOM.h
+++ b/Marlin/pins_GEN7_CUSTOM.h
@@ -33,58 +33,71 @@
 
 #define BOARD_NAME      "Gen7 Custom"
 
-//x axis pins
-#define X_STEP_PIN      21                  // different from standard GEN7
-#define X_DIR_PIN       20                  // different from standard GEN7
-#define X_ENABLE_PIN    24
+//
+// Limit Switches
+//
 #define X_STOP_PIN       0
+#define Y_STOP_PIN       1
+#define Z_STOP_PIN       2
+
+//
+// Steppers
+//
+#define X_STEP_PIN      21   // different from standard GEN7
+#define X_DIR_PIN       20   // different from standard GEN7
+#define X_ENABLE_PIN    24
 
-//y axis pins
 #define Y_STEP_PIN      23
 #define Y_DIR_PIN       22
 #define Y_ENABLE_PIN    24
-#define Y_STOP_PIN       1
 
-//z axis pins
 #define Z_STEP_PIN      26
 #define Z_DIR_PIN       25
 #define Z_ENABLE_PIN    24
-#define Z_STOP_PIN       2
 
-//extruder pins
 #define E0_STEP_PIN     28
 #define E0_DIR_PIN      27
 #define E0_ENABLE_PIN   24
 
-#define TEMP_0_PIN       2
-#define TEMP_BED_PIN     1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN       2   // Analog Input
+#define TEMP_BED_PIN     1   // Analog Input (pin 34 bed)
 
+//
+// Heaters
+//
 #define HEATER_0_PIN     4
 #define HEATER_BED_PIN   3  // (bed)
 
-#define SDSS            31                  // SCL pin of I2C header || CS Pin for SD Card support
-
+//
+// Misc. Functions
+//
+#define SDSS            31  // SCL pin of I2C header || CS Pin for SD Card support
 #define PS_ON_PIN       19
-//our pin for debugging.
 
+// A pin for debugging
 #define DEBUG_PIN       -1
 
-//our RS485 pins
-//#define TX_ENABLE_PIN       12
-//#define RX_ENABLE_PIN       13
-
-#define BEEPER_PIN       -1
+//
+// LCD / Controller
+//
+#define BEEPER_PIN      -1
 
-//Pins for 4bit LCD Support
-#define LCD_PINS_RS 18
+// 4bit LCD Support
+#define LCD_PINS_RS     18
 #define LCD_PINS_ENABLE 17
-#define LCD_PINS_D4 16
-#define LCD_PINS_D5 15
-#define LCD_PINS_D6 13
-#define LCD_PINS_D7 14
-
-//buttons are directly attached
-#define BTN_EN1 11
-#define BTN_EN2 10
-#define BTN_ENC 12
-
+#define LCD_PINS_D4     16
+#define LCD_PINS_D5     15
+#define LCD_PINS_D6     13
+#define LCD_PINS_D7     14
+
+// Buttons are directly attached
+#define BTN_EN1         11
+#define BTN_EN2         10
+#define BTN_ENC         12
+
+// RS485 pins
+//#define TX_ENABLE_PIN   12
+//#define RX_ENABLE_PIN   13
diff --git a/Marlin/pins_K8400.h b/Marlin/pins_K8400.h
index a15e9e4..030546c 100644
--- a/Marlin/pins_K8400.h
+++ b/Marlin/pins_K8400.h
@@ -37,16 +37,31 @@
 
 #include "pins_3DRAG.h"
 
-#undef  X_MAX_PIN
-#define X_MAX_PIN     -1
-#undef  Y_MAX_PIN
-#define Y_MAX_PIN     -1
+//
+// Limit Switches
+//
+#define X_STOP_PIN  3
+#define Y_STOP_PIN 14
 
+#undef X_MIN_PIN
+#undef X_MAX_PIN
+#undef Y_MIN_PIN
+#undef Y_MAX_PIN
+
+//
+// Steppers
+//
 #undef E1_STEP_PIN
 #define E1_STEP_PIN   32
 
-#undef PS_ON_PIN
-#undef KILL_PIN
-
+//
+// Heaters / Fans
+//
 #undef HEATER_1_PIN
 #define HEATER_1_PIN  11
+
+//
+// Misc. Functions
+//
+#undef PS_ON_PIN
+#undef KILL_PIN
diff --git a/Marlin/pins_LEAPFROG.h b/Marlin/pins_LEAPFROG.h
index ece4d0f..a7fffa5 100644
--- a/Marlin/pins_LEAPFROG.h
+++ b/Marlin/pins_LEAPFROG.h
@@ -64,19 +64,11 @@
 #define E1_ENABLE_PIN      36 // 36
 
 //
-// Misc. Functions
-//
-#define SDSS               11
-#define LED_PIN            13
-#define SOL1_PIN           16
-#define SOL2_PIN           17
-
-//
 // Temperature Sensors
 //
-#define TEMP_0_PIN         13 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_1_PIN         15 // 1
-#define TEMP_BED_PIN       14 // 1,2 or I2C
+#define TEMP_0_PIN         13   // Analog Input (D27)
+#define TEMP_1_PIN         15   // Analog Input (1)
+#define TEMP_BED_PIN       14   // Analog Input (1,2 or I2C)
 
 //
 // Heaters / Fans
@@ -88,5 +80,12 @@
 
 #define FAN_PIN             7
 
-/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
+//
+// Misc. Functions
+//
+#define SDSS               11
+#define LED_PIN            13
+#define SOL1_PIN           16
+#define SOL2_PIN           17
 
+/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
diff --git a/Marlin/pins_MEGACONTROLLER.h b/Marlin/pins_MEGACONTROLLER.h
index 2828842..10ffe32 100644
--- a/Marlin/pins_MEGACONTROLLER.h
+++ b/Marlin/pins_MEGACONTROLLER.h
@@ -83,32 +83,26 @@
 #define E1_ENABLE_PIN      25
 
 //
-// Misc. Functions
-//
-#define SDSS               53
-#define LED_PIN            13
-
-//
 // Temperature Sensors
 //
 #if TEMP_SENSOR_0 == -1
-  #define TEMP_0_PIN        4 // ANALOG NUMBERING
+  #define TEMP_0_PIN        4   // Analog Input
 #else
-  #define TEMP_0_PIN        0 // ANALOG NUMBERING
+  #define TEMP_0_PIN        0   // Analog Input
 #endif
 
 #if TEMP_SENSOR_1 == -1
-  #define TEMP_1_PIN        5 // ANALOG NUMBERING
+  #define TEMP_1_PIN        5   // Analog Input
 #else
-  #define TEMP_1_PIN        2 // ANALOG NUMBERING
+  #define TEMP_1_PIN        2   // Analog Input
 #endif
 
-#define TEMP_2_PIN          3 // ANALOG NUMBERING
+#define TEMP_2_PIN          3   // Analog Input
 
 #if TEMP_SENSOR_BED == -1
-  #define TEMP_BED_PIN      6 // ANALOG NUMBERING
+  #define TEMP_BED_PIN      6   // Analog Input
 #else
-  #define TEMP_BED_PIN      1 // ANALOG NUMBERING
+  #define TEMP_BED_PIN      1   // Analog Input
 #endif
 
 //
@@ -127,6 +121,12 @@
 #define FAN_SOFT_PWM
 
 //
+// Misc. Functions
+//
+#define SDSS               53
+#define LED_PIN            13
+
+//
 // LCD / Controller
 //
 #if ENABLED(MINIPANEL)
@@ -134,7 +134,7 @@
   // Pins for DOGM SPI LCD Support
   #define DOGLCD_A0        47
   #define DOGLCD_CS        45
-  #define LCD_PIN_BL       44  // backlight LED on PA3
+  #define LCD_BACKLIGHT_PIN 44  // backlight LED on PA3
 
   #define KILL_PIN         12
   // GLCD features
@@ -150,4 +150,3 @@
 
   #define SD_DETECT_PIN    49
 #endif // MINIPANEL
-
diff --git a/Marlin/pins_MEGATRONICS.h b/Marlin/pins_MEGATRONICS.h
index 893c6fc..5b8d41f 100644
--- a/Marlin/pins_MEGATRONICS.h
+++ b/Marlin/pins_MEGATRONICS.h
@@ -72,22 +72,15 @@
 #define E1_ENABLE_PIN      30
 
 //
-// Misc. Functions
-//
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          12
-
-//
 // Temperature Sensors
 //
 #if TEMP_SENSOR_0 == -1
-  #define TEMP_0_PIN        8   // ANALOG NUMBERING
+  #define TEMP_0_PIN        8   // Analog Input
 #else
-  #define TEMP_0_PIN       13   // ANALOG NUMBERING
+  #define TEMP_0_PIN       13   // Analog Input
 #endif
-#define TEMP_1_PIN         15   // ANALOG NUMBERING
-#define TEMP_BED_PIN       14   // ANALOG NUMBERING
+#define TEMP_1_PIN         15   // Analog Input
+#define TEMP_BED_PIN       14   // Analog Input
 
 //
 // Heaters / Fans
@@ -99,6 +92,13 @@
 #define FAN_PIN             7   // IO pin. Buffer needed
 
 //
+// Misc. Functions
+//
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          12
+
+//
 // LCD / Controller
 //
 #define BEEPER_PIN         33
diff --git a/Marlin/pins_MEGATRONICS_2.h b/Marlin/pins_MEGATRONICS_2.h
index ec07280..be3ed4c 100644
--- a/Marlin/pins_MEGATRONICS_2.h
+++ b/Marlin/pins_MEGATRONICS_2.h
@@ -76,31 +76,24 @@
 #define E2_ENABLE_PIN      22
 
 //
-// Misc. Functions
-//
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          12
-
-//
 // Temperature Sensors
 //
 #if TEMP_SENSOR_0 == -1
-  #define TEMP_0_PIN        4 // ANALOG NUMBERING
+  #define TEMP_0_PIN        4   // Analog Input
 #else
-  #define TEMP_0_PIN       13 // ANALOG NUMBERING
+  #define TEMP_0_PIN       13   // Analog Input
 #endif
 
 #if TEMP_SENSOR_1 == -1
-  #define TEMP_1_PIN        8 // ANALOG NUMBERING
+  #define TEMP_1_PIN        8   // Analog Input
 #else
-  #define TEMP_1_PIN       15 // ANALOG NUMBERING
+  #define TEMP_1_PIN       15   // Analog Input
 #endif
 
 #if TEMP_SENSOR_BED == -1
-  #define TEMP_BED_PIN      8 // ANALOG NUMBERING
+  #define TEMP_BED_PIN      8   // Analog Input
 #else
-  #define TEMP_BED_PIN     14 // ANALOG NUMBERING
+  #define TEMP_BED_PIN     14   // Analog Input
 #endif
 
 //
@@ -114,6 +107,13 @@
 #define FAN1_PIN            6
 
 //
+// Misc. Functions
+//
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          12
+
+//
 // LCD / Controller
 //
 #define BEEPER_PIN         64
diff --git a/Marlin/pins_MEGATRONICS_3.h b/Marlin/pins_MEGATRONICS_3.h
index 4035a78..8f02325 100644
--- a/Marlin/pins_MEGATRONICS_3.h
+++ b/Marlin/pins_MEGATRONICS_3.h
@@ -63,6 +63,8 @@
   #define Z_MIN_PROBE_PIN  19
 #endif
 
+#define SLED_PIN           -1
+
 //
 // Steppers
 //
@@ -91,35 +93,27 @@
 #define E2_ENABLE_PIN      23
 
 //
-// Misc. Functions
-//
-#define SDSS               53
-#define LED_PIN            13
-#define PS_ON_PIN          12
-#define SLED_PIN           -1
-
-//
 // Temperature Sensors
 //
 #if TEMP_SENSOR_0 == -1
-  #define TEMP_0_PIN       11 // ANALOG NUMBERING
+  #define TEMP_0_PIN       11   // Analog Input
 #else
-  #define TEMP_0_PIN       15 // ANALOG NUMBERING
+  #define TEMP_0_PIN       15   // Analog Input
 #endif
 #if TEMP_SENSOR_1 == -1
-  #define TEMP_1_PIN       10 // ANALOG NUMBERING
+  #define TEMP_1_PIN       10   // Analog Input
 #else
-  #define TEMP_1_PIN       13 // ANALOG NUMBERING
+  #define TEMP_1_PIN       13   // Analog Input
 #endif
 #if TEMP_SENSOR_2 == -1
-  #define TEMP_2_PIN        9 // ANALOG NUMBERING
+  #define TEMP_2_PIN        9   // Analog Input
 #else
-  #define TEMP_2_PIN       12 // ANALOG NUMBERING
+  #define TEMP_2_PIN       12   // Analog Input
 #endif
 #if TEMP_SENSOR_BED == -1
-  #define TEMP_BED_PIN      8 // ANALOG NUMBERING
+  #define TEMP_BED_PIN      8   // Analog Input
 #else
-  #define TEMP_BED_PIN     14 // ANALOG NUMBERING
+  #define TEMP_BED_PIN     14   // Analog Input
 #endif
 
 //
@@ -134,6 +128,13 @@
 #define FAN1_PIN            7
 
 //
+// Misc. Functions
+//
+#define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          12
+
+//
 // LCD / Controller
 //
 #define BEEPER_PIN         61
diff --git a/Marlin/pins_MINIRAMBO.h b/Marlin/pins_MINIRAMBO.h
index 40b3afc..551926a 100644
--- a/Marlin/pins_MINIRAMBO.h
+++ b/Marlin/pins_MINIRAMBO.h
@@ -54,44 +54,46 @@
 #define X_STEP_PIN         37
 #define X_DIR_PIN          48
 #define X_ENABLE_PIN       29
-#define X_MS1_PIN          40
-#define X_MS2_PIN          41
 
 #define Y_STEP_PIN         36
 #define Y_DIR_PIN          49
 #define Y_ENABLE_PIN       28
-#define Y_MS1_PIN          69
-#define Y_MS2_PIN          39
 
 #define Z_STEP_PIN         35
 #define Z_DIR_PIN          47
 #define Z_ENABLE_PIN       27
-#define Z_MS1_PIN          68
-#define Z_MS2_PIN          67
 
 #define E0_STEP_PIN        34
 #define E0_DIR_PIN         43
 #define E0_ENABLE_PIN      26
-#define E0_MS1_PIN         65
-#define E0_MS2_PIN         66
 
 #define E1_STEP_PIN        -1
 #define E1_DIR_PIN         -1
 #define E1_ENABLE_PIN      -1
 
+// Microstepping pins - Mapping not from fastio.h (?)
+#define X_MS1_PIN          40
+#define X_MS2_PIN          41
+#define Y_MS1_PIN          69
+#define Y_MS2_PIN          39
+#define Z_MS1_PIN          68
+#define Z_MS2_PIN          67
+#define E0_MS1_PIN         65
+#define E0_MS2_PIN         66
+
 #define MOTOR_CURRENT_PWM_XY_PIN 46
 #define MOTOR_CURRENT_PWM_Z_PIN  45
 #define MOTOR_CURRENT_PWM_E_PIN  44
-//Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
+// Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
 #define MOTOR_CURRENT_PWM_RANGE 2000
 #define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}
 
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0
-#define TEMP_1_PIN          1
-#define TEMP_BED_PIN        2
+#define TEMP_0_PIN          0   // Analog Input
+#define TEMP_1_PIN          1   // Analog Input
+#define TEMP_BED_PIN        2   // Analog Input
 
 //
 // Heaters / Fans
@@ -129,12 +131,12 @@
     #define LCD_PINS_D6    85
     #define LCD_PINS_D7    71
 
-    //buttons are directly attached using AUX-2
+    // buttons are directly attached using AUX-2
     #define BTN_EN1        14
     #define BTN_EN2        72
     #define BTN_ENC         9  // the click
 
     #define SD_DETECT_PIN  15
 
-  #endif //NEWPANEL
-#endif //ULTRA_LCD
+  #endif // NEWPANEL
+#endif // ULTRA_LCD
diff --git a/Marlin/pins_MINITRONICS.h b/Marlin/pins_MINITRONICS.h
index ecd29d9..7ee89a0 100644
--- a/Marlin/pins_MINITRONICS.h
+++ b/Marlin/pins_MINITRONICS.h
@@ -71,12 +71,9 @@
 //
 // Temperature Sensors
 //
-#define SDSS               16
-#define LED_PIN            46
-
-#define TEMP_0_PIN          7 // ANALOG NUMBERING
-#define TEMP_1_PIN          6 // ANALOG NUMBERING
-#define TEMP_BED_PIN        6 // ANALOG NUMBERING
+#define TEMP_0_PIN          7   // Analog Input
+#define TEMP_1_PIN          6   // Analog Input
+#define TEMP_BED_PIN        6   // Analog Input
 
 //
 // Heaters / Fans
@@ -88,6 +85,12 @@
 #define FAN_PIN             9
 
 //
+// Misc. Functions
+//
+#define SDSS               16
+#define LED_PIN            46
+
+//
 // LCD / Controller
 //
 #define BEEPER_PIN         -1
@@ -118,5 +121,5 @@
   #define BTN_EN2          -1
   #define BTN_ENC          -1
 
-  #define SD_DETECT_PIN    -1  // Minitronics doesn't use this
+  #define SD_DETECT_PIN    -1 // Minitronics doesn't use this
 #endif
diff --git a/Marlin/pins_MKS_13.h b/Marlin/pins_MKS_13.h
index 3b5b242..ce12171 100644
--- a/Marlin/pins_MKS_13.h
+++ b/Marlin/pins_MKS_13.h
@@ -35,11 +35,17 @@
 
 #define BOARD_NAME "MKS > v1.3"
 
+//
+// Heaters / Fans
+//
 // Power outputs EFBF or EFBE
 #define MOSFET_D_PIN 7
 
 #include "pins_RAMPS.h"
 
+//
+// LCD / Controller
+//
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
   /**
    * VIKI2 Has two groups of wires with...
@@ -120,9 +126,9 @@
   #define BEEPER_PIN      25
 
   // yellow               RED-LED
-  #define STAT_LED_RED    16
+  #define STAT_LED_RED_PIN 16
 
   // white                BLUE-LED
-  #define STAT_LED_BLUE   17
+  #define STAT_LED_BLUE_PIN 17
 
 #endif
diff --git a/Marlin/pins_MKS_BASE.h b/Marlin/pins_MKS_BASE.h
index 8c72220..c098341 100644
--- a/Marlin/pins_MKS_BASE.h
+++ b/Marlin/pins_MKS_BASE.h
@@ -30,6 +30,9 @@
 
 #define BOARD_NAME "MKS BASE 1.0"
 
+//
+// Heaters / Fans
+//
 // Power outputs EFBF or EFBE
 #define MOSFET_D_PIN 7
 
diff --git a/Marlin/pins_OMCA.h b/Marlin/pins_OMCA.h
index 9ec6309..a69d61e 100644
--- a/Marlin/pins_OMCA.h
+++ b/Marlin/pins_OMCA.h
@@ -57,33 +57,32 @@
 
 #define BOARD_NAME         "Final OMCA"
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN         0
+#define Y_STOP_PIN         1
+#define Z_STOP_PIN         2
+
+//
+// Steppers
+//
 #define X_STEP_PIN         26
 #define X_DIR_PIN          25
 #define X_ENABLE_PIN       10
-#define X_STOP_PIN         0
 
 #define Y_STEP_PIN         28
 #define Y_DIR_PIN          27
 #define Y_ENABLE_PIN       10
-#define Y_STOP_PIN         1
 
 #define Z_STEP_PIN         23
 #define Z_DIR_PIN          22
 #define Z_ENABLE_PIN       10
-#define Z_STOP_PIN         2
 
 #define E0_STEP_PIN        24
 #define E0_DIR_PIN         21
 #define E0_ENABLE_PIN      10
 
-// future proofing
-#define __FS  20
-#define __FD  19
-#define __GS  18
-#define __GD  13
-
-#define UNUSED_PWM         14 // PWM on LEFT connector
-
 #define E1_STEP_PIN        -1 // 21
 #define E1_DIR_PIN         -1 // 20
 #define E1_ENABLE_PIN      -1 // 19
@@ -92,16 +91,33 @@
 #define E2_DIR_PIN         -1 // 20
 #define E2_ENABLE_PIN      -1 // 18
 
-#define SDSS               11
-#define FAN_PIN            14 // PWM on MIDDLE connector
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          0   // Analog Input
+#define TEMP_1_PIN          1   // Analog Input
+#define TEMP_BED_PIN        2   // Analog Input (1,2 or I2C)
 
+//
+// Heaters / Fans
+//
 #define HEATER_0_PIN        3 // DONE PWM on RIGHT connector
 #define HEATER_BED_PIN      4
 
-#define TEMP_0_PIN          0 // ANALOG INPUT NUMBERING
-#define TEMP_1_PIN          1 // ANALOG
-#define TEMP_BED_PIN        2 // 1,2 or I2C
+#define FAN_PIN            14 // PWM on MIDDLE connector
+
+//
+// Misc. Functions
+//
+#define SDSS               11
 
 #define I2C_SCL            16
 #define I2C_SDA            17
 
+// future proofing
+#define __FS  20
+#define __FD  19
+#define __GS  18
+#define __GD  13
+
+#define UNUSED_PWM         14 // PWM on LEFT connector
diff --git a/Marlin/pins_OMCA_A.h b/Marlin/pins_OMCA_A.h
index 39d232a..d325a64 100644
--- a/Marlin/pins_OMCA_A.h
+++ b/Marlin/pins_OMCA_A.h
@@ -56,20 +56,27 @@
 
 #define BOARD_NAME         "Alpha OMCA"
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN          0
+#define Y_STOP_PIN          1
+#define Z_STOP_PIN          2
+
+//
+// Steppers
+//
 #define X_STEP_PIN         21
 #define X_DIR_PIN          20
 #define X_ENABLE_PIN       24
-#define X_STOP_PIN          0
 
 #define Y_STEP_PIN         23
 #define Y_DIR_PIN          22
 #define Y_ENABLE_PIN       24
-#define Y_STOP_PIN          1
 
 #define Z_STEP_PIN         26
 #define Z_DIR_PIN          25
 #define Z_ENABLE_PIN       24
-#define Z_STOP_PIN          2
 
 #define E0_STEP_PIN        28
 #define E0_DIR_PIN         27
@@ -83,10 +90,21 @@
 #define E2_DIR_PIN         -1 // 16
 #define E2_ENABLE_PIN      24
 
-#define SDSS               11
-#define FAN_PIN             3
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          0   // Analog Input (D27)
 
+//
+// Heaters / Fans
+//
 #define HEATER_0_PIN        4
-#define TEMP_0_PIN          0 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+
+#define FAN_PIN             3
+
+//
+// Misc. Functions
+//
+#define SDSS               11
 
 /*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */
diff --git a/Marlin/pins_PRINTRBOARD.h b/Marlin/pins_PRINTRBOARD.h
index f2a2bbb..b53db77 100644
--- a/Marlin/pins_PRINTRBOARD.h
+++ b/Marlin/pins_PRINTRBOARD.h
@@ -43,6 +43,20 @@
 // Disable JTAG pins so they can be used for the Extrudrboard
 #define DISABLE_JTAG       true
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN         35
+#if ENABLED(SDSUPPORT)
+  #define Y_STOP_PIN       37 // Move Ystop to Estop socket
+#else
+  #define Y_STOP_PIN        8 // Ystop in Ystop socket
+#endif
+#define Z_STOP_PIN         36
+
+//
+// Steppers
+//
 #define X_STEP_PIN          0
 #define X_DIR_PIN           1
 #define X_ENABLE_PIN       39
@@ -59,7 +73,16 @@
 #define E0_DIR_PIN          7
 #define E0_ENABLE_PIN      19
 
-#define HEATER_0_PIN       21  // Extruder
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          1   // Analog Input
+#define TEMP_BED_PIN        0   // Analog Input
+
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN       21 // Extruder
 #define HEATER_1_PIN       46
 #define HEATER_2_PIN       47
 #define HEATER_BED_PIN     20
@@ -72,39 +95,32 @@
   #define FAN_PIN          16
 #endif
 
-#define X_STOP_PIN         35
-#if ENABLED(SDSUPPORT)
-  #define Y_STOP_PIN       37 // Move Ystop to Estop socket
-#else
-  #define Y_STOP_PIN        8 // Ystop in Ystop socket
-#endif
-#define Z_STOP_PIN         36
-#define TEMP_0_PIN          1  // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        0  // Bed / Analog pin numbering
-
-#define FILWIDTH_PIN        2  // ANALOG NUMBERING
-
-////LCD Pin Setup////
-
+//
+// Misc. Functions
+//
 #define SDSS               26
+#define FILWIDTH_PIN        2   // Analog Input
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
-  //we have no buzzer installed
+  // we have no buzzer installed
   #define BEEPER_PIN -1
 
-  //LCD Pins
+  // LCD Pins
   #if ENABLED(LCD_I2C_PANELOLU2)
-    #define BTN_EN1 27  //RX1 - fastio.h pin mapping 27
-    #define BTN_EN2 26  //TX1 - fastio.h pin mapping 26
-    #define BTN_ENC 43 //A3 - fastio.h pin mapping 43
-    #define SDSS   40 //use SD card on Panelolu2 (Teensyduino pin mapping)
+    #define BTN_EN1 27 // RX1 - fastio.h pin mapping 27
+    #define BTN_EN2 26 // TX1 - fastio.h pin mapping 26
+    #define BTN_ENC 43 // A3 - fastio.h pin mapping 43
+    #define SDSS    40 // use SD card on Panelolu2 (Teensyduino pin mapping)
   #else
     #define BTN_EN1 16
     #define BTN_EN2 17
-    #define BTN_ENC 18//the click
+    #define BTN_ENC 18 // the click
   #endif // LCD_I2C_PANELOLU2
 
-  //not connected to a pin
+  // not connected to a pin
   #define SD_DETECT_PIN -1
 
   #define LCD_PINS_RS 9
@@ -117,22 +133,22 @@
 #endif // ULTRA_LCD && NEWPANEL
 
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
-  //FastIO
+  // FastIO
   #define BEEPER_PIN 32
   // Pins for DOGM SPI LCD Support
-  #define DOGLCD_A0  42 //Non-FastIO
-  #define DOGLCD_CS  43 //Non-FastIO
+  #define DOGLCD_A0  42 // Non-FastIO
+  #define DOGLCD_CS  43 // Non-FastIO
   #define LCD_SCREEN_ROT_180
 
-  //The encoder and click button (FastIO Pins)
+  // The encoder and click button (FastIO Pins)
   #define BTN_EN1 26
   #define BTN_EN2 27
   #define BTN_ENC 47
 
   #define SDSS 45
   #define SD_DETECT_PIN -1 // FastIO (Manual says 72 I'm not certain cause I can't test)
-  #if ENABLED(TEMP_STAT_LEDS)
-    #define STAT_LED_RED      12 //Non-FastIO
-    #define STAT_LED_BLUE     10 //Non-FastIO
-  #endif
+
+  #define STAT_LED_RED_PIN  12 // Non-FastIO
+  #define STAT_LED_BLUE_PIN 10 // Non-FastIO
+
 #endif
diff --git a/Marlin/pins_PRINTRBOARD_REVF.h b/Marlin/pins_PRINTRBOARD_REVF.h
index 1b49f89..fa5c3a6 100644
--- a/Marlin/pins_PRINTRBOARD_REVF.h
+++ b/Marlin/pins_PRINTRBOARD_REVF.h
@@ -38,6 +38,16 @@
 #define BOARD_NAME         "Printrboard Rev F"
 #define LARGE_FLASH        true
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN         35
+#define Y_STOP_PIN         12
+#define Z_STOP_PIN         36
+
+//
+// Steppers
+//
 #define X_STEP_PIN          0
 #define X_DIR_PIN           1
 #define X_ENABLE_PIN       39
@@ -54,7 +64,28 @@
 #define E0_DIR_PIN          7
 #define E0_ENABLE_PIN      19
 
-#define HEATER_0_PIN       21  // Extruder
+// uncomment to enable an I2C based DAC like on the Printrboard REVF
+#define DAC_STEPPER_CURRENT
+// Number of channels available for DAC, For Printrboar REVF there are 4
+#define DAC_STEPPER_ORDER { 3, 2, 1, 0 }
+
+#define DAC_STEPPER_SENSE    0.11
+#define DAC_STEPPER_ADDRESS  0
+#define DAC_STEPPER_MAX   3520
+#define DAC_STEPPER_VREF     1 // internal Vref, gain 1x = 2.048V
+#define DAC_STEPPER_GAIN     0
+#define DAC_OR_ADDRESS    0x00
+
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          1   // Analog Input (Extruder)
+#define TEMP_BED_PIN        0   // Analog Input (Bed)
+
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN       21 // Extruder
 #define HEATER_1_PIN       46
 #define HEATER_2_PIN       47
 #define HEATER_BED_PIN     20
@@ -67,31 +98,15 @@
   #define FAN_PIN          16
 #endif
 
-#define X_STOP_PIN         35
-#define Y_STOP_PIN         12
-#define Z_STOP_PIN         36
-
-#define TEMP_0_PIN          1  // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        0  // Bed / Analog pin numbering
-
-#define FILWIDTH_PIN        2  // ANALOG NUMBERING
-
-////LCD Pin Setup////
-
+//
+// Misc. Functions
+//
 #define SDSS               20 // Teensylu pin mapping
+#define FILWIDTH_PIN        2 // Analog Input
 
-// uncomment to enable an I2C based DAC like on the Printrboard REVF
-#define DAC_STEPPER_CURRENT
-// Number of channels available for DAC, For Printrboar REVF there are 4
-#define DAC_STEPPER_ORDER { 3, 2, 1, 0 }
-
-#define DAC_STEPPER_SENSE    0.11
-#define DAC_STEPPER_ADDRESS  0
-#define DAC_STEPPER_MAX   3520
-#define DAC_STEPPER_VREF     1 //internal Vref, gain 1x = 2.048V
-#define DAC_STEPPER_GAIN     0
-#define DAC_OR_ADDRESS    0x00
-
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD)
   #define BEEPER_PIN -1
 
@@ -104,11 +119,11 @@
 
   #define BTN_EN1   16
   #define BTN_EN2   17
-  #define BTN_ENC   18//the click
+  #define BTN_ENC   18 // the click
 
   #define SD_DETECT_PIN -1
 
-  //encoder rotation values
+  // encoder rotation values
   #define encrot0 0
   #define encrot1 2
   #define encrot2 3
@@ -116,22 +131,19 @@
 #endif
 
 #if ENABLED(VIKI2) || ENABLED(miniVIKI)
-  #define BEEPER_PIN 32 //FastIO
-  // Pins for DOGM SPI LCD Support
-  #define DOGLCD_A0  42 //Non-FastIO
-  #define DOGLCD_CS  43 //Non-FastIO
+  #define BEEPER_PIN 32 // FastIO
+  #define DOGLCD_A0  42 // Non-FastIO
+  #define DOGLCD_CS  43 // Non-FastIO
   #define LCD_SCREEN_ROT_180
 
-  //The encoder and click button (FastIO Pins)
+  // (FastIO Pins)
   #define BTN_EN1 26
   #define BTN_EN2 27
   #define BTN_ENC 47
 
   #define SDSS 45
-  #define SD_DETECT_PIN -1 // FastIO (Manual says 72 I'm not certain cause I can't test)
+  #define SD_DETECT_PIN -1 // FastIO (Manual says 72)
 
-  #if ENABLED(TEMP_STAT_LEDS)
-    #define STAT_LED_RED      12 //Non-FastIO
-    #define STAT_LED_BLUE     10 //Non-FastIO
-  #endif
+  #define STAT_LED_RED_PIN  12 // Non-FastIO
+  #define STAT_LED_BLUE_PIN 10 // Non-FastIO
 #endif
diff --git a/Marlin/pins_RAMBO.h b/Marlin/pins_RAMBO.h
index 19778eb..8289940 100755
--- a/Marlin/pins_RAMBO.h
+++ b/Marlin/pins_RAMBO.h
@@ -56,6 +56,13 @@
 #define SERVO2_PIN         24 // Motor header MX3
 #define SERVO3_PIN          5 // PWM header pin 5
 
+//
+// Z Probe (when not Z_MIN_PIN)
+//
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN  30
+#endif
+
 #if ENABLED(Z_PROBE_SLED)
   #define SLED_PIN         -1
 #endif
@@ -71,42 +78,37 @@
 #define Z_MAX_PIN          30
 
 //
-// Z Probe (when not Z_MIN_PIN)
-//
-#ifndef Z_MIN_PROBE_PIN
-  #define Z_MIN_PROBE_PIN  30
-#endif
-
-//
 // Steppers
 //
 #define X_STEP_PIN         37
 #define X_DIR_PIN          48
 #define X_ENABLE_PIN       29
-#define X_MS1_PIN          40
-#define X_MS2_PIN          41
 
 #define Y_STEP_PIN         36
 #define Y_DIR_PIN          49
 #define Y_ENABLE_PIN       28
-#define Y_MS1_PIN          69
-#define Y_MS2_PIN          39
 
 #define Z_STEP_PIN         35
 #define Z_DIR_PIN          47
 #define Z_ENABLE_PIN       27
-#define Z_MS1_PIN          68
-#define Z_MS2_PIN          67
 
 #define E0_STEP_PIN        34
 #define E0_DIR_PIN         43
 #define E0_ENABLE_PIN      26
-#define E0_MS1_PIN         65
-#define E0_MS2_PIN         66
 
 #define E1_STEP_PIN        33
 #define E1_DIR_PIN         42
 #define E1_ENABLE_PIN      25
+
+// Microstepping pins - Mapping not from fastio.h (?)
+#define X_MS1_PIN          40
+#define X_MS2_PIN          41
+#define Y_MS1_PIN          69
+#define Y_MS2_PIN          39
+#define Z_MS1_PIN          68
+#define Z_MS2_PIN          67
+#define E0_MS1_PIN         65
+#define E0_MS2_PIN         66
 #define E1_MS1_PIN         63
 #define E1_MS2_PIN         64
 
@@ -116,9 +118,9 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          0
-#define TEMP_1_PIN          1
-#define TEMP_BED_PIN        2
+#define TEMP_0_PIN          0   // Analog Input
+#define TEMP_1_PIN          1   // Analog Input
+#define TEMP_BED_PIN        2   // Analog Input
 
 //
 // Heaters / Fans
@@ -137,9 +139,12 @@
 //
 #define SDSS               53
 #define LED_PIN            13
-#define FILWIDTH_PIN        3  // ANALOG NUMBERING
+#define FILWIDTH_PIN        3   // Analog Input
 #define PS_ON_PIN           4
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD)
 
   #define KILL_PIN 80
@@ -155,9 +160,9 @@
 
     #if ENABLED(VIKI2) || ENABLED(miniVIKI)
       #define BEEPER_PIN 44
-      //NB: Panucatt's Viki 2.0 wiring diagram (v1.2) indicates that the
-      //    beeper/buzzer is connected to pin 33; however, the pin used in the
-      //    diagram is actually pin 44, so this is correct.
+      // NB: Panucatt's Viki 2.0 wiring diagram (v1.2) indicates that the
+      //     beeper/buzzer is connected to pin 33; however, the pin used in the
+      //     diagram is actually pin 44, so this is correct.
 
       #define DOGLCD_A0  70
       #define DOGLCD_CS  71
@@ -169,10 +174,8 @@
 
       #define SD_DETECT_PIN -1 // Pin 72 if using easy adapter board
 
-      #if ENABLED(TEMP_STAT_LEDS)
-        #define STAT_LED_RED      22
-        #define STAT_LED_BLUE     32
-      #endif
+      #define STAT_LED_RED_PIN 22
+      #define STAT_LED_BLUE_PIN 32
 
     #else
 
@@ -187,12 +190,12 @@
 
     #endif // VIKI2/miniVIKI
 
-  #else //!NEWPANEL - old style panel with shift register
+  #else // !NEWPANEL - old style panel with shift register
 
     // No Beeper added
     #define BEEPER_PIN 33
 
-    //buttons are attached to a shift register
+    // buttons are attached to a shift register
     // Not wired yet
     //#define SHIFT_CLK 38
     //#define SHIFT_LD 42
diff --git a/Marlin/pins_RAMPS.h b/Marlin/pins_RAMPS.h
index 8d5fb41..e1d9c87 100644
--- a/Marlin/pins_RAMPS.h
+++ b/Marlin/pins_RAMPS.h
@@ -85,6 +85,8 @@
   #define Z_MIN_PROBE_PIN  32
 #endif
 
+#define SLED_PIN           -1
+
 //
 // Steppers
 //
@@ -111,24 +113,16 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN         13   // ANALOG NUMBERING
-#define TEMP_1_PIN         15   // ANALOG NUMBERING
-#define TEMP_BED_PIN       14   // ANALOG NUMBERING
-
-//
-// Misc. Functions
-//
-#define SDSS               53
-#define LED_PIN            13
-
-// Use the RAMPS 1.4 Analog input 5 on the AUX2 connector
-#define FILWIDTH_PIN        5 // ANALOG NUMBERING
-
-// define digital pin 4 for the filament runout sensor. Use the RAMPS 1.4 digital input 4 on the servos connector
-#define FIL_RUNOUT_PIN      4
+#define TEMP_0_PIN         13   // Analog Input
+#define TEMP_1_PIN         15   // Analog Input
+#define TEMP_BED_PIN       14   // Analog Input
 
-#define PS_ON_PIN          12
-#define SLED_PIN           -1
+// SPI for Max6675 or Max31855 Thermocouple
+#if DISABLED(SDSUPPORT)
+  #define MAX6675_SS       66 // Do not use pin 53 if there is even the remote possibility of using Display/SD card
+#else
+  #define MAX6675_SS       66 // Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
+#endif
 
 //
 // Augmentation for auto-assigning RAMPS plugs
@@ -194,14 +188,28 @@
 #endif
 
 //
+// Misc. Functions
+//
+#define SDSS               53
+#define LED_PIN            13
+
+// Use the RAMPS 1.4 Analog input 5 on the AUX2 connector
+#define FILWIDTH_PIN        5   // Analog Input
+
+// define digital pin 4 for the filament runout sensor. Use the RAMPS 1.4 digital input 4 on the servos connector
+#define FIL_RUNOUT_PIN      4
+
+#define PS_ON_PIN          12
+
+//
 // LCD / Controller
 //
 #if ENABLED(ULTRA_LCD)
 
   #if ENABLED(REPRAPWORLD_GRAPHICAL_LCD)
-    #define LCD_PINS_RS     49 //CS chip select /SS chip slave select
-    #define LCD_PINS_ENABLE 51 //SID (MOSI)
-    #define LCD_PINS_D4     52 //SCK (CLK) clock
+    #define LCD_PINS_RS     49 // CS chip select /SS chip slave select
+    #define LCD_PINS_ENABLE 51 // SID (MOSI)
+    #define LCD_PINS_D4     52 // SCK (CLK) clock
   #elif ENABLED(NEWPANEL) && ENABLED(PANEL_ONE)
     #define LCD_PINS_RS 40
     #define LCD_PINS_ENABLE 42
@@ -240,7 +248,7 @@
       #define KILL_PIN 41
 
       #if ENABLED(BQ_LCD_SMART_CONTROLLER)
-        #define LCD_PIN_BL 39
+        #define LCD_BACKLIGHT_PIN 39
       #endif
 
     #elif ENABLED(REPRAPWORLD_GRAPHICAL_LCD)
@@ -280,10 +288,9 @@
 
       #define KILL_PIN         31
 
-      #if ENABLED(TEMP_STAT_LEDS)
-        #define STAT_LED_RED   32
-        #define STAT_LED_BLUE  35
-      #endif
+      #define STAT_LED_RED_PIN 32
+      #define STAT_LED_BLUE_PIN 35
+
     #elif ENABLED(ELB_FULL_GRAPHIC_CONTROLLER)
       #define BTN_EN1 35  // reverse if the encoder turns the wrong way.
       #define BTN_EN2 37
@@ -294,13 +301,13 @@
       #define BEEPER_PIN 23
       #define DOGLCD_CS 29
       #define DOGLCD_A0 27
-      #define LCD_PIN_BL 33
+      #define LCD_BACKLIGHT_PIN 33
     #elif ENABLED(MINIPANEL)
       #define BEEPER_PIN 42
       // Pins for DOGM SPI LCD Support
       #define DOGLCD_A0  44
       #define DOGLCD_CS  66
-      #define LCD_PIN_BL 65 // backlight LED on A11/D65
+      #define LCD_BACKLIGHT_PIN 65 // backlight LED on A11/D65
       #define SDSS   53
 
       #define KILL_PIN 64
@@ -310,11 +317,11 @@
       //#define LCD_SCREEN_ROT_90
       //#define LCD_SCREEN_ROT_180
       //#define LCD_SCREEN_ROT_270
-      //The encoder and click button
+      // The encoder and click button
       #define BTN_EN1 40
       #define BTN_EN2 63
       #define BTN_ENC 59
-      //not connected to a pin
+      // not connected to a pin
       #define SD_DETECT_PIN 49
 
     #else
@@ -337,24 +344,17 @@
       #else
         #define BTN_EN1 37
         #define BTN_EN2 35
-        #define BTN_ENC 31  // the click
+        #define BTN_ENC 31 // the click
       #endif
 
       #if ENABLED(G3D_PANEL)
         #define SD_DETECT_PIN 49
         #define KILL_PIN 41
       #else
-        //        #define SD_DETECT_PIN -1  // Ramps doesn't use this
+        //#define SD_DETECT_PIN -1 // Ramps doesn't use this
       #endif
 
     #endif
   #endif // NEWPANEL
 
 #endif // ULTRA_LCD
-
-// SPI for Max6675 or Max31855 Thermocouple
-#if DISABLED(SDSUPPORT)
-  #define MAX6675_SS       66 // Do not use pin 53 if there is even the remote possibility of using Display/SD card
-#else
-  #define MAX6675_SS       66 // Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
-#endif
diff --git a/Marlin/pins_RAMPS_OLD.h b/Marlin/pins_RAMPS_OLD.h
index 238e484..29812bb 100644
--- a/Marlin/pins_RAMPS_OLD.h
+++ b/Marlin/pins_RAMPS_OLD.h
@@ -70,17 +70,17 @@
 #define E0_ENABLE_PIN      30
 
 //
-// Misc. Functions
-//
-#define SDPOWER            48
-#define SDSS               53
-#define LED_PIN            13
-
-//
 // Temperature Sensors
 //
-#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
-#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!
+#define TEMP_0_PIN          2   // Analog Input
+#define TEMP_BED_PIN        1   // Analog Input
+
+// SPI for Max6675 or Max31855 Thermocouple
+#if DISABLED(SDSUPPORT)
+  #define MAX6675_SS       66 // Do not use pin 53 if there is even the remote possibility of using Display/SD card
+#else
+  #define MAX6675_SS       66 // Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
+#endif
 
 //
 // Heaters / Fans
@@ -95,9 +95,9 @@
   #define FAN_PIN           9
 #endif
 
-// SPI for Max6675 or Max31855 Thermocouple
-#if DISABLED(SDSUPPORT)
-  #define MAX6675_SS       66// Do not use pin 53 if there is even the remote possibility of using Display/SD card
-#else
-  #define MAX6675_SS       66// Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
-#endif
+//
+// Misc. Functions
+//
+#define SDPOWER            48
+#define SDSS               53
+#define LED_PIN            13
diff --git a/Marlin/pins_RIGIDBOARD.h b/Marlin/pins_RIGIDBOARD.h
index a60e492..bcd1437 100644
--- a/Marlin/pins_RIGIDBOARD.h
+++ b/Marlin/pins_RIGIDBOARD.h
@@ -26,21 +26,75 @@
 
 #define BOARD_NAME "RigidBoard"
 
-#define RAMPS_D10_PIN       9    // EXTRUDER 1
-#define MOSFET_D_PIN       12    // EXTRUDER 2 or FAN
+//
+// Z Probe (when not Z_MIN_PIN)
+//
 #ifndef Z_MIN_PROBE_PIN
   #define Z_MIN_PROBE_PIN  19    // Z-MAX pin J14 End Stops
 #endif
 
 #include "pins_RAMPS.h"
 
+//
+// Steppers
+//
+// RigidBot swaps E0 / E1 plugs vs RAMPS 1.3
+#undef E0_STEP_PIN
+#undef E0_DIR_PIN
+#undef E0_ENABLE_PIN
+#define E0_STEP_PIN        36
+#define E0_DIR_PIN         34
+#define E0_ENABLE_PIN      30
+
+#undef E1_STEP_PIN
+#undef E1_DIR_PIN
+#undef E1_ENABLE_PIN
+#define E1_STEP_PIN        26
+#define E1_DIR_PIN         28
+#define E1_ENABLE_PIN      24
+
+#define STEPPER_RESET_PIN  41   // Stepper drivers have a reset on RigidBot
+
+//
+// Temperature Sensors
+//
 #undef TEMP_0_PIN
 #undef TEMP_1_PIN
-#define TEMP_0_PIN         14   // ANALOG NUMBERING
-#define TEMP_1_PIN         13   // ANALOG NUMBERING
+#undef TEMP_BED_PIN
+#define TEMP_0_PIN         14   // Analog Input
+#define TEMP_1_PIN         13   // Analog Input
+#define TEMP_BED_PIN       15   // Analog Input
 
-// LCD Panel options for the RigidBoard
+// SPI for Max6675 or Max31855 Thermocouple
+#undef MAX6675_SS
+#if DISABLED(SDSUPPORT)
+  #define MAX6675_SS       53 // Don't use pin 53 if there is even the remote possibility of using Display/SD card
+#else
+  #define MAX6675_SS       49 // Don't use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
+#endif
+
+//
+// Heaters / Fans
+//
+#define RAMPS_D10_PIN       9 // EXTRUDER 1
+#define MOSFET_D_PIN       12 // EXTRUDER 2 or FAN
 
+#undef  HEATER_BED_PIN
+#define HEATER_BED_PIN     10
+
+#undef  FAN_PIN
+#define FAN_PIN             8 // Same as RAMPS_13_EEF
+
+//
+// Misc. Functions
+//
+#undef  PS_ON_PIN
+#define PS_ON_PIN          -1
+
+//
+// LCD / Controller
+//
+// LCD Panel options for the RigidBoard
 #if ENABLED(RIGIDBOT_PANEL)
 
   #undef BEEPER_PIN
@@ -77,41 +131,3 @@
   #define KILL_PIN 32
 
 #endif
-
-// SPI for Max6675 or Max31855 Thermocouple
-#undef MAX6675_SS
-#if ENABLED(SDSUPPORT)
-  #define MAX6675_SS       49 // Don't use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present
-#else
-  #define MAX6675_SS       53 // Don't use pin 53 if there is even the remote possibility of using Display/SD card
-#endif
-
-// RigidBot swaps E0 / E1 plugs vs RAMPS 1.3
-
-#undef E0_STEP_PIN
-#undef E0_DIR_PIN
-#undef E0_ENABLE_PIN
-#define E0_STEP_PIN        36
-#define E0_DIR_PIN         34
-#define E0_ENABLE_PIN      30
-
-#undef E1_STEP_PIN
-#undef E1_DIR_PIN
-#undef E1_ENABLE_PIN
-#define E1_STEP_PIN        26
-#define E1_DIR_PIN         28
-#define E1_ENABLE_PIN      24
-
-#undef  FAN_PIN
-#define FAN_PIN             8 // Same as RAMPS_13_EEF
-
-#undef  PS_ON_PIN
-#define PS_ON_PIN          -1
-
-#undef  HEATER_BED_PIN
-#define HEATER_BED_PIN     10
-
-#undef  TEMP_BED_PIN
-#define TEMP_BED_PIN       15   // ANALOG NUMBERING
-
-#define STEPPER_RESET_PIN  41   // Stepper drivers have a reset on RigidBot
diff --git a/Marlin/pins_RIGIDBOARD_V2.h b/Marlin/pins_RIGIDBOARD_V2.h
index 4f0171a..501bcc2 100644
--- a/Marlin/pins_RIGIDBOARD_V2.h
+++ b/Marlin/pins_RIGIDBOARD_V2.h
@@ -29,15 +29,18 @@
 #undef BOARD_NAME
 #define BOARD_NAME "RigidBoard V2"
 
+//
+// Steppers
+//
 // I2C based DAC like on the Printrboard REVF
 #define DAC_STEPPER_CURRENT
 // Channels available for DAC, For Rigidboard there are 4
 #define DAC_STEPPER_ORDER { 0, 1, 2, 3 }
 
-#define DAC_STEPPER_SENSE    0.11
+#define DAC_STEPPER_SENSE    0.05 // sense resistors on rigidboard stepper chips are .05 value
 #define DAC_STEPPER_ADDRESS  0
-#define DAC_STEPPER_MAX   5000
-#define DAC_STEPPER_VREF     1 //internal Vref, gain 1x = 2.048V
-#define DAC_STEPPER_GAIN     0
-#define DAC_DISABLE_PIN     42 //  set low to enable DAC
+#define DAC_STEPPER_MAX   4096 // was 5000 but max allowable value is actually 4096 
+#define DAC_STEPPER_VREF     1 // internal Vref, gain 2x = 4.096V
+#define DAC_STEPPER_GAIN     1 // value of 1 here sets gain of 2
+#define DAC_DISABLE_PIN     42 // set low to enable DAC
 #define DAC_OR_ADDRESS    0x01
diff --git a/Marlin/pins_RUMBA.h b/Marlin/pins_RUMBA.h
index 3c0e945..dcc5bee 100644
--- a/Marlin/pins_RUMBA.h
+++ b/Marlin/pins_RUMBA.h
@@ -36,6 +36,11 @@
 #define BOARD_NAME           "Rumba"
 
 //
+// Servos
+//
+#define SERVO0_PIN         5
+
+//
 // Limit Switches
 //
 #define X_MIN_PIN          37
@@ -80,32 +85,33 @@
 #define E2_ENABLE_PIN      39
 
 //
-// Misc. Functions
-//
-#define LED_PIN            13
-
-#define PS_ON_PIN          45
-#define KILL_PIN           46
-
-//
 // Temperature Sensors
 //
 #if TEMP_SENSOR_0 == -1
-  #define TEMP_0_PIN        6   // ANALOG NUMBERING - connector *K1* on RUMBA thermocouple ADD ON is used
+  #define TEMP_0_PIN        6   // Analog Input (connector *K1* on RUMBA thermocouple ADD ON is used)
 #else
-  #define TEMP_0_PIN       15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used
+  #define TEMP_0_PIN       15   // Analog Input (default connector for thermistor *T0* on rumba board is used)
 #endif
 
 #if TEMP_SENSOR_1 == -1
-  #define TEMP_1_PIN        5   // ANALOG NUMBERING - connector *K2* on RUMBA thermocouple ADD ON is used
+  #define TEMP_1_PIN        5   // Analog Input (connector *K2* on RUMBA thermocouple ADD ON is used)
 #else
-  #define TEMP_1_PIN       14   // ANALOG NUMBERING - default connector for thermistor *T1* on rumba board is used
+  #define TEMP_1_PIN       14   // Analog Input (default connector for thermistor *T1* on rumba board is used)
 #endif
 
 #if TEMP_SENSOR_2 == -1
-  #define TEMP_2_PIN        7   // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_BED is defined as thermocouple
+  #define TEMP_2_PIN        7   // Analog Input (connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_BED is defined as thermocouple)
+#else
+  #define TEMP_2_PIN       13   // Analog Input (default connector for thermistor *T2* on rumba board is used)
+#endif
+
+// optional for extruder 4 or chamber:
+//#define TEMP_X_PIN         12   // Analog Input (default connector for thermistor *T3* on rumba board is used)
+
+#if TEMP_SENSOR_BED == -1
+  #define TEMP_BED_PIN      7   // Analog Input (connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_2 is defined as thermocouple)
 #else
-  #define TEMP_2_PIN       13   // ANALOG NUMBERING - default connector for thermistor *T2* on rumba board is used
+  #define TEMP_BED_PIN     11   // Analog Input (default connector for thermistor *THB* on rumba board is used)
 #endif
 
 //
@@ -120,16 +126,17 @@
 #define FAN_PIN             7
 #define FAN1_PIN            8
 
-//optional for extruder 4 or chamber:
-// #define TEMP_X_PIN         12   // ANALOG NUMBERING - default connector for thermistor *T3* on rumba board is used
-
-#if TEMP_SENSOR_BED == -1
-  #define TEMP_BED_PIN      7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used <-- this can not be used when TEMP_SENSOR_2 is defined as thermocouple
-#else
-  #define TEMP_BED_PIN     11    // ANALOG NUMBERING - default connector for thermistor *THB* on rumba board is used
-#endif
-
+//
+// Misc. Functions
+//
 #define SDSS               53
+#define LED_PIN            13
+#define PS_ON_PIN          45
+#define KILL_PIN           46
+
+//
+// LCD / Controller
+//
 #define SD_DETECT_PIN      49
 #define BEEPER_PIN         44
 #define LCD_PINS_RS        19
@@ -141,6 +148,3 @@
 #define BTN_EN1            11
 #define BTN_EN2            12
 #define BTN_ENC            43
-
-#define SERVO0_PIN         5
-
diff --git a/Marlin/pins_SAINSMART_2IN1.h b/Marlin/pins_SAINSMART_2IN1.h
index 8d272ad..b418308 100644
--- a/Marlin/pins_SAINSMART_2IN1.h
+++ b/Marlin/pins_SAINSMART_2IN1.h
@@ -30,6 +30,9 @@
 
 #define BOARD_NAME "Sainsmart"
 
+//
+// Heaters / Fans
+//
 #define RAMPS_D10_PIN 9 // E
 #define RAMPS_D9_PIN  7 // F PART FAN in front of board next to Extruder heat
      // RAMPS_D8_PIN  8 // B
diff --git a/Marlin/pins_SANGUINOLOLU_11.h b/Marlin/pins_SANGUINOLOLU_11.h
index a6220c5..cd8d1cc 100644
--- a/Marlin/pins_SANGUINOLOLU_11.h
+++ b/Marlin/pins_SANGUINOLOLU_11.h
@@ -34,35 +34,44 @@
 
 #define IS_MELZI (MB(MELZI) || MB(MELZI_MAKR3D))
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN         18
+#define Y_STOP_PIN         19
+#define Z_STOP_PIN         20
+
+//
+// Z Probe (when not Z_MIN_PIN)
+//
+#if ENABLED(Z_PROBE_SLED)
+  #define SLED_PIN         -1
+#endif
+
+//
+// Steppers
+//
 #define X_STEP_PIN         15
 #define X_DIR_PIN          21
-#define X_STOP_PIN         18
 
 #define Y_STEP_PIN         22
 #define Y_DIR_PIN          23
-#define Y_STOP_PIN         19
 
 #define Z_STEP_PIN          3
 #define Z_DIR_PIN           2
-#define Z_STOP_PIN         20
 
 #define E0_STEP_PIN         1
 #define E0_DIR_PIN          0
 
-#if MB(AZTEEG_X1) || MB(STB_11) || IS_MELZI
-  #define FAN_PIN           4 // Works for Panelolu2 too
-#endif
-
-#if IS_MELZI
-  #define LED_PIN          27 // On some broken versions of the Sanguino libraries the pin definitions are wrong, so LED_PIN needs to be 28. But you should upgrade your Sanguino libraries! See #368.
-#elif MB(STB_11)
-  #define LCD_PIN_BL       17 // LCD backlight LED
-#endif
-
-#if ENABLED(Z_PROBE_SLED)
-  #define SLED_PIN         -1
-#endif
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          7   // Analog Input (pin 33 extruder)
+#define TEMP_BED_PIN        6   // Analog Input (pin 34 bed)
 
+//
+// Heaters / Fans
+//
 #define HEATER_0_PIN       13 // (extruder)
 
 #if ENABLED(SANGUINOLOLU_V_1_2)
@@ -79,7 +88,7 @@
 
 #else
 
-  #define HEATER_BED_PIN   14  // (bed)
+  #define HEATER_BED_PIN   14 // (bed)
   #define X_ENABLE_PIN     -1
   #define Y_ENABLE_PIN     -1
   #define Z_ENABLE_PIN     -1
@@ -87,16 +96,29 @@
 
 #endif
 
-#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)
-#define TEMP_BED_PIN        6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)
-#define SDSS               31
+#if MB(AZTEEG_X1) || MB(STB_11) || IS_MELZI
+  #define FAN_PIN           4 // Works for Panelolu2 too
+#endif
 
+//
+// Misc. Functions
+//
 /**
  * On some broken versions of the Sanguino libraries the pin definitions are wrong,
  * which then needs SDSS as pin 24. But you should upgrade your Sanguino libraries! See #368.
  */
 //#define SDSS               24
+#define SDSS               31
+
+#if IS_MELZI
+  #define LED_PIN          27 // On some broken versions of the Sanguino libraries the pin definitions are wrong, so LED_PIN needs to be 28. But you should upgrade your Sanguino libraries! See #368.
+#elif MB(STB_11)
+  #define LCD_BACKLIGHT_PIN 17 // LCD backlight LED
+#endif
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
 
   // No buzzer installed
@@ -105,12 +127,12 @@
   // LCD Pins
   #if ENABLED(DOGLCD)
 
-    #if ENABLED(U8GLIB_ST7920) //SPI GLCD 12864 ST7920 ( like [www.digole.com] ) For Melzi V2.0
+    #if ENABLED(U8GLIB_ST7920) // SPI GLCD 12864 ST7920 ( like [www.digole.com] ) For Melzi V2.0
 
       #if IS_MELZI // Melzi board
-        #define LCD_PINS_RS     30 //CS chip select /SS chip slave select
-        #define LCD_PINS_ENABLE 29 //SID (MOSI)
-        #define LCD_PINS_D4     17 //SCK (CLK) clock
+        #define LCD_PINS_RS     30 // CS chip select /SS chip slave select
+        #define LCD_PINS_ENABLE 29 // SID (MOSI)
+        #define LCD_PINS_D4     17 // SCK (CLK) clock
         // Pin 27 is taken by LED_PIN, but Melzi LED does nothing with
         // Marlin so this can be used for BEEPER_PIN. You can use this pin
         // with M42 instead of BEEPER_PIN.
@@ -162,7 +184,7 @@
   #else
     #define BTN_ENC             16
     #define LCD_SDSS            28 // Smart Controller SD card reader rather than the Melzi
-  #endif //Panelolu2
+  #endif // Panelolu2
 
   #define SD_DETECT_PIN         -1
 
@@ -173,7 +195,7 @@
   // Pins for DOGM SPI LCD Support
   #define DOGLCD_A0             30
   #define DOGLCD_CS             17
-  #define LCD_PIN_BL            28 // backlight LED on PA3
+  #define LCD_BACKLIGHT_PIN     28 // backlight LED on PA3
   // GLCD features
   #define LCD_CONTRAST           1
   // Uncomment screen orientation
diff --git a/Marlin/pins_SAV_MKI.h b/Marlin/pins_SAV_MKI.h
index e3e24c9..c2ad006 100644
--- a/Marlin/pins_SAV_MKI.h
+++ b/Marlin/pins_SAV_MKI.h
@@ -38,6 +38,22 @@
 #define USBCON 1286  // Disable MarlinSerial etc.
 #define LARGE_FLASH        true
 
+//
+// Servos
+//
+#define SERVO0_PIN         41 // In teensy's pin definition for pinMode (in servo.cpp)
+
+//
+// Limit Switches
+//
+#define X_STOP_PIN         13
+#define Y_STOP_PIN         14
+//#define Z_STOP_PIN         15
+#define Z_STOP_PIN         36  // For inductive sensor.
+
+//
+// Steppers
+//
 #define X_STEP_PIN         0
 #define X_DIR_PIN          1
 #define X_ENABLE_PIN       39
@@ -54,19 +70,25 @@
 #define E0_DIR_PIN         7
 #define E0_ENABLE_PIN      19
 
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          7  // Analog Input (Extruder)
+#define TEMP_BED_PIN        6  // Analog Input (Bed)
+
+//
+// Heaters / Fans
+//
 #define HEATER_0_PIN       21  // Extruder
 #define HEATER_BED_PIN     20  // Bed
-#define FAN_PIN            16  // Fan   -- from Teensyduino environment.
-                               // For the fan and Teensyduino uses a different pin mapping.
-#define X_STOP_PIN         13
-#define Y_STOP_PIN         14
-//#define Z_STOP_PIN         15
-#define Z_STOP_PIN         36  // For inductive sensor.
 
-#define TEMP_0_PIN          7  // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        6  // Bed / Analog pin numbering
+#define FAN_PIN            16  // Fan -- from Teensyduino environment.
+                               // For the fan and Teensyduino uses a different pin mapping.
 
-#define SDSS               20         // PB0 - 8 in marlin env.
+//
+// Misc. Functions
+//
+#define SDSS               20  // PB0 - 8 in marlin env.
 
 // Extension header pin mapping
 // ----------------------------
@@ -94,6 +116,9 @@
 #define EXT_AUX_A4_IO             44 // Digital IO, 42 (teensy), 44 (marlin)
 
 
+//
+// LCD / Controller
+//
 #define BEEPER_PIN         -1
 #define LCD_PINS_RS        -1
 #define LCD_PINS_ENABLE    -1
@@ -116,5 +141,3 @@
   #define KILL_PIN           EXT_AUX_A2_IO
   #define HOME_PIN           EXT_AUX_A4_IO
 #endif // SAV_3DLCD || SAV_3DGLCD
-
-#define SERVO0_PIN         41 // In teensy's pin definition for pinMode (in servo.cpp)
diff --git a/Marlin/pins_SETHI.h b/Marlin/pins_SETHI.h
index a710e1b..12521f4 100644
--- a/Marlin/pins_SETHI.h
+++ b/Marlin/pins_SETHI.h
@@ -64,8 +64,8 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          1
-#define TEMP_BED_PIN        2
+#define TEMP_0_PIN          1   // Analog Input
+#define TEMP_BED_PIN        2   // Analog Input
 
 //
 // Heaters / Fans
@@ -81,15 +81,18 @@
   #define FAN_PIN          31
 #endif
 
+//
+// Misc. Functions
+//
 #define PS_ON_PIN          15
 
-//All these generations of Gen7 supply thermistor power
-//via PS_ON, so ignore bad thermistor readings
+// All these generations of Gen7 supply thermistor power
+// via PS_ON, so ignore bad thermistor readings
 #define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
 
-//our pin for debugging.
+// our pin for debugging.
 #define DEBUG_PIN           0
 
-//our RS485 pins
+// our RS485 pins
 #define TX_ENABLE_PIN      12
 #define RX_ENABLE_PIN      13
diff --git a/Marlin/pins_TEENSY2.h b/Marlin/pins_TEENSY2.h
index 65992be..b7cf484 100644
--- a/Marlin/pins_TEENSY2.h
+++ b/Marlin/pins_TEENSY2.h
@@ -79,37 +79,55 @@
 #define USBCON 1286  // Disable MarlinSerial etc.
 #define LARGE_FLASH        true
 
-#define X_STEP_PIN         28 //  0 Marlin
-#define X_DIR_PIN          29 //  1 Marlin
+//
+// Limit Switches
+//
+#define X_STOP_PIN          2
+#define Y_STOP_PIN          3
+#define Z_STOP_PIN          4
+
+//
+// Steppers
+//
+#define X_STEP_PIN         28 // 0 Marlin
+#define X_DIR_PIN          29 // 1 Marlin
 #define X_ENABLE_PIN       26
 
-#define Y_STEP_PIN         30 //  2 Marlin
-#define Y_DIR_PIN          31 //  3
-#define Y_ENABLE_PIN       26     // Shared w/x
+#define Y_STEP_PIN         30 // 2 Marlin
+#define Y_DIR_PIN          31 // 3
+#define Y_ENABLE_PIN       26 // Shared w/x
 
-#define Z_STEP_PIN         32 //  4
-#define Z_DIR_PIN          33 //  5
+#define Z_STEP_PIN         32 // 4
+#define Z_DIR_PIN          33 // 5
 #define Z_ENABLE_PIN       26 // Shared w/x
 
-#define E0_STEP_PIN        34 //  6
-#define E0_DIR_PIN         35 //  7
+#define E0_STEP_PIN        34 // 6
+#define E0_DIR_PIN         35 // 7
 #define E0_ENABLE_PIN      26 // Shared w/x
 
-#define HEATER_0_PIN       15 //  21  // Extruder
-#define HEATER_BED_PIN     14 // 20  // Bed
-#define FAN_PIN            16 // 22  // Fan
-
-#define X_STOP_PIN          2
-#define Y_STOP_PIN          3
-#define Z_STOP_PIN          4
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          7   // Analog Input (Extruder)
+#define TEMP_BED_PIN        6   // Analog Input (Bed)
 
-#define TEMP_0_PIN          7 // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        6 // Bed / Analog pin numbering
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN       15 // 21 // Extruder
+#define HEATER_BED_PIN     14 // 20 // Bed
+#define FAN_PIN            16 // 22 // Fan
 
+//
+// Misc. Functions
+//
 #define SDSS               20 // 8
 #define LED_PIN             6
 #define PS_ON_PIN          27
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTIPANEL)
   #define LCD_PINS_RS         8
   #define LCD_PINS_ENABLE     9
diff --git a/Marlin/pins_TEENSYLU.h b/Marlin/pins_TEENSYLU.h
index 2269b31..b0fc8ae 100644
--- a/Marlin/pins_TEENSYLU.h
+++ b/Marlin/pins_TEENSYLU.h
@@ -40,6 +40,16 @@
 #define USBCON 1286  // Disable MarlinSerial etc.
 #define LARGE_FLASH        true
 
+//
+// Limit Switches
+//
+#define X_STOP_PIN         13
+#define Y_STOP_PIN         14
+#define Z_STOP_PIN         15
+
+//
+// Steppers
+//
 #define X_STEP_PIN          0
 #define X_DIR_PIN           1
 #define X_ENABLE_PIN       39
@@ -56,6 +66,15 @@
 #define E0_DIR_PIN          7
 #define E0_ENABLE_PIN      19
 
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN          7   // Analog Input (Extruder)
+#define TEMP_BED_PIN        6   // Analog Input (Bed)
+
+//
+// Heaters / Fans
+//
 #define HEATER_0_PIN       21  // Extruder
 #define HEATER_1_PIN       46
 #define HEATER_2_PIN       47
@@ -69,23 +88,23 @@
   #define FAN_PIN          16
 #endif
 
-#define X_STOP_PIN         13
-#define Y_STOP_PIN         14
-#define Z_STOP_PIN         15
-#define TEMP_0_PIN          7  // Extruder / Analog pin numbering
-#define TEMP_BED_PIN        6  // Bed / Analog pin numbering
-
+//
+// Misc. Functions
+//
 #define SDSS                8
 
+//
+// LCD / Controller
+//
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
 
   #define BEEPER_PIN       -1
 
   #if ENABLED(LCD_I2C_PANELOLU2)
-    #define BTN_EN1        27  //RX1 - fastio.h pin mapping 27
-    #define BTN_EN2        26  //TX1 - fastio.h pin mapping 26
-    #define BTN_ENC        43  //A3  - fastio.h pin mapping 43
-    #define SDSS           40  //use SD card on Panelolu2 (Teensyduino pin mapping)
+    #define BTN_EN1        27  // RX1 - fastio.h pin mapping 27
+    #define BTN_EN2        26  // TX1 - fastio.h pin mapping 26
+    #define BTN_ENC        43  // A3  - fastio.h pin mapping 43
+    #define SDSS           40  // use SD card on Panelolu2 (Teensyduino pin mapping)
   #endif // LCD_I2C_PANELOLU2
 
   #define SD_DETECT_PIN    -1
diff --git a/Marlin/pins_ULTIMAIN_2.h b/Marlin/pins_ULTIMAIN_2.h
index e1b0ece..731f6f8 100644
--- a/Marlin/pins_ULTIMAIN_2.h
+++ b/Marlin/pins_ULTIMAIN_2.h
@@ -65,16 +65,16 @@
 #define MOTOR_CURRENT_PWM_XY_PIN 44
 #define MOTOR_CURRENT_PWM_Z_PIN 45
 #define MOTOR_CURRENT_PWM_E_PIN 46
-//Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
+// Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range
 #define MOTOR_CURRENT_PWM_RANGE 2000
 #define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}
 
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          8
-#define TEMP_1_PIN          9
-#define TEMP_BED_PIN       10
+#define TEMP_0_PIN          8   // Analog Input
+#define TEMP_1_PIN          9   // Analog Input
+#define TEMP_BED_PIN       10   // Analog Input
 
 //
 // Heaters / Fans
@@ -86,15 +86,17 @@
 #define FAN_PIN             7
 
 //
-// SD Card
+// Misc. Functions
 //
 #define SDSS               53
 #define SD_DETECT_PIN      39
-
 #define LED_PIN             8
 #define SAFETY_TRIGGERED_PIN     28 // PIN to detect the safety circuit has triggered
 #define MAIN_VOLTAGE_MEASURE_PIN 14 // ANALOG PIN to measure the main voltage, with a 100k - 4k7 resitor divider.
 
+//
+// LCD / Controller
+//
 #define BEEPER_PIN         18
 
 #define LCD_PINS_RS        20
diff --git a/Marlin/pins_ULTIMAKER.h b/Marlin/pins_ULTIMAKER.h
index f7ad15e..4b4b31a 100644
--- a/Marlin/pins_ULTIMAKER.h
+++ b/Marlin/pins_ULTIMAKER.h
@@ -82,9 +82,9 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          8
-#define TEMP_1_PIN          9
-#define TEMP_BED_PIN       10
+#define TEMP_0_PIN          8   // Analog Input
+#define TEMP_1_PIN          9   // Analog Input
+#define TEMP_BED_PIN       10   // Analog Input
 
 //
 // Heaters / Fans
@@ -93,11 +93,15 @@
 #define HEATER_1_PIN        3
 #define HEATER_BED_PIN      4
 
+#define FAN_PIN             7
+
+//
+// Misc. Functions
+//
 #define SDSS               53
 #define LED_PIN            13
-#define FAN_PIN             7
 #define PS_ON_PIN          12
-#define SUICIDE_PIN        54  //PIN that has to be turned on right after start, to keep power flowing.
+#define SUICIDE_PIN        54  // PIN that has to be turned on right after start, to keep power flowing.
 
 //
 // LCD / Controller
@@ -115,16 +119,16 @@
     #define LCD_PINS_D6 5
     #define LCD_PINS_D7 6
 
-    //buttons are directly attached
+    // buttons are directly attached
     #define BTN_EN1 40
     #define BTN_EN2 42
     #define BTN_ENC 19
 
     #define SD_DETECT_PIN 38
 
-  #else //!NEWPANEL - Old style panel with shift register
+  #else // !NEWPANEL - Old style panel with shift register
 
-    //buttons are attached to a shift register
+    // buttons are attached to a shift register
     #define SHIFT_CLK 38
     #define SHIFT_LD 42
     #define SHIFT_OUT 40
diff --git a/Marlin/pins_ULTIMAKER_OLD.h b/Marlin/pins_ULTIMAKER_OLD.h
index cb0f763..b42ba69 100644
--- a/Marlin/pins_ULTIMAKER_OLD.h
+++ b/Marlin/pins_ULTIMAKER_OLD.h
@@ -77,8 +77,8 @@
 //
 // Temperature Sensors
 //
-#define TEMP_0_PIN          8
-#define TEMP_1_PIN          1
+#define TEMP_0_PIN          8   // Analog Input
+#define TEMP_1_PIN          1   // Analog Input
 
 //
 // Heaters / Fans
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 45cd467..073179c 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -85,24 +85,22 @@ float Planner::max_feedrate_mm_s[NUM_AXIS], // Max speeds in mm per second
       Planner::axis_steps_per_mm[NUM_AXIS],
       Planner::steps_to_mm[NUM_AXIS];
 
-unsigned long Planner::max_acceleration_steps_per_s2[NUM_AXIS],
-              Planner::max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
+uint32_t Planner::max_acceleration_steps_per_s2[NUM_AXIS],
+         Planner::max_acceleration_mm_per_s2[NUM_AXIS]; // Use M201 to override by software
 
 millis_t Planner::min_segment_time;
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-      Planner::max_xy_jerk,          // The largest speed change requiring no acceleration
-      Planner::max_z_jerk,
-      Planner::max_e_jerk,
+      Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
       Planner::min_travel_feedrate_mm_s;
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
   bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_LINEAR)
+#if ABL_PLANAR
   matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
 #endif
 
@@ -117,6 +115,8 @@ float Planner::min_feedrate_mm_s,
 
 long Planner::position[NUM_AXIS] = { 0 };
 
+uint32_t Planner::cutoff_long;
+
 float Planner::previous_speed[NUM_AXIS],
       Planner::previous_nominal_speed;
 
@@ -139,59 +139,55 @@ Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
-  memset(position, 0, sizeof(position));
-  memset(previous_speed, 0, sizeof(previous_speed));
+  ZERO(position);
+  ZERO(previous_speed);
   previous_nominal_speed = 0.0;
-  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+  #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
 }
 
+#define MINIMAL_STEP_RATE 120
+
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  */
-void Planner::calculate_trapezoid_for_block(block_t* block, float entry_factor, float exit_factor) {
-  unsigned long initial_rate = ceil(block->nominal_rate * entry_factor),
-                final_rate = ceil(block->nominal_rate * exit_factor); // (steps per second)
+void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
+  uint32_t initial_rate = ceil(block->nominal_rate * entry_factor),
+           final_rate = ceil(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
-  NOLESS(initial_rate, 120);
-  NOLESS(final_rate, 120);
+  NOLESS(initial_rate, MINIMAL_STEP_RATE);
+  NOLESS(final_rate, MINIMAL_STEP_RATE);
 
-  long accel = block->acceleration_steps_per_s2;
-  int32_t accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel));
-  int32_t decelerate_steps = floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
-
-  // Calculate the size of Plateau of Nominal Rate.
-  int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
+  int32_t accel = block->acceleration_steps_per_s2,
+          accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
+          decelerate_steps = floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
+          plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
   // have to use intersection_distance() to calculate when to abort accel and start braking
   // in order to reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
-    accelerate_steps = max(accelerate_steps, 0); // Check limits due to numerical round-off
+    NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
     accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
   }
 
-  #if ENABLED(ADVANCE)
-    volatile long initial_advance = block->advance * sq(entry_factor);
-    volatile long final_advance = block->advance * sq(exit_factor);
-  #endif // ADVANCE
-
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
+
   CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
-  if (!block->busy) { // Don't update variables if block is busy.
+  if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     block->final_rate = final_rate;
     #if ENABLED(ADVANCE)
-      block->initial_advance = initial_advance;
-      block->final_advance = final_advance;
+      block->initial_advance = block->advance * sq(entry_factor);
+      block->final_advance = block->advance * sq(exit_factor);
     #endif
   }
   CRITICAL_SECTION_END;
@@ -207,29 +203,20 @@ void Planner::calculate_trapezoid_for_block(block_t* block, float entry_factor,
 
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t* current, block_t* next) {
-  if (!current) return;
-
-  if (next) {
-    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
-    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
-    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
-    float max_entry_speed = current->max_entry_speed;
-    if (current->entry_speed != max_entry_speed) {
-
-      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
-      // for max allowable speed if block is decelerating and nominal length is false.
-      if (!current->nominal_length_flag && max_entry_speed > next->entry_speed) {
-        current->entry_speed = min(max_entry_speed,
-                                   max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
-      }
-      else {
-        current->entry_speed = max_entry_speed;
-      }
-      current->recalculate_flag = true;
-
-    }
-  } // Skip last block. Already initialized and set for recalculation.
+void Planner::reverse_pass_kernel(block_t* const current, const block_t *next) {
+  if (!current || !next) return;
+  // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
+  // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
+  // check for maximum allowable speed reductions to ensure maximum possible planned speed.
+  float max_entry_speed = current->max_entry_speed;
+  if (current->entry_speed != max_entry_speed) {
+    // If nominal length true, max junction speed is guaranteed to be reached. Only compute
+    // for max allowable speed if block is decelerating and nominal length is false.
+    current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
+      ? max_entry_speed
+      : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
+    SBI(current->flag, BLOCK_BIT_RECALCULATE);
+  }
 }
 
 /**
@@ -243,12 +230,14 @@ void Planner::reverse_pass() {
     block_t* block[3] = { NULL, NULL, NULL };
 
     // Make a local copy of block_buffer_tail, because the interrupt can alter it
-    CRITICAL_SECTION_START;
-      uint8_t tail = block_buffer_tail;
-    CRITICAL_SECTION_END
+    // Is a critical section REALLY needed for a single byte change?
+    //CRITICAL_SECTION_START;
+    uint8_t tail = block_buffer_tail;
+    //CRITICAL_SECTION_END
 
     uint8_t b = BLOCK_MOD(block_buffer_head - 3);
     while (b != tail) {
+      if (block[0] && TEST(block[0]->flag, BLOCK_BIT_START_FROM_FULL_HALT)) break;
       b = prev_block_index(b);
       block[2] = block[1];
       block[1] = block[0];
@@ -259,21 +248,21 @@ void Planner::reverse_pass() {
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(block_t* previous, block_t* current) {
+void Planner::forward_pass_kernel(const block_t* previous, block_t* const current) {
   if (!previous) return;
 
   // If the previous block is an acceleration block, but it is not long enough to complete the
   // full speed change within the block, we need to adjust the entry speed accordingly. Entry
   // speeds have already been reset, maximized, and reverse planned by reverse planner.
   // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
-  if (!previous->nominal_length_flag) {
+  if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
     if (previous->entry_speed < current->entry_speed) {
-      double entry_speed = min(current->entry_speed,
+      float entry_speed = min(current->entry_speed,
                                max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
       // Check for junction speed change
       if (current->entry_speed != entry_speed) {
         current->entry_speed = entry_speed;
-        current->recalculate_flag = true;
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
   }
@@ -302,19 +291,18 @@ void Planner::forward_pass() {
  */
 void Planner::recalculate_trapezoids() {
   int8_t block_index = block_buffer_tail;
-  block_t* current;
-  block_t* next = NULL;
+  block_t *current, *next = NULL;
 
   while (block_index != block_buffer_head) {
     current = next;
     next = &block_buffer[block_index];
     if (current) {
       // Recalculate if current block entry or exit junction speed has changed.
-      if (current->recalculate_flag || next->recalculate_flag) {
+      if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
         // NOTE: Entry and exit factors always > 0 by all previous logic operations.
         float nom = current->nominal_speed;
         calculate_trapezoid_for_block(current, current->entry_speed / nom, next->entry_speed / nom);
-        current->recalculate_flag = false; // Reset current only to ensure next trapezoid is computed
+        CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
       }
     }
     block_index = next_block_index(block_index);
@@ -323,7 +311,7 @@ void Planner::recalculate_trapezoids() {
   if (next) {
     float nom = next->nominal_speed;
     calculate_trapezoid_for_block(next, next->entry_speed / nom, (MINIMUM_PLANNER_SPEED) / nom);
-    next->recalculate_flag = false;
+    CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
@@ -526,10 +514,12 @@ void Planner::check_axes_activity() {
 }
 
 #if PLANNER_LEVELING
-
+  /**
+   * lx, ly, lz - logical (cartesian, not delta) positions in mm
+   */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    #if HAS_ABL
       if (!abl_enabled) return;
     #endif
 
@@ -538,7 +528,7 @@ void Planner::check_axes_activity() {
       if (mbl.active())
         lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
 
-    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #elif ABL_PLANAR
 
       float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
             dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
@@ -550,29 +540,17 @@ void Planner::check_axes_activity() {
       ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
       lz = LOGICAL_Z_POSITION(dz);
 
-    #elif ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       float tmp[XYZ] = { lx, ly, 0 };
-
-      #if ENABLED(DELTA)
-
-        float offset = nonlinear_z_offset(tmp);
-        lx += offset;
-        ly += offset;
-        lz += offset;
-
-      #else
-
-        lz += nonlinear_z_offset(tmp);
-
-      #endif
+      lz += bilinear_z_offset(tmp);
 
     #endif
   }
 
   void Planner::unapply_leveling(float logical[XYZ]) {
 
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    #if HAS_ABL
       if (!abl_enabled) return;
     #endif
 
@@ -581,7 +559,7 @@ void Planner::check_axes_activity() {
       if (mbl.active())
         logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
 
-    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #elif ABL_PLANAR
 
       matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
@@ -595,9 +573,9 @@ void Planner::check_axes_activity() {
       logical[Y_AXIS] = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
       logical[Z_AXIS] = LOGICAL_Z_POSITION(dz);
 
-    #elif ENABLED(AUTO_BED_LEVELING_NONLINEAR)
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      logical[Z_AXIS] -= nonlinear_z_offset(logical);
+      logical[Z_AXIS] -= bilinear_z_offset(logical);
 
     #endif
   }
@@ -605,60 +583,53 @@ void Planner::check_axes_activity() {
 #endif // PLANNER_LEVELING
 
 /**
- * Planner::buffer_line
+ * Planner::_buffer_line
  *
  * Add a new linear movement to the buffer.
  *
- *  x,y,z,e   - target position in mm
- *  fr_mm_s   - (target) speed of the move
- *  extruder  - target extruder
+ * Leveling and kinematics should be applied ahead of calling this.
+ *
+ *  a,b,c,e     - target positions in mm or degrees
+ *  fr_mm_s     - (target) speed of the move
+ *  extruder    - target extruder
  */
-void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, const uint8_t extruder) {
-  // Calculate the buffer head after we push this byte
-  int next_buffer_head = next_block_index(block_buffer_head);
-
-  // If the buffer is full: good! That means we are well ahead of the robot.
-  // Rest here until there is room in the buffer.
-  while (block_buffer_tail == next_buffer_head) idle();
-
-  #if PLANNER_LEVELING
-    apply_leveling(lx, ly, lz);
-  #endif
+void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
-  long target[NUM_AXIS] = {
-    lround(lx * axis_steps_per_mm[X_AXIS]),
-    lround(ly * axis_steps_per_mm[Y_AXIS]),
-    lround(lz * axis_steps_per_mm[Z_AXIS]),
+  long target[XYZE] = {
+    lround(a * axis_steps_per_mm[X_AXIS]),
+    lround(b * axis_steps_per_mm[Y_AXIS]),
+    lround(c * axis_steps_per_mm[Z_AXIS]),
     lround(e * axis_steps_per_mm[E_AXIS])
   };
 
-  long dx = target[X_AXIS] - position[X_AXIS],
-       dy = target[Y_AXIS] - position[Y_AXIS],
-       dz = target[Z_AXIS] - position[Z_AXIS];
+  long da = target[X_AXIS] - position[X_AXIS],
+       db = target[Y_AXIS] - position[Y_AXIS],
+       dc = target[Z_AXIS] - position[Z_AXIS];
 
   /*
   SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
   SERIAL_CHAR(' ');
   #if IS_KINEMATIC
-    SERIAL_ECHOPAIR("A:", lx);
-    SERIAL_ECHOPAIR(" (", dx);
-    SERIAL_ECHOPAIR(") B:", ly);
+    SERIAL_ECHOPAIR("A:", a);
+    SERIAL_ECHOPAIR(" (", da);
+    SERIAL_ECHOPAIR(") B:", b);
   #else
-    SERIAL_ECHOPAIR("X:", lx);
-    SERIAL_ECHOPAIR(" (", dx);
-    SERIAL_ECHOPAIR(") Y:", ly);
+    SERIAL_ECHOPAIR("X:", a);
+    SERIAL_ECHOPAIR(" (", da);
+    SERIAL_ECHOPAIR(") Y:", b);
   #endif
-  SERIAL_ECHOPAIR(" (", dy);
+  SERIAL_ECHOPAIR(" (", db);
   #if ENABLED(DELTA)
-    SERIAL_ECHOPAIR(") C:", lz);
+    SERIAL_ECHOPAIR(") C:", c);
   #else
-    SERIAL_ECHOPAIR(") Z:", lz);
+    SERIAL_ECHOPAIR(") Z:", c);
   #endif
-  SERIAL_ECHOPAIR(" (", dz);
-  SERIAL_ECHOLNPGM(")");
+  SERIAL_ECHOPAIR(" (", dc);
+  SERIAL_CHAR(')');
+  SERIAL_EOL;
   //*/
 
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
@@ -685,38 +656,77 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
     }
   #endif
 
+  // Compute direction bit-mask for this block
+  uint8_t dm = 0;
+  #if ENABLED(COREXY)
+    if (da < 0) SBI(dm, X_HEAD); // Save the real Extruder (head) direction in X Axis
+    if (db < 0) SBI(dm, Y_HEAD); // ...and Y
+    if (dc < 0) SBI(dm, Z_AXIS);
+    if (da + db < 0) SBI(dm, A_AXIS); // Motor A direction
+    if (da - db < 0) SBI(dm, B_AXIS); // Motor B direction
+  #elif ENABLED(COREXZ)
+    if (da < 0) SBI(dm, X_HEAD); // Save the real Extruder (head) direction in X Axis
+    if (db < 0) SBI(dm, Y_AXIS);
+    if (dc < 0) SBI(dm, Z_HEAD); // ...and Z
+    if (da + dc < 0) SBI(dm, A_AXIS); // Motor A direction
+    if (da - dc < 0) SBI(dm, C_AXIS); // Motor C direction
+  #elif ENABLED(COREYZ)
+    if (da < 0) SBI(dm, X_AXIS);
+    if (db < 0) SBI(dm, Y_HEAD); // Save the real Extruder (head) direction in Y Axis
+    if (dc < 0) SBI(dm, Z_HEAD); // ...and Z
+    if (db + dc < 0) SBI(dm, B_AXIS); // Motor B direction
+    if (db - dc < 0) SBI(dm, C_AXIS); // Motor C direction
+  #else
+    if (da < 0) SBI(dm, X_AXIS);
+    if (db < 0) SBI(dm, Y_AXIS);
+    if (dc < 0) SBI(dm, Z_AXIS);
+  #endif
+  if (de < 0) SBI(dm, E_AXIS);
+
+  int32_t esteps = labs(de) * volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01 + 0.5;
+
+  // Calculate the buffer head after we push this byte
+  int next_buffer_head = next_block_index(block_buffer_head);
+
+  // If the buffer is full: good! That means we are well ahead of the robot.
+  // Rest here until there is room in the buffer.
+  while (block_buffer_tail == next_buffer_head) idle();
+
   // Prepare to set up new block
   block_t* block = &block_buffer[block_buffer_head];
 
-  // Mark block as not busy (Not executed by the stepper interrupt)
-  block->busy = false;
+  // Clear all flags, including the "busy" bit
+  block->flag = 0;
+
+  // Set direction bits
+  block->direction_bits = dm;
 
   // Number of steps for each axis
   #if ENABLED(COREXY)
     // corexy planning
     // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
-    block->steps[A_AXIS] = labs(dx + dy);
-    block->steps[B_AXIS] = labs(dx - dy);
-    block->steps[Z_AXIS] = labs(dz);
+    block->steps[A_AXIS] = labs(da + db);
+    block->steps[B_AXIS] = labs(da - db);
+    block->steps[Z_AXIS] = labs(dc);
   #elif ENABLED(COREXZ)
     // corexz planning
-    block->steps[A_AXIS] = labs(dx + dz);
-    block->steps[Y_AXIS] = labs(dy);
-    block->steps[C_AXIS] = labs(dx - dz);
+    block->steps[A_AXIS] = labs(da + dc);
+    block->steps[Y_AXIS] = labs(db);
+    block->steps[C_AXIS] = labs(da - dc);
   #elif ENABLED(COREYZ)
     // coreyz planning
-    block->steps[X_AXIS] = labs(dx);
-    block->steps[B_AXIS] = labs(dy + dz);
-    block->steps[C_AXIS] = labs(dy - dz);
+    block->steps[X_AXIS] = labs(da);
+    block->steps[B_AXIS] = labs(db + dc);
+    block->steps[C_AXIS] = labs(db - dc);
   #else
     // default non-h-bot planning
-    block->steps[X_AXIS] = labs(dx);
-    block->steps[Y_AXIS] = labs(dy);
-    block->steps[Z_AXIS] = labs(dz);
+    block->steps[X_AXIS] = labs(da);
+    block->steps[Y_AXIS] = labs(db);
+    block->steps[Z_AXIS] = labs(dc);
   #endif
 
-  block->steps[E_AXIS] = labs(de) * volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01 + 0.5;
-  block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], block->steps[E_AXIS]);
+  block->steps[E_AXIS] = esteps;
+  block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
@@ -736,34 +746,6 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
-  // Compute direction bits for this block
-  uint8_t db = 0;
-  #if ENABLED(COREXY)
-    if (dx < 0) SBI(db, X_HEAD); // Save the real Extruder (head) direction in X Axis
-    if (dy < 0) SBI(db, Y_HEAD); // ...and Y
-    if (dz < 0) SBI(db, Z_AXIS);
-    if (dx + dy < 0) SBI(db, A_AXIS); // Motor A direction
-    if (dx - dy < 0) SBI(db, B_AXIS); // Motor B direction
-  #elif ENABLED(COREXZ)
-    if (dx < 0) SBI(db, X_HEAD); // Save the real Extruder (head) direction in X Axis
-    if (dy < 0) SBI(db, Y_AXIS);
-    if (dz < 0) SBI(db, Z_HEAD); // ...and Z
-    if (dx + dz < 0) SBI(db, A_AXIS); // Motor A direction
-    if (dx - dz < 0) SBI(db, C_AXIS); // Motor C direction
-  #elif ENABLED(COREYZ)
-    if (dx < 0) SBI(db, X_AXIS);
-    if (dy < 0) SBI(db, Y_HEAD); // Save the real Extruder (head) direction in Y Axis
-    if (dz < 0) SBI(db, Z_HEAD); // ...and Z
-    if (dy + dz < 0) SBI(db, B_AXIS); // Motor B direction
-    if (dy - dz < 0) SBI(db, C_AXIS); // Motor C direction
-  #else
-    if (dx < 0) SBI(db, X_AXIS);
-    if (dy < 0) SBI(db, Y_AXIS);
-    if (dz < 0) SBI(db, Z_AXIS);
-  #endif
-  if (de < 0) SBI(db, E_AXIS);
-  block->direction_bits = db;
-
   block->active_extruder = extruder;
 
   //enable active axes
@@ -781,6 +763,12 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
       enable_z();
     }
     if (block->steps[Y_AXIS]) enable_y();
+  #elif ENABLED(COREYZ)
+    if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
+      enable_y();
+      enable_z();
+    }
+    if (block->steps[X_AXIS]) enable_x();
   #else
     if (block->steps[X_AXIS]) enable_x();
     if (block->steps[Y_AXIS]) enable_y();
@@ -790,7 +778,7 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
   #endif
 
   // Enable extruder(s)
-  if (block->steps[E_AXIS]) {
+  if (esteps) {
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
@@ -859,7 +847,7 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
     #endif
   }
 
-  if (block->steps[E_AXIS])
+  if (esteps)
     NOLESS(fr_mm_s, min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
@@ -875,29 +863,29 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
   #if ENABLED(COREXY) || ENABLED(COREXZ) || ENABLED(COREYZ)
     float delta_mm[7];
     #if ENABLED(COREXY)
-      delta_mm[X_HEAD] = dx * steps_to_mm[A_AXIS];
-      delta_mm[Y_HEAD] = dy * steps_to_mm[B_AXIS];
-      delta_mm[Z_AXIS] = dz * steps_to_mm[Z_AXIS];
-      delta_mm[A_AXIS] = (dx + dy) * steps_to_mm[A_AXIS];
-      delta_mm[B_AXIS] = (dx - dy) * steps_to_mm[B_AXIS];
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
+      delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
+      delta_mm[B_AXIS] = (da - db) * steps_to_mm[B_AXIS];
     #elif ENABLED(COREXZ)
-      delta_mm[X_HEAD] = dx * steps_to_mm[A_AXIS];
-      delta_mm[Y_AXIS] = dy * steps_to_mm[Y_AXIS];
-      delta_mm[Z_HEAD] = dz * steps_to_mm[C_AXIS];
-      delta_mm[A_AXIS] = (dx + dz) * steps_to_mm[A_AXIS];
-      delta_mm[C_AXIS] = (dx - dz) * steps_to_mm[C_AXIS];
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
+      delta_mm[C_AXIS] = (da - dc) * steps_to_mm[C_AXIS];
     #elif ENABLED(COREYZ)
-      delta_mm[X_AXIS] = dx * steps_to_mm[X_AXIS];
-      delta_mm[Y_HEAD] = dy * steps_to_mm[B_AXIS];
-      delta_mm[Z_HEAD] = dz * steps_to_mm[C_AXIS];
-      delta_mm[B_AXIS] = (dy + dz) * steps_to_mm[B_AXIS];
-      delta_mm[C_AXIS] = (dy - dz) * steps_to_mm[C_AXIS];
+      delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
+      delta_mm[C_AXIS] = (db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
     float delta_mm[4];
-    delta_mm[X_AXIS] = dx * steps_to_mm[X_AXIS];
-    delta_mm[Y_AXIS] = dy * steps_to_mm[Y_AXIS];
-    delta_mm[Z_AXIS] = dz * steps_to_mm[Z_AXIS];
+    delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
+    delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
+    delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   #endif
   delta_mm[E_AXIS] = 0.01 * (de * steps_to_mm[E_AXIS]) * volumetric_multiplier[extruder] * flow_percentage[extruder];
 
@@ -983,15 +971,13 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
-  float current_speed[NUM_AXIS];
-  float speed_factor = 1.0; //factor <=1 do decrease speed
+  float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    current_speed[i] = delta_mm[i] * inverse_mm_s;
-    float cs = fabs(current_speed[i]), mf = max_feedrate_mm_s[i];
-    if (cs > mf) speed_factor = min(speed_factor, mf / cs);
+    float cs = fabs(current_speed[i] = delta_mm[i] * inverse_mm_s);
+    if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
-  // Max segement time in us.
+  // Max segment time in µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -1025,7 +1011,7 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
          min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME) {
       float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME);
-      speed_factor = min(speed_factor, low_sf);
+      NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
@@ -1037,100 +1023,191 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
-  float steps_per_mm = block->step_event_count / block->millimeters;
+  float steps_per_mm = block->step_event_count * inverse_millimeters;
+  uint32_t accel;
   if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
-    block->acceleration_steps_per_s2 = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
+    // convert to: acceleration steps/sec^2
+    accel = ceil(retract_acceleration * steps_per_mm);
   }
   else {
+    #define LIMIT_ACCEL_LONG(AXIS) do{ \
+      if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS] < accel) { \
+        const uint32_t comp = max_acceleration_steps_per_s2[AXIS] * block->step_event_count; \
+        if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
+      } \
+    }while(0)
+	
+    #define LIMIT_ACCEL_FLOAT(AXIS) do{ \
+      if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS] < accel) { \
+        const float comp = (float)max_acceleration_steps_per_s2[AXIS] * (float)block->step_event_count; \
+        if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
+      } \
+    }while(0)
+
+    // Start with print or travel acceleration
+    accel = ceil((esteps ? acceleration : travel_acceleration) * steps_per_mm);
+
     // Limit acceleration per axis
-    block->acceleration_steps_per_s2 = ceil((block->steps[E_AXIS] ? acceleration : travel_acceleration) * steps_per_mm);
-    if (max_acceleration_steps_per_s2[X_AXIS] < (block->acceleration_steps_per_s2 * block->steps[X_AXIS]) / block->step_event_count)
-      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[X_AXIS] * block->step_event_count) / block->steps[X_AXIS];
-    if (max_acceleration_steps_per_s2[Y_AXIS] < (block->acceleration_steps_per_s2 * block->steps[Y_AXIS]) / block->step_event_count)
-      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[Y_AXIS] * block->step_event_count) / block->steps[Y_AXIS];
-    if (max_acceleration_steps_per_s2[Z_AXIS] < (block->acceleration_steps_per_s2 * block->steps[Z_AXIS]) / block->step_event_count)
-      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[Z_AXIS] * block->step_event_count) / block->steps[Z_AXIS];
-    if (max_acceleration_steps_per_s2[E_AXIS] < (block->acceleration_steps_per_s2 * block->steps[E_AXIS]) / block->step_event_count)
-      block->acceleration_steps_per_s2 = (max_acceleration_steps_per_s2[E_AXIS] * block->step_event_count) / block->steps[E_AXIS];
+    if (block->step_event_count <= cutoff_long){
+      LIMIT_ACCEL_LONG(X_AXIS);
+      LIMIT_ACCEL_LONG(Y_AXIS);
+      LIMIT_ACCEL_LONG(Z_AXIS);
+      LIMIT_ACCEL_LONG(E_AXIS);
+    } else {
+      LIMIT_ACCEL_FLOAT(X_AXIS);
+      LIMIT_ACCEL_FLOAT(Y_AXIS);
+      LIMIT_ACCEL_FLOAT(Z_AXIS);
+      LIMIT_ACCEL_FLOAT(E_AXIS);
+    }
   }
-  block->acceleration = block->acceleration_steps_per_s2 / steps_per_mm;
-  block->acceleration_rate = (long)(block->acceleration_steps_per_s2 * 16777216.0 / ((F_CPU) * 0.125));
+  block->acceleration_steps_per_s2 = accel;
+  block->acceleration = accel / steps_per_mm;
+  block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
+
+  // Initial limit on the segment entry velocity
+  float vmax_junction;
 
   #if 0  // Use old jerk for now
 
     float junction_deviation = 0.1;
 
     // Compute path unit vector
-    double unit_vec[XYZ];
-
-    unit_vec[X_AXIS] = delta_mm[X_AXIS] * inverse_millimeters;
-    unit_vec[Y_AXIS] = delta_mm[Y_AXIS] * inverse_millimeters;
-    unit_vec[Z_AXIS] = delta_mm[Z_AXIS] * inverse_millimeters;
-
-    // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
-    // Let a circle be tangent to both previous and current path line segments, where the junction
-    // deviation is defined as the distance from the junction to the closest edge of the circle,
-    // collinear with the circle center. The circular segment joining the two paths represents the
-    // path of centripetal acceleration. Solve for max velocity based on max acceleration about the
-    // radius of the circle, defined indirectly by junction deviation. This may be also viewed as
-    // path width or max_jerk in the previous grbl version. This approach does not actually deviate
-    // from path, but used as a robust way to compute cornering speeds, as it takes into account the
-    // nonlinearities of both the junction angle and junction velocity.
-    double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
+    double unit_vec[XYZ] = {
+      delta_mm[X_AXIS] * inverse_millimeters,
+      delta_mm[Y_AXIS] * inverse_millimeters,
+      delta_mm[Z_AXIS] * inverse_millimeters
+    };
+
+    /*
+       Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
+
+       Let a circle be tangent to both previous and current path line segments, where the junction
+       deviation is defined as the distance from the junction to the closest edge of the circle,
+       collinear with the circle center.
+
+       The circular segment joining the two paths represents the path of centripetal acceleration.
+       Solve for max velocity based on max acceleration about the radius of the circle, defined
+       indirectly by junction deviation.
+
+       This may be also viewed as path width or max_jerk in the previous grbl version. This approach
+       does not actually deviate from path, but used as a robust way to compute cornering speeds, as
+       it takes into account the nonlinearities of both the junction angle and junction velocity.
+     */
+
+    vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
-    if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed > 0.0)) {
+    if (block_buffer_head != block_buffer_tail && previous_nominal_speed > 0.0) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
-      double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
-                         - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
-                         - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
+      float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
+                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
+                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
       // Skip and use default max junction speed for 0 degree acute junction.
       if (cos_theta < 0.95) {
         vmax_junction = min(previous_nominal_speed, block->nominal_speed);
         // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
         if (cos_theta > -0.95) {
           // Compute maximum junction velocity based on maximum acceleration and junction deviation
-          double sin_theta_d2 = sqrt(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
-          vmax_junction = min(vmax_junction,
-                              sqrt(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
+          float sin_theta_d2 = sqrt(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
+          NOMORE(vmax_junction, sqrt(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
         }
       }
     }
   #endif
 
-  // Start with a safe speed
-  float vmax_junction = max_xy_jerk * 0.5,
-        vmax_junction_factor = 1.0,
-        mz2 = max_z_jerk * 0.5,
-        me2 = max_e_jerk * 0.5,
-        csz = current_speed[Z_AXIS],
-        cse = current_speed[E_AXIS];
-  if (fabs(csz) > mz2) vmax_junction = min(vmax_junction, mz2);
-  if (fabs(cse) > me2) vmax_junction = min(vmax_junction, me2);
-  vmax_junction = min(vmax_junction, block->nominal_speed);
-  float safe_speed = vmax_junction;
-
-  if ((moves_queued > 1) && (previous_nominal_speed > 0.0001)) {
-    float dsx = current_speed[X_AXIS] - previous_speed[X_AXIS],
-          dsy = current_speed[Y_AXIS] - previous_speed[Y_AXIS],
-          dsz = fabs(csz - previous_speed[Z_AXIS]),
-          dse = fabs(cse - previous_speed[E_AXIS]),
-          jerk = HYPOT(dsx, dsy);
-
-    //    if ((fabs(previous_speed[X_AXIS]) > 0.0001) || (fabs(previous_speed[Y_AXIS]) > 0.0001)) {
-    vmax_junction = block->nominal_speed;
-    //    }
-    if (jerk > max_xy_jerk) vmax_junction_factor = max_xy_jerk / jerk;
-    if (dsz > max_z_jerk) vmax_junction_factor = min(vmax_junction_factor, max_z_jerk / dsz);
-    if (dse > max_e_jerk) vmax_junction_factor = min(vmax_junction_factor, max_e_jerk / dse);
-
-    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed
+  /**
+   * Adapted from Prusa MKS firmware
+   *
+   * Start with a safe speed (from which the machine may halt to stop immediately).
+   */
+
+  // Exit speed limited by a jerk to full halt of a previous last segment
+  static float previous_safe_speed;
+
+  float safe_speed = block->nominal_speed;
+  bool limited = false;
+  LOOP_XYZE(i) {
+    float jerk = fabs(current_speed[i]);
+    if (jerk > max_jerk[i]) {
+      // The actual jerk is lower if it has been limited by the XY jerk.
+      if (limited) {
+        // Spare one division by a following gymnastics:
+        // Instead of jerk *= safe_speed / block->nominal_speed,
+        // multiply max_jerk[i] by the divisor.
+        jerk *= safe_speed;
+        float mjerk = max_jerk[i] * block->nominal_speed;
+        if (jerk > mjerk) safe_speed *= mjerk / jerk;
+      }
+      else {
+        safe_speed = max_jerk[i];
+        limited = true;
+      }
+    }
   }
+
+  if (moves_queued > 1 && previous_nominal_speed > 0.0001) {
+    // Estimate a maximum velocity allowed at a joint of two successive segments.
+    // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
+    // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
+
+    // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
+    bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
+    float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
+    // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
+    vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
+    // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
+    float v_factor = 1.f;
+    limited = false;
+    // Now limit the jerk in all axes.
+    LOOP_XYZE(axis) {
+      // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
+      float v_exit = previous_speed[axis], v_entry = current_speed[axis];
+      if (prev_speed_larger) v_exit *= smaller_speed_factor;
+      if (limited) {
+        v_exit *= v_factor;
+        v_entry *= v_factor;
+      }
+      // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
+      float jerk = 
+        (v_exit > v_entry) ?
+          ((v_entry > 0.f || v_exit < 0.f) ?
+            // coasting
+            (v_exit - v_entry) : 
+            // axis reversal
+            max(v_exit, -v_entry)) :
+          // v_exit <= v_entry
+          ((v_entry < 0.f || v_exit > 0.f) ?
+            // coasting
+            (v_entry - v_exit) :
+            // axis reversal
+            max(-v_exit, v_entry));
+      if (jerk > max_jerk[axis]) {
+        v_factor *= max_jerk[axis] / jerk;
+        limited = true;
+      }
+    }
+    if (limited) vmax_junction *= v_factor;
+    // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
+    // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
+    float vmax_junction_threshold = vmax_junction * 0.99f;
+    if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
+      // Not coasting. The machine will stop and start the movements anyway,
+      // better to start the segment from start.
+      SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+      vmax_junction = safe_speed;
+    }
+  }
+  else {
+    SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+    vmax_junction = safe_speed;
+  }
+
+  // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
-  double v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
+  float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   block->entry_speed = min(vmax_junction, v_allowable);
 
   // Initialize planner efficiency flags
@@ -1141,12 +1218,12 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->nominal_length_flag = (block->nominal_speed <= v_allowable);
-  block->recalculate_flag = true; // Always calculate trapezoid for new block
+  block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
 
   // Update previous path unit_vector and nominal speed
   memcpy(previous_speed, current_speed, sizeof(previous_speed));
   previous_nominal_speed = block->nominal_speed;
+  previous_safe_speed = safe_speed;
 
   #if ENABLED(LIN_ADVANCE)
 
@@ -1155,24 +1232,24 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
     // This leads to an enormous number of advance steps due to a huge e_acceleration.
     // The math is correct, but you don't want a retract move done with advance!
     // So this situation is filtered out here.
-    if (!block->steps[E_AXIS] || (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) || stepper.get_advance_k() == 0 || (uint32_t) block->steps[E_AXIS] == block->step_event_count) {
+    if (!esteps || (!block->steps[X_AXIS] && !block->steps[Y_AXIS]) || stepper.get_advance_k() == 0 || (uint32_t)esteps == block->step_event_count) {
       block->use_advance_lead = false;
     }
     else {
       block->use_advance_lead = true;
-      block->e_speed_multiplier8 = (block->steps[E_AXIS] << 8) / block->step_event_count;
+      block->e_speed_multiplier8 = (esteps << 8) / block->step_event_count;
     }
 
   #elif ENABLED(ADVANCE)
 
     // Calculate advance rate
-    if (!block->steps[E_AXIS] || (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS])) {
+    if (!esteps || (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS])) {
       block->advance_rate = 0;
       block->advance = 0;
     }
     else {
       long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_steps_per_s2);
-      float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * HYPOT(cse, EXTRUSION_AREA) * 256;
+      float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * HYPOT(current_speed[E_AXIS], EXTRUSION_AREA) * 256;
       block->advance = advance;
       block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
     }
@@ -1201,26 +1278,39 @@ void Planner::buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, float fr_mm_s, co
 } // buffer_line()
 
 /**
- * Directly set the planner XYZ position (hence the stepper positions).
+ * Directly set the planner XYZ position (and stepper positions)
+ * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
-void Planner::set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
-
-  #if PLANNER_LEVELING
-    apply_leveling(lx, ly, lz);
-  #endif
 
-  long nx = position[X_AXIS] = lround(lx * axis_steps_per_mm[X_AXIS]),
-       ny = position[Y_AXIS] = lround(ly * axis_steps_per_mm[Y_AXIS]),
-       nz = position[Z_AXIS] = lround(lz * axis_steps_per_mm[Z_AXIS]),
+void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
+  long na = position[X_AXIS] = lround(a * axis_steps_per_mm[X_AXIS]),
+       nb = position[Y_AXIS] = lround(b * axis_steps_per_mm[Y_AXIS]),
+       nc = position[Z_AXIS] = lround(c * axis_steps_per_mm[Z_AXIS]),
        ne = position[E_AXIS] = lround(e * axis_steps_per_mm[E_AXIS]);
-  stepper.set_position(nx, ny, nz, ne);
+  stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
 
-  memset(previous_speed, 0, sizeof(previous_speed));
+  ZERO(previous_speed);
+}
+
+void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
+  #if PLANNER_LEVELING
+    float pos[XYZ] = { position[X_AXIS], position[Y_AXIS], position[Z_AXIS] };
+    apply_leveling(pos);
+  #else
+    const float * const pos = position;
+  #endif
+  #if IS_KINEMATIC
+    inverse_kinematics(pos);
+    _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
+  #else
+    _set_position_mm(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], position[E_AXIS]);
+  #endif
 }
 
+
 /**
  * Sync from the stepper positions. (e.g., after an interrupted move)
  */
@@ -1229,29 +1319,28 @@ void Planner::sync_from_steppers() {
 }
 
 /**
- * Directly set the planner E position (hence the stepper E position).
+ * Setters for planner position (also setting stepper position).
  */
-void Planner::set_e_position_mm(const float& e) {
-  position[E_AXIS] = lround(e * axis_steps_per_mm[E_AXIS]);
-  stepper.set_e_position(position[E_AXIS]);
-  previous_speed[E_AXIS] = 0.0;
+void Planner::set_position_mm(const AxisEnum axis, const float& v) {
+  position[axis] = lround(v * axis_steps_per_mm[axis]);
+  stepper.set_position(axis, v);
+  previous_speed[axis] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
-  LOOP_XYZE(i)
+  uint32_t highest_rate = 1;
+  LOOP_XYZE(i) {
     max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
+    NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
+  }
+  cutoff_long = 4294967295UL / highest_rate;
 }
 
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
-  #if IS_KINEMATIC
-    inverse_kinematics(current_position);
-    set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS]);
-  #else
-    set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-  #endif
+  set_position_mm_kinematic(current_position);
   reset_acceleration_rates();
 }
 
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 27505e9..0d97107 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -33,14 +33,35 @@
 #define PLANNER_H
 
 #include "types.h"
-#include "MarlinConfig.h"
+#include "enum.h"
+#include "Marlin.h"
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
   #include "vector_3.h"
 #endif
 
-class Planner;
-extern Planner planner;
+enum BlockFlagBit {
+  // Recalculate trapezoids on entry junction. For optimization.
+  BLOCK_BIT_RECALCULATE,
+
+  // Nominal speed always reached.
+  // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
+  // from a safe speed (in consideration of jerking from zero speed).
+  BLOCK_BIT_NOMINAL_LENGTH,
+
+  // Start from a halt at the start of this block, respecting the maximum allowed jerk.
+  BLOCK_BIT_START_FROM_FULL_HALT,
+
+  // The block is busy
+  BLOCK_BIT_BUSY
+};
+
+enum BlockFlag {
+  BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
+  BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
+  BLOCK_FLAG_START_FROM_FULL_HALT = _BV(BLOCK_BIT_START_FROM_FULL_HALT),
+  BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY)
+};
 
 /**
  * struct block_t
@@ -53,58 +74,56 @@ extern Planner planner;
  */
 typedef struct {
 
+  uint8_t flag;                             // Block flags (See BlockFlag enum above)
+
   unsigned char active_extruder;            // The extruder to move (if E move)
 
-  // Fields used by the bresenham algorithm for tracing the line
-  long steps[NUM_AXIS];                     // Step count along each axis
-  unsigned long step_event_count;           // The number of step events required to complete this block
+  // Fields used by the Bresenham algorithm for tracing the line
+  int32_t steps[NUM_AXIS];                  // Step count along each axis
+  uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if ENABLED(MIXING_EXTRUDER)
-    unsigned long mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
+    uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
   #endif
 
-  long accelerate_until,                    // The index of the step event on which to stop acceleration
-       decelerate_after,                    // The index of the step event on which to start decelerating
-       acceleration_rate;                   // The acceleration rate used for acceleration calculation
+  int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
+          decelerate_after,                 // The index of the step event on which to start decelerating
+          acceleration_rate;                // The acceleration rate used for acceleration calculation
 
-  unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
+  uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
-    int e_speed_multiplier8; // Factorised by 2^8 to avoid float
+    int16_t e_speed_multiplier8; // Factorised by 2^8 to avoid float
   #elif ENABLED(ADVANCE)
-    long advance_rate;
-    volatile long initial_advance;
-    volatile long final_advance;
+    int32_t advance_rate;
+    volatile int32_t initial_advance;
+    volatile int32_t final_advance;
     float advance;
   #endif
 
   // Fields used by the motion planner to manage acceleration
-  float nominal_speed,                               // The nominal speed for this block in mm/sec
-        entry_speed,                                 // Entry speed at previous-current junction in mm/sec
-        max_entry_speed,                             // Maximum allowable junction entry speed in mm/sec
-        millimeters,                                 // The total travel of this block in mm
-        acceleration;                                // acceleration mm/sec^2
-  unsigned char recalculate_flag,                    // Planner flag to recalculate trapezoids on entry junction
-                nominal_length_flag;                 // Planner flag for nominal speed always reached
+  float nominal_speed,                      // The nominal speed for this block in mm/sec
+        entry_speed,                        // Entry speed at previous-current junction in mm/sec
+        max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
+        millimeters,                        // The total travel of this block in mm
+        acceleration;                       // acceleration mm/sec^2
 
   // Settings for the trapezoid generator
-  unsigned long nominal_rate,                        // The nominal step rate for this block in step_events/sec
-                initial_rate,                        // The jerk-adjusted step rate at start of block
-                final_rate,                          // The minimal rate at exit
-                acceleration_steps_per_s2;           // acceleration steps/sec^2
+  uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
+           initial_rate,                    // The jerk-adjusted step rate at start of block
+           final_rate,                      // The minimal rate at exit
+           acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
-    unsigned long fan_speed[FAN_COUNT];
+    uint32_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
-    unsigned long valve_pressure, e_to_p_pressure;
+    uint32_t valve_pressure, e_to_p_pressure;
   #endif
 
-  volatile char busy;
-
 } block_t;
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
@@ -131,12 +150,10 @@ class Planner {
     static float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
     static float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
     static float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-    static float max_xy_jerk;          // The largest speed change requiring no acceleration
-    static float max_z_jerk;
-    static float max_e_jerk;
+    static float max_jerk[XYZE];       // The largest speed change requiring no acceleration
     static float min_travel_feedrate_mm_s;
 
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    #if HAS_ABL
       static bool abl_enabled;            // Flag that bed leveling is enabled
       static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
     #endif
@@ -158,6 +175,11 @@ class Planner {
      * Nominal speed of previous path line segment
      */
     static float previous_nominal_speed;
+	
+	/**
+ 	 * Limit where 64bit math is necessary for acceleration calculation
+ 	 */
+ 	static uint32_t cutoff_long;
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       /**
@@ -202,35 +224,85 @@ class Planner {
 
     static bool is_full() { return (block_buffer_tail == BLOCK_MOD(block_buffer_head + 1)); }
 
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
+    #if PLANNER_LEVELING
+
       #define ARG_X float lx
       #define ARG_Y float ly
       #define ARG_Z float lz
-    #else
-      #define ARG_X const float &lx
-      #define ARG_Y const float &ly
-      #define ARG_Z const float &lz
-    #endif
-
-    #if PLANNER_LEVELING
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(float &lx, float &ly, float &lz);
+      static void apply_leveling(float logical[XYZ]) { apply_leveling(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS]); }
       static void unapply_leveling(float logical[XYZ]);
 
+    #else
+
+      #define ARG_X const float &lx
+      #define ARG_Y const float &ly
+      #define ARG_Z const float &lz
+
     #endif
 
     /**
-     * Add a new linear movement to the buffer.
+     * Planner::_buffer_line
+     *
+     * Add a new direct linear movement to the buffer.
+     *
+     * Leveling and kinematics should be applied ahead of this.
      *
-     *  x,y,z,e   - target position in mm
+     *  a,b,c,e   - target position in mm or degrees
      *  fr_mm_s   - (target) speed of the move (mm/s)
      *  extruder  - target extruder
      */
-    static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float& e, float fr_mm_s, const uint8_t extruder);
+    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
+
+    static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
+
+    /**
+     * Add a new linear movement to the buffer.
+     * The target is NOT translated to delta/scara
+     *
+     * Leveling will be applied to input on cartesians.
+     * Kinematic machines should call buffer_line_kinematic (for leveled moves).
+     * (Cartesians may also call buffer_line_kinematic.)
+     *
+     *  lx,ly,lz,e   - target position in mm or degrees
+     *  fr_mm_s      - (target) speed of the move (mm/s)
+     *  extruder     - target extruder
+     */
+    static FORCE_INLINE void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+      #if PLANNER_LEVELING && IS_CARTESIAN
+        apply_leveling(lx, ly, lz);
+      #endif
+      _buffer_line(lx, ly, lz, e, fr_mm_s, extruder);
+    }
+
+    /**
+     * Add a new linear movement to the buffer.
+     * The target is cartesian, it's translated to delta/scara if
+     * needed.
+     *
+     *  target   - x,y,z,e CARTESIAN target in mm
+     *  fr_mm_s  - (target) speed of the move (mm/s)
+     *  extruder - target extruder
+     */
+    static FORCE_INLINE void buffer_line_kinematic(const float target[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+      #if PLANNER_LEVELING
+        float pos[XYZ] = { target[X_AXIS], target[Y_AXIS], target[Z_AXIS] };
+        apply_leveling(pos);
+      #else
+        const float * const pos = target;
+      #endif
+      #if IS_KINEMATIC
+        inverse_kinematics(pos);
+        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], target[E_AXIS], fr_mm_s, extruder);
+      #else
+        _buffer_line(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], target[E_AXIS], fr_mm_s, extruder);
+      #endif
+    }
 
     /**
      * Set the planner.position and individual stepper positions.
@@ -241,7 +313,16 @@ class Planner {
      *
      * Clears previous speed values.
      */
-    static void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float& e);
+    static FORCE_INLINE void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
+      #if PLANNER_LEVELING && IS_CARTESIAN
+        apply_leveling(lx, ly, lz);
+      #endif
+      _set_position_mm(lx, ly, lz, e);
+    }
+    static void set_position_mm_kinematic(const float position[NUM_AXIS]);
+    static void set_position_mm(const AxisEnum axis, const float &v);
+    static FORCE_INLINE void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
+    static FORCE_INLINE void set_e_position_mm(const float &e) { set_position_mm(E_AXIS, e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
@@ -249,11 +330,6 @@ class Planner {
     static void sync_from_steppers();
 
     /**
-     * Set the E position (mm) of the planner (and the E stepper)
-     */
-    static void set_e_position_mm(const float& e);
-
-    /**
      * Does the buffer have any blocks queued?
      */
     static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
@@ -274,7 +350,7 @@ class Planner {
     static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t* block = &block_buffer[block_buffer_tail];
-        block->busy = true;
+        SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else
@@ -302,7 +378,7 @@ class Planner {
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
-    static float estimate_acceleration_distance(float initial_rate, float target_rate, float accel) {
+    static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
@@ -315,7 +391,7 @@ class Planner {
      * This is used to compute the intersection point between acceleration and deceleration
      * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
      */
-    static float intersection_distance(float initial_rate, float final_rate, float accel, float distance) {
+    static float intersection_distance(const float &initial_rate, const float &final_rate, const float &accel, const float &distance) {
       if (accel == 0) return 0; // accel was 0, set intersection distance to 0
       return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
     }
@@ -325,14 +401,14 @@ class Planner {
      * to reach 'target_velocity' using 'acceleration' within a given
      * 'distance'.
      */
-    static float max_allowable_speed(float accel, float target_velocity, float distance) {
+    static float max_allowable_speed(const float &accel, const float &target_velocity, const float &distance) {
       return sqrt(sq(target_velocity) - 2 * accel * distance);
     }
 
-    static void calculate_trapezoid_for_block(block_t* block, float entry_factor, float exit_factor);
+    static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
 
-    static void reverse_pass_kernel(block_t* current, block_t* next);
-    static void forward_pass_kernel(block_t* previous, block_t* current);
+    static void reverse_pass_kernel(block_t* const current, const block_t *next);
+    static void forward_pass_kernel(const block_t *previous, block_t* const current);
 
     static void reverse_pass();
     static void forward_pass();
@@ -343,4 +419,6 @@ class Planner {
 
 };
 
+extern Planner planner;
+
 #endif // PLANNER_H
diff --git a/Marlin/planner_bezier.cpp b/Marlin/planner_bezier.cpp
index ad46f89..d7dd960 100644
--- a/Marlin/planner_bezier.cpp
+++ b/Marlin/planner_bezier.cpp
@@ -187,13 +187,7 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
     clamp_to_software_endstops(bez_target);
-
-    #if IS_KINEMATIC
-      inverse_kinematics(bez_target);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], bez_target[E_AXIS], fr_mm_s, extruder);
-    #else
-      planner.buffer_line(bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS], bez_target[E_AXIS], fr_mm_s, extruder);
-    #endif
+    planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder);
   }
 }
 
diff --git a/Marlin/platformio.ini b/Marlin/platformio.ini
index 8e66bd3..a008646 100755
--- a/Marlin/platformio.ini
+++ b/Marlin/platformio.ini
@@ -13,6 +13,8 @@
 
 [platformio]
 src_dir = ./
+envs_dir = ../.pioenvs
+lib_dir = ../.piolib
 env_default = mega2560
 
 [env:mega2560]
diff --git a/Marlin/qr_solve.cpp b/Marlin/qr_solve.cpp
index 9404f8e..20bbb62 100644
--- a/Marlin/qr_solve.cpp
+++ b/Marlin/qr_solve.cpp
@@ -22,7 +22,7 @@
 
 #include "qr_solve.h"
 
-#if ENABLED(AUTO_BED_LEVELING_LINEAR_GRID)
+#if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
 #include <stdlib.h>
 #include <math.h>
diff --git a/Marlin/qr_solve.h b/Marlin/qr_solve.h
index a83509d..c409220 100644
--- a/Marlin/qr_solve.h
+++ b/Marlin/qr_solve.h
@@ -22,7 +22,7 @@
 
 #include "MarlinConfig.h"
 
-#if ENABLED(AUTO_BED_LEVELING_GRID)
+#if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
 void daxpy(int n, float da, float dx[], int incx, float dy[], int incy);
 float ddot(int n, float dx[], int incx, float dy[], int incy);
diff --git a/Marlin/stepper.cpp b/Marlin/stepper.cpp
index 00595e1..5b910a3 100644
--- a/Marlin/stepper.cpp
+++ b/Marlin/stepper.cpp
@@ -91,11 +91,11 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
 
-  unsigned char Stepper::old_OCR0A;
+  unsigned char Stepper::old_OCR0A = 0;
   volatile unsigned char Stepper::eISR_Rate = 200; // Keep the ISR at a low rate until needed
 
   #if ENABLED(LIN_ADVANCE)
-    volatile long Stepper::e_steps[E_STEPPERS];
+    volatile int Stepper::e_steps[E_STEPPERS];
     int Stepper::extruder_advance_k = LIN_ADVANCE_K,
         Stepper::final_estep_rate,
         Stepper::current_estep_rate[E_STEPPERS],
@@ -162,14 +162,14 @@ volatile long Stepper::endstops_trigsteps[XYZ];
   #if ENABLED(Z_DUAL_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) \
     if (performing_homing) { \
-      if (Z_HOME_DIR > 0) {\
-        if (!(TEST(endstops.old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
-        if (!(TEST(endstops.old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
-      } \
-      else { \
+      if (Z_HOME_DIR < 0) { \
         if (!(TEST(endstops.old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
         if (!(TEST(endstops.old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
       } \
+      else { \
+        if (!(TEST(endstops.old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
+        if (!(TEST(endstops.old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
+      } \
     } \
     else { \
       Z_STEP_WRITE(v); \
@@ -299,18 +299,32 @@ void Stepper::set_directions() {
     SET_STEP_DIR(Z); // C
   #endif
 
-  if (motor_direction(E_AXIS)) {
-    REV_E_DIR();
-    count_direction[E_AXIS] = -1;
-  }
-  else {
-    NORM_E_DIR();
-    count_direction[E_AXIS] = 1;
-  }
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    if (motor_direction(E_AXIS)) {
+      REV_E_DIR();
+      count_direction[E_AXIS] = -1;
+    }
+    else {
+      NORM_E_DIR();
+      count_direction[E_AXIS] = 1;
+    }
+  #endif // !ADVANCE && !LIN_ADVANCE
 }
 
-// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.
-// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.
+/**
+ * Stepper Driver Interrupt
+ *
+ * Directly pulses the stepper motors at high frequency.
+ * Timer 1 runs at a base frequency of 2MHz, with this ISR using OCR1A compare mode.
+ *
+ * OCR1A   Frequency
+ *     1     2 MHz
+ *    50    40 KHz
+ *   100    20 KHz - capped max rate
+ *   200    10 KHz - nominal max rate
+ *  2000     1 KHz - sleep rate
+ *  4000   500  Hz - init rate
+ */
 ISR(TIMER1_COMPA_vect) { Stepper::isr(); }
 
 void Stepper::isr() {
@@ -321,7 +335,7 @@ void Stepper::isr() {
       if ((cleaning_buffer_counter == 1) && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
     #endif
     cleaning_buffer_counter--;
-    OCR1A = 200;
+    OCR1A = 200; // Run at max speed - 10 KHz
     return;
   }
 
@@ -330,7 +344,7 @@ void Stepper::isr() {
     // Anything in the buffer?
     current_block = planner.get_current_block();
     if (current_block) {
-      current_block->busy = true;
+      SBI(current_block->flag, BLOCK_BIT_BUSY);
       trapezoid_generator_reset();
 
       // Initialize Bresenham counters to 1/2 the ceiling
@@ -346,7 +360,7 @@ void Stepper::isr() {
       #if ENABLED(Z_LATE_ENABLE)
         if (current_block->steps[Z_AXIS] > 0) {
           enable_z();
-          OCR1A = 2000; //1ms wait
+          OCR1A = 2000; // Run at slow speed - 1 KHz
           return;
         }
       #endif
@@ -356,7 +370,7 @@ void Stepper::isr() {
       // #endif
     }
     else {
-      OCR1A = 2000; // 1kHz.
+      OCR1A = 2000; // Run at slow speed - 1 KHz
       return;
     }
   }
@@ -389,7 +403,7 @@ void Stepper::isr() {
 
       #if ENABLED(MIXING_EXTRUDER)
         // Step mixing steppers proportionally
-        bool dir = motor_direction(E_AXIS);
+        const bool dir = motor_direction(E_AXIS);
         MIXING_STEPPERS_LOOP(j) {
           counter_m[j] += current_block->steps[E_AXIS];
           if (counter_m[j] > 0) {
@@ -399,22 +413,6 @@ void Stepper::isr() {
         }
       #endif
 
-      if (current_block->use_advance_lead) {
-        int delta_adv_steps = (((long)extruder_advance_k * current_estep_rate[TOOL_E_INDEX]) >> 9) - current_adv_steps[TOOL_E_INDEX];
-        #if ENABLED(MIXING_EXTRUDER)
-          // Mixing extruders apply advance lead proportionally
-          MIXING_STEPPERS_LOOP(j) {
-            int steps = delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
-            e_steps[j] += steps;
-            current_adv_steps[j] += steps;
-          }
-        #else
-          // For most extruders, advance the single E stepper
-          e_steps[TOOL_E_INDEX] += delta_adv_steps;
-          current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
-        #endif
-      }
-
     #elif ENABLED(ADVANCE)
 
       // Always count the unified E axis
@@ -430,7 +428,7 @@ void Stepper::isr() {
       #if ENABLED(MIXING_EXTRUDER)
 
         // Step mixing steppers proportionally
-        bool dir = motor_direction(E_AXIS);
+        const bool dir = motor_direction(E_AXIS);
         MIXING_STEPPERS_LOOP(j) {
           counter_m[j] += current_block->steps[E_AXIS];
           if (counter_m[j] > 0) {
@@ -534,6 +532,21 @@ void Stepper::isr() {
     }
   }
 
+  #if ENABLED(LIN_ADVANCE)
+    if (current_block->use_advance_lead) {
+      int delta_adv_steps = (((long)extruder_advance_k * current_estep_rate[TOOL_E_INDEX]) >> 9) - current_adv_steps[TOOL_E_INDEX];
+      current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
+      #if ENABLED(MIXING_EXTRUDER)
+        // Mixing extruders apply advance lead proportionally
+        MIXING_STEPPERS_LOOP(j)
+          e_steps[j] += delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
+      #else
+        // For most extruders, advance the single E stepper
+        e_steps[TOOL_E_INDEX] += delta_adv_steps;
+      #endif
+   }
+  #endif
+  
   #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
     // If we have esteps to execute, fire the next advance_isr "now"
     if (e_steps[TOOL_E_INDEX]) OCR0A = TCNT0 + 2;
@@ -556,9 +569,6 @@ void Stepper::isr() {
 
     #if ENABLED(LIN_ADVANCE)
 
-      if (current_block->use_advance_lead)
-        current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->e_speed_multiplier8) >> 8;
-
       if (current_block->use_advance_lead) {
         #if ENABLED(MIXING_EXTRUDER)
           MIXING_STEPPERS_LOOP(j)
@@ -591,7 +601,7 @@ void Stepper::isr() {
     #endif // ADVANCE or LIN_ADVANCE
 
     #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
-      eISR_Rate = (timer >> 2) * step_loops / abs(e_steps[TOOL_E_INDEX]);
+      eISR_Rate = (timer >> 3) * step_loops / abs(e_steps[TOOL_E_INDEX]); //>> 3 is divide by 8. Reason: Timer 1 runs at 16/8=2MHz, Timer 0 at 16/64=0.25MHz. ==> 2/0.25=8.
     #endif
   }
   else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
@@ -641,7 +651,7 @@ void Stepper::isr() {
     #endif // ADVANCE or LIN_ADVANCE
 
     #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
-      eISR_Rate = (timer >> 2) * step_loops / abs(e_steps[TOOL_E_INDEX]);
+      eISR_Rate = (timer >> 3) * step_loops / abs(e_steps[TOOL_E_INDEX]);
     #endif
   }
   else {
@@ -651,7 +661,7 @@ void Stepper::isr() {
       if (current_block->use_advance_lead)
         current_estep_rate[TOOL_E_INDEX] = final_estep_rate;
 
-      eISR_Rate = (OCR1A_nominal >> 2) * step_loops_nominal / abs(e_steps[TOOL_E_INDEX]);
+      eISR_Rate = (OCR1A_nominal >> 3) * step_loops_nominal / abs(e_steps[TOOL_E_INDEX]);
 
     #endif
 
@@ -680,15 +690,29 @@ void Stepper::isr() {
     old_OCR0A += eISR_Rate;
     OCR0A = old_OCR0A;
 
+    #define SET_E_STEP_DIR(INDEX) \
+      if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
+
     #define START_E_PULSE(INDEX) \
       if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
 
     #define STOP_E_PULSE(INDEX) \
       if (e_steps[INDEX]) { \
-        e_steps[INDEX] <= 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
+        e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
         E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
       }
 
+    SET_E_STEP_DIR(0);
+    #if E_STEPPERS > 1
+      SET_E_STEP_DIR(1);
+      #if E_STEPPERS > 2
+        SET_E_STEP_DIR(2);
+        #if E_STEPPERS > 3
+          SET_E_STEP_DIR(3);
+        #endif
+      #endif
+    #endif
+
     #define CYCLES_EATEN_BY_E 60
 
     // Step all E steppers that have steps
@@ -733,19 +757,27 @@ void Stepper::isr() {
 
 void Stepper::init() {
 
-  digipot_init(); //Initialize Digipot Motor Current
-  microstep_init(); //Initialize Microstepping Pins
+  // Init Digipot Motor Current
+  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+    digipot_init();
+  #endif
+
+  // Init Microstepping Pins
+  #if HAS_MICROSTEPS
+    microstep_init();
+  #endif
 
-  // initialise TMC Steppers
+  // Init TMC Steppers
   #if ENABLED(HAVE_TMCDRIVER)
     tmc_init();
   #endif
-    // initialise L6470 Steppers
+
+  // Init L6470 Steppers
   #if ENABLED(HAVE_L6470DRIVER)
     L6470_init();
   #endif
 
-  // Initialize Dir Pins
+  // Init Dir Pins
   #if HAS_X_DIR
     X_DIR_INIT;
   #endif
@@ -777,8 +809,7 @@ void Stepper::init() {
     E3_DIR_INIT;
   #endif
 
-  //Initialize Enable Pins - steppers default to disabled.
-
+  // Init Enable Pins - steppers default to disabled.
   #if HAS_X_ENABLE
     X_ENABLE_INIT;
     if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
@@ -787,7 +818,6 @@ void Stepper::init() {
       if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
     #endif
   #endif
-
   #if HAS_Y_ENABLE
     Y_ENABLE_INIT;
     if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
@@ -796,7 +826,6 @@ void Stepper::init() {
       if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
     #endif
   #endif
-
   #if HAS_Z_ENABLE
     Z_ENABLE_INIT;
     if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
@@ -805,7 +834,6 @@ void Stepper::init() {
       if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
     #endif
   #endif
-
   #if HAS_E0_ENABLE
     E0_ENABLE_INIT;
     if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
@@ -823,9 +851,7 @@ void Stepper::init() {
     if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
   #endif
 
-  //
-  // Init endstops and pullups here
-  //
+  // Init endstops and pullups
   endstops.init();
 
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
@@ -839,7 +865,7 @@ void Stepper::init() {
 
   #define E_AXIS_INIT(NUM) AXIS_INIT(e## NUM, E## NUM, E)
 
-  // Initialize Step Pins
+  // Init Step Pins
   #if HAS_X_STEP
     #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
       X2_STEP_INIT;
@@ -886,6 +912,7 @@ void Stepper::init() {
   // output mode = 00 (disconnected)
   TCCR1A &= ~(3 << COM1A0);
   TCCR1A &= ~(3 << COM1B0);
+
   // Set the timer pre-scaler
   // Generally we use a divider of 8, resulting in a 2MHz timer
   // frequency on a 16MHz MCU. If you are going to change this, be
@@ -893,6 +920,7 @@ void Stepper::init() {
   // create_speed_lookuptable.py
   TCCR1B = (TCCR1B & ~(0x07 << CS10)) | (2 << CS10);
 
+  // Init Stepper ISR to 122 Hz for quick starting
   OCR1A = 0x4000;
   TCNT1 = 0;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
@@ -935,7 +963,7 @@ void Stepper::synchronize() { while (planner.blocks_queued()) idle(); }
  * This allows get_axis_position_mm to correctly
  * derive the current XYZ position later on.
  */
-void Stepper::set_position(const long& x, const long& y, const long& z, const long& e) {
+void Stepper::set_position(const long &a, const long &b, const long &c, const long &e) {
 
   synchronize(); // Bad to set stepper counts in the middle of a move
 
@@ -944,31 +972,37 @@ void Stepper::set_position(const long& x, const long& y, const long& z, const lo
   #if ENABLED(COREXY)
     // corexy positioning
     // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
-    count_position[A_AXIS] = x + y;
-    count_position[B_AXIS] = x - y;
-    count_position[Z_AXIS] = z;
+    count_position[A_AXIS] = a + b;
+    count_position[B_AXIS] = a - b;
+    count_position[Z_AXIS] = c;
   #elif ENABLED(COREXZ)
     // corexz planning
-    count_position[A_AXIS] = x + z;
-    count_position[Y_AXIS] = y;
-    count_position[C_AXIS] = x - z;
+    count_position[A_AXIS] = a + c;
+    count_position[Y_AXIS] = b;
+    count_position[C_AXIS] = a - c;
   #elif ENABLED(COREYZ)
     // coreyz planning
-    count_position[X_AXIS] = x;
-    count_position[B_AXIS] = y + z;
-    count_position[C_AXIS] = y - z;
+    count_position[X_AXIS] = a;
+    count_position[B_AXIS] = y + c;
+    count_position[C_AXIS] = y - c;
   #else
     // default non-h-bot planning
-    count_position[X_AXIS] = x;
-    count_position[Y_AXIS] = y;
-    count_position[Z_AXIS] = z;
+    count_position[X_AXIS] = a;
+    count_position[Y_AXIS] = b;
+    count_position[Z_AXIS] = c;
   #endif
 
   count_position[E_AXIS] = e;
   CRITICAL_SECTION_END;
 }
 
-void Stepper::set_e_position(const long& e) {
+void Stepper::set_position(const AxisEnum &axis, const long &v) {
+  CRITICAL_SECTION_START;
+  count_position[axis] = v;
+  CRITICAL_SECTION_END;
+}
+
+void Stepper::set_e_position(const long &e) {
   CRITICAL_SECTION_START;
   count_position[E_AXIS] = e;
   CRITICAL_SECTION_END;
@@ -1155,143 +1189,167 @@ void Stepper::report_positions() {
 
   // From Arduino DigitalPotControl example
   void Stepper::digitalPotWrite(int address, int value) {
-    digitalWrite(DIGIPOTSS_PIN, LOW); // take the SS pin low to select the chip
+    WRITE(DIGIPOTSS_PIN, LOW); // take the SS pin low to select the chip
     SPI.transfer(address); //  send in the address and value via SPI:
     SPI.transfer(value);
-    digitalWrite(DIGIPOTSS_PIN, HIGH); // take the SS pin high to de-select the chip:
+    WRITE(DIGIPOTSS_PIN, HIGH); // take the SS pin high to de-select the chip:
     //delay(10);
   }
 
 #endif //HAS_DIGIPOTSS
 
-void Stepper::digipot_init() {
-  #if HAS_DIGIPOTSS
-    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
-
-    SPI.begin();
-    pinMode(DIGIPOTSS_PIN, OUTPUT);
-    for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
-      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
-      digipot_current(i, digipot_motor_current[i]);
-    }
-  #endif
-  #if HAS_MOTOR_CURRENT_PWM
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-      pinMode(MOTOR_CURRENT_PWM_XY_PIN, OUTPUT);
-      digipot_current(0, motor_current_setting[0]);
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-      pinMode(MOTOR_CURRENT_PWM_Z_PIN, OUTPUT);
-      digipot_current(1, motor_current_setting[1]);
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-      pinMode(MOTOR_CURRENT_PWM_E_PIN, OUTPUT);
-      digipot_current(2, motor_current_setting[2]);
-    #endif
-    //Set timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
-    TCCR5B = (TCCR5B & ~(_BV(CS50) | _BV(CS51) | _BV(CS52))) | _BV(CS50);
-  #endif
-}
+#if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
 
-void Stepper::digipot_current(uint8_t driver, int current) {
-  #if HAS_DIGIPOTSS
-    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
-    digitalPotWrite(digipot_ch[driver], current);
-  #elif HAS_MOTOR_CURRENT_PWM
-    #define _WRITE_CURRENT_PWM(P) analogWrite(P, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
-    switch (driver) {
+  void Stepper::digipot_init() {
+    #if HAS_DIGIPOTSS
+      static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
+      SPI.begin();
+      SET_OUTPUT(DIGIPOTSS_PIN);
+      for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
+        //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
+        digipot_current(i, digipot_motor_current[i]);
+      }
+    #elif HAS_MOTOR_CURRENT_PWM
       #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-        case 0: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_XY_PIN); break;
+        SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
+        digipot_current(0, motor_current_setting[0]);
       #endif
       #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-        case 1: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_Z_PIN); break;
+        SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
+        digipot_current(1, motor_current_setting[1]);
       #endif
       #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-        case 2: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_E_PIN); break;
+        SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
+        digipot_current(2, motor_current_setting[2]);
       #endif
-    }
-  #else
-    UNUSED(driver);
-    UNUSED(current);
-  #endif
-}
+      //Set timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
+      TCCR5B = (TCCR5B & ~(_BV(CS50) | _BV(CS51) | _BV(CS52))) | _BV(CS50);
+    #endif
+  }
 
-void Stepper::microstep_init() {
-  #if HAS_MICROSTEPS_E1
-    pinMode(E1_MS1_PIN, OUTPUT);
-    pinMode(E1_MS2_PIN, OUTPUT);
-  #endif
+  void Stepper::digipot_current(uint8_t driver, int current) {
+    #if HAS_DIGIPOTSS
+      const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
+      digitalPotWrite(digipot_ch[driver], current);
+    #elif HAS_MOTOR_CURRENT_PWM
+      #define _WRITE_CURRENT_PWM(P) analogWrite(P, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+      switch (driver) {
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+          case 0: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_XY_PIN); break;
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+          case 1: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_Z_PIN); break;
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+          case 2: _WRITE_CURRENT_PWM(MOTOR_CURRENT_PWM_E_PIN); break;
+        #endif
+      }
+    #endif
+  }
 
-  #if HAS_MICROSTEPS
-    pinMode(X_MS1_PIN, OUTPUT);
-    pinMode(X_MS2_PIN, OUTPUT);
-    pinMode(Y_MS1_PIN, OUTPUT);
-    pinMode(Y_MS2_PIN, OUTPUT);
-    pinMode(Z_MS1_PIN, OUTPUT);
-    pinMode(Z_MS2_PIN, OUTPUT);
-    pinMode(E0_MS1_PIN, OUTPUT);
-    pinMode(E0_MS2_PIN, OUTPUT);
-    const uint8_t microstep_modes[] = MICROSTEP_MODES;
-    for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
-      microstep_mode(i, microstep_modes[i]);
-  #endif
-}
+#endif
 
-/**
- * Software-controlled Microstepping
- */
+#if HAS_MICROSTEPS
+
+  /**
+   * Software-controlled Microstepping
+   */
 
-void Stepper::microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2) {
-  if (ms1 >= 0) switch (driver) {
-    case 0: digitalWrite(X_MS1_PIN, ms1); break;
-    case 1: digitalWrite(Y_MS1_PIN, ms1); break;
-    case 2: digitalWrite(Z_MS1_PIN, ms1); break;
-    case 3: digitalWrite(E0_MS1_PIN, ms1); break;
+  void Stepper::microstep_init() {
+    SET_OUTPUT(X_MS1_PIN);
+    SET_OUTPUT(X_MS2_PIN);
+    #if HAS_MICROSTEPS_Y
+      SET_OUTPUT(Y_MS1_PIN);
+      SET_OUTPUT(Y_MS2_PIN);
+    #endif
+    #if HAS_MICROSTEPS_Z
+      SET_OUTPUT(Z_MS1_PIN);
+      SET_OUTPUT(Z_MS2_PIN);
+    #endif
+    #if HAS_MICROSTEPS_E0
+      SET_OUTPUT(E0_MS1_PIN);
+      SET_OUTPUT(E0_MS2_PIN);
+    #endif
     #if HAS_MICROSTEPS_E1
-      case 4: digitalWrite(E1_MS1_PIN, ms1); break;
+      SET_OUTPUT(E1_MS1_PIN);
+      SET_OUTPUT(E1_MS2_PIN);
     #endif
+    static const uint8_t microstep_modes[] = MICROSTEP_MODES;
+    for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
+      microstep_mode(i, microstep_modes[i]);
   }
-  if (ms2 >= 0) switch (driver) {
-    case 0: digitalWrite(X_MS2_PIN, ms2); break;
-    case 1: digitalWrite(Y_MS2_PIN, ms2); break;
-    case 2: digitalWrite(Z_MS2_PIN, ms2); break;
-    case 3: digitalWrite(E0_MS2_PIN, ms2); break;
-    #if PIN_EXISTS(E1_MS2)
-      case 4: digitalWrite(E1_MS2_PIN, ms2); break;
-    #endif
+
+  void Stepper::microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2) {
+    if (ms1 >= 0) switch (driver) {
+      case 0: digitalWrite(X_MS1_PIN, ms1); break;
+      #if HAS_MICROSTEPS_Y
+        case 1: digitalWrite(Y_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_MICROSTEPS_Z
+        case 2: digitalWrite(Z_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_MICROSTEPS_E0
+        case 3: digitalWrite(E0_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_MICROSTEPS_E1
+        case 4: digitalWrite(E1_MS1_PIN, ms1); break;
+      #endif
+    }
+    if (ms2 >= 0) switch (driver) {
+      case 0: digitalWrite(X_MS2_PIN, ms2); break;
+      #if HAS_MICROSTEPS_Y
+        case 1: digitalWrite(Y_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_MICROSTEPS_Z
+        case 2: digitalWrite(Z_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_MICROSTEPS_E0
+        case 3: digitalWrite(E0_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_MICROSTEPS_E1
+        case 4: digitalWrite(E1_MS2_PIN, ms2); break;
+      #endif
+    }
   }
-}
 
-void Stepper::microstep_mode(uint8_t driver, uint8_t stepping_mode) {
-  switch (stepping_mode) {
-    case 1: microstep_ms(driver, MICROSTEP1); break;
-    case 2: microstep_ms(driver, MICROSTEP2); break;
-    case 4: microstep_ms(driver, MICROSTEP4); break;
-    case 8: microstep_ms(driver, MICROSTEP8); break;
-    case 16: microstep_ms(driver, MICROSTEP16); break;
+  void Stepper::microstep_mode(uint8_t driver, uint8_t stepping_mode) {
+    switch (stepping_mode) {
+      case 1: microstep_ms(driver, MICROSTEP1); break;
+      case 2: microstep_ms(driver, MICROSTEP2); break;
+      case 4: microstep_ms(driver, MICROSTEP4); break;
+      case 8: microstep_ms(driver, MICROSTEP8); break;
+      case 16: microstep_ms(driver, MICROSTEP16); break;
+    }
   }
-}
 
-void Stepper::microstep_readings() {
-  SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
-  SERIAL_PROTOCOLPGM("X: ");
-  SERIAL_PROTOCOL(digitalRead(X_MS1_PIN));
-  SERIAL_PROTOCOLLN(digitalRead(X_MS2_PIN));
-  SERIAL_PROTOCOLPGM("Y: ");
-  SERIAL_PROTOCOL(digitalRead(Y_MS1_PIN));
-  SERIAL_PROTOCOLLN(digitalRead(Y_MS2_PIN));
-  SERIAL_PROTOCOLPGM("Z: ");
-  SERIAL_PROTOCOL(digitalRead(Z_MS1_PIN));
-  SERIAL_PROTOCOLLN(digitalRead(Z_MS2_PIN));
-  SERIAL_PROTOCOLPGM("E0: ");
-  SERIAL_PROTOCOL(digitalRead(E0_MS1_PIN));
-  SERIAL_PROTOCOLLN(digitalRead(E0_MS2_PIN));
-  #if HAS_MICROSTEPS_E1
-    SERIAL_PROTOCOLPGM("E1: ");
-    SERIAL_PROTOCOL(digitalRead(E1_MS1_PIN));
-    SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));
-  #endif
-}
+  void Stepper::microstep_readings() {
+    SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
+    SERIAL_PROTOCOLPGM("X: ");
+    SERIAL_PROTOCOL(READ(X_MS1_PIN));
+    SERIAL_PROTOCOLLN(READ(X_MS2_PIN));
+    #if HAS_MICROSTEPS_Y
+      SERIAL_PROTOCOLPGM("Y: ");
+      SERIAL_PROTOCOL(READ(Y_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(Y_MS2_PIN));
+    #endif
+    #if HAS_MICROSTEPS_Z
+      SERIAL_PROTOCOLPGM("Z: ");
+      SERIAL_PROTOCOL(READ(Z_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(Z_MS2_PIN));
+    #endif
+    #if HAS_MICROSTEPS_E0
+      SERIAL_PROTOCOLPGM("E0: ");
+      SERIAL_PROTOCOL(READ(E0_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E0_MS2_PIN));
+    #endif
+    #if HAS_MICROSTEPS_E1
+      SERIAL_PROTOCOLPGM("E1: ");
+      SERIAL_PROTOCOL(READ(E1_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E1_MS2_PIN));
+    #endif
+  }
+
+#endif // HAS_MICROSTEPS
 
 #if ENABLED(LIN_ADVANCE)
 
diff --git a/Marlin/stepper.h b/Marlin/stepper.h
index 995aaea..a722a50 100644
--- a/Marlin/stepper.h
+++ b/Marlin/stepper.h
@@ -108,7 +108,7 @@ class Stepper {
       static unsigned char old_OCR0A;
       static volatile unsigned char eISR_Rate;
       #if ENABLED(LIN_ADVANCE)
-        static volatile long e_steps[E_STEPPERS];
+        static volatile int e_steps[E_STEPPERS];
         static int extruder_advance_k;
         static int final_estep_rate;
         static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
@@ -188,8 +188,9 @@ class Stepper {
     //
     // Set the current position in steps
     //
-    static void set_position(const long& x, const long& y, const long& z, const long& e);
-    static void set_e_position(const long& e);
+    static void set_position(const long &a, const long &b, const long &c, const long &e);
+    static void set_position(const AxisEnum &a, const long &v);
+    static void set_e_position(const long &e);
 
     //
     // Set direction bits for all steppers
@@ -239,13 +240,16 @@ class Stepper {
     //
     static FORCE_INLINE bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
-    #if HAS_DIGIPOTSS
+    #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(int address, int value);
+      static void digipot_current(uint8_t driver, int current);
+    #endif
+
+    #if HAS_MICROSTEPS
+      static void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);
+      static void microstep_mode(uint8_t driver, uint8_t stepping);
+      static void microstep_readings();
     #endif
-    static void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);
-    static void digipot_current(uint8_t driver, int current);
-    static void microstep_mode(uint8_t driver, uint8_t stepping);
-    static void microstep_readings();
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static FORCE_INLINE void set_homing_flag(bool state) { performing_homing = state; }
@@ -380,7 +384,10 @@ class Stepper {
     }
 
     static void digipot_init();
-    static void microstep_init();
+
+    #if HAS_MICROSTEPS
+      static void microstep_init();
+    #endif
 
 };
 
diff --git a/Marlin/stepper_dac.cpp b/Marlin/stepper_dac.cpp
index 6c71b89..efdea60 100644
--- a/Marlin/stepper_dac.cpp
+++ b/Marlin/stepper_dac.cpp
@@ -49,11 +49,11 @@
 
   bool dac_present = false;
   const uint8_t dac_order[NUM_AXIS] = DAC_STEPPER_ORDER;
+  uint16_t dac_channel_pct[XYZE];
 
   int dac_init() {
     #if PIN_EXISTS(DAC_DISABLE)
-      pinMode(DAC_DISABLE_PIN, OUTPUT);
-      digitalWrite(DAC_DISABLE_PIN, LOW);  // set pin low to enable DAC
+      OUT_WRITE(DAC_DISABLE_PIN, LOW);  // set pin low to enable DAC
     #endif
 
     mcp4728_init();
@@ -73,7 +73,7 @@
 
     NOMORE(val, 100);
 
-    mcp4728_analogWrite(dac_order[channel], val * DAC_STEPPER_MAX / 100);
+    mcp4728_analogWrite(dac_order[channel], val * 0.01 * (DAC_STEPPER_MAX));
     mcp4728_simpleCommand(UPDATE);
   }
 
@@ -86,8 +86,14 @@
     mcp4728_simpleCommand(UPDATE);
   }
 
-  static float dac_perc(int8_t n) { return 100.0 * mcp4728_getValue(dac_order[n]) / DAC_STEPPER_MAX; }
-  static float dac_amps(int8_t n) { return ((2.048 * mcp4728_getValue(dac_order[n])) / 4096.0) / (8.0 * DAC_STEPPER_SENSE); }
+  static float dac_perc(int8_t n) { return 100.0 * mcp4728_getValue(dac_order[n]) * (1.0 / (DAC_STEPPER_MAX)); }
+  static float dac_amps(int8_t n) { return mcp4728_getDrvPct(dac_order[n]) * (DAC_STEPPER_MAX) * 0.125 * (1.0 / (DAC_STEPPER_SENSE)); }
+  
+  int16_t dac_current_get_percent(AxisEnum axis) { return mcp4728_getDrvPct(dac_order[axis]); }
+  void dac_current_set_percents(int16_t pct[XYZE]) {
+    LOOP_XYZE(i) dac_channel_pct[i] = pct[dac_order[i]];
+    mcp4728_setDrvPct(dac_channel_pct);
+  }
 
   void dac_print_values() {
     if (!dac_present) return;
@@ -95,15 +101,15 @@
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Stepper current values in % (Amps):");
     SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR(" X:",  dac_perc(0));
-    SERIAL_ECHOPAIR(" (",   dac_amps(0));
-    SERIAL_ECHOPAIR(") Y:", dac_perc(1));
-    SERIAL_ECHOPAIR(" (",   dac_amps(1));
-    SERIAL_ECHOPAIR(") Z:", dac_perc(2));
-    SERIAL_ECHOPAIR(" (",   dac_amps(2));
-    SERIAL_ECHOPAIR(") E:", dac_perc(3));
-    SERIAL_ECHOPAIR(" (",   dac_amps(3));
-    SERIAL_ECHOLNPGM(")");
+    SERIAL_ECHOPAIR(" X:",  dac_perc(X_AXIS)); 
+    SERIAL_ECHOPAIR(" (",   dac_amps(X_AXIS));
+    SERIAL_ECHOPAIR(") Y:", dac_perc(Y_AXIS));
+    SERIAL_ECHOPAIR(" (",   dac_amps(Y_AXIS));
+    SERIAL_ECHOPAIR(") Z:", dac_perc(Z_AXIS));
+    SERIAL_ECHOPAIR(" (",   dac_amps(Z_AXIS));
+    SERIAL_ECHOPAIR(") E:", dac_perc(E_AXIS));
+    SERIAL_ECHOPAIR(" (",   dac_amps(E_AXIS));
+    SERIAL_ECHOLN(")");
   }
 
   void dac_commit_eeprom() {
diff --git a/Marlin/stepper_dac.h b/Marlin/stepper_dac.h
index d80a846..ab338a2 100644
--- a/Marlin/stepper_dac.h
+++ b/Marlin/stepper_dac.h
@@ -51,5 +51,7 @@ void dac_current_percent(uint8_t channel, float val);
 void dac_current_raw(uint8_t channel, uint16_t val);
 void dac_print_values();
 void dac_commit_eeprom();
+int16_t dac_current_get_percent(AxisEnum axis);
+void dac_current_set_percents(int16_t pct[XYZE]);
 
 #endif // STEPPER_DAC_H
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index ba9d970..b1f97eb 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -136,9 +136,7 @@ volatile bool Temperature::temp_meas_ready = false;
     int Temperature::lpq_ptr = 0;
   #endif
 
-  float Temperature::pid_error[HOTENDS],
-        Temperature::temp_iState_min[HOTENDS],
-        Temperature::temp_iState_max[HOTENDS];
+  float Temperature::pid_error[HOTENDS];
   bool Temperature::pid_reset[HOTENDS];
 #endif
 
@@ -148,14 +146,12 @@ volatile bool Temperature::temp_meas_ready = false;
         Temperature::pTerm_bed,
         Temperature::iTerm_bed,
         Temperature::dTerm_bed,
-        Temperature::pid_error_bed,
-        Temperature::temp_iState_min_bed,
-        Temperature::temp_iState_max_bed;
+        Temperature::pid_error_bed;
 #else
   millis_t Temperature::next_bed_check_ms;
 #endif
 
-unsigned long Temperature::raw_temp_value[4] = { 0 };
+unsigned long Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 };
 unsigned long Temperature::raw_temp_bed_value = 0;
 
 // Init min and max temp with extreme values to prevent false errors during startup
@@ -240,13 +236,13 @@ uint8_t Temperature::soft_pwm[HOTENDS];
 
     #if HAS_PID_FOR_BOTH
       if (hotend < 0)
-        soft_pwm_bed = bias = d = (MAX_BED_POWER) / 2;
+        soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
       else
-        soft_pwm[hotend] = bias = d = (PID_MAX) / 2;
+        soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;
     #elif ENABLED(PIDTEMP)
-      soft_pwm[hotend] = bias = d = (PID_MAX) / 2;
+      soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;
     #else
-      soft_pwm_bed = bias = d = (MAX_BED_POWER) / 2;
+      soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
     #endif
 
     wait_for_heatup = true;
@@ -269,8 +265,8 @@ uint8_t Temperature::soft_pwm[HOTENDS];
           #endif
         ;
 
-        max = max(max, input);
-        min = min(min, input);
+        NOLESS(max, input);
+        NOMORE(min, input);
 
         #if HAS_AUTO_FAN
           if (ELAPSED(ms, next_auto_fan_check_ms)) {
@@ -448,12 +444,6 @@ void Temperature::updatePID() {
     #if ENABLED(PID_EXTRUSION_SCALING)
       last_e_position = 0;
     #endif
-    HOTEND_LOOP() {
-      temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
-    }
-  #endif
-  #if ENABLED(PIDTEMPBED)
-    temp_iState_max_bed = (PID_BED_INTEGRAL_DRIVE_MAX) / bedKi;
   #endif
 }
 
@@ -464,7 +454,7 @@ int Temperature::getHeaterPower(int heater) {
 #if HAS_AUTO_FAN
 
   void Temperature::checkExtruderAutoFans() {
-    const int8_t fanPin[] = { EXTRUDER_0_AUTO_FAN_PIN, EXTRUDER_1_AUTO_FAN_PIN, EXTRUDER_2_AUTO_FAN_PIN, EXTRUDER_3_AUTO_FAN_PIN };
+    const int8_t fanPin[] = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN };
     const int fanBit[] = {
                     0,
       AUTO_1_IS_0 ? 0 :               1,
@@ -564,7 +554,6 @@ float Temperature::get_pid_output(int e) {
         }
         pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
         temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
-        temp_iState[HOTEND_INDEX] = constrain(temp_iState[HOTEND_INDEX], temp_iState_min[HOTEND_INDEX], temp_iState_max[HOTEND_INDEX]);
         iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
 
         pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
@@ -627,7 +616,6 @@ float Temperature::get_pid_output(int e) {
       pid_error_bed = target_temperature_bed - current_temperature_bed;
       pTerm_bed = bedKp * pid_error_bed;
       temp_iState_bed += pid_error_bed;
-      temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
       iTerm_bed = bedKi * temp_iState_bed;
 
       dTerm_bed = K2 * bedKd * (current_temperature_bed - temp_dState_bed) + K1 * dTerm_bed;
@@ -681,8 +669,8 @@ void Temperature::manage_heater() {
   updateTemperaturesFromRawValues(); // also resets the watchdog
 
   #if ENABLED(HEATER_0_USES_MAX6675)
-    if (current_temperature[0] > min(HEATER_0_MAXTEMP, 1023)) max_temp_error(0);
-    if (current_temperature[0] < max(HEATER_0_MINTEMP, 0.01)) min_temp_error(0);
+    if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1)) max_temp_error(0);
+    if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + 0.01)) min_temp_error(0);
   #endif
 
   #if (ENABLED(THERMAL_PROTECTION_HOTENDS) && WATCH_TEMP_PERIOD > 0) || (ENABLED(THERMAL_PROTECTION_BED) && WATCH_BED_TEMP_PERIOD > 0) || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN
@@ -955,16 +943,10 @@ void Temperature::init() {
     // populate with the first value
     maxttemp[e] = maxttemp[0];
     #if ENABLED(PIDTEMP)
-      temp_iState_min[e] = 0.0;
-      temp_iState_max[e] = (PID_INTEGRAL_DRIVE_MAX) / PID_PARAM(Ki, e);
       #if ENABLED(PID_EXTRUSION_SCALING)
         last_e_position = 0;
       #endif
     #endif //PIDTEMP
-    #if ENABLED(PIDTEMPBED)
-      temp_iState_min_bed = 0.0;
-      temp_iState_max_bed = (PID_BED_INTEGRAL_DRIVE_MAX) / bedKi;
-    #endif //PIDTEMPBED
   }
 
   #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)
@@ -993,7 +975,7 @@ void Temperature::init() {
       setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
     #if ENABLED(FAN_SOFT_PWM)
-      soft_pwm_fan[0] = fanSpeedSoftPwm[0] / 2;
+      soft_pwm_fan[0] = fanSpeedSoftPwm[0] >> 1;
     #endif
   #endif
 
@@ -1003,7 +985,7 @@ void Temperature::init() {
       setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
     #if ENABLED(FAN_SOFT_PWM)
-      soft_pwm_fan[1] = fanSpeedSoftPwm[1] / 2;
+      soft_pwm_fan[1] = fanSpeedSoftPwm[1] >> 1;
     #endif
   #endif
 
@@ -1013,20 +995,17 @@ void Temperature::init() {
       setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
     #endif
     #if ENABLED(FAN_SOFT_PWM)
-      soft_pwm_fan[2] = fanSpeedSoftPwm[2] / 2;
+      soft_pwm_fan[2] = fanSpeedSoftPwm[2] >> 1;
     #endif
   #endif
 
   #if ENABLED(HEATER_0_USES_MAX6675)
 
-    #if DISABLED(SDSUPPORT)
-      OUT_WRITE(SCK_PIN, LOW);
-      OUT_WRITE(MOSI_PIN, HIGH);
-      SET_INPUT(MISO_PIN);
-      WRITE(MISO_PIN,1);
-    #else
-      OUT_WRITE(SS_PIN, HIGH);
-    #endif
+    OUT_WRITE(SCK_PIN, LOW);
+    OUT_WRITE(MOSI_PIN, HIGH);
+    SET_INPUT(MISO_PIN);
+    WRITE(MISO_PIN, HIGH);
+    OUT_WRITE(SS_PIN, HIGH);
 
     OUT_WRITE(MAX6675_SS, HIGH);
 
@@ -1064,43 +1043,43 @@ void Temperature::init() {
   #endif
 
   #if HAS_AUTO_FAN_0
-    #if EXTRUDER_0_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(EXTRUDER_0_AUTO_FAN_PIN);
+    #if E0_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E0_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(EXTRUDER_0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
-      pinMode(EXTRUDER_0_AUTO_FAN_PIN, OUTPUT);
+      SET_OUTPUT(E0_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
-    #if EXTRUDER_1_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(EXTRUDER_1_AUTO_FAN_PIN);
+    #if E1_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E1_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(EXTRUDER_1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
-      pinMode(EXTRUDER_1_AUTO_FAN_PIN, OUTPUT);
+      SET_OUTPUT(E1_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
-    #if EXTRUDER_2_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(EXTRUDER_2_AUTO_FAN_PIN);
+    #if E2_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E2_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(EXTRUDER_2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
-      pinMode(EXTRUDER_2_AUTO_FAN_PIN, OUTPUT);
+      SET_OUTPUT(E2_AUTO_FAN_PIN);
     #endif
   #endif
   #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
-    #if EXTRUDER_3_AUTO_FAN_PIN == FAN1_PIN
-      SET_OUTPUT(EXTRUDER_3_AUTO_FAN_PIN);
+    #if E3_AUTO_FAN_PIN == FAN1_PIN
+      SET_OUTPUT(E3_AUTO_FAN_PIN);
       #if ENABLED(FAST_PWM_FAN)
-        setPwmFrequency(EXTRUDER_3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
+        setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
       #endif
     #else
-      pinMode(EXTRUDER_3_AUTO_FAN_PIN, OUTPUT);
+      SET_OUTPUT(E3_AUTO_FAN_PIN);
     #endif
   #endif
 
@@ -1259,12 +1238,12 @@ void Temperature::init() {
         *state = TRStable;
       // While the temperature is stable watch for a bad temperature
       case TRStable:
-        if (temperature < tr_target_temperature[heater_index] - hysteresis_degc && ELAPSED(millis(), *timer))
-          *state = TRRunaway;
-        else {
+        if (temperature >= tr_target_temperature[heater_index] - hysteresis_degc) {
           *timer = millis() + period_seconds * 1000UL;
           break;
         }
+        else if (PENDING(millis(), *timer)) break;
+        *state = TRRunaway;
       case TRRunaway:
         _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
     }
@@ -1362,10 +1341,28 @@ void Temperature::disable_all_heaters() {
 
     WRITE(MAX6675_SS, 1); // disable TT_MAX6675
 
-    if (max6675_temp & MAX6675_ERROR_MASK)
-      max6675_temp = 4000; // thermocouple open
+    if (max6675_temp & MAX6675_ERROR_MASK) {
+      SERIAL_ERROR_START;
+      SERIAL_ERRORPGM("Temp measurement error! ");
+      #if MAX6675_ERROR_MASK == 7
+        SERIAL_ERRORPGM("MAX31855 ");
+        if (max6675_temp & 1)
+          SERIAL_ERRORLNPGM("Open Circuit");
+        else if (max6675_temp & 2)
+          SERIAL_ERRORLNPGM("Short to GND");
+        else if (max6675_temp & 4)
+          SERIAL_ERRORLNPGM("Short to VCC");
+      #else
+        SERIAL_ERRORLNPGM("MAX6675");
+      #endif
+      max6675_temp = MAX6675_TMAX * 4; // thermocouple open
+    }
     else
       max6675_temp >>= MAX6675_DISCARD_BITS;
+      #if ENABLED(MAX6675_IS_MAX31855)
+        // Support negative temperature
+        if (max6675_temp & 0x00002000) max6675_temp |= 0xffffc000;
+      #endif
 
     return (int)max6675_temp;
   }
@@ -1400,7 +1397,7 @@ void Temperature::set_current_temp_raw() {
  * Timer 0 is shared with millies so don't change the prescaler.
  *
  * This ISR uses the compare method so it runs at the base
- * frequency (16 MHz / 256 = 62500 Hz), but at the TCNT0 set
+ * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
  * in OCR0B above (128 or halfway between OVFs).
  *
  *  - Manage PWM to all the heaters and fan
@@ -1473,15 +1470,15 @@ void Temperature::isr() {
 
       #if ENABLED(FAN_SOFT_PWM)
         #if HAS_FAN0
-          soft_pwm_fan[0] = fanSpeedSoftPwm[0] / 2;
+          soft_pwm_fan[0] = fanSpeedSoftPwm[0] >> 1;
           WRITE_FAN(soft_pwm_fan[0] > 0 ? 1 : 0);
         #endif
         #if HAS_FAN1
-          soft_pwm_fan[1] = fanSpeedSoftPwm[1] / 2;
+          soft_pwm_fan[1] = fanSpeedSoftPwm[1] >> 1;
           WRITE_FAN1(soft_pwm_fan[1] > 0 ? 1 : 0);
         #endif
         #if HAS_FAN2
-          soft_pwm_fan[2] = fanSpeedSoftPwm[2] / 2;
+          soft_pwm_fan[2] = fanSpeedSoftPwm[2] >> 1;
           WRITE_FAN2(soft_pwm_fan[2] > 0 ? 1 : 0);
         #endif
       #endif
@@ -1514,9 +1511,16 @@ void Temperature::isr() {
       #endif
     #endif
 
-    // 488.28 Hz (or 1:976.56, 2:1953.12, 3:3906.25, 4:7812.5, 5:7812.5 6:15625, 6:15625 7:31250)
+    // SOFT_PWM_SCALE to frequency:
+    //
+    // 0: 16000000/64/256/128 =   7.6294 Hz
+    // 1:                / 64 =  15.2588 Hz
+    // 2:                / 32 =  30.5176 Hz
+    // 3:                / 16 =  61.0352 Hz
+    // 4:                /  8 = 122.0703 Hz
+    // 5:                /  4 = 244.1406 Hz
     pwm_count += _BV(SOFT_PWM_SCALE);
-    pwm_count &= 0x7f;
+    pwm_count &= 0x7F;
 
   #else // SLOW_PWM_HEATERS
 
@@ -1592,15 +1596,15 @@ void Temperature::isr() {
     #if ENABLED(FAN_SOFT_PWM)
       if (pwm_count == 0) {
         #if HAS_FAN0
-          soft_pwm_fan[0] = fanSpeedSoftPwm[0] / 2;
+          soft_pwm_fan[0] = fanSpeedSoftPwm[0] >> 1;
           WRITE_FAN(soft_pwm_fan[0] > 0 ? 1 : 0);
         #endif
         #if HAS_FAN1
-          soft_pwm_fan[1] = fanSpeedSoftPwm[1] / 2;
+          soft_pwm_fan[1] = fanSpeedSoftPwm[1] >> 1;
           WRITE_FAN1(soft_pwm_fan[1] > 0 ? 1 : 0);
         #endif
         #if HAS_FAN2
-          soft_pwm_fan[2] = fanSpeedSoftPwm[2] / 2;
+          soft_pwm_fan[2] = fanSpeedSoftPwm[2] >> 1;
           WRITE_FAN2(soft_pwm_fan[2] > 0 ? 1 : 0);
         #endif
       }
@@ -1615,10 +1619,18 @@ void Temperature::isr() {
       #endif
     #endif //FAN_SOFT_PWM
 
+    // SOFT_PWM_SCALE to frequency:
+    //
+    // 0: 16000000/64/256/128 =   7.6294 Hz
+    // 1:                / 64 =  15.2588 Hz
+    // 2:                / 32 =  30.5176 Hz
+    // 3:                / 16 =  61.0352 Hz
+    // 4:                /  8 = 122.0703 Hz
+    // 5:                /  4 = 244.1406 Hz
     pwm_count += _BV(SOFT_PWM_SCALE);
-    pwm_count &= 0x7f;
+    pwm_count &= 0x7F;
 
-    // increment slow_pwm_count only every 64 pwm_count circa 65.5ms
+    // increment slow_pwm_count only every 64 pwm_count (e.g., every 8s)
     if ((pwm_count % 64) == 0) {
       slow_pwm_count++;
       slow_pwm_count &= 0x7f;
@@ -1750,6 +1762,9 @@ void Temperature::isr() {
   } // switch(temp_state)
 
   if (temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
+
+    temp_count = 0;
+
     // Update the raw values if they've been read. Else we could be updating them during reading.
     if (!temp_meas_ready) set_current_temp_raw();
 
@@ -1758,85 +1773,54 @@ void Temperature::isr() {
       current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
     #endif
 
-    temp_count = 0;
-    for (int i = 0; i < 4; i++) raw_temp_value[i] = 0;
+    ZERO(raw_temp_value);
     raw_temp_bed_value = 0;
 
-    #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
-      #if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
-        #define GE0 <=
+    int constexpr temp_dir[] = {
+      #if ENABLED(HEATER_0_USES_MAX6675)
+         0
+      #elif HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
+        -1
       #else
-        #define GE0 >=
+         1
       #endif
-      if (current_temperature_raw[0] GE0 maxttemp_raw[0]) max_temp_error(0);
-      if (minttemp_raw[0] GE0 current_temperature_raw[0] && !is_preheating(0) && target_temperature[0] > 0.0f) {
-        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[0] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+      #if HAS_TEMP_1 && HOTENDS > 1
+        #if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
+          , -1
+        #else
+          ,  1
         #endif
-            min_temp_error(0);
-      }
-      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        else
-          consecutive_low_temperature_error[0] = 0;
       #endif
-    #endif
-
-    #if HAS_TEMP_1 && HOTENDS > 1
-      #if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
-        #define GE1 <=
-      #else
-        #define GE1 >=
-      #endif
-      if (current_temperature_raw[1] GE1 maxttemp_raw[1]) max_temp_error(1);
-      if (minttemp_raw[1] GE1 current_temperature_raw[1] && !is_preheating(1) && target_temperature[1] > 0.0f) {
-        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[1] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+      #if HAS_TEMP_2 && HOTENDS > 2
+        #if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
+          , -1
+        #else
+          ,  1
         #endif
-          min_temp_error(1);
-      }
-      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        else
-          consecutive_low_temperature_error[1] = 0;
       #endif
-    #endif // TEMP_SENSOR_1
-
-    #if HAS_TEMP_2 && HOTENDS > 2
-      #if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
-        #define GE2 <=
-      #else
-        #define GE2 >=
-      #endif
-      if (current_temperature_raw[2] GE2 maxttemp_raw[2]) max_temp_error(2);
-      if (minttemp_raw[2] GE2 current_temperature_raw[2] && !is_preheating(2) && target_temperature[2] > 0.0f) {
-        #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[2] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+      #if HAS_TEMP_3 && HOTENDS > 3
+        #if HEATER_3_RAW_LO_TEMP > HEATER_3_RAW_HI_TEMP
+          , -1
+        #else
+          ,  1
         #endif
-          min_temp_error(2);
-      }
-      #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-        else
-          consecutive_low_temperature_error[2] = 0;
       #endif
-    #endif // TEMP_SENSOR_2
+    };
 
-    #if HAS_TEMP_3 && HOTENDS > 3
-      #if HEATER_3_RAW_LO_TEMP > HEATER_3_RAW_HI_TEMP
-        #define GE3 <=
-      #else
-        #define GE3 >=
-      #endif
-      if (current_temperature_raw[3] GE3 maxttemp_raw[3]) max_temp_error(3);
-      if (minttemp_raw[3] GE3 current_temperature_raw[3] && !is_preheating(3) && target_temperature[3] > 0.0f) {
+    for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
+      const int tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
+      if (rawtemp > maxttemp_raw[e] * tdir && target_temperature[e] > 0.0f) max_temp_error(e);
+      if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && target_temperature[e] > 0.0f) {
         #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-          if (++consecutive_low_temperature_error[3] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
+          if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
         #endif
-          min_temp_error(3);
+            min_temp_error(e);
       }
       #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
         else
-          consecutive_low_temperature_error[3] = 0;
+          consecutive_low_temperature_error[e] = 0;
       #endif
-    #endif // TEMP_SENSOR_3
+    }
 
     #if HAS_TEMP_BED
       #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
@@ -1844,7 +1828,7 @@ void Temperature::isr() {
       #else
         #define GEBED >=
       #endif
-      if (current_temperature_bed_raw GEBED bed_maxttemp_raw) max_temp_error(-1);
+      if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0.0f) max_temp_error(-1);
       if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0.0f) min_temp_error(-1);
     #endif
 
diff --git a/Marlin/temperature.h b/Marlin/temperature.h
index 72f55b3..072364e 100644
--- a/Marlin/temperature.h
+++ b/Marlin/temperature.h
@@ -157,9 +157,7 @@ class Temperature {
         static int lpq_ptr;
       #endif
 
-      static float pid_error[HOTENDS],
-                   temp_iState_min[HOTENDS],
-                   temp_iState_max[HOTENDS];
+      static float pid_error[HOTENDS];
       static bool pid_reset[HOTENDS];
     #endif
 
@@ -169,9 +167,7 @@ class Temperature {
                    pTerm_bed,
                    iTerm_bed,
                    dTerm_bed,
-                   pid_error_bed,
-                   temp_iState_min_bed,
-                   temp_iState_max_bed;
+                   pid_error_bed;
     #else
       static millis_t next_bed_check_ms;
     #endif
@@ -376,15 +372,15 @@ class Temperature {
      */
     static void updatePID();
 
-    static void autotempShutdown() {
-      #if ENABLED(AUTOTEMP)
+    #if ENABLED(AUTOTEMP)
+      static void autotempShutdown() {
         if (planner.autotemp_enabled) {
           planner.autotemp_enabled = false;
           if (degTargetHotend(EXTRUDER_IDX) > planner.autotemp_min)
             setTargetHotend(0, EXTRUDER_IDX);
         }
-      #endif
-    }
+      }
+    #endif
 
     #if ENABLED(BABYSTEPPING)
 
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index d327103..8be85aa 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -30,6 +30,10 @@
 #include "configuration_store.h"
 #include "utility.h"
 
+#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #include "buzzer.h"
+#endif
+
 #if ENABLED(BLTOUCH)
   #include "endstops.h"
 #endif
@@ -39,8 +43,7 @@
   #include "duration_t.h"
 #endif
 
-int preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1,
-    preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2;
+int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   millis_t previous_lcd_status_ms = 0;
@@ -62,6 +65,11 @@ millis_t next_lcd_update_ms;
 
 uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
 
+#if ENABLED(DAC_STEPPER_CURRENT)
+  #include "stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
+  uint16_t driverPercent[XYZE];
+#endif
+
 #if ENABLED(ULTIPANEL)
 
   // place-holders for Ki and Kd edits
@@ -114,6 +122,13 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   static void lcd_control_motion_menu();
   static void lcd_control_volumetric_menu();
 
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    static void dac_driver_commit();
+    static void dac_driver_getValues();
+    static void lcd_dac_menu();
+    static void lcd_dac_write_eeprom();
+  #endif
+
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       static void lcd_info_stats_menu();
@@ -153,7 +168,8 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   typedef void (*screenFunc_t)();
 
   // Different types of actions that can be used in menu items.
-  static void menu_action_back();
+  #define menu_action_back(dummy) _menu_action_back()
+  static void _menu_action_back();
   static void menu_action_submenu(screenFunc_t data);
   static void menu_action_gcode(const char* pgcode);
   static void menu_action_function(screenFunc_t data);
@@ -211,7 +227,7 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
     static int8_t _countedItems = 0; \
     int8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
     if (_countedItems > 0 && encoderLine >= _countedItems - LIMIT) { \
-      encoderLine = _countedItems - LIMIT; \
+      encoderLine = max(0, _countedItems - LIMIT); \
       encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
     }
 
@@ -226,7 +242,6 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
    *
    * START_MENU    Opening code for a screen with menu items.
    *               Scroll as-needed to keep the selected line in view.
-   *               'wasClicked' indicates the controller was clicked.
    */
   #define START_SCREEN() \
     START_SCREEN_OR_MENU(LCD_HEIGHT); \
@@ -240,7 +255,6 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
     if (encoderLine >= encoderTopLine + LCD_HEIGHT) { \
       encoderTopLine = encoderLine - (LCD_HEIGHT - 1); \
     } \
-    bool wasClicked = LCD_CLICKED; \
     bool _skipStatic = true; \
     SCREEN_OR_MENU_LOOP()
 
@@ -251,7 +265,9 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
    *   menu_action_[type](arg3...)
    *
    * Examples:
-   *   MENU_ITEM(back, MSG_WATCH)
+   *   MENU_ITEM(back, MSG_WATCH, 0 [dummy parameter] )
+   *   or
+   *   MENU_BACK(MSG_WATCH)
    *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH))
    *     menu_action_back()
    *
@@ -265,35 +281,36 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
    *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *
    */
-  #define _MENU_ITEM_PART_1(TYPE, LABEL, ARGS...) \
+  #define _MENU_ITEM_PART_1(TYPE, LABEL, ...) \
     if (_menuLineNr == _thisItemNr) { \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## ARGS); \
-      if (wasClicked && encoderLine == _thisItemNr) { \
-        lcd_quick_feedback()
+        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
+      if (lcd_clicked && encoderLine == _thisItemNr) {
 
-  #define _MENU_ITEM_PART_2(TYPE, ARGS...) \
-        menu_action_ ## TYPE(ARGS); \
+  #define _MENU_ITEM_PART_2(TYPE, ...) \
+        menu_action_ ## TYPE(__VA_ARGS__); \
         return; \
       } \
     } \
     ++_thisItemNr
 
-  #define MENU_ITEM(TYPE, LABEL, ARGS...) do { \
+  #define MENU_ITEM(TYPE, LABEL, ...) do { \
       _skipStatic = false; \
-      _MENU_ITEM_PART_1(TYPE, LABEL, ## ARGS); \
-      _MENU_ITEM_PART_2(TYPE, ## ARGS); \
+      _MENU_ITEM_PART_1(TYPE, LABEL, ## __VA_ARGS__); \
+      _MENU_ITEM_PART_2(TYPE, ## __VA_ARGS__); \
     } while(0)
 
+  #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
+
   // Used to print static text with no visible cursor.
-  #define STATIC_ITEM(LABEL, ARGS...) \
+  #define STATIC_ITEM(LABEL, ...) \
     if (_menuLineNr == _thisItemNr) { \
       if (_skipStatic && encoderLine <= _thisItemNr) { \
         encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
       } \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## ARGS); \
+        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
     } \
     ++_thisItemNr
 
@@ -313,24 +330,24 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
     /**
      * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item
      */
-    #define MENU_MULTIPLIER_ITEM(type, label, args...) do { \
-        _MENU_ITEM_PART_1(type, label, ## args); \
+    #define MENU_MULTIPLIER_ITEM(type, label, ...) do { \
+        _MENU_ITEM_PART_1(type, label, ## __VA_ARGS__); \
         encoderRateMultiplierEnabled = true; \
         lastEncoderMovementMillis = 0; \
-        _MENU_ITEM_PART_2(type, ## args); \
+        _MENU_ITEM_PART_2(type, ## __VA_ARGS__); \
       } while(0)
 
   #endif //ENCODER_RATE_MULTIPLIER
 
   #define MENU_ITEM_DUMMY() do { _thisItemNr++; } while(0)
-  #define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)
-  #define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)
+  #define MENU_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)
+    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
   #else //!ENCODER_RATE_MULTIPLIER
-    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)
+    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
   #endif //!ENCODER_RATE_MULTIPLIER
 
   /** Used variables to keep track of the menu */
@@ -360,9 +377,8 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   menuPosition screen_history[10];
   uint8_t screen_history_depth = 0;
 
-  bool ignore_click = false;
-  bool wait_for_unclick;
-  bool defer_return_to_status = false;
+  // LCD and menu clicks
+  bool lcd_clicked, wait_for_unclick, defer_return_to_status;
 
   // Variables used when editing values.
   const char* editLabel;
@@ -371,9 +387,9 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
   screenFunc_t callbackFunc;              // call this after editing
 
   /**
-   * General function to go directly to a menu
+   * General function to go directly to a screen
    */
-  static void lcd_goto_screen(screenFunc_t screen, const bool feedback = false, const uint32_t encoder = 0) {
+  static void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder = 0) {
     if (currentScreen != screen) {
       currentScreen = screen;
       encoderPosition = encoder;
@@ -381,7 +397,6 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
         defer_return_to_status = false;
         screen_history_depth = 0;
       }
-      if (feedback) lcd_quick_feedback();
       lcd_implementation_clear();
       #if ENABLED(LCD_PROGRESS_BAR)
         // For LCD_PROGRESS_BAR re-initialize custom characters
@@ -406,7 +421,6 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       --screen_history_depth;
       lcd_goto_screen(
         screen_history[screen_history_depth].menu_function,
-        feedback,
         screen_history[screen_history_depth].encoder_position
       );
     }
@@ -414,11 +428,6 @@ uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to
       lcd_return_to_status();
   }
 
-  void lcd_ignore_click(bool b) {
-    ignore_click = b;
-    wait_for_unclick = false;
-  }
-
 #endif // ULTIPANEL
 
 /**
@@ -472,23 +481,7 @@ static void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
 
-    bool current_click = LCD_CLICKED;
-
-    if (ignore_click) {
-      if (wait_for_unclick) {
-        if (!current_click)
-          ignore_click = wait_for_unclick = false;
-        else
-          current_click = false;
-      }
-      else if (current_click) {
-        lcd_quick_feedback();
-        wait_for_unclick = true;
-        current_click = false;
-      }
-    }
-
-    if (current_click) {
+    if (lcd_clicked) {
       #if ENABLED(FILAMENT_LCD_DISPLAY)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
@@ -497,7 +490,7 @@ static void lcd_status_screen() {
           false
         #endif
       );
-      lcd_goto_screen(lcd_main_menu, true);
+      lcd_goto_screen(lcd_main_menu);
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
@@ -549,12 +542,7 @@ void kill_screen(const char* lcd_msg) {
 #if ENABLED(ULTIPANEL)
 
   inline void line_to_current(AxisEnum axis) {
-    #if ENABLED(DELTA)
-      inverse_kinematics(current_position);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[axis]), active_extruder);
-    #else // !DELTA
-      planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[axis]), active_extruder);
-    #endif // !DELTA
+    planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[axis]), active_extruder);
   }
 
   #if ENABLED(SDSUPPORT)
@@ -574,7 +562,9 @@ void kill_screen(const char* lcd_msg) {
       clear_command_queue();
       quickstop_stepper();
       print_job_timer.stop();
-      thermalManager.autotempShutdown();
+      #if ENABLED(AUTOTEMP)
+        thermalManager.autotempShutdown();
+      #endif
       wait_for_heatup = false;
       lcd_setstatus(MSG_PRINT_ABORTED, true);
     }
@@ -589,7 +579,7 @@ void kill_screen(const char* lcd_msg) {
 
   static void lcd_main_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_WATCH);
+    MENU_BACK(MSG_WATCH);
 
     #if ENABLED(BLTOUCH)
       if (!endstops.z_probe_enabled && TEST_BLTOUCH())
@@ -658,7 +648,7 @@ void kill_screen(const char* lcd_msg) {
     long babysteps_done = 0;
 
     static void _lcd_babystep(const AxisEnum axis, const char* msg) {
-      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+      if (lcd_clicked) { defer_return_to_status = false; return lcd_goto_previous_menu(true); }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         int babystep_increment = (int32_t)encoderPosition * BABYSTEP_MULTIPLICATOR;
@@ -676,11 +666,11 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(BABYSTEP_XY)
       static void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
       static void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
-      static void lcd_babystep_x() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_x); }
-      static void lcd_babystep_y() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_y); }
+      static void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
+      static void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
     static void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }
-    static void lcd_babystep_z() { babysteps_done = 0; lcd_goto_screen(_lcd_babystep_z); }
+    static void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
   #endif //BABYSTEPPING
 
@@ -736,7 +726,7 @@ void kill_screen(const char* lcd_msg) {
     //
     // ^ Main
     //
-    MENU_ITEM(back, MSG_MAIN);
+    MENU_BACK(MSG_MAIN);
 
     //
     // Speed:
@@ -848,6 +838,31 @@ void kill_screen(const char* lcd_msg) {
 
   /**
    *
+   * "Driver current control" submenu items
+   *
+   */
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    static void dac_driver_getValues() { LOOP_XYZE(i) driverPercent[i] = dac_current_get_percent((AxisEnum)i); }
+
+    static void dac_driver_commit() { dac_current_set_percents(driverPercent); }
+
+    static void dac_driver_eeprom_write() { dac_commit_eeprom(); }
+
+    static void lcd_dac_menu() {
+      dac_driver_getValues();
+      START_MENU();    
+      MENU_BACK(MSG_CONTROL);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_X " " MSG_DAC_PERCENT, &driverPercent[X_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_Y " " MSG_DAC_PERCENT, &driverPercent[Y_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_Z " " MSG_DAC_PERCENT, &driverPercent[Z_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_E " " MSG_DAC_PERCENT, &driverPercent[E_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM(function, MSG_DAC_EEPROM_WRITE, dac_driver_eeprom_write);
+      END_MENU();
+    }
+  #endif
+
+  /**
+   *
    * "Prepare" submenu items
    *
    */
@@ -871,29 +886,29 @@ void kill_screen(const char* lcd_msg) {
   }
 
   #if TEMP_SENSOR_0 != 0
-    void lcd_preheat_pla0() { _lcd_preheat(0, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
-    void lcd_preheat_abs0() { _lcd_preheat(0, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
+    void lcd_preheat_pla0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_abs0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
   #endif
 
   #if HOTENDS > 1
-    void lcd_preheat_pla1() { _lcd_preheat(1, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
-    void lcd_preheat_abs1() { _lcd_preheat(1, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
+    void lcd_preheat_pla1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_abs1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
     #if HOTENDS > 2
-      void lcd_preheat_pla2() { _lcd_preheat(2, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
-      void lcd_preheat_abs2() { _lcd_preheat(2, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
+      void lcd_preheat_pla2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_abs2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
       #if HOTENDS > 3
-        void lcd_preheat_pla3() { _lcd_preheat(3, preheatHotendTemp1, preheatBedTemp1, preheatFanSpeed1); }
-        void lcd_preheat_abs3() { _lcd_preheat(3, preheatHotendTemp2, preheatBedTemp2, preheatFanSpeed2); }
+        void lcd_preheat_pla3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+        void lcd_preheat_abs3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
       #endif
     #endif
 
     void lcd_preheat_pla0123() {
       #if HOTENDS > 1
-        thermalManager.setTargetHotend(preheatHotendTemp1, 1);
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
         #if HOTENDS > 2
-          thermalManager.setTargetHotend(preheatHotendTemp1, 2);
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
           #if HOTENDS > 3
-            thermalManager.setTargetHotend(preheatHotendTemp1, 3);
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
           #endif
         #endif
       #endif
@@ -901,11 +916,11 @@ void kill_screen(const char* lcd_msg) {
     }
     void lcd_preheat_abs0123() {
       #if HOTENDS > 1
-        thermalManager.setTargetHotend(preheatHotendTemp2, 1);
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
         #if HOTENDS > 2
-          thermalManager.setTargetHotend(preheatHotendTemp2, 2);
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
           #if HOTENDS > 3
-            thermalManager.setTargetHotend(preheatHotendTemp2, 3);
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
           #endif
         #endif
       #endif
@@ -915,15 +930,15 @@ void kill_screen(const char* lcd_msg) {
   #endif // HOTENDS > 1
 
   #if TEMP_SENSOR_BED != 0
-    void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, preheatBedTemp1, preheatFanSpeed1); }
-    void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, preheatBedTemp2, preheatFanSpeed2); }
+    void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
   #endif
 
   #if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)
 
     static void lcd_preheat_pla_menu() {
       START_MENU();
-      MENU_ITEM(back, MSG_PREPARE);
+      MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
         MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_pla0);
       #else
@@ -945,7 +960,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_preheat_abs_menu() {
       START_MENU();
-      MENU_ITEM(back, MSG_PREPARE);
+      MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
         MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_abs0);
       #else
@@ -1000,13 +1015,13 @@ void kill_screen(const char* lcd_msg) {
     // Note: During Manual Bed Leveling the homed Z position is MESH_HOME_SEARCH_Z
     // Z position will be restored with the final action, a G28
     inline void _mbl_goto_xy(float x, float y) {
-      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z + Z_HOMING_HEIGHT;
+      current_position[Z_AXIS] = LOGICAL_Z_POSITION(MESH_HOME_SEARCH_Z + Z_HOMING_HEIGHT);
       line_to_current(Z_AXIS);
-      current_position[X_AXIS] = x + home_offset[X_AXIS];
-      current_position[Y_AXIS] = y + home_offset[Y_AXIS];
+      current_position[X_AXIS] = LOGICAL_X_POSITION(x);
+      current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
       line_to_current(manual_feedrate_mm_m[X_AXIS] <= manual_feedrate_mm_m[Y_AXIS] ? X_AXIS : Y_AXIS);
       #if Z_HOMING_HEIGHT > 0
-        current_position[Z_AXIS] = MESH_HOME_SEARCH_Z; // How do condition and action match?
+        current_position[Z_AXIS] = LOGICAL_Z_POSITION(MESH_HOME_SEARCH_Z);
         line_to_current(Z_AXIS);
       #endif
       stepper.synchronize();
@@ -1049,12 +1064,12 @@ void kill_screen(const char* lcd_msg) {
       }
 
       static bool debounce_click = false;
-      if (LCD_CLICKED) {
+      if (lcd_clicked) {
         if (!debounce_click) {
           debounce_click = true; // ignore multiple "clicks" in a row
           mbl.set_zigzag_z(_lcd_level_bed_position++, current_position[Z_AXIS]);
           if (_lcd_level_bed_position == (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
-            lcd_goto_screen(_lcd_level_bed_done, true);
+            lcd_goto_screen(_lcd_level_bed_done);
 
             current_position[Z_AXIS] = MESH_HOME_SEARCH_Z + Z_HOMING_HEIGHT;
             line_to_current(Z_AXIS);
@@ -1070,7 +1085,7 @@ void kill_screen(const char* lcd_msg) {
             #endif
           }
           else {
-            lcd_goto_screen(_lcd_level_goto_next_point, true);
+            lcd_goto_screen(_lcd_level_goto_next_point);
           }
         }
       }
@@ -1128,7 +1143,7 @@ void kill_screen(const char* lcd_msg) {
      */
     static void _lcd_level_bed_homing_done() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-      if (LCD_CLICKED) {
+      if (lcd_clicked) {
         _lcd_level_bed_position = 0;
         current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
           #if Z_HOME_DIR > 0
@@ -1136,7 +1151,7 @@ void kill_screen(const char* lcd_msg) {
           #endif
         ;
         planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-        lcd_goto_screen(_lcd_level_goto_next_point, true);
+        lcd_goto_screen(_lcd_level_goto_next_point);
       }
     }
 
@@ -1172,7 +1187,7 @@ void kill_screen(const char* lcd_msg) {
      */
     static void lcd_level_bed() {
       START_MENU();
-      MENU_ITEM(back, MSG_LEVEL_BED_CANCEL);
+      MENU_BACK(MSG_LEVEL_BED_CANCEL);
       MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
       END_MENU();
     }
@@ -1191,7 +1206,7 @@ void kill_screen(const char* lcd_msg) {
     //
     // ^ Main
     //
-    MENU_ITEM(back, MSG_MAIN);
+    MENU_BACK(MSG_MAIN);
 
     //
     // Auto Home
@@ -1212,7 +1227,7 @@ void kill_screen(const char* lcd_msg) {
     //
     // Level Bed
     //
-    #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+    #if HAS_ABL
       MENU_ITEM(gcode, MSG_LEVEL_BED,
         axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
       );
@@ -1295,7 +1310,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_delta_calibrate_menu() {
       START_MENU();
-      MENU_ITEM(back, MSG_MAIN);
+      MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       MENU_ITEM(function, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
       MENU_ITEM(function, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
@@ -1314,12 +1329,7 @@ void kill_screen(const char* lcd_msg) {
    */
   inline void manage_manual_move() {
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
-      #if ENABLED(DELTA)
-        inverse_kinematics(current_position);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
-      #else
-        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
-      #endif
+      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
       manual_move_axis = (int8_t)NO_AXIS;
     }
   }
@@ -1347,7 +1357,7 @@ void kill_screen(const char* lcd_msg) {
    */
 
   static void _lcd_move_xyz(const char* name, AxisEnum axis) {
-    if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+    if (lcd_clicked) { return lcd_goto_previous_menu(true); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       refresh_cmd_timeout();
@@ -1387,7 +1397,7 @@ void kill_screen(const char* lcd_msg) {
       int8_t eindex=-1
     #endif
   ) {
-    if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+    if (lcd_clicked) { return lcd_goto_previous_menu(true); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
@@ -1445,7 +1455,7 @@ void kill_screen(const char* lcd_msg) {
 
   static void _lcd_move_menu_axis() {
     START_MENU();
-    MENU_ITEM(back, MSG_MOVE_AXIS);
+    MENU_BACK(MSG_MOVE_AXIS);
 
     if (_MOVE_XYZ_ALLOWED) {
       MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
@@ -1498,7 +1508,7 @@ void kill_screen(const char* lcd_msg) {
 
   static void lcd_move_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_PREPARE);
+    MENU_BACK(MSG_PREPARE);
 
     if (_MOVE_XYZ_ALLOWED)
       MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
@@ -1517,7 +1527,7 @@ void kill_screen(const char* lcd_msg) {
 
   static void lcd_control_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_MAIN);
+    MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
     MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
@@ -1529,6 +1539,10 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
+    #if ENABLED(DAC_STEPPER_CURRENT)
+      MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu); 
+    #endif
+
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
       MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);
@@ -1600,14 +1614,14 @@ void kill_screen(const char* lcd_msg) {
       #define _PIDTEMP_FUNCTIONS(eindex) _PIDTEMP_BASE_FUNCTIONS(eindex)
     #endif
 
-    _PIDTEMP_FUNCTIONS(0);
+    _PIDTEMP_FUNCTIONS(0)
     #if ENABLED(PID_PARAMS_PER_HOTEND)
       #if HOTENDS > 1
-        _PIDTEMP_FUNCTIONS(1);
+        _PIDTEMP_FUNCTIONS(1)
         #if HOTENDS > 2
-          _PIDTEMP_FUNCTIONS(2);
+          _PIDTEMP_FUNCTIONS(2)
           #if HOTENDS > 3
-            _PIDTEMP_FUNCTIONS(3);
+            _PIDTEMP_FUNCTIONS(3)
           #endif //HOTENDS > 3
         #endif //HOTENDS > 2
       #endif //HOTENDS > 1
@@ -1626,7 +1640,7 @@ void kill_screen(const char* lcd_msg) {
     //
     // ^ Control
     //
-    MENU_ITEM(back, MSG_CONTROL);
+    MENU_BACK(MSG_CONTROL);
 
     //
     // Nozzle:
@@ -1659,7 +1673,7 @@ void kill_screen(const char* lcd_msg) {
     // Bed:
     //
     #if TEMP_SENSOR_BED != 0
-      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
@@ -1751,20 +1765,15 @@ void kill_screen(const char* lcd_msg) {
     END_MENU();
   }
 
-  /**
-   *
-   * "Temperature" > "Preheat PLA conf" submenu
-   *
-   */
-  static void lcd_control_temperature_preheat_pla_settings_menu() {
+  static void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
     START_MENU();
-    MENU_ITEM(back, MSG_TEMPERATURE);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &preheatFanSpeed1, 0, 255);
+    MENU_BACK(MSG_TEMPERATURE);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
     #if TEMP_SENSOR_0 != 0
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &preheatHotendTemp1, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
     #endif
     #if TEMP_SENSOR_BED != 0
-      MENU_ITEM_EDIT(int3, MSG_BED, &preheatBedTemp1, BED_MINTEMP, BED_MAXTEMP - 15);
+      MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
     #endif
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
@@ -1774,24 +1783,17 @@ void kill_screen(const char* lcd_msg) {
 
   /**
    *
+   * "Temperature" > "Preheat PLA conf" submenu
+   *
+   */
+  static void lcd_control_temperature_preheat_pla_settings_menu() { _lcd_control_temperature_preheat_settings_menu(0); }
+
+  /**
+   *
    * "Temperature" > "Preheat ABS conf" submenu
    *
    */
-  static void lcd_control_temperature_preheat_abs_settings_menu() {
-    START_MENU();
-    MENU_ITEM(back, MSG_TEMPERATURE);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &preheatFanSpeed2, 0, 255);
-    #if TEMP_SENSOR_0 != 0
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &preheatHotendTemp2, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
-    #endif
-    #if TEMP_SENSOR_BED != 0
-      MENU_ITEM_EDIT(int3, MSG_BED, &preheatBedTemp2, BED_MINTEMP, BED_MAXTEMP - 15);
-    #endif
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);
-    #endif
-    END_MENU();
-  }
+  static void lcd_control_temperature_preheat_abs_settings_menu() { _lcd_control_temperature_preheat_settings_menu(1); }
 
   static void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
   static void _planner_refresh_positioning() { planner.refresh_positioning(); }
@@ -1803,7 +1805,7 @@ void kill_screen(const char* lcd_msg) {
    */
   static void lcd_control_motion_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_CONTROL);
+    MENU_BACK(MSG_CONTROL);
     #if HAS_BED_PROBE
       MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
@@ -1812,13 +1814,14 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
     MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
-    MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &planner.max_xy_jerk, 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VX_JERK, &planner.max_jerk[X_AXIS], 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VY_JERK, &planner.max_jerk[Y_AXIS], 1, 990);
     #if ENABLED(DELTA)
-      MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_z_jerk, 1, 990);
+      MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 1, 990);
     #else
-      MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_z_jerk, 0.1, 990);
+      MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 0.1, 990);
     #endif
-    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_e_jerk, 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
     MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate_mm_s[X_AXIS], 1, 999);
     MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate_mm_s[Y_AXIS], 1, 999);
     MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate_mm_s[Z_AXIS], 1, 999);
@@ -1852,7 +1855,7 @@ void kill_screen(const char* lcd_msg) {
    */
   static void lcd_control_volumetric_menu() {
     START_MENU();
-    MENU_ITEM(back, MSG_CONTROL);
+    MENU_BACK(MSG_CONTROL);
 
     MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
 
@@ -1881,7 +1884,7 @@ void kill_screen(const char* lcd_msg) {
    */
   #if HAS_LCD_CONTRAST
     static void lcd_set_contrast() {
-      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+      if (lcd_clicked) { return lcd_goto_previous_menu(true); }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         set_lcd_contrast(lcd_contrast + encoderPosition);
@@ -1909,7 +1912,7 @@ void kill_screen(const char* lcd_msg) {
 
     static void lcd_control_retract_menu() {
       START_MENU();
-      MENU_ITEM(back, MSG_CONTROL);
+      MENU_BACK(MSG_CONTROL);
       MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
       #if EXTRUDERS > 1
@@ -1948,10 +1951,10 @@ void kill_screen(const char* lcd_msg) {
      */
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
-      if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return; // nothing to do (so don't thrash the SD card)
+      if (!lcdDrawUpdate && !lcd_clicked) return; // nothing to do (so don't thrash the SD card)
       uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
-      MENU_ITEM(back, MSG_MAIN);
+      MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
@@ -1994,7 +1997,7 @@ void kill_screen(const char* lcd_msg) {
        *
        */
       static void lcd_info_stats_menu() {
-        if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+        if (lcd_clicked) { return lcd_goto_previous_menu(true); }
 
         char buffer[21];
         printStatistics stats = print_job_timer.getStats();
@@ -2028,7 +2031,7 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_thermistors_menu() {
-      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+      if (lcd_clicked) { return lcd_goto_previous_menu(true); }
       START_SCREEN();
       #define THERMISTOR_ID TEMP_SENSOR_0
       #include "thermistornames.h"
@@ -2080,16 +2083,16 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_board_menu() {
-      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+      if (lcd_clicked) { return lcd_goto_previous_menu(true); }
       START_SCREEN();
-      STATIC_ITEM(BOARD_NAME, true, true);                     // MyPrinterController
-      STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE)); // Baud: 250000
-      STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION);    // Protocol: 1.0
+      STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
+      STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
+      STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
       #ifdef POWER_SUPPLY
         #if (POWER_SUPPLY == 1)
-          STATIC_ITEM(MSG_INFO_PSU ": ATX");  // Power Supply: ATX
+          STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
         #elif (POWER_SUPPLY == 2)
-          STATIC_ITEM(MSG_INFO_PSU ": XBox"); // Power Supply: XBox
+          STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
         #endif
       #endif // POWER_SUPPLY
       END_SCREEN();
@@ -2101,14 +2104,14 @@ void kill_screen(const char* lcd_msg) {
      *
      */
     static void lcd_info_printer_menu() {
-      if (LCD_CLICKED) { lcd_goto_previous_menu(true); return; }
+      if (lcd_clicked) { return lcd_goto_previous_menu(true); }
       START_SCREEN();
-      STATIC_ITEM(MSG_MARLIN, true, true);                       // Marlin
-      STATIC_ITEM(SHORT_BUILD_VERSION);                          // x.x.x-Branch
-      STATIC_ITEM(STRING_DISTRIBUTION_DATE);                     // YYYY-MM-DD HH:MM
-      STATIC_ITEM(MACHINE_NAME);                                 // My3DPrinter
-      STATIC_ITEM(WEBSITE_URL);                                  // www.my3dprinter.com
-      STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS)); // Extruders: 2
+      STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
+      STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
+      STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
+      STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
+      STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
+      STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
       END_SCREEN();
     }
 
@@ -2119,7 +2122,7 @@ void kill_screen(const char* lcd_msg) {
      */
     static void lcd_info_menu() {
       START_MENU();
-      MENU_ITEM(back, MSG_MAIN);
+      MENU_BACK(MSG_MAIN);
       MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, lcd_info_printer_menu);        // Printer Info >
       MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, lcd_info_board_menu);            // Board Info >
       MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, lcd_info_thermistors_menu); // Thermistors >
@@ -2291,16 +2294,15 @@ void kill_screen(const char* lcd_msg) {
   #define menu_edit_type(_type, _name, _strFunc, scale) \
     bool _menu_edit_ ## _name () { \
       ENCODER_DIRECTION_NORMAL(); \
-      bool isClicked = LCD_CLICKED; \
       if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
       if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
       if (lcdDrawUpdate) \
         lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
-      if (isClicked) { \
+      if (lcd_clicked) { \
         *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
         lcd_goto_previous_menu(true); \
       } \
-      return isClicked; \
+      return lcd_clicked; \
     } \
     void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \
     void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \
@@ -2325,14 +2327,14 @@ void kill_screen(const char* lcd_msg) {
       callbackFunc = callback; \
     }
 
-  menu_edit_type(int, int3, itostr3, 1);
-  menu_edit_type(float, float3, ftostr3, 1);
-  menu_edit_type(float, float32, ftostr32, 100);
-  menu_edit_type(float, float43, ftostr43sign, 1000);
-  menu_edit_type(float, float5, ftostr5rj, 0.01);
-  menu_edit_type(float, float51, ftostr51sign, 10);
-  menu_edit_type(float, float52, ftostr52sign, 100);
-  menu_edit_type(unsigned long, long5, ftostr5rj, 0.01);
+  menu_edit_type(int, int3, itostr3, 1)
+  menu_edit_type(float, float3, ftostr3, 1)
+  menu_edit_type(float, float32, ftostr32, 100)
+  menu_edit_type(float, float43, ftostr43sign, 1000)
+  menu_edit_type(float, float5, ftostr5rj, 0.01)
+  menu_edit_type(float, float51, ftostr51sign, 10)
+  menu_edit_type(float, float52, ftostr52sign, 100)
+  menu_edit_type(unsigned long, long5, ftostr5rj, 0.01)
 
   /**
    *
@@ -2347,6 +2349,7 @@ void kill_screen(const char* lcd_msg) {
         case X_AXIS: lcd_move_x(); break;
         case Y_AXIS: lcd_move_y(); break;
         case Z_AXIS: lcd_move_z();
+        default: break;
       }
     }
     static void reprapworld_keypad_move_z_up()    { _reprapworld_keypad_move(Z_AXIS,  1); }
@@ -2393,7 +2396,7 @@ void kill_screen(const char* lcd_msg) {
    * Menu actions
    *
    */
-  static void menu_action_back() { lcd_goto_previous_menu(); }
+  static void _menu_action_back() { lcd_goto_previous_menu(); }
   static void menu_action_submenu(screenFunc_t func) { lcd_save_previous_menu(); lcd_goto_screen(func); }
   static void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
   static void menu_action_function(screenFunc_t func) { (*func)(); }
@@ -2447,11 +2450,9 @@ void lcd_init() {
     #endif
 
     #if ENABLED(REPRAPWORLD_KEYPAD)
-      pinMode(SHIFT_CLK, OUTPUT);
-      pinMode(SHIFT_LD, OUTPUT);
-      pinMode(SHIFT_OUT, INPUT);
-      WRITE(SHIFT_OUT, HIGH);
-      WRITE(SHIFT_LD, HIGH);
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      SET_INPUT_PULLUP(SHIFT_OUT);
     #endif
 
     #if BUTTON_EXISTS(UP)
@@ -2470,16 +2471,13 @@ void lcd_init() {
   #else // !NEWPANEL
 
     #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
-      pinMode(SR_DATA_PIN, OUTPUT);
-      pinMode(SR_CLK_PIN, OUTPUT);
+      SET_OUTPUT(SR_DATA_PIN);
+      SET_OUTPUT(SR_CLK_PIN);
     #elif defined(SHIFT_CLK)
-      pinMode(SHIFT_CLK, OUTPUT);
-      pinMode(SHIFT_LD, OUTPUT);
-      pinMode(SHIFT_EN, OUTPUT);
-      pinMode(SHIFT_OUT, INPUT);
-      WRITE(SHIFT_OUT, HIGH);
-      WRITE(SHIFT_LD, HIGH);
-      WRITE(SHIFT_EN, LOW);
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      OUT_WRITE(SHIFT_EN, LOW);
+      SET_INPUT_PULLUP(SHIFT_OUT);
     #endif // SR_LCD_2W_NL
 
   #endif // !NEWPANEL
@@ -2575,9 +2573,20 @@ void lcd_update() {
   #if ENABLED(ULTIPANEL)
     static millis_t return_to_status_ms = 0;
     manage_manual_move();
-  #endif
 
-  lcd_buttons_update();
+    lcd_buttons_update();
+
+    // If the action button is pressed...
+    if (LCD_CLICKED) {
+      if (!wait_for_unclick) {           // If not waiting for a debounce release:
+        wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user;    //  Keep the click if not waiting for a user-click
+        wait_for_user = false;           //  Any click clears wait for user
+        lcd_quick_feedback();            //  Always make a click sound
+      }
+    }
+    else wait_for_unclick = false;
+  #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
@@ -2652,7 +2661,7 @@ void lcd_update() {
       #endif // REPRAPWORLD_KEYPAD
 
       bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
-      if (encoderPastThreshold || LCD_CLICKED) {
+      if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
           int32_t encoderMultiplier = 1;
 
@@ -2718,7 +2727,7 @@ void lcd_update() {
       }
 
       #if ENABLED(ULTIPANEL)
-        #define CURRENTSCREEN() (*currentScreen)()
+        #define CURRENTSCREEN() (*currentScreen)(), lcd_clicked = false
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
@@ -2886,30 +2895,44 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
         #if LCD_HAS_DIRECTIONAL_BUTTONS
 
+          // Manage directional buttons
+          #if ENABLED(REVERSE_MENU_DIRECTION)
+            #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
+          #else
+            #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM
+          #endif
+          #if ENABLED(REVERSE_ENCODER_DIRECTION)
+            #define ENCODER_UD_STEPS _ENCODER_UD_STEPS
+            #define ENCODER_LR_PULSES ENCODER_PULSES_PER_STEP
+          #else
+            #define ENCODER_UD_STEPS -(_ENCODER_UD_STEPS)
+            #define ENCODER_LR_PULSES -(ENCODER_PULSES_PER_STEP)
+          #endif
+
           if (false) {
             // for the else-ifs below
           }
           #if BUTTON_EXISTS(UP)
             else if (BUTTON_PRESSED(UP)) {
-              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM);
+              encoderDiff = -(ENCODER_UD_STEPS);
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(DWN)
             else if (BUTTON_PRESSED(DWN)) {
-              encoderDiff = ENCODER_STEPS_PER_MENU_ITEM;
+              encoderDiff = ENCODER_UD_STEPS;
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(LFT)
             else if (BUTTON_PRESSED(LFT)) {
-              encoderDiff = -(ENCODER_PULSES_PER_STEP);
+              encoderDiff = -(ENCODER_LR_PULSES);
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
-              encoderDiff = ENCODER_PULSES_PER_STEP;
+              encoderDiff = ENCODER_LR_PULSES;
               next_button_update_ms = now + 300;
             }
           #endif
@@ -2967,8 +2990,6 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     #endif
   }
 
-  bool lcd_clicked() { return LCD_CLICKED; }
-
 #endif // ULTIPANEL
 
 #endif // ULTRA_LCD
diff --git a/Marlin/ultralcd.h b/Marlin/ultralcd.h
index 3652da0..a89f47c 100644
--- a/Marlin/ultralcd.h
+++ b/Marlin/ultralcd.h
@@ -30,6 +30,8 @@
   #define BUTTON_EXISTS(BN) (defined(BTN_## BN) && BTN_## BN >= 0)
   #define BUTTON_PRESSED(BN) !READ(BTN_## BN)
 
+  extern int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+
   int lcd_strlen(const char* s);
   int lcd_strlen_P(const char* s);
   void lcd_update();
@@ -65,26 +67,31 @@
   #define LCD_TIMEOUT_TO_STATUS 15000
 
   #if ENABLED(ULTIPANEL)
+
+    #define BLEN_A 0
+    #define BLEN_B 1
+    // Encoder click is directly connected
+    #if BUTTON_EXISTS(ENC)
+      #define BLEN_C 2
+      #define EN_C (_BV(BLEN_C))
+    #endif
+    #define EN_A (_BV(BLEN_A))
+    #define EN_B (_BV(BLEN_B))
+    #define EN_C (_BV(BLEN_C))
+
     extern volatile uint8_t buttons;  //the last checked buttons in a bit array.
     void lcd_buttons_update();
     void lcd_quick_feedback(); // Audible feedback for a button click - could also be visual
-    bool lcd_clicked();
-    void lcd_ignore_click(bool b=true);
 
     #if ENABLED(FILAMENT_CHANGE_FEATURE)
       void lcd_filament_change_show_message(FilamentChangeMessage message);
     #endif // FILAMENT_CHANGE_FEATURE
 
   #else
-    FORCE_INLINE void lcd_buttons_update() {}
-  #endif
 
-  extern int preheatHotendTemp1;
-  extern int preheatBedTemp1;
-  extern int preheatFanSpeed1;
-  extern int preheatHotendTemp2;
-  extern int preheatBedTemp2;
-  extern int preheatFanSpeed2;
+    inline void lcd_buttons_update() {}
+
+  #endif
 
   #if ENABLED(FILAMENT_LCD_DISPLAY)
     extern millis_t previous_lcd_status_ms;
@@ -92,19 +99,6 @@
 
   bool lcd_blink();
 
-  #if ENABLED(ULTIPANEL)
-    #define BLEN_A 0
-    #define BLEN_B 1
-    // Encoder click is directly connected
-    #if BUTTON_EXISTS(ENC)
-      #define BLEN_C 2
-      #define EN_C (_BV(BLEN_C))
-    #endif
-    #define EN_A (_BV(BLEN_A))
-    #define EN_B (_BV(BLEN_B))
-    #define EN_C (_BV(BLEN_C))
-  #endif
-
   #if ENABLED(REPRAPWORLD_KEYPAD) // is also ULTIPANEL and NEWPANEL
 
     #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
@@ -150,21 +144,23 @@
     #define LCD_CLICKED ((buttons & EN_C) || (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F1))
   #elif ENABLED(NEWPANEL)
     #define LCD_CLICKED (buttons & EN_C)
+  #else
+    #define LCD_CLICKED false
   #endif
 
 #else //no LCD
-  FORCE_INLINE void lcd_update() {}
-  FORCE_INLINE void lcd_init() {}
-  FORCE_INLINE bool lcd_hasstatus() { return false; }
-  FORCE_INLINE void lcd_setstatus(const char* message, const bool persist=false) {UNUSED(message); UNUSED(persist);}
-  FORCE_INLINE void lcd_setstatuspgm(const char* message, const uint8_t level=0) {UNUSED(message); UNUSED(level);}
-  FORCE_INLINE void lcd_buttons_update() {}
-  FORCE_INLINE void lcd_reset_alert_level() {}
-  FORCE_INLINE bool lcd_detected(void) { return true; }
+  inline void lcd_update() {}
+  inline void lcd_init() {}
+  inline bool lcd_hasstatus() { return false; }
+  inline void lcd_setstatus(const char* message, const bool persist=false) { UNUSED(message); UNUSED(persist); }
+  inline void lcd_setstatuspgm(const char* message, const uint8_t level=0) { UNUSED(message); UNUSED(level); }
+  inline void lcd_buttons_update() {}
+  inline void lcd_reset_alert_level() {}
+  inline bool lcd_detected(void) { return true; }
 
   #define LCD_MESSAGEPGM(x) NOOP
   #define LCD_ALERTMESSAGEPGM(x) NOOP
 
-#endif //ULTRA_LCD
+#endif // ULTRA_LCD
 
-#endif //ULTRALCD_H
+#endif // ULTRALCD_H
diff --git a/Marlin/ultralcd_impl_DOGM.h b/Marlin/ultralcd_impl_DOGM.h
index aeed61f..d39aec8 100644
--- a/Marlin/ultralcd_impl_DOGM.h
+++ b/Marlin/ultralcd_impl_DOGM.h
@@ -220,14 +220,12 @@ void lcd_printPGM(const char* str) {
 // Initialize or re-initializw the LCD
 static void lcd_implementation_init() {
 
-  #if defined(LCD_PIN_BL) && LCD_PIN_BL > -1 // Enable LCD backlight
-    pinMode(LCD_PIN_BL, OUTPUT);
-    digitalWrite(LCD_PIN_BL, HIGH);
+  #if PIN_EXISTS(LCD_BACKLIGHT) // Enable LCD backlight
+    OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
   #endif
 
-  #if defined(LCD_PIN_RESET) && LCD_PIN_RESET > -1
-    pinMode(LCD_PIN_RESET, OUTPUT);
-    digitalWrite(LCD_PIN_RESET, HIGH);
+  #if PIN_EXISTS(LCD_RESET)
+    OUT_WRITE(LCD_RESET_PIN, HIGH);
   #endif
 
   #if DISABLED(MINIPANEL) // setContrast not working for Mini Panel
@@ -552,7 +550,7 @@ static void lcd_implementation_status_screen() {
   }
 
   // Macros for specific types of menu items
-  #define lcd_implementation_drawmenu_back(sel, row, pstr) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
+  #define lcd_implementation_drawmenu_back(sel, row, pstr, dummy) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
   #define lcd_implementation_drawmenu_submenu(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', LCD_STR_ARROW_RIGHT[0])
   #define lcd_implementation_drawmenu_gcode(sel, row, pstr, gcode) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
   #define lcd_implementation_drawmenu_function(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
diff --git a/Marlin/ultralcd_impl_HD44780.h b/Marlin/ultralcd_impl_HD44780.h
index 692f7ae..b60deec 100644
--- a/Marlin/ultralcd_impl_HD44780.h
+++ b/Marlin/ultralcd_impl_HD44780.h
@@ -228,6 +228,16 @@ static void lcd_set_custom_characters(
     B10001,
     B01110
   };
+  static byte uplevel[8] = {
+    B00100,
+    B01110,
+    B11111,
+    B00100,
+    B11100,
+    B00000,
+    B00000,
+    B00000
+  }; //thanks joris
   static byte feedrate[8] = {
     B11100,
     B10000,
@@ -256,16 +266,6 @@ static void lcd_set_custom_characters(
   lcd.createChar(LCD_STR_CLOCK[0], clock);
 
   #if ENABLED(SDSUPPORT)
-    static byte uplevel[8] = {
-      B00100,
-      B01110,
-      B11111,
-      B00100,
-      B11100,
-      B00000,
-      B00000,
-      B00000
-    }; //thanks joris
     static byte refresh[8] = {
       B00000,
       B00110,
@@ -334,6 +334,8 @@ static void lcd_set_custom_characters(
       lcd.createChar(LCD_STR_FOLDER[0], folder);
     #endif
 
+  #else
+    lcd.createChar(LCD_STR_UPLEVEL[0], uplevel);
   #endif
 }
 
@@ -915,7 +917,7 @@ static void lcd_implementation_status_screen() {
 
   #endif // SDSUPPORT
 
-  #define lcd_implementation_drawmenu_back(sel, row, pstr) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
+  #define lcd_implementation_drawmenu_back(sel, row, pstr, dummy) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])
   #define lcd_implementation_drawmenu_submenu(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', LCD_STR_ARROW_RIGHT[0])
   #define lcd_implementation_drawmenu_gcode(sel, row, pstr, gcode) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
   #define lcd_implementation_drawmenu_function(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '>', ' ')
diff --git a/Marlin/vector_3.cpp b/Marlin/vector_3.cpp
index 1cca0d9..c5f0cc0 100644
--- a/Marlin/vector_3.cpp
+++ b/Marlin/vector_3.cpp
@@ -41,7 +41,7 @@
 #include <math.h>
 #include "Marlin.h"
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
 #include "vector_3.h"
 
 vector_3::vector_3() : x(0), y(0), z(0) { }
@@ -156,5 +156,5 @@ void matrix_3x3::debug(const char title[]) {
   }
 }
 
-#endif // AUTO_BED_LEVELING_FEATURE
+#endif // HAS_ABL
 
diff --git a/Marlin/vector_3.h b/Marlin/vector_3.h
index e76188b..efc0132 100644
--- a/Marlin/vector_3.h
+++ b/Marlin/vector_3.h
@@ -41,7 +41,7 @@
 #ifndef VECTOR_3_H
 #define VECTOR_3_H
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE)
+#if HAS_ABL
 class matrix_3x3;
 
 struct vector_3 {
@@ -77,6 +77,6 @@ struct matrix_3x3 {
 
 
 void apply_rotation_xyz(matrix_3x3 rotationMatrix, float& x, float& y, float& z);
-#endif // AUTO_BED_LEVELING_FEATURE
+#endif // HAS_ABL
 
 #endif // VECTOR_3_H

