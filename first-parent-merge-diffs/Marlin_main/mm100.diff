commit 6e5e388861f40458b09ba9a4a2491062f041ba19
Merge: f30df89 d4134e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 22 19:10:37 2016 -0700

    Merge pull request #4021 from thinkyhead/rc_raise_z_for_servos
    
    Make probes independent of leveling

diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ad83f42..0e42a4b 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -366,6 +366,8 @@ static uint8_t target_extruder;
   float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
 #endif
 
+#define PLANNER_XY_FEEDRATE() (min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]))
+
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   int xy_probe_speed = XY_PROBE_SPEED;
   bool bed_leveling_in_progress = false;
@@ -373,7 +375,7 @@ static uint8_t target_extruder;
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE XY_PROBE_SPEED
 #else
-  #define XY_PROBE_FEEDRATE (min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]) * 60)
+  #define XY_PROBE_FEEDRATE (PLANNER_XY_FEEDRATE() * 60)
 #endif
 
 #if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)
@@ -414,7 +416,7 @@ static uint8_t target_extruder;
 
   float retract_length = RETRACT_LENGTH;
   float retract_length_swap = RETRACT_LENGTH_SWAP;
-  float retract_feedrate = RETRACT_FEEDRATE;
+  float retract_feedrate_mm_s = RETRACT_FEEDRATE;
   float retract_zlift = RETRACT_ZLIFT;
   float retract_recover_length = RETRACT_RECOVER_LENGTH;
   float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
@@ -493,8 +495,10 @@ static bool send_ok[BUFSIZE];
 #if HAS_SERVOS
   Servo servo[NUM_SERVOS];
   #define MOVE_SERVO(I, P) servo[I].move(P)
-  #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
-  #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
+  #if HAS_Z_SERVO_ENDSTOP
+    #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
+    #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
+  #endif
 #endif
 
 #ifdef CHDK
@@ -582,6 +586,9 @@ static void report_current_position();
     calculate_delta(current_position);
     planner.set_position_mm(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
   }
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_delta()
+#else
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
 #endif
 
 #if ENABLED(SDSUPPORT)
@@ -861,13 +868,16 @@ void setup() {
   // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
   Config_RetrieveSettings();
 
-  thermalManager.init();    // Initialize temperature loop
+  // Initialize current position based on home_offset
+  memcpy(current_position, home_offset, sizeof(home_offset));
 
   #if ENABLED(DELTA) || ENABLED(SCARA)
     // Vital to init kinematic equivalent for X0 Y0 Z0
-    sync_plan_position_delta();
+    SYNC_PLAN_POSITION_KINEMATIC();
   #endif
 
+  thermalManager.init();    // Initialize temperature loop
+
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();
   #endif
@@ -918,8 +928,6 @@ void setup() {
       lcd_init();
     #endif
   #endif
-
-
 }
 
 /**
@@ -1581,33 +1589,40 @@ inline void set_destination_to_current() { memcpy(destination, current_position,
 //
 //  - Save current feedrates
 //  - Reset the rate multiplier
-//  - Enable the endstops
 //  - Reset the command timeout
+//  - Enable the endstops (for endstop moves)
 //
 // clean_up_after_endstop_move() restores
 // feedrates, sets endstops back to global state.
 //
-static void setup_for_endstop_move() {
+static void setup_for_endstop_or_probe_move() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
+  #endif
   saved_feedrate = feedrate;
   saved_feedrate_multiplier = feedrate_multiplier;
   feedrate_multiplier = 100;
   refresh_cmd_timeout();
+}
+static void setup_for_endstop_move() {
+  setup_for_endstop_or_probe_move();
+  endstops.enable();
+}
+
+static void clean_up_after_endstop_or_probe_move() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("setup_for_endstop_move > endstops.enable()");
+    if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   #endif
-  endstops.enable();
+  feedrate = saved_feedrate;
+  feedrate_multiplier = saved_feedrate_multiplier;
+  refresh_cmd_timeout();
 }
 
 #if HAS_BED_PROBE
 
   static void clean_up_after_endstop_move() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("clean_up_after_endstop_move > endstops.not_homing()");
-    #endif
+    clean_up_after_endstop_or_probe_move();
     endstops.not_homing();
-    feedrate = saved_feedrate;
-    feedrate_multiplier = saved_feedrate_multiplier;
-    refresh_cmd_timeout();
   }
 
   #if ENABLED(DELTA)
@@ -1678,37 +1693,55 @@ static void setup_for_endstop_move() {
     do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z);
   }
 
-  inline void raise_z_after_probing() {
-    #if Z_RAISE_AFTER_PROBING > 0
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("raise_z_after_probing()");
-      #endif
-      do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING);
-    #endif
-  }
-#endif //HAS_BED_PROBE
-
-#if HAS_Z_SERVO_ENDSTOP
-
   /**
-   * Raise Z to a minimum height to make room for a servo to move
+   * Raise Z to a minimum height to make room for a probe to move
    *
    * zprobe_zoffset: Negative of the Z height where the probe engages
-   *         z_dest: The before / after probing raise distance
+   *        z_raise: The probing raise distance
    *
    * The zprobe_zoffset is negative for a switch below the nozzle, so
    * multiply by Z_HOME_DIR (-1) to move enough away from the bed.
    */
-  void raise_z_for_servo(float z_dest) {
-    z_dest += home_offset[Z_AXIS];
+  inline void do_probe_raise(float z_raise) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
+        SERIAL_ECHOLNPGM(")");
+      }
+    #endif
+    float z_dest = home_offset[Z_AXIS] + z_raise;
 
     if ((Z_HOME_DIR) < 0 && zprobe_zoffset < 0)
       z_dest -= zprobe_zoffset;
 
-    if (z_dest > current_position[Z_AXIS])
-      do_blocking_move_to_z(z_dest); // also updates current_position
+    if (z_dest > current_position[Z_AXIS]) {
+      float old_feedrate = feedrate;
+      feedrate = homing_feedrate[Z_AXIS];
+      do_blocking_move_to_z(z_dest);
+      feedrate = old_feedrate;
+    }
+  }
+
+  inline void raise_z_after_probing() {
+    #if Z_RAISE_AFTER_PROBING > 0
+      do_probe_raise(Z_RAISE_AFTER_PROBING);
+    #endif
   }
+#endif //HAS_BED_PROBE
 
+#if ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || HAS_PROBING_PROCEDURE
+  static void axis_unhomed_error(bool xyz=false) {
+    if (xyz) {
+      LCD_MESSAGEPGM(MSG_XYZ_UNHOMED);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_XYZ_UNHOMED);
+    }
+    else {
+      LCD_MESSAGEPGM(MSG_YX_UNHOMED);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_YX_UNHOMED);
+    }
+  }
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
@@ -1739,19 +1772,24 @@ static void setup_for_endstop_move() {
     if (endstops.z_probe_enabled == !dock) return; // already docked/undocked?
 
     float oldXpos = current_position[X_AXIS]; // save x position
+    float old_feedrate = feedrate;
     if (dock) {
       raise_z_after_probing(); // raise Z
       // Dock sled a bit closer to ensure proper capturing
+      feedrate = XY_PROBE_FEEDRATE;
       do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);
       digitalWrite(SLED_PIN, LOW); // turn off magnet
     }
     else {
+      feedrate = XY_PROBE_FEEDRATE;
       float z_loc = current_position[Z_AXIS];
       if (z_loc < Z_RAISE_BEFORE_PROBING + 5) z_loc = Z_RAISE_BEFORE_PROBING;
       do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc); // this also updates current_position
       digitalWrite(SLED_PIN, HIGH); // turn on magnet
     }
     do_blocking_move_to_x(oldXpos); // return to position before docking
+
+    feedrate = old_feedrate;
   }
 
 #endif // Z_PROBE_SLED
@@ -1773,7 +1811,7 @@ static void setup_for_endstop_move() {
     #elif HAS_Z_SERVO_ENDSTOP
 
       // Make room for Z Servo
-      raise_z_for_servo(Z_RAISE_BEFORE_PROBING);
+      do_probe_raise(Z_RAISE_BEFORE_PROBING);
 
       // Engage Z Servo endstop if enabled
       DEPLOY_Z_SERVO();
@@ -1852,7 +1890,7 @@ static void setup_for_endstop_move() {
           stop();
         }
 
-    #elif ENABLED(FIX_MOUNTED_PROBE)
+    #else
 
       // Nothing to be done. Just enable_z_probe below...
 
@@ -1875,7 +1913,7 @@ static void setup_for_endstop_move() {
     #elif HAS_Z_SERVO_ENDSTOP
 
       // Make room for the servo
-      raise_z_for_servo(Z_RAISE_AFTER_PROBING);
+      do_probe_raise(Z_RAISE_AFTER_PROBING);
 
       // Change the Z servo angle
       STOW_Z_SERVO();
@@ -1944,7 +1982,7 @@ static void setup_for_endstop_move() {
           stop();
         }
 
-    #elif ENABLED(FIX_MOUNTED_PROBE)
+    #else
 
       // Nothing to do here. Just clear endstops.z_probe_enabled
 
@@ -1953,14 +1991,13 @@ static void setup_for_endstop_move() {
     endstops.enable_z_probe(false);
   }
 
-  static void run_z_probe() {
+  // Do a single Z probe and return with current_position[Z_AXIS]
+  // at the height where the probe triggered.
+  static float run_z_probe() {
 
     float old_feedrate = feedrate;
 
-    /**
-     * To prevent stepper_inactive_time from running out and
-     * EXTRUDER_RUNOUT_PREVENT from extruding
-     */
+    // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
     refresh_cmd_timeout();
 
     #if ENABLED(DELTA)
@@ -1991,7 +2028,7 @@ static void setup_for_endstop_move() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe (DELTA) 2", current_position);
       #endif
 
-      sync_plan_position_delta();
+      SYNC_PLAN_POSITION_KINEMATIC();
 
     #else // !DELTA
 
@@ -2029,7 +2066,8 @@ static void setup_for_endstop_move() {
 
       // Get the current stepper position after bumping an endstop
       current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
-      sync_plan_position();
+
+      SYNC_PLAN_POSITION_KINEMATIC();
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe", current_position);
@@ -2038,10 +2076,96 @@ static void setup_for_endstop_move() {
     #endif // !DELTA
 
     feedrate = old_feedrate;
+
+    return current_position[Z_AXIS];
   }
 
 #endif // HAS_BED_PROBE
 
+#if HAS_PROBING_PROCEDURE
+
+  inline void do_blocking_move_to_xy(float x, float y) {
+    do_blocking_move_to(x, y, current_position[Z_AXIS]);
+  }
+
+  enum ProbeAction {
+    ProbeStay          = 0,
+    ProbeDeploy        = _BV(0),
+    ProbeStow          = _BV(1),
+    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
+  };
+
+  // Probe bed height at position (x,y), returns the measured z value
+  static float probe_pt(float x, float y, float z_raise, ProbeAction probe_action = ProbeDeployAndStow, int verbose_level = 1) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("probe_pt >>>");
+        SERIAL_ECHOPAIR("> ProbeAction:", probe_action);
+        SERIAL_EOL;
+        DEBUG_POS("", current_position);
+      }
+    #endif
+
+    float old_feedrate = feedrate;
+
+    // Raise by z_raise, then move the Z probe to the given XY
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("Z Raise by z_raise ", z_raise);
+        SERIAL_EOL;
+      }
+    #endif
+    do_probe_raise(z_raise); // this also updates current_position
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("> do_blocking_move_to_xy ", x - (X_PROBE_OFFSET_FROM_EXTRUDER));
+        SERIAL_ECHOPAIR(", ", y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
+        SERIAL_EOL;
+      }
+    #endif
+
+    // this also updates current_position
+    feedrate = XY_PROBE_FEEDRATE;
+    do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
+
+    if (probe_action & ProbeDeploy) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeDeploy");
+      #endif
+      deploy_z_probe();
+    }
+
+    float measured_z = run_z_probe();
+
+    if (probe_action & ProbeStow) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
+      #endif
+      stow_z_probe();
+    }
+
+    if (verbose_level > 2) {
+      SERIAL_PROTOCOLPGM("Bed X: ");
+      SERIAL_PROTOCOL_F(x, 3);
+      SERIAL_PROTOCOLPGM(" Y: ");
+      SERIAL_PROTOCOL_F(y, 3);
+      SERIAL_PROTOCOLPGM(" Z: ");
+      SERIAL_PROTOCOL_F(measured_z, 3);
+      SERIAL_EOL;
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
+    #endif
+
+    feedrate = old_feedrate;
+
+    return measured_z;
+  }
+
+#endif // AUTO_BED_LEVELING_FEATURE || Z_MIN_PROBE_REPEATABILITY_TEST
+
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
 
   #if ENABLED(AUTO_BED_LEVELING_GRID)
@@ -2073,7 +2197,7 @@ static void setup_for_endstop_move() {
           if (DEBUGGING(LEVELING)) DEBUG_POS("<<< set_bed_level_equation_lsq", corrected_position);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
       }
 
     #endif // !DELTA
@@ -2084,6 +2208,13 @@ static void setup_for_endstop_move() {
 
       planner.bed_level_matrix.set_to_identity();
 
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          vector_3 uncorrected_position = planner.adjusted_position();
+          DEBUG_POS("set_bed_level_equation_3pts", uncorrected_position);
+        }
+      #endif
+
       vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);
       vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);
       vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);
@@ -2096,16 +2227,8 @@ static void setup_for_endstop_move() {
       }
 
       planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
-
       vector_3 corrected_position = planner.adjusted_position();
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          vector_3 uncorrected_position = corrected_position;
-          DEBUG_POS("set_bed_level_equation_3pts", uncorrected_position);
-        }
-      #endif
-
       current_position[X_AXIS] = corrected_position.x;
       current_position[Y_AXIS] = corrected_position.y;
       current_position[Z_AXIS] = corrected_position.z;
@@ -2114,94 +2237,11 @@ static void setup_for_endstop_move() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("set_bed_level_equation_3pts", corrected_position);
       #endif
 
-      sync_plan_position();
+      SYNC_PLAN_POSITION_KINEMATIC();
     }
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  inline void do_blocking_move_to_xy(float x, float y) {
-    do_blocking_move_to(x, y, current_position[Z_AXIS]);
-  }
-
-  enum ProbeAction {
-    ProbeStay          = 0,
-    ProbeDeploy        = _BV(0),
-    ProbeStow          = _BV(1),
-    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
-  };
-
-  // Probe bed height at position (x,y), returns the measured z value
-  static float probe_pt(float x, float y, float z_before, ProbeAction probe_action = ProbeDeployAndStow, int verbose_level = 1) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("probe_pt >>>");
-        SERIAL_ECHOPAIR("> ProbeAction:", probe_action);
-        SERIAL_EOL;
-        DEBUG_POS("", current_position);
-      }
-    #endif
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("Z Raise to z_before ", z_before);
-        SERIAL_EOL;
-        SERIAL_ECHOPAIR("> do_blocking_move_to_z ", z_before);
-        SERIAL_EOL;
-      }
-    #endif
-
-    // Move Z up to the z_before height, then move the Z probe to the given XY
-    do_blocking_move_to_z(z_before); // this also updates current_position
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("> do_blocking_move_to_xy ", x - (X_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_ECHOPAIR(", ", y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_EOL;
-      }
-    #endif
-
-    // this also updates current_position
-    do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-
-    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
-      if (probe_action & ProbeDeploy) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeDeploy");
-        #endif
-        deploy_z_probe();
-      }
-    #endif
-
-    run_z_probe();
-    float measured_z = current_position[Z_AXIS];
-
-    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
-      if (probe_action & ProbeStow) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
-        #endif
-        stow_z_probe();
-      }
-    #endif
-
-    if (verbose_level > 2) {
-      SERIAL_PROTOCOLPGM("Bed X: ");
-      SERIAL_PROTOCOL_F(x, 3);
-      SERIAL_PROTOCOLPGM(" Y: ");
-      SERIAL_PROTOCOL_F(y, 3);
-      SERIAL_PROTOCOLPGM(" Z: ");
-      SERIAL_PROTOCOL_F(measured_z, 3);
-      SERIAL_EOL;
-    }
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
-    #endif
-
-    return measured_z;
-  }
-
   #if ENABLED(DELTA)
 
     /**
@@ -2274,21 +2314,6 @@ static void setup_for_endstop_move() {
 
 #endif // AUTO_BED_LEVELING_FEATURE
 
-#if ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || ENABLED(AUTO_BED_LEVELING_FEATURE)
-  static void axis_unhomed_error(bool xyz=false) {
-    if (xyz) {
-      LCD_MESSAGEPGM(MSG_XYZ_UNHOMED);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM(MSG_XYZ_UNHOMED);
-    }
-    else {
-      LCD_MESSAGEPGM(MSG_YX_UNHOMED);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM(MSG_YX_UNHOMED);
-    }
-  }
-#endif
-
 /**
  * Home an individual axis
  */
@@ -2315,7 +2340,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position as setup for the move
     current_position[axis] = 0;
-    sync_plan_position();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     // Homing Z towards the bed? Deploy the Z probe or endstop.
     #if HAS_BED_PROBE
@@ -2340,7 +2365,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position as setup for the move
     current_position[axis] = 0;
-    sync_plan_position();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(false)");
@@ -2381,7 +2406,7 @@ static void homeaxis(AxisEnum axis) {
           lockZ1 = (z_endstop_adj < 0);
 
         if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         // Move to the adjusted endstop height
         feedrate = homing_feedrate[axis];
@@ -2401,7 +2426,7 @@ static void homeaxis(AxisEnum axis) {
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(false)");
         #endif
         endstops.enable(false); // Disable endstops while moving away
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         destination[axis] = endstop_adj[axis];
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
@@ -2428,7 +2453,8 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position to its home position (plus home offsets)
     set_axis_is_at_home(axis);
-    sync_plan_position();
+
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
@@ -2466,24 +2492,20 @@ static void homeaxis(AxisEnum axis) {
 
     if (retracting == retracted[active_extruder]) return;
 
-    float oldFeedrate = feedrate;
+    float old_feedrate = feedrate;
 
     set_destination_to_current();
 
     if (retracting) {
 
-      feedrate = retract_feedrate * 60;
+      feedrate = retract_feedrate_mm_s * 60;
       current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
       sync_plan_position_e();
       prepare_move_to_destination();
 
       if (retract_zlift > 0.01) {
         current_position[Z_AXIS] -= retract_zlift;
-        #if ENABLED(DELTA)
-          sync_plan_position_delta();
-        #else
-          sync_plan_position();
-        #endif
+        SYNC_PLAN_POSITION_KINEMATIC();
         prepare_move_to_destination();
       }
     }
@@ -2491,11 +2513,7 @@ static void homeaxis(AxisEnum axis) {
 
       if (retract_zlift > 0.01) {
         current_position[Z_AXIS] += retract_zlift;
-        #if ENABLED(DELTA)
-          sync_plan_position_delta();
-        #else
-          sync_plan_position();
-        #endif
+        SYNC_PLAN_POSITION_KINEMATIC();
       }
 
       feedrate = retract_recover_feedrate * 60;
@@ -2505,7 +2523,7 @@ static void homeaxis(AxisEnum axis) {
       prepare_move_to_destination();
     }
 
-    feedrate = oldFeedrate;
+    feedrate = old_feedrate;
     retracted[active_extruder] = retracting;
 
   } // retract()
@@ -2806,7 +2824,7 @@ inline void gcode_G28() {
     HOMEAXIS(Y);
     HOMEAXIS(Z);
 
-    sync_plan_position_delta();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(DELTA)", current_position);
@@ -2868,7 +2886,7 @@ inline void gcode_G28() {
           int x_axis_home_dir = home_dir(X_AXIS);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         float mlx = max_length(X_AXIS), mly = max_length(Y_AXIS),
               mlratio = mlx > mly ? mly / mlx : mlx / mly;
@@ -2881,7 +2899,7 @@ inline void gcode_G28() {
 
         set_axis_is_at_home(X_AXIS);
         set_axis_is_at_home(Y_AXIS);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> QUICK_HOME 1", current_position);
@@ -2965,7 +2983,7 @@ inline void gcode_G28() {
              * enough to reach Z_SAFE_HOMING XY positions.
              * Just make sure the planner is in sync.
              */
-            sync_plan_position();
+            SYNC_PLAN_POSITION_KINEMATIC();
 
             /**
              * Set the Z probe (or just the nozzle) destination to the safe
@@ -3050,29 +3068,18 @@ inline void gcode_G28() {
 
     #endif // Z_HOME_DIR < 0
 
-    sync_plan_position();
-
-  #endif // else DELTA
+    SYNC_PLAN_POSITION_KINEMATIC();
 
-  #if ENABLED(SCARA)
-    sync_plan_position_delta();
-  #endif
+  #endif // !DELTA (gcode_G28)
 
-  #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
-    endstops.enable(false);
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING endstops.enable(false)");
-      }
-    #endif
-  #endif
+  endstops.not_homing();
 
   // Enable mesh leveling again
   #if ENABLED(MESH_BED_LEVELING)
     if (mbl.has_mesh()) {
       if (home_all_axis || (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && homeZ)) {
         current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         mbl.set_active(true);
         #if ENABLED(MESH_G28_REST_ORIGIN)
           current_position[Z_AXIS] = 0.0;
@@ -3088,7 +3095,7 @@ inline void gcode_G28() {
       }
       else if ((axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) && (homeX || homeY)) {
         current_position[Z_AXIS] = pre_home_z;
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         mbl.set_active(true);
         current_position[Z_AXIS] = pre_home_z -
           mbl.get_z(current_position[X_AXIS] - home_offset[X_AXIS],
@@ -3097,20 +3104,27 @@ inline void gcode_G28() {
     }
   #endif
 
-  feedrate = saved_feedrate;
-  feedrate_multiplier = saved_feedrate_multiplier;
-  refresh_cmd_timeout();
+  clean_up_after_endstop_or_probe_move();
+
   endstops.hit_on_purpose(); // clear endstop hit flags
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM("<<< gcode_G28");
-    }
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   #endif
 
   report_current_position();
 }
 
+#if HAS_PROBING_PROCEDURE
+
+  void out_of_range_error(const char* p_edge) {
+    SERIAL_PROTOCOLPGM("?Probe ");
+    serialprintPGM(p_edge);
+    SERIAL_PROTOCOLLNPGM(" position out of range.");
+  }
+
+#endif
+
 #if ENABLED(MESH_BED_LEVELING)
 
   enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet, MeshSetZOffset, MeshReset };
@@ -3216,7 +3230,7 @@ inline void gcode_G28() {
         if (probe_point == 0) {
           // For the intial G29 S2 make Z a positive value (e.g., 4.0)
           current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-          sync_plan_position();
+          SYNC_PLAN_POSITION_KINEMATIC();
         }
         else {
           // For G29 S2 after adjusting Z.
@@ -3296,7 +3310,7 @@ inline void gcode_G28() {
             mbl.get_z(current_position[X_AXIS] - home_offset[X_AXIS],
                       current_position[Y_AXIS] - home_offset[Y_AXIS]) - MESH_HOME_SEARCH_Z;
           mbl.reset();
-          sync_plan_position();
+          SYNC_PLAN_POSITION_KINEMATIC();
         }
         else
           mbl.reset();
@@ -3308,12 +3322,6 @@ inline void gcode_G28() {
 
 #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
 
-  void out_of_range_error(const char* p_edge) {
-    SERIAL_PROTOCOLPGM("?Probe ");
-    serialprintPGM(p_edge);
-    SERIAL_PROTOCOLLNPGM(" position out of range.");
-  }
-
   /**
    * G29: Detailed Z probe, probes the bed at 3 or more points.
    *      Will fail if the printer has not been homed with G28.
@@ -3373,8 +3381,11 @@ inline void gcode_G28() {
       return;
     }
 
-    bool dryrun = code_seen('D'),
-         deploy_probe_for_each_reading = code_seen('E');
+    bool dryrun = code_seen('D');
+
+    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
+      bool deploy_probe_for_each_reading = code_seen('E');
+    #endif
 
     #if ENABLED(AUTO_BED_LEVELING_GRID)
 
@@ -3464,20 +3475,17 @@ inline void gcode_G28() {
           if (DEBUGGING(LEVELING)) DEBUG_POS("AFTER matrix.set_to_identity", uncorrected_position);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
       #endif // !DELTA
     }
 
-    #if HAS_BED_PROBE
-      deploy_z_probe();
-    #endif
-
     stepper.synchronize();
 
-    setup_for_endstop_move();
+    setup_for_endstop_or_probe_move();
 
-    feedrate = homing_feedrate[Z_AXIS];
+    // Deploy the probe. Servo will raise if needed.
+    deploy_z_probe();
 
     bed_leveling_in_progress = true;
 
@@ -3535,16 +3543,16 @@ inline void gcode_G28() {
 
           // raise extruder
           float measured_z,
-                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS];
+                z_raise = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS : Z_RAISE_BEFORE_PROBING;
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("z_before = (");
+              SERIAL_ECHOPGM("z_raise = (");
               if (probePointCounter)
                 SERIAL_ECHOPGM("between) ");
               else
                 SERIAL_ECHOPGM("before) ");
-              SERIAL_ECHOLN(z_before);
+              SERIAL_ECHOLN(z_raise);
             }
           #endif
 
@@ -3554,17 +3562,21 @@ inline void gcode_G28() {
             if (distance_from_center > DELTA_PROBEABLE_RADIUS) continue;
           #endif //DELTA
 
-          ProbeAction act;
-          if (deploy_probe_for_each_reading) // G29 E - Stow between probes
-            act = ProbeDeployAndStow;
-          else if (yCount == 0 && xCount == xStart)
-            act = ProbeDeploy;
-          else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)
-            act = ProbeStow;
-          else
-            act = ProbeStay;
+          #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+            const ProbeAction act = ProbeStay;
+          #else
+            ProbeAction act;
+            if (deploy_probe_for_each_reading) // G29 E - Stow between probes
+              act = ProbeDeployAndStow;
+            else if (yCount == 0 && xCount == xStart)
+              act = ProbeDeploy;
+            else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)
+              act = ProbeStow;
+            else
+              act = ProbeStay;
+          #endif
 
-          measured_z = probe_pt(xProbe, yProbe, z_before, act, verbose_level);
+          measured_z = probe_pt(xProbe, yProbe, z_raise, act, verbose_level);
 
           #if DISABLED(DELTA)
             mean += measured_z;
@@ -3589,8 +3601,6 @@ inline void gcode_G28() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
       #endif
 
-      clean_up_after_endstop_move();
-
       #if ENABLED(DELTA)
 
         if (!dryrun) extrapolate_unprobed_bed_level();
@@ -3690,32 +3700,34 @@ inline void gcode_G28() {
     #else // !AUTO_BED_LEVELING_GRID
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("> 3-point Leveling");
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
       #endif
 
-      // Actions for each probe
-      ProbeAction p1, p2, p3;
-      if (deploy_probe_for_each_reading)
-        p1 = p2 = p3 = ProbeDeployAndStow;
-      else
-        p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;
+      #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+        const ProbeAction p1 = ProbeStay, p2 = ProbeStay, p3 = ProbeStay;
+      #else
+        // Actions for each probe
+        ProbeAction p1, p2, p3;
+        if (deploy_probe_for_each_reading)
+          p1 = p2 = p3 = ProbeDeployAndStow;
+        else
+          p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;
+      #endif
 
       // Probe at 3 arbitrary points
       float z_at_pt_1 = probe_pt( ABL_PROBE_PT_1_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_1_Y + home_offset[Y_AXIS],
-                                  Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS],
+                                  Z_RAISE_BEFORE_PROBING,
                                   p1, verbose_level),
             z_at_pt_2 = probe_pt( ABL_PROBE_PT_2_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_2_Y + home_offset[Y_AXIS],
-                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  Z_RAISE_BETWEEN_PROBINGS,
                                   p2, verbose_level),
             z_at_pt_3 = probe_pt( ABL_PROBE_PT_3_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_3_Y + home_offset[Y_AXIS],
-                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  Z_RAISE_BETWEEN_PROBINGS,
                                   p3, verbose_level);
-      clean_up_after_endstop_move();
+
       if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
 
     #endif // !AUTO_BED_LEVELING_GRID
@@ -3782,23 +3794,23 @@ inline void gcode_G28() {
           #endif
         ;
         // current_position[Z_AXIS] += home_offset[Z_AXIS]; // The Z probe determines Z=0, not "Z home"
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> corrected Z in G29", current_position);
         #endif
       }
+
     #endif // !DELTA
 
-    #if DISABLED(Z_PROBE_ALLEN_KEY) && DISABLED(Z_PROBE_SLED) && !HAS_Z_SERVO_ENDSTOP
-      raise_z_after_probing();
-    #endif
+    // Final raise of Z axis after probing.
+    raise_z_after_probing();
 
-    #if ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(MECHANICAL_PROBE)
-      stow_z_probe();
-    #else
-      endstops.enable_z_probe(false);
-    #endif
+    // Stow the probe. Servo will raise if needed.
+    stow_z_probe();
+
+    // Restore state after probing
+    clean_up_after_endstop_or_probe_move();
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3833,26 +3845,26 @@ inline void gcode_G28() {
    */
   inline void gcode_G30() {
 
-    setup_for_endstop_move();
+    setup_for_endstop_or_probe_move();
 
     deploy_z_probe();
 
     stepper.synchronize();
 
     // TODO: clear the leveling matrix or the planner will be set incorrectly
-    run_z_probe(); // clears the ABL non-delta matrix only
+    float measured_z = run_z_probe(); // clears the ABL non-delta matrix only
 
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL(current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER + 0.0001);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL(current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER + 0.0001);
     SERIAL_PROTOCOLPGM(" Z: ");
-    SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);
+    SERIAL_PROTOCOL(measured_z + 0.0001);
     SERIAL_EOL;
 
     stow_z_probe();
 
-    clean_up_after_endstop_move();
+    clean_up_after_endstop_or_probe_move();
 
     report_current_position();
   }
@@ -3882,16 +3894,10 @@ inline void gcode_G92() {
       }
     }
   }
-  if (didXYZ) {
-    #if ENABLED(DELTA) || ENABLED(SCARA)
-      sync_plan_position_delta();
-    #else
-      sync_plan_position();
-    #endif
-  }
-  else if (didE) {
+  if (didXYZ)
+    SYNC_PLAN_POSITION_KINEMATIC();
+  else if (didE)
     sync_plan_position_e();
-  }
 }
 
 #if ENABLED(ULTIPANEL)
@@ -4201,9 +4207,13 @@ inline void gcode_M42() {
     }
 
     float  X_current = current_position[X_AXIS],
-           Y_current = current_position[Y_AXIS],
-           Z_start_location = current_position[Z_AXIS] + Z_RAISE_BEFORE_PROBING;
-    bool deploy_probe_for_each_reading = code_seen('E');
+           Y_current = current_position[Y_AXIS];
+
+    #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+      const bool deploy_probe_for_each_reading = false;
+    #else
+      bool deploy_probe_for_each_reading = code_seen('E');
+    #endif
 
     float X_probe_location = code_seen('X') ? code_value_axis_units(X_AXIS) : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
@@ -4228,7 +4238,7 @@ inline void gcode_M42() {
 
     bool seen_L = code_seen('L');
     uint8_t n_legs = seen_L ? code_value_byte() : 0;
-    if (n_legs < 0 || n_legs > 15) {
+    if (n_legs > 15) {
       SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");
       return;
     }
@@ -4248,34 +4258,35 @@ inline void gcode_M42() {
     #if ENABLED(DELTA)
       // we don't do bed level correction in M48 because we want the raw data when we probe
       reset_bed_level();
-    #else
+    #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
       // we don't do bed level correction in M48 because we want the raw data when we probe
       planner.bed_level_matrix.set_to_identity();
     #endif
 
-    if (Z_start_location < Z_RAISE_BEFORE_PROBING * 2.0)
-      do_blocking_move_to_z(Z_start_location);
+    setup_for_endstop_or_probe_move();
+
+    do_probe_raise(Z_RAISE_BEFORE_PROBING);
 
+    feedrate = XY_PROBE_FEEDRATE;
     do_blocking_move_to_xy(X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER), Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER));
 
     /**
      * OK, do the initial probe to get us close to the bed.
      * Then retrace the right amount and use that in subsequent probes
      */
-    setup_for_endstop_move();
 
     // Height before each probe (except the first)
-    float z_between = home_offset[Z_AXIS] + (deploy_probe_for_each_reading ? Z_RAISE_BEFORE_PROBING : Z_RAISE_BETWEEN_PROBINGS);
+    float z_between = deploy_probe_for_each_reading ? Z_RAISE_BEFORE_PROBING : Z_RAISE_BETWEEN_PROBINGS;
 
     // Deploy the probe and probe the first point
     probe_pt(X_probe_location, Y_probe_location,
-      home_offset[Z_AXIS] + Z_RAISE_BEFORE_PROBING,
+      Z_RAISE_BEFORE_PROBING,
       deploy_probe_for_each_reading ? ProbeDeployAndStow : ProbeDeploy,
       verbose_level);
 
     randomSeed(millis());
 
-    double mean, sigma, sample_set[n_samples];
+    double mean = 0, sigma = 0, sample_set[n_samples];
     for (uint8_t n = 0; n < n_samples; n++) {
       if (n_legs) {
         int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
@@ -4399,8 +4410,10 @@ inline void gcode_M42() {
 
       // Raise before the next loop for the legs,
       // or do the final raise after the last probe
-      if (n_legs || last_probe) {
-        do_blocking_move_to_z(last_probe ? home_offset[Z_AXIS] + Z_RAISE_AFTER_PROBING : z_between);
+      if (last_probe)
+        do_probe_raise(Z_RAISE_AFTER_PROBING);
+      else if (n_legs) {
+        do_probe_raise(z_between);
         if (!last_probe) delay(500);
       }
 
@@ -4416,7 +4429,7 @@ inline void gcode_M42() {
     SERIAL_PROTOCOL_F(sigma, 6);
     SERIAL_EOL; SERIAL_EOL;
 
-    clean_up_after_endstop_move();
+    clean_up_after_endstop_or_probe_move();
 
     report_current_position();
   }
@@ -5383,7 +5396,7 @@ inline void gcode_M206() {
     if (code_seen('P')) set_home_offset(Y_AXIS, code_value_axis_units(Y_AXIS)); // Psi
   #endif
 
-  sync_plan_position();
+  SYNC_PLAN_POSITION_KINEMATIC();
   report_current_position();
 }
 
@@ -5456,12 +5469,12 @@ inline void gcode_M206() {
    *
    *   S[+mm]    retract_length
    *   W[+mm]    retract_length_swap (multi-extruder)
-   *   F[mm/min] retract_feedrate
+   *   F[mm/min] retract_feedrate_mm_s
    *   Z[mm]     retract_zlift
    */
   inline void gcode_M207() {
     if (code_seen('S')) retract_length = code_value_axis_units(E_AXIS);
-    if (code_seen('F')) retract_feedrate = code_value_axis_units(E_AXIS) / 60;
+    if (code_seen('F')) retract_feedrate_mm_s = code_value_axis_units(E_AXIS) / 60;
     if (code_seen('Z')) retract_zlift = code_value_axis_units(Z_AXIS);
     #if EXTRUDERS > 1
       if (code_seen('W')) retract_length_swap = code_value_axis_units(E_AXIS);
@@ -5949,7 +5962,7 @@ inline void gcode_M303() {
  */
 inline void gcode_M400() { stepper.synchronize(); }
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_ALLEN_KEY))
+#if HAS_BED_PROBE
 
   /**
    * M401: Engage Z Servo endstop if available
@@ -5965,7 +5978,7 @@ inline void gcode_M400() { stepper.synchronize(); }
     stow_z_probe();
   }
 
-#endif // AUTO_BED_LEVELING_FEATURE && (HAS_Z_SERVO_ENDSTOP || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+#endif // HAS_BED_PROBE
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
@@ -6134,11 +6147,7 @@ inline void gcode_M428() {
   }
 
   if (!err) {
-    #if ENABLED(DELTA) || ENABLED(SCARA)
-      sync_plan_position_delta();
-    #else
-      sync_plan_position();
-    #endif
+    SYNC_PLAN_POSITION_KINEMATIC();
     report_current_position();
     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
     #if HAS_BUZZER
@@ -6556,15 +6565,8 @@ inline void gcode_T(uint8_t tmp_extruder) {
       float next_feedrate = code_value_axis_units(X_AXIS);
       if (next_feedrate > 0.0) stored_feedrate = feedrate = next_feedrate;
     }
-    else {
-      feedrate =
-        #ifdef XY_PROBE_SPEED
-          XY_PROBE_SPEED
-        #else
-          min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]) * 60
-        #endif
-      ;
-    }
+    else
+      feedrate = XY_PROBE_FEEDRATE;
 
     if (tmp_extruder != active_extruder) {
       bool no_move = code_seen('S') && code_value_bool();
@@ -6704,11 +6706,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
       #endif // !DUAL_X_CARRIAGE
 
       // Tell the planner the new "current position"
-      #if ENABLED(DELTA)
-        sync_plan_position_delta();
-      #else
-        sync_plan_position();
-      #endif
+      SYNC_PLAN_POSITION_KINEMATIC();
 
       // Move to the "old position" (move the extruder into place)
       if (!no_move && IsRunning()) prepare_move_to_destination();
@@ -7262,14 +7260,14 @@ void process_next_command() {
         gcode_M400();
         break;
 
-      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)
+      #if HAS_BED_PROBE
         case 401:
           gcode_M401();
           break;
         case 402:
           gcode_M402();
           break;
-      #endif // AUTO_BED_LEVELING_FEATURE && (HAS_Z_SERVO_ENDSTOP || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+      #endif // HAS_BED_PROBE
 
       #if ENABLED(FILAMENT_WIDTH_SENSOR)
         case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
@@ -7657,7 +7655,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
         planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         planner.buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
                          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[X_AXIS], 1);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         stepper.synchronize();
         extruder_duplication_enabled = true;
         active_extruder_parked = false;
@@ -7677,7 +7675,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
         delayed_move_time = 0;
         // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
         planner.buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[Z_AXIS], active_extruder);
-        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]), active_extruder);
+        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], PLANNER_XY_FEEDRATE(), active_extruder);
         planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[Z_AXIS], active_extruder);
         active_extruder_parked = false;
       }

